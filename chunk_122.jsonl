{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a value to a datetime object.", "response": "def convert_datetime(value, parameter):\n    '''\n    Converts to datetime.datetime:\n        '', '-', None convert to parameter default\n        The first matching format in settings.DATETIME_INPUT_FORMATS converts to datetime\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if value is None or isinstance(value, datetime.datetime):\n        return value\n    for fmt in settings.DATETIME_INPUT_FORMATS:\n        try:\n            return datetime.datetime.strptime(value, fmt)\n        except (ValueError, TypeError):\n            continue\n    raise ValueError(\"`{}` does not match a format in settings.DATETIME_INPUT_FORMATS\".format(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_date(value, parameter):\n    '''\n    Converts to datetime.date:\n        '', '-', None convert to parameter default\n        The first matching format in settings.DATE_INPUT_FORMATS converts to datetime\n    '''\n    value = _check_default(value, parameter, ( '', '-', None ))\n    if value is None or isinstance(value, datetime.date):\n        return value\n    for fmt in settings.DATE_INPUT_FORMATS:\n        try:\n            return datetime.datetime.strptime(value, fmt).date()\n        except (ValueError, TypeError):\n            continue\n    raise ValueError(\"`{}` does not match a format in settings.DATE_INPUT_FORMATS\".format(value))", "response": "Converts a value to a datetime. date object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_id_to_model(value, parameter):\n    '''\n    Converts to a Model object.\n        '', '-', '0', None convert to parameter default\n        Anything else is assumed an object id and sent to `.get(id=value)`.\n    '''\n    value = _check_default(value, parameter, ( '', '-', '0', None ))\n    if isinstance(value, (int, str)):  # only convert if we have the id\n        try:\n            return parameter.type.objects.get(id=value)\n        except (MultipleObjectsReturned, ObjectDoesNotExist) as e:\n            raise ValueError(str(e))\n    return value", "response": "Converts an id to a Model object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_default(value, parameter, default_chars):\n    '''Returns the default if the value is \"empty\"'''\n    # not using a set here because it fails when value is unhashable\n    if value in default_chars:\n        if parameter.default is inspect.Parameter.empty:\n            raise ValueError('Value was empty, but no default value is given in view function for parameter: {} ({})'.format(parameter.position, parameter.name))\n        return parameter.default\n    return value", "response": "Checks if the value is empty and returns the default if it is empty"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef protocol(handler, cfg):\n    # Stages\n    if 'stages' not in cfg:\n        raise ValueError('Protocol must include stages of simulation')\n\n    pos, vel, box = handler.positions, handler.velocities, handler.box\n    stages = cfg.pop('stages')\n    for stage_options in stages:\n        options = DEFAULT_OPTIONS.copy()\n        options.update(cfg)\n        stage_system_options = prepare_system_options(stage_options)\n        options.update(stage_options)\n        options['system_options'].update(stage_system_options)\n        stage = Stage(handler, positions=pos, velocities=vel, box=box,\n                      total_stages=len(stages), **options)\n        pos, vel, box = stage.run()\n        del stage", "response": "Run all the stages in protocol\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        if self.verbose:\n            status = '#{}'.format(self.stage_index)\n            if self.total_stages is not None:\n                status += '/{}'.format(self.total_stages)\n            status += ': {}'.format(self.name)\n            pieces = []\n            if self.restrained_atoms is not None:\n                pieces.append('restrained {}'.format(self.restrained_atoms))\n            if self.constrained_atoms is not None:\n                pieces.append('constrained {}'.format(self.constrained_atoms))\n            if self.distance_restrained_atoms is not None:\n                pieces.append('distance restrained for {} atom pairs'.format(len(self.distance_restrained_atoms)))\n            if pieces:\n                status += ' [{}]'.format(', '.join(pieces))\n            logger.info(status)\n\n        # Add forces\n        self.apply_restraints()\n        self.apply_constraints()\n\n        if self.barostat:\n            self.apply_barostat()\n\n        if self.minimization:\n            if self.verbose:\n                logger.info('  Minimizing...')\n            self.minimize()\n\n        uses_pbc = self.system.usesPeriodicBoundaryConditions()\n        if self.steps:\n            # Stdout progress\n            if self.report and self.progress_reporter not in self.simulation.reporters:\n                self.simulation.reporters.append(self.progress_reporter)\n\n            # Log report\n            if self.report and self.log_reporter not in self.simulation.reporters:\n                self.simulation.reporters.append(self.log_reporter)\n\n            # Trajectory / movie files\n            if self.trajectory and self.trajectory_reporter not in self.simulation.reporters:\n                self.simulation.reporters.append(self.trajectory_reporter)\n\n            # Checkpoint or restart files\n            if self.restart and self.restart_reporter not in self.simulation.reporters:\n                self.simulation.reporters.append(self.restart_reporter)\n\n            # MD simulation\n            if self.verbose:\n                pbc = 'PBC ' if uses_pbc else ''\n                conditions = 'NPT' if self.barostat else 'NVT'\n                logger.info('  Running {}MD for {} steps @ {}K, {}'.format(pbc, self.steps,\n                                                                     self.temperature,\n                                                                     conditions))\n\n            with self.handle_exceptions():\n                self.simulate()\n\n        if self.save_state_at_end:\n            path = self.new_filename(suffix='.state')\n            self.simulation.saveState(path)\n\n        # Save and return state\n        state = self.simulation.context.getState(getPositions=True, getVelocities=True,\n                                                 enforcePeriodicBox=uses_pbc)\n\n        return state.getPositions(), state.getVelocities(), state.getPeriodicBoxVectors()", "response": "Runs the MD simulation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nminimize energy of the system until meeting tolerance or max_iterations.", "response": "def minimize(self, tolerance=None, max_iterations=None):\n        \"\"\"\n        Minimize energy of the system until meeting `tolerance` or\n        performing `max_iterations`.\n        \"\"\"\n        if tolerance is None:\n            tolerance = self.minimization_tolerance\n        if max_iterations is None:\n            max_iterations = self.minimization_max_iterations\n        self.simulation.minimizeEnergy(tolerance * u.kilojoules_per_mole, max_iterations)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadvance simulation n steps", "response": "def simulate(self, steps=None):\n        \"\"\"\n        Advance simulation n steps\n        \"\"\"\n        if steps is None:\n            steps = self.steps\n        self.simulation.step(steps)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a custom force that restrains atoms to fix their positions while allowing severe clashes and so on.", "response": "def restraint_force(self, indices=None, strength=5.0):\n        \"\"\"\n        Force that restrains atoms to fix their positions, while allowing\n        tiny movement to resolve severe clashes and so on.\n\n        Returns\n        -------\n        force : simtk.openmm.CustomExternalForce\n            A custom force to restrain the selected atoms\n        \"\"\"\n        if self.system.usesPeriodicBoundaryConditions():\n            expression = 'k*periodicdistance(x, y, z, x0, y0, z0)^2'\n        else:\n            expression = 'k*((x-x0)^2 + (y-y0)^2 + (z-z0)^2)'\n        force = mm.CustomExternalForce(expression)\n        force.addGlobalParameter('k', strength*u.kilocalories_per_mole/u.angstroms**2)\n        force.addPerParticleParameter('x0')\n        force.addPerParticleParameter('y0')\n        force.addPerParticleParameter('z0')\n        positions = self.positions if self.positions is not None else self.handler.positions\n        if indices is None:\n            indices = range(self.handler.topology.getNumAtoms())\n        for i, index in enumerate(indices):\n            force.addParticle(i, positions[index].value_in_unit(u.nanometers))\n        return force"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a force for a set of atoms and distances.", "response": "def distance_restraint_force(self, atoms, distances, strengths):\n        \"\"\"\n        Parameters\n        ----------\n        atoms : tuple of tuple of int or str\n            Pair of atom indices to be restrained, with shape (n, 2),\n            like ((a1, a2), (a3, a4)). Items can be str compatible with MDTraj DSL.\n        distances : tuple of float\n            Equilibrium distances for each pair\n        strengths : tuple of float\n            Force constant for each pair\n        \"\"\"\n        system = self.system\n        force = mm.HarmonicBondForce()\n        force.setUsesPeriodicBoundaryConditions(self.system.usesPeriodicBoundaryConditions())\n        for pair, distance, strength in zip(atoms, distances, strengths):\n            indices = []\n            for atom in pair:\n                if isinstance(atom, str):\n                    index = self.subset(atom)\n                    if len(index) != 1:\n                        raise ValueError('Distance restraint for selection `{}` returns != 1 atom!: {}'\n                                         .format(atom, index))\n                    indices.append(int(index[0]))\n                elif isinstance(atom, (int, float)):\n                    indices.append(int(atom))\n                else:\n                    raise ValueError('Distance restraint atoms must be int or str DSL selections')\n            if distance == 'current':\n                pos = self.positions or system.positions\n                distance = np.linalg.norm(pos[indices[0]] - pos[indices[1]])\n\n            force.addBond(indices[0], indices[1], distance*u.nanometers,\n                          strength*u.kilocalories_per_mole/u.angstroms**2)\n        return force"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subset(self, selector):\n        if isinstance(selector, (list, tuple)):\n            return map(int, selector)\n        selector = SELECTORS.get(selector, selector)\n        mdtop = MDTrajTopology.from_openmm(self.handler.topology)\n        return mdtop.select(selector)", "response": "Returns a list of atom indices corresponding to a MDTraj DSL\n        query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_exceptions(self, verbose=True):\n        try:\n            yield\n        except (KeyboardInterrupt, Exception) as ex:\n            if not self.attempt_rescue:\n                raise ex\n            if isinstance(ex, KeyboardInterrupt):\n                reraise = False\n                answer = timed_input('\\n\\nDo you want to save current state? (y/N): ')\n                if answer and answer.lower() not in ('y', 'yes'):\n                    if verbose:\n                        sys.exit('Ok, bye!')\n            else:\n                reraise = True\n                logger.error('\\n\\nAn error occurred: %s', ex)\n            if verbose:\n                logger.info('Saving state...')\n            try:\n                self.backup_simulation()\n            except Exception:\n                if verbose:\n                    logger.error('FAILED :(')\n            else:\n                if verbose:\n                    logger.info('SUCCESS!')\n            finally:\n                if reraise:\n                    raise ex\n                sys.exit()", "response": "Handle exceptions and attempt to save the current state of the simulation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef backup_simulation(self):\n        path = self.new_filename(suffix='_emergency.state')\n        self.simulation.saveState(path)\n        uses_pbc = self.system.usesPeriodicBoundaryConditions()\n        state_kw = dict(getPositions=True, getVelocities=True,\n                        getForces=True, enforcePeriodicBox=uses_pbc,\n                        getParameters=True, getEnergy=True)\n        state = self.simulation.context.getState(**state_kw)\n        for reporter in self.simulation.reporters:\n            if not isinstance(reporter, app.StateDataReporter):\n                reporter.report(self.simulation, state)", "response": "Creates an emergency report run and saves the state of the simulation context to disk."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting parse and prepare input file.", "response": "def prepare_input(argv=None):\n    \"\"\"\n    Get, parse and prepare input file.\n    \"\"\"\n    p = ArgumentParser(description='InsiliChem Ommprotocol: '\n                       'easy to deploy MD protocols for OpenMM')\n    p.add_argument('input', metavar='INPUT FILE', type=extant_file,\n                   help='YAML input file')\n    p.add_argument('--version', action='version', version='%(prog)s v{}'.format(__version__))\n    p.add_argument('-c', '--check', action='store_true',\n                   help='Validate input file only')\n    args = p.parse_args(argv if argv else sys.argv[1:])\n\n    jinja_env = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)\n    # Load config file\n    with open(args.input) as f:\n        rendered = jinja_env.from_string(f.read()).render()\n        cfg = yaml.load(rendered, Loader=YamlLoader)\n    # Paths and dirs\n    from .md import SYSTEM_OPTIONS\n    cfg['_path'] = os.path.abspath(args.input)\n    cfg['system_options'] = prepare_system_options(cfg, defaults=SYSTEM_OPTIONS)\n    cfg['outputpath'] = sanitize_path_for_file(cfg.get('outputpath', '.'), args.input)\n\n    if not args.check:\n        with ignored_exceptions(OSError):\n            os.makedirs(cfg['outputpath'])\n\n    handler = prepare_handler(cfg)\n\n    return handler, cfg, args"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading all files into single object.", "response": "def prepare_handler(cfg):\n    \"\"\"\n    Load all files into single object.\n    \"\"\"\n    positions, velocities, box = None, None, None\n    _path = cfg.get('_path', './')\n    forcefield = cfg.pop('forcefield', None)\n    topology_args = sanitize_args_for_file(cfg.pop('topology'), _path)\n\n    if 'checkpoint' in cfg:\n        restart_args = sanitize_args_for_file(cfg.pop('checkpoint'), _path)\n        restart = Restart.load(*restart_args)\n        positions = restart.positions\n        velocities = restart.velocities\n        box = restart.box\n\n    if 'positions' in cfg:\n        positions_args = sanitize_args_for_file(cfg.pop('positions'), _path)\n        positions = Positions.load(*positions_args)\n        box = BoxVectors.load(*positions_args)\n\n    if 'velocities' in cfg:\n        velocities_args = sanitize_args_for_file(cfg.pop('velocities'), _path)\n        velocities = Velocities.load(*velocities_args)\n\n    if 'box' in cfg:\n        box_args = sanitize_args_for_file(cfg.pop('box'), _path)\n        box = BoxVectors.load(*box_args)\n\n    options = {}\n    for key in 'positions velocities box forcefield'.split():\n        value = locals()[key]\n        if value is not None:\n            options[key] = value\n\n    return SystemHandler.load(*topology_args, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_system_options(cfg, defaults=None):\n    d = {} if defaults is None else defaults.copy()\n    if 'nonbondedMethod' in cfg:\n        d['nonbondedMethod'] = warned_getattr(openmm_app, cfg.pop('nonbondedMethod'), None)\n    if 'nonbondedCutoff' in cfg:\n        d['nonbondedCutoff'] = cfg.pop('nonbondedCutoff') * u.nanometers\n    if 'constraints' in cfg:\n        d['constraints'] = warned_getattr(openmm_app, cfg.pop('constraints'), None)\n    for key in ['rigidWater', 'ewaldErrorTolerance']:\n        if key in cfg:\n            d[key] = cfg.pop(key)\n    if 'extra_system_options' in cfg:\n        if 'implicitSolvent' in cfg['extra_system_options']:\n            implicit_solvent = warned_getattr(\n                openmm_app, cfg['extra_system_options']['implicitSolvent'], None)\n            cfg['extra_system_options']['implicitSolvent'] = implicit_solvent\n        d.update(cfg.pop('extra_system_options'))\n    return d", "response": "Retrieve and delete system options from input configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_forcefield(*forcefields):\n    for forcefield in forcefields:\n        if forcefield.endswith('.frcmod'):\n            gaffmol2 = os.path.splitext(forcefield)[0] + '.gaff.mol2'\n            yield create_ffxml_file([gaffmol2], [forcefield])\n        else:\n            yield forcefield", "response": "Yields a list of filenames if they are frcmods."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef statexml2pdb(topology, state, output=None):\n    state = Restart.from_xml(state)\n    system = SystemHandler.load(topology, positions=state.positions)\n    if output is None:\n        output = topology + '.pdb'\n    system.write_pdb(output)", "response": "Given an OpenMM xml file containing the state of the simulation generate a PDB snapshot for easy visualization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract a single frame structure from a trajectory.", "response": "def export_frame_coordinates(topology, trajectory, nframe, output=None):\n    \"\"\"\n    Extract a single frame structure from a trajectory.\n    \"\"\"\n    if output is None:\n        basename, ext = os.path.splitext(trajectory)\n        output = '{}.frame{}.inpcrd'.format(basename, nframe)\n\n    # ParmEd sometimes struggles with certain PRMTOP files\n    if os.path.splitext(topology)[1] in ('.top', '.prmtop'):\n        top = AmberPrmtopFile(topology)\n        mdtop = mdtraj.Topology.from_openmm(top.topology)\n        traj = mdtraj.load_frame(trajectory, int(nframe), top=mdtop)\n        structure = parmed.openmm.load_topology(top.topology, system=top.createSystem())\n        structure.box_vectors = top.topology.getPeriodicBoxVectors()\n\n    else:  # standard protocol (the topology is loaded twice, though)\n        traj = mdtraj.load_frame(trajectory, int(nframe), top=topology)\n        structure = parmed.load_file(topology)\n\n    structure.positions = traj.openmm_positions(0)\n\n    if traj.unitcell_vectors is not None:  # if frame provides box vectors, use those\n        structure.box_vectors = traj.openmm_boxes(0)\n\n    structure.save(output, overwrite=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef construct_include(self, node):\n\n        filename = os.path.join(self._root, self.construct_scalar(node))\n        filename = os.path.abspath(filename)\n        extension = os.path.splitext(filename)[1].lstrip('.')\n\n        with open(filename, 'r') as f:\n            if extension in ('yaml', 'yml'):\n                return yaml.load(f, Loader=self)\n            else:\n                return ''.join(f.readlines())", "response": "Construct include file referenced at node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_pdb(cls, path, forcefield=None, loader=PDBFile, strict=True, **kwargs):\n        pdb = loader(path)\n        box = kwargs.pop('box', pdb.topology.getPeriodicBoxVectors())\n        positions = kwargs.pop('positions', pdb.positions)\n        velocities = kwargs.pop('velocities', getattr(pdb, 'velocities', None))\n\n        if strict and not forcefield:\n            from .md import FORCEFIELDS as forcefield\n            logger.info('! Forcefields for PDB not specified. Using default: %s',\n                        ', '.join(forcefield))\n        pdb.forcefield = ForceField(*list(process_forcefield(*forcefield)))\n\n        return cls(master=pdb.forcefield, topology=pdb.topology, positions=positions,\n                   velocities=velocities, box=box, path=path, **kwargs)", "response": "Loads a SystemHandler from a PDB file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a SystemHandler from an Amber. prmtop file.", "response": "def from_amber(cls, path, positions=None, strict=True, **kwargs):\n        \"\"\"\n        Loads Amber Parm7 parameters and topology file\n\n        Parameters\n        ----------\n        path : str\n            Path to *.prmtop or *.top file\n        positions : simtk.unit.Quantity\n            Atomic positions\n\n        Returns\n        -------\n        prmtop : SystemHandler\n            SystemHandler with topology\n        \"\"\"\n        if strict and positions is None:\n            raise ValueError('Amber TOP/PRMTOP files require initial positions.')\n        prmtop = AmberPrmtopFile(path)\n        box = kwargs.pop('box', prmtop.topology.getPeriodicBoxVectors())\n        return cls(master=prmtop, topology=prmtop.topology, positions=positions, box=box,\n                   path=path, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_charmm(cls, path, positions=None, forcefield=None, strict=True, **kwargs):\n        psf = CharmmPsfFile(path)\n        if strict and forcefield is None:\n            raise ValueError('PSF files require key `forcefield`.')\n        if strict and positions is None:\n            raise ValueError('PSF files require key `positions`.')\n        psf.parmset = CharmmParameterSet(*forcefield)\n        psf.loadParameters(psf.parmset)\n        return cls(master=psf, topology=psf.topology, positions=positions, path=path,\n                   **kwargs)", "response": "Loads a SystemHandler from a Charmm structure file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a topology from a Desmond DMS file located at path.", "response": "def from_desmond(cls, path, **kwargs):\n        \"\"\"\n        Loads a topology from a Desmond DMS file located at `path`.\n\n        Arguments\n        ---------\n        path : str\n            Path to a Desmond DMS file\n        \"\"\"\n        dms = DesmondDMSFile(path)\n        pos = kwargs.pop('positions', dms.getPositions())\n        return cls(master=dms, topology=dms.getTopology(), positions=pos, path=path,\n                   **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_gromacs(cls, path, positions=None, forcefield=None, strict=True, **kwargs):\n        if strict and positions is None:\n            raise ValueError('Gromacs TOP files require initial positions.')\n        box = kwargs.pop('box', None)\n        top = GromacsTopFile(path, includeDir=forcefield, periodicBoxVectors=box)\n        return cls(master=top, topology=top.topology, positions=positions, box=box,\n                   path=path, **kwargs)", "response": "Loads a topology from a Gromacs TOP file located at path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_parmed(cls, path, *args, **kwargs):\n        st = parmed.load_file(path, structure=True, *args, **kwargs)\n        box = kwargs.pop('box', getattr(st, 'box', None))\n        velocities = kwargs.pop('velocities', getattr(st, 'velocities', None))\n        positions = kwargs.pop('positions', getattr(st, 'positions', None))\n        return cls(master=st, topology=st.topology, positions=positions, box=box,\n                   velocities=velocities, path=path, **kwargs)", "response": "Load a new object from a ParmEd file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading pickled topology. Careful with Python versions though!", "response": "def _pickle_load(path):\n        \"\"\"\n        Loads pickled topology. Careful with Python versions though!\n        \"\"\"\n        _, ext = os.path.splitext(path)\n        topology = None\n        if sys.version_info.major == 2:\n            if ext == '.pickle2':\n                with open(path, 'rb') as f:\n                    topology = pickle.load(f)\n            elif ext in ('.pickle3', '.pickle'):\n                with open(path, 'rb') as f:\n                    topology = pickle.load(f, protocol=3)\n        elif sys.version_info.major == 3:\n            if ext == '.pickle2':\n                with open(path, 'rb') as f:\n                    topology = pickle.load(f)\n            elif ext in ('.pickle3', '.pickle'):\n                with open(path, 'rb') as f:\n                    topology = pickle.load(f)\n        if topology is None:\n            raise ValueError('File {} is not compatible with this version'.format(path))\n        return topology"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate an OpenMM system for every supported topology file with given system options.", "response": "def create_system(self, **system_options):\n        \"\"\"\n        Create an OpenMM system for every supported topology file with given system options\n        \"\"\"\n        if self.master is None:\n            raise ValueError('Handler {} is not able to create systems.'.format(self))\n\n        if isinstance(self.master, ForceField):\n            system = self.master.createSystem(self.topology, **system_options)\n        elif isinstance(self.master, (AmberPrmtopFile, GromacsTopFile, DesmondDMSFile)):\n            system = self.master.createSystem(**system_options)\n        elif isinstance(self.master, CharmmPsfFile):\n            if not hasattr(self.master, 'parmset'):\n                raise ValueError('PSF topology files require Charmm parameters.')\n            system = self.master.createSystem(self.master.parmset, **system_options)\n        else:\n            raise NotImplementedError('Handler {} is not able to create systems.'.format(self))\n\n        if self.has_box:\n            system.setDefaultPeriodicBoxVectors(*self.box)\n        return system"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noutputting a PDB file with the current contents of the system.", "response": "def write_pdb(self, path):\n        \"\"\"\n        Outputs a PDB file with the current contents of the system\n        \"\"\"\n        if self.master is None and self.positions is None:\n            raise ValueError('Topology and positions are needed to write output files.')\n        with open(path, 'w') as f:\n            PDBFile.writeFile(self.topology, self.positions, f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_xsc(cls, path):\n\n        def parse(path):\n            \"\"\"\n            Open and parses an XSC file into its fields\n\n            Parameters\n            ----------\n            path : str\n                Path to XSC file\n\n            Returns\n            -------\n            namedxsc : namedtuple\n                A namedtuple with XSC fields as names\n            \"\"\"\n            with open(path) as f:\n                lines = f.readlines()\n            NamedXsc = namedtuple('NamedXsc', lines[1].split()[1:])\n            return NamedXsc(*map(float, lines[2].split()))\n\n        xsc = parse(path)\n        return u.Quantity([[xsc.a_x, xsc.a_y, xsc.a_z],\n                           [xsc.b_x, xsc.b_y, xsc.b_z],\n                           [xsc.c_x, xsc.c_y, xsc.c_z]], unit=u.angstroms)", "response": "Returns u. Quantity with box vectors from XSC file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_csv(cls, path):\n        with open(path) as f:\n            fields = map(float, next(f).split(','))\n        if len(fields) == 3:\n            return u.Quantity([[fields[0], 0, 0],\n                               [0, fields[1], 0],\n                               [0, 0, fields[2]]], unit=u.nanometers)\n        elif len(fields) == 9:\n            return u.Quantity([fields[0:3],\n                               fields[3:6],\n                               fields[6:9]], unit=u.nanometers)\n        else:\n            raise ValueError('This type of CSV is not supported. Please '\n                             'provide a comma-separated list of three or nine '\n                             'floats in a single-line file.')", "response": "Returns a new instance of the class u. Quantity object from a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describeNextReport(self, simulation):\n        steps = self.interval - simulation.currentStep % self.interval\n        return steps, False, False, False, False", "response": "Get information about the next report for this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef report(self, simulation, state):\n        if not self._initialized:\n            self._initial_clock_time = datetime.now()\n            self._initial_simulation_time = state.getTime()\n            self._initial_steps = simulation.currentStep\n            self._initialized = True\n\n        steps = simulation.currentStep\n        time = datetime.now() - self._initial_clock_time\n        days = time.total_seconds()/86400.0\n        ns = (state.getTime()-self._initial_simulation_time).value_in_unit(u.nanosecond)\n\n        margin = ' ' * self.margin\n        ns_day = ns/days\n        delta = ((self.total_steps-steps)*time.total_seconds())/steps\n        # remove microseconds to have cleaner output\n        remaining = timedelta(seconds=int(delta))\n        percentage = 100.0*steps/self.total_steps\n        if ns_day:\n            template = '{}{}/{} steps ({:.1f}%) - {} left @ {:.1f} ns/day                    \\r'\n        else:\n            template = '{}{}/{} steps ({:.1f}%)                                              \\r'\n        report = template.format(margin, steps, self.total_steps, percentage, remaining, ns_day)\n        self._out.write(report)\n        if hasattr(self._out, 'flush'):\n            self._out.flush()", "response": "Generate a report.\n\n        Parameters\n        ----------\n        simulation : Simulation\n            The Simulation to generate a report for\n        state : State\n            The current state of the simulation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report(self, simulation, state):\n        if not self._initialized:\n            self._initialized = True\n\n        self._steps[0] += self.interval\n        positions = state.getPositions()\n\n        # Serialize\n        self._out.write(b''.join([b'\\nSTARTOFCHUNK\\n',\n                                  pickle.dumps([self._steps[0], positions._value]),\n                                  b'\\nENDOFCHUNK\\n']))\n        if hasattr(self._out, 'flush'):\n            self._out.flush()", "response": "Generate a report.\n\n        Parameters\n        ----------\n        simulation : Simulation\n            The Simulation to generate a report for\n        state : State\n            The current state of the simulation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assert_not_exists(path, sep='.'):\n    name, ext = os.path.splitext(path)\n    i = 1\n    while os.path.exists(path):\n        path = '{}{}{}{}'.format(name, sep, i, ext)\n        i += 1\n    return path", "response": "Checks if a file does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure object obj is of type types. Else raise TypeError.", "response": "def assertinstance(obj, types):\n    \"\"\"\n    Make sure object `obj` is of type `types`. Else, raise TypeError.\n    \"\"\"\n    if isinstance(obj, types):\n        return obj\n    raise TypeError('{} must be instance of {}'.format(obj, types))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extant_file(path):\n    if not os.path.exists(path):\n        raise argparse.ArgumentTypeError(\"{} does not exist\".format(path))\n    return path", "response": "Check if file exists with argparse. ArgumentParser"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsort files taking into account potentially absent suffixes like 2000. 1000. 2000.", "response": "def sort_key_for_numeric_suffixes(path, sep='.', suffix_index=-2):\n    \"\"\"\n    Sort files taking into account potentially absent suffixes like\n        somefile.dcd\n        somefile.1000.dcd\n        somefile.2000.dcd\n\n    To be used with sorted(..., key=callable).\n    \"\"\"\n    chunks = path.split(sep)\n    # Remove suffix from path and convert to int\n    if chunks[suffix_index].isdigit():\n        return sep.join(chunks[:suffix_index] + chunks[suffix_index+1:]), int(chunks[suffix_index])\n    return path, 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json_response(f, *args, **kwargs):\n    try:\n        result = f(*args, **kwargs)\n        if isinstance(result, AJAXError):\n            raise result\n    except AJAXError as e:\n        result = e.get_response()\n\n        request = args[0]\n        logger.warn('AJAXError: %d %s - %s', e.code, request.path, e.msg,\n            exc_info=True,\n            extra={\n                'status_code': e.code,\n                'request': request\n            }\n        )\n    except Http404 as e:\n        result = AJAXError(404, e.__str__()).get_response()\n    except Exception as e:\n        import sys\n        exc_info = sys.exc_info()\n        type, message, trace = exc_info\n        if settings.DEBUG:\n            import traceback\n            tb = [{'file': l[0], 'line': l[1], 'in': l[2], 'code': l[3]} for\n                l in traceback.extract_tb(trace)]\n            result = AJAXError(500, message, traceback=tb).get_response()\n        else:\n            result = AJAXError(500, \"Internal server error.\").get_response()\n\n        request = args[0]\n        logger.error('Internal Server Error: %s' % request.path,\n            exc_info=exc_info,\n            extra={\n                'status_code': 500,\n                'request': request\n            }\n        )\n\n    result['Content-Type'] = 'application/json'\n    return result", "response": "A decorator that wraps a view in JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_by_path(dotted_path, error_prefix=''):\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError:\n        raise ImproperlyConfigured(\"%s%s doesn't look like a module path\" % (\n            error_prefix, dotted_path))\n    try:\n        module = import_module(module_path)\n    except ImportError as e:\n        raise ImproperlyConfigured('%sError importing module %s: \"%s\"' % (\n            error_prefix, module_path, e))\n    try:\n        attr = getattr(module, class_name)\n    except AttributeError:\n        raise ImproperlyConfigured(\n            '%sModule \"%s\" does not define a \"%s\" attribute/class' % (\n                error_prefix, module_path, class_name\n            )\n        )\n    return attr", "response": "Imports a dotted module path and returns the attribute or class designated by the last name in the path. Raise ImproperlyConfigured if something goes wrong."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading an AJAX endpoint. This will load either an ad-hoc endpoint or it will load up a model endpoint depending on what it finds. It first attempts to load ``model`` as if it were an ad-hoc endpoint. Alternatively, it will attempt to see if there is a ``ModelEndpoint`` for the given ``model``.", "response": "def endpoint_loader(request, application, model, **kwargs):\n    \"\"\"Load an AJAX endpoint.\n\n    This will load either an ad-hoc endpoint or it will load up a model\n    endpoint depending on what it finds. It first attempts to load ``model``\n    as if it were an ad-hoc endpoint. Alternatively, it will attempt to see if\n    there is a ``ModelEndpoint`` for the given ``model``.\n    \"\"\"\n    if request.method != \"POST\":\n        raise AJAXError(400, _('Invalid HTTP method used.'))\n\n    try:\n        module = import_module('%s.endpoints' % application)\n    except ImportError as e:\n        if settings.DEBUG:\n            raise e\n        else:\n            raise AJAXError(404, _('AJAX endpoint does not exist.'))\n\n    if hasattr(module, model):\n        # This is an ad-hoc endpoint\n        endpoint = getattr(module, model)\n    else:\n        # This is a model endpoint\n        method = kwargs.get('method', 'create').lower()\n        try:\n            del kwargs['method']\n        except:\n            pass\n\n        try:\n            model_endpoint = ajax.endpoint.load(model, application, method,\n                **kwargs)\n            if not model_endpoint.authenticate(request, application, method):\n                raise AJAXError(403, _('User is not authorized.'))\n\n            endpoint = getattr(model_endpoint, method, False)\n\n            if not endpoint:\n                raise AJAXError(404, _('Invalid method.'))\n        except NotRegistered:\n            raise AJAXError(500, _('Invalid model.'))\n\n    data = endpoint(request)\n    if isinstance(data, HttpResponse):\n        return data\n\n    if isinstance(data, EnvelopedResponse):\n        envelope = data.metadata\n        payload = data.data\n    else:\n        envelope = {}\n        payload = data\n\n    envelope.update({\n        'success': True,\n        'data': payload,\n    })\n\n    return HttpResponse(json.dumps(envelope, cls=DjangoJSONEncoder,\n        separators=(',', ':')))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list(self, request):\n\n        max_items_per_page = getattr(self, 'max_per_page',\n                                      getattr(settings, 'AJAX_MAX_PER_PAGE', 100))\n        requested_items_per_page = request.POST.get(\"items_per_page\", 20)\n        items_per_page = min(max_items_per_page, requested_items_per_page)\n        current_page = request.POST.get(\"current_page\", 1)\n\n        if not self.can_list(request.user):\n            raise AJAXError(403, _(\"Access to this endpoint is forbidden\"))\n\n        objects = self.get_queryset(request)\n\n        paginator = Paginator(objects, items_per_page)\n\n        try:\n            page = paginator.page(current_page)\n        except PageNotAnInteger:\n            # If page is not an integer, deliver first page.\n            page = paginator.page(1)\n        except EmptyPage:\n            # If page is out of range (e.g. 9999), return empty list.\n            page = EmptyPageResult()\n\n        data = [encoder.encode(record) for record in page.object_list]\n        return EnvelopedResponse(data=data, metadata={'total': paginator.count})", "response": "List objects of a model."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the data from the POST request.", "response": "def _extract_data(self, request):\n        \"\"\"Extract data from POST.\n\n        Handles extracting a vanilla Python dict of values that are present\n        in the given model. This also handles instances of ``ForeignKey`` and\n        will convert those to the appropriate object instances from the\n        database. In other words, it will see that user is a ``ForeignKey`` to\n        Django's ``User`` class, assume the value is an appropriate pk, and\n        load up that record.\n        \"\"\"\n        data = {}\n        for field, val in six.iteritems(request.POST):\n            if field in self.immutable_fields:\n                continue  # Ignore immutable fields silently.\n\n            if field in self.fields:\n                field_obj = self.model._meta.get_field(field)\n                val = self._extract_value(val)\n                if isinstance(field_obj, models.ForeignKey):\n                    if field_obj.null and not val:\n                        clean_value = None\n                    else:\n                        clean_value = field_obj.rel.to.objects.get(pk=val)\n                else:\n                    clean_value = field_obj.to_python(val)\n                data[smart_str(field)] = clean_value\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_record(self):\n        if not self.pk:\n            raise AJAXError(400, _('Invalid request for record.'))\n\n        try:\n            return self.model.objects.get(pk=self.pk)\n        except self.model.DoesNotExist:\n            raise AJAXError(404, _('%s with id of \"%s\" not found.') % (\n                self.model.__name__, self.pk))", "response": "Fetch a given record from the database along with throwing an anonymization of AJAXError."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef authenticate(self, request, application, method):\n        return self.authentication.is_authenticated(request, application, method)", "response": "Authenticate the AJAX request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all entries of a space.", "response": "def all(self, query=None):\n        \"\"\"\n        Gets all entries of a space.\n        \"\"\"\n\n        if query is None:\n            query = {}\n\n        if self.content_type_id is not None:\n            query['content_type'] = self.content_type_id\n\n        normalize_select(query)\n\n        return super(EntriesProxy, self).all(query=query)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a single entry by ID.", "response": "def find(self, entry_id, query=None):\n        \"\"\"\n        Gets a single entry by ID.\n        \"\"\"\n\n        if query is None:\n            query = {}\n\n        if self.content_type_id is not None:\n            query['content_type'] = self.content_type_id\n\n        normalize_select(query)\n\n        return super(EntriesProxy, self).find(entry_id, query=query)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, resource_id=None, attributes=None, **kwargs):\n\n        if self.content_type_id is not None:\n            if attributes is None:\n                attributes = {}\n            attributes['content_type_id'] = self.content_type_id\n\n        return super(EntriesProxy, self).create(resource_id=resource_id, attributes=attributes)", "response": "Creates an entry with a given ID and attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a webhook with given attributes.", "response": "def create(self, attributes=None, **kwargs):\n        \"\"\"\n        Creates a webhook with given attributes.\n        \"\"\"\n\n        return super(WebhooksProxy, self).create(resource_id=None, attributes=attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef camel_case(snake_str):\n\n    components = snake_str.split('_')\n    # We capitalize the first letter of each component except the first one\n    # with the 'title' method and join them together.\n    return components[0] + \"\".join(x.title() for x in components[1:])", "response": "Return a camel - cased version of a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize_select(query):\n\n    if 'select' not in query:\n        return\n\n    if isinstance(\n            query['select'],\n            str_type()):\n        query['select'] = [s.strip() for s in query['select'].split(',')]\n\n    query['select'] = [s for s\n                       in query['select']\n                       if not s.startswith('sys.')]\n\n    if 'sys' not in query['select']:\n        query['select'].append('sys')", "response": "Normalizes the select operator in the query."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the JSON representation of the environment.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON representation of the environment.\n        \"\"\"\n\n        result = super(Environment, self).to_json()\n        result.update({\n            'name': self.name\n        })\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef content_types(self):\n\n        return EnvironmentContentTypesProxy(self._client, self.space.id, self.id)", "response": "Provides access to content types of an environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef entries(self):\n\n        return EnvironmentEntriesProxy(self._client, self.space.id, self.id)", "response": "Provides access to entry management methods."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding access to asset management methods.", "response": "def assets(self):\n        \"\"\"\n        Provides access to asset management methods.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/assets\n\n        :return: :class:`EnvironmentAssetsProxy <contentful_management.environment_assets_proxy.EnvironmentAssetsProxy>` object.\n        :rtype: contentful.environment_assets_proxy.EnvironmentAssetsProxy\n\n        Usage:\n\n            >>> environment_assets_proxy = environment.assets()\n            <EnvironmentAssetsProxy space_id=\"cfexampleapi\" environment_id=\"master\">\n        \"\"\"\n\n        return EnvironmentAssetsProxy(self._client, self.space.id, self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides access to locale management methods.", "response": "def locales(self):\n        \"\"\"\n        Provides access to locale management methods.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/locales\n\n        :return: :class:`EnvironmentLocalesProxy <contentful_management.environment_locales_proxy.EnvironmentLocalesProxy>` object.\n        :rtype: contentful.environment_locales_proxy.EnvironmentLocalesProxy\n\n        Usage:\n\n            >>> environment_locales_proxy = environment.locales()\n            <EnvironmentLocalesProxy space_id=\"cfexampleapi\" environment_id=\"master\">\n        \"\"\"\n\n        return EnvironmentLocalesProxy(self._client, self.space.id, self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ui_extensions(self):\n\n        return EnvironmentUIExtensionsProxy(self._client, self.space.id, self.id)", "response": "Provides access to UI extensions management methods."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a personal access token.", "response": "def delete(self, token_id, *args, **kwargs):\n        \"\"\"\n        Revokes a personal access token.\n        \"\"\"\n\n        return self.client._put(\n            \"{0}/revoked\".format(\n                self._url(token_id)\n            ),\n            None,\n            *args,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrevoke a personal access token.", "response": "def revoke(self, token_id, *args, **kwargs):\n        \"\"\"\n        Revokes a personal access token.\n        \"\"\"\n\n        return self.delete(token_id, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the base URL for the resource.", "response": "def base_url(klass, space_id='', resource_id=None, environment_id=None, **kwargs):\n        \"\"\"\n        Returns the URI for the resource.\n        \"\"\"\n\n        url = \"spaces/{0}\".format(\n            space_id)\n\n        if environment_id is not None:\n            url = url = \"{0}/environments/{1}\".format(url, environment_id)\n\n        url = \"{0}/{1}\".format(\n            url,\n            base_path_for(klass.__name__)\n        )\n\n        if resource_id:\n            url = \"{0}/{1}\".format(url, resource_id)\n\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_attributes(klass, attributes, previous_object=None):\n\n        result = {}\n\n        if previous_object is not None:\n            result = {k: v for k, v in previous_object.to_json().items() if k != 'sys'}\n\n        result.update(attributes)\n\n        return result", "response": "Create attributes for resource creation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, attributes=None):\n\n        if attributes is None:\n            attributes = {}\n\n        headers = self.__class__.create_headers(attributes)\n        headers.update(self._update_headers())\n\n        result = self._client._put(\n            self._update_url(),\n            self.__class__.create_attributes(attributes, self),\n            headers=headers\n        )\n\n        self._update_from_resource(result)\n\n        return self", "response": "Updates the resource with the attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_link(self):\n\n        link_type = self.link_type if self.type == 'Link' else self.type\n\n        return Link({'sys': {'linkType': link_type, 'id': self.sys.get('id')}}, client=self._client)", "response": "Returns a link for the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the JSON representation of the resource.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON representation of the resource.\n        \"\"\"\n\n        result = {\n            'sys': {}\n        }\n        for k, v in self.sys.items():\n            if k in ['space', 'content_type', 'created_by',\n                     'updated_by', 'published_by']:\n                v = v.to_json()\n            if k in ['created_at', 'updated_at', 'deleted_at',\n                     'first_published_at', 'published_at', 'expires_at']:\n                v = v.isoformat()\n            result['sys'][camel_case(k)] = v\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the attributes for a resource creation.", "response": "def create_attributes(klass, attributes, previous_object=None):\n        \"\"\"\n        Attributes for resource creation.\n        \"\"\"\n\n        if 'fields' not in attributes:\n            if previous_object is None:\n                attributes['fields'] = {}\n            else:\n                attributes['fields'] = previous_object.to_json()['fields']\n        return {'fields': attributes['fields']}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fields_with_locales(self):\n\n        result = {}\n        for locale, fields in self._fields.items():\n            for k, v in fields.items():\n                real_field_id = self._real_field_id_for(k)\n                if real_field_id not in result:\n                    result[real_field_id] = {}\n                result[real_field_id][locale] = self._serialize_value(v)\n        return result", "response": "Get fields with locales per field."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n\n        result = super(FieldsResource, self).to_json()\n        result['fields'] = self.fields_with_locales()\n        return result", "response": "Returns the JSON Representation of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a resource has been updated since last publish.", "response": "def is_updated(self):\n        \"\"\"\n        Checks if a resource has been updated since last publish.\n        Returns False if resource has not been published before.\n        \"\"\"\n\n        if not self.is_published:\n            return False\n\n        return sanitize_date(self.sys['published_at']) < sanitize_date(self.sys['updated_at'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving a link to a specific resource.", "response": "def resolve(self, space_id=None, environment_id=None):\n        \"\"\"\n        Resolves link to a specific resource.\n        \"\"\"\n\n        proxy_method = getattr(\n            self._client,\n            base_path_for(self.link_type)\n        )\n        if self.link_type == 'Space':\n            return proxy_method().find(self.id)\n        elif environment_id is not None:\n            return proxy_method(space_id, environment_id).find(self.id)\n        else:\n            return proxy_method(space_id).find(self.id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a formatted URL for the asset s File with serialized parameters.", "response": "def url(self, **kwargs):\n        \"\"\"\n        Returns a formatted URL for the asset's File\n        with serialized parameters.\n\n        Usage:\n            >>> my_asset.url()\n            \"//images.contentful.com/spaces/foobar/...\"\n            >>> my_asset.url(w=120, h=160)\n            \"//images.contentful.com/spaces/foobar/...?w=120&h=160\"\n        \"\"\"\n\n        url = self.fields(self._locale()).get('file', {}).get('url', '')\n        args = ['{0}={1}'.format(k, v) for k, v in kwargs.items()]\n\n        if args:\n            url += '?{0}'.format('&'.join(args))\n\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process(self):\n\n        for locale in self._fields.keys():\n            self._client._put(\n                \"{0}/files/{1}/process\".format(\n                    self.__class__.base_url(\n                        self.space.id,\n                        self.id,\n                        environment_id=self._environment_id\n                    ),\n                    locale\n                ),\n                {},\n                headers=self._update_headers()\n            )\n        return self.reload()", "response": "Processes the asset for all locales of the asset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_json(self):\n\n        result = super(UIExtension, self).to_json()\n        result.update({\n            'extension': self.extension\n        })\n\n        return result", "response": "Returns the JSON representation of the UI extension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_attributes(klass, attributes, previous_object=None):\n\n        return {\n            'name': attributes.get(\n                'name',\n                previous_object.name if previous_object is not None else ''\n            ),\n            'description': attributes.get(\n                'description',\n                previous_object.description if previous_object is not None else ''\n            ),\n            'environments': attributes.get(\n                'environments',\n                [e.to_json() for e in previous_object.environments] if previous_object is not None else []  # Will default to master if empty\n            )\n        }", "response": "Create a dictionary of attributes for a resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the JSON representation of the API key.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON representation of the API key.\n        \"\"\"\n\n        result = super(ApiKey, self).to_json()\n        result.update({\n            'name': self.name,\n            'description': self.description,\n            'accessToken': self.access_token,\n            'environments': [e.to_json() for e in self.environments]\n        })\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all(self, usage_type, usage_period_id, api, query=None, *args, **kwargs):\n\n        if query is None:\n            query = {}\n\n        mandatory_query = {\n            'filters[usagePeriod]': usage_period_id,\n            'filters[metric]': api\n        }\n\n        mandatory_query.update(query)\n\n        return self.client._get(\n            self._url(usage_type),\n            mandatory_query,\n            headers={\n                'x-contentful-enable-alpha-feature': 'usage-insights'\n            }\n        )", "response": "Gets all api usages by type for a given period an api."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the base URL for the content type.", "response": "def base_url(klass, space_id, resource_id=None, public=False, environment_id=None, **kwargs):\n        \"\"\"\n        Returns the URI for the content type.\n        \"\"\"\n\n        if public:\n            environment_slug = \"\"\n            if environment_id is not None:\n                environment_slug = \"/environments/{0}\".format(environment_id)\n            return \"spaces/{0}{1}/public/content_types\".format(space_id, environment_slug)\n        return super(ContentType, klass).base_url(\n            space_id,\n            resource_id=resource_id,\n            environment_id=environment_id,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_attributes(klass, attributes, previous_object=None):\n\n        result = super(ContentType, klass).create_attributes(attributes, previous_object)\n\n        if 'fields' not in result:\n            result['fields'] = []\n        return result", "response": "Create a new object of the specified content type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n\n        result = super(ContentType, self).to_json()\n        result.update({\n            'name': self.name,\n            'description': self.description,\n            'displayField': self.display_field,\n            'fields': [f.to_json() for f in self.fields]\n        })\n        return result", "response": "Returns the JSON representation of the content type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef entries(self):\n        return ContentTypeEntriesProxy(self._client, self.space.id, self._environment_id, self.id)", "response": "Provides access to entry management methods for the given content type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef editor_interfaces(self):\n        return ContentTypeEditorInterfacesProxy(self._client, self.space.id, self._environment_id, self.id)", "response": "Provides access to editor interfaces methods for the given content type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nproviding access to snapshot management methods for the given content type.", "response": "def snapshots(self):\n        \"\"\"\n        Provides access to snapshot management methods for the given content type.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/snapshots/content-type-snapshots-collection\n\n        :return: :class:`ContentTypeSnapshotsProxy <contentful_management.content_type_snapshots_proxy.ContentTypeSnapshotsProxy>` object.\n        :rtype: contentful.content_type_snapshots_proxy.ContentTypeSnapshotsProxy\n\n        Usage:\n\n            >>> content_type_snapshots_proxy = content_type.entries()\n            <ContentTypeSnapshotsProxy space_id=\"cfexampleapi\" environment_id=\"master\" content_type_id=\"cat\">\n        \"\"\"\n        return ContentTypeSnapshotsProxy(self._client, self.space.id, self._environment_id, self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef base_url(klass, space_id, webhook_id, resource_id=None):\n\n        return \"spaces/{0}/webhooks/{1}/calls/{2}\".format(\n            space_id,\n            webhook_id,\n            resource_id if resource_id is not None else ''\n        )", "response": "Returns the base URL for the webhook call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattribute for space creation.", "response": "def create_attributes(klass, attributes, previous_object=None):\n        \"\"\"Attributes for space creation.\"\"\"\n\n        if previous_object is not None:\n            return {'name': attributes.get('name', previous_object.name)}\n        return {\n            'name': attributes.get('name', ''),\n            'defaultLocale': attributes['default_locale']\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self):\n\n        return self._client._delete(\n            self.__class__.base_url(\n                self.sys['id']\n            )\n        )", "response": "Deletes the object from the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n\n        result = super(Space, self).to_json()\n        result.update({'name': self.name})\n        return result", "response": "Returns the JSON representation of the space."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all spaces in the system.", "response": "def all(self, query=None, **kwargs):\n        \"\"\"\n        Gets all spaces.\n        \"\"\"\n\n        return super(SpacesProxy, self).all(query=query)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find(self, space_id, query=None, **kwargs):\n\n        try:\n            self.space_id = space_id\n            return super(SpacesProxy, self).find(space_id, query=query)\n        finally:\n            self.space_id = None", "response": "Gets a space by ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a space with given attributes.", "response": "def create(self, attributes=None, **kwargs):\n        \"\"\"\n        Creates a space with given attributes.\n        \"\"\"\n\n        if attributes is None:\n            attributes = {}\n        if 'default_locale' not in attributes:\n            attributes['default_locale'] = self.client.default_locale\n\n        return super(SpacesProxy, self).create(resource_id=None, attributes=attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, space_id):\n\n        try:\n            self.space_id = space_id\n            return super(SpacesProxy, self).delete(space_id)\n        finally:\n            self.space_id = None", "response": "Deletes a space by ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding access to editor interfaces management methods.", "response": "def editor_interfaces(self, space_id, environment_id, content_type_id):\n        \"\"\"\n        Provides access to editor interfaces management methods.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/editor-interface\n\n        :return: :class:`EditorInterfacesProxy <contentful_management.editor_interfaces_proxy.EditorInterfacesProxy>` object.\n        :rtype: contentful.editor_interfaces_proxy.EditorInterfacesProxy\n\n        Usage:\n\n            >>> editor_interfaces_proxy = client.editor_interfaces('cfexampleapi', 'master', 'cat')\n            <EditorInterfacesProxy space_id=\"cfexampleapi\" environment_id=\"master\" content_type_id=\"cat\">\n        \"\"\"\n\n        return EditorInterfacesProxy(self, space_id, environment_id, content_type_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprovide access to snapshot management methods.", "response": "def snapshots(self, space_id, environment_id, resource_id, resource_kind='entries'):\n        \"\"\"\n        Provides access to snapshot management methods.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/snapshots\n\n        :return: :class:`SnapshotsProxy <contentful_management.snapshots_proxy.SnapshotsProxy>` object.\n        :rtype: contentful.snapshots_proxy.SnapshotsProxy\n\n        Usage:\n\n            >>> entry_snapshots_proxy = client.snapshots('cfexampleapi', 'master', 'nyancat')\n            <SnapshotsProxy[entries] space_id=\"cfexampleapi\" environment_id=\"master\" parent_resource_id=\"nyancat\">\n\n            >>> content_type_snapshots_proxy = client.snapshots('cfexampleapi', 'master', 'cat', 'content_types')\n            <SnapshotsProxy[content_types] space_id=\"cfexampleapi\" environment_id=\"master\" parent_resource_id=\"cat\">\n        \"\"\"\n\n        return SnapshotsProxy(self, space_id, environment_id, resource_id, resource_kind)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef entry_snapshots(self, space_id, environment_id, entry_id):\n\n        return SnapshotsProxy(self, space_id, environment_id, entry_id, 'entries')", "response": "Provides access to entry snapshot management methods."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprovides access to content type snapshot management methods.", "response": "def content_type_snapshots(self, space_id, environment_id, content_type_id):\n        \"\"\"\n        Provides access to content type snapshot management methods.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/snapshots\n\n        :return: :class:`SnapshotsProxy <contentful_management.snapshots_proxy.SnapshotsProxy>` object.\n        :rtype: contentful.snapshots_proxy.SnapshotsProxy\n\n        Usage:\n\n            >>> content_type_snapshots_proxy = client.content_type_snapshots('cfexampleapi', 'master', 'cat')\n            <SnapshotsProxy[content_types] space_id=\"cfexampleapi\" environment_id=\"master\" parent_resource_id=\"cat\">\n        \"\"\"\n\n        return SnapshotsProxy(self, space_id, environment_id, content_type_id, 'content_types')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating that required parameters are present.", "response": "def _validate_configuration(self):\n        \"\"\"\n        Validates that required parameters are present.\n        \"\"\"\n\n        if not self.access_token:\n            raise ConfigurationException(\n                'You will need to initialize a client with an Access Token'\n            )\n        if not self.api_url:\n            raise ConfigurationException(\n                'The client configuration needs to contain an API URL'\n            )\n        if not self.default_locale:\n            raise ConfigurationException(\n                'The client configuration needs to contain a Default Locale'\n            )\n        if not self.api_version or self.api_version < 1:\n            raise ConfigurationException(\n                'The API Version must be a positive number'\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the X - Contentful - User - Agent header.", "response": "def _contentful_user_agent(self):\n        \"\"\"\n        Sets the X-Contentful-User-Agent header.\n        \"\"\"\n        header = {}\n        from . import __version__\n        header['sdk'] = {\n            'name': 'contentful-management.py',\n            'version': __version__\n        }\n        header['app'] = {\n            'name': self.application_name,\n            'version': self.application_version\n        }\n        header['integration'] = {\n            'name': self.integration_name,\n            'version': self.integration_version\n        }\n        header['platform'] = {\n            'name': 'python',\n            'version': platform.python_version()\n        }\n\n        os_name = platform.system()\n        if os_name == 'Darwin':\n            os_name = 'macOS'\n        elif not os_name or os_name == 'Java':\n            os_name = None\n        elif os_name and os_name not in ['macOS', 'Windows']:\n            os_name = 'Linux'\n        header['os'] = {\n            'name': os_name,\n            'version': platform.release()\n        }\n\n        def format_header(key, values):\n            header = \"{0} {1}\".format(key, values['name'])\n            if values['version'] is not None:\n                header = \"{0}/{1}\".format(header, values['version'])\n            return \"{0};\".format(header)\n\n        result = []\n        for k, values in header.items():\n            if not values['name']:\n                continue\n            result.append(format_header(k, values))\n\n        return ' '.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate the URL for the current request.", "response": "def _url(self, url, file_upload=False):\n        \"\"\"\n        Creates the request URL.\n        \"\"\"\n\n        host = self.api_url\n        if file_upload:\n            host = self.uploads_api_url\n\n        protocol = 'https' if self.https else 'http'\n        if url.endswith('/'):\n            url = url[:-1]\n        return '{0}://{1}/{2}'.format(\n            protocol,\n            host,\n            url\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms the HTTP request.", "response": "def _http_request(self, method, url, request_kwargs=None):\n        \"\"\"\n        Performs the requested HTTP request.\n        \"\"\"\n\n        kwargs = request_kwargs if request_kwargs is not None else {}\n\n        headers = self._request_headers()\n        headers.update(self.additional_headers)\n        if 'headers' in kwargs:\n            headers.update(kwargs['headers'])\n        kwargs['headers'] = headers\n\n        if self._has_proxy():\n            kwargs['proxies'] = self._proxy_parameters()\n\n        request_url = self._url(\n            url,\n            file_upload=kwargs.pop('file_upload', False)\n        )\n\n        request_method = getattr(requests, method)\n        response = request_method(request_url, **kwargs)\n\n        if response.status_code == 429:\n            raise RateLimitExceededError(response)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms the HTTP GET request.", "response": "def _http_get(self, url, query, **kwargs):\n        \"\"\"\n        Performs the HTTP GET request.\n        \"\"\"\n\n        self._normalize_query(query)\n\n        kwargs.update({'params': query})\n\n        return self._http_request('get', url, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _http_post(self, url, data, **kwargs):\n\n        if not kwargs.get('file_upload', False):\n            data = json.dumps(data)\n\n        kwargs.update({'data': data})\n\n        return self._http_request('post', url, kwargs)", "response": "Performs the HTTP POST request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform the HTTP PUT request.", "response": "def _http_put(self, url, data, **kwargs):\n        \"\"\"\n        Performs the HTTP PUT request.\n        \"\"\"\n\n        kwargs.update({'data': json.dumps(data)})\n\n        return self._http_request('put', url, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _request(self, method, url, query_or_data=None, **kwargs):\n\n        if query_or_data is None:\n            query_or_data = {}\n\n        request_method = getattr(self, '_http_{0}'.format(method))\n        response = retry_request(self)(request_method)(url, query_or_data, **kwargs)\n\n        if self.raw_mode:\n            return response\n\n        if response.status_code >= 300:\n            error = get_error(response)\n            if self.raise_errors:\n                raise error\n            return error\n\n        # Return response object on NoContent\n        if response.status_code == 204 or not response.text:\n            return response\n\n        return ResourceBuilder(\n            self,\n            self.default_locale,\n            response.json()\n        ).build()", "response": "Wrapper for the HTTP requests and return the response object on success."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get(self, url, query=None, **kwargs):\n\n        return self._request('get', url, query, **kwargs)", "response": "Wrapper for the HTTP GET request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _post(self, url, attributes=None, **kwargs):\n\n        return self._request('post', url, attributes, **kwargs)", "response": "Wrapper for the HTTP POST request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps for the HTTP PUT request.", "response": "def _put(self, url, attributes=None, **kwargs):\n        \"\"\"\n        Wrapper for the HTTP PUT request.\n        \"\"\"\n\n        return self._request('put', url, attributes, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap for the HTTP DELETE request.", "response": "def _delete(self, url, **kwargs):\n        \"\"\"\n        Wrapper for the HTTP DELETE request.\n        \"\"\"\n\n        response = retry_request(self)(self._http_delete)(url, **kwargs)\n\n        if self.raw_mode:\n            return response\n\n        if response.status_code >= 300:\n            error = get_error(response)\n            if self.raise_errors:\n                raise error\n            return error\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_json(self):\n\n        result = super(Locale, self).to_json()\n        result.update({\n            'code': self.code,\n            'name': self.name,\n            'fallbackCode': self.fallback_code,\n            'optional': self.optional,\n            'contentDeliveryApi': self.content_delivery_api,\n            'contentManagementApi': self.content_management_api\n        })\n        return result", "response": "Returns the JSON representation of the locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all assets of a space.", "response": "def all(self, query=None, **kwargs):\n        \"\"\"\n        Gets all assets of a space.\n        \"\"\"\n\n        if query is None:\n            query = {}\n\n        normalize_select(query)\n\n        return super(AssetsProxy, self).all(query, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, asset_id, query=None, **kwargs):\n\n        if query is None:\n            query = {}\n\n        normalize_select(query)\n\n        return super(AssetsProxy, self).find(asset_id, query=query, **kwargs)", "response": "Gets a single asset by ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef snapshots(self):\n        return EntrySnapshotsProxy(self._client, self.sys['space'].id, self._environment_id, self.sys['id'])", "response": "Provides access to snapshot management methods for the given entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the entry with attributes.", "response": "def update(self, attributes=None):\n        \"\"\"\n        Updates the entry with attributes.\n        \"\"\"\n\n        if attributes is None:\n            attributes = {}\n\n        attributes['content_type_id'] = self.sys['content_type'].id\n\n        return super(Entry, self).update(attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef all(self, query=None):\n\n        if query is None:\n            query = {}\n        return self.client._get(\n            self._url(),\n            query\n        )", "response": "Gets all the resource collections for this resource class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, resource_id, query=None, **kwargs):\n\n        if query is None:\n            query = {}\n        return self.client._get(\n            self._url(resource_id),\n            query,\n            **kwargs\n        )", "response": "Gets a single resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, resource_id=None, attributes=None):\n\n        if attributes is None:\n            attributes = {}\n\n        result = None\n        if not resource_id:\n            result = self.client._post(\n                self._url(resource_id),\n                self._resource_class.create_attributes(attributes),\n                headers=self._resource_class.create_headers(attributes)\n            )\n        else:\n            result = self.client._put(\n                self._url(resource_id),\n                self._resource_class.create_attributes(attributes),\n                headers=self._resource_class.create_headers(attributes)\n            )\n\n        return result", "response": "Creates a resource with the given ID and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, resource_id, **kwargs):\n\n        return self.client._delete(self._url(resource_id), **kwargs)", "response": "Deletes a resource by ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_json(self):\n\n        result = super(Role, self).to_json()\n        result.update({\n            'name': self.name,\n            'description': self.description,\n            'permissions': self.permissions,\n            'policies': self.policies\n        })\n        return result", "response": "Returns the JSON representation of the role."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the JSON representation of the space membership.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON representation of the space membership.\n        \"\"\"\n\n        result = super(SpaceMembership, self).to_json()\n        result.update({\n            'admin': self.admin,\n            'roles': self.roles\n        })\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, file_or_path, **kwargs):\n\n        opened = False\n        if isinstance(file_or_path, str_type()):\n            file_or_path = open(file_or_path, 'rb')\n            opened = True\n        elif not getattr(file_or_path, 'read', False):\n            raise Exception(\"A file or path to a file is required for this operation.\")\n\n        try:\n            return self.client._post(\n                self._url(),\n                file_or_path,\n                headers=self._resource_class.create_headers({}),\n                file_upload=True\n            )\n        finally:\n            if opened:\n                file_or_path.close()", "response": "Creates an upload for the given file or path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds an upload by ID.", "response": "def find(self, upload_id, **kwargs):\n        \"\"\"\n        Finds an upload by ID.\n        \"\"\"\n\n        return super(UploadsProxy, self).find(upload_id, file_upload=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an upload by ID.", "response": "def delete(self, upload_id):\n        \"\"\"\n        Deletes an upload by ID.\n        \"\"\"\n\n        return super(UploadsProxy, self).delete(upload_id, file_upload=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the JSON representation of the content type field.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON Representation of the content type field.\n        \"\"\"\n\n        result = {\n            'name': self.name,\n            'id': self._real_id(),\n            'type': self.type,\n            'localized': self.localized,\n            'omitted': self.omitted,\n            'required': self.required,\n            'disabled': self.disabled,\n            'validations': [v.to_json() for v in self.validations]\n        }\n\n        if self.type == 'Array':\n            result['items'] = self.items\n\n        if self.type == 'Link':\n            result['linkType'] = self.link_type\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncoercing value to location hash.", "response": "def coerce(self, value):\n        \"\"\"\n        Coerces value to location hash.\n        \"\"\"\n\n        return {\n            'lat': float(value.get('lat', value.get('latitude'))),\n            'lon': float(value.get('lon', value.get('longitude')))\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the base URL for the snapshot.", "response": "def base_url(klass, space_id, parent_resource_id, resource_url='entries', resource_id=None, environment_id=None):\n        \"\"\"\n        Returns the URI for the snapshot.\n        \"\"\"\n\n        return \"spaces/{0}{1}/{2}/{3}/snapshots/{4}\".format(\n            space_id,\n            '/environments/{0}'.format(environment_id) if environment_id is not None else '',\n            resource_url,\n            parent_resource_id,\n            resource_id if resource_id is not None else ''\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_json(self):\n\n        result = super(Snapshot, self).to_json()\n        result.update({\n            'snapshot': self.snapshot.to_json(),\n        })\n        return result", "response": "Returns the JSON representation of the snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all(self, *args, **kwargs):\n\n        return self.client._get(\n            self._url(),\n            {},\n            headers={\n                'x-contentful-enable-alpha-feature': 'usage-insights'\n            }\n        )", "response": "Gets all usage periods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate attributes for webhook creation.", "response": "def create_attributes(klass, attributes, previous_object=None):\n        \"\"\"\n        Attributes for webhook creation.\n        \"\"\"\n\n        result = super(Webhook, klass).create_attributes(attributes, previous_object)\n\n        if 'topics' not in result:\n            raise Exception(\"Topics ('topics') must be provided for this operation.\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprovides access to call overview for the given webhook.", "response": "def calls(self):\n        \"\"\"\n        Provides access to call overview for the given webhook.\n\n        API reference: https://www.contentful.com/developers/docs/references/content-management-api/#/reference/webhook-calls\n\n        :return: :class:`WebhookWebhooksCallProxy <contentful_management.webhook_webhooks_call_proxy.WebhookWebhooksCallProxy>` object.\n        :rtype: contentful.webhook_webhooks_call_proxy.WebhookWebhooksCallProxy\n\n        Usage:\n\n            >>> webhook_webhooks_call_proxy = webhook.calls()\n            <WebhookWebhooksCallProxy space_id=\"cfexampleapi\" webhook_id=\"my_webhook\">\n        \"\"\"\n        return WebhookWebhooksCallProxy(self._client, self.sys['space'].id, self.sys['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef health(self):\n        return WebhookWebhooksHealthProxy(self._client, self.sys['space'].id, self.sys['id'])", "response": "Provides access to health overview for the given webhook."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self):\n\n        result = super(Webhook, self).to_json()\n        result.update({\n            'name': self.name,\n            'url': self.url,\n            'topics': self.topics,\n            'httpBasicUsername': self.http_basic_username,\n            'headers': self.headers\n        })\n\n        if self.filters:\n            result.update({'filters': self.filters})\n\n        if self.transformation:\n            result.update({'transformation': self.transformation})\n\n        return result", "response": "Returns the JSON representation of the webhook."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef base_url(self, space_id, content_type_id, environment_id=None, **kwargs):\n\n        return \"spaces/{0}{1}/content_types/{2}/editor_interface\".format(\n            space_id,\n            '/environments/{0}'.format(environment_id) if environment_id is not None else '',\n            content_type_id\n        )", "response": "Returns the URI for the editor interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_json(self):\n\n        result = super(EditorInterface, self).to_json()\n        result.update({'controls': self.controls})\n        return result", "response": "Returns the JSON representation of the editor interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the JSON representation of the content type field validation.", "response": "def to_json(self):\n        \"\"\"\n        Returns the JSON Representation of the content type field validation.\n        \"\"\"\n\n        result = {}\n        for k, v in self._data.items():\n            result[camel_case(k)] = v\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding the object from the JSON response.", "response": "def build(self):\n        \"\"\"\n        Creates the objects from the JSON response.\n        \"\"\"\n\n        if self.json['sys']['type'] == 'Array':\n            return self._build_array()\n        return self._build_item(self.json)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, resource_id=None, attributes=None):\n\n        return self.proxy.create(resource_id=resource_id, attributes=attributes)", "response": "Creates a resource with a given ID and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a single resource by ID related to the current space.", "response": "def find(self, resource_id, query=None):\n        \"\"\"\n        Finds a single resource by ID related to the current space.\n        \"\"\"\n\n        return self.proxy.find(resource_id, query=query)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ngroups(self, field=None):\n        '''\n        Returns ngroups count if it was specified in the query, otherwise ValueError.\n\n        If grouping on more than one field, provide the field argument to specify which count you are looking for.\n        '''\n        field = field if field else self._determine_group_field(field)\n        if 'ngroups' in self.data['grouped'][field]:\n            return self.data['grouped'][field]['ngroups']\n        raise ValueError(\"ngroups not found in response. specify group.ngroups in the query.\")", "response": "Returns the number of groups in the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_groups_count(self, field=None):\n        '''\n        Returns 'matches' from group response.\n\n                If grouping on more than one field, provide the field argument to specify which count you are looking for.\n        '''\n        field = field if field else self._determine_group_field(field)\n        if 'matches' in self.data['grouped'][field]:\n            return self.data['grouped'][field]['matches']\n        raise ValueError(\"group matches not found in response\")", "response": "Returns the number of matches in the group response."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nflatten the group response and just returns a list of documents.", "response": "def get_flat_groups(self, field=None):\n        '''\n        Flattens the group response and just returns a list of documents.\n        '''\n        field = field if field else self._determine_group_field(field)\n        temp_groups = self.data['grouped'][field]['groups']\n        return [y for x in temp_groups for y in x['doclist']['docs']]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary of facets for the current locale.", "response": "def get_facets(self):\n        '''\n        Returns a dictionary of facets::\n\n            >>> res = solr.query('SolrClient_unittest',{\n                    'q':'product_name:Lorem',\n                    'facet':True,\n                    'facet.field':'facet_test',\n            })... ... ... ...\n            >>> res.get_results_count()\n            4\n            >>> res.get_facets()\n            {'facet_test': {'ipsum': 0, 'sit': 0, 'dolor': 2, 'amet,': 1, 'Lorem': 1}}\n\n        '''\n        if not hasattr(self,'facets'):\n            self.facets = {}\n            data = self.data\n            if 'facet_counts' in data.keys() and type(data['facet_counts']) == dict:\n                if 'facet_fields' in data['facet_counts'].keys() and type(data['facet_counts']['facet_fields']) == dict:\n                    for facetfield in data['facet_counts']['facet_fields']:\n                        if type(data['facet_counts']['facet_fields'][facetfield] == list):\n                            l = data['facet_counts']['facet_fields'][facetfield]\n                            self.facets[facetfield] = OrderedDict(zip(l[::2],l[1::2]))\n                return self.facets\n            else:\n                raise SolrResponseError(\"No Facet Information in the Response\")\n        else:\n            return self.facets"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn query facet ranges", "response": "def get_facets_ranges(self):\n        '''\n        Returns query facet ranges ::\n\n            >>> res = solr.query('SolrClient_unittest',{\n                'q':'*:*',\n                'facet':True,\n                'facet.range':'price',\n                'facet.range.start':0,\n                'facet.range.end':100,\n                'facet.range.gap':10\n                })\n            >>> res.get_facets_ranges()\n            {'price': {'80': 9, '10': 5, '50': 3, '20': 7, '90': 3, '70': 4, '60': 7, '0': 3, '40': 5, '30': 4}}\n\n        '''\n        if not hasattr(self,'facet_ranges'):\n            self.facet_ranges = {}\n            data = self.data\n            if 'facet_counts' in data.keys() and type(data['facet_counts']) == dict:\n                if 'facet_ranges' in data['facet_counts'].keys() and type(data['facet_counts']['facet_ranges']) == dict:\n                    for facetfield in data['facet_counts']['facet_ranges']:\n                        if type(data['facet_counts']['facet_ranges'][facetfield]['counts']) == list:\n                            l = data['facet_counts']['facet_ranges'][facetfield]['counts']\n                            self.facet_ranges[facetfield] = OrderedDict(zip(l[::2],l[1::2]))\n                    return self.facet_ranges\n            else:\n                raise SolrResponseError(\"No Facet Ranges in the Response\")\n        else:\n            return self.facet_ranges"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses facet pivot response. Example :: returns a dict of facet pivot field names and values.", "response": "def get_facet_pivot(self):\n        '''\n        Parses facet pivot response. Example::\n            >>> res = solr.query('SolrClient_unittest',{\n            'q':'*:*',\n            'fq':'price:[50 TO *]',\n            'facet':True,\n            'facet.pivot':'facet_test,price' #Note how there is no space between fields. They are just separated by commas\n            })\n            >>> res.get_facet_pivot()\n            {'facet_test,price': {'Lorem': {89: 1, 75: 1}, 'ipsum': {53: 1, 70: 1, 55: 1, 89: 1, 74: 1, 93: 1, 79: 1}, 'dolor': {61: 1, 94: 1}, 'sit': {99: 1, 50: 1, 67: 1, 52: 1, 54: 1, 71: 1, 72: 1, 84: 1, 62: 1}, 'amet,': {68: 1}}}\n\n        This method has built in recursion and can support indefinite number of facets. However, note that the output format is significantly massaged since Solr by default outputs a list of fields in each pivot field.\n        '''\n        if not hasattr(self,'facet_pivot'):\n            self.facet_pivot = {}\n            if 'facet_counts' in self.data.keys():\n                pivots = self.data['facet_counts']['facet_pivot']\n                for fieldset in pivots:\n                    self.facet_pivot[fieldset] = {}\n                    for sub_field_set in pivots[fieldset]:\n                        res = self._rec_subfield(sub_field_set)\n                        self.facet_pivot[fieldset].update(res)\n                return self.facet_pivot\n        else:\n            return self.facet_pivot"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all values of the given field in the database as a list.", "response": "def get_field_values_as_list(self,field):\n        '''\n        :param str field: The name of the field for which to pull in values.\n        Will parse the query results (must be ungrouped) and return all values of 'field' as a list. Note that these are not unique values.  Example::\n\n            >>> r.get_field_values_as_list('product_name_exact')\n            ['Mauris risus risus lacus. sit', 'dolor auctor Vivamus fringilla. vulputate', 'semper nisi lacus nulla sed', 'vel amet diam sed posuere', 'vitae neque ultricies, Phasellus ac', 'consectetur nisi orci, eu diam', 'sapien, nisi accumsan accumsan In', 'ligula. odio ipsum sit vel', 'tempus orci. elit, Ut nisl.', 'neque nisi Integer nisi Lorem']\n\n        '''\n        return [doc[field] for doc in self.docs if field in doc]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_first_field_values_as_list(self, field):\n        '''\n        :param str field: The name of the field for lookup.\n\n        Goes through all documents returned looking for specified field. At first encounter will return the field's value.\n        '''\n        for doc in self.docs:\n            if field in doc.keys():\n                return doc[field]\n        raise SolrResponseError(\"No field in result set\")", "response": "Returns the first value of a field in the result set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_facet_values_as_list(self, field):\n        '''\n        :param str field: Name of facet field to retrieve values from.\n\n        Returns facet values as list for a given field. Example::\n\n            >>> res = solr.query('SolrClient_unittest',{\n                'q':'*:*',\n                'facet':'true',\n                'facet.field':'facet_test',\n            })\n            >>> res.get_facet_values_as_list('facet_test')\n            [9, 6, 14, 10, 11]\n            >>> res.get_facets()\n            {'facet_test': {'Lorem': 9, 'ipsum': 6, 'amet,': 14, 'dolor': 10, 'sit': 11}}\n\n        '''\n        facets = self.get_facets()\n        out = []\n        if field in facets.keys():\n            for facetfield in facets[field]:\n                out.append(facets[field][facetfield])\n            return out\n        else:\n            raise SolrResponseError(\"No field in facet output\")", "response": "Returns facet values as list for a given field."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of keys from the facet field.", "response": "def get_facet_keys_as_list(self,field):\n        '''\n        :param str field: Name of facet field to retrieve keys from.\n\n        Similar to get_facet_values_as_list but returns the list of keys as a list instead.\n        Example::\n\n            >>> r.get_facet_keys_as_list('facet_test')\n            ['Lorem', 'ipsum', 'amet,', 'dolor', 'sit']\n\n        '''\n        facets = self.get_facets()\n        if facets == -1:\n            return facets\n        if field in facets.keys():\n            return [x for x in facets[field]]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the json. fact output of the resource.", "response": "def json_facet(self, field=None):\n        '''\n        EXPERIMENTAL\n\n        Tried to kick back the json.fact output.\n        '''\n        facets = self.data['facets']\n        if field is None:\n            temp_fields = [x for x in facets.keys() if x != 'count']\n            if len(temp_fields) != 1:\n                raise ValueError(\"field argument not specified and it looks like there is more than one field in facets. Specify the field to get json.facet from. \")\n            field = temp_fields[0]\n\n        if field not in self.data['facets']:\n            raise ValueError(\"Facet Field {} Not found in response, available fields are {}\".format(\n                                        field, self.data['facets'].keys() ))\n        return self.data['facets'][field]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary that is easier to work with the count of the facets and returns then as a dictionary that is easier to work with the base class.", "response": "def get_jsonfacet_counts_as_dict(self, field, data=None):\n        '''\n        EXPERIMENTAL\n        Takes facets and returns then as a dictionary that is easier to work with,\n        for example, if you are getting something this::\n\n            {'facets': {'count': 50,\n              'test': {'buckets': [{'count': 10,\n                 'pr': {'buckets': [{'count': 2, 'unique': 1, 'val': 79},\n                   {'count': 1, 'unique': 1, 'val': 9}]},\n                 'pr_sum': 639.0,\n                 'val': 'consectetur'},\n                {'count': 8,\n                 'pr': {'buckets': [{'count': 1, 'unique': 1, 'val': 9},\n                   {'count': 1, 'unique': 1, 'val': 31},\n                   {'count': 1, 'unique': 1, 'val': 33}]},\n                 'pr_sum': 420.0,\n                 'val': 'auctor'},\n                {'count': 8,\n                 'pr': {'buckets': [{'count': 2, 'unique': 1, 'val': 94},\n                   {'count': 1, 'unique': 1, 'val': 25}]},\n                 'pr_sum': 501.0,\n                 'val': 'nulla'}]}}}\n\n\n        This should return you something like this::\n\n            {'test': {'auctor': {'count': 8,\n                                 'pr': {9: {'count': 1, 'unique': 1},\n                                        31: {'count': 1, 'unique': 1},\n                                        33: {'count': 1, 'unique': 1}},\n                                 'pr_sum': 420.0},\n                      'consectetur': {'count': 10,\n                                      'pr': {9: {'count': 1, 'unique': 1},\n                                             79: {'count': 2, 'unique': 1}},\n                                      'pr_sum': 639.0},\n                      'nulla': {'count': 8,\n                                'pr': {25: {'count': 1, 'unique': 1},\n                                       94: {'count': 2, 'unique': 1}},\n                                'pr_sum': 501.0}}}\n        '''\n        data = data if data else self.data['facets']\n        if field not in data:\n            raise ValueError(\"Field To start Faceting on not specified.\")\n        out = { field: self._json_rec_dict(data[field]['buckets']) }\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a random file name based on self. _output_filename_pattern for the output to do file.", "response": "def _gen_file_name(self):\n        '''\n        Generates a random file name based on self._output_filename_pattern for the output to do file.\n        '''\n        date = datetime.datetime.now()\n        dt = \"{}-{}-{}-{}-{}-{}-{}\".format(str(date.year),str(date.month),str(date.day),str(date.hour),str(date.minute),str(date.second),str(random.randint(0,10000)))\n        return self._output_filename_pattern.format(dt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, item=None, finalize=False, callback=None):\n        '''\n        Takes a string, dictionary or list of items for adding to queue. To help troubleshoot it will output the updated buffer size, however when the content gets written it will output the file path of the new file. Generally this can be safely discarded.\n\n        :param <dict,list> item: Item to add to the queue. If dict will be converted directly to a list and then to json. List must be a list of dictionaries. If a string is submitted, it will be written out as-is immediately and not buffered.\n        :param bool finalize: If items are buffered internally, it will flush them to disk and return the file name.\n        :param callback: A callback function that will be called when the item gets written to disk. It will be passed one position argument, the file path of the file written. Note that errors from the callback method will not be re-raised here.\n        '''\n        if item:\n            if type(item) is list:\n                check = list(set([type(d) for d in item]))\n                if len(check) > 1 or dict not in check:\n                    raise ValueError(\"More than one data type detected in item (list). Make sure they are all dicts of data going to Solr\")\n            elif type(item) is dict:\n                item = [item]\n            elif type(item) is str:\n                return self._write_file(item)\n            else:\n                raise ValueError(\"Not the right data submitted. Make sure you are sending a dict or list of dicts\")\n        with self._rlock:\n            res = self._preprocess(item, finalize, callback)\n        return res", "response": "Adds a new item to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _lock(self):\n        '''\n        Locks, or returns False if already locked\n        '''\n        if not self._is_locked():\n            with open(self._lck,'w') as fh:\n                if self._devel: self.logger.debug(\"Locking\")\n                fh.write(str(os.getpid()))\n            return True\n        else:\n            return False", "response": "Locks the current user s log file. Returns True if the lock was successful False if the lock was already acquired."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_locked(self):\n        '''\n        Checks to see if we are already pulling items from the queue\n        '''\n        if os.path.isfile(self._lck):\n            try:\n                import psutil\n            except ImportError:\n                return True #Lock file exists and no psutil\n            #If psutil is imported\n            with open(self._lck) as f:\n                pid = f.read()\n            return True if psutil.pid_exists(int(pid)) else False\n        else:\n            return False", "response": "Checks to see if we are already pulling items from the queue\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_as_list(self, dir='_todo_dir'):\n        '''\n        Returns a list of the the full path to all items currently in the todo directory. The items will be listed in ascending order based on filesystem time.\n        This will re-scan the directory on each execution.\n\n        Do not use this to process items, this method should only be used for troubleshooting or something axillary. To process items use get_todo_items() iterator.\n        '''\n        dir = getattr(self,dir)\n        list = [x for x in os.listdir(dir) if x.endswith('.json') or x.endswith('.json.gz')]\n        full = [os.path.join(dir,x) for x in list]\n        full.sort(key=lambda x: os.path.getmtime(x))\n        return full", "response": "Returns a list of the full path to all items currently in the todo directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an iterator that will provide each item in the todo queue.", "response": "def get_todo_items(self, **kwargs):\n        '''\n        Returns an iterator that will provide each item in the todo queue. Note that to complete each item you have to run complete method with the output of this iterator.\n\n        That will move the item to the done directory and prevent it from being retrieved in the future.\n        '''\n        def inner(self):\n            for item in self.get_all_as_list():\n                yield item\n            self._unlock()\n\n        if not self._is_locked():\n            if self._lock():\n                return inner(self)\n        raise RuntimeError(\"RuntimeError: Index Already Locked\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmark the item as complete by moving it to the done directory and optionally gzipping it.", "response": "def complete(self, filepath):\n        '''\n        Marks the item as complete by moving it to the done directory and optionally gzipping it.\n        '''\n        if not os.path.exists(filepath):\n            raise FileNotFoundError(\"Can't Complete {}, it doesn't exist\".format(filepath))\n        if self._devel: self.logger.debug(\"Completing - {} \".format(filepath))\n        if self.rotate_complete:\n            try:\n                complete_dir = str(self.rotate_complete())\n            except Exception as e:\n                self.logger.error(\"rotate_complete function failed with the following exception.\")\n                self.logger.exception(e)\n                raise\n            newdir = os.path.join(self._done_dir, complete_dir)\n            newpath = os.path.join(newdir, os.path.split(filepath)[-1] )\n\n            if not os.path.isdir(newdir):\n                self.logger.debug(\"Making new directory: {}\".format(newdir))\n                os.makedirs(newdir)\n        else:\n            newpath = os.path.join(self._done_dir, os.path.split(filepath)[-1] )\n\n        try:\n            if self._compress_complete:\n                if not filepath.endswith('.gz'):\n                    #  Compressing complete, but existing file not compressed\n                    #  Compress and move it and kick out\n                    newpath += '.gz'\n                    self._compress_and_move(filepath, newpath)\n                    return newpath\n                # else the file is already compressed and can just be moved\n            #if not compressing completed file, just move it\n            shutil.move(filepath, newpath)\n            self.logger.info(\" Completed - {}\".format(filepath))\n        except Exception as e:\n            self.logger.error(\"Couldn't Complete {}\".format(filepath))\n            self.logger.exception(e)\n            raise\n        return newpath"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef index(self, solr, collection, threads=1, send_method='stream_file', **kwargs):\n        '''\n        Will index the queue into a specified solr instance and collection. Specify multiple threads to make this faster, however keep in mind that if you specify multiple threads the items may not be in order.\n        Example::\n            solr = SolrClient('http://localhost:8983/solr/')\n            for doc in self.docs:\n                index.add(doc, finalize=True)\n            index.index(solr,'SolrClient_unittest')\n\n        :param object solr: SolrClient object.\n        :param string collection: The name of the collection to index document into.\n        :param int threads: Number of simultaneous threads to spin up for indexing.\n        :param string send_method: SolrClient method to execute for indexing. Default is stream_file\n        '''\n\n        try:\n            method = getattr(solr, send_method)\n        except AttributeError:\n            raise AttributeError(\"Couldn't find the send_method. Specify either stream_file or local_index\")\n\n        self.logger.info(\"Indexing {} into {} using {}\".format(self._queue_name,\r\n                                                               collection,\r\n                                                               send_method))\r\n        if threads > 1:\r\n            if hasattr(collection, '__call__'):\r\n                self.logger.debug(\"Overwriting send_method to index_json\")\r\n                method = getattr(solr, 'index_json')\r\n                method = partial(self._wrap_dynamic, method, collection)\r\n            else:\r\n                method = partial(self._wrap, method, collection)\r\n            with ThreadPool(threads) as p:\n                p.map(method, self.get_todo_items())\n        else:\n            for todo_file in self.get_todo_items():\n                try:\n                    result = method(collection, todo_file)\n                    if result:\n                        self.complete(todo_file)\n                except SolrError:\n                    self.logger.error(\"Error Indexing Item: {}\".format(todo_file))\n                    self._unlock()\n                    raise", "response": "Index the items in a specified collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_json_from_indexq(self):\n        '''\n        Gets all data from the todo files in indexq and returns one huge list of all data.\n        '''\n        files = self.get_all_as_list()\n        out = []\n        for efile in files:\r\n            out.extend(self._open_file(efile))\r\n        return out", "response": "Gets all todo files in indexq and returns one huge list of all data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_multi_q(self, sentinel='STOP'):\n        '''\n        This helps indexq operate in multiprocessing environment without each process having to have it's own IndexQ. It also is a handy way to deal with thread / process safety.\n\n        This method will create and return a JoinableQueue object. Additionally, it will kick off a back end process that will monitor the queue, de-queue items and add them to this indexq.\n\n        The returned JoinableQueue object can be safely passed to multiple worker processes to populate it with data.\n\n        To indicate that you are done writing the data to the queue, pass in the sentinel value ('STOP' by default).\n\n        Make sure you call join_indexer() after you are done to close out the queue and join the worker.\n        '''\n        self.in_q = JoinableQueue()\n        self.indexer_process = Process(target=self._indexer_process, args=(self.in_q, sentinel))\n        self.indexer_process.daemon = False\n        self.indexer_process.start()\n        return self.in_q", "response": "This method creates a JoinableQueue object and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _retry(function):\n\n        def inner(self, **kwargs):\n            last_exception = None\n            #for host in self.router.get_hosts(**kwargs):\n            for host in self.host:\n                try:\n                    return function(self, host, **kwargs)\n                except SolrError as e:\n                    self.logger.exception(e)\n                    raise\n                except ConnectionError as e:\n                    self.logger.exception(\"Tried connecting to Solr, but couldn't because of the following exception.\")\n                    if '401' in e.__str__():\n                        raise\n                    last_exception = e\n            # raise the last exception after contacting all hosts instead of returning None\n            if last_exception is not None:\n                raise last_exception\n        return inner", "response": "Internal mechanism to retry the function if multiple hosts fail."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncommit the current state of the current object to Solr.", "response": "def commit(self, collection, openSearcher=False, softCommit=False,\n               waitSearcher=True, commit=True, **kwargs):\n        \"\"\"\n        :param str collection: The name of the collection for the request\n        :param bool openSearcher: If new searcher is to be opened\n        :param bool softCommit: SoftCommit\n        :param bool waitServer: Blocks until the new searcher is opened\n        :param bool commit: Commit\n\n        Sends a commit to a Solr collection.\n\n        \"\"\"\n        comm = {\n            'openSearcher': str(openSearcher).lower(),\n            'softCommit': str(softCommit).lower(),\n            'waitSearcher': str(waitSearcher).lower(),\n            'commit': str(commit).lower()\n        }\n\n        self.logger.debug(\"Sending Commit to Collection {}\".format(collection))\n        try:\n            resp, con_inf = self.transport.send_request(method='GET', endpoint='update', collection=collection,\n                                                        params=comm, **kwargs)\n        except Exception as e:\n            raise\n        self.logger.debug(\"Commit Successful, QTime is {}\".format(resp['responseHeader']['QTime']))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_raw(self, collection, query, request_handler='select', **kwargs):\n        headers = {'content-type': 'application/x-www-form-urlencoded'}\n        data = query\n        resp, con_inf = self.transport.send_request(method='POST',\n                                                    endpoint=request_handler,\n                                                    collection=collection,\n                                                    data=data,\n                                                    headers=headers,\n                                                    **kwargs)\n        return resp", "response": "Send a query to Solr and return a dict of the response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a query to Solr.", "response": "def query(self, collection, query, request_handler='select', **kwargs):\n        \"\"\"\n        :param str collection: The name of the collection for the request\n        :param str request_handler: Request handler, default is 'select'\n        :param dict query: Python dictonary of Solr query parameters.\n\n        Sends a query to Solr, returns a SolrResults Object. `query` should be a dictionary of solr request handler arguments.\n        Example::\n\n            res = solr.query('SolrClient_unittest',{\n                'q':'*:*',\n                'facet':True,\n                'facet.field':'facet_test',\n            })\n\n        \"\"\"\n        for field in ['facet.pivot']:\n            if field in query.keys():\n                if type(query[field]) is str:\n                    query[field] = query[field].replace(' ', '')\n                elif type(query[field]) is list:\n                    query[field] = [s.replace(' ', '') for s in query[field]]\n\n        method = 'POST'\n        headers = {'content-type': 'application/x-www-form-urlencoded'}\n        params = query\n        data = {}\n        resp, con_inf = self.transport.send_request(method=method,\n                                                    endpoint=request_handler,\n                                                    collection=collection,\n                                                    params=params,\n                                                    data=data,\n                                                    headers=headers,\n                                                    **kwargs)\n        if resp:\n            resp = SolrResponse(resp)\n            resp.url = con_inf['url']\n            return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index(self, collection, docs, params=None, min_rf=None, **kwargs):\n        data = json.dumps(docs)\n        return self.index_json(collection, data, params, min_rf=min_rf, **kwargs)", "response": "This method is used to index the given list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the document from Solr based on the ID.", "response": "def get(self, collection, doc_id, **kwargs):\n        \"\"\"\n        :param str collection: The name of the collection for the request\n        :param str doc_id: ID of the document to be retrieved.\n\n        Retrieve document from Solr based on the ID. ::\n\n            >>> solr.get('SolrClient_unittest','changeme')\n        \"\"\"\n\n        resp, con_inf = self.transport.send_request(method='GET',\n                                                    endpoint='get',\n                                                    collection=collection,\n                                                    params={'id': doc_id},\n                                                    **kwargs)\n        if 'doc' in resp and resp['doc']:\n            return resp['doc']\n        raise NotFoundError"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the documents from Solr based on the ID.", "response": "def mget(self, collection, doc_ids, **kwargs):\n        \"\"\"\n        :param str collection: The name of the collection for the request\n        :param tuple doc_ids: ID of the document to be retrieved.\n\n        Retrieve documents from Solr based on the ID. ::\n\n            >>> solr.get('SolrClient_unittest','changeme')\n        \"\"\"\n\n        resp, con_inf = self.transport.send_request(method='GET',\n                                                    endpoint='get',\n                                                    collection=collection,\n                                                    params={'ids': doc_ids},\n                                                    **kwargs)\n        if 'docs' in resp['response']:\n            return resp['response']['docs']\n        raise NotFoundError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_doc_by_id(self, collection, doc_id, **kwargs):\n        if ' ' in doc_id:\n            doc_id = '\"{}\"'.format(doc_id)\n        temp = {\"delete\": {\"query\": 'id:{}'.format(doc_id)}}\n        resp, con_inf = self.transport.send_request(method='POST',\n                                                    endpoint='update',\n                                                    collection=collection,\n                                                    data=json.dumps(temp),\n                                                    **kwargs)\n        return resp", "response": "Delete a single document from Solr based on the ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_doc_by_query(self, collection, query, **kwargs):\n        temp = {\"delete\": {\"query\": query}}\n        resp, con_inf = self.transport.send_request(method='POST',\n                                                    endpoint='update',\n                                                    collection=collection,\n                                                    data=json.dumps(temp),\n                                                    **kwargs)\n        return resp", "response": "Delete items from Solr based on a given query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef local_index(self, collection, filename, **kwargs):\n        filename = os.path.abspath(filename)\n        self.logger.info(\"Indexing {} into Solr Collection {}\".format(filename, collection))\n\n        data = {'stream.file': filename,\n                'stream.contentType': 'text/json'}\n        resp, con_inf = self.transport.send_request(method='GET', endpoint='update/json', collection=collection,\n                                                    params=data, **kwargs)\n        if resp['responseHeader']['status'] == 0:\n            return True\n        else:\n            return False", "response": "This method will index a file into Solr."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an iterator of SolrResponse objects for the requested collection and query.", "response": "def cursor_query(self, collection, query):\n        \"\"\"\n        :param str collection: The name of the collection for the request.\n        :param dict query: Dictionary of solr args.\n\n        Will page through the result set in increments using cursorMark until it has all items. Sort is required for cursorMark \\\n        queries, if you don't specify it, the default is 'id desc'.\n\n        Returns an iterator of SolrResponse objects. For Example::\n\n            >>> for res in solr.cursor_query('SolrClient_unittest',{'q':'*:*'}):\n                    print(res)\n        \"\"\"\n        cursor = '*'\n        if 'sort' not in query:\n            query['sort'] = 'id desc'\n        while True:\n            query['cursorMark'] = cursor\n            # Get data with starting cursorMark\n            results = self.query(collection, query)\n            if results.get_results_count():\n                cursor = results.get_cursor()\n                yield results\n            else:\n                self.logger.debug(\"Got zero Results with cursor: {}\".format(cursor))\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the shard - map from somewhere or somehow place.", "response": "def get_shard_map(self, force_refresh=False):\n        \"\"\"\n        You can change this function to get the shard-map from somewhere/somehow place else in conjuction with\n        save_shard_map().\n\n        \"\"\"\n        now = datetime.utcnow()\n        if force_refresh is True or \\\n                        self.shard_map is None or \\\n                        (now - self.last_refresh).total_seconds() > self.refresh_ttl:\n            self.last_refresh = now\n            self.refresh_shard_map()\n        return self.shard_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks the znodes in the Solr cluster and returns a dict of the status of each node.", "response": "def check_zk(self):\n        '''\n        Will attempt to telnet to each zookeeper that is used by SolrClient and issue 'mntr' command. Response is parsed to check to see if the \n        zookeeper node is a leader or a follower and returned as a dict. \n\n        If the telnet collection fails or the proper response is not parsed, the zk node will be listed as 'down' in the dict. Desired values are\n        either follower or leader. \n        '''\n        import telnetlib\n        temp = self.zk_hosts.split('/')\n        zks = temp[0].split(',')\n        status = {}\n        for zk in zks:\n            self.logger.debug(\"Checking {}\".format(zk))\n            host, port = zk.split(':')\n            try:\n                t = telnetlib.Telnet(host, port=int(port))\n                t.write('mntr'.encode('ascii'))\n                r = t.read_all()\n                for out in r.decode('utf-8').split('\\n'):\n                    if out:\n                        param, val = out.split('\\t')\n                        if param == 'zk_server_state':\n                            status[zk] = val\n            except Exception as e:\n                self.logger.error(\"Unable to reach ZK: {}\".format(zk))\n                self.logger.exception(e)\n                status[zk] = 'down'\n        #assert len(zks) == len(status)\n        return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncopies collection configs into a new folder.", "response": "def copy_config(self, original, new):\n        '''\n        Copies collection configs into a new folder. Can be used to create new collections based on existing configs. \n\n        Basically, copies all nodes under /configs/original to /configs/new.\n\n        :param original str: ZK name of original config\n        :param new str: New name of the ZK config. \n        '''\n        if not self.kz.exists('/configs/{}'.format(original)):\n            raise ZookeeperError(\"Collection doesn't exist in Zookeeper. Current Collections are: {}\".format(self.kz.get_children('/configs')))\n        base = '/configs/{}'.format(original)\n        nbase = '/configs/{}'.format(new)\n        self._copy_dir(base, nbase)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_collection_configs(self, collection, fs_path):\n        '''\n        Downloads ZK Directory to the FileSystem.\n\n        :param collection str: Name of the collection (zk config name)\n        :param fs_path str: Destination filesystem path. \n        '''\n        \n        if not self.kz.exists('/configs/{}'.format(collection)):\n            raise ZookeeperError(\"Collection doesn't exist in Zookeeper. Current Collections are: {} \".format(self.kz.get_children('/configs')))\n        self._download_dir('/configs/{}'.format(collection), fs_path + os.sep + collection)", "response": "Downloads the ZK Directory to the FileSystem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupload collection configurations from a specified directory to zookeeper.", "response": "def upload_collection_configs(self, collection, fs_path):\n        '''\n        Uploads collection configurations from a specified directory to zookeeper. \n        \n        '''\n        coll_path = fs_path\n        if not os.path.isdir(coll_path):\n            raise ValueError(\"{} Doesn't Exist\".format(coll_path))\n        self._upload_dir(coll_path, '/configs/{}'.format(collection))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new field in managed schema", "response": "def create_field(self, collection, field_dict):\n        '''\n        Creates a new field in managed schema, will raise ValueError if the field already exists.  field_dict should look like this::\n\n            {\n                 \"name\":\"sell-by\",\n                 \"type\":\"tdate\",\n                 \"stored\":True\n            }\n\n        Reference: https://cwiki.apache.org/confluence/display/solr/Defining+Fields\n\n        '''\n        if self.does_field_exist(collection,field_dict['name']):\n            raise ValueError(\"Field {} Already Exists in Solr Collection {}\".format(field_dict['name'],collection))\n        temp = {\"add-field\":dict(field_dict)}\n        res, con_info =self.solr.transport.send_request(method='POST',endpoint=self.schema_endpoint,collection=collection, data=json.dumps(temp))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_field(self,collection,field_name):\n        '''\n        Deletes a field from the Solr Collection. Will raise ValueError if the field doesn't exist.\n\n        :param string collection: Name of the collection for the action\n        :param string field_name: String name of the field.\n        '''\n        if not self.does_field_exist(collection,field_name):\n            raise ValueError(\"Field {} Doesn't Exists in Solr Collection {}\".format(field_name,collection))\n        else:\n            temp = {\"delete-field\" : { \"name\":field_name }}\n            res, con_info = self.solr.transport.send_request(method='POST',endpoint=self.schema_endpoint,collection=collection, data=json.dumps(temp))\n            return res", "response": "Deletes a field from the Solr Collection. Will raise ValueError if the field doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef does_field_exist(self,collection,field_name):\n        '''\n        Checks if the field exists will return a boolean True (exists) or False(doesn't exist).\n\n        :param string collection: Name of the collection for the action\n        :param string field_name: String name of the field.\n        '''\n        schema = self.get_schema_fields(collection)\n        logging.info(schema)\n        return True if field_name in [field['name'] for field in schema['fields']] else False", "response": "Checks if the field exists will return a boolean True or False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a copy field.", "response": "def create_copy_field(self,collection,copy_dict):\n        '''\n        Creates a copy field.\n\n        copy_dict should look like ::\n\n            {'source':'source_field_name','dest':'destination_field_name'}\n\n        :param string collection: Name of the collection for the action\n        :param dict copy_field: Dictionary of field info\n\n        Reference: https://cwiki.apache.org/confluence/display/solr/Schema+API#SchemaAPI-AddaNewCopyFieldRule\n        '''\n        temp = {\"add-copy-field\":dict(copy_dict)}\n        res, con_info = self.solr.transport.send_request(method='POST',endpoint=self.schema_endpoint,collection=collection, data=json.dumps(temp))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_copy_field(self, collection, copy_dict):\n        '''\n        Deletes a copy field.\n\n        copy_dict should look like ::\n\n            {'source':'source_field_name','dest':'destination_field_name'}\n\n        :param string collection: Name of the collection for the action\n        :param dict copy_field: Dictionary of field info\n        '''\n\n        #Fix this later to check for field before sending a delete\n        if self.devel:\n            self.logger.debug(\"Deleting {}\".format(str(copy_dict)))\n        copyfields = self.get_schema_copyfields(collection)\n        if copy_dict not in copyfields:\n            self.logger.info(\"Fieldset not in Solr Copy Fields: {}\".format(str(copy_dict)))\n        temp = {\"delete-copy-field\": dict(copy_dict)}\n        res, con_info = self.solr.transport.send_request(method='POST',endpoint=self.schema_endpoint,collection=collection, data=json.dumps(temp))\n        return res", "response": "Delete a copy field."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shuffle_hosts(self):\n        if len(self.hosts) > 1:\n            random.shuffle(self.hosts)\n        return self.hosts", "response": "Shuffle hosts so we don t always query the first one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting virtual display which will be used for testing.", "response": "def start_virtual_display(self, width=1440, height=900,\n                              colordepth=24, **kwargs):\n        \"\"\"Starts virtual display which will be\n         destroyed after test execution will be end\n\n        *Arguments:*\n        - width: a width to be set in pixels\n        - height: a height to be set in pixels\n        - color_depth: a color depth to be used\n        - kwargs: extra parameters\n\n        *Example:*\n\n        | Start Virtual Display |\n        | Start Virtual Display | 1920 | 1080 |\n        | Start Virtual Display | ${1920} | ${1080} | ${16} |\n        \"\"\"\n        if self._display is None:\n            logger.info(\"Using virtual display: '{0}x{1}x{2}'\".format(\n                        width, height, colordepth))\n\n            self._display = Xvfb(int(width), int(height),\n                                 int(colordepth), **kwargs)\n            self._display.start()\n            atexit.register(self._display.stop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a request to Solr Cloud Collections API.", "response": "def api(self, action, args=None):\n        \"\"\"\n        Sends a request to Solr Collections API.\n        Documentation is here: https://cwiki.apache.org/confluence/display/solr/Collections+API\n\n        :param string action: Name of the collection for the action\n        :param dict args: Dictionary of specific parameters for action\n        \"\"\"\n        if args is None:\n            args = {}\n        args['action'] = action.upper()\n\n        try:\n            res, con_info = self.solr.transport.send_request(endpoint='admin/collections', params=args)\n        except Exception as e:\n            self.logger.error(\"Error querying SolrCloud Collections API. \")\n            self.logger.exception(e)\n            raise e\n\n        if 'responseHeader' in res and res['responseHeader']['status'] == 0:\n            return res, con_info\n        else:\n            raise SolrError(\"Error Issuing Collections API Call for: {} +\".format(con_info, res))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new collection.", "response": "def create(self, name, numShards, params=None):\n        \"\"\"\n        Create a new collection.\n        \"\"\"\n        if params is None:\n            params = {}\n        params.update(\n            name=name,\n            numShards=numShards\n        )\n        return self.api('CREATE', params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery each core to get individual counts for each shard.", "response": "def _get_collection_counts(self, core_data):\n        \"\"\"\n        Queries each core to get individual counts for each core for each shard.\n        \"\"\"\n        if core_data['base_url'] not in self.solr_clients:\n            from SolrClient import SolrClient\n            self.solr_clients['base_url'] = SolrClient(core_data['base_url'], log=self.logger)\n        try:\n            return self.solr_clients['base_url'].query(core_data['core'],\n                                                       {'q': '*:*',\n                                                        'rows': 0,\n                                                        'distrib': 'false',\n                                                        }).get_num_found()\n        except Exception as e:\n            self.logger.error(\"Couldn't get Counts for {}/{}\".format(core_data['base_url'], core_data['core']))\n            self.logger.exception(e)\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_status(self, ignore=(), status=None):\n        self.SHARD_CHECKS = [\n            {'check_msg': 'Bad Core Count Check', 'f': self._check_shard_count},\n            {'check_msg': 'Bad Shard Cluster Status', 'f': self._check_shard_status}\n        ]\n        if status is None:\n            status = self.clusterstatus()\n        out = {}\n        for collection in status:\n            out[collection] = {}\n            out[collection]['coll_status'] = True  # Means it's fine\n            out[collection]['coll_messages'] = []\n            for shard in status[collection]:\n                self.logger.debug(\"Checking {}/{}\".format(collection, shard))\n                s_dict = status[collection][shard]\n                for check in self.SHARD_CHECKS:\n                    if check['check_msg'] in ignore:\n                        continue\n                    res = check['f'](s_dict)\n                    if not res:\n                        out[collection]['coll_status'] = False\n                        if check['check_msg'] not in out[collection]['coll_messages']:\n                            out[collection]['coll_messages'].append(check['check_msg'])\n                        self.logger.debug(s_dict)\n        return out", "response": "Checks status of each collection and shard and returns a dict of results for custom alerting."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart Reindexing Process. All parameter arguments will be passed down to the getter function. :param string fq: FilterQuery to pass to source Solr to retrieve items. This can be used to limit the results.", "response": "def reindex(self, fq= [], **kwargs):\r\n        '''\r\n        Starts Reindexing Process. All parameter arguments will be passed down to the getter function.\r\n        :param string fq: FilterQuery to pass to source Solr to retrieve items. This can be used to limit the results.\r\n        '''\r\n        for items in self._getter(fq=fq, **kwargs):\r\n            self._putter(items)\r\n        if type(self._dest) is SolrClient and self._dest_coll:\r\n            self.log.info(\"Finished Indexing, sending a commit\")\r\n            self._dest.commit(self._dest_coll, openSearcher=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _trim_fields(self, docs):\r\n        '''\r\n        Removes ignore fields from the data that we got from Solr.\r\n        '''\r\n        for doc in docs:\r\n            for field in self._ignore_fields:\r\n                if field in doc:\r\n                    del(doc[field])\r\n        return docs", "response": "Removes ignore fields from the data that we got from Solr."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_query(self, cursor):\r\n        '''\r\n        Query tempalte for source Solr, sorts by id by default.\r\n        '''\r\n        query = {'q':'*:*',\r\n                'sort':'id desc',\r\n                'rows':self._rows,\r\n                'cursorMark':cursor}\r\n        if self._date_field:\r\n            query['sort'] = \"{} asc, id desc\".format(self._date_field)\r\n        if self._per_shard:\r\n            query['distrib'] = 'false'\r\n        return query", "response": "Returns a query dict for source Solr sorts by id by default."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _to_solr(self, data):\r\n        '''\r\n        Sends data to a Solr instance.\r\n        '''\r\n        return self._dest.index_json(self._dest_coll, json.dumps(data,sort_keys=True))", "response": "Send data to a Solr instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_date_range_query(self, start_date, end_date, timespan= 'DAY', date_field= None):\r\n        '''\r\n        Gets counts of items per specified date range.\r\n        :param collection: Solr Collection to use.\r\n        :param timespan: Solr Date Math compliant value for faceting ex HOUR, MONTH, DAY\r\n        '''\r\n        if date_field is None:\r\n            date_field = self._date_field\r\n        query ={'q':'*:*',\r\n                'rows':0,\r\n                'facet':'true',\r\n                'facet.range': date_field,\r\n                'facet.range.gap': '+1{}'.format(timespan),\r\n                'facet.range.end': '{}'.format(end_date),\r\n                'facet.range.start': '{}'.format(start_date),\r\n                'facet.range.include': 'all'\r\n                }\r\n        if self._per_shard:\r\n            query['distrib'] = 'false'\r\n        return query", "response": "Returns a query string that returns the count of items per specified date range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_edge_date(self, date_field, sort):\r\n        '''\r\n        This method is used to get start and end dates for the collection.\r\n        '''\r\n        return self._source.query(self._source_coll, {\r\n                'q':'*:*',\r\n                'rows':1,\r\n                'fq':'+{}:*'.format(date_field),\r\n                'sort':'{} {}'.format(date_field, sort)}).docs[0][date_field]", "response": "This method returns the start and end dates for the edge of the source collection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_date_facet_counts(self, timespan, date_field, start_date=None, end_date=None):\r\n        '''\r\n        Returns Range Facet counts based on\r\n        '''\r\n        if 'DAY' not in timespan:\r\n            raise ValueError(\"At this time, only DAY date range increment is supported. Aborting..... \")\r\n\r\n        #Need to do this a bit better later. Don't like the string and date concatenations.\r\n        if not start_date:\r\n            start_date = self._get_edge_date(date_field, 'asc')\r\n            start_date = datetime.strptime(start_date,'%Y-%m-%dT%H:%M:%S.%fZ').date().isoformat()+'T00:00:00.000Z'\r\n        else:\r\n            start_date = start_date+'T00:00:00.000Z'\r\n\r\n        if not end_date:\r\n            end_date = self._get_edge_date(date_field, 'desc')\r\n            end_date = datetime.strptime(end_date,'%Y-%m-%dT%H:%M:%S.%fZ').date()\r\n            end_date += timedelta(days=1)\r\n            end_date = end_date.isoformat()+'T00:00:00.000Z'\r\n        else:\r\n            end_date = end_date+'T00:00:00.000Z'\r\n\r\n\r\n        self.log.info(\"Processing Items from {} to {}\".format(start_date, end_date))\r\n\r\n        #Get facet counts for source and destination collections\r\n        source_facet = self._source.query(self._source_coll,\r\n            self._get_date_range_query(timespan=timespan, start_date=start_date, end_date=end_date)\r\n            ).get_facets_ranges()[date_field]\r\n        dest_facet = self._dest.query(\r\n            self._dest_coll, self._get_date_range_query(\r\n                    timespan=timespan, start_date=start_date, end_date=end_date\r\n                    )).get_facets_ranges()[date_field]\r\n        return source_facet, dest_facet", "response": "Returns a list of facet counts based on a date range increment."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resume(self, start_date=None, end_date=None, timespan='DAY', check= False):\r\n        '''\r\n        This method may help if the original run was interrupted for some reason. It will only work under the following conditions\r\n        * You have a date field that you can facet on\r\n        * Indexing was stopped for the duration of the copy\r\n\r\n        The way this tries to resume re-indexing is by running a date range facet on the source and destination collections. It then compares\r\n        the counts in both collections for each timespan specified. If the counts are different, it will re-index items for each range where\r\n        the counts are off. You can also pass in a start_date to only get items after a certain time period. Note that each date range will be indexed in\r\n        it's entirety, even if there is only one item missing.\r\n\r\n        Keep in mind this only checks the counts and not actual data. So make the indexes weren't modified between the reindexing execution and\r\n        running the resume operation.\r\n\r\n        :param start_date: Date to start indexing from. If not specified there will be no restrictions and all data will be processed. Note that\r\n        this value will be passed to Solr directly and not modified.\r\n        :param end_date: The date to index items up to. Solr Date Math compliant value for faceting; currenlty only DAY is supported.\r\n        :param timespan: Solr Date Math compliant value for faceting; currenlty only DAY is supported.\r\n        :param check: If set to True it will only log differences between the two collections without actually modifying the destination.\r\n        '''\r\n\r\n        if type(self._source) is not SolrClient or type(self._dest) is not SolrClient:\r\n            raise ValueError(\"To resume, both source and destination need to be Solr.\")\r\n\r\n        source_facet, dest_facet = self._get_date_facet_counts(timespan, self._date_field, start_date=start_date, end_date=end_date)\r\n\r\n        for dt_range in sorted(source_facet):\r\n            if dt_range in dest_facet:\r\n                self.log.info(\"Date Range: {} Source: {} Destination:{} Difference:{}\".format(\r\n                        dt_range, source_facet[dt_range], dest_facet[dt_range], (source_facet[dt_range]-dest_facet[dt_range])))\r\n                if check:\r\n                    continue\r\n                if source_facet[dt_range] > dest_facet[dt_range]:\r\n                    #Kicks off reindexing with an additional FQ\r\n                    self.reindex(fq=['{}:[{} TO {}]'.format(self._date_field, dt_range, dt_range+'+1{}'.format(timespan))])\r\n                    self.log.info(\"Complete Date Range {}\".format(dt_range))\r\n            else:\r\n                self.log.error(\"Something went wrong; destinationSource: {}\".format(source_facet))\r\n                self.log.error(\"Destination: {}\".format(dest_facet))\r\n                raise ValueError(\"Date Ranges don't match up\")\r\n        self._dest.commit(self._dest_coll, openSearcher=True)", "response": "Resume indexing items from one collection to another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart a new client session.", "response": "def start_client(self, event=None):\n        \"\"\"\n        Negotiate a new SSH2 session as a client.  This is the first step after\n        creating a new L{Transport}.  A separate thread is created for protocol\n        negotiation.\n\n        If an event is passed in, this method returns immediately.  When\n        negotiation is done (successful or not), the given C{Event} will\n        be triggered.  On failure, L{is_active} will return C{False}.\n\n        (Since 1.4) If C{event} is C{None}, this method will not return until\n        negotation is done.  On success, the method returns normally.\n        Otherwise an SSHException is raised.\n\n        After a successful negotiation, you will usually want to authenticate,\n        calling L{auth_password <Transport.auth_password>} or\n        L{auth_publickey <Transport.auth_publickey>}.\n\n        @note: L{connect} is a simpler method for connecting as a client.\n\n        @note: After calling this method (or L{start_server} or L{connect}),\n            you should no longer directly read from or write to the original\n            socket object.\n\n        @param event: an event to trigger when negotiation is complete\n            (optional)\n        @type event: threading.Event\n\n        @raise SSHException: if negotiation fails (and no C{event} was passed\n            in)\n        \"\"\"\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        Random.atfork()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.isSet():\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start_server(self, event=None, server=None):\n        if server is None:\n            server = ServerInterface()\n        self.server_mode = True\n        self.server_object = server\n        self.active = True\n        if event is not None:\n            # async, return immediately and let the app poll for completion\n            self.completion_event = event\n            self.start()\n            return\n\n        # synchronous, wait for a result\n        self.completion_event = event = threading.Event()\n        self.start()\n        while True:\n            event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if event.isSet():\n                break", "response": "Start a new server session."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose this session and any open channels that are tied to it.", "response": "def close(self):\n        \"\"\"\n        Close this session, and any open channels that are tied to it.\n        \"\"\"\n        if not self.active:\n            return\n        self.active = False\n        self.packetizer.close()\n        self.join()\n        for chan in self._channels.values():\n            chan._unlink()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening a forwarded TCP channel.", "response": "def open_forwarded_tcpip_channel(self, (src_addr, src_port), (dest_addr, dest_port)):\n        \"\"\"\n        Request a new channel back to the client, of type C{\"forwarded-tcpip\"}.\n        This is used after a client has requested port forwarding, for sending\n        incoming connections back to the client.\n\n        @param src_addr: originator's address\n        @param src_port: originator's port\n        @param dest_addr: local (server) connected address\n        @param dest_port: local (server) connected port\n        \"\"\"\n        return self.open_channel('forwarded-tcpip', (dest_addr, dest_port), (src_addr, src_port))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting a TCP forwarding connection from a listening port on the server.", "response": "def request_port_forward(self, address, port, handler=None):\n        \"\"\"\n        Ask the server to forward TCP connections from a listening port on\n        the server, across this SSH session.\n\n        If a handler is given, that handler is called from a different thread\n        whenever a forwarded connection arrives.  The handler parameters are::\n\n            handler(channel, (origin_addr, origin_port), (server_addr, server_port))\n\n        where C{server_addr} and C{server_port} are the address and port that\n        the server was listening on.\n\n        If no handler is set, the default behavior is to send new incoming\n        forwarded connections into the accept queue, to be picked up via\n        L{accept}.\n\n        @param address: the address to bind when forwarding\n        @type address: str\n        @param port: the port to forward, or 0 to ask the server to allocate\n            any port\n        @type port: int\n        @param handler: optional handler for incoming forwarded connections\n        @type handler: function(Channel, (str, int), (str, int))\n        @return: the port # allocated by the server\n        @rtype: int\n\n        @raise SSHException: if the server refused the TCP forward request\n        \"\"\"\n        if not self.active:\n            raise SSHException('SSH session not active')\n        address = str(address)\n        port = int(port)\n        response = self.global_request('tcpip-forward', (address, port), wait=True)\n        if response is None:\n            raise SSHException('TCP forwarding request denied')\n        if port == 0:\n            port = response.get_int()\n        if handler is None:\n            def default_handler(channel, (src_addr, src_port), (dest_addr, dest_port)):\n                self._queue_incoming_channel(channel)\n            handler = default_handler\n        self._tcp_handler = handler\n        return port"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a junk packet across the encrypted link.", "response": "def send_ignore(self, bytes=None):\n        \"\"\"\n        Send a junk packet across the encrypted link.  This is sometimes used\n        to add \"noise\" to a connection to confuse would-be attackers.  It can\n        also be used as a keep-alive for long lived connections traversing\n        firewalls.\n\n        @param bytes: the number of random bytes to send in the payload of the\n            ignored packet -- defaults to a random number from 10 to 41.\n        @type bytes: int\n        \"\"\"\n        m = Message()\n        m.add_byte(chr(MSG_IGNORE))\n        if bytes is None:\n            bytes = (ord(rng.read(1)) % 32) + 10\n        m.add_bytes(rng.read(bytes))\n        self._send_user_message(m)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nforce this session to switch to new keys. Normally this is done automatically after the session hits a certain number of packets or bytes sent or received, but this method gives you the option of forcing new keys whenever you want. Negotiating new keys causes a pause in traffic both ways as the two sides swap keys and do computations. This method returns when the session has switched to new keys. @raise SSHException: if the key renegotiation failed (which causes the session to end)", "response": "def renegotiate_keys(self):\n        \"\"\"\n        Force this session to switch to new keys.  Normally this is done\n        automatically after the session hits a certain number of packets or\n        bytes sent or received, but this method gives you the option of forcing\n        new keys whenever you want.  Negotiating new keys causes a pause in\n        traffic both ways as the two sides swap keys and do computations.  This\n        method returns when the session has switched to new keys.\n\n        @raise SSHException: if the key renegotiation failed (which causes the\n            session to end)\n        \"\"\"\n        self.completion_event = threading.Event()\n        self._send_kex_init()\n        while True:\n            self.completion_event.wait(0.1)\n            if not self.active:\n                e = self.get_exception()\n                if e is not None:\n                    raise e\n                raise SSHException('Negotiation failed.')\n            if self.completion_event.isSet():\n                break\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_keepalive(self, interval):\n        self.packetizer.set_keepalive(interval,\n            lambda x=weakref.proxy(self): x.global_request('keepalive@lag.net', wait=False))", "response": "Turn on keepalive packets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nestablish a connection to the server.", "response": "def connect(self, hostkey=None, username='', password=None, pkey=None):\n        \"\"\"\n        Negotiate an SSH2 session, and optionally verify the server's host key\n        and authenticate using a password or private key.  This is a shortcut\n        for L{start_client}, L{get_remote_server_key}, and\n        L{Transport.auth_password} or L{Transport.auth_publickey}.  Use those\n        methods if you want more control.\n\n        You can use this method immediately after creating a Transport to\n        negotiate encryption with a server.  If it fails, an exception will be\n        thrown.  On success, the method will return cleanly, and an encrypted\n        session exists.  You may immediately call L{open_channel} or\n        L{open_session} to get a L{Channel} object, which is used for data\n        transfer.\n\n        @note: If you fail to supply a password or private key, this method may\n        succeed, but a subsequent L{open_channel} or L{open_session} call may\n        fail because you haven't authenticated yet.\n\n        @param hostkey: the host key expected from the server, or C{None} if\n            you don't want to do host key verification.\n        @type hostkey: L{PKey<pkey.PKey>}\n        @param username: the username to authenticate as.\n        @type username: str\n        @param password: a password to use for authentication, if you want to\n            use password authentication; otherwise C{None}.\n        @type password: str\n        @param pkey: a private key to use for authentication, if you want to\n            use private key authentication; otherwise C{None}.\n        @type pkey: L{PKey<pkey.PKey>}\n\n        @raise SSHException: if the SSH2 negotiation fails, the host key\n            supplied by the server is incorrect, or authentication fails.\n        \"\"\"\n        if hostkey is not None:\n            self._preferred_keys = [ hostkey.get_name() ]\n\n        self.start_client()\n\n        # check host key if we were given one\n        if (hostkey is not None):\n            key = self.get_remote_server_key()\n            if (key.get_name() != hostkey.get_name()) or (str(key) != str(hostkey)):\n                self._log(DEBUG, 'Bad host key from server')\n                self._log(DEBUG, 'Expected: %s: %s' % (hostkey.get_name(), repr(str(hostkey))))\n                self._log(DEBUG, 'Got     : %s: %s' % (key.get_name(), repr(str(key))))\n                raise SSHException('Bad host key from server')\n            self._log(DEBUG, 'Host key verified (%s)' % hostkey.get_name())\n\n        if (pkey is not None) or (password is not None):\n            if password is not None:\n                self._log(DEBUG, 'Attempting password auth...')\n                self.auth_password(username, password)\n            else:\n                self._log(DEBUG, 'Attempting public-key auth...')\n                self.auth_publickey(username, pkey)\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auth_none(self, username):\n        if (not self.active) or (not self.initial_kex_done):\n            raise SSHException('No existing session')\n        my_event = threading.Event()\n        self.auth_handler = AuthHandler(self)\n        self.auth_handler.auth_none(username, my_event)\n        return self.auth_handler.wait_for_response(my_event)", "response": "Try to authenticate to the server using no authentication at all."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to the user.", "response": "def _send_user_message(self, data):\n        \"\"\"\n        send a message, but block if we're in key negotiation.  this is used\n        for user-initiated requests.\n        \"\"\"\n        start = time.time()\n        while True:\n            self.clear_to_send.wait(0.1)\n            if not self.active:\n                self._log(DEBUG, 'Dropping user packet because connection is dead.')\n                return\n            self.clear_to_send_lock.acquire()\n            if self.clear_to_send.isSet():\n                break\n            self.clear_to_send_lock.release()\n            if time.time() > start + self.clear_to_send_timeout:\n              raise SSHException('Key-exchange timed out waiting for key negotiation')\n        try:\n            self._send_message(data)\n        finally:\n            self.clear_to_send_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing by a kex object to set the K and H", "response": "def _set_K_H(self, k, h):\n        \"used by a kex object to set the K (root key) and H (exchange hash)\"\n        self.K = k\n        self.H = h\n        if self.session_id == None:\n            self.session_id = h"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compute_key(self, id, nbytes):\n        \"id is 'A' - 'F' for the various keys used by ssh\"\n        m = Message()\n        m.add_mpint(self.K)\n        m.add_bytes(self.H)\n        m.add_byte(id)\n        m.add_bytes(self.session_id)\n        out = sofar = SHA.new(str(m)).digest()\n        while len(out) < nbytes:\n            m = Message()\n            m.add_mpint(self.K)\n            m.add_bytes(self.H)\n            m.add_bytes(sofar)\n            digest = SHA.new(str(m)).digest()\n            out += digest\n            sofar += digest\n        return out[:nbytes]", "response": "id is A - F for the various keys used by ssh"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a KEXINIT message to the other side that we don t know about.", "response": "def _send_kex_init(self):\n        \"\"\"\n        announce to the other side that we'd like to negotiate keys, and what\n        kind of key negotiation we support.\n        \"\"\"\n        self.clear_to_send_lock.acquire()\n        try:\n            self.clear_to_send.clear()\n        finally:\n            self.clear_to_send_lock.release()\n        self.in_kex = True\n        if self.server_mode:\n            if (self._modulus_pack is None) and ('diffie-hellman-group-exchange-sha1' in self._preferred_kex):\n                # can't do group-exchange if we don't have a pack of potential primes\n                pkex = list(self.get_security_options().kex)\n                pkex.remove('diffie-hellman-group-exchange-sha1')\n                self.get_security_options().kex = pkex\n            available_server_keys = filter(self.server_key_dict.keys().__contains__,\n                                           self._preferred_keys)\n        else:\n            available_server_keys = self._preferred_keys\n\n        m = Message()\n        m.add_byte(chr(MSG_KEXINIT))\n        m.add_bytes(rng.read(16))\n        m.add_list(self._preferred_kex)\n        m.add_list(available_server_keys)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_ciphers)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_macs)\n        m.add_list(self._preferred_compression)\n        m.add_list(self._preferred_compression)\n        m.add_string('')\n        m.add_string('')\n        m.add_boolean(False)\n        m.add_int(0)\n        # save a copy for later (needed to compute a hash)\n        self.local_kex_init = str(m)\n        self._send_message(m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generate_prime(bits, rng):\n    \"primtive attempt at prime generation\"\n    hbyte_mask = pow(2, bits % 8) - 1\n    while True:\n        # loop catches the case where we increment n into a higher bit-range\n        x = rng.read((bits+7) // 8)\n        if hbyte_mask > 0:\n            x = chr(ord(x[0]) & hbyte_mask) + x[1:]\n        n = util.inflate_long(x, 1)\n        n |= 1\n        n |= (1 << (bits - 1))\n        while not number.isPrime(n):\n            n += 2\n        if util.bit_length(n) == bits:\n            break\n    return n", "response": "primtive attempt at prime generation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a random from 0 to N - 1", "response": "def _roll_random(rng, n):\n    \"returns a random # from 0 to N-1\"\n    bits = util.bit_length(n-1)\n    bytes = (bits + 7) // 8\n    hbyte_mask = pow(2, bits % 8) - 1\n\n    # so here's the plan:\n    # we fetch as many random bits as we'd need to fit N-1, and if the\n    # generated number is >= N, we try again.  in the worst case (N-1 is a\n    # power of 2), we have slightly better than 50% odds of getting one that\n    # fits, so i can't guarantee that this loop will ever finish, but the odds\n    # of it looping forever should be infinitesimal.\n    while True:\n        x = rng.read(bytes)\n        if hbyte_mask > 0:\n            x = chr(ord(x[0]) & hbyte_mask) + x[1:]\n        num = util.inflate_long(x, 1)\n        if num < n:\n            break\n    return num"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting a private key file in SSH2 - format.", "response": "def _write_private_key_file(self, tag, filename, data, password=None):\n        \"\"\"\n        Write an SSH2-format private key file in a form that can be read by\n        ssh or openssh.  If no password is given, the key is written in\n        a trivially-encoded format (base64) which is completely insecure.  If\n        a password is given, DES-EDE3-CBC is used.\n\n        @param tag: C{\"RSA\"} or C{\"DSA\"}, the tag used to mark the data block.\n        @type tag: str\n        @param filename: name of the file to write.\n        @type filename: str\n        @param data: data blob that makes up the private key.\n        @type data: str\n        @param password: an optional password to use to encrypt the file.\n        @type password: str\n\n        @raise IOError: if there was an error writing the file.\n        \"\"\"\n        f = open(filename, 'w', 0600)\n        # grrr... the mode doesn't always take hold\n        os.chmod(filename, 0600)\n        self._write_private_key(tag, f, data, password)\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting an event on this buffer.", "response": "def set_event(self, event):\n        \"\"\"\n        Set an event on this buffer.  When data is ready to be read (or the\n        buffer has been closed), the event will be set.  When no data is\n        ready, the event will be cleared.\n        \n        @param event: the event to set/clear\n        @type event: Event\n        \"\"\"\n        self._event = event\n        if len(self._buffer) > 0:\n            event.set()\n        else:\n            event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef feed(self, data):\n        self._lock.acquire()\n        try:\n            if self._event is not None:\n                self._event.set()\n            self._buffer.fromstring(data)\n            self._cv.notifyAll()\n        finally:\n            self._lock.release()", "response": "Feed new data into the pipe."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self, offset, length):\n        readfile = getattr(self, 'readfile', None)\n        if readfile is None:\n            return SFTP_OP_UNSUPPORTED\n        try:\n            if self.__tell is None:\n                self.__tell = readfile.tell()\n            if offset != self.__tell:\n                readfile.seek(offset)\n                self.__tell = offset\n            data = readfile.read(length)\n        except IOError, e:\n            self.__tell = None\n            return SFTPServer.convert_errno(e.errno)\n        self.__tell += len(data)\n        return data", "response": "Reads up to length bytes from this file starting at position\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite data into the file at the specified offset.", "response": "def write(self, offset, data):\n        \"\"\"\n        Write C{data} into this file at position C{offset}.  Extending the\n        file past its original end is expected.  Unlike python's normal\n        C{write()} methods, this method cannot do a partial write: it must\n        write all of C{data} or else return an error.\n\n        The default implementation checks for an attribute on C{self} named\n        C{writefile}, and if present, performs the write operation on the\n        python file-like object found there.  The attribute is named\n        differently from C{readfile} to make it easy to implement read-only\n        (or write-only) files, but if both attributes are present, they should\n        refer to the same file.\n        \n        @param offset: position in the file to start reading from.\n        @type offset: int or long\n        @param data: data to write into the file.\n        @type data: str\n        @return: an SFTP error code like L{SFTP_OK}.\n        \"\"\"\n        writefile = getattr(self, 'writefile', None)\n        if writefile is None:\n            return SFTP_OP_UNSUPPORTED\n        try:\n            # in append mode, don't care about seeking\n            if (self.__flags & os.O_APPEND) == 0:\n                if self.__tell is None:\n                    self.__tell = writefile.tell()\n                if offset != self.__tell:\n                    writefile.seek(offset)\n                    self.__tell = offset\n            writefile.write(data)\n            writefile.flush()\n        except IOError, e:\n            self.__tell = None\n            return SFTPServer.convert_errno(e.errno)\n        if self.__tell is not None:\n            self.__tell += len(data)\n        return SFTP_OK"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef canonicalize(self, path):\n        if os.path.isabs(path):\n            out = os.path.normpath(path)\n        else:\n            out = os.path.normpath('/' + path)\n        if sys.platform == 'win32':\n            # on windows, normalize backslashes to sftp/posix format\n            out = out.replace('\\\\', '/')\n        return out", "response": "Return the canonical form of a path on the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(self):\n        if ('SSH_AUTH_SOCK' in os.environ) and (sys.platform != 'win32'):\n            conn = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                retry_on_signal(lambda: conn.connect(os.environ['SSH_AUTH_SOCK']))\n            except:\n                # probably a dangling env var: the ssh agent is gone\n                return\n        elif sys.platform == 'win32':\n            import win_pageant\n            if win_pageant.can_talk_to_agent():\n                conn = win_pageant.PageantConnection()\n            else:\n                return\n        else:\n            # no agent support\n            return\n        self._conn = conn", "response": "Connect to the SSH agent."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the host keys to a file.", "response": "def save_host_keys(self, filename):\n        \"\"\"\n        Save the host keys back to a file.  Only the host keys loaded with\n        L{load_host_keys} (plus any added directly) will be saved -- not any\n        host keys loaded with L{load_system_host_keys}.\n\n        @param filename: the filename to save to\n        @type filename: str\n\n        @raise IOError: if the file could not be written\n        \"\"\"\n        f = open(filename, 'w')\n        f.write('# SSH host keys collected by ssh\\n')\n        for hostname, keys in self._host_keys.iteritems():\n            for keytype, key in keys.iteritems():\n                f.write('%s %s %s\\n' % (hostname, keytype, key.get_base64()))\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exec_command(self, command, bufsize=-1):\n        chan = self._transport.open_session()\n        chan.exec_command(command)\n        stdin = chan.makefile('wb', bufsize)\n        stdout = chan.makefile('rb', bufsize)\n        stderr = chan.makefile_stderr('rb', bufsize)\n        return stdin, stdout, stderr", "response": "Execute a command on the SSH server and return the stdout and stderr streams."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _auth(self, username, password, pkey, key_filenames, allow_agent, look_for_keys):\n        saved_exception = None\n        two_factor = False\n        allowed_types = []\n\n        if pkey is not None:\n            try:\n                self._log(DEBUG, 'Trying SSH key %s' % hexlify(pkey.get_fingerprint()))\n                allowed_types = self._transport.auth_publickey(username, pkey)\n                two_factor = (allowed_types == ['password'])\n                if not two_factor:\n                    return\n            except SSHException, e:\n                saved_exception = e\n\n        if not two_factor:\n            for key_filename in key_filenames:\n                for pkey_class in (RSAKey, DSSKey):\n                    try:\n                        key = pkey_class.from_private_key_file(key_filename, password)\n                        self._log(DEBUG, 'Trying key %s from %s' % (hexlify(key.get_fingerprint()), key_filename))\n                        self._transport.auth_publickey(username, key)\n                        two_factor = (allowed_types == ['password'])\n                        if not two_factor:\n                            return\n                        break\n                    except SSHException, e:\n                        saved_exception = e\n\n        if not two_factor and allow_agent:\n            if self._agent == None:\n                self._agent = Agent()\n\n            for key in self._agent.get_keys():\n                try:\n                    self._log(DEBUG, 'Trying SSH agent key %s' % hexlify(key.get_fingerprint()))\n                    # for 2-factor auth a successfully auth'd key will result in ['password']\n                    allowed_types = self._transport.auth_publickey(username, key)\n                    two_factor = (allowed_types == ['password'])\n                    if not two_factor:\n                        return\n                    break\n                except SSHException, e:\n                    saved_exception = e\n\n        if not two_factor:\n            keyfiles = []\n            rsa_key = os.path.expanduser('~/.ssh/id_rsa')\n            dsa_key = os.path.expanduser('~/.ssh/id_dsa')\n            if os.path.isfile(rsa_key):\n                keyfiles.append((RSAKey, rsa_key))\n            if os.path.isfile(dsa_key):\n                keyfiles.append((DSSKey, dsa_key))\n            # look in ~/ssh/ for windows users:\n            rsa_key = os.path.expanduser('~/ssh/id_rsa')\n            dsa_key = os.path.expanduser('~/ssh/id_dsa')\n            if os.path.isfile(rsa_key):\n                keyfiles.append((RSAKey, rsa_key))\n            if os.path.isfile(dsa_key):\n                keyfiles.append((DSSKey, dsa_key))\n    \n            if not look_for_keys:\n                keyfiles = []\n    \n            for pkey_class, filename in keyfiles:\n                try:\n                    key = pkey_class.from_private_key_file(filename, password)\n                    self._log(DEBUG, 'Trying discovered key %s in %s' % (hexlify(key.get_fingerprint()), filename))\n                    # for 2-factor auth a successfully auth'd key will result in ['password']\n                    allowed_types = self._transport.auth_publickey(username, key)\n                    two_factor = (allowed_types == ['password'])\n                    if not two_factor:\n                        return\n                    break\n                except SSHException, e:\n                    saved_exception = e\n                except IOError, e:\n                    saved_exception = e\n\n        if password is not None:\n            try:\n                self._transport.auth_password(username, password)\n                return\n            except SSHException, e:\n                saved_exception = e\n        elif two_factor:\n            raise SSHException('Two-factor authentication requires a password')\n\n        # if we got an auth-failed exception earlier, re-raise it\n        if saved_exception is not None:\n            raise saved_exception\n        raise SSHException('No authentication methods available')", "response": "Authenticates a user with a private key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the next n bytes of the message.", "response": "def get_bytes(self, n):\n        \"\"\"\n        Return the next C{n} bytes of the Message, without decomposing into\n        an int, string, etc.  Just the raw bytes are returned.\n\n        @return: a string of the next C{n} bytes of the Message, or a string\n            of C{n} zero bytes, if there aren't C{n} bytes remaining.\n        @rtype: string\n        \"\"\"\n        b = self.packet.read(n)\n        if len(b) < n:\n            return b + '\\x00' * (n - len(b))\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an integer to the stream.", "response": "def add_int(self, n):\n        \"\"\"\n        Add an integer to the stream.\n        \n        @param n: integer to add\n        @type n: int\n        \"\"\"\n        self.packet.write(struct.pack('>I', n))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a string to the stream.", "response": "def add_string(self, s):\n        \"\"\"\n        Add a string to the stream.\n        \n        @param s: string to add\n        @type s: str\n        \"\"\"\n        self.add_int(len(s))\n        self.packet.write(s)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resize_pty(self, width=80, height=24):\n        if self.closed or self.eof_received or self.eof_sent or not self.active:\n            raise SSHException('Channel is not open')\n        m = Message()\n        m.add_byte(chr(MSG_CHANNEL_REQUEST))\n        m.add_int(self.remote_chanid)\n        m.add_string('window-change')\n        m.add_boolean(True)\n        m.add_int(width)\n        m.add_int(height)\n        m.add_int(0).add_int(0)\n        self._event_pending()\n        self.transport._send_user_message(m)\n        self._wait_for_event()", "response": "This method is used to resize the pseudo - terminal. This method is used to change the width and height of the terminal screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the exit status from the process on the server. This is mostly useful for retrieving the reults of an L{exec_command}. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. @return: the exit code of the process on the server. @rtype: int @since: 1.2", "response": "def recv_exit_status(self):\n        \"\"\"\n        Return the exit status from the process on the server.  This is\n        mostly useful for retrieving the reults of an L{exec_command}.\n        If the command hasn't finished yet, this method will wait until\n        it does, or until the channel is closed.  If no exit status is\n        provided by the server, -1 is returned.\n        \n        @return: the exit code of the process on the server.\n        @rtype: int\n        \n        @since: 1.2\n        \"\"\"\n        self.status_event.wait()\n        assert self.status_event.isSet()\n        return self.exit_status"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends the exit status of an executed command to the client.", "response": "def send_exit_status(self, status):\n        \"\"\"\n        Send the exit status of an executed command to the client.  (This\n        really only makes sense in server mode.)  Many clients expect to\n        get some sort of status code back from an executed command after\n        it completes.\n        \n        @param status: the exit code of the process\n        @type status: int\n        \n        @since: 1.2\n        \"\"\"\n        # in many cases, the channel will not still be open here.\n        # that's fine.\n        m = Message()\n        m.add_byte(chr(MSG_CHANNEL_REQUEST))\n        m.add_int(self.remote_chanid)\n        m.add_string('exit-status')\n        m.add_boolean(False)\n        m.add_int(status)\n        self.transport._send_user_message(m)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreceives data from the channel.", "response": "def recv(self, nbytes):\n        \"\"\"\n        Receive data from the channel.  The return value is a string\n        representing the data received.  The maximum amount of data to be\n        received at once is specified by C{nbytes}.  If a string of length zero\n        is returned, the channel stream has closed.\n\n        @param nbytes: maximum number of bytes to read.\n        @type nbytes: int\n        @return: data.\n        @rtype: str\n        \n        @raise socket.timeout: if no data is ready before the timeout set by\n            L{settimeout}.\n        \"\"\"\n        try:\n            out = self.in_buffer.read(nbytes, self.timeout)\n        except PipeTimeout, e:\n            raise socket.timeout()\n\n        ack = self._check_add_window(len(out))\n        # no need to hold the channel lock when sending this\n        if ack > 0:\n            m = Message()\n            m.add_byte(chr(MSG_CHANNEL_WINDOW_ADJUST))\n            m.add_int(self.remote_chanid)\n            m.add_int(ack)\n            self.transport._send_user_message(m)\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending data to the channel without allowing partial results.", "response": "def sendall(self, s):\n        \"\"\"\n        Send data to the channel, without allowing partial results.  Unlike\n        L{send}, this method continues to send data from the given string until\n        either all data has been sent or an error occurs.  Nothing is returned.\n\n        @param s: data to send.\n        @type s: str\n\n        @raise socket.timeout: if sending stalled for longer than the timeout\n            set by L{settimeout}.\n        @raise socket.error: if an error occured before the entire string was\n            sent.\n        \n        @note: If the channel is closed while only part of the data hase been\n            sent, there is no way to determine how much data (if any) was sent.\n            This is irritating, but identically follows python's API.\n        \"\"\"\n        while s:\n            if self.closed:\n                # this doesn't seem useful, but it is the documented behavior of Socket\n                raise socket.error('Socket is closed')\n            sent = self.send(s)\n            s = s[sent:]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending data to the channel s stderr stream without allowing partial results.", "response": "def sendall_stderr(self, s):\n        \"\"\"\n        Send data to the channel's \"stderr\" stream, without allowing partial\n        results.  Unlike L{send_stderr}, this method continues to send data\n        from the given string until all data has been sent or an error occurs.\n        Nothing is returned.\n        \n        @param s: data to send to the client as \"stderr\" output.\n        @type s: str\n        \n        @raise socket.timeout: if sending stalled for longer than the timeout\n            set by L{settimeout}.\n        @raise socket.error: if an error occured before the entire string was\n            sent.\n            \n        @since: 1.1\n        \"\"\"\n        while s:\n            if self.closed:\n                raise socket.error('Socket is closed')\n            sent = self.send_stderr(s)\n            s = s[sent:]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattempt to authenticate to the given transport using any of the SSH - agent keys available from the given username.", "response": "def agent_auth(transport, username):\n    \"\"\"\n    Attempt to authenticate to the given transport using any of the private\n    keys available from an SSH agent.\n    \"\"\"\n    \n    agent = ssh.Agent()\n    agent_keys = agent.get_keys()\n    if len(agent_keys) == 0:\n        return\n        \n    for key in agent_keys:\n        print 'Trying ssh-agent key %s' % hexlify(key.get_fingerprint()),\n        try:\n            transport.auth_publickey(username, key)\n            print '... success!'\n            return\n        except ssh.SSHException:\n            print '... nope.'"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _read_prefetch(self, size):\n        # while not closed, and haven't fetched past the current position, and haven't reached EOF...\n        while True:\n            offset = self._data_in_prefetch_buffers(self._realpos)\n            if offset is not None:\n                break\n            if self._prefetch_done or self._closed:\n                break\n            self.sftp._read_response()\n            self._check_exception()\n        if offset is None:\n            self._prefetching = False\n            return None\n        prefetch = self._prefetch_data[offset]\n        del self._prefetch_data[offset]\n        \n        buf_offset = self._realpos - offset\n        if buf_offset > 0:\n            self._prefetch_data[offset] = prefetch[:buf_offset]\n            prefetch = prefetch[buf_offset:]\n        if size < len(prefetch):\n            self._prefetch_data[self._realpos + size] = prefetch[size:]\n            prefetch = prefetch[:size]\n        return prefetch", "response": "read data out of the prefetch buffer if possible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the permissions of this file.", "response": "def chmod(self, mode):\n        \"\"\"\n        Change the mode (permissions) of this file.  The permissions are\n        unix-style and identical to those used by python's C{os.chmod}\n        function.\n\n        @param mode: new permissions\n        @type mode: int\n        \"\"\"\n        self.sftp._log(DEBUG, 'chmod(%s, %r)' % (hexlify(self.handle), mode))\n        attr = SFTPAttributes()\n        attr.st_mode = mode\n        self.sftp._request(CMD_FSETSTAT, self.handle, attr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchange the owner and group of this file.", "response": "def chown(self, uid, gid):\n        \"\"\"\n        Change the owner (C{uid}) and group (C{gid}) of this file.  As with\n        python's C{os.chown} function, you must pass both arguments, so if you\n        only want to change one, use L{stat} first to retrieve the current\n        owner and group.\n\n        @param uid: new owner's uid\n        @type uid: int\n        @param gid: new group id\n        @type gid: int\n        \"\"\"\n        self.sftp._log(DEBUG, 'chown(%s, %r, %r)' % (hexlify(self.handle), uid, gid))\n        attr = SFTPAttributes()\n        attr.st_uid, attr.st_gid = uid, gid\n        self.sftp._request(CMD_FSETSTAT, self.handle, attr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef utime(self, times):\n        if times is None:\n            times = (time.time(), time.time())\n        self.sftp._log(DEBUG, 'utime(%s, %r)' % (hexlify(self.handle), times))\n        attr = SFTPAttributes()\n        attr.st_atime, attr.st_mtime = times\n        self.sftp._request(CMD_FSETSTAT, self.handle, attr)", "response": "Set the access and modified times of this file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flush(self):\n        self._write_all(self._wbuffer.getvalue())\n        self._wbuffer = StringIO()\n        return", "response": "Flushes all data in the write buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readline(self, size=None):\n        # it's almost silly how complex this function is.\n        if self._closed:\n            raise IOError('File is closed')\n        if not (self._flags & self.FLAG_READ):\n            raise IOError('File not open for reading')\n        line = self._rbuffer\n        while True:\n            if self._at_trailing_cr and (self._flags & self.FLAG_UNIVERSAL_NEWLINE) and (len(line) > 0):\n                # edge case: the newline may be '\\r\\n' and we may have read\n                # only the first '\\r' last time.\n                if line[0] == '\\n':\n                    line = line[1:]\n                    self._record_newline('\\r\\n')\n                else:\n                    self._record_newline('\\r')\n                self._at_trailing_cr = False\n            # check size before looking for a linefeed, in case we already have\n            # enough.\n            if (size is not None) and (size >= 0):\n                if len(line) >= size:\n                    # truncate line and return\n                    self._rbuffer = line[size:]\n                    line = line[:size]\n                    self._pos += len(line)\n                    return line\n                n = size - len(line)\n            else:\n                n = self._bufsize\n            if ('\\n' in line) or ((self._flags & self.FLAG_UNIVERSAL_NEWLINE) and ('\\r' in line)):\n                break\n            try:\n                new_data = self._read(n)\n            except EOFError:\n                new_data = None\n            if (new_data is None) or (len(new_data) == 0):\n                self._rbuffer = ''\n                self._pos += len(line)\n                return line\n            line += new_data\n            self._realpos += len(new_data)\n        # find the newline\n        pos = line.find('\\n')\n        if self._flags & self.FLAG_UNIVERSAL_NEWLINE:\n            rpos = line.find('\\r')\n            if (rpos >= 0) and ((rpos < pos) or (pos < 0)):\n                pos = rpos\n        xpos = pos + 1\n        if (line[pos] == '\\r') and (xpos < len(line)) and (line[xpos] == '\\n'):\n            xpos += 1\n        self._rbuffer = line[xpos:]\n        lf = line[pos:xpos]\n        line = line[:pos] + '\\n'\n        if (len(self._rbuffer) == 0) and (lf == '\\r'):\n            # we could read the line up to a '\\r' and there could still be a\n            # '\\n' following that we read next time.  note that and eat it.\n            self._at_trailing_cr = True\n        else:\n            self._record_newline(lf)\n        self._pos += len(line)\n        return line", "response": "Read one entire line from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_mode(self, mode='r', bufsize=-1):\n        # set bufsize in any event, because it's used for readline().\n        self._bufsize = self._DEFAULT_BUFSIZE\n        if bufsize < 0:\n            # do no buffering by default, because otherwise writes will get\n            # buffered in a way that will probably confuse people.\n            bufsize = 0\n        if bufsize == 1:\n            # apparently, line buffering only affects writes.  reads are only\n            # buffered if you call readline (directly or indirectly: iterating\n            # over a file will indirectly call readline).\n            self._flags |= self.FLAG_BUFFERED | self.FLAG_LINE_BUFFERED\n        elif bufsize > 1:\n            self._bufsize = bufsize\n            self._flags |= self.FLAG_BUFFERED\n            self._flags &= ~self.FLAG_LINE_BUFFERED\n        elif bufsize == 0:\n            # unbuffered\n            self._flags &= ~(self.FLAG_BUFFERED | self.FLAG_LINE_BUFFERED)\n\n        if ('r' in mode) or ('+' in mode):\n            self._flags |= self.FLAG_READ\n        if ('w' in mode) or ('+' in mode):\n            self._flags |= self.FLAG_WRITE\n        if ('a' in mode):\n            self._flags |= self.FLAG_WRITE | self.FLAG_APPEND\n            self._size = self._get_size()\n            self._pos = self._realpos = self._size\n        if ('b' in mode):\n            self._flags |= self.FLAG_BINARY\n        if ('U' in mode):\n            self._flags |= self.FLAG_UNIVERSAL_NEWLINE\n            # built-in file objects have this attribute to store which kinds of\n            # line terminations they've seen:\n            # <http://www.python.org/doc/current/lib/built-in-funcs.html>\n            self.newlines = None", "response": "Sets the mode of the current file object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an SFTP client channel from an open L { Transport } which is already authenticated .", "response": "def from_transport(cls, t):\n        \"\"\"\n        Create an SFTP client channel from an open L{Transport}.\n\n        @param t: an open L{Transport} which is already authenticated\n        @type t: L{Transport}\n        @return: a new L{SFTPClient} object, referring to an sftp session\n            (channel) across the transport\n        @rtype: L{SFTPClient}\n        \"\"\"\n        chan = t.open_session()\n        if chan is None:\n            return None\n        chan.invoke_subsystem('sftp')\n        return cls(chan)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listdir_attr(self, path='.'):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'listdir(%r)' % path)\n        t, msg = self._request(CMD_OPENDIR, path)\n        if t != CMD_HANDLE:\n            raise SFTPError('Expected handle')\n        handle = msg.get_string()\n        filelist = []\n        while True:\n            try:\n                t, msg = self._request(CMD_READDIR, handle)\n            except EOFError, e:\n                # done with handle\n                break\n            if t != CMD_NAME:\n                raise SFTPError('Expected name response')\n            count = msg.get_int()\n            for i in range(count):\n                filename = _to_unicode(msg.get_string())\n                longname = _to_unicode(msg.get_string())\n                attr = SFTPAttributes._from_msg(msg, filename, longname)\n                if (filename != '.') and (filename != '..'):\n                    filelist.append(attr)\n        self._request(CMD_CLOSE, handle)\n        return filelist", "response": "Return a list of attributes corresponding to the files in the given path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'remove(%r)' % path)\n        self._request(CMD_REMOVE, path)", "response": "Removes the file at the given path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rmdir(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'rmdir(%r)' % path)\n        self._request(CMD_RMDIR, path)", "response": "Remove the folder named C { path}.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stat(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'stat(%r)' % path)\n        t, msg = self._request(CMD_STAT, path)\n        if t != CMD_ATTRS:\n            raise SFTPError('Expected attributes')\n        return SFTPAttributes._from_msg(msg)", "response": "Return the attributes of a file on the remote system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lstat(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'lstat(%r)' % path)\n        t, msg = self._request(CMD_LSTAT, path)\n        if t != CMD_ATTRS:\n            raise SFTPError('Expected attributes')\n        return SFTPAttributes._from_msg(msg)", "response": "Retrieve information about a file on the remote system without symbolic links."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef symlink(self, source, dest):\n        dest = self._adjust_cwd(dest)\n        self._log(DEBUG, 'symlink(%r, %r)' % (source, dest))\n        if type(source) is unicode:\n            source = source.encode('utf-8')\n        self._request(CMD_SYMLINK, source, dest)", "response": "Create a symbolic link of the source path at\n        dest."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange the permissions of a file.", "response": "def chmod(self, path, mode):\n        \"\"\"\n        Change the mode (permissions) of a file.  The permissions are\n        unix-style and identical to those used by python's C{os.chmod}\n        function.\n\n        @param path: path of the file to change the permissions of\n        @type path: str\n        @param mode: new permissions\n        @type mode: int\n        \"\"\"\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'chmod(%r, %r)' % (path, mode))\n        attr = SFTPAttributes()\n        attr.st_mode = mode\n        self._request(CMD_SETSTAT, path, attr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readlink(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'readlink(%r)' % path)\n        t, msg = self._request(CMD_READLINK, path)\n        if t != CMD_NAME:\n            raise SFTPError('Expected name response')\n        count = msg.get_int()\n        if count == 0:\n            return None\n        if count != 1:\n            raise SFTPError('Readlink returned %d results' % count)\n        return _to_unicode(msg.get_string())", "response": "Read a symbolic link from the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize(self, path):\n        path = self._adjust_cwd(path)\n        self._log(DEBUG, 'normalize(%r)' % path)\n        t, msg = self._request(CMD_REALPATH, path)\n        if t != CMD_NAME:\n            raise SFTPError('Expected name response')\n        count = msg.get_int()\n        if count != 1:\n            raise SFTPError('Realpath returned %d results' % count)\n        return _to_unicode(msg.get_string())", "response": "Return the normalized form of a given path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, remotepath, localpath, callback=None):\n        fr = self.file(remotepath, 'rb')\n        file_size = self.stat(remotepath).st_size\n        fr.prefetch()\n        try:\n            fl = file(localpath, 'wb')\n            try:\n                size = 0\n                while True:\n                    data = fr.read(32768)\n                    if len(data) == 0:\n                        break\n                    fl.write(data)\n                    size += len(data)\n                    if callback is not None:\n                        callback(size, file_size)\n            finally:\n                fl.close()\n        finally:\n            fr.close()\n        s = os.stat(localpath)\n        if s.st_size != size:\n            raise IOError('size mismatch in get!  %d != %d' % (s.st_size, size))", "response": "Copy a remote file from the SFTP server to the local file system as a local file system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadjust the cwd to match the path", "response": "def _adjust_cwd(self, path):\n        \"\"\"\n        Return an adjusted path if we're emulating a \"current working\n        directory\" for the server.\n        \"\"\"\n        if type(path) is unicode:\n            path = path.encode('utf-8')\n        if self._cwd is None:\n            return path\n        if (len(path) > 0) and (path[0] == '/'):\n            # absolute path\n            return path\n        if self._cwd == '/':\n            return self._cwd + path\n        return self._cwd + '/' + path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a resource to be closed with an object is collected.", "response": "def register(self, obj, resource):\n        \"\"\"\n        Register a resource to be closed with an object is collected.\n        \n        When the given C{obj} is garbage-collected by the python interpreter,\n        the C{resource} will be closed by having its C{close()} method called.\n        Any exceptions are ignored.\n        \n        @param obj: the object to track\n        @type obj: object\n        @param resource: the resource to close when the object is collected\n        @type resource: object\n        \"\"\"\n        def callback(ref):\n            try:\n                resource.close()\n            except:\n                pass\n            del self._table[id(resource)]\n\n        # keep the weakref in a table so it sticks around long enough to get\n        # its callback called. :)\n        self._table[id(resource)] = weakref.ref(obj, callback)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _request(self, method, path, data=None, reestablish_session=True):\n        if path.startswith(\"http\"):\n            url = path  # For cases where URL of different form is needed.\n        else:\n            url = self._format_path(path)\n\n        headers = {\"Content-Type\": \"application/json\"}\n        if self._user_agent:\n            headers['User-Agent'] = self._user_agent\n\n        body = json.dumps(data).encode(\"utf-8\")\n        try:\n            response = requests.request(method, url, data=body, headers=headers,\n                                        cookies=self._cookies, **self._request_kwargs)\n        except requests.exceptions.RequestException as err:\n            # error outside scope of HTTP status codes\n            # e.g. unable to resolve domain name\n            raise PureError(err.message)\n\n        if response.status_code == 200:\n            if \"application/json\" in response.headers.get(\"Content-Type\", \"\"):\n                if response.cookies:\n                    self._cookies.update(response.cookies)\n                else:\n                    self._cookies.clear()\n                content = response.json()\n                if isinstance(content, list):\n                    content = ResponseList(content)\n                elif isinstance(content, dict):\n                    content = ResponseDict(content)\n                content.headers = response.headers\n                return content\n            raise PureError(\"Response not in JSON: \" + response.text)\n        elif response.status_code == 401 and reestablish_session:\n            self._start_session()\n            return self._request(method, path, data, False)\n        elif response.status_code == 450 and self._renegotiate_rest_version:\n            # Purity REST API version is incompatible.\n            old_version = self._rest_version\n            self._rest_version = self._choose_rest_version()\n            if old_version == self._rest_version:\n                # Got 450 error, but the rest version was supported\n                # Something really unexpected happened.\n                raise PureHTTPError(self._target, str(self._rest_version), response)\n            return self._request(method, path, data, reestablish_session)\n        else:\n            raise PureHTTPError(self._target, str(self._rest_version), response)", "response": "Perform HTTP request for REST API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_rest_version(self, version):\n        version = str(version)\n\n        if version not in self.supported_rest_versions:\n            msg = \"Library is incompatible with REST API version {0}\"\n            raise ValueError(msg.format(version))\n\n        array_rest_versions = self._list_available_rest_versions()\n        if version not in array_rest_versions:\n            msg = \"Array is incompatible with REST API version {0}\"\n            raise ValueError(msg.format(version))\n\n        return LooseVersion(version)", "response": "Validate a REST API version is supported by the library and target array."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the newest REST API version supported by target array.", "response": "def _choose_rest_version(self):\n        \"\"\"Return the newest REST API version supported by target array.\"\"\"\n        versions = self._list_available_rest_versions()\n        versions = [LooseVersion(x) for x in versions if x in self.supported_rest_versions]\n        if versions:\n            return max(versions)\n        else:\n            raise PureError(\n                \"Library is incompatible with all REST API versions supported\"\n                \"by the target array.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of the REST API versions supported by the array", "response": "def _list_available_rest_versions(self):\n        \"\"\"Return a list of the REST API versions supported by the array\"\"\"\n        url = \"https://{0}/api/api_version\".format(self._target)\n\n        data = self._request(\"GET\", url, reestablish_session=False)\n        return data[\"version\"]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse username and password to obtain and return an API token.", "response": "def _obtain_api_token(self, username, password):\n        \"\"\"Use username and password to obtain and return an API token.\"\"\"\n        data = self._request(\"POST\", \"auth/apitoken\",\n                             {\"username\": username, \"password\": password},\n                             reestablish_session=False)\n        return data[\"api_token\"]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_snapshots(self, volumes, **kwargs):\n        data = {\"source\": volumes, \"snap\": True}\n        data.update(kwargs)\n        return self._request(\"POST\", \"volume\", data)", "response": "Create snapshots of the listed volumes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_volume(self, volume, size, **kwargs):\n        data = {\"size\": size}\n        data.update(kwargs)\n        return self._request(\"POST\", \"volume/{0}\".format(volume), data)", "response": "Create a new volume and return a dictionary describing it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextending a specific volume to a new size.", "response": "def extend_volume(self, volume, size):\n        \"\"\"Extend a volume to a new, larger size.\n\n        :param volume: Name of the volume to be extended.\n        :type volume: str\n        :type size: int or str\n        :param size: Size in bytes, or string representing the size of the\n                     volume to be created.\n\n        :returns: A dictionary mapping \"name\" to volume and \"size\" to the volume's\n                  new size in bytes.\n        :rtype: ResponseDict\n\n        .. note::\n\n            The new size must be larger than the volume's old size.\n\n        .. note::\n\n            The maximum volume size supported is 4 petabytes (4 * 2^50).\n\n        .. note::\n\n            If size is an int, it must be a multiple of 512.\n\n        .. note::\n\n           If size is a string, it  must consist of an integer followed by a\n           valid suffix.\n\n        Accepted Suffixes\n\n        ====== ======== ======\n        Suffix Size     Bytes\n        ====== ======== ======\n        S      Sector   (2^9)\n        K      Kilobyte (2^10)\n        M      Megabyte (2^20)\n        G      Gigabyte (2^30)\n        T      Terabyte (2^40)\n        P      Petabyte (2^50)\n        ====== ======== ======\n\n        \"\"\"\n        return self.set_volume(volume, size=size, truncate=False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef truncate_volume(self, volume, size):\n        return self.set_volume(volume, size=size, truncate=True)", "response": "Truncate a specific entry in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_host(self, host, volume, **kwargs):\n        return self._request(\n            \"POST\", \"host/{0}/volume/{1}\".format(host, volume), kwargs)", "response": "Create a connection between a host and a volume."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a shared connection between a host group and a volume.", "response": "def connect_hgroup(self, hgroup, volume, **kwargs):\n        \"\"\"Create a shared connection between a host group and a volume.\n\n        :param hgroup: Name of hgroup to connect to volume.\n        :type hgroup: str\n        :param volume: Name of volume to connect to hgroup.\n        :type volume: str\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **POST hgroup/:hgroup/volume/:volume**\n        :type \\*\\*kwargs: optional\n\n        :returns: A dictionary describing the connection between the hgroup and volume.\n        :rtype: ResponseDict\n\n        \"\"\"\n        return self._request(\n            \"POST\", \"hgroup/{0}/volume/{1}\".format(hgroup, volume), kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_offload(self, name, **kwargs):\n        # Unbox if a list to accommodate a bug in REST 1.14\n        result = self._request(\"GET\", \"offload/{0}\".format(name), kwargs)\n        if isinstance(result, list):\n            headers = result.headers\n            result = ResponseDict(result[0])\n            result.headers = headers\n        return result", "response": "Returns a dictionary describing the connected offload target."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a subnet. :param subnet: Name of subnet to be created. :type subnet: str :param prefix: Routing prefix of subnet to be created. :type prefix: str :param \\*\\*kwargs: See the REST API Guide on your array for the documentation on the request: **POST subnet/:subnet** :type \\*\\*kwargs: optional :returns: A dictionary describing the created subnet. :rtype: ResponseDict .. note:: prefix should be specified as an IPv4 CIDR address. (\"xxx.xxx.xxx.xxx/nn\", representing prefix and prefix length) .. note:: Requires use of REST API 1.5 or later.", "response": "def create_subnet(self, subnet, prefix, **kwargs):\n        \"\"\"Create a subnet.\n\n        :param subnet: Name of subnet to be created.\n        :type subnet: str\n        :param prefix: Routing prefix of subnet to be created.\n        :type prefix: str\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **POST subnet/:subnet**\n        :type \\*\\*kwargs: optional\n\n        :returns: A dictionary describing the created subnet.\n        :rtype: ResponseDict\n\n        .. note::\n\n            prefix should be specified as an IPv4 CIDR address.\n            (\"xxx.xxx.xxx.xxx/nn\", representing prefix and prefix length)\n\n        .. note::\n\n            Requires use of REST API 1.5 or later.\n\n        \"\"\"\n        data = {\"prefix\": prefix}\n        data.update(kwargs)\n        return self._request(\"POST\", \"subnet/{0}\".format(subnet), data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_vlan_interface(self, interface, subnet, **kwargs):\n        data = {\"subnet\": subnet}\n        data.update(kwargs)\n        return self._request(\"POST\", \"network/vif/{0}\".format(interface), data)", "response": "Create a vlan interface."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_password(self, admin, new_password, old_password):\n        return self.set_admin(admin, password=new_password,\n                              old_password=old_password)", "response": "Set an admin s password."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable the directory service.", "response": "def disable_directory_service(self, check_peer=False):\n        \"\"\"Disable the directory service.\n\n        :param check_peer: If True, disables server authenticity\n                           enforcement. If False, disables directory\n                           service integration.\n        :type check_peer: bool, optional\n\n        :returns: A dictionary describing the status of the directory service.\n        :rtype: ResponseDict\n\n        \"\"\"\n        if check_peer:\n            return self.set_directory_service(check_peer=False)\n        return self.set_directory_service(enabled=False)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef enable_directory_service(self, check_peer=False):\n        if check_peer:\n            return self.set_directory_service(check_peer=True)\n        return self.set_directory_service(enabled=True)", "response": "Enable the directory service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_snmp_manager(self, manager, host, **kwargs):\n        data = {\"host\": host}\n        data.update(kwargs)\n        return self._request(\"POST\", \"snmp/{0}\".format(manager), data)", "response": "Create an SNMP manager."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_array(self, address, connection_key, connection_type, **kwargs):\n        data = {\"management_address\": address,\n                \"connection_key\": connection_key,\n                \"type\": connection_type}\n        data.update(kwargs)\n        return self._request(\"POST\", \"array/connection\", data)", "response": "Connect this array with another one."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_pgroup_snapshot(self, source, **kwargs):\n        # In REST 1.4, support was added for snapshotting multiple pgroups. As a\n        # result, the endpoint response changed from an object to an array of\n        # objects. To keep the  response type consistent between REST versions,\n        # we unbox the response when creating a single snapshot.\n        result = self.create_pgroup_snapshots([source], **kwargs)\n        if self._rest_version >= LooseVersion(\"1.4\"):\n            headers = result.headers\n            result = ResponseDict(result[0])\n            result.headers = headers\n        return result", "response": "Create a snapshot of a pgroup from a source."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending an existing pgroup snapshot to target ( s )", "response": "def send_pgroup_snapshot(self, source, **kwargs):\n        \"\"\" Send an existing pgroup snapshot to target(s)\n\n        :param source: Name of pgroup snapshot to send.\n        :type source: str\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **POST pgroup**\n        :type \\*\\*kwargs: optional\n\n        :returns: A list of dictionaries describing the sent snapshots.\n        :rtype: ResponseList\n\n        .. note::\n\n            Requires use of REST API 1.16 or later.\n\n        \"\"\"\n        data = {\"name\": [source], \"action\":\"send\"}\n        data.update(kwargs)\n        return self._request(\"POST\", \"pgroup\", data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_pgroup_snapshots(self, sources, **kwargs):\n        data = {\"source\": sources, \"snap\": True}\n        data.update(kwargs)\n        return self._request(\"POST\", \"pgroup\", data)", "response": "Create snapshots of pgroups from specified sources."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eradicate_pgroup(self, pgroup, **kwargs):\n        eradicate = {\"eradicate\": True}\n        eradicate.update(kwargs)\n        return self._request(\"DELETE\", \"pgroup/{0}\".format(pgroup), eradicate)", "response": "Eradicate a destroyed pgroup."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncloning an existing pod to a new one.", "response": "def clone_pod(self, source, dest, **kwargs):\n        \"\"\"Clone an existing pod to a new one.\n\n        :param source: Name of the pod the be cloned.\n        :type source: str\n        :param dest: Name of the target pod to clone into\n        :type dest: str\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **POST pod/:pod**\n        :type \\*\\*kwargs: optional\n\n        :returns: A dictionary describing the created pod\n        :rtype: ResponseDict\n\n        .. note::\n\n            Requires use of REST API 1.13 or later.\n        \"\"\"\n        data = {\"source\": source}\n        data.update(kwargs)\n        return self._request(\"POST\", \"pod/{0}\".format(dest), data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the array from a pod.", "response": "def remove_pod(self, pod, array, **kwargs):\n        \"\"\"Remove arrays from a pod.\n\n        :param pod: Name of the pod.\n        :type pod: str\n        :param array: Array to remove from pod.\n        :type array: str\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **DELETE pod/:pod**/array/:array**\n        :type \\*\\*kwargs: optional\n        :returns: A dictionary mapping \"name\" to pod and \"array\" to the pod's\n                  new array list.\n        :rtype: ResponseDict\n\n        .. note::\n\n            Requires use of REST API 1.13 or later.\n        \"\"\"\n        return self._request(\"DELETE\", \"pod/{0}/array/{1}\".format(pod, array), kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the attributes of the current array certificate.", "response": "def get_certificate(self, **kwargs):\n        \"\"\"Get the attributes of the current array certificate.\n\n        :param \\*\\*kwargs: See the REST API Guide on your array for the\n                           documentation on the request:\n                           **GET cert**\n        :type \\*\\*kwargs: optional\n\n        :returns: A dictionary describing the configured array certificate.\n        :rtype: ResponseDict\n\n        .. note::\n\n            Requires use of REST API 1.3 or later.\n\n        \"\"\"\n\n        if self._rest_version >= LooseVersion(\"1.12\"):\n            return self._request(\"GET\",\n                \"cert/{0}\".format(kwargs.pop('name', 'management')), kwargs)\n        else:\n            return self._request(\"GET\", \"cert\", kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_certificates(self):\n\n        # This call takes no parameters.\n        if self._rest_version >= LooseVersion(\"1.12\"):\n            return self._request(\"GET\", \"cert\")\n        else:\n            # If someone tries to call this against a too-early api version,\n            # do the best we can to provide expected behavior.\n            cert = self._request(\"GET\", \"cert\")\n            out = ResponseList([cert])\n            out.headers = cert.headers\n            return out", "response": "Returns a list of dictionaries describing all configured certificates."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_certificate_signing_request(self, **kwargs):\n        if self._rest_version >= LooseVersion(\"1.12\"):\n            return self._request(\"GET\",\n                \"cert/certificate_signing_request/{0}\".format(\n                    kwargs.pop('name', 'management')), kwargs)\n        else:\n            return self._request(\"GET\", \"cert/certificate_signing_request\", kwargs)", "response": "Construct a certificate signing request for the specified certificate authority."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_certificate(self, **kwargs):\n        if self._rest_version >= LooseVersion(\"1.12\"):\n            return self._request(\"PUT\",\n                \"cert/{0}\".format(kwargs.pop('name', 'management')), kwargs)\n        else:\n            return self._request(\"PUT\", \"cert\", kwargs)", "response": "Modify an existing certificate creating a new self signed one or importing a certificate signed by a certificate authority."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an iterator over all pages of a REST API operation.", "response": "def page_through(page_size, function, *args, **kwargs):\n        \"\"\"Return an iterator over all pages of a REST operation.\n\n        :param page_size: Number of elements to retrieve per call.\n        :param function: FlashArray function that accepts limit as an argument.\n        :param \\*args: Positional arguments to be passed to function.\n        :param \\*\\*kwargs: Keyword arguments to be passed to function.\n\n        :returns: An iterator of tuples containing a page of results for the\n                  function(\\*args, \\*\\*kwargs) and None, or None and a PureError\n                  if a call to retrieve a page fails.\n        :rtype: iterator\n\n        .. note::\n\n            Requires use of REST API 1.7 or later.\n\n            Only works with functions that accept limit as an argument.\n\n            Iterator will retrieve page_size elements per call\n\n            Iterator will yield None and an error if a call fails. The next\n            call will repeat the same call, unless the caller sends in an\n            alternate page token.\n\n        \"\"\"\n\n        kwargs[\"limit\"] = page_size\n\n        def get_page(token):\n            page_kwargs = kwargs.copy()\n            if token:\n                page_kwargs[\"token\"] = token\n            return function(*args, **page_kwargs)\n\n        def page_generator():\n            token = None\n            while True:\n                try:\n                    response = get_page(token)\n                    token = response.headers.get(\"x-next-token\")\n                except PureError as err:\n                    yield None, err\n                else:\n                    if response:\n                        sent_token = yield response, None\n                        if sent_token is not None:\n                            token = sent_token\n                    else:\n                        return\n\n        return page_generator()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_file_attr(filename, attr):\n        if sys.platform != 'win32':\n            # mode operations are meaningless on win32\n            if attr._flags & attr.FLAG_PERMISSIONS:\n                os.chmod(filename, attr.st_mode)\n            if attr._flags & attr.FLAG_UIDGID:\n                os.chown(filename, attr.st_uid, attr.st_gid)\n        if attr._flags & attr.FLAG_AMTIME:\n            os.utime(filename, (attr.st_atime, attr.st_mtime))\n        if attr._flags & attr.FLAG_SIZE:\n            open(filename, 'w+').truncate(attr.st_size)", "response": "Change a file s attributes on the local filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_all(self, n, check_rekey=False):\n        out = ''\n        # handle over-reading from reading the banner line\n        if len(self.__remainder) > 0:\n            out = self.__remainder[:n]\n            self.__remainder = self.__remainder[n:]\n            n -= len(out)\n        if PY22:\n            return self._py22_read_all(n, out)\n        while n > 0:\n            got_timeout = False\n            try:\n                x = self.__socket.recv(n)\n                if len(x) == 0:\n                    raise EOFError()\n                out += x\n                n -= len(x)\n            except socket.timeout:\n                got_timeout = True\n            except socket.error, e:\n                # on Linux, sometimes instead of socket.timeout, we get\n                # EAGAIN.  this is a bug in recent (> 2.6.9) kernels but\n                # we need to work around it.\n                if (type(e.args) is tuple) and (len(e.args) > 0) and (e.args[0] == errno.EAGAIN):\n                    got_timeout = True\n                elif (type(e.args) is tuple) and (len(e.args) > 0) and (e.args[0] == errno.EINTR):\n                    # syscall interrupted; try again\n                    pass\n                elif self.__closed:\n                    raise EOFError()\n                else:\n                    raise\n            if got_timeout:\n                if self.__closed:\n                    raise EOFError()\n                if check_rekey and (len(out) == 0) and self.__need_rekey:\n                    raise NeedRekeyException()\n                self._check_keepalive()\n        return out", "response": "Read all the bytes from the socket as long as possible blocking as long as necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readline(self, timeout):\n        buf = self.__remainder\n        while not '\\n' in buf:\n            buf += self._read_timeout(timeout)\n        n = buf.index('\\n')\n        self.__remainder = buf[n+1:]\n        buf = buf[:n]\n        if (len(buf) > 0) and (buf[-1] == '\\r'):\n            buf = buf[:-1]\n        return buf", "response": "Read a line from the socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a message to the SSH server.", "response": "def send_message(self, data):\n        \"\"\"\n        Write a block of data using the current cipher, as an SSH block.\n        \"\"\"\n        # encrypt this sucka\n        data = str(data)\n        cmd = ord(data[0])\n        if cmd in MSG_NAMES:\n            cmd_name = MSG_NAMES[cmd]\n        else:\n            cmd_name = '$%x' % cmd\n        orig_len = len(data)\n        self.__write_lock.acquire()\n        try:\n            if self.__compress_engine_out is not None:\n                data = self.__compress_engine_out(data)\n            packet = self._build_packet(data)\n            if self.__dump_packets:\n                self._log(DEBUG, 'Write packet <%s>, length %d' % (cmd_name, orig_len))\n                self._log(DEBUG, util.format_binary(packet, 'OUT: '))\n            if self.__block_engine_out != None:\n                out = self.__block_engine_out.encrypt(packet)\n            else:\n                out = packet\n            # + mac\n            if self.__block_engine_out != None:\n                payload = struct.pack('>I', self.__sequence_number_out) + packet\n                out += compute_hmac(self.__mac_key_out, payload, self.__mac_engine_out)[:self.__mac_size_out]\n            self.__sequence_number_out = (self.__sequence_number_out + 1) & 0xffffffffL\n            self.write_all(out)\n\n            self.__sent_bytes += len(out)\n            self.__sent_packets += 1\n            if ((self.__sent_packets >= self.REKEY_PACKETS) or (self.__sent_bytes >= self.REKEY_BYTES)) \\\n                   and not self.__need_rekey:\n                # only ask once for rekeying\n                self._log(DEBUG, 'Rekeying (hit %d packets, %d bytes sent)' %\n                          (self.__sent_packets, self.__sent_bytes))\n                self.__received_bytes_overflow = 0\n                self.__received_packets_overflow = 0\n                self._trigger_rekey()\n        finally:\n            self.__write_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_message(self):\n        header = self.read_all(self.__block_size_in, check_rekey=True)\n        if self.__block_engine_in != None:\n            header = self.__block_engine_in.decrypt(header)\n        if self.__dump_packets:\n            self._log(DEBUG, util.format_binary(header, 'IN: '));\n        packet_size = struct.unpack('>I', header[:4])[0]\n        # leftover contains decrypted bytes from the first block (after the length field)\n        leftover = header[4:]\n        if (packet_size - len(leftover)) % self.__block_size_in != 0:\n            raise SSHException('Invalid packet blocking')\n        buf = self.read_all(packet_size + self.__mac_size_in - len(leftover))\n        packet = buf[:packet_size - len(leftover)]\n        post_packet = buf[packet_size - len(leftover):]\n        if self.__block_engine_in != None:\n            packet = self.__block_engine_in.decrypt(packet)\n        if self.__dump_packets:\n            self._log(DEBUG, util.format_binary(packet, 'IN: '));\n        packet = leftover + packet\n\n        if self.__mac_size_in > 0:\n            mac = post_packet[:self.__mac_size_in]\n            mac_payload = struct.pack('>II', self.__sequence_number_in, packet_size) + packet\n            my_mac = compute_hmac(self.__mac_key_in, mac_payload, self.__mac_engine_in)[:self.__mac_size_in]\n            if my_mac != mac:\n                raise SSHException('Mismatched MAC')\n        padding = ord(packet[0])\n        payload = packet[1:packet_size - padding]\n        \n        if self.__dump_packets:\n            self._log(DEBUG, 'Got payload (%d bytes, %d padding)' % (packet_size, padding))\n\n        if self.__compress_engine_in is not None:\n            payload = self.__compress_engine_in(payload)\n\n        msg = Message(payload[1:])\n        msg.seqno = self.__sequence_number_in\n        self.__sequence_number_in = (self.__sequence_number_in + 1) & 0xffffffffL\n\n        # check for rekey\n        raw_packet_size = packet_size + self.__mac_size_in + 4\n        self.__received_bytes += raw_packet_size\n        self.__received_packets += 1\n        if self.__need_rekey:\n            # we've asked to rekey -- give them some packets to comply before\n            # dropping the connection\n            self.__received_bytes_overflow += raw_packet_size\n            self.__received_packets_overflow += 1\n            if (self.__received_packets_overflow >= self.REKEY_PACKETS_OVERFLOW_MAX) or \\\n               (self.__received_bytes_overflow >= self.REKEY_BYTES_OVERFLOW_MAX):\n                raise SSHException('Remote transport is ignoring rekey requests')\n        elif (self.__received_packets >= self.REKEY_PACKETS) or \\\n             (self.__received_bytes >= self.REKEY_BYTES):\n            # only ask once for rekeying\n            self._log(DEBUG, 'Rekeying (hit %d packets, %d bytes received)' %\n                      (self.__received_packets, self.__received_bytes))\n            self.__received_bytes_overflow = 0\n            self.__received_packets_overflow = 0\n            self._trigger_rekey()\n\n        cmd = ord(payload[0])\n        if cmd in MSG_NAMES:\n            cmd_name = MSG_NAMES[cmd]\n        else:\n            cmd_name = '$%x' % cmd\n        if self.__dump_packets:\n            self._log(DEBUG, 'Read packet <%s>, length %d' % (cmd_name, len(payload)))\n        return cmd, msg", "response": "Reads a message from the transport and returns the message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_tarball(base_name, base_dir, compress='gzip',\n                 verbose=False, dry_run=False):\n    \"\"\"Create a tar file from all the files under 'base_dir'.\n    This file may be compressed.\n\n    :param compress: Compression algorithms. Supported algorithms are:\n        'gzip': (the default)\n        'compress'\n        'bzip2'\n        None\n    For 'gzip' and 'bzip2' the internal tarfile module will be used.\n    For 'compress' the .tar will be created using tarfile, and then\n    we will spawn 'compress' afterwards.\n    The output tar file will be named 'base_name' + \".tar\", \n    possibly plus the appropriate compression extension (\".gz\",\n    \".bz2\" or \".Z\").  Return the output filename.\n    \"\"\"\n    # XXX GNU tar 1.13 has a nifty option to add a prefix directory.\n    # It's pretty new, though, so we certainly can't require it --\n    # but it would be nice to take advantage of it to skip the\n    # \"create a tree of hardlinks\" step!  (Would also be nice to\n    # detect GNU tar to use its 'z' option and save a step.)\n\n    compress_ext = { 'gzip': \".gz\",\n                     'bzip2': '.bz2',\n                     'compress': \".Z\" }\n\n    # flags for compression program, each element of list will be an argument\n    tarfile_compress_flag = {'gzip':'gz', 'bzip2':'bz2'}\n    compress_flags = {'compress': [\"-f\"]}\n\n    if compress is not None and compress not in compress_ext.keys():\n        raise ValueError(\"bad value for 'compress': must be None, 'gzip',\"\n                         \"'bzip2' or 'compress'\")\n\n    archive_name = base_name + \".tar\"\n    if compress and compress in tarfile_compress_flag:\n        archive_name += compress_ext[compress]\n\n    mode = 'w:' + tarfile_compress_flag.get(compress, '')\n\n    mkpath(os.path.dirname(archive_name), dry_run=dry_run)\n    log.info('Creating tar file %s with mode %s' % (archive_name, mode))\n\n    if not dry_run:\n        tar = tarfile.open(archive_name, mode=mode)\n        # This recursively adds everything underneath base_dir\n        tar.add(base_dir)\n        tar.close()\n\n    if compress and compress not in tarfile_compress_flag:\n        spawn([compress] + compress_flags[compress] + [archive_name],\n              dry_run=dry_run)\n        return archive_name + compress_ext[compress]\n    else:\n        return archive_name", "response": "Create a tar file from all the files under base_dir."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending an interactive request to the server.", "response": "def auth_interactive(self, username, handler, event, submethods=''):\n        \"\"\"\n        response_list = handler(title, instructions, prompt_list)\n        \"\"\"\n        self.transport.lock.acquire()\n        try:\n            self.auth_event = event\n            self.auth_method = 'keyboard-interactive'\n            self.username = username\n            self.interactive_handler = handler\n            self.submethods = submethods\n            self._request_auth()\n        finally:\n            self.transport.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_line(cls, line):\n        fields = line.split(' ')\n        if len(fields) < 3:\n            # Bad number of fields\n            return None\n        fields = fields[:3]\n\n        names, keytype, key = fields\n        names = names.split(',')\n\n        # Decide what kind of key we're looking at and create an object\n        # to hold it accordingly.\n        try:\n            if keytype == 'ssh-rsa':\n                key = RSAKey(data=base64.decodestring(key))\n            elif keytype == 'ssh-dss':\n                key = DSSKey(data=base64.decodestring(key))\n            else:\n                return None\n        except binascii.Error, e:\n            raise InvalidHostKey(line, e)\n\n        return cls(names, key)", "response": "Parses a line of text to find the names for the host the type of key and the key data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string in OpenSSH known_hosts file format or None if the object is not in a valid state.", "response": "def to_line(self):\n        \"\"\"\n        Returns a string in OpenSSH known_hosts file format, or None if\n        the object is not in a valid state.  A trailing newline is\n        included.\n        \"\"\"\n        if self.valid:\n            return '%s %s %s\\n' % (','.join(self.hostnames), self.key.get_name(),\n                   self.key.get_base64())\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self, filename):\n        f = open(filename, 'r')\n        for line in f:\n            line = line.strip()\n            if (len(line) == 0) or (line[0] == '#'):\n                continue\n            e = HostKeyEntry.from_line(line)\n            if e is not None:\n                self._entries.append(e)\n        f.close()", "response": "Load a file of known SSH host keys from a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the host keys into a file.", "response": "def save(self, filename):\n        \"\"\"\n        Save host keys into a file, in the format used by openssh.  The order of\n        keys in the file will be preserved when possible (if these keys were\n        loaded from a file originally).  The single exception is that combined\n        lines will be split into individual key lines, which is arguably a bug.\n\n        @param filename: name of the file to write\n        @type filename: str\n\n        @raise IOError: if there was an error writing the file\n\n        @since: 1.6.1\n        \"\"\"\n        f = open(filename, 'w')\n        for e in self._entries:\n            line = e.to_line()\n            if line:\n                f.write(line)\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds a hostkey entry for a given hostname or IP. If no entry is found, C{None} is returned. Otherwise a dictionary of keytype to key is returned. The keytype will be either C{\"ssh-rsa\"} or C{\"ssh-dss\"}. @param hostname: the hostname (or IP) to lookup @type hostname: str @return: keys associated with this host (or C{None}) @rtype: dict(str, L{PKey})", "response": "def lookup(self, hostname):\n        \"\"\"\n        Find a hostkey entry for a given hostname or IP.  If no entry is found,\n        C{None} is returned.  Otherwise a dictionary of keytype to key is\n        returned.  The keytype will be either C{\"ssh-rsa\"} or C{\"ssh-dss\"}.\n\n        @param hostname: the hostname (or IP) to lookup\n        @type hostname: str\n        @return: keys associated with this host (or C{None})\n        @rtype: dict(str, L{PKey})\n        \"\"\"\n        class SubDict (UserDict.DictMixin):\n            def __init__(self, hostname, entries, hostkeys):\n                self._hostname = hostname\n                self._entries = entries\n                self._hostkeys = hostkeys\n\n            def __getitem__(self, key):\n                for e in self._entries:\n                    if e.key.get_name() == key:\n                        return e.key\n                raise KeyError(key)\n\n            def __setitem__(self, key, val):\n                for e in self._entries:\n                    if e.key is None:\n                        continue\n                    if e.key.get_name() == key:\n                        # replace\n                        e.key = val\n                        break\n                else:\n                    # add a new one\n                    e = HostKeyEntry([hostname], val)\n                    self._entries.append(e)\n                    self._hostkeys._entries.append(e)\n\n            def keys(self):\n                return [e.key.get_name() for e in self._entries if e.key is not None]\n\n        entries = []\n        for e in self._entries:\n            for h in e.hostnames:\n                if (h.startswith('|1|') and (self.hash_host(hostname, h) == h)) or (h == hostname):\n                    entries.append(e)\n        if len(entries) == 0:\n            return None\n        return SubDict(hostname, entries, self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(self, hostname, key):\n        k = self.lookup(hostname)\n        if k is None:\n            return False\n        host_key = k.get(key.get_name(), None)\n        if host_key is None:\n            return False\n        return str(host_key) == str(key)", "response": "Check if the given key is associated with the given hostname in this dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hash_host(hostname, salt=None):\n        if salt is None:\n            salt = rng.read(SHA.digest_size)\n        else:\n            if salt.startswith('|1|'):\n                salt = salt.split('|')[2]\n            salt = base64.decodestring(salt)\n        assert len(salt) == SHA.digest_size\n        hmac = HMAC.HMAC(salt, hostname, SHA).digest()\n        hostkey = '|1|%s|%s' % (base64.encodestring(salt), base64.encodestring(hmac))\n        return hostkey.replace('\\n', '')", "response": "Return a hashed form of the hostname"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nturn a normalized byte string into a long - int ( adapted from Crypto. Util. number", "response": "def inflate_long(s, always_positive=False):\n    \"turns a normalized byte string into a long-int (adapted from Crypto.Util.number)\"\n    out = 0L\n    negative = 0\n    if not always_positive and (len(s) > 0) and (ord(s[0]) >= 0x80):\n        negative = 1\n    if len(s) % 4:\n        filler = '\\x00'\n        if negative:\n            filler = '\\xff'\n        s = filler * (4 - len(s) % 4) + s\n    for i in range(0, len(s), 4):\n        out = (out << 32) + struct.unpack('>I', s[i:i+4])[0]\n    if negative:\n        out -= (1L << (8 * len(s)))\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nturn a long - int into a normalized byte string (adapted from Crypto. Util. number", "response": "def deflate_long(n, add_sign_padding=True):\n    \"turns a long-int into a normalized byte string (adapted from Crypto.Util.number)\"\n    # after much testing, this algorithm was deemed to be the fastest\n    s = ''\n    n = long(n)\n    while (n != 0) and (n != -1):\n        s = struct.pack('>I', n & 0xffffffffL) + s\n        n = n >> 32\n    # strip off leading zeros, FFs\n    for i in enumerate(s):\n        if (n == 0) and (i[1] != '\\000'):\n            break\n        if (n == -1) and (i[1] != '\\xff'):\n            break\n    else:\n        # degenerate case, n was either 0 or -1\n        i = (0,)\n        if n == 0:\n            s = '\\000'\n        else:\n            s = '\\xff'\n    s = s[i[0]:]\n    if add_sign_padding:\n        if (n == 0) and (ord(s[0]) >= 0x80):\n            s = '\\x00' + s\n        if (n == -1) and (ord(s[0]) < 0x80):\n            s = '\\xff' + s\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a password, passphrase, or other human-source key, scramble it through a secure hash into some keyworthy bytes. This specific algorithm is used for encrypting/decrypting private key files. @param hashclass: class from L{Crypto.Hash} that can be used as a secure hashing function (like C{MD5} or C{SHA}). @type hashclass: L{Crypto.Hash} @param salt: data to salt the hash with. @type salt: string @param key: human-entered password or passphrase. @type key: string @param nbytes: number of bytes to generate. @type nbytes: int @return: key data @rtype: string", "response": "def generate_key_bytes(hashclass, salt, key, nbytes):\n    \"\"\"\n    Given a password, passphrase, or other human-source key, scramble it\n    through a secure hash into some keyworthy bytes.  This specific algorithm\n    is used for encrypting/decrypting private key files.\n\n    @param hashclass: class from L{Crypto.Hash} that can be used as a secure\n        hashing function (like C{MD5} or C{SHA}).\n    @type hashclass: L{Crypto.Hash}\n    @param salt: data to salt the hash with.\n    @type salt: string\n    @param key: human-entered password or passphrase.\n    @type key: string\n    @param nbytes: number of bytes to generate.\n    @type nbytes: int\n    @return: key data\n    @rtype: string\n    \"\"\"\n    keydata = ''\n    digest = ''\n    if len(salt) > 8:\n        salt = salt[:8]\n    while nbytes > 0:\n        hash_obj = hashclass.new()\n        if len(digest) > 0:\n            hash_obj.update(digest)\n        hash_obj.update(key)\n        hash_obj.update(salt)\n        digest = hash_obj.digest()\n        size = min(nbytes, len(digest))\n        keydata += digest[:size]\n        nbytes -= size\n    return keydata"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretry function until it doesn t raise an EINTR error", "response": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a new private RSA key. This factory function can be used to generate a new host key or authentication key. @param bits: number of bits the generated key should be. @type bits: int @param progress_func: an optional function to call at key points in key generation (used by C{pyCrypto.PublicKey}). @type progress_func: function @return: new private key @rtype: L{RSAKey}", "response": "def generate(bits, progress_func=None):\n        \"\"\"\n        Generate a new private RSA key.  This factory function can be used to\n        generate a new host key or authentication key.\n\n        @param bits: number of bits the generated key should be.\n        @type bits: int\n        @param progress_func: an optional function to call at key points in\n            key generation (used by C{pyCrypto.PublicKey}).\n        @type progress_func: function\n        @return: new private key\n        @rtype: L{RSAKey}\n        \"\"\"\n        rsa = RSA.generate(bits, rng.read, progress_func)\n        key = RSAKey(vals=(rsa.e, rsa.n))\n        key.d = rsa.d\n        key.p = rsa.p\n        key.q = rsa.q\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a data string to a 20 - byte SHA1 hash.", "response": "def _pkcs1imify(self, data):\n        \"\"\"\n        turn a 20-byte SHA1 hash into a blob of data as large as the key's N,\n        using PKCS1's \\\"emsa-pkcs1-v1_5\\\" encoding.  totally bizarre.\n        \"\"\"\n        SHA1_DIGESTINFO = '\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n        size = len(util.deflate_long(self.n, 0))\n        filler = '\\xff' * (size - len(SHA1_DIGESTINFO) - len(data) - 3)\n        return '\\x00\\x01' + filler + '\\x00' + SHA1_DIGESTINFO + data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a new private DSS key. This factory function can be used to generate a new host key or authentication key. @param bits: number of bits the generated key should be. @type bits: int @param progress_func: an optional function to call at key points in key generation (used by C{pyCrypto.PublicKey}). @type progress_func: function @return: new private key @rtype: L{DSSKey}", "response": "def generate(bits=1024, progress_func=None):\n        \"\"\"\n        Generate a new private DSS key.  This factory function can be used to\n        generate a new host key or authentication key.\n\n        @param bits: number of bits the generated key should be.\n        @type bits: int\n        @param progress_func: an optional function to call at key points in\n            key generation (used by C{pyCrypto.PublicKey}).\n        @type progress_func: function\n        @return: new private key\n        @rtype: L{DSSKey}\n        \"\"\"\n        dsa = DSA.generate(bits, rng.read, progress_func)\n        key = DSSKey(vals=(dsa.p, dsa.q, dsa.g, dsa.y))\n        key.x = dsa.x\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, file_obj):\n        configs = [self._config[0]]\n        for line in file_obj:\n            line = line.rstrip('\\n').lstrip()\n            if (line == '') or (line[0] == '#'):\n                continue\n            if '=' in line:\n                key, value = line.split('=', 1)\n                key = key.strip().lower()\n            else:\n                # find first whitespace, and split there\n                i = 0\n                while (i < len(line)) and not line[i].isspace():\n                    i += 1\n                if i == len(line):\n                    raise Exception('Unparsable line: %r' % line)\n                key = line[:i].lower()\n                value = line[i:].lstrip()\n\n            if key == 'host':\n                del configs[:]\n                # the value may be multiple hosts, space-delimited\n                for host in value.split():\n                    # do we have a pre-existing host config to append to?\n                    matches = [c for c in self._config if c['host'] == host]\n                    if len(matches) > 0:\n                        configs.append(matches[0])\n                    else:\n                        config = { 'host': host }\n                        self._config.append(config)\n                        configs.append(config)\n            else:\n                for config in configs:\n                    config[key] = value", "response": "Read an OpenSSH config file from the given file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dict of config options for a given hostname.", "response": "def lookup(self, hostname):\n        \"\"\"\n        Return a dict of config options for a given hostname.\n\n        The host-matching rules of OpenSSH's C{ssh_config} man page are used,\n        which means that all configuration options from matching host\n        specifications are merged, with more specific hostmasks taking\n        precedence. In other words, if C{\"Port\"} is set under C{\"Host *\"}\n        and also C{\"Host *.example.com\"}, and the lookup is for\n        C{\"ssh.example.com\"}, then the port entry for C{\"Host *.example.com\"}\n        will win out.\n\n        The keys in the returned dict are all normalized to lowercase (look for\n        C{\"port\"}, not C{\"Port\"}. No other processing is done to the keys or\n        values.\n\n        @param hostname: the hostname to lookup\n        @type hostname: str\n        \"\"\"\n        matches = [x for x in self._config if fnmatch.fnmatch(hostname, x['host'])]\n        # Move * to the end\n        _star = matches.pop(0)\n        matches.append(_star)\n        ret = {}\n        for m in matches:\n            for k,v in m.iteritems():\n                if not k in ret:\n                    ret[k] = v\n        ret = self._expand_variables(ret, hostname)\n        del ret['host']\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexpanding the variables that are set in the config dictionary.", "response": "def _expand_variables(self, config, hostname ):\n        \"\"\"\n        Return a dict of config options with expanded substitutions\n        for a given hostname.\n\n        Please refer to man ssh_config(5) for the parameters that\n        are replaced.\n\n        @param config: the config for the hostname\n        @type hostname: dict\n        @param hostname: the hostname that the config belongs to\n        @type hostname: str\n        \"\"\"\n\n        if 'hostname' in config:\n            config['hostname'] = config['hostname'].replace('%h',hostname)\n        else:\n            config['hostname'] = hostname\n\n        if 'port' in config:\n            port = config['port']\n        else:\n            port = SSH_PORT\n\n        user = os.getenv('USER')\n        if 'user' in config:\n            remoteuser = config['user']\n        else:\n            remoteuser = user\n\n        host = socket.gethostname().split('.')[0]\n        fqdn = socket.getfqdn()\n        homedir = os.path.expanduser('~')\n        replacements = {'controlpath' :\n                [\n                    ('%h', config['hostname']),\n                    ('%l', fqdn),\n                    ('%L', host),\n                    ('%n', hostname),\n                    ('%p', port),\n                    ('%r', remoteuser),\n                    ('%u', user)\n                ],\n                'identityfile' :\n                [\n                    ('~', homedir),\n                    ('%d', homedir),\n                    ('%h', config['hostname']),\n                    ('%l', fqdn),\n                    ('%u', user),\n                    ('%r', remoteuser)\n                ]\n                }\n        for k in config:\n            if k in replacements:\n                for find, replace in replacements[k]:\n                        config[k] = config[k].replace(find, str(replace))\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef url(proto, server, port=None, uri=None):\n        url_parts = [proto, '://', server]\n        if port:\n            port = int(port)\n            if port < 1 or port > 65535:\n                raise ValueError('invalid port value')\n            if not ((proto == 'http' and port == 80) or\n                    (proto == 'https' and port == 443)):\n                url_parts.append(':')\n                url_parts.append(str(port))\n\n        if uri:\n            url_parts.append('/')\n            url_parts.append(requests.utils.quote(uri.strip('/')))\n\n        url_parts.append('/')\n        return ''.join(url_parts)", "response": "Construct a URL from the given components."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a URL from the specified parts.", "response": "def make_url(self, container=None, resource=None, query_items=None):\n        \"\"\"Create a URL from the specified parts.\"\"\"\n        pth = [self._base_url]\n        if container:\n            pth.append(container.strip('/'))\n        if resource:\n            pth.append(resource)\n        else:\n            pth.append('')\n        url = '/'.join(pth)\n        if isinstance(query_items, (list, tuple, set)):\n            url += RestHttp._list_query_str(query_items)\n            query_items = None\n        p = requests.PreparedRequest()\n        p.prepare_url(url, query_items)\n        return p.url"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef head_request(self, container, resource=None):\n        url = self.make_url(container, resource)\n        headers = self._make_headers(None)\n\n        try:\n            rsp = requests.head(url, headers=self._base_headers,\n                                verify=self._verify, timeout=self._timeout)\n        except requests.exceptions.ConnectionError as e:\n            RestHttp._raise_conn_error(e)\n\n        if self._dbg_print:\n            self.__print_req('HEAD', rsp.url, headers, None)\n\n        return rsp.status_code", "response": "Send a HEAD request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a POST request to the server.", "response": "def post_request(self, container, resource=None, params=None, accept=None):\n        \"\"\"Send a POST request.\"\"\"\n        url = self.make_url(container, resource)\n        headers = self._make_headers(accept)\n\n        try:\n            rsp = requests.post(url, data=params, headers=headers,\n                                verify=self._verify, timeout=self._timeout)\n        except requests.exceptions.ConnectionError as e:\n            RestHttp._raise_conn_error(e)\n\n        if self._dbg_print:\n            self.__print_req('POST', rsp.url, headers, params)\n\n        return self._handle_response(rsp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_request(self, container, resource=None, query_items=None,\n                       accept=None):\n        \"\"\"Send a DELETE request.\"\"\"\n        url = self.make_url(container, resource)\n        headers = self._make_headers(accept)\n\n        if query_items and isinstance(query_items, (list, tuple, set)):\n            url += RestHttp._list_query_str(query_items)\n            query_items = None\n\n        try:\n            rsp = requests.delete(url, params=query_items, headers=headers,\n                                  verify=self._verify, timeout=self._timeout)\n        except requests.exceptions.ConnectionError as e:\n            RestHttp._raise_conn_error(e)\n\n        if self._dbg_print:\n            self.__print_req('DELETE', rsp.url, headers, None)\n\n        return self._handle_response(rsp)", "response": "Send a DELETE request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload a file from a container.", "response": "def download_file(self, container, resource, save_path=None, accept=None,\n                      query_items=None):\n        \"\"\"Download a file.\n\n        If a timeout defined, it is not a time limit on the entire download;\n        rather, an exception is raised if the server has not issued a response\n        for timeout seconds (more precisely, if no bytes have been received on\n        the underlying socket for timeout seconds). If no timeout is specified\n        explicitly, requests do not time out.\n\n        \"\"\"\n        url = self.make_url(container, resource)\n        if not save_path:\n            save_path = resource.split('/')[-1]\n\n        headers = self._make_headers(accept)\n\n        if query_items and isinstance(query_items, (list, tuple, set)):\n            url += RestHttp._list_query_str(query_items)\n            query_items = None\n\n        try:\n            rsp = requests.get(url, query_items, headers=headers, stream=True,\n                               verify=self._verify, timeout=self._timeout)\n        except requests.exceptions.ConnectionError as e:\n            RestHttp._raise_conn_error(e)\n\n        if self._dbg_print:\n            self.__print_req('GET', rsp.url, headers, None)\n\n        if rsp.status_code >= 300:\n            raise RestHttpError(rsp.status_code, rsp.reason, rsp.text)\n\n        file_size_dl = 0\n        try:\n            with open(save_path, 'wb') as f:\n                for buff in rsp.iter_content(chunk_size=16384):\n                    f.write(buff)\n        except Exception as e:\n            raise RuntimeError('could not download file: ' + str(e))\n        finally:\n            rsp.close()\n\n        if self._dbg_print:\n            print('===> downloaded %d bytes to %s' % (file_size_dl, save_path))\n\n        return rsp.status_code, save_path, os.path.getsize(save_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload a single file to a specific container.", "response": "def upload_file(self, container, src_file_path, dst_name=None, put=True,\n                    content_type=None):\n        \"\"\"Upload a single file.\"\"\"\n        if not os.path.exists(src_file_path):\n            raise RuntimeError('file not found: ' + src_file_path)\n        if not dst_name:\n            dst_name = os.path.basename(src_file_path)\n        if not content_type:\n            content_type = \"application/octet.stream\"\n        headers = dict(self._base_headers)\n        if content_type:\n            headers[\"content-length\"] = content_type\n        else:\n            headers[\"content-length\"] = \"application/octet.stream\"\n        headers[\"content-length\"] = str(os.path.getsize(src_file_path))\n        headers['content-disposition'] = 'attachment; filename=' + dst_name\n        if put:\n            method = 'PUT'\n            url = self.make_url(container, dst_name, None)\n        else:\n            method = 'POST'\n            url = self.make_url(container, None, None)\n        with open(src_file_path, 'rb') as up_file:\n            try:\n                rsp = requests.request(method, url, headers=headers,\n                                       data=up_file, timeout=self._timeout)\n            except requests.exceptions.ConnectionError as e:\n                RestHttp._raise_conn_error(e)\n\n        return self._handle_response(rsp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nuploading a file using multi - part encoding.", "response": "def upload_file_mp(self, container, src_file_path, dst_name=None,\n                       content_type=None):\n        \"\"\"Upload a file using multi-part encoding.\"\"\"\n        if not os.path.exists(src_file_path):\n            raise RuntimeError('file not found: ' + src_file_path)\n        if not dst_name:\n            dst_name = os.path.basename(src_file_path)\n        if not content_type:\n            content_type = \"application/octet.stream\"\n        url = self.make_url(container, None, None)\n        headers = self._base_headers\n        with open(src_file_path, 'rb') as up_file:\n            files = {'file': (dst_name, up_file, content_type)}\n            try:\n                rsp = requests.post(url, headers=headers, files=files,\n                                    timeout=self._timeout)\n            except requests.exceptions.ConnectionError as e:\n                RestHttp._raise_conn_error(e)\n\n        return self._handle_response(rsp)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new session or attach to existing.", "response": "def new_session(self, server=None, session_name=None, user_name=None,\n                    existing_session=None):\n        \"\"\"Create a new session or attach to existing.\n\n        Normally, this function is called automatically, and gets its parameter\n        values from the environment.  It is provided as a public function for\n        cases when extra control over session creation is required in an\n        automation script that is adapted to use ReST.\n\n        WARNING:  This function is not part of the original StcPython.py and if\n        called directly by an automation script, then that script will not be\n        able to revert to using the non-ReST API until the call to this\n        function is removed.\n\n        Arguments:\n        server           -- STC server (Lab Server) address.  If not set get\n                            value from STC_SERVER_ADDRESS environment variable.\n        session_name     -- Name part of session ID.  If not set get value from\n                            STC_SESSION_NAME environment variable.\n        user_name        -- User portion of session ID.  If not set get name of\n                            user this script is running as.\n        existing_session -- Behavior when session already exists.  Recognized\n                            values are 'kill' and 'join'.  If not set get value\n                            from EXISTING_SESSION environment variable.  If not\n                            set to recognized value, raise exception if session\n                            already exists.\n\n        See also: stchttp.StcHttp(), stchttp.new_session()\n\n        Return:\n        The internal StcHttp object that is used for this session.  This allows\n        the caller to perform additional interactions with the STC ReST API\n        beyond what the adapter provides.\n\n        \"\"\"\n        if not server:\n            server = os.environ.get('STC_SERVER_ADDRESS')\n            if not server:\n                raise EnvironmentError('STC_SERVER_ADDRESS not set')\n        self._stc = stchttp.StcHttp(server)\n        if not session_name:\n            session_name = os.environ.get('STC_SESSION_NAME')\n            if not session_name or session_name == '__NEW_TEST_SESSION__':\n                session_name = None\n        if not user_name:\n            try:\n                # Try to get the name of the current user.\n                user_name = getpass.getuser()\n            except:\n                pass\n\n        if not existing_session:\n            # Try to get existing_session from environ if not passed in.\n            existing_session = os.environ.get('EXISTING_SESSION')\n\n        if existing_session:\n            existing_session = existing_session.lower()\n            if existing_session == 'kill':\n                # Kill any existing session and create a new one.\n                self._stc.new_session(user_name, session_name, True)\n                return self._stc\n            if existing_session == 'join':\n                # Create a new session, or join if already exists.\n                try:\n                    self._stc.new_session(user_name, session_name, False)\n                except RuntimeError as e:\n                    if str(e).find('already exists') >= 0:\n                        sid = ' - '.join((session_name, user_name))\n                        self._stc.join_session(sid)\n                    else:\n                        raise\n                return self._stc\n\n        # Create a new session, raise exception if session already exists.\n        self._stc.new_session(user_name, session_name, False)\n        return self._stc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nending the client session.", "response": "def _end_session(self, kill=None):\n        \"\"\"End the client session.\"\"\"\n        if self._stc:\n            if kill is None:\n                kill = os.environ.get('STC_SESSION_TERMINATE_ON_DISCONNECT')\n                kill = _is_true(kill)\n            self._stc.end_session(kill)\n            self._stc = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup(app):\n\n    app.add_directive('readthedocs-embed', EmbedDirective)\n    app.add_config_value('readthedocs_embed_project', '', 'html')\n    app.add_config_value('readthedocs_embed_version', '', 'html')\n    app.add_config_value('readthedocs_embed_doc', '', 'html')\n\n    return app", "response": "This is a helper function that sets up the embed directive and adds the appropriate configuration values to the application."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef finalize_media(app):\n\n    if (app.builder.name == 'readthedocssinglehtmllocalmedia' or\n            app.builder.format != 'html' or\n            not hasattr(app.builder, 'script_files')):\n        return  # Use local media for downloadable files\n    # Pull project data from conf.py if it exists\n    context = app.builder.config.html_context\n    STATIC_URL = context.get('STATIC_URL', DEFAULT_STATIC_URL)\n    js_file = '{}javascript/readthedocs-doc-embed.js'.format(STATIC_URL)\n    if sphinx.version_info < (1, 8):\n        app.builder.script_files.append(js_file)\n    else:\n        app.add_js_file(js_file)", "response": "Point media files at our media server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the Sphinx body content.", "response": "def update_body(app, pagename, templatename, context, doctree):\n    \"\"\"\n    Add Read the Docs content to Sphinx body content.\n\n    This is the most reliable way to inject our content into the page.\n    \"\"\"\n\n    STATIC_URL = context.get('STATIC_URL', DEFAULT_STATIC_URL)\n    online_builders = [\n        'readthedocs', 'readthedocsdirhtml', 'readthedocssinglehtml'\n    ]\n    if app.builder.name == 'readthedocssinglehtmllocalmedia':\n        if 'html_theme' in context and context['html_theme'] == 'sphinx_rtd_theme':\n            theme_css = '_static/css/theme.css'\n        else:\n            theme_css = '_static/css/badge_only.css'\n    elif app.builder.name in online_builders:\n        if 'html_theme' in context and context['html_theme'] == 'sphinx_rtd_theme':\n            theme_css = '%scss/sphinx_rtd_theme.css' % STATIC_URL\n        else:\n            theme_css = '%scss/badge_only.css' % STATIC_URL\n    else:\n        # Only insert on our HTML builds\n        return\n\n    inject_css = True\n\n    # Starting at v0.4.0 of the sphinx theme, the theme CSS should not be injected\n    # This decouples the theme CSS (which is versioned independently) from readthedocs.org\n    if theme_css.endswith('sphinx_rtd_theme.css'):\n        try:\n            import sphinx_rtd_theme\n            inject_css = LooseVersion(sphinx_rtd_theme.__version__) < LooseVersion('0.4.0')\n        except ImportError:\n            pass\n\n    if inject_css and theme_css not in app.builder.css_files:\n        if sphinx.version_info < (1, 8):\n            app.builder.css_files.insert(0, theme_css)\n        else:\n            app.add_css_file(theme_css)\n\n    # This is monkey patched on the signal because we can't know what the user\n    # has done with their `app.builder.templates` before now.\n\n    if not hasattr(app.builder.templates.render, '_patched'):\n        # Janky monkey patch of template rendering to add our content\n        old_render = app.builder.templates.render\n\n        def rtd_render(self, template, render_context):\n            \"\"\"\n            A decorator that renders the content with the users template renderer,\n            then adds the Read the Docs HTML content at the end of body.\n            \"\"\"\n            # Render Read the Docs content\n            template_context = render_context.copy()\n            template_context['rtd_css_url'] = '{}css/readthedocs-doc-embed.css'.format(STATIC_URL)\n            template_context['rtd_analytics_url'] = '{}javascript/readthedocs-analytics.js'.format(\n                STATIC_URL,\n            )\n            source = os.path.join(\n                os.path.abspath(os.path.dirname(__file__)),\n                '_templates',\n                'readthedocs-insert.html.tmpl'\n            )\n            templ = open(source).read()\n            rtd_content = app.builder.templates.render_string(templ, template_context)\n\n            # Handle original render function\n            content = old_render(template, render_context)\n            end_body = content.lower().find('</head>')\n\n            # Insert our content at the end of the body.\n            if end_body != -1:\n                content = content[:end_body] + rtd_content + \"\\n\" + content[end_body:]\n            else:\n                log.debug(\"File doesn't look like HTML. Skipping RTD content addition\")\n\n            return content\n\n        rtd_render._patched = True\n        app.builder.templates.render = types.MethodType(rtd_render,\n                                                        app.builder.templates)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_json_artifacts(app, pagename, templatename, context, doctree):\n    try:\n        # We need to get the output directory where the docs are built\n        # _build/json.\n        build_json = os.path.abspath(\n            os.path.join(app.outdir, '..', 'json')\n        )\n        outjson = os.path.join(build_json, pagename + '.fjson')\n        outdir = os.path.dirname(outjson)\n        if not os.path.exists(outdir):\n            os.makedirs(outdir)\n        with open(outjson, 'w+') as json_file:\n            to_context = {\n                key: context.get(key, '')\n                for key in KEYS\n            }\n            json.dump(to_context, json_file, indent=4)\n    except TypeError:\n        log.exception(\n            'Fail to encode JSON for page {page}'.format(page=outjson)\n        )\n    except IOError:\n        log.exception(\n            'Fail to save JSON output for page {page}'.format(page=outjson)\n        )\n    except Exception as e:\n        log.exception(\n            'Failure in JSON search dump for page {page}'.format(page=outjson)\n        )", "response": "Generate JSON artifacts for each page."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy and patch searchtools to _static", "response": "def _copy_searchtools(self, renderer=None):\n        \"\"\"Copy and patch searchtools\n\n        This uses the included Sphinx version's searchtools, but patches it to\n        remove automatic initialization. This is a fork of\n        ``sphinx.util.fileutil.copy_asset``\n        \"\"\"\n        log.info(bold('copying searchtools... '), nonl=True)\n\n        if sphinx.version_info < (1, 8):\n            search_js_file = 'searchtools.js_t'\n        else:\n            search_js_file = 'searchtools.js'\n        path_src = os.path.join(\n            package_dir, 'themes', 'basic', 'static', search_js_file\n        )\n        if os.path.exists(path_src):\n            path_dest = os.path.join(self.outdir, '_static', 'searchtools.js')\n            if renderer is None:\n                # Sphinx 1.4 used the renderer from the existing builder, but\n                # the pattern for Sphinx 1.5 is to pass in a renderer separate\n                # from the builder. This supports both patterns for future\n                # compatibility\n                if sphinx.version_info < (1, 5):\n                    renderer = self.templates\n                else:\n                    from sphinx.util.template import SphinxRenderer\n                    renderer = SphinxRenderer()\n            with codecs.open(path_src, 'r', encoding='utf-8') as h_src:\n                with codecs.open(path_dest, 'w', encoding='utf-8') as h_dest:\n                    data = h_src.read()\n                    data = self.REPLACEMENT_PATTERN.sub(self.REPLACEMENT_TEXT, data)\n                    h_dest.write(renderer.render_string(\n                        data,\n                        self.get_static_readthedocs_context()\n                    ))\n        else:\n            log.warning('Missing {}'.format(search_js_file))\n        log.info('done')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns dictionary of STC and API information.", "response": "def stc_system_info(stc_addr):\n    \"\"\"Return dictionary of STC and API information.\n\n    If a session already exists, then use it to get STC information and avoid\n    taking the time to start a new session.  A session is necessary to get\n    STC information.\n\n    \"\"\"\n    stc = stchttp.StcHttp(stc_addr)\n    sessions = stc.sessions()\n    if sessions:\n        # If a session already exists, use it to get STC information.\n        stc.join_session(sessions[0])\n        sys_info = stc.system_info()\n    else:\n        # Create a new session to get STC information.\n        stc.new_session('anonymous')\n        try:\n            sys_info = stc.system_info()\n        finally:\n            # Make sure the temporary session in terminated.\n            stc.end_session()\n\n    return sys_info"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_session(self, user_name=None, session_name=None,\n                    kill_existing=False, analytics=None):\n        \"\"\"Create a new test session.\n\n        The test session is identified by the specified user_name and optional\n        session_name parameters.  If a session name is not specified, then the\n        server will create one.\n\n        Arguments:\n        user_name     -- User name part of session ID.\n        session_name  -- Session name part of session ID.\n        kill_existing -- If there is an existing session, with the same session\n                         name and user name, then terminate it before creating\n                         a new session\n        analytics     -- Optional boolean value to disable or enable analytics\n                         for new session.  None will use setting configured on\n                         server.\n\n        Return:\n        True is session started, False if session was already started.\n\n        \"\"\"\n        if self.started():\n            return False\n        if not session_name or not session_name.strip():\n            session_name = ''\n        if not user_name or not user_name.strip():\n            user_name = ''\n        params = {'userid': user_name, 'sessionname': session_name}\n        if analytics not in (None, ''):\n            params['analytics'] = str(analytics).lower()\n        try:\n            status, data = self._rest.post_request('sessions', None, params)\n        except resthttp.RestHttpError as e:\n            if kill_existing and str(e).find('already exists') >= 0:\n                self.end_session('kill', ' - '.join((session_name, user_name)))\n            else:\n                raise RuntimeError('failed to create session: ' + str(e))\n\n            # Starting session\n            if self._dbg_print:\n                print('===> starting session')\n            status, data = self._rest.post_request('sessions', None, params)\n            if self._dbg_print:\n                print('===> OK, started')\n\n        sid = data['session_id']\n        if self._dbg_print:\n            print('===> session ID:', sid)\n            print('===> URL:', self._rest.make_url('sessions', sid))\n\n        self._rest.add_header('X-STC-API-Session', sid)\n        self._sid = sid\n        return sid", "response": "Creates a new test session."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattaches to an existing session.", "response": "def join_session(self, sid):\n        \"\"\"Attach to an existing session.\"\"\"\n        self._rest.add_header('X-STC-API-Session', sid)\n        self._sid = sid\n        try:\n            status, data = self._rest.get_request('objects', 'system1',\n                                                  ['version', 'name'])\n        except resthttp.RestHttpError as e:\n            self._rest.del_header('X-STC-API-Session')\n            self._sid = None\n            raise RuntimeError('failed to join session \"%s\": %s' % (sid, e))\n\n        return data['version']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef end_session(self, end_tcsession=True, sid=None):\n        if not sid or sid == self._sid:\n            if not self.started():\n                return False\n\n            sid = self._sid\n            self._sid = None\n            self._rest.del_header('X-STC-API-Session')\n\n        if end_tcsession is None:\n            if self._dbg_print:\n                print('===> detached from session')\n            return True\n\n        try:\n            if end_tcsession:\n                if self._dbg_print:\n                    print('===> deleting session:', sid)\n                if end_tcsession == 'kill':\n                    status, data = self._rest.delete_request(\n                        'sessions', sid, 'kill')\n                else:\n                    status, data = self._rest.delete_request('sessions', sid)\n                count = 0\n                while 1:\n                    time.sleep(5)\n                    if self._dbg_print:\n                        print('===> checking if session ended')\n                    ses_list = self.sessions()\n                    if not ses_list or sid not in ses_list:\n                        break\n                    count += 1\n                    if count == 3:\n                        raise RuntimeError(\"test session has not stopped\")\n\n                if self._dbg_print:\n                    print('===> ok - deleted test session')\n            else:\n                # Ending client session is supported on version >= 2.1.5\n                if self._get_api_version() < (2, 1, 5):\n                    raise RuntimeError('option no available on server')\n\n                status, data = self._rest.delete_request(\n                    'sessions', sid, 'false')\n                if self._dbg_print:\n                    print('===> OK - detached REST API from test session')\n        except resthttp.RestHttpError as e:\n            raise RuntimeError('failed to end session: ' + str(e))\n\n        return True", "response": "Ends a test session."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting information about a specific session.", "response": "def session_info(self, session_id=None):\n        \"\"\"Get information on session.\n\n        If session_id is None, the default, then return information about this\n        session.  If a session ID is given, then get information about that\n        session.\n\n        Arguments:\n        session_id -- Id of session to get info for, if not this session.\n\n        Return:\n        Dictionary of session information.\n\n        \"\"\"\n        if not session_id:\n            if not self.started():\n                return []\n            session_id = self._sid\n        status, data = self._rest.get_request('sessions', session_id)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget list of files for this session on server.", "response": "def files(self):\n        \"\"\"Get list of files, for this session, on server.\"\"\"\n        self._check_session()\n        status, data = self._rest.get_request('files')\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the BLL version this session is connected to.", "response": "def bll_version(self):\n        \"\"\"Get the BLL version this session is connected to.\n\n        Return:\n        Version string if session started.  None if session not started.\n\n        \"\"\"\n        if not self.started():\n            return None\n        status, data = self._rest.get_request('objects', 'system1',\n                                              ['version', 'name'])\n        return data['version']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, handle, *args):\n        self._check_session()\n        status, data = self._rest.get_request('objects', str(handle), args)\n        return data", "response": "Returns the value of one or more object attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new automation object.", "response": "def create(self, object_type, under=None, attributes=None, **kwattrs):\n        \"\"\"Create a new automation object.\n\n        Arguments:\n        object_type -- Type of object to create.\n        under       -- Handle of the parent of the new object.\n        attributes  -- Dictionary of attributes (name-value pairs).\n        kwattrs     -- Optional keyword attributes (name=value pairs).\n\n        Return:\n        Handle of newly created object.\n\n        \"\"\"\n        data = self.createx(object_type, under, attributes, **kwattrs)\n        return data['handle']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new automation object.", "response": "def createx(self, object_type, under=None, attributes=None, **kwattrs):\n        \"\"\"Create a new automation object.\n\n        Arguments:\n        object_type -- Type of object to create.\n        under       -- Handle of the parent of the new object.\n        attributes  -- Dictionary of attributes (name-value pairs).\n        kwattrs     -- Optional keyword attributes (name=value pairs).\n\n        Return:\n        Dictionary containing handle of newly created object.\n\n        \"\"\"\n        self._check_session()\n        params = {'object_type': object_type}\n        if under:\n            params['under'] = under\n        if attributes:\n            params.update(attributes)\n        if kwattrs:\n            params.update(kwattrs)\n\n        status, data = self._rest.post_request('objects', None, params)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(self, handle):\n        self._check_session()\n        self._rest.delete_request('objects', str(handle))", "response": "Delete the specified object from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a command. Arguments can be supplied either as a dictionary or as keyword arguments. Examples: stc.perform('LoadFromXml', {'filename':'config.xml'}) stc.perform('LoadFromXml', filename='config.xml') Arguments: command -- Command to execute. params -- Optional. Dictionary of parameters (name-value pairs). kwargs -- Optional keyword arguments (name=value pairs). Return: Data from command.", "response": "def perform(self, command, params=None, **kwargs):\n        \"\"\"Execute a command.\n\n        Arguments can be supplied either as a dictionary or as keyword\n        arguments.  Examples:\n            stc.perform('LoadFromXml', {'filename':'config.xml'})\n            stc.perform('LoadFromXml', filename='config.xml')\n\n        Arguments:\n        command -- Command to execute.\n        params  -- Optional.  Dictionary of parameters (name-value pairs).\n        kwargs  -- Optional keyword arguments (name=value pairs).\n\n        Return:\n        Data from command.\n\n        \"\"\"\n        self._check_session()\n        if not params:\n            params = {}\n        if kwargs:\n            params.update(kwargs)\n        params['command'] = command\n        status, data = self._rest.post_request('perform', None, params)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset or modifies one or more object attributes or relations.", "response": "def config(self, handle, attributes=None, **kwattrs):\n        \"\"\"Sets or modifies one or more object attributes or relations.\n\n        Arguments can be supplied either as a dictionary or as keyword\n        arguments.  Examples:\n            stc.config('port1', location='//10.1.2.3/1/1')\n            stc.config('port2', {'location': '//10.1.2.3/1/2'})\n\n        Arguments:\n        handle     -- Handle of object to modify.\n        attributes -- Dictionary of attributes (name-value pairs).\n        kwattrs    -- Optional keyword attributes (name=value pairs).\n\n        \"\"\"\n        self._check_session()\n        if kwattrs:\n            if attributes:\n                attributes.update(kwattrs)\n            else:\n                attributes = kwattrs\n        self._rest.put_request('objects', str(handle), attributes)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef chassis(self):\n        self._check_session()\n        status, data = self._rest.get_request('chassis')\n        return data", "response": "Get list of chassis known to test session."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef chassis_info(self, chassis):\n        if not chassis or not isinstance(chassis, str):\n            raise RuntimeError('missing chassis address')\n        self._check_session()\n        status, data = self._rest.get_request('chassis', chassis)\n        return data", "response": "Get information about the specified chassis."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connections(self):\n        self._check_session()\n        status, data = self._rest.get_request('connections')\n        return data", "response": "Get list of connections."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_connected(self, chassis):\n        self._check_session()\n        try:\n            status, data = self._rest.get_request('connections', chassis)\n        except resthttp.RestHttpError as e:\n            if int(e) == 404:\n                # 404 NOT FOUND means the chassis in unknown, so return false.\n                return False\n        return bool(data and data.get('IsConnected'))", "response": "Get Boolean connected status of the specified chassis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self, chassis_list):\n        self._check_session()\n        if not isinstance(chassis_list, (list, tuple, set, dict, frozenset)):\n            chassis_list = (chassis_list,)\n\n        if len(chassis_list) == 1:\n            status, data = self._rest.put_request(\n                'connections', chassis_list[0])\n            data = [data]\n        else:\n            params = {chassis: True for chassis in chassis_list}\n            params['action'] = 'connect'\n            status, data = self._rest.post_request('connections', None, params)\n        return data", "response": "Establish connection to one or more chassis."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove connection with one or more chassis.", "response": "def disconnect(self, chassis_list):\n        \"\"\"Remove connection with one or more chassis.\n\n        Arguments:\n        chassis_list -- List of chassis (IP addresses or DNS names)\n\n        \"\"\"\n        self._check_session()\n        if not isinstance(chassis_list, (list, tuple, set, dict, frozenset)):\n            chassis_list = (chassis_list,)\n\n        if len(chassis_list) == 1:\n            self._rest.delete_request('connections', chassis_list[0])\n        else:\n            params = {chassis: True for chassis in chassis_list}\n            params['action'] = 'disconnect'\n            self._rest.post_request('connections', None, params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef help(self, subject=None, args=None):\n        if subject:\n            if subject not in (\n                'commands', 'create', 'config', 'get', 'delete', 'perform',\n                'connect', 'connectall', 'disconnect', 'disconnectall',\n                'apply', 'log', 'help'):\n                self._check_session()\n            status, data = self._rest.get_request('help', subject, args)\n        else:\n            status, data = self._rest.get_request('help')\n\n        if isinstance(data, (list, tuple, set)):\n            return ' '.join((str(i) for i in data))\n        return data['message']", "response": "Get help information about the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a diagnostic message to a log file or to standard output.", "response": "def log(self, level, msg):\n        \"\"\"Write a diagnostic message to a log file or to standard output.\n\n        Arguments:\n        level -- Severity level of entry.  One of: INFO, WARN, ERROR, FATAL.\n        msg   -- Message to write to log.\n\n        \"\"\"\n        self._check_session()\n        level = level.upper()\n        allowed_levels = ('INFO', 'WARN', 'ERROR', 'FATAL')\n        if level not in allowed_levels:\n            raise ValueError('level must be one of: ' +\n                             ', '.join(allowed_levels))\n        self._rest.post_request(\n            'log', None, {'log_level': level.upper(), 'message': msg})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download(self, file_name, save_as=None):\n        self._check_session()\n        try:\n            if save_as:\n                save_as = os.path.normpath(save_as)\n                save_dir = os.path.dirname(save_as)\n                if save_dir:\n                    if not os.path.exists(save_dir):\n                        os.makedirs(save_dir)\n                    elif not os.path.isdir(save_dir):\n                        raise RuntimeError(save_dir + \" is not a directory\")\n\n            status, save_path, bytes = self._rest.download_file(\n                'files', file_name, save_as, 'application/octet-stream')\n        except resthttp.RestHttpError as e:\n            raise RuntimeError('failed to download \"%s\": %s' % (file_name, e))\n        return save_path, bytes", "response": "Download the specified file from the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_all(self, dst_dir=None):\n        saved = {}\n        save_as = None\n        for f in self.files():\n            if dst_dir:\n                save_as = os.path.join(dst_dir, f.split('/')[-1])\n            name, bytes = self.download(f, save_as)\n            saved[name] = bytes\n        return saved", "response": "Download all available files."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upload(self, src_file_path, dst_file_name=None):\n        self._check_session()\n        status, data = self._rest.upload_file(\n            'files', src_file_path, dst_file_name)\n        return data", "response": "Upload the specified file to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_until_complete(self, timeout=None):\n        timeout_at = None\n        if timeout:\n            timeout_at = time.time() + int(timeout)\n\n        sequencer = self.get('system1', 'children-sequencer')\n        while True:\n            cur_test_state = self.get(sequencer, 'state')\n            if 'PAUSE' in cur_test_state or 'IDLE' in cur_test_state:\n                break\n            time.sleep(2)\n            if timeout_at and time.time() >= timeout_at:\n                raise RuntimeError('wait_until_complete timed out after %s sec'\n                                   % timeout)\n\n        return self.get(sequencer, 'testState')", "response": "Wait until the sequencer is finished."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ManagerMock(manager, *return_value):\n\n    def make_get_query_set(self, model):\n        def _get(*a, **k):\n            return QuerySetMock(model, *return_value)\n        return _get\n\n    actual_model = getattr(manager, 'model', None)\n    if actual_model:\n        model = mock.MagicMock(spec=actual_model())\n    else:\n        model = mock.MagicMock()\n\n    m = SharedMock()\n    m.model = model\n    m.get_query_set = make_get_query_set(m, actual_model)\n    m.get = m.get_query_set().get\n    m.count = m.get_query_set().count\n    m.exists = m.get_query_set().exists\n    m.__iter__ = m.get_query_set().__iter__\n    m.__getitem__ = m.get_query_set().__getitem__\n    return m", "response": "Mocks the results of a single object in a Manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assert_chain_calls(self, *calls):\n\n        all_calls = self.__parent.mock_calls[:]\n\n        not_found = []\n        for kall in calls:\n            try:\n                all_calls.remove(kall)\n            except ValueError:\n                not_found.append(kall)\n        if not_found:\n            if self.__parent.mock_calls:\n                message = '%r not all found in call list, %d other(s) were:\\n%r' % (not_found, len(self.__parent.mock_calls), self.__parent.mock_calls)\n            else:\n                message = 'no calls were found'\n\n            raise AssertionError(message)", "response": "Ensures that a chained method was called."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a SharedMock that returns self for most attributes and a new copy of for any method that ordinarily generates QuerySets.", "response": "def QuerySetMock(model, *return_value):\n    \"\"\"\n    Get a SharedMock that returns self for most attributes and a new copy of\n    itself for any method that ordinarily generates QuerySets.\n\n    Set the results to two items:\n\n    >>> class Post(object): pass\n    >>> objects = QuerySetMock(Post, 'return', 'values')\n    >>> assert list(objects.filter()) == list(objects.all())\n\n    Force an exception:\n\n    >>> objects = QuerySetMock(Post, Exception())\n\n    Chain calls:\n    >>> objects.all().filter(filter_arg='dummy')\n    \"\"\"\n\n    def make_get(self, model):\n        def _get(*a, **k):\n            results = list(self)\n            if len(results) > 1:\n                raise model.MultipleObjectsReturned\n            try:\n                return results[0]\n            except IndexError:\n                raise model.DoesNotExist\n        return _get\n\n    def make_qs_returning_method(self):\n        def _qs_returning_method(*a, **k):\n            return copy.deepcopy(self)\n        return _qs_returning_method\n\n    def make_getitem(self):\n        def _getitem(k):\n            if isinstance(k, slice):\n                self.__start = k.start\n                self.__stop = k.stop\n            else:\n                return list(self)[k]\n            return self\n        return _getitem\n\n    def make_iterator(self):\n        def _iterator(*a, **k):\n            if len(return_value) == 1 and isinstance(return_value[0], Exception):\n                raise return_value[0]\n\n            start = getattr(self, '__start', None)\n            stop = getattr(self, '__stop', None)\n            for x in return_value[start:stop]:\n                yield x\n        return _iterator\n\n    actual_model = model\n    if actual_model:\n        model = mock.MagicMock(spec=actual_model())\n    else:\n        model = mock.MagicMock()\n\n    m = SharedMock(reserved=['count', 'exists'] + QUERYSET_RETURNING_METHODS)\n    m.__start = None\n    m.__stop = None\n    m.__iter__.side_effect = lambda: iter(m.iterator())\n    m.__getitem__.side_effect = make_getitem(m)\n    if hasattr(m, \"__nonzero__\"):\n        # Python 2\n        m.__nonzero__.side_effect = lambda: bool(return_value)\n        m.exists.side_effect = m.__nonzero__\n    else:\n        # Python 3\n        m.__bool__.side_effect = lambda: bool(return_value)\n        m.exists.side_effect = m.__bool__\n    m.__len__.side_effect = lambda: len(return_value)\n    m.count.side_effect = m.__len__\n\n    m.model = model\n    m.get = make_get(m, actual_model)\n\n    for method_name in QUERYSET_RETURNING_METHODS:\n        setattr(m, method_name, make_qs_returning_method(m))\n\n    # Note since this is a SharedMock, *all* auto-generated child\n    # attributes will have the same side_effect ... might not make\n    # sense for some like count().\n    m.iterator.side_effect = make_iterator(m)\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noverride read method to call parse_flask_section at the end of the method", "response": "def read(self, *args, **kwargs):\n        '''Overridden read() method to call parse_flask_section() at the end'''\n        ret = configparser.SafeConfigParser.read(self, *args, **kwargs)\n        self.parse_flask_section()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverriding readfp method to call parse_flask_section at the end", "response": "def readfp(self, *args, **kwargs):\n        '''Overridden readfp() method to call parse_flask_section() at the\n        end'''\n        ret = configparser.SafeConfigParser.readfp(self, *args, **kwargs)\n        self.parse_flask_section()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_flask_section(self):\n        '''Parse the [flask] section of your config and hand off the config\n        to the app in context.\n\n        Config vars should have the same name as their flask equivalent except\n        in all lower-case.'''\n        if self.has_section('flask'):\n            for item in self.items('flask'):\n                self._load_item(item[0])\n        else:\n            warnings.warn(\"No [flask] section found in config\")", "response": "Parse the [ flask ] section of your config and hand off the config\n        to the app in context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_item(self, key):\n        '''Load the specified item from the [flask] section. Type is\n        determined by the type of the equivalent value in app.default_config\n        or string if unknown.'''\n        key_u   = key.upper()\n        default = current_app.default_config.get(key_u)\n\n        # One of the default config vars is a timedelta - interpret it\n        # as an int and construct using it\n        if isinstance(default, datetime.timedelta):\n            current_app.config[key_u] = datetime.timedelta(self.getint('flask', key))\n        elif isinstance(default, bool):\n            current_app.config[key_u] = self.getboolean('flask', key)\n        elif isinstance(default, float):\n            current_app.config[key_u] = self.getfloat('flask', key)\n        elif isinstance(default, int):\n            current_app.config[key_u] = self.getint('flask', key)\n        else:\n            # All the string keys need to be coerced into str()\n            # because Flask expects some of them not to be unicode\n            current_app.config[key_u] = str(self.get('flask', key))", "response": "Load the specified item from the [ flask ] section. Type is\n        determined by the type of the equivalent value in app. default_config\n        or string if unknown."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _execute_migrations(self, current_version, destination_version):\n\n        is_migration_up = True\n        # check if a version was passed to the program\n        if self.config.get(\"schema_version\"):\n            # if was passed and this version is present in the database, check if is older than the current version\n            destination_version_id = self.sgdb.get_version_id_from_version_number(destination_version)\n            if destination_version_id:\n                current_version_id = self.sgdb.get_version_id_from_version_number(current_version)\n                # if this version is previous to the current version in database, then will be done a migration down to this version\n                if current_version_id > destination_version_id:\n                    is_migration_up = False\n            # if was passed and this version is not present in the database and is older than the current version, raise an exception\n            # cause is trying to go down to something that never was done\n            elif current_version > destination_version:\n                raise Exception(\"Trying to migrate to a lower version wich is not found on database (%s)\" % destination_version)\n\n        # getting only the migration sql files to be executed\n        migrations_to_be_executed = self._get_migration_files_to_be_executed(current_version, destination_version, is_migration_up)\n\n        self._execution_log(\"- Current version is: %s\" % current_version, \"GREEN\", log_level_limit=1)\n\n        if migrations_to_be_executed is None or len(migrations_to_be_executed) == 0:\n            self._execution_log(\"- Destination version is: %s\" % current_version, \"GREEN\", log_level_limit=1)\n            self._execution_log(\"\\nNothing to do.\\n\", \"PINK\", log_level_limit=1)\n            return\n\n        self._execution_log(\"- Destination version is: %s\" % (is_migration_up and migrations_to_be_executed[-1].version or destination_version), \"GREEN\", log_level_limit=1)\n\n        up_down_label = is_migration_up and \"up\" or \"down\"\n        if self.config.get(\"show_sql_only\", False):\n            self._execution_log(\"\\nWARNING: database migrations are not being executed ('--showsqlonly' activated)\", \"YELLOW\", log_level_limit=1)\n        else:\n            self._execution_log(\"\\nStarting migration %s!\" % up_down_label, log_level_limit=1)\n\n        self._execution_log(\"*** versions: %s\\n\" % ([ migration.version for migration in migrations_to_be_executed]), \"CYAN\", log_level_limit=1)\n\n        sql_statements_executed = []\n        for migration in migrations_to_be_executed:\n            sql = is_migration_up and migration.sql_up or migration.sql_down\n\n            if not self.config.get(\"show_sql_only\", False):\n                self._execution_log(\"===== executing %s (%s) =====\" % (migration.file_name, up_down_label), log_level_limit=1)\n\n                label = None\n                if is_migration_up:\n                    label = self.config.get(\"label_version\", None)\n\n                try:\n                    self.sgdb.change(sql, migration.version, migration.file_name, migration.sql_up, migration.sql_down, is_migration_up, self._execution_log, label)\n                except Exception as e:\n                    self._execution_log(\"===== ERROR executing %s (%s) =====\" % (migration.abspath, up_down_label), log_level_limit=1)\n                    raise e\n\n                # paused mode\n                if self.config.get(\"paused_mode\", False):\n                    if (sys.version_info > (3, 0)):\n                        input(\"* press <enter> to continue... \")\n                    else:\n                        raw_input(\"* press <enter> to continue... \")\n\n            # recording the last statement executed\n            sql_statements_executed.append(sql)\n\n        if self.config.get(\"show_sql\", False) or self.config.get(\"show_sql_only\", False):\n            self._execution_log(\"__________ SQL statements executed __________\", \"YELLOW\", log_level_limit=1)\n            for sql in sql_statements_executed:\n                self._execution_log(sql, \"YELLOW\", log_level_limit=1)\n            self._execution_log(\"_____________________________________________\", \"YELLOW\", log_level_limit=1)", "response": "Execute the migrations for the specified version of the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef csrf_token():\n    if \"_csrf_token\" not in session:\n        session[\"_csrf_token\"] = os.urandom(128)\n    return hmac.new(app.secret_key, session[\"_csrf_token\"],\n            digestmod=sha1).hexdigest()", "response": "Generate a token string from bytes arrays."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks that token is correct aborting if not", "response": "def check_csrf_token():\n    \"\"\"Checks that token is correct, aborting if not\"\"\"\n    if request.method in (\"GET\",): # not exhaustive list\n        return\n    token = request.form.get(\"csrf_token\")\n    if token is None:\n        app.logger.warning(\"Expected CSRF Token: not present\")\n        abort(400)\n    if not safe_str_cmp(token, csrf_token()):\n        app.logger.warning(\"CSRF Token incorrect\")\n        abort(400)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the HTTPRequest object from thread storage or from a callee by searching the stack for the HTTPRequest object in the call stack.", "response": "def get_request(cls):\n        \"\"\"\n        Get the HTTPRequest object from thread storage or from a callee by searching\n        each frame in the call stack.\n        \"\"\"\n        request = cls.get_global('request')\n        if request:\n            return request\n        try:\n            stack = inspect.stack()\n        except IndexError:\n            # in some cases this may return an index error\n            # (pyc files dont match py files for example)\n            return\n        for frame, _, _, _, _, _ in stack:\n            if 'request' in frame.f_locals:\n                if isinstance(frame.f_locals['request'], HttpRequest):\n                    request = frame.f_locals['request']\n                    cls.set_global('request', request)\n                    return request"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef route(app_or_blueprint, rule, **options):\n    def decorator(f):\n        methods = options.pop('methods', ('GET', 'POST'))\n        if 'POST' not in methods:\n            methods = tuple(methods) + ('POST',)\n        options['methods'] = methods\n        app_or_blueprint.add_url_rule(rule, None, f, **options)\n        return f\n    return decorator", "response": "A decorator that returns a function that will be used to route the given Flask application to the given rule."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a Sijax response object and returns a valid Flask response object.", "response": "def _make_response(sijax_response):\n    \"\"\"Takes a Sijax response object and returns a\n    valid Flask response object.\"\"\"\n    from types import GeneratorType\n\n    if isinstance(sijax_response, GeneratorType):\n        # Streaming response using a generator (non-JSON response).\n        # Upon returning a response, Flask would automatically destroy\n        # the request data and uploaded files - done by `flask.ctx.RequestContext.auto_pop()`\n        # We can't allow that, since the user-provided callback we're executing\n        # from within the generator may want to access request data/files.\n        # That's why we'll tell Flask to preserve the context and we'll clean up ourselves.\n\n        request.environ['flask._preserve_context'] = True\n\n        # Clean-up code taken from `flask.testing.TestingClient`\n        def clean_up_context():\n            top = _request_ctx_stack.top\n            if top is not None and top.preserved:\n                top.pop()\n\n        # As per the WSGI specification, `close()` would be called on iterator responses.\n        # Let's wrap the iterator in another one, which will forward that `close()` call to our clean-up callback.\n        response = Response(ClosingIterator(sijax_response, clean_up_context), direct_passthrough=True)\n    else:\n        # Non-streaming response - a single JSON string\n        response = Response(sijax_response)\n\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_comet_callback(self, *args, **kwargs):\n        sijax.plugin.comet.register_comet_callback(self._sijax, *args, **kwargs)", "response": "Registers a single Comet callback function that will be called when the service is ready to access the related attributes of the related attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering all functions from the object as Comet functions", "response": "def register_comet_object(self, *args, **kwargs):\n        \"\"\"Registers all functions from the object as Comet functions\n        (see :ref:`comet-plugin`).\n\n        This makes mass registration of functions a lot easier.\n\n        Refer to :func:`sijax.plugin.comet.register_comet_object`\n        for more details -ts signature differs slightly.\n\n        This method's signature is the same, except that the first\n        argument that :func:`sijax.plugin.comet.register_comet_object`\n        expects is the Sijax instance, and this method\n        does that automatically, so you don't have to do it.\n        \"\"\"\n        sijax.plugin.comet.register_comet_object(self._sijax, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_upload_callback(self, *args, **kwargs):\n        if 'args_extra' not in kwargs:\n            kwargs['args_extra'] = [request.files]\n        return sijax.plugin.upload.register_upload_callback(self._sijax, *args, **kwargs)", "response": "Registers an Upload function to handle a certain form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a callback and returns the proper response.", "response": "def execute_callback(self, *args, **kwargs):\n        \"\"\"Executes a callback and returns the proper response.\n\n        Refer to :meth:`sijax.Sijax.execute_callback` for more details.\n        \"\"\"\n        response = self._sijax.execute_callback(*args, **kwargs)\n        return _make_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_permission(self, request, extra_permission=None):\n        permission = request.user.is_active and request.user.is_staff\n        if extra_permission:\n            permission = permission and request.user.has_perm(extra_permission)\n        return permission", "response": "Returns True if the given HttpRequest has permission to view at least one page in the admin site."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap a view in authentication/caching logic extra_permission can be used to require an extra permission for this view, such as a module permission", "response": "def as_view(self, view, cacheable=False, extra_permission=None):\n        \"\"\"\n        Wraps a view in authentication/caching logic\n\n        extra_permission can be used to require an extra permission for this view, such as a module permission\n        \"\"\"\n        def inner(request, *args, **kwargs):\n            if not self.has_permission(request, extra_permission):\n                # show login pane\n                return self.login(request)\n            return view(request, *args, **kwargs)\n\n        # Mark it as never_cache\n        if not cacheable:\n            inner = never_cache(inner)\n\n        # We add csrf_protect here so this function can be used as a utility\n        # function for any view, without having to repeat 'csrf_protect'.\n        if not getattr(view, 'csrf_exempt', False):\n            inner = csrf_protect(inner)\n\n        inner = ensure_csrf_cookie(inner)\n\n        return update_wrapper(inner, view)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserving static files below a given point in the directory structure.", "response": "def media(self, request, module, path):\n        \"\"\"\n        Serve static files below a given point in the directory structure.\n        \"\"\"\n        if module == 'nexus':\n            document_root = os.path.join(NEXUS_ROOT, 'media')\n        else:\n            document_root = self.get_module(module).media_root\n\n        path = posixpath.normpath(urllib.unquote(path))\n        path = path.lstrip('/')\n        newpath = ''\n        for part in path.split('/'):\n            if not part:\n                # Strip empty path components.\n                continue\n            drive, part = os.path.splitdrive(part)\n            head, part = os.path.split(part)\n            if part in (os.curdir, os.pardir):\n                # Strip '.' and '..' in path.\n                continue\n            newpath = os.path.join(newpath, part).replace('\\\\', '/')\n        if newpath and path != newpath:\n            return HttpResponseRedirect(newpath)\n        fullpath = os.path.join(document_root, newpath)\n        if os.path.isdir(fullpath):\n            raise Http404(\"Directory indexes are not allowed here.\")\n        if not os.path.exists(fullpath):\n            raise Http404('\"%s\" does not exist' % fullpath)\n        # Respect the If-Modified-Since header.\n        statobj = os.stat(fullpath)\n        mimetype = mimetypes.guess_type(fullpath)[0] or 'application/octet-stream'\n        if not was_modified_since(request.META.get('HTTP_IF_MODIFIED_SINCE'),\n                                  statobj[stat.ST_MTIME], statobj[stat.ST_SIZE]):\n            return HttpResponseNotModified(content_type=mimetype)\n        contents = open(fullpath, 'rb').read()\n        response = HttpResponse(contents, content_type=mimetype)\n        response[\"Last-Modified\"] = http_date(statobj[stat.ST_MTIME])\n        response[\"Content-Length\"] = len(contents)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlogging out user and redirects them to Nexus home", "response": "def logout(self, request):\n        \"Logs out user and redirects them to Nexus home\"\n        from django.contrib.auth import logout\n\n        logout(request)\n\n        return HttpResponseRedirect(reverse('nexus:index', current_app=self.name))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the row of buttons for delete and save.", "response": "def submit_row(context):\n    \"\"\"\n    Displays the row of buttons for delete and save. \n    \"\"\"\n    opts = context['opts']\n    change = context['change']\n    is_popup = context['is_popup']\n    save_as = context['save_as']\n    return {\n        'onclick_attrib': (opts.get_ordered_objects() and change\n                            and 'onclick=\"submitOrderForm();\"' or ''),\n        'show_delete_link': (not is_popup and context['has_delete_permission']\n                              and (change or context['show_delete'])),\n        'show_save_as_new': not is_popup and change and save_as,\n        'show_save_and_add_another': context['has_add_permission'] and \n                            not is_popup and (not save_as or context['add']),\n        'show_save_and_continue': not is_popup and context['has_change_permission'],\n        'is_popup': is_popup,\n        'show_save': True,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef autodiscover(site=None):\n    # Bail out if autodiscover didn't finish loading from a previous call so\n    # that we avoid running autodiscover again when the URLconf is loaded by\n    # the exception handler to resolve the handler500 view.  This prevents an\n    # admin.py module with errors from re-registering models and raising a\n    # spurious AlreadyRegistered exception (see #8245).\n    global LOADING\n    if LOADING:\n        return\n    LOADING = True\n\n    if site:\n        orig_site = globals()['site']\n        globals()['site'] = locals()['site']\n\n    import imp\n    from django.utils.importlib import import_module\n    from django.conf import settings\n\n    for app in settings.INSTALLED_APPS:\n        # For each app, we need to look for an api.py inside that app's\n        # package. We can't use os.path here -- recall that modules may be\n        # imported different ways (think zip files) -- so we need to get\n        # the app's __path__ and look for admin.py on that path.\n\n        # Step 1: find out the app's __path__ Import errors here will (and\n        # should) bubble up, but a missing __path__ (which is legal, but weird)\n        # fails silently -- apps that do weird things with __path__ might\n        # need to roll their own admin registration.\n        try:\n            app_path = import_module(app).__path__\n        except (AttributeError, ImportError):\n            continue\n\n        # Step 2: use imp.find_module to find the app's admin.py. For some\n        # reason imp.find_module raises ImportError if the app can't be found\n        # but doesn't actually try to import the module. So skip this app if\n        # its admin.py doesn't exist\n        try:\n            imp.find_module('nexus_modules', app_path)\n        except ImportError:\n            continue\n\n        # Step 3: import the app's admin file. If this has errors we want them\n        # to bubble up.\n        import_module(\"%s.nexus_modules\" % app)\n    # # load builtins\n    # from gargoyle.builtins import *\n\n    if site:\n        globals()['site'] = orig_site\n\n    # autodiscover was successful, reset loading flag.\n    LOADING = False", "response": "Autodiscovers INSTALLED_APPS nexus. py modules and returns a nexus tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_starttag(self, tagName, attributeList, isSelfClosing=False):\n        '''\n            Internal for parsing\n        '''\n        tagName = tagName.lower()\n        inTag = self._inTag\n\n        if isSelfClosing is False and tagName in IMPLICIT_SELF_CLOSING_TAGS:\n            isSelfClosing = True\n\n        newTag = AdvancedTag(tagName, attributeList, isSelfClosing, ownerDocument=self)\n        if self.root is None:\n            self.root = newTag\n        elif len(inTag) > 0:\n            inTag[-1].appendChild(newTag)\n        else:\n            raise MultipleRootNodeException()\n\n        if isSelfClosing is False:\n            inTag.append(newTag)\n\n        return newTag", "response": "Internal for parsing\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_endtag(self, tagName):\n        '''\n            Internal for parsing\n        '''\n        try:\n            foundIt = False\n            inTag = self._inTag\n            for i in range(len(inTag)):\n                if inTag[i].tagName == tagName:\n                    foundIt = True\n                    break\n\n            if not foundIt:\n                return\n            # Handle closing tags which should have been closed but weren't\n            while inTag[-1].tagName != tagName:\n                inTag.pop()\n\n            inTag.pop()\n        except:\n            pass", "response": "Internal for parsing\n            Internal for parsing\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getRootNodes(self):\n        '''\n            getRootNodes - Gets all objects at the \"root\" (first level; no parent). Use this if you may have multiple roots (not children of <html>)\n                Use this method to get objects, for example, in an AJAX request where <html> may not be your root.\n\n                Note: If there are multiple root nodes (i.e. no <html> at the top), getRoot will return a special tag. This function automatically\n                  handles that, and returns all root nodes.\n\n                @return list<AdvancedTag> - A list of AdvancedTags which are at the root level of the tree.\n        '''\n        root = self.root\n        if not root:\n            return []\n        if root.tagName == INVISIBLE_ROOT_TAG:\n            return list(root.children)\n        return [root]", "response": "Get all objects at the root level of the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getAllNodes(self):\n        '''\n            getAllNodes - Get every element\n\n            @return TagCollection<AdvancedTag>\n        '''\n\n        ret = TagCollection()\n\n        for rootNode in self.getRootNodes():\n            ret.append(rootNode)\n\n            ret += rootNode.getAllChildNodes()\n\n        return ret", "response": "getAllNodes - Get every element of the tree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getElementsByName(self, name, root='root'):\n        '''\n            getElementsByName - Searches and returns all elements with a specific name.\n               \n                @param name <str> - A string of the name attribute\n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root' [default], the root of the parsed tree will be used.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        elements = []\n\n        if isFromRoot is True and root.name == name:\n            elements.append(root)\n\n        getElementsByName = self.getElementsByName\n        for child in root.children:\n\n            if child.getAttribute('name') == name:\n                elements.append(child)\n\n            elements += getElementsByName(name, child)\n\n        return TagCollection(elements)", "response": "getElementsByName - Searches and returns all elements with a specific name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getElementById(self, _id, root='root'):\n        '''\n            getElementById - Searches and returns the first (should only be one) element with the given ID.\n               \n                @param id <str> - A string of the id attribute.\n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root' [default], the root of the parsed tree will be used.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        if isFromRoot is True and root.id == _id:\n            return root\n\n        getElementById = self.getElementById\n        for child in root.children:\n\n            if child.getAttribute('id') == _id:\n                return child\n\n            potential = getElementById(_id, child)\n            if potential is not None:\n                return potential\n\n        return None", "response": "Searches and returns the first element with the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getElementsByAttr(self, attrName, attrValue, root='root'):\n        '''\n            getElementsByAttr - Searches the full tree for elements with a given attribute name and value combination. This is always a full scan.\n               \n                @param attrName <lowercase str> - A lowercase attribute name\n                @param attrValue <str> - Expected value of attribute\n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root', the root of the parsed tree will be used.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        elements = []\n\n        if isFromRoot is True and root.getAttribute(attrName) == attrValue:\n            elements.append(root)\n\n        getElementsByAttr = self.getElementsByAttr\n        for child in root.children:\n\n            if child.getAttribute(attrName) == attrValue:\n                elements.append(child)\n\n            elements += getElementsByAttr(attrName, attrValue, child)\n\n        return TagCollection(elements)", "response": "getElementsByAttr - Searches the full tree for elements with a given attribute name and value combination. This is always a full scan."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getElementsCustomFilter(self, filterFunc, root='root'):\n        '''\n            getElementsCustomFilter - Scan elements using a provided function\n\n            @param filterFunc <function>(node) - A function that takes an AdvancedTag as an argument, and returns True if some arbitrary criteria is met\n\n            @return - TagCollection of all matching elements\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        elements = []\n\n        if isFromRoot is True and filterFunc(root) is True:\n            elements.append(root)\n\n        getElementsCustomFilter = self.getElementsCustomFilter\n        for child in root.children:\n\n            if filterFunc(child) is True:\n                elements.append(child)\n\n            elements += getElementsCustomFilter(filterFunc, child)\n\n        return TagCollection(elements)", "response": "getElementsCustomFilter - Scan elements using a provided function\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef contains(self, em):\n        '''\n            Checks if #em is found anywhere within this element tree\n\n            @param em <AdvancedTag> - Tag of interest\n\n            @return <bool> - If element #em is within this tree\n        '''\n        for rootNode in self.getRootNodes():\n            if rootNode.contains(em):\n                return True\n\n        return False", "response": "Checks if the given element is found anywhere within this tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef containsUid(self, uid):\n        '''\n            Check if #uid is found anywhere within this element tree\n\n            @param uid <uuid.UUID> - Uid\n\n            @return <bool> - If #uid is found within this tree\n        '''\n        for rootNode in self.getRootNodes():\n            if rootNode.containsUid(uid):\n                return True\n\n        return False", "response": "Check if the uid is found anywhere within this element tree\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find(self, **kwargs):\n        '''\n            find - Perform a search of elements using attributes as keys and potential values as values\n            \n               (i.e.  parser.find(name='blah', tagname='span')  will return all elements in this document\n                 with the name \"blah\" of the tag type \"span\" )\n\n            Arguments are key = value, or key can equal a tuple/list of values to match ANY of those values.\n\n            Append a key with __contains to test if some strs (or several possible strs) are within an element\n            Append a key with __icontains to perform the same __contains op, but ignoring case\n\n            Special keys:\n\n               tagname    - The tag name of the element\n               text       - The text within an element\n\n            NOTE: Empty string means both \"not set\" and \"no value\" in this implementation.\n\n            NOTE: If you installed the QueryableList module (i.e. ran setup.py without --no-deps) it is\n              better to use the \"filter\"/\"filterAnd\" or \"filterOr\" methods, which are also available\n              on all tags and tag collections (tag collections also have filterAllAnd and filterAllOr)\n\n\n            @return TagCollection<AdvancedTag> - A list of tags that matched the filter criteria\n        '''\n\n        if not kwargs:\n            return TagCollection()\n\n\n        # Because of how closures work in python, need a function to generate these lambdas\n        #  because the closure basically references \"current key in iteration\" and not\n        #  \"actual instance\" of variable. Seems to me to be a bug... but whatever\n        def _makeTagnameLambda(tagName):\n            return lambda em : em.tagName == tagName\n\n        def _makeAttributeLambda(_key, _value):\n            return lambda em : em.getAttribute(_key, '') == _value\n\n        def _makeTagnameInLambda(tagNames):\n            return lambda em : em.tagName in tagNames\n\n        def _makeAttributeInLambda(_key, _values):\n            return lambda em : em.getAttribute(_key, '') in _values\n\n        def _makeTextLambda(_value):\n            return lambda em : em.text == _value\n\n        def _makeTextInLambda(_values):\n            return lambda em : em.text in _values\n\n        def _makeAttributeContainsLambda(_key, _value, icontains=False):\n            if icontains is False:\n                return lambda em : _value in em.getAttribute(_key, '')\n            else:\n                _value = _value.lower()\n                return lambda em : _value in em.getAttribute(_key, '').lower()\n\n        def _makeTextContainsLambda(_value, icontains=False):\n            if icontains is False:\n                return lambda em : _value in em.text\n            else:\n                _value = _value.lower()\n                return lambda em : _value in em.text.lower()\n\n        def _makeAttributeContainsInLambda(_key, _values, icontains=False):\n            if icontains:\n                _values = tuple([x.lower() for x in _values])\n\n            def _testFunc(em):\n                attrValue = em.getAttribute(_key, '')\n                if icontains:\n                    attrValue = attrValue.lower()\n\n                for value in _values:\n                    if value in attrValue:\n                        return True\n\n                return False\n\n            return _testFunc\n\n        def _makeTextContainsInLambda(_values, icontains=False):\n            if icontains:\n                _values = tuple([x.lower() for x in _values])\n\n            def _testFunc(em):\n                text = em.text\n                if icontains:\n                    text = text.lower()\n\n                for value in _values:\n                    if value in text:\n                        return True\n\n                return False\n\n            return _testFunc\n\n        # This will hold all the functions we will chain for matching\n        matchFunctions = []\n\n        # Iterate over all the filter portions, and build a filter.\n        for key, value in kwargs.items():\n            key = key.lower()\n\n            endsIContains = key.endswith('__icontains')\n            endsContains = key.endswith('__contains')\n\n            isValueList = isinstance(value, (list, tuple))\n\n            thisFunc = None\n\n            if endsIContains or endsContains:\n                key = re.sub('__[i]{0,1}contains$', '', key)\n                if key == 'tagname':\n                    raise ValueError('tagname is not supported for contains')\n\n                if isValueList:\n                    if key == 'text':\n                        thisFunc = _makeTextContainsInLambda(value, icontains=endsIContains)\n                    else:\n                        thisFunc = _makeAttributeContainsLambda(key, value, icontains=endsIContains)\n                else:\n                    if key == 'text':\n                        thisFunc = _makeTextContainsLambda(value, icontains=endsIContains)\n                    else:\n                        thisFunc = _makeAttributeContainsLambda(key, value, icontains=endsIContains)\n\n            else:\n                # Not contains, straight up\n\n                if isValueList:\n                    if key == 'tagname':\n                        thisFunc = _makeTagnameInLambda(value)\n                    elif key == 'text':\n                        thisFunc = _makeTextInLambda(value)\n                    else:\n                        thisFunc = _makeAttributeInLambda(key, value)\n                else:\n                    if key == 'tagname':\n                        thisFunc = _makeTagnameLambda(value)\n                    elif key == 'text':\n                        thisFunc = _makeTextLambda(value)\n                    else:\n                        thisFunc = _makeAttributeLambda(key, value)\n\n\n            matchFunctions.append( thisFunc )\n\n        # The actual matching function - This will run through the assembled\n        #  #matchFunctions list, testing the element against each match\n        #  and returning all elements in a TagCollection that match this list.\n        def doMatchFunc(em):\n            for matchFunction in matchFunctions:\n                if matchFunction(em) is False:\n                    return False\n\n            return True\n\n        return self.getElementsCustomFilter(doMatchFunc)", "response": "This method is used to find all tags in this document."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the full HTML as contained within this tree.", "response": "def getHTML(self):\n        '''\n            getHTML - Get the full HTML as contained within this tree.\n\n                If parsed from a document, this will contain the original whitespacing.\n\n                @returns - <str> of html\n\n                    @see getFormattedHTML\n\n                    @see getMiniHTML\n        '''\n        root = self.getRoot()\n        if root is None:\n            raise ValueError('Did not parse anything. Use parseFile or parseStr')\n\n        if self.doctype:\n            doctypeStr = '<!%s>\\n' %(self.doctype)\n        else:\n            doctypeStr = ''\n\n        # 6.6.0: If we have a real root tag, print the outerHTML. If we have a fake root tag (for multiple root condition),\n        #   then print the innerHTML (skipping the outer root tag). Otherwise, we will miss\n        #   untagged text (between the multiple root nodes).\n        rootNode = self.getRoot()\n        if rootNode.tagName == INVISIBLE_ROOT_TAG:\n            return doctypeStr + rootNode.innerHTML\n        else:\n            return doctypeStr + rootNode.outerHTML"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget formatted and xhtml of this document replacing the original whitespace with a pretty - printed version of each level of indent.", "response": "def getFormattedHTML(self, indent='  '):\n        '''\n            getFormattedHTML - Get formatted and xhtml of this document, replacing the original whitespace\n                with a pretty-printed version\n\n            @param indent - space/tab/newline of each level of indent, or integer for how many spaces per level\n        \n            @return - <str> Formatted html\n\n            @see getHTML - Get HTML with original whitespace\n\n            @see getMiniHTML - Get HTML with only functional whitespace remaining\n        '''\n        from .Formatter import AdvancedHTMLFormatter\n        html = self.getHTML()\n        formatter = AdvancedHTMLFormatter(indent, None) # Do not double-encode\n        formatter.feed(html)\n        return formatter.getHTML()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the HTML representation of this document without any pretty formatting and disregarding original whitespace beyond the functional.", "response": "def getMiniHTML(self):\n        '''\n            getMiniHTML - Gets the HTML representation of this document without any pretty formatting\n                and disregarding original whitespace beyond the functional.\n\n                @return <str> - HTML with only functional whitespace present\n        '''\n        from .Formatter import AdvancedHTMLMiniFormatter\n        html = self.getHTML()\n        formatter = AdvancedHTMLMiniFormatter(None) # Do not double-encode\n        formatter.feed(html)\n        return formatter.getHTML()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreset the internal state of the object.", "response": "def _reset(self):\n        '''\n            _reset - reset this object. Assigned to .reset after __init__ call.\n        '''\n        HTMLParser.reset(self)\n\n        self.root = None\n        self.doctype = None\n        self._inTag = []"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef feed(self, contents):\n        '''\n            feed - Feed contents. Use  parseStr or parseFile instead.\n\n            @param contents - Contents\n        '''\n        contents = stripIEConditionals(contents)\n        try:\n            HTMLParser.feed(self, contents)\n        except MultipleRootNodeException:\n            self.reset()\n            HTMLParser.feed(self, \"%s%s\" %(addStartTag(contents, INVISIBLE_ROOT_TAG_START), INVISIBLE_ROOT_TAG_END))", "response": "Feed contents. Use parseStr or parseFile instead."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parseFile(self, filename):\n        '''\n            parseFile - Parses a file and creates the DOM tree and indexes\n    \n                @param filename <str/file> - A string to a filename or a file object. If file object, it will not be closed, you must close.\n        '''\n        self.reset()\n\n        if isinstance(filename, file):\n            contents = filename.read()\n        else:\n            with codecs.open(filename, 'r', encoding=self.encoding) as f:\n                contents = f.read()\n\n        self.feed(contents)", "response": "Parse a file and creates the DOM tree and indexes\n    \n               "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a string and creates the DOM tree and indexes.", "response": "def parseStr(self, html):\n        '''\n            parseStr - Parses a string and creates the DOM tree and indexes.\n\n                @param html <str> - valid HTML\n        '''\n        self.reset()\n\n        if isinstance(html, bytes):\n            self.feed(html.decode(self.encoding))\n        else:\n            self.feed(html)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef createElementFromHTML(cls, html, encoding='utf-8'):\n        '''\n            createElementFromHTML - Creates an element from a string of HTML.\n\n                If this could create multiple root-level elements (children are okay),\n                  you must use #createElementsFromHTML which returns a list of elements created.\n\n            @param html <str> - Some html data\n\n            @param encoding <str> - Encoding to use for document\n\n            @raises MultipleRootNodeException - If given html would produce multiple root-level elements (use #createElementsFromHTML instead)\n\n            @return AdvancedTag - A single AdvancedTag\n\n            NOTE: If there is text outside the tag, they will be lost in this.\n              Use createBlocksFromHTML instead if you need to retain both text and tags.\n\n              Also, if you are just appending to an existing tag, use AdvancedTag.appendInnerHTML\n        '''\n        \n        parser = cls(encoding=encoding)\n\n        html = stripIEConditionals(html)\n        try:\n            HTMLParser.feed(parser, html)\n        except MultipleRootNodeException:\n            raise MultipleRootNodeException('Multiple nodes passed to createElementFromHTML method. Use #createElementsFromHTML instead to get a list of AdvancedTag elements.')\n\n        rootNode = parser.getRoot()\n        rootNode.remove()\n\n        return rootNode", "response": "Create an element from a string of HTML."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef createElementsFromHTML(cls, html, encoding='utf-8'):\n        '''\n            createElementsFromHTML - Creates elements from provided html, and returns a list of the root-level elements\n                children of these root-level nodes are accessable via the usual means.\n\n            @param html <str> - Some html data\n\n            @param encoding <str> - Encoding to use for document\n\n            @return list<AdvancedTag> - The root (top-level) tags from parsed html.\n\n            NOTE: If there is text outside the tags, they will be lost in this.\n              Use createBlocksFromHTML instead if you need to retain both text and tags.\n\n              Also, if you are just appending to an existing tag, use AdvancedTag.appendInnerHTML\n        '''\n        # TODO: If text is present outside a tag, it will be lost.\n\n        parser = cls(encoding=encoding)\n\n        parser.parseStr(html)\n\n        rootNode = parser.getRoot()\n\n        rootNode.remove() # Detatch from temp document\n\n        if isInvisibleRootTag(rootNode):\n            return rootNode.children\n\n        return [rootNode]", "response": "Create elements from provided html and returns a list of the root - level elements that are accessable via the usual means."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate blocks from HTML.", "response": "def createBlocksFromHTML(cls, html, encoding='utf-8'):\n        '''\n            createBlocksFromHTML - Returns the root level node (unless multiple nodes), and \n                a list of \"blocks\" added (text and nodes).\n\n            @return list< str/AdvancedTag > - List of blocks created. May be strings (text nodes) or AdvancedTag (tags)\n\n            NOTE:\n                Results may be checked by:\n\n                    issubclass(block.__class__, AdvancedTag)\n\n                If True, block is a tag, otherwise, it is a text node\n        '''\n        \n        parser = cls(encoding=encoding)\n\n        parser.parseStr(html)\n\n        rootNode = parser.getRoot()\n\n        rootNode.remove()\n\n        return rootNode.blocks"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_starttag(self, tagName, attributeList, isSelfClosing=False):\n        '''\n            internal for parsing\n        '''\n        newTag = AdvancedHTMLParser.handle_starttag(self, tagName, attributeList, isSelfClosing)\n        self._indexTag(newTag)\n\n        return newTag", "response": "Internal method to index and return a new tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disableIndexing(self):\n        '''\n            disableIndexing - Disables indexing. Consider using plain AdvancedHTMLParser class.\n              Maybe useful in some scenarios where you want to parse, add a ton of elements, then index\n              and do a bunch of searching.\n        '''\n        self.indexIDs = self.indexNames = self.indexClassNames = self.indexTagNames = False\n        self._resetIndexInternal()", "response": "Disables indexing. Consider using plain AdvancedHTMLParser class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an index for an arbitrary attribute. This will be used by the getElementsByAttr function.", "response": "def addIndexOnAttribute(self, attributeName):\n        '''\n            addIndexOnAttribute - Add an index for an arbitrary attribute. This will be used by the getElementsByAttr function.\n                You should do this prior to parsing, or call reindex. Otherwise it will be blank. \"name\" and \"id\" will have no effect.\n    \n                @param attributeName <lowercase str> - An attribute name. Will be lowercased.\n        '''\n        attributeName = attributeName.lower()\n        self._otherAttributeIndexes[attributeName] = {}\n\n        def _otherIndexFunction(self, tag):\n            thisAttribute = tag.getAttribute(attributeName)\n            if thisAttribute is not None:\n                if thisAttribute not in self._otherAttributeIndexes[attributeName]:\n                    self._otherAttributeIndexes[attributeName][thisAttribute] = []\n                self._otherAttributeIndexes[attributeName][thisAttribute].append(tag)\n\n\n        self.otherAttributeIndexFunctions[attributeName] = _otherIndexFunction"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeIndexOnAttribute(self, attributeName):\n        '''\n            removeIndexOnAttribute - Remove an attribute from indexing (for getElementsByAttr function) and remove indexed data.\n\n        @param attributeName <lowercase str> - An attribute name. Will be lowercased. \"name\" and \"id\" will have no effect.\n        '''\n        attributeName = attributeName.lower()\n        if attributeName in self.otherAttributeIndexFunctions:\n                del self.otherAttributeIndexFunctions[attributeName]\n        if attributeName in self._otherAttributeIndexes:\n                del self._otherAttributeIndexes[attributeName]", "response": "Removes an attribute from indexing and remove indexed data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getElementsByTagName(self, tagName, root='root', useIndex=True):\n        '''\n            getElementsByTagName - Searches and returns all elements with a specific tag name.\n               \n                @param tagName <lowercase str> - A lowercase string of the tag name. \n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root', the root of the parsed tree will be used.\n                @param useIndex - If True [default] and tag names are set to be indexed [default, see constructor], only the index will be used. If False, all tags\n                  will be searched.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        if useIndex is True and self.indexTagNames is True:\n            elements = self._tagNameMap.get(tagName, []) # Use .get here as to not create a lot of extra indexes on the defaultdict for misses\n            if isFromRoot is False:\n                _hasTagInParentLine = self._hasTagInParentLine\n                elements = [x for x in elements if _hasTagInParentLine(x, root)]\n\n            return TagCollection(elements)\n\n        return AdvancedHTMLParser.getElementsByTagName(self, tagName, root)", "response": "getElementsByTagName - Searches and returns all elements with a specific tag name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getElementsByClassName(self, className, root='root', useIndex=True):\n        '''\n            getElementsByClassName - Searches and returns all elements containing a given class name.\n               \n                @param className <str> - A one-word class name\n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root', the root of the parsed tree will be used.\n                @param useIndex <bool> If useIndex is True and class names are indexed [see constructor] only the index will be used. Otherwise a full search is performed.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        if useIndex is True and self.indexClassNames is True:\n\n            elements = self._classNameMap.get(className, [])\n\n            if isFromRoot is False:\n                _hasTagInParentLine = self._hasTagInParentLine\n                elements = [x for x in elements if _hasTagInParentLine(x, root)]\n\n            return TagCollection(elements)\n\n        return AdvancedHTMLParser.getElementsByClassName(self, className, root)", "response": "getElementsByClassName - Searches and returns all elements containing a given class name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getElementsByAttr(self, attrName, attrValue, root='root', useIndex=True):\n        '''\n            getElementsByAttr - Searches the full tree for elements with a given attribute name and value combination. If you want multiple potential values, see getElementsWithAttrValues\n               If you want an index on a random attribute, use the addIndexOnAttribute function.\n               \n                @param attrName <lowercase str> - A lowercase attribute name\n                @param attrValue <str> - Expected value of attribute\n                @param root <AdvancedTag/'root'> - Search starting at a specific node, if provided. if string 'root', the root of the parsed tree will be used.\n                @param useIndex <bool> If useIndex is True and this specific attribute is indexed [see addIndexOnAttribute] only the index will be used. Otherwise a full search is performed.\n        '''\n        (root, isFromRoot) = self._handleRootArg(root)\n\n        if useIndex is True and attrName in self._otherAttributeIndexes:\n\n            elements = self._otherAttributeIndexes[attrName].get(attrValue, [])\n\n            if isFromRoot is False:\n                _hasTagInParentLine = self._hasTagInParentLine\n                elements = [x for x in elements if _hasTagInParentLine(x, root)]\n\n            return TagCollection(elements)\n        \n        return AdvancedHTMLParser.getElementsByAttr(self, attrName, attrValue, root)", "response": "getElementsByAttr - Searches the full tree for elements with a given attribute name and value combination."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uniqueTags(tagList):\n    '''\n        uniqueTags - Returns the unique tags in tagList.\n        \n            @param tagList list<AdvancedTag> : A list of tag objects.\n    '''\n    ret = []\n    alreadyAdded = set()\n    for tag in tagList:\n        myUid = tag.getUid()\n        if myUid in alreadyAdded:\n            continue\n        ret.append(tag)\n    return TagCollection(ret)", "response": "Returns the unique tags in tagList."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef toggleAttributesDOM(isEnabled):\n    '''\n        toggleAttributesDOM - Toggle if the old DOM tag.attributes NamedNodeMap model should be used for the .attributes method, versus\n\n           a more sane direct dict implementation.\n\n            The DOM version is always accessable as AdvancedTag.attributesDOM\n            The dict version is always accessable as AdvancedTag.attributesDict\n\n            Default for AdvancedTag.attributes is to be attributesDict implementation.\n\n          @param isEnabled <bool> - If True, .attributes will be changed to use the DOM-provider. Otherwise, it will use the dict provider.\n    '''\n\n    if isEnabled:\n        AdvancedTag.attributes = AdvancedTag.attributesDOM\n    else:\n        AdvancedTag.attributes = AdvancedTag.attributesDict", "response": "Toggle if the old DOM tag. attributes NamedNodeMap model should be used for the. attributes method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a clone of this node.", "response": "def cloneNode(self):\n        '''\n            cloneNode - Clone this node (tag name and attributes). Does not clone children.\n\n            Tags will be equal according to isTagEqual method, but will contain a different internal\n            unique id such tag origTag != origTag.cloneNode() , as is the case in JS DOM.\n        '''\n        return self.__class__(self.tagName, self.getAttributesList(), self.isSelfClosing)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef removeText(self, text):\n        '''\n            removeText - Removes the first occurace of given text in a text node (i.e. not part of a tag)\n\n            @param text <str> - text to remove\n\n            @return text <str/None> - The text in that block (text node) after remove, or None if not found\n\n            NOTE: To remove a node, @see removeChild\n            NOTE: To remove a block (maybe a node, maybe text), @see removeBlock\n            NOTE: To remove ALL occuraces of text, @see removeTextAll\n        '''\n        # TODO: This would be a good candidate for the refactor of text blocks\n        removedBlock = None\n\n        # Scan all text blocks for \"text\"\n        blocks = self.blocks\n        for i in range(len(blocks)):\n            block = blocks[i]\n\n            # We only care about text blocks\n            if issubclass(block.__class__, AdvancedTag):\n                continue\n\n            if text in block:\n                # We have a block that matches.\n                \n                # Create a copy of the old text in this block for return\n                removedBlock = block[:]\n                # Remove first occurance of #text from matched block\n                blocks[i] = block.replace(text, '')\n                break # remove should only remove FIRST occurace, per other methods\n\n        # Regenerate the \"text\" property\n        self.text = ''.join([thisBlock for thisBlock in blocks if not issubclass(thisBlock.__class__, AdvancedTag)])\n\n        # Return None if no match, otherwise the text previously within the block we removed #text from\n        return removedBlock", "response": "Removes the first occurace of given text in a text node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef removeTextAll(self, text):\n        '''\n            removeTextAll - Removes ALL occuraces of given text in a text node (i.e. not part of a tag)\n\n            @param text <str> - text to remove\n\n            @return list <str> - All text node containing #text BEFORE the text was removed.\n                Empty list if no text removed\n\n            NOTE: To remove a node, @see removeChild\n            NOTE: To remove a block (maybe a node, maybe text), @see removeBlock\n            NOTE: To remove a single occurace of text, @see removeText\n        '''\n        # TODO: This would be a good candidate for the refactor of text blocks\n        removedBlocks = []\n\n        blocks = self.blocks\n        for i in range(len(blocks)):\n\n            block = blocks[i]\n\n            # We only care about text blocks\n            if issubclass(block.__class__, AdvancedTag):\n                continue\n\n            if text in block:\n                # Got a match, save a copy of the text block pre-replace for the return\n                removedBlocks.append( block[:] )\n                \n                # And replace the text within this matched block\n                blocks[i] = block.replace(text, '')\n\n        \n        # Regenerate self.text\n        self.text = ''.join([thisBlock for thisBlock in blocks if not issubclass(thisBlock.__class__, AdvancedTag)])\n\n        return removedBlocks", "response": "Removes all occuraces of given text in a text node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving this node from its parent if it has a parent.", "response": "def remove(self):\n        '''\n            remove - Will remove this node from its parent, if it has a parent (thus taking it out of the HTML tree)\n\n                NOTE: If you are using an IndexedAdvancedHTMLParser, calling this will NOT update the index. You MUST call\n                  reindex method manually.\n\n            @return <bool> - While JS DOM defines no return for this function, this function will return True if a\n               remove did happen, or False if no parent was set.\n        '''\n        if self.parentNode:\n            self.parentNode.removeChild(self)\n            # self.parentNode will now be None by 'removeChild' method\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef removeBlocks(self, blocks):\n        '''\n            removeBlock - Removes a list of blocks (the first occurance of each) from the direct children of this node.\n\n            @param blocks  list<str/AdvancedTag> - List of AdvancedTags for tag nodes, else strings for text nodes\n\n            @return The removed blocks in each slot, or None if None removed.\n\n            @see removeChild\n            @see removeText\n\n            For multiple, @see removeBlocks\n        '''\n        ret = []\n        for block in blocks:\n            if issubclass(block.__class__, AdvancedTag):\n                ret.append( self.removeChild(block) )\n            else:\n                # TODO: Should this just forward to removeText?\n                ret.append( self.removeBlock(block) )\n\n        return ret", "response": "Removes a list of blocks from the direct children of this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nappends a child to this element.", "response": "def appendChild(self, child):\n        '''\n            appendChild - Append a child to this element.\n\n            @param child <AdvancedTag> - Append a child element to this element\n        '''\n\n        # Associate parentNode of #child to this tag\n        child.parentNode = self\n\n        # Associate owner document to child and all children recursive\n        ownerDocument = self.ownerDocument\n\n        child.ownerDocument = ownerDocument\n        for subChild in child.getAllChildNodes():\n            subChild.ownerDocument = ownerDocument\n\n        # Our tag cannot be self-closing if we have a child tag\n        self.isSelfClosing = False\n\n        # Append to both \"children\" and \"blocks\"\n        self.children.append(child)\n        self.blocks.append(child)\n        return child"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef appendBlock(self, block):\n        '''\n            append / appendBlock - Append a block to this element. A block can be a string (text node), or an AdvancedTag (tag node)\n\n            @param <str/AdvancedTag> - block to add\n\n            @return - #block\n\n            NOTE: To add multiple blocks, @see appendBlocks\n                  If you know the type, use either @see appendChild for tags or @see appendText for text\n        '''\n        # Determine block type and call appropriate method\n        if isinstance(block, AdvancedTag):\n            self.appendNode(block)\n        else:\n            self.appendText(block)\n        \n        return block", "response": "Append a block to this element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nappend blocks to this element.", "response": "def appendBlocks(self, blocks):\n        '''\n            appendBlocks - Append blocks to this element. A block can be a string (text node), or an AdvancedTag (tag node)\n\n            @param blocks list<str/AdvancedTag> - A list, in order to append, of blocks to add.\n\n            @return - #blocks\n\n            NOTE: To add a single block, @see appendBlock\n                  If you know the type, use either @see appendChild for tags or @see appendText for text\n        '''\n        for block in blocks:\n            if isinstance(block, AdvancedTag):\n                self.appendNode(block)\n            else:\n                self.appendText(block)\n\n        return blocks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef appendInnerHTML(self, html):\n        '''\n            appendInnerHTML - Appends nodes from arbitrary HTML as if doing element.innerHTML += 'someHTML' in javascript.\n\n            @param html <str> - Some HTML\n\n            NOTE: If associated with a document ( AdvancedHTMLParser ), the html will use the encoding associated with\n                    that document.\n\n            @return - None. A browser would return innerHTML, but that's somewhat expensive on a high-level node.\n              So just call .innerHTML explicitly if you need that\n        '''\n\n        # Late-binding to prevent circular import\n        from .Parser import AdvancedHTMLParser\n\n        # Inherit encoding from the associated document, if any.\n        encoding = None\n        if self.ownerDocument:\n            encoding = self.ownerDocument.encoding\n\n        # Generate blocks (text nodes and AdvancedTag's) from HTML\n        blocks = AdvancedHTMLParser.createBlocksFromHTML(html, encoding)\n\n        # Throw them onto this node\n        self.appendBlocks(blocks)", "response": "Append nodes from arbitrary HTML as if doing element. innerHTML += someHTML in javascript."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a child tag from the tree if present.", "response": "def removeChild(self, child):\n        '''\n            removeChild - Remove a child tag, if present.\n\n                @param child <AdvancedTag> - The child to remove\n\n                @return - The child [with parentNode cleared] if removed, otherwise None.\n\n                NOTE: This removes a tag. If removing a text block, use #removeText function.\n                  If you need to remove an arbitrary block (text or AdvancedTag), @see removeBlock\n\n                Removing multiple children? @see removeChildren\n        '''\n        try:\n            # Remove from children and blocks\n            self.children.remove(child)\n            self.blocks.remove(child)\n\n            # Clear parent node association on child\n            child.parentNode = None\n\n            # Clear document reference on removed child and all children thereof\n            child.ownerDocument = None\n            for subChild in child.getAllChildNodes():\n                subChild.ownerDocument = None\n            return child\n        except ValueError:\n            # TODO: What circumstances cause this to be raised? Is it okay to have a partial remove?\n            #\n            #  Is it only when \"child\" is not found? Should that just be explicitly tested?\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove multiple child AdvancedTags.", "response": "def removeChildren(self, children):\n        '''\n            removeChildren - Remove multiple child AdvancedTags.\n\n            @see removeChild\n\n            @return list<AdvancedTag/None> - A list of all tags removed in same order as passed.\n                Item is \"None\" if it was not attached to this node, and thus was not removed.\n        '''\n        ret = []\n\n        for child in children:\n            ret.append( self.removeChild(child) )\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef removeBlock(self, block):\n        '''\n            removeBlock - Removes a single block (text node or AdvancedTag) which is a child of this object.\n\n            @param block <str/AdvancedTag> - The block (text node or AdvancedTag) to remove.\n            \n            @return Returns the removed block if one was removed, or None if requested block is not a child of this node.\n\n            NOTE: If you know you are going to remove an AdvancedTag, @see removeChild\n                  If you know you are going to remove a text node,    @see removeText\n\n            If removing multiple blocks, @see removeBlocks\n        '''\n        if issubclass(block.__class__, AdvancedTag):\n            return self.removeChild(block)\n        else:\n            return self.removeText(block)", "response": "Removes a single block which is a child of this object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insertBefore(self, child, beforeChild):\n        '''\n            insertBefore - Inserts a child before #beforeChild\n\n\n                @param child <AdvancedTag/str> - Child block to insert\n\n                @param beforeChild <AdvancedTag/str> - Child block to insert before. if None, will  be appended\n\n            @return - The added child. Note, if it is a text block (str), the return isl NOT be linked by reference.\n\n            @raises ValueError - If #beforeChild is defined and is not a child of this node\n\n        '''\n        # When the second arg is null/None, the node is appended. The argument is required per JS API, but null is acceptable..\n        if beforeChild is None:\n            return self.appendBlock(child)\n\n        # If #child is an AdvancedTag, we need to add it to both blocks and children.\n        isChildTag = isTagNode(child)\n\n        myBlocks = self.blocks\n        myChildren = self.children\n\n        # Find the index #beforeChild falls under current element\n        try:\n            blocksIdx =  myBlocks.index(beforeChild)\n            if isChildTag:\n                childrenIdx = myChildren.index(beforeChild)\n        except ValueError:\n            # #beforeChild is not a child of this element. Raise error.\n            raise ValueError('Provided \"beforeChild\" is not a child of element, cannot insert.')\n        \n        # Add to blocks in the right spot\n        self.blocks = myBlocks[:blocksIdx] + [child] + myBlocks[blocksIdx:]\n        # Add to child in the right spot\n        if isChildTag: \n            self.children = myChildren[:childrenIdx] + [child] + myChildren[childrenIdx:]\n        \n        return child", "response": "Insert a child into the node with the highest priority."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef insertAfter(self, child, afterChild):\n        '''\n            insertAfter - Inserts a child after #afterChild\n\n\n                @param child <AdvancedTag/str> - Child block to insert\n\n                @param afterChild <AdvancedTag/str> - Child block to insert after. if None, will  be appended\n\n            @return - The added child. Note, if it is a text block (str), the return isl NOT be linked by reference.\n        '''\n\n        # If after child is null/None, just append\n        if afterChild is None:\n            return self.appendBlock(child)\n\n        isChildTag = isTagNode(child)\n\n        myBlocks = self.blocks\n        myChildren = self.children\n\n        # Determine where we need to insert this both in \"blocks\" and, if a tag, \"children\"\n        try:\n            blocksIdx =  myBlocks.index(afterChild)\n            if isChildTag:\n                childrenIdx = myChildren.index(afterChild)\n        except ValueError:\n            raise ValueError('Provided \"afterChild\" is not a child of element, cannot insert.')\n\n        # Append child to requested spot\n        self.blocks = myBlocks[:blocksIdx+1] + [child] + myBlocks[blocksIdx+1:]\n        if isChildTag:\n            self.children = myChildren[:childrenIdx+1] + [child] + myChildren[childrenIdx+1:]\n\n        return child", "response": "Insert a child into the tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the last child block text or tag", "response": "def lastChild(self):\n        '''\n            lastChild - property, Get the last child block, text or tag\n\n                @return <str/AdvancedTag/None> - The last child block, or None if no child blocks\n        '''\n        blocks = object.__getattribute__(self, 'blocks')\n        # First block is empty string for indent, but don't hardcode incase that changes\n        if blocks[0] == '':\n           firstIdx = 1\n        else:\n           firstIdx = 0\n\n        if len(blocks) <= firstIdx:\n            return None\n\n        return blocks[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next sibling that is an element. This is the next sibling that is an element.", "response": "def nextElementSibling(self):\n        '''\n            nextElementSibling - Returns the next sibling that is an element.\n                This is the tag node following this node in the parent's list of children\n\n                @return <None/AdvancedTag> - None if there are no children (tag) in the parent after this node,\n                                                    Otherwise the following element (tag)\n        '''\n        parentNode = self.parentNode\n\n        # If no parent, no siblings\n        if not parentNode:\n            return None\n\n        # Determine the index in children\n        myElementIdx = parentNode.children.index(self)\n\n        # If we are last child, no next sibling\n        if myElementIdx == len(parentNode.children) - 1:\n            return None\n\n        # Else, return the next child in parent\n        return parentNode.children[myElementIdx+1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the previous sibling of this node in the parent s list", "response": "def previousSibling(self):\n        '''\n            previousSibling - Returns the previous sibling. This would be the previous node (text or tag) in the parent's list\n            \n                This could be text or an element. use previousSiblingElement to ensure element\n\n\n                @return <None/str/AdvancedTag> - None if there are no nodes (text or tag) in the parent before this node,\n                                                    Otherwise the previous node (text or tag)\n        '''\n        parentNode = self.parentNode\n\n        # If no parent, no previous sibling\n        if not parentNode:\n            return None\n\n        # Determine block index on parent of this node\n        myBlockIdx = parentNode.blocks.index(self)\n        \n        # If we are the first, no previous sibling\n        if myBlockIdx == 0:\n            return None\n\n        # Else, return the previous block in parent\n        return parentNode.blocks[myBlockIdx-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef previousElementSibling(self):\n        '''\n            previousElementSibling - Returns the previous  sibling  that is an element. \n\n                                        This is the previous tag node in the parent's list of children\n\n\n                @return <None/AdvancedTag> - None if there are no children (tag) in the parent before this node,\n                                                    Otherwise the previous element (tag)\n\n        '''\n        parentNode = self.parentNode\n\n        # If no parent, no siblings\n        if not parentNode:\n            return None\n\n        # Determine this node's index in the children of parent\n        myElementIdx = parentNode.children.index(self)\n        \n        # If we are the first child, no previous element\n        if myElementIdx == 0:\n            return None\n\n        # Else, return previous element tag\n        return parentNode.children[myElementIdx-1]", "response": "Returns the previous sibling that is an element. \n\n clf - The node that is an element. \n\n clf - The node that is an element. \n\n clf - The node that is an element. \n\nMimeType This is the previous element in the parent s list of children\n\n                This is the previous element in the parent s list of children\n ArcGIS elements."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tagBlocks(self):\n        '''\n            tagBlocks - Property. \n                        Returns all the blocks which are direct children of this node, where that block is a tag (not text)\n\n                NOTE: This is similar to .children , and you should probably use .children instead except within this class itself\n\n                @return list<AdvancedTag> - A list of direct children which are tags.\n        '''\n        myBlocks = self.blocks\n\n        return [block for block in myBlocks if issubclass(block.__class__, AdvancedTag)]", "response": "Property. \n                        Returns all the blocks which are direct children of this node where that block is a tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getBlocksTags(self):\n        '''\n            getBlocksTags - Returns a list of tuples referencing the blocks which are direct children of this node, and the block is an AdvancedTag.\n\n                The tuples are ( block, blockIdx ) where \"blockIdx\" is the index of self.blocks wherein the tag resides.\n\n                @return list< tuple(block, blockIdx) > - A list of tuples of child blocks which are tags and their index in the self.blocks list\n        '''\n        myBlocks = self.blocks\n\n        return [ (myBlocks[i], i) for i in range( len(myBlocks) ) if issubclass(myBlocks[i].__class__, AdvancedTag) ]", "response": "getBlocksTags - Returns a list of tuples referencing the blocks which are direct children of this node and the block is an AdvancedTag."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef textBlocks(self):\n        '''\n            textBlocks - Property. \n                        Returns all the blocks which are direct children of this node, where that block is a text (not a tag)\n\n                @return list<AdvancedTag> - A list of direct children which are text.\n        '''\n        myBlocks = self.blocks\n\n        return [block for block in myBlocks if not issubclass(block.__class__, AdvancedTag)]", "response": "Property. vsetTextBlocks Returns all the blocks which are direct children of this node where that block is a text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef containsUid(self, uid):\n        '''\n            containsUid - Check if the uid (unique internal ID) appears anywhere as a direct child to this node, or the node itself.\n\n                @param uid <uuid.UUID> - uuid to check\n\n            @return <bool> - True if #uid is this node's uid, or is the uid of any children at any level down\n        '''\n        # Check if this node is the match\n        if self.uid == uid:\n            return True\n\n        # Scan all children\n        for child in self.children:\n            if child.containsUid(uid):\n                return True\n\n        return False", "response": "Check if the uid appears anywhere as a direct child to this node or the node itself."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getAllChildNodes(self):\n        '''\n            getAllChildNodes - Gets all the children, and their children, \n               and their children, and so on, all the way to the end as a TagCollection.\n               \n               Use .childNodes for a regular list\n\n            @return TagCollection<AdvancedTag> - A TagCollection of all children (and their children recursive)\n        '''\n\n        ret = TagCollection()\n\n        # Scan all the children of this node\n        for child in self.children:\n            # Append each child\n            ret.append(child)\n\n            # Append children's children recursive\n            ret += child.getAllChildNodes()\n\n        return ret", "response": "getAllChildNodes - Gets all the children and their children and their children recursive"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getAllNodeUids(self):\n        '''\n            getAllNodeUids - Returns all the unique internal IDs from getAllChildNodeUids, but also includes this tag's uid\n\n            @return set<uuid.UUID> A set of uuid objects\n        '''\n        # Start with a set including this tag's uuid\n        ret = { self.uid }\n\n        ret.update(self.getAllChildNodeUids())\n\n        return ret", "response": "getAllNodeUids - Returns all the unique internal IDs from getAllChildNodeUids but also includes this tag s uid\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getPeers(self):\n        '''\n            getPeers - Get elements who share a parent with this element\n\n            @return - TagCollection of elements\n        '''\n        parentNode = self.parentNode\n        # If no parent, no peers\n        if not parentNode:\n            return None\n\n        peers = parentNode.children\n\n        # Otherwise, get all children of parent excluding this node\n        return TagCollection([peer for peer in peers if peer is not self])", "response": "getPeers - Get elements who share a parent with this element\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getStartTag(self):\n        '''\n            getStartTag - Returns the start tag represented as HTML\n\n            @return - String of start tag with attributes\n        '''\n        attributeStrings = []\n        # Get all attributes as a tuple (name<str>, value<str>)\n        for name, val in self._attributes.items():\n            # Get all attributes\n            if val:\n                val = tostr(val)\n\n            # Only binary attributes have a \"present/not present\"\n            if val or name not in TAG_ITEM_BINARY_ATTRIBUTES:\n                # Escape any quotes found in the value\n                val = escapeQuotes(val)\n\n                # Add a name=\"value\" to the resulting string\n                attributeStrings.append('%s=\"%s\"' %(name, val) )\n            else:\n                # This is a binary attribute, and thus only includes the name ( e.x. checked )\n                attributeStrings.append(name)\n\n        # Join together all the attributes in @attributeStrings list into a string\n        if attributeStrings:\n            attributeString = ' ' + ' '.join(attributeStrings)\n        else:\n            attributeString = ''\n\n        # If this is a self-closing tag, generate like  <tag attr1=\"val\" attr2=\"val2\" />  with the close \"/>\"\n        # Include the indent prior to tag opening\n        if self.isSelfClosing is False:\n            return \"%s<%s%s >\" %(self._indent, self.tagName, attributeString)\n        else:\n            return \"%s<%s%s />\" %(self._indent, self.tagName, attributeString)", "response": "Returns the start tag represented as HTML\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the end tag representation as HTML string", "response": "def getEndTag(self):\n        '''\n            getEndTag - returns the end tag representation as HTML string\n\n            @return - String of end tag\n        '''\n        # If this is a self-closing tag, we have no end tag (opens and closes in the start)\n        if self.isSelfClosing is True:\n            return ''\n\n        tagName = self.tagName\n\n        # Do not add any indentation to the end of preformatted tags.\n        if self._indent and tagName in PREFORMATTED_TAGS:\n            return \"</%s>\" %(tagName, )\n\n        # Otherwise, indent the end of this tag\n        return \"%s</%s>\" %(self._indent, tagName)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef innerHTML(self):\n        '''\n            innerHTML - Returns an HTML string of the inner contents of this tag, including children.\n\n            @return - String of inner contents HTML\n        '''\n\n        # If a self-closing tag, there are no contents\n        if self.isSelfClosing is True:\n            return ''\n\n        # Assemble all the blocks.\n        ret = []\n\n        # Iterate through blocks\n        for block in self.blocks:\n            # For each block:\n            #   If a tag, append the outer html (start tag, contents, and end tag)\n            #   Else, append the text node directly\n\n            if isinstance(block, AdvancedTag):\n                ret.append(block.outerHTML)\n            else:\n                ret.append(block)\n        \n        return ''.join(ret)", "response": "Returns an HTML string of the inner contents of this tag including children."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an attribute value on this tag.", "response": "def getAttribute(self, attrName, defaultValue=None):\n        '''\n            getAttribute - Gets an attribute on this tag. Be wary using this for classname, maybe use addClass/removeClass. Attribute names are all lowercase.\n                @return - The attribute value, or None if none exists.\n        '''\n\n        if attrName in TAG_ITEM_BINARY_ATTRIBUTES:\n            if attrName in self._attributes:\n                attrVal = self._attributes[attrName]\n                if not attrVal:\n                    return True # Empty valued binary attribute\n\n                return attrVal # optionally-valued binary attribute\n            else:\n                return False\n        else:\n            return self._attributes.get(attrName, defaultValue)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getAttributesList(self):\n        '''\n            getAttributesList - Get a copy of all attributes as a list of tuples (name, value)\n\n              ALL values are converted to string and copied, so modifications will not affect the original attributes.\n                If you want types like \"style\" to work as before, you'll need to recreate those elements (like StyleAttribute(strValue) ).\n\n              @return list< tuple< str(name), str(value) > > - A list of tuples of attrName, attrValue pairs, all converted to strings.\n\n                This is suitable for passing back into AdvancedTag when creating a new tag.\n        '''\n        return [ (tostr(name)[:], tostr(value)[:]) for name, value in self._attributes.items() ]", "response": "getAttributesList - Get a copy of all attributes as a list of tuples name and value pairs all converted to strings and all values are copied to strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getAttributesDict(self):\n        '''\n            getAttributesDict - Get a copy of all attributes as a dict map of name -> value\n\n              ALL values are converted to string and copied, so modifications will not affect the original attributes.\n                If you want types like \"style\" to work as before, you'll need to recreate those elements (like StyleAttribute(strValue) ).\n\n              @return <dict ( str(name), str(value) )> - A dict of attrName to attrValue , all as strings and copies.\n        '''\n            \n        return { tostr(name)[:] : tostr(value)[:] for name, value in self._attributes.items() }", "response": "Get a copy of all attributes as a dict of name - > value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hasAttribute(self, attrName):\n        '''\n            hasAttribute - Checks for the existance of an attribute. Attribute names are all lowercase.\n   \n                @param attrName <str> - The attribute name\n                \n                @return <bool> - True or False if attribute exists by that name\n        '''\n        attrName = attrName.lower()\n\n        # Check if requested attribute is present on this node\n        return bool(attrName in self._attributes)", "response": "Checks if the attribute name is present on this node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving an attribute by name.", "response": "def removeAttribute(self, attrName):\n        '''\n            removeAttribute - Removes an attribute, by name.\n            \n            @param attrName <str> - The attribute name\n\n        '''\n        attrName = attrName.lower()\n\n        # Delete provided attribute name ( #attrName ) from attributes map\n        try:\n            del self._attributes[attrName]\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a class name to the end of the class attribute.", "response": "def addClass(self, className):\n        '''\n            addClass - append a class name to the end of the \"class\" attribute, if not present\n\n                @param className <str> - The name of the class to add\n        '''\n        className = stripWordsOnly(className)\n\n        if not className:\n            return None\n\n        if ' ' in className:\n            # Multiple class names passed, do one at a time\n            for oneClassName in className.split(' '):\n                self.addClass(oneClassName)\n            return\n\n        myClassNames = self._classNames\n\n        # Do not allow duplicates\n        if className in myClassNames:\n            return\n\n        # Regenerate \"classNames\" and \"class\" attr.\n        #   TODO: Maybe those should be properties?\n        myClassNames.append(className)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef removeClass(self, className):\n        '''\n            removeClass - remove a class name if present. Returns the class name if  removed, otherwise None.\n\n                @param className <str> - The name of the class to remove\n\n                @return <str> - The class name removed if one was removed, otherwise None if #className wasn't present\n        '''\n        className = stripWordsOnly(className)\n\n        if not className:\n            return None\n\n        if ' ' in className:\n            # Multiple class names passed, do one at a time\n            for oneClassName in className.split(' '):\n                self.removeClass(oneClassName)\n            return\n\n        myClassNames = self._classNames\n\n        # If not present, this is a no-op\n        if className not in myClassNames:\n            return None\n\n\n        myClassNames.remove(className)\n\n        return className", "response": "Removes a class name if present. Returns the class name if removed otherwise None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary of style attribute value pairs.", "response": "def getStyleDict(self):\n        '''\n            getStyleDict - Gets a dictionary of style attribute/value pairs.\n\n            @return - OrderedDict of \"style\" attribute.\n        '''\n\n        # TODO: This method is not used and does not appear in any tests.\n\n        styleStr = (self.getAttribute('style') or '').strip()\n        styles = styleStr.split(';') # Won't work for strings containing semicolon..\n        styleDict = OrderedDict()\n        for item in styles:\n            try:\n                splitIdx = item.index(':')\n                name = item[:splitIdx].strip().lower()\n                value = item[splitIdx+1:].strip()\n                styleDict[name] = value\n            except:\n                continue\n\n        return styleDict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setStyle(self, styleName, styleValue):\n        '''\n            setStyle - Sets a style param. Example: \"display\", \"block\"\n\n                If you need to set many styles on an element, use setStyles instead. \n                It takes a dictionary of attribute, value pairs and applies it all in one go (faster)\n\n                To remove a style, set its value to empty string.\n                When all styles are removed, the \"style\" attribute will be nullified.\n\n            @param styleName - The name of the style element\n            @param styleValue - The value of which to assign the style element\n\n            @return - String of current value of \"style\" after change is made.\n        '''\n        myAttributes = self._attributes\n\n        if 'style' not in myAttributes:\n            myAttributes['style'] = \"%s: %s\" %(styleName, styleValue)\n        else:\n            setattr(myAttributes['style'], styleName, styleValue)", "response": "Sets a style attribute of the element containing the specified name and value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setStyles(self, styleUpdatesDict):\n        '''\n            setStyles - Sets one or more style params. \n                This all happens in one shot, so it is much much faster than calling setStyle for every value.\n\n                To remove a style, set its value to empty string.\n                When all styles are removed, the \"style\" attribute will be nullified.\n\n            @param styleUpdatesDict - Dictionary of attribute : value styles.\n\n            @return - String of current value of \"style\" after change is made.\n        '''\n        setStyleMethod = self.setStyle\n        for newName, newValue in styleUpdatesDict.items():\n            setStyleMethod(newName, newValue)\n\n        return self.style", "response": "Sets the style of the elements in styleUpdatesDict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching children of this tag for a tag containing an id. Returns the AdvancedTag or None if no such tag exists.", "response": "def getElementById(self, _id):\n        '''\n            getElementById - Search children of this tag for a tag containing an id\n\n            @param _id - String of id\n\n            @return - AdvancedTag or None\n        '''\n        for child in self.children:\n            if child.getAttribute('id') == _id:\n                return child\n            found = child.getElementById(_id)\n            if found is not None:\n                return found\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getElementsByAttr(self, attrName, attrValue):\n        '''\n            getElementsByAttr - Search children of this tag for tags with an attribute name/value pair\n\n            @param attrName - Attribute name (lowercase)\n            @param attrValue - Attribute value\n\n            @return - TagCollection of matching elements\n        '''\n        elements = []\n        for child in self.children:\n            if child.getAttribute(attrName) == attrValue:\n                elements.append(child)\n            elements += child.getElementsByAttr(attrName, attrValue)\n        return TagCollection(elements)", "response": "getElementsByAttr - Search children of this tag for tags with an attribute name and value pair\n            - Attribute name to use as the attribute name and value pair\n            - Attribute value to use as the attribute value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getElementsByClassName(self, className):\n        '''\n            getElementsByClassName - Search children of this tag for tags containing a given class name\n\n            @param className - Class name\n\n            @return - TagCollection of matching elements\n        '''\n        elements = []\n        for child in self.children:\n            if child.hasClass(className) is True:\n                elements.append(child)\n            elements += child.getElementsByClassName(className)\n        return TagCollection(elements)", "response": "getElementsByClassName - Search children of this tag for tags containing a given class name\n            - Tag class name\n            - Class name of the tag"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getFirstElementCustomFilter(self, filterFunc):\n        '''\n            getFirstElementCustomFilter - Gets the first element which matches a given filter func.\n\n                Scans first child, to the bottom, then next child to the bottom, etc. Does not include \"self\" node.\n\n            @param filterFunc <function> - A function or lambda expression that should return \"True\" if the passed node matches criteria.\n\n            @return <AdvancedTag/None> - First match, or None\n\n            @see getElementsCustomFilter\n        '''\n\n        for child in self.children:\n            if filterFunc(child) is True:\n                return child\n\n            childSearchResult = child.getFirstElementCustomFilter(filterFunc)\n            if childSearchResult is not None:\n                return childSearchResult\n\n        return None", "response": "Gets the first element which matches a given filterFunc."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getParentElementCustomFilter(self, filterFunc):\n        '''\n            getParentElementCustomFilter - Runs through parent on up to document root, returning the\n\n                                              first tag which filterFunc(tag) returns True.\n\n                @param filterFunc <function/lambda> - A function or lambda expression that should return \"True\" if the passed node matches criteria.\n\n                @return <AdvancedTag/None> - First match, or None\n\n\n                @see getFirstElementCustomFilter for matches against children\n        '''\n        parentNode = self.parentNode\n        while parentNode:\n\n            if filterFunc(parentNode) is True:\n                return parentNode\n\n            parentNode = parentNode.parentNode\n\n        return None", "response": "This method returns the first tag which filterFunc returns True."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getPeersWithAttrValues(self, attrName, attrValues):\n        '''\n            getPeersWithAttrValues - Gets peers (elements on same level) whose attribute given by #attrName \n                are in the list of possible vaues #attrValues\n\n            @param attrName - Name of attribute\n            @param attrValues - List of possible values which will match\n\n            @return - None if no parent element (error condition), otherwise a TagCollection of peers that matched.\n        '''\n        peers = self.peers\n        if peers is None:\n            return None\n        return TagCollection([peer for peer in peers if peer.getAttribute(attrName) in attrValues])", "response": "Returns a TagCollection of peers whose attribute given by attrName is in the list of possible values which will match attrValues."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getPeersByName(self, name):\n        '''\n            getPeersByName - Gets peers (elements on same level) with a given name\n\n            @param name - Name to match\n\n            @return - None if no parent element (error condition), otherwise a TagCollection of peers that matched.\n        '''\n        peers = self.peers\n        if peers is None:\n            return None\n        return TagCollection([peer for peer in peers if peer.name == name])", "response": "Returns a TagCollection of peers with a given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompares two tags and return True if they are the same.", "response": "def isTagEqual(self, other):\n        '''\n            isTagEqual - Compare if a tag contains the same tag name and attributes as another tag,\n\n                i.e. if everything between < and > parts of this tag are the same.\n\n                Does NOT compare children, etc. Does NOT compare if these are the same exact tag in the html (use regular == operator for that)\n\n                So for example:\n\n                    tag1 = document.getElementById('something')\n                    tag2 = copy.copy(tag1)\n\n                    tag1 == tag2          # This is False\n                    tag1.isTagEqual(tag2) # This is True\n\n                @return bool - True if tags have the same name and attributes, otherwise False\n        '''\n#        if type(other) != type(self):\n#            return False\n\n#       NOTE: Instead of type check,\n#          just see if we can get the needed attributes in case subclassing\n        try:\n            if self.tagName != other.tagName:\n                return False\n\n            myAttributes = self._attributes\n            otherAttributes = other._attributes\n\n            attributeKeysSelf = list(myAttributes.keys())\n            attributeKeysOther = list(otherAttributes.keys())\n        except:\n            return False\n\n        # Check that we have all the same attribute names\n        if set(attributeKeysSelf) != set(attributeKeysOther):\n            return False\n\n        for key in attributeKeysSelf:\n\n            if myAttributes.get(key) != otherAttributes.get(key):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends an item to this tag collection", "response": "def append(self, tag):\n        '''\n            append - Append an item to this tag collection\n\n            @param tag - an AdvancedTag\n        '''\n        list.append(self, tag)\n        self.uids.add(tag.uid)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an item from this tag collection", "response": "def remove(self, toRemove):\n        '''\n            remove - Remove an item from this tag collection\n\n            @param toRemove - an AdvancedTag\n        '''\n        list.remove(self, toRemove)\n        self.uids.remove(toRemove.uid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters only the immediate objects contained within this Collection against a function or lambda expression that returns True to have that element", "response": "def filterCollection(self, filterFunc):\n        '''\n            filterCollection - Filters only the immediate objects contained within this Collection against a function, not including any children\n\n            @param filterFunc <function> - A function or lambda expression that returns True to have that element match\n\n            @return TagCollection<AdvancedTag>\n        '''\n        ret = TagCollection()\n        if len(self) == 0:\n            return ret\n\n        for tag in self:\n            if filterFunc(tag) is True:\n                ret.append(tag)\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getElementsByClassName(self, className):\n        '''\n            getElementsByClassName - Get elements within this collection containing a specific class name\n\n            @param className - A single class name\n\n            @return - TagCollection of unique elements within this collection tagged with a specific class name\n        '''\n        ret = TagCollection()\n        if len(self) == 0:\n            return ret\n        _cmpFunc = lambda tag : tag.hasClass(className)\n        for tag in self:\n            TagCollection._subset(ret, _cmpFunc, tag)\n        \n        return ret", "response": "getElementsByClassName - Get elements within this collection containing a specific class name\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getElementById(self, _id):\n        '''\n            getElementById - Gets an element within this collection by id\n\n            @param _id - string of \"id\" attribute\n\n            @return - a single tag matching the id, or None if none found\n        '''\n        for tag in self:\n            if tag.id == _id:\n                return tag\n            for subtag in tag.children:\n                tmp = subtag.getElementById(_id)\n                if tmp is not None:\n                    return tmp\n        return None", "response": "Gets an element within this collection by id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getElementsByAttr(self, attr, value):\n        '''\n            getElementsByAttr - Get elements within this collection posessing a given attribute/value pair\n\n            @param attr - Attribute name (lowercase)\n            @param value - Matching value\n\n            @return - TagCollection of all elements matching name/value\n        '''\n        ret = TagCollection()\n        if len(self) == 0:\n            return ret\n\n        attr = attr.lower()\n        _cmpFunc = lambda tag : tag.getAttribute(attr) == value\n        for tag in self:\n            TagCollection._subset(ret, _cmpFunc, tag)\n        \n        return ret", "response": "getElementsByAttr - Get elements within this collection posessing a given attribute value pair\n            - Name of the attribute to search for value - Value of the attribute to search for"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getElementsWithAttrValues(self, attr, values):\n        '''\n            getElementsWithAttrValues - Get elements within this collection possessing an attribute name matching one of several values\n\n            @param attr <lowercase str> - Attribute name (lowerase)\n            @param values set<str> - Set of possible matching values\n\n            @return - TagCollection of all elements matching criteria\n        '''\n        ret = TagCollection()\n        if len(self) == 0:\n            return ret\n\n        if type(values) != set:\n            values = set(values)\n\n        attr = attr.lower()\n        _cmpFunc = lambda tag : tag.getAttribute(attr) in values\n        for tag in self:\n            TagCollection._subset(ret, _cmpFunc, tag)\n        \n        return ret", "response": "getElementsWithAttrValues - Get elements within this collection possessing an attribute name matching one of several values\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getElementsCustomFilter(self, filterFunc):\n        '''\n            getElementsCustomFilter - Get elements within this collection that match a user-provided function.\n\n            @param filterFunc <function> - A function that returns True if the element matches criteria\n\n            @return - TagCollection of all elements that matched criteria\n        '''\n        ret = TagCollection()\n        if len(self) == 0:\n            return ret\n\n        _cmpFunc = lambda tag : filterFunc(tag) is True\n        for tag in self:\n            TagCollection._subset(ret, _cmpFunc, tag)\n\n        return ret", "response": "getElementsCustomFilter - Get elements within this collection that match a user - provided function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all the nodes and all their children for every node within this collection", "response": "def getAllNodes(self):\n        '''\n            getAllNodes - Gets all the nodes, and all their children for every node within this collection\n        '''\n        ret = TagCollection()\n\n        for tag in self:\n            ret.append(tag)\n            ret += tag.getAllChildNodes()\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains(self, em):\n        '''\n            contains - Check if #em occurs within any of the elements within this list, as themselves or as a child, any\n               number of levels down.\n\n               To check if JUST an element is contained within this list directly, use the \"in\" operator.\n            \n            @param em <AdvancedTag> - Element of interest\n\n            @return <bool> - True if contained, otherwise False\n        '''\n\n        for node in self:\n            if node.contains(em):\n                return True\n\n        return False", "response": "Check if an element is contained within this list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the uid of the element in this list is contained in any of the levels down.", "response": "def containsUid(self, uid):\n        '''\n            containsUid - Check if #uid is the uid (unique internal identifier) of any of the elements within this list,\n              as themselves or as a child, any number of levels down.\n\n           \n            @param uid <uuid.UUID> - uuid of interest\n\n            @return <bool> - True if contained, otherwise False\n        '''\n        for node in self:\n            if node.containsUid(uid):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filterAll(self, **kwargs):\n        '''\n            filterAll aka filterAllAnd - Perform a filter operation on ALL nodes in this collection and all their children.\n\n            Results must match ALL the filter criteria. for ANY, use the *Or methods\n\n            For just the nodes in this collection, use \"filter\" or \"filterAnd\" on a TagCollection\n\n            For special filter keys, @see #AdvancedHTMLParser.AdvancedHTMLParser.filter\n\n            Requires the QueryableList module to be installed (i.e. AdvancedHTMLParser was installed\n              without '--no-deps' flag.)\n            \n            For alternative without QueryableList,\n              consider #AdvancedHTMLParser.AdvancedHTMLParser.find method or the getElement* methods\n\n            @return TagCollection<AdvancedTag>\n        '''\n        if canFilterTags is False:\n            raise NotImplementedError('filter methods requires QueryableList installed, it is not. Either install QueryableList, or try the less-robust \"find\" method, or the getElement* methods.')\n\n        allNodes = self.getAllNodes()\n\n        filterableNodes = FilterableTagCollection(allNodes)\n\n        return filterableNodes.filterAnd(**kwargs)", "response": "Filter all the tags in this collection and all their children."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filterAllOr(self, **kwargs):\n        '''\n            filterAllOr - Perform a filter operation on ALL nodes in this collection and all their children.\n\n            Results must match ANY the filter criteria. for ALL, use the *And methods\n\n            For just the nodes in this collection, use \"filterOr\" on a TagCollection\n\n            For special filter keys, @see #AdvancedHTMLParser.AdvancedHTMLParser.filter\n\n            Requires the QueryableList module to be installed (i.e. AdvancedHTMLParser was installed\n              without '--no-deps' flag.)\n            \n            For alternative without QueryableList,\n              consider #AdvancedHTMLParser.AdvancedHTMLParser.find method or the getElement* methods\n\n\n            @return TagCollection<AdvancedTag>\n        '''\n        if canFilterTags is False:\n            raise NotImplementedError('filter methods requires QueryableList installed, it is not. Either install QueryableList, or try the less-robust \"find\" method, or the getElement* methods.')\n\n        allNodes = self.getAllNodes()\n\n        filterableNodes = FilterableTagCollection(allNodes)\n\n        return filterableNodes.filterOr(**kwargs)", "response": "Filter all tags in this collection and all their children."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_endtag(self, tagName):\n        '''\n            handle_endtag - Internal for parsing\n        '''\n        inTag = self._inTag\n        try:\n            # Handle closing tags which should have been closed but weren't\n            foundIt = False\n            for i in range(len(inTag)):\n                if inTag[i].tagName == tagName:\n                    foundIt = True\n                    break\n\n            if not foundIt:\n                sys.stderr.write('WARNING: found close tag with no matching start.\\n')\n                return\n\n            while inTag[-1].tagName != tagName:\n                oldTag = inTag.pop()\n                if oldTag.tagName in PREFORMATTED_TAGS:\n                    self.inPreformatted -= 1\n\n                self.currentIndentLevel -= 1\n\n            inTag.pop()\n            if tagName != INVISIBLE_ROOT_TAG:\n                self.currentIndentLevel -= 1\n            if tagName in PREFORMATTED_TAGS:\n                self.inPreformatted -= 1\n        except:\n            pass", "response": "handle_endtag - Internal for parsing"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getStartTag(self, *args, **kwargs):\n        '''\n            getStartTag - Override the end-spacing rules\n\n              @see AdvancedTag.getStartTag\n        '''\n\n        ret = AdvancedTag.getStartTag(self, *args, **kwargs)\n\n        if ret.endswith(' >'):\n            ret = ret[:-2] + '>'\n        elif object.__getattribute__(self, 'slimSelfClosing') and ret.endswith(' />'):\n            ret = ret[:-3] + '/>'\n\n        return ret", "response": "Override the end - spacing rules\n            getStartTag - Override the end - spacing rules\n            getStartTag - Override the end - spacing rules\n            getStartTag - Override the end - spacing rules\n            getStartTag\n              @see AdvancedTag. getStartTag"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stripIEConditionals(contents, addHtmlIfMissing=True):\n    '''\n        stripIEConditionals - Strips Internet Explorer conditional statements.\n\n        @param contents <str> - Contents String\n        @param addHtmlIfMissing <bool> - Since these normally encompass the \"html\" element, optionally add it back if missing.\n    '''\n    allMatches = IE_CONDITIONAL_PATTERN.findall(contents)\n    if not allMatches:\n        return contents\n\n    for match in allMatches:\n        contents = contents.replace(match, '')\n\n    if END_HTML.match(contents) and not START_HTML.match(contents):\n        contents = addStartTag(contents, '<html>')\n\n    return contents", "response": "Strips Internet Explorer conditional statements from the contents string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addStartTag(contents, startTag):\n    '''\n        addStartTag - Safetly add a start tag to the document, taking into account the DOCTYPE\n\n        @param contents <str> - Contents\n        @param startTag <str> - Fully formed tag, i.e. <html>\n    '''\n\n    matchObj = DOCTYPE_MATCH.match(contents)\n    if matchObj:\n        idx = matchObj.end()\n    else:\n        idx = 0\n    return \"%s\\n%s\\n%s\" %(contents[:idx], startTag, contents[idx:])", "response": "This function will take a list of contents and startTag and add it to the document."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a value to either a string of true or false", "response": "def convertToBooleanString(val=None):\n    '''\n        convertToBooleanString - Converts a value to either a string of \"true\" or \"false\"\n\n            @param val <int/str/bool> - Value\n    '''\n    if hasattr(val, 'lower'):\n        val = val.lower()\n\n        # Technically, if you set one of these attributes (like \"spellcheck\") to a string of 'false',\n        #   it gets set to true. But we will retain \"false\" here.\n        if val in ('false', '0'):\n            return 'false'\n        else:\n            return 'true'\n    \n    try:\n        if bool(val):\n            return \"true\"\n    except:\n        pass\n\n    return \"false\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convertBooleanStringToBoolean(val=None):\n    '''\n        convertBooleanStringToBoolean - Convert from a boolean attribute (string \"true\" / \"false\" ) into a booelan\n    '''\n    if not val:\n        return False\n\n    if hasattr(val, 'lower'):\n        val = val.lower()\n\n    if val == \"false\":\n        return False\n    return True", "response": "Convert a boolean attribute to a booelan\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handleInvalid(invalidDefault):\n    '''\n        _handleInvalid - Common code for raising / returning an invalid value\n\n            @param invalidDefault <None/str/Exception> - The value to return if \"val\" is not empty string/None\n                                                           and \"val\" is not in #possibleValues\n\n                     If instantiated Exception (like ValueError('blah')):  Raise this exception\n\n                     If an Exception type ( like ValueError ) - Instantiate and raise this exception type\n\n                     Otherwise, use this raw value\n    '''\n    # If not\n    #   If an instantiated Exception, raise that exception\n    try:\n        isInstantiatedException = bool( issubclass(invalidDefault.__class__, Exception) )\n    except:\n        isInstantiatedException = False\n\n    if isInstantiatedException:\n        raise invalidDefault\n    else:\n        try:\n            isExceptionType = bool( issubclass( invalidDefault, Exception) )\n        except TypeError:\n            isExceptionType = False\n\n        #   If an Exception type, instantiate and raise\n        if isExceptionType:\n            raise invalidDefault()\n        else:\n        #   Otherwise, just return invalidDefault itself\n            return invalidDefault", "response": "Internal helper function to handle exceptions raised by the base class"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert input value to one of several possible values in the database.", "response": "def convertPossibleValues(val, possibleValues, invalidDefault, emptyValue=''):\n    '''\n        convertPossibleValues - Convert input value to one of several possible values,\n            \n                                    with a default for invalid entries\n\n            @param val <None/str> - The input value\n\n            @param possibleValues list<str> - A list of possible values\n\n            @param invalidDefault <None/str/Exception> - The value to return if \"val\" is not empty string/None\n                                                           and \"val\" is not in #possibleValues\n\n                     If instantiated Exception (like ValueError('blah')):  Raise this exception\n\n                     If an Exception type ( like ValueError ) - Instantiate and raise this exception type\n\n                     Otherwise, use this raw value\n\n            @param emptyValue Default '', used for an empty value (empty string or None)\n                \n\n    '''\n    from .utils import tostr\n\n    # If null, retain null\n    if val is None:\n        if emptyValue is EMPTY_IS_INVALID:\n            return _handleInvalid(invalidDefault)\n        return emptyValue\n\n    # Convert to a string\n    val = tostr(val).lower()\n\n    # If empty string, same as null\n    if val == '':\n        if emptyValue is EMPTY_IS_INVALID:\n            return _handleInvalid(invalidDefault)\n        return emptyValue\n\n    # Check if this is a valid value\n    if val not in possibleValues:\n        return _handleInvalid(invalidDefault)\n\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convertToIntRange(val, minValue, maxValue, invalidDefault, emptyValue=''):\n    '''\n        converToIntRange - Convert input value to an integer within a certain range\n            \n            @param val <None/str/int/float> - The input value\n\n            @param minValue <None/int> - The minimum value (inclusive), or None if no minimum\n\n            @param maxValue <None/int> - The maximum value (inclusive), or None if no maximum\n\n            @param invalidDefault <None/str/Exception> - The value to return if \"val\" is not empty string/None\n                                                           and \"val\" is not in #possibleValues\n\n                     If instantiated Exception (like ValueError('blah')):  Raise this exception\n\n                     If an Exception type ( like ValueError ) - Instantiate and raise this exception type\n\n                     Otherwise, use this raw value\n\n            @param emptyValue Default '', used for an empty value (empty string or None)\n                \n\n    '''\n    from .utils import tostr\n\n    # If null, retain null\n    if val is None or val == '':\n        if emptyValue is EMPTY_IS_INVALID:\n            return _handleInvalid(invalidDefault)\n        return emptyValue\n\n    try:\n        val = int(val)\n    except ValueError:\n        return _handleInvalid(invalidDefault)\n\n    if minValue is not None and val < minValue:\n        return _handleInvalid(invalidDefault)\n    if maxValue is not None and val > maxValue:\n        return _handleInvalid(invalidDefault)\n\n    return val", "response": "Convert input value to an integer within a certain range."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setTag(self, tag):\n        '''\n            _setTag - INTERNAL METHOD. Associated a given AdvancedTag to this attributes dict.\n\n                        If bool(#tag) is True, will set the weakref to that tag.\n\n                        Otherwise, will clear the reference\n\n                      @param tag <AdvancedTag/None> - Either the AdvancedTag to associate, or None to clear current association\n        '''\n        if tag:\n            self._tagRef = weakref.ref(tag)\n        else:\n            self._tagRef = None", "response": "Internal method to set the tag of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handleClassAttr(self):\n        '''\n            _handleClassAttr - Hack to ensure \"class\" and \"style\" show up in attributes when classes are set,\n                and doesn't when no classes are present on associated tag.\n\n                TODO: I don't like this hack.\n        '''\n        if len(self.tag._classNames) > 0:\n            dict.__setitem__(self, \"class\", self.tag.className)\n        else:\n            try:\n                dict.__delitem__(self, \"class\")\n            except:\n                pass\n\n        styleAttr = self.tag.style\n        if styleAttr.isEmpty() is False:\n            dict.__setitem__(self, \"style\", styleAttr)\n        else:\n            try:\n                dict.__delitem__(self, \"style\")\n            except:\n                pass", "response": "Handle class and style attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, key, default=None):\n        '''\n            get - Gets an attribute by key with the chance to provide a default value\n\n                @param key <str> - The key to query\n\n                @param default <Anything> Default None - The value to return if key is not found\n\n             @return - The value of attribute at #key, or #default if not present.\n        '''\n\n        key = key.lower()\n\n        if key == 'class':\n            return self.tag.className\n\n        if key in ('style', 'class') or key in self.keys():\n            return self[key]\n        return default", "response": "Get an attribute by key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the tag association for this style.", "response": "def setTag(self, tag):\n        '''\n            setTag - Set the tag association for this style.\n            \n              This will handle the underlying weakref to the tag.\n\n              Call setTag(None) to clear the association, otherwise setTag(tag) to associate this style to that tag.\n\n\n                @param tag <AdvancedTag/None> - The new association. If None, the association is cleared, otherwise the passed tag\n                    becomes associated with this style.\n\n        '''\n                \n        if tag:\n            self._tagRef = weakref.ref(tag)\n        else:\n            self._tagRef = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ensureHtmlAttribute(self):\n        '''\n            _ensureHtmlAttribute - INTERNAL METHOD. \n                                    Ensure the \"style\" attribute is present in the html attributes when\n                                        is has a value, and absent when it does not.\n\n              This requires special linkage.\n        '''\n        tag = self.tag\n\n        if tag:\n            styleDict = self._styleDict\n            tagAttributes = tag._attributes\n\n            # If this is called before we have _attributes setup\n            if not issubclass(tagAttributes.__class__, SpecialAttributesDict):\n                return\n\n            # If we have any styles set, ensure we have the style=\"whatever\" in the HTML representation,\n            #   otherwise ensure we don't have style=\"\" \n            if not styleDict:\n                tagAttributes._direct_del('style')\n            else: #if 'style' not in tagAttributes.keys():\n                tagAttributes._direct_set('style', self)", "response": "Internal method. \n                                    Ensure the style attribute is present in the html attributes when it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dashNameToCamelCase(dashName):\n        '''\n            dashNameToCamelCase - Converts a \"dash name\" (like padding-top) to its camel-case name ( like \"paddingTop\" )\n\n            @param dashName <str> - A name containing dashes\n\n                NOTE: This method is currently unused, but may be used in the future. kept for completeness.\n\n            @return <str> - The camel-case form\n        '''\n        nameParts = dashName.split('-')\n        for i in range(1, len(nameParts), 1):\n            nameParts[i][0] = nameParts[i][0].upper()\n\n        return ''.join(nameParts)", "response": "Converts a dash name to its camel - case name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a camel case name to a dash - name", "response": "def camelCaseToDashName(camelCase):\n        '''\n            camelCaseToDashName - Convert a camel case name to a dash-name (like paddingTop to padding-top)\n\n            @param camelCase <str> - A camel-case string\n\n            @return <str> - A dash-name\n        '''\n\n        camelCaseList = list(camelCase)\n\n        ret = []\n\n        for ch in camelCaseList:\n            if ch.isupper():\n                ret.append('-')\n                ret.append(ch.lower())\n            else:\n                ret.append(ch)\n\n        return ''.join(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef styleToDict(styleStr):\n        '''\n            getStyleDict - Gets a dictionary of style attribute/value pairs.\n\n              NOTE: dash-names (like padding-top) are used here\n\n            @return - OrderedDict of \"style\" attribute.\n        '''\n        styleStr = styleStr.strip()\n        styles = styleStr.split(';') # Won't work for strings containing semicolon..\n\n        styleDict = OrderedDict()\n        for item in styles:\n            try:\n                splitIdx = item.index(':')\n                name = item[:splitIdx].strip().lower()\n                value = item[splitIdx+1:].strip()\n                styleDict[name] = value\n            except:\n                continue\n\n        return styleDict", "response": "Returns a dictionary of style attribute value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the string representation of this style", "response": "def _asStr(self):\n        '''\n            _asStr - Get the string representation of this style\n\n              @return <str> - A string representation of this style (semicolon separated, key: value format)\n        '''\n\n        styleDict = self._styleDict\n        if styleDict:\n            return '; '.join([name + ': ' + value for name, value in styleDict.items()])\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling rows special attribute which differs if tagName is a textarea or frameset", "response": "def _special_value_rows(em):\n    '''\n        _special_value_rows - Handle \"rows\" special attribute, which differs if tagName is a textarea or frameset\n    '''\n    if em.tagName == 'textarea':\n        return convertToIntRange(em.getAttribute('rows', 2), minValue=1, maxValue=None, invalidDefault=2)\n    else:\n        # frameset\n        return em.getAttribute('rows', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _special_value_cols(em):\n    '''\n        _special_value_cols - Handle \"cols\" special attribute, which differs if tagName is a textarea or frameset\n    '''\n    if em.tagName == 'textarea':\n        return convertToIntRange(em.getAttribute('cols', 20), minValue=1, maxValue=None, invalidDefault=20)\n    else:\n        # frameset\n        return em.getAttribute('cols', '')", "response": "Handle cols special attribute which differs if tagName is a textarea or frameset\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling autocomplete property which has different behaviour for form vs input", "response": "def _special_value_autocomplete(em):\n    '''\n        handle \"autocomplete\" property, which has different behaviour for form vs input\"\n    '''\n    if em.tagName == 'form':\n        return convertPossibleValues(em.getAttribute('autocomplete', 'on'), POSSIBLE_VALUES_ON_OFF, invalidDefault='on', emptyValue=EMPTY_IS_INVALID)\n    # else: input\n    return convertPossibleValues(em.getAttribute('autocomplete', ''), POSSIBLE_VALUES_ON_OFF, invalidDefault=\"\", emptyValue='')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling size property which has different behaviour for input vs everything else", "response": "def _special_value_size(em):\n    '''\n        handle \"size\" property, which has different behaviour for input vs everything else\n    '''\n    if em.tagName == 'input':\n        # TODO: \"size\" on an input is implemented very weirdly. Negative values are treated as invalid,\n        #          A value of \"0\" raises an exception (and does not set HTML attribute)\n        #          No upper limit.\n        return convertToPositiveInt(em.getAttribute('size', 20), invalidDefault=20)\n    return em.getAttribute('size', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a value into a corresponding ata object.", "response": "def get_by_value(cls, value, type):\n        \"\"\" Converts a value into a corresponding  data object.\n        For files, this looks up a file DataObject by name, uuid, and/or md5.\n        For other types, it creates a new DataObject.\n        \"\"\"\n        if type == 'file':\n            return cls._get_file_by_value(value)\n        else:\n            data_object = DataObject(data={\n                'value': cls._type_cast(value, type)}, type=type)\n            data_object.full_clean()\n            data_object.save()\n            return data_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks up a file DataObject by name uuid and or md5.", "response": "def _get_file_by_value(cls, value):\n        \"\"\"Look up a file DataObject by name, uuid, and/or md5.\n        \"\"\"\n        # Ignore any FileResource with no DataObject. This is a typical state\n        # for a deleted file that has not yet been cleaned up.\n        queryset = FileResource.objects.exclude(data_object__isnull=True)\n        matches = FileResource.filter_by_name_or_id_or_tag_or_hash(\n            value, queryset=queryset)\n        if matches.count() == 0:\n            raise ValidationError(\n                'No file found that matches value \"%s\"' % value)\n        elif matches.count() > 1:\n            match_id_list = ['%s@%s' % (match.filename, match.get_uuid())\n                             for match in matches]\n            match_id_string = ('\", \"'.join(match_id_list))\n            raise ValidationError(\n                'Multiple files were found matching value \"%s\": \"%s\". '\\\n                'Use a more precise identifier to select just one file.' % (\n                    value, match_id_string))\n        return matches.first().data_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a path for a given file in such a way that files end up being organized and browsable by run .", "response": "def _get_run_breadcrumbs(cls, source_type, data_object, task_attempt):\n        \"\"\"Create a path for a given file, in such a way\n        that files end up being organized and browsable by run\n        \"\"\"\n        # We cannot generate the path unless connect to a TaskAttempt\n        # and a run\n        if not task_attempt:\n            return []\n        # If multiple tasks exist, use the original.\n        task = task_attempt.tasks.earliest('datetime_created')\n        if task is None:\n            return []\n        run = task.run\n        if run is None:\n            return []\n\n        breadcrumbs = [\n            run.name,\n            \"task-%s\" % str(task.uuid)[0:8],\n            \"attempt-%s\" % str(task_attempt.uuid)[0:8],\n        ]\n\n        # Include any ancestors if run is nested\n        while run.parent is not None:\n            run = run.parent\n            breadcrumbs = [run.name] + breadcrumbs\n\n        # Prepend first breadcrumb with datetime and id\n        breadcrumbs[0] = \"%s-%s-%s\" % (\n            run.datetime_created.strftime('%Y-%m-%dT%H.%M.%SZ'),\n            str(run.uuid)[0:8],\n            breadcrumbs[0])\n\n        breadcrumbs = ['runs'] + breadcrumbs\n        return breadcrumbs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter objects by name ID or tag.", "response": "def filter_by_name_or_id_or_tag(self, query_string, queryset = None):\n        \"\"\"Find objects that match the identifier of form {name}@{ID}, {name},\n        or @{ID}, where ID may be truncated\n        \"\"\"\n        assert self.Model.NAME_FIELD, \\\n            'NAME_FIELD is missing on model %s' % self.Model.__name__\n        assert self.Model.ID_FIELD, \\\n            'ID_FIELD is missing on model %s' % self.Model.__name__\n        assert self.Model.TAG_FIELD, \\\n            'TAG_FIELD is missing on model %s' % self.Model.__name__\n\n        filter_args = {}\n        name, uuid, tag = self._parse_as_name_or_id_or_tag(query_string)\n        if name is not None:\n            filter_args[self.Model.NAME_FIELD] = name\n        if uuid is not None:\n            filter_args[self.Model.ID_FIELD+'__startswith'] = uuid\n        if tag is not None:\n            filter_args[self.Model.TAG_FIELD] = tag\n        if queryset is None:\n            queryset = self.Model.objects.all()\n        return queryset.filter(**filter_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, *args, **kwargs):\n        cls = self.__class__\n        if self.pk:\n            rows = cls.objects.filter(\n                pk=self.pk, _change=self._change).update(\n                _change=self._change + 1)\n            if not rows:\n                raise ConcurrentModificationError(cls.__name__, self.pk)\n            self._change += 1\n\n        count = 0\n        max_retries=3\n        while True:\n            try:\n                return super(BaseModel, self).save(*args, **kwargs)\n            except django.db.utils.OperationalError:\n                if count >= max_retries:\n                    raise\n                count += 1", "response": "This method protects against two processesses concurrently modifying the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks server. ini for server type.", "response": "def get_server_type():\n    \"\"\"Checks server.ini for server type.\"\"\"\n    server_location_file = os.path.expanduser(SERVER_LOCATION_FILE)\n    if not os.path.exists(server_location_file):\n        raise Exception(\n            \"%s not found. Please run 'loom server set \"\n            \"<servertype>' first.\" % server_location_file)\n    config = ConfigParser.SafeConfigParser()\n    config.read(server_location_file)\n    server_type = config.get('server', 'type')\n    return server_type"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset file_data_object. file_resource. upload_status", "response": "def _set_upload_status(self, file_data_object, upload_status):\n        \"\"\" Set file_data_object.file_resource.upload_status\n        \"\"\"\n        uuid = file_data_object['uuid']\n        return self.connection.update_data_object(\n            uuid,\n            {'uuid': uuid, 'value': { 'upload_status': upload_status}}\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a template and a list of file_dependencies this method will substitute the UUIDs of files that are not found in the file_dependencies list with the UUIDs of the files that were imported through the server.", "response": "def _substitute_file_uuids_throughout_template(self, template, file_dependencies):\n        \"\"\"Anywhere in \"template\" that refers to a data object but does not \n        give a specific UUID, if a matching file can be found in \"file_dependencies\",\n        we will change the data object reference to use that UUID. That way templates\n        have a preference to connect to files nested under their \".dependencies\" over\n        files that were previously imported to the server.\n        \"\"\"\n        if not isinstance(template, dict):\n            # Nothing to do if this is a reference to a previously imported template.\n            return\n        for input in template.get('inputs', []):\n            self._substitute_file_uuids_in_input(input, file_dependencies)\n        for step in template.get('steps', []):\n            self._substitute_file_uuids_throughout_template(step, file_dependencies)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert command line args into a list of template inputs", "response": "def _get_inputs(self):\n        \"\"\"Converts command line args into a list of template inputs\n        \"\"\"\n        # Convert file inputs to a dict, to make it easier to override\n        # them with commandline inputs\n        file_inputs = self._get_file_inputs()\n        try:\n            jsonschema.validate(file_inputs, file_input_schema)\n        except jsonschema.ValidationError:\n            raise SystemExit(\"ERROR! Input file was invalid\")\n        input_dict = {}\n        for (channel, input_id) in file_inputs.iteritems():\n            input_dict[channel] = input_id\n\n        if self.args.inputs:\n            for kv_pair in self.args.inputs:\n                (channel, input_id) = kv_pair.split('=')\n                input_dict[channel] = self._parse_string_to_nested_lists(\n                    input_id)\n\n        inputs = []\n        for (channel, contents) in input_dict.iteritems():\n            inputs.append({\n                'channel': channel,\n                'data': {\n                    'contents': contents\n                }\n            })\n        return inputs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_inputs(self, old_inputs):\n        # Convert inputs to dict to facilitate overriding by channel name\n        # Also, drop DataNode ID and keep only contents.\n        input_dict = {}\n        for input in old_inputs:\n            # Strip out DataNode UUID and URL\n            input['data'] = {'contents': input['data']['contents']}\n            input_dict[input['channel']] = input\n\n        file_inputs = self._get_file_inputs()\n        try:\n            jsonschema.validate(file_inputs, file_input_schema)\n        except jsonschema.ValidationError:\n            raise SystemExit(\"ERROR! User inputs file is not valid\")\n        for (channel, input_id) in file_inputs.iteritems():\n            input_dict[channel] = {\n                'channel': channel,\n                'data': {'contents': input_id}\n            }\n        # Override with cli user inputs if specified\n        if self.args.inputs:\n            for kv_pair in self.args.inputs:\n                (channel, input_id) = kv_pair.split('=')\n                input_dict[channel] = {\n                    'channel': channel,\n                    'data': {\n                        'contents':\n                        self._parse_string_to_nested_lists(input_id)}\n                }\n        return input_dict.values()", "response": "Converts command line args into a list of template inputs\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsuppresses warning about untrusted SSL certificate.", "response": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretries sending a request to the server until the response is received.", "response": "def _make_request_to_server(self, query_function, raise_for_status=True,\n                                time_limit_seconds=2, retry_delay_seconds=0.2):\n        \"\"\"Retry sending request until timeout or until receiving a response.\n        \"\"\"\n        start_time = datetime.datetime.now()\n        while datetime.datetime.now() - start_time < datetime.timedelta(\n                0, time_limit_seconds):\n            error = None\n            response = None\n            try:\n                response = query_function()\n            except requests.exceptions.ConnectionError as e:\n                error = ServerConnectionError(\n                    \"No response from server.\\n%s\" % e)\n            except:\n                if response:\n                    logger.info(response.text)\n                raise\n            if response is not None and raise_for_status:\n                # raises requests.exceptions.HTTPError\n                self._raise_for_status(response)\n            if error:\n                time.sleep(retry_delay_seconds)\n                continue\n            else:\n                return response\n        raise error"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef TaskAttemptInput(input, task_attempt):\n\n    (data_type, mode) = _get_input_info(input)\n\n    if data_type != 'file':\n        return NoOpInput(None, task_attempt)\n\n    if mode == 'no_gather':\n        return FileInput(input['data']['contents'], task_attempt)\n    else:\n        assert mode.startswith('gather')\n        return FileListInput(input['data']['contents'], task_attempt)", "response": "Returns the correct Input class for a given input data type and gather mode\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute(task_function, *args, **kwargs):\n\n    if get_setting('TEST_DISABLE_ASYNC_DELAY'):\n        # Delay disabled, run synchronously\n        logger.debug('Running function \"%s\" synchronously because '\\\n                     'TEST_DISABLE_ASYNC_DELAY is True'\n                     % task_function.__name__)\n        return task_function(*args, **kwargs)\n\n    db.connections.close_all()\n    task_function.delay(*args, **kwargs)", "response": "Execute a task asynchronously"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a task asynchronously after at least delay_seconds", "response": "def execute_with_delay(task_function, *args, **kwargs):\n    \"\"\"Run a task asynchronously after at least delay_seconds\n    \"\"\"\n    delay = kwargs.pop('delay', 0)\n    if get_setting('TEST_DISABLE_ASYNC_DELAY'):\n        # Delay disabled, run synchronously\n        logger.debug('Running function \"%s\" synchronously because '\\\n                     'TEST_DISABLE_ASYNC_DELAY is True'\n                     % task_function.__name__)\n        return task_function(*args, **kwargs)\n\n    db.connections.close_all()\n    task_function.apply_async(args=args, kwargs=kwargs, countdown=delay)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_for_stalled_tasks():\n    from api.models.tasks import Task\n    for task in Task.objects.filter(status_is_running=True):\n        if not task.is_responsive():\n            task.system_error()\n        if task.is_timed_out():\n            task.timeout_error()", "response": "Check for tasks that are no longer sending a heartbeat"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_for_missed_cleanup():\n    if get_setting('PRESERVE_ALL'):\n        return\n    from api.models.tasks import TaskAttempt\n    if get_setting('PRESERVE_ON_FAILURE'):\n        for task_attempt in TaskAttempt.objects.filter(\n                status_is_running=False).filter(\n                    status_is_cleaned_up=False).exclude(\n                        status_is_failed=True):\n            task_attempt.cleanup()\n    else:\n        for task_attempt in TaskAttempt.objects.filter(\n                status_is_running=False).filter(status_is_cleaned_up=False):\n            task_attempt.cleanup()", "response": "Check for TaskAttempts that were never cleaned up"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_with_retries(retryable_function,\n                         retryable_errors,\n                         logger,\n                         human_readable_action_name='Action',\n                         nonretryable_errors=None):\n    \"\"\"This attempts to execute \"retryable_function\" with exponential backoff\n    on delay time.\n    10 retries adds up to about 34 minutes total delay before the last attempt.\n    \"human_readable_action_name\" is an option input to customize retry message.\n    \"\"\"\n    max_retries = 10\n    attempt = 0\n    if not nonretryable_errors:\n        nonretryable_errors = ()\n    while True:\n        try:\n            return retryable_function()\n        except tuple(nonretryable_errors):\n            raise\n        except tuple(retryable_errors) as e:\n            attempt += 1\n            if attempt > max_retries:\n                raise\n            # Exponentional backoff on retry delay as suggested by\n            # https://cloud.google.com/storage/docs/exponential-backoff\n            delay = 2**attempt + random.random()\n            logger.info('\"%s\" failed with error \"%s\". '\\\n                        'Retry number %s of %s in %s seconds'\n                        % (human_readable_action_name, str(e),\n                           attempt, max_retries, delay))\n            time.sleep(delay)", "response": "Execute retryable_function with exponential backoff on delay time."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_file(self, data_object, destination_directory=None,\n                    destination_filename=None, retry=False,\n                    export_metadata=False, export_raw_file=True):\n        \"\"\"Export a file from Loom to some file storage location.\n        Default destination_directory is cwd. Default destination_filename is the \n        filename from the file data object associated with the given file_id.\n        \"\"\"\n        if not destination_directory:\n            destination_directory = os.getcwd()\n\n        # We get filename from the dataobject\n        if not destination_filename:\n            destination_filename = data_object['value']['filename']\n\n        destination_file_url = os.path.join(destination_directory,\n                                            destination_filename)\n\n        logger.info('Exporting file %s@%s ...' % (\n            data_object['value']['filename'],\n            data_object['uuid']))\n\n        if export_raw_file:\n            destination = File(\n                destination_file_url, self.storage_settings, retry=retry)\n            if destination.exists():\n                raise FileAlreadyExistsError(\n                    'File already exists at %s' % destination_file_url)\n            logger.info('...copying file to %s' % (\n                destination.get_url()))\n\n            # Copy from the first file location\n            file_resource = data_object.get('value')\n            md5 = file_resource.get('md5')\n            source_url = data_object['value']['file_url']\n            File(source_url, self.storage_settings, retry=retry).copy_to(\n                destination, expected_md5=md5)\n            data_object['value'] = self._create_new_file_resource(\n                data_object['value'], destination.get_url())\n        else:\n            logger.info('...skipping raw file')\n\n        if export_metadata:\n            data_object['value'].pop('link', None)\n            data_object['value'].pop('upload_status', None)\n            destination_metadata_url = os.path.join(\n                destination_file_url + '.metadata.yaml')\n            logger.info('...writing metadata to %s' % destination_metadata_url)\n            metadata = yaml.safe_dump(data_object, default_flow_style=False)\n            metadata_file = File(destination_metadata_url,\n                                 self.storage_settings, retry=retry)\n            metadata_file.write(metadata)\n        else:\n            logger.info('...skipping metadata')\n\n        logger.info('...finished file export')", "response": "Export a file from Loom to some file storage location."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlike urlparse except it assumes that the scheme is specified", "response": "def _urlparse(path):\n    \"\"\"Like urlparse except it assumes 'file://' if no scheme is specified\n    \"\"\"\n    url = urlparse.urlparse(path)\n    _validate_url(url)\n    if not url.scheme or url.scheme == 'file://':\n        # Normalize path, and set scheme to \"file\" if missing\n        path = os.path.abspath(\n            os.path.expanduser(path))\n        url = urlparse.urlparse('file://'+path)\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Copier(source, destination):\n\n    if source.type == 'local' and destination.type == 'local':\n        return LocalCopier(source, destination)\n    elif source.type == 'local' and destination.type == 'google_storage':\n        return Local2GoogleStorageCopier(source, destination)\n    elif source.type == 'google_storage' and destination.type == 'local':\n        return GoogleStorage2LocalCopier(source, destination)\n    elif source.type == 'google_storage' and destination.type == 'google_storage':\n        return GoogleStorageCopier(source, destination)\n    else:\n        raise FileUtilsError('Could not find method to copy from source '\\\n                        '\"%s\" to destination \"%s\".' % (source, destination))", "response": "Factory method to select the right copier for a given source and destination."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_from_data_channel(cls, data_channel):\n        gather_depth = cls._get_gather_depth(data_channel)\n\n        generator = InputSetGeneratorNode()\n        for (data_path, data_node) in data_channel.get_ready_data_nodes(\n                [], gather_depth):\n            flat_data_node = data_node.flattened_clone(save=False)\n            input_item = InputItem(\n                flat_data_node, data_channel.channel,\n                data_channel.as_channel, mode=data_channel.mode)\n            generator._add_input_item(data_path, input_item)\n        return generator", "response": "Create a corresponding InputSetGenerator from a data channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the correct Output class for a given task_attempt.", "response": "def TaskAttemptOutput(output, task_attempt):\n    \"\"\"Returns the correct Output class for a given\n    data type, source type, and scatter mode\n    \"\"\"\n\n    (data_type, mode, source_type) = _get_output_info(output)\n\n    if data_type == 'file':\n        if mode == 'scatter':\n            assert source_type in ['filenames', 'glob'], \\\n                'source type \"%s\" not allowed' % source_type\n            if source_type == 'filenames':\n                return FileListScatterOutput(output, task_attempt)\n            return GlobScatterOutput(output, task_attempt)\n        else:\n            assert mode == 'no_scatter'\n            assert source_type == 'filename', \\\n                'source type \"%s\" not allowed' % source_type\n            return FileOutput(output, task_attempt)\n    else:  # data_type is non-file\n        if mode == 'scatter':\n            assert source_type in [\n                'filename', 'filenames', 'glob', 'stream'], \\\n                'source type \"%s\" not allowed' % source_type\n            if source_type == 'filename':\n                return FileContentsScatterOutput(output, task_attempt)\n            if source_type == 'filenames':\n                return FileListContentsScatterOutput(output, task_attempt)\n            if source_type == 'glob':\n                return GlobContentsScatterOutput(output, task_attempt)\n            assert source_type == 'stream'\n            return StreamScatterOutput(output, task_attempt)\n        else:\n            assert mode == 'no_scatter'\n            assert source_type in ['filename', 'stream'], \\\n                'source type \"%s\" not allowed' % source_type\n            if source_type == 'filename':\n                return FileContentsOutput(output, task_attempt)\n            assert source_type == 'stream'\n            return StreamOutput(output, task_attempt)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new leaf node at the given index with the given data_object.", "response": "def add_leaf(self, index, data_object, save=False):\n        \"\"\"Adds a new leaf node at the given index with the given data_object\n        \"\"\"\n        assert self.type == data_object.type, 'data type mismatch'\n        if self._get_child_by_index(index) is not None:\n            raise NodeAlreadyExistsError(\n                'Leaf data node already exists at this index')\n        else:\n            data_node = DataNode(\n                parent=self,\n                index=index,\n                data_object=data_object,\n                type=self.type)\n            if save:\n                data_node.full_clean()\n                data_node.save()\n            self._add_unsaved_child(data_node)\n            return data_node"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of entries only for existing nodes with is_ready == True.", "response": "def get_ready_data_nodes(self, seed_path, gather_depth):\n        \"\"\"Returns a list [(path1,data_node1),...]\n        with entries only for existing nodes with DataObjects where is_ready==True.\n        Missing nodes or those with non-ready or non-existing data are ignored.\n        \"\"\"\n        try:\n            seed_node = self.get_node(seed_path)\n        except MissingBranchError:\n            return []\n        all_paths = seed_node._get_all_paths(seed_path, gather_depth)\n        ready_data_nodes = []\n        for path in all_paths:\n            if self.is_ready(data_path=path):\n                ready_data_nodes.append((path, self.get_node(path)))\n        return ready_data_nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_index(self, index):\n        if self.degree is None:\n            raise UnknownDegreeError(\n                'Cannot access child DataNode on a parent with degree of None. '\\\n                'Set the degree on the parent first.')\n        if index < 0 or index >= self.degree:\n            raise IndexOutOfRangeError(\n                'Out of range index %s. DataNode parent has degree %s, so index '\\\n                'should be in the range 0 to %s' % (\n                    index, self.degree, self.degree-1))", "response": "Verify that the given index is consistent with the degree of the node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_gcloud_vm():\n    r = None\n    try:\n        r = requests.get('http://metadata.google.internal')\n    except requests.ConnectionError:\n        return False\n\n    try:\n        if r.headers['Metadata-Flavor'] == 'Google' and \\\n           r.headers['Server'] == 'Metadata Server for VM':\n            return True\n    except KeyError:\n        return False", "response": "Determines if we re running on a GCE instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cheapest_instance_type(cores, memory):\n\n    pricelist = get_gcloud_pricelist()\n\n    # Filter out preemptible, shared-CPU, and non-US instance types\n    us_instance_types = {k: v for k, v in pricelist.items()\n                         if k.startswith('CP-COMPUTEENGINE-VMIMAGE-')\n                         and not k.endswith('-PREEMPTIBLE')\n                         and 'us' in v and v['cores'] != 'shared'}\n\n    # Convert to array and add keys (instance type names) as type names\n    price_array = []\n    for key in us_instance_types:\n        value = us_instance_types[key]\n        value.update({'name': key.replace(\n            'CP-COMPUTEENGINE-VMIMAGE-', '').lower()})\n        price_array.append(value)\n\n    # Sort by price in US\n    price_array.sort(None, lambda x: x['us'])\n\n    # Look for an instance type that satisfies requested\n    # cores and memory; first will be cheapest\n    for instance_type in price_array:\n        if int(instance_type['cores']) >= int(cores) \\\n           and float(instance_type['memory']) >= float(memory):\n            print instance_type['name']\n            return instance_type['name']\n\n    # No instance type found that can fulfill requested cores and memory\n    raise Exception('No instance type found with at least %d cores '\n                    'and %f GB of RAM.' % (cores, memory))", "response": "Determine the cheapest instance type given a minimum\n    number of cores and minimum amount of RAM."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves latest pricelist from Google Cloud or use cached copy if not reachable.", "response": "def get_gcloud_pricelist():\n    \"\"\"Retrieve latest pricelist from Google Cloud, or use\n    cached copy if not reachable.\n    \"\"\"\n    try:\n        r = requests.get('http://cloudpricingcalculator.appspot.com'\n                         '/static/data/pricelist.json')\n        content = json.loads(r.content)\n    except ConnectionError:\n        logger.warning(\n            \"Couldn't get updated pricelist from \"\n            \"http://cloudpricingcalculator.appspot.com\"\n            \"/static/data/pricelist.json. Falling back to cached \"\n            \"copy, but prices may be out of date.\")\n        with open('gcloudpricelist.json') as infile:\n            content = json.load(infile)\n\n    pricelist = content['gcp_price_list']\n    return pricelist"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_base_name(hostname, step_name, attempt_id, max_length):\n    max_length = int(max_length)\n    if len(hostname)+len(step_name)+MIN_TASK_ID_CHARS+2 > max_length:\n        # round with ceil/floor such that extra char goes to hostname if odd\n        hostname_chars = int(math.ceil(\n            (max_length-MIN_TASK_ID_CHARS-2)/float(2)))\n        step_name_chars = int(math.floor(\n            (max_length-MIN_TASK_ID_CHARS-2)/float(2)))\n        hostname = hostname[:hostname_chars]\n        step_name = step_name[:step_name_chars]\n    name_base = '-'.join([hostname, step_name, attempt_id])\n    return _sanitize_instance_name(name_base, max_length)", "response": "Create a base name for the worker instance that will run the specified\n    task run attempt from this server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sanitize_instance_name(name, max_length):\n    name = str(name).lower()                # make all letters lowercase\n    name = re.sub(r'[^-a-z0-9]', '', name)  # remove invalid characters\n    # remove non-lowercase letters from the beginning\n    name = re.sub(r'^[^a-z]+', '', name)\n    name = name[:max_length]\n    name = re.sub(r'-+$', '', name)         # remove hyphens from the end\n    return name", "response": "Instance names must start with a lowercase letter.\n    All following characters must be a dash, lowercase letter,\n    or digit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_valid(self, max_age=None):\n        ''' Determines if the cache files have expired, or if it is still valid '''\n\n        if max_age is None:\n            max_age = self.cache_max_age\n\n        if os.path.isfile(self.cache_path_cache):\n            mod_time = os.path.getmtime(self.cache_path_cache)\n            current_time = time()\n            if (mod_time + max_age) > current_time:\n                return True\n\n        return False", "response": "Determines if the cache files have expired or still valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_data_from_cache(self, filename=''):\n        ''' Reads the JSON inventory from the cache file. Returns Python dictionary. '''\n\n        data = ''\n        if not filename:\n            filename = self.cache_path_cache\n        with open(filename, 'r') as cache:\n            data = cache.read()\n        return json.loads(data)", "response": "Reads the JSON inventory from the cache file. Returns Python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_to_cache(self, data, filename=''):\n        ''' Writes data to file as JSON.  Returns True. '''\n        if not filename:\n            filename = self.cache_path_cache\n        json_data = json.dumps(data)\n        with open(filename, 'w') as cache:\n            cache.write(json_data)\n        return True", "response": "Writes data to file as JSON. Returns True."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the settings from the gce. ini file and returns a ConfigParser object with the values set as attributes.", "response": "def get_config(self):\n        \"\"\"\n        Reads the settings from the gce.ini file.\n\n        Populates a SafeConfigParser object with defaults and\n        attempts to read an .ini-style configuration from the filename\n        specified in GCE_INI_PATH. If the environment variable is\n        not present, the filename defaults to gce.ini in the current\n        working directory.\n        \"\"\"\n        gce_ini_default_path = os.path.join(\n            os.path.dirname(os.path.realpath(__file__)), \"gce.ini\")\n        gce_ini_path = os.environ.get('GCE_INI_PATH', gce_ini_default_path)\n\n        # Create a ConfigParser.\n        # This provides empty defaults to each key, so that environment\n        # variable configuration (as opposed to INI configuration) is able\n        # to work.\n        config = ConfigParser.SafeConfigParser(defaults={\n            'gce_service_account_email_address': '',\n            'gce_service_account_pem_file_path': '',\n            'gce_project_id': '',\n            'libcloud_secrets': '',\n            'inventory_ip_type': '',\n            'cache_path': '~/.ansible/tmp',\n            'cache_max_age': '300'\n        })\n        if 'gce' not in config.sections():\n            config.add_section('gce')\n        if 'inventory' not in config.sections():\n            config.add_section('inventory')\n        if 'cache' not in config.sections():\n            config.add_section('cache')\n\n        config.read(gce_ini_path)\n\n        #########\n        # Section added for processing ini settings\n        #########\n\n        # Set the instance_states filter based on config file options\n        self.instance_states = []\n        if config.has_option('gce', 'instance_states'):\n            states = config.get('gce', 'instance_states')\n            # Ignore if instance_states is an empty string.\n            if states:\n                self.instance_states = states.split(',')\n\n        # Caching\n        cache_path = config.get('cache', 'cache_path')\n        cache_max_age = config.getint('cache', 'cache_max_age')\n        # TOOD(supertom): support project-specific caches\n        cache_name = 'ansible-gce.cache'\n        self.cache = CloudInventoryCache(cache_path=cache_path,\n                                         cache_max_age=cache_max_age,\n                                         cache_name=cache_name)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_inventory_options(self):\n        ip_type = self.config.get('inventory', 'inventory_ip_type')\n        # If the appropriate environment variables are set, they override\n        # other configuration\n        ip_type = os.environ.get('INVENTORY_IP_TYPE', ip_type)\n        return ip_type", "response": "Determine inventory options. Environment variables always\n        take precedence over configuration files."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetermines the GCE authorization settings and return a libcloud driver.", "response": "def get_gce_driver(self):\n        \"\"\"Determine the GCE authorization settings and return a\n        libcloud driver.\n        \"\"\"\n        # Attempt to get GCE params from a configuration file, if one\n        # exists.\n        secrets_path = self.config.get('gce', 'libcloud_secrets')\n        secrets_found = False\n        try:\n            import secrets\n            args = list(getattr(secrets, 'GCE_PARAMS', []))\n            kwargs = getattr(secrets, 'GCE_KEYWORD_PARAMS', {})\n            secrets_found = True\n        except:\n            pass\n\n        if not secrets_found and secrets_path:\n            if not secrets_path.endswith('secrets.py'):\n                err = \"Must specify libcloud secrets file as \"\n                err += \"/absolute/path/to/secrets.py\"\n                sys.exit(err)\n            sys.path.append(os.path.dirname(secrets_path))\n            try:\n                import secrets\n                args = list(getattr(secrets, 'GCE_PARAMS', []))\n                kwargs = getattr(secrets, 'GCE_KEYWORD_PARAMS', {})\n                secrets_found = True\n            except:\n                pass\n        if not secrets_found:\n            args = [\n                self.config.get('gce','gce_service_account_email_address'),\n                self.config.get('gce','gce_service_account_pem_file_path')\n            ]\n            kwargs = {'project': self.config.get('gce', 'gce_project_id')}\n\n        # If the appropriate environment variables are set, they override\n        # other configuration; process those into our args and kwargs.\n        args[0] = os.environ.get('GCE_EMAIL', args[0])\n        args[1] = os.environ.get('GCE_PEM_FILE_PATH', args[1])\n        kwargs['project'] = os.environ.get('GCE_PROJECT', kwargs['project'])\n\n        # Retrieve and return the GCE driver.\n        gce = get_driver(Provider.GCE)(*args, **kwargs)\n        gce.connection.user_agent_append(\n            '%s/%s' % (USER_AGENT_PRODUCT, USER_AGENT_VERSION),\n        )\n        return gce"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of comma separated zones parsed from the GCE_ZONE environment variable.", "response": "def parse_env_zones(self):\n        '''returns a list of comma separated zones parsed from the GCE_ZONE environment variable.\n        If provided, this will be used to filter the results of the grouped_instances call'''\n        import csv\n        reader = csv.reader([os.environ.get('GCE_ZONE',\"\")], skipinitialspace=True)\n        zones = [r for r in reader]\n        return [z for z in zones[0]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommands line argument processing", "response": "def parse_cli_args(self):\n        ''' Command line argument processing '''\n\n        parser = argparse.ArgumentParser(\n                description='Produce an Ansible Inventory file based on GCE')\n        parser.add_argument('--list', action='store_true', default=True,\n                           help='List instances (default: True)')\n        parser.add_argument('--host', action='store',\n                           help='Get all information about an instance')\n        parser.add_argument('--pretty', action='store_true', default=False,\n                           help='Pretty format (default: False)')\n        parser.add_argument(\n            '--refresh-cache', action='store_true', default=False,\n            help='Force refresh of cache by making API requests (default: False - use cache files)')\n        self.args = parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload inventory from JSON on disk.", "response": "def load_inventory_from_cache(self):\n        ''' Loads inventory from JSON on disk. '''\n\n        try:\n            self.inventory = self.cache.get_all_data_from_cache()\n            hosts = self.inventory['_meta']['hostvars']\n        except Exception as e:\n            print(\n                \"Invalid inventory file %s.  Please rebuild with -refresh-cache option.\"\n                % (self.cache.cache_path_cache))\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_api_calls_update_cache(self):\n        ''' Do API calls and save data in cache. '''\n        zones = self.parse_env_zones()\n        data = self.group_instances(zones)\n        self.cache.write_to_cache(data)\n        self.inventory = data", "response": "Do API calls and save data in cache."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef group_instances(self, zones=None):\n        '''Group all instances'''\n        groups = {}\n        meta = {}\n        meta[\"hostvars\"] = {}\n\n        for node in self.list_nodes():\n\n            # This check filters on the desired instance states defined in the\n            # config file with the instance_states config option.\n            #\n            # If the instance_states list is _empty_ then _ALL_ states are returned.\n            #\n            # If the instance_states list is _populated_ then check the current\n            # state against the instance_states list\n            if self.instance_states and not node.extra['status'] in self.instance_states:\n                continue\n\n            name = node.name\n\n            meta[\"hostvars\"][name] = self.node_to_dict(node)\n\n            zone = node.extra['zone'].name\n\n            # To avoid making multiple requests per zone\n            # we list all nodes and then filter the results\n            if zones and zone not in zones:\n                continue\n\n            if zone in groups: groups[zone].append(name)\n            else: groups[zone] = [name]\n\n            tags = node.extra['tags']\n            for t in tags:\n                if t.startswith('group-'):\n                    tag = t[6:]\n                else:\n                    tag = 'tag_%s' % t\n                if tag in groups: groups[tag].append(name)\n                else: groups[tag] = [name]\n\n            net = node.extra['networkInterfaces'][0]['network'].split('/')[-1]\n            net = 'network_%s' % net\n            if net in groups: groups[net].append(name)\n            else: groups[net] = [name]\n\n            machine_type = node.size\n            if machine_type in groups: groups[machine_type].append(name)\n            else: groups[machine_type] = [name]\n\n            image = node.image and node.image or 'persistent_disk'\n            if image in groups: groups[image].append(name)\n            else: groups[image] = [name]\n\n            status = node.extra['status']\n            stat = 'status_%s' % status.lower()\n            if stat in groups: groups[stat].append(name)\n            else: groups[stat] = [name]\n\n        groups[\"_meta\"] = meta\n\n        return groups", "response": "Group all instances in the cluster by their state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef json_format_dict(self, data, pretty=False):\n        ''' Converts a dict to a JSON object and dumps it as a formatted\n        string '''\n\n        if pretty:\n            return json.dumps(data, sort_keys=True, indent=2)\n        else:\n            return json.dumps(data)", "response": "Converts a dict to a JSON object and dumps it as a formatted\n            string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstreaming stdout and stderr from the task container to this process s stdout and stderr respectively.", "response": "def _stream_docker_logs(self):\n        \"\"\"Stream stdout and stderr from the task container to this\n        process's stdout and stderr, respectively.\n        \"\"\"\n        thread = threading.Thread(target=self._stderr_stream_worker)\n        thread.start()\n        for line in self.docker_client.logs(self.container, stdout=True,\n                                            stderr=False, stream=True):\n            sys.stdout.write(line)\n        thread.join()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_internal_value(self, data):\n        converted_data = _convert_template_id_to_dict(data)\n        return super(TemplateSerializer, self)\\\n            .to_internal_value(converted_data)", "response": "Convert the template ID string to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing two identifier (for pre-release/build components).", "response": "def identifier_cmp(a, b):\n    \"\"\"Compare two identifier (for pre-release/build components).\"\"\"\n\n    a_cmp, a_is_int = _to_int(a)\n    b_cmp, b_is_int = _to_int(b)\n\n    if a_is_int and b_is_int:\n        # Numeric identifiers are compared as integers\n        return base_cmp(a_cmp, b_cmp)\n    elif a_is_int:\n        # Numeric identifiers have lower precedence\n        return -1\n    elif b_is_int:\n        return 1\n    else:\n        # Non-numeric identifiers are compared lexicographically\n        return base_cmp(a_cmp, b_cmp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing two list of identifiers.", "response": "def identifier_list_cmp(a, b):\n    \"\"\"Compare two identifier list (pre-release/build components).\n\n    The rule is:\n        - Identifiers are paired between lists\n        - They are compared from left to right\n        - If all first identifiers match, the longest list is greater.\n\n    >>> identifier_list_cmp(['1', '2'], ['1', '2'])\n    0\n    >>> identifier_list_cmp(['1', '2a'], ['1', '2b'])\n    -1\n    >>> identifier_list_cmp(['1'], ['1', '2'])\n    -1\n    \"\"\"\n    identifier_pairs = zip(a, b)\n    for id_a, id_b in identifier_pairs:\n        cmp_res = identifier_cmp(id_a, id_b)\n        if cmp_res != 0:\n            return cmp_res\n    # alpha1.3 < alpha1.3.1\n    return base_cmp(len(a), len(b))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncoerces an arbitrary version string into a semver - compatible version.", "response": "def coerce(cls, version_string, partial=False):\n        \"\"\"Coerce an arbitrary version string into a semver-compatible one.\n\n        The rule is:\n        - If not enough components, fill minor/patch with zeroes; unless\n          partial=True\n        - If more than 3 dot-separated components, extra components are \"build\"\n          data. If some \"build\" data already appeared, append it to the\n          extra components\n\n        Examples:\n            >>> Version.coerce('0.1')\n            Version(0, 1, 0)\n            >>> Version.coerce('0.1.2.3')\n            Version(0, 1, 2, (), ('3',))\n            >>> Version.coerce('0.1.2.3+4')\n            Version(0, 1, 2, (), ('3', '4'))\n            >>> Version.coerce('0.1+2-3+4_5')\n            Version(0, 1, 0, (), ('2-3', '4-5'))\n        \"\"\"\n        base_re = re.compile(r'^\\d+(?:\\.\\d+(?:\\.\\d+)?)?')\n\n        match = base_re.match(version_string)\n        if not match:\n            raise ValueError(\n                \"Version string lacks a numerical component: %r\"\n                % version_string\n            )\n\n        version = version_string[:match.end()]\n        if not partial:\n            # We need a not-partial version.\n            while version.count('.') < 2:\n                version += '.0'\n\n        if match.end() == len(version_string):\n            return Version(version, partial=partial)\n\n        rest = version_string[match.end():]\n\n        # Cleanup the 'rest'\n        rest = re.sub(r'[^a-zA-Z0-9+.-]', '-', rest)\n\n        if rest[0] == '+':\n            # A 'build' component\n            prerelease = ''\n            build = rest[1:]\n        elif rest[0] == '.':\n            # An extra version component, probably 'build'\n            prerelease = ''\n            build = rest[1:]\n        elif rest[0] == '-':\n            rest = rest[1:]\n            if '+' in rest:\n                prerelease, build = rest.split('+', 1)\n            else:\n                prerelease, build = rest, ''\n        elif '+' in rest:\n            prerelease, build = rest.split('+', 1)\n        else:\n            prerelease, build = rest, ''\n\n        build = build.replace('+', '.')\n\n        if prerelease:\n            version = '%s-%s' % (version, prerelease)\n        if build:\n            version = '%s+%s' % (version, build)\n\n        return cls(version, partial=partial)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a version string into a tuple of version numbers.", "response": "def parse(cls, version_string, partial=False, coerce=False):\n        \"\"\"Parse a version string into a Version() object.\n\n        Args:\n            version_string (str), the version string to parse\n            partial (bool), whether to accept incomplete input\n            coerce (bool), whether to try to map the passed in string into a\n                valid Version.\n        \"\"\"\n        if not version_string:\n            raise ValueError('Invalid empty version string: %r' % version_string)\n\n        if partial:\n            version_re = cls.partial_version_re\n        else:\n            version_re = cls.version_re\n\n        match = version_re.match(version_string)\n        if not match:\n            raise ValueError('Invalid version string: %r' % version_string)\n\n        major, minor, patch, prerelease, build = match.groups()\n\n        if _has_leading_zero(major):\n            raise ValueError(\"Invalid leading zero in major: %r\" % version_string)\n        if _has_leading_zero(minor):\n            raise ValueError(\"Invalid leading zero in minor: %r\" % version_string)\n        if _has_leading_zero(patch):\n            raise ValueError(\"Invalid leading zero in patch: %r\" % version_string)\n\n        major = int(major)\n        minor = cls._coerce(minor, partial)\n        patch = cls._coerce(patch, partial)\n\n        if prerelease is None:\n            if partial and (build is None):\n                # No build info, strip here\n                return (major, minor, patch, None, None)\n            else:\n                prerelease = ()\n        elif prerelease == '':\n            prerelease = ()\n        else:\n            prerelease = tuple(prerelease.split('.'))\n            cls._validate_identifiers(prerelease, allow_leading_zeroes=False)\n\n        if build is None:\n            if partial:\n                build = None\n            else:\n                build = ()\n        elif build == '':\n            build = ()\n        else:\n            build = tuple(build.split('.'))\n            cls._validate_identifiers(build, allow_leading_zeroes=True)\n\n        return (major, minor, patch, prerelease, build)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of 5 - tuple of comparison methods.", "response": "def _comparison_functions(cls, partial=False):\n        \"\"\"Retrieve comparison methods to apply on version components.\n\n        This is a private API.\n\n        Args:\n            partial (bool): whether to provide 'partial' or 'strict' matching.\n\n        Returns:\n            5-tuple of cmp-like functions.\n        \"\"\"\n\n        def prerelease_cmp(a, b):\n            \"\"\"Compare prerelease components.\n\n            Special rule: a version without prerelease component has higher\n            precedence than one with a prerelease component.\n            \"\"\"\n            if a and b:\n                return identifier_list_cmp(a, b)\n            elif a:\n                # Versions with prerelease field have lower precedence\n                return -1\n            elif b:\n                return 1\n            else:\n                return 0\n\n        def build_cmp(a, b):\n            \"\"\"Compare build metadata.\n\n            Special rule: there is no ordering on build metadata.\n            \"\"\"\n            if a == b:\n                return 0\n            else:\n                return NotImplemented\n\n        def make_optional(orig_cmp_fun):\n            \"\"\"Convert a cmp-like function to consider 'None == *'.\"\"\"\n            @functools.wraps(orig_cmp_fun)\n            def alt_cmp_fun(a, b):\n                if a is None or b is None:\n                    return 0\n                return orig_cmp_fun(a, b)\n\n            return alt_cmp_fun\n\n        if partial:\n            return [\n                base_cmp,  # Major is still mandatory\n                make_optional(base_cmp),\n                make_optional(base_cmp),\n                make_optional(prerelease_cmp),\n                make_optional(build_cmp),\n            ]\n        else:\n            return [\n                base_cmp,\n                base_cmp,\n                base_cmp,\n                prerelease_cmp,\n                build_cmp,\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __compare_helper(self, other, condition, notimpl_target):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n\n        cmp_res = self.__cmp__(other)\n        if cmp_res is NotImplemented:\n            return notimpl_target\n\n        return condition(cmp_res)", "response": "Helper function for comparison."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks whether a Version satisfies the Spec.", "response": "def match(self, version):\n        \"\"\"Check whether a Version satisfies the Spec.\"\"\"\n        return all(spec.match(version) for spec in self.specs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select(self, versions):\n        options = list(self.filter(versions))\n        if options:\n            return max(options)\n        return None", "response": "Select the best compatible version among an iterable of options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deconstruct(self):\n        name, path, args, kwargs = super(VersionField, self).deconstruct()\n        kwargs['partial'] = self.partial\n        kwargs['coerce'] = self.coerce\n        return name, path, args, kwargs", "response": "Handle django. db. migrations."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_python(self, value):\n        if value is None or value == '':\n            return value\n        if isinstance(value, base.Version):\n            return value\n        if self.coerce:\n            return base.Version.coerce(value, partial=self.partial)\n        else:\n            return base.Version(value, partial=self.partial)", "response": "Converts any value to a base. Version field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert any value to a base. Spec field.", "response": "def to_python(self, value):\n        \"\"\"Converts any value to a base.Spec field.\"\"\"\n        if value is None or value == '':\n            return value\n        if isinstance(value, base.Spec):\n            return value\n        return base.Spec(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef move_left(self):\n        self.at(ardrone.at.pcmd, True, -self.speed, 0, 0, 0)", "response": "Make the drone move left."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes the drone move right.", "response": "def move_right(self):\n        \"\"\"Make the drone move right.\"\"\"\n        self.at(ardrone.at.pcmd, True, self.speed, 0, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes the drone rise upwards.", "response": "def move_up(self):\n        \"\"\"Make the drone rise upwards.\"\"\"\n        self.at(ardrone.at.pcmd, True, 0, 0, self.speed, 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_down(self):\n        self.at(ardrone.at.pcmd, True, 0, 0, -self.speed, 0)", "response": "Make the drone decent downwards."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef move_forward(self):\n        self.at(ardrone.at.pcmd, True, 0, -self.speed, 0, 0)", "response": "Make the drone move forward."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake the drone move backwards.", "response": "def move_backward(self):\n        \"\"\"Make the drone move backwards.\"\"\"\n        self.at(ardrone.at.pcmd, True, 0, self.speed, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef turn_left(self):\n        self.at(ardrone.at.pcmd, True, 0, 0, 0, -self.speed)", "response": "Make the drone rotate left."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking the drone rotate right.", "response": "def turn_right(self):\n        \"\"\"Make the drone rotate right.\"\"\"\n        self.at(ardrone.at.pcmd, True, 0, 0, 0, self.speed)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntoggling the drone s emergency state.", "response": "def reset(self):\n        \"\"\"Toggle the drone's emergency state.\"\"\"\n        self.at(ardrone.at.ref, False, True)\n        time.sleep(0.1)\n        self.at(ardrone.at.ref, False, False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef at(self, cmd, *args, **kwargs):\n        with self.lock:\n            self.com_watchdog_timer.cancel()\n            cmd(self.host, self.sequence, *args, **kwargs)\n            self.sequence += 1\n            self.com_watchdog_timer = threading.Timer(self.timer, self.commwdg)\n            self.com_watchdog_timer.start()", "response": "Wrapper for the low level at commands."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking the drone move.", "response": "def move(self, lr, fb, vv, va):\n        \"\"\"Makes the drone move (translate/rotate).\n\n        Parameters:\n        lr -- left-right tilt: float [-1..1] negative: left, positive: right\n        fb -- front-back tilt: float [-1..1] negative: forwards, positive:\n            backwards\n        vv -- vertical speed: float [-1..1] negative: go down, positive: rise\n        va -- angular speed: float [-1..1] negative: spin left, positive: spin\n            right\"\"\"\n        self.at(ardrone.at.pcmd, True, lr, fb, vv, va)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pcmd(host, seq, progressive, lr, fb, vv, va):\n    p = 1 if progressive else 0\n    at(host, 'PCMD', seq, [p, float(lr), float(fb), float(vv), float(va)])", "response": "This function is used to make the drone move at the specified sequence number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets configuration parameters of the drone.", "response": "def config(host, seq, option, value):\n    \"\"\"Set configuration parameters of the drone.\"\"\"\n    at(host, 'CONFIG', seq, [str(option), str(value)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending control values directly to the engines overriding control loops.", "response": "def pwm(host, seq, m1, m2, m3, m4):\n    \"\"\"\n    Sends control values directly to the engines, overriding control loops.\n\n    Parameters:\n    seq -- sequence number\n    m1 -- Integer: front left command\n    m2 -- Integer: front right command\n    m3 -- Integer: back right command\n    m4 -- Integer: back left command\n    \"\"\"\n    at(host, 'PWM', seq, [m1, m2, m3, m4])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef led(host, seq, anim, f, d):\n    at(host, 'LED', seq, [anim, float(f), d])", "response": "Control the drones LED."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef anim(host, seq, anim, d):\n    at(host, 'ANIM', seq, [anim, d])", "response": "Execute an animation on the sequence seq."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef at(host, command, seq, params):\n    params_str = []\n    for p in params:\n        if type(p) == int:\n            params_str.append('{:d}'.format(p))\n        elif type(p) == float:\n            params_str.append('{:d}'.format(f2i(p)))\n        elif type(p) == str:\n            params_str.append('\"{:s}\"'.format(p))\n    msg = 'AT*{:s}={:d},{:s}\\r'.format(command, seq, ','.join(params_str))\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(msg.encode(), (host, ardrone.constant.COMMAND_PORT))", "response": "This function sends a command to the ardrone."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode(packet):\n    offset = 0\n\n    _ = struct.unpack_from('IIII', packet, offset)\n    s = _[1]\n    state = dict()\n    state['fly']                 = s       & 1 # FLY MASK : (0) ardrone is landed, (1) ardrone is flying\n    state['video']               = s >>  1 & 1 # VIDEO MASK : (0) video disable, (1) video enable\n    state['vision']              = s >>  2 & 1 # VISION MASK : (0) vision disable, (1) vision enable\n    state['control']             = s >>  3 & 1 # CONTROL ALGO (0) euler angles control, (1) angular speed control\n    state['altitude']            = s >>  4 & 1 # ALTITUDE CONTROL ALGO : (0) altitude control inactive (1) altitude control active\n    state['user_feedback_start'] = s >>  5 & 1 # USER feedback : Start button state\n    state['command']             = s >>  6 & 1 # Control command ACK : (0) None, (1) one received\n    state['fw_file']             = s >>  7 & 1 # Firmware file is good (1)\n    state['fw_ver']              = s >>  8 & 1 # Firmware update is newer (1)\n    state['fw_upd']              = s >>  9 & 1 # Firmware update is ongoing (1)\n    state['navdata_demo']        = s >> 10 & 1 # Navdata demo : (0) All navdata, (1) only navdata demo\n    state['navdata_bootstrap']   = s >> 11 & 1 # Navdata bootstrap : (0) options sent in all or demo mode, (1) no navdata options sent\n    state['motors']              = s >> 12 & 1 # Motor status : (0) Ok, (1) Motors problem\n    state['com_lost']            = s >> 13 & 1 # Communication lost : (1) com problem, (0) Com is ok\n    state['vbat_low']            = s >> 15 & 1 # VBat low : (1) too low, (0) Ok\n    state['user_el']             = s >> 16 & 1 # User Emergency Landing : (1) User EL is ON, (0) User EL is OFF\n    state['timer_elapsed']       = s >> 17 & 1 # Timer elapsed : (1) elapsed, (0) not elapsed\n    state['angles_out_of_range'] = s >> 19 & 1 # Angles : (0) Ok, (1) out of range\n    state['ultrasound']          = s >> 21 & 1 # Ultrasonic sensor : (0) Ok, (1) deaf\n    state['cutout']              = s >> 22 & 1 # Cutout system detection : (0) Not detected, (1) detected\n    state['pic_version']         = s >> 23 & 1 # PIC Version number OK : (0) a bad version number, (1) version number is OK\n    state['atcodec_thread_on']   = s >> 24 & 1 # ATCodec thread ON : (0) thread OFF (1) thread ON\n    state['navdata_thread_on']   = s >> 25 & 1 # Navdata thread ON : (0) thread OFF (1) thread ON\n    state['video_thread_on']     = s >> 26 & 1 # Video thread ON : (0) thread OFF (1) thread ON\n    state['acq_thread_on']       = s >> 27 & 1 # Acquisition thread ON : (0) thread OFF (1) thread ON\n    state['ctrl_watchdog']       = s >> 28 & 1 # CTRL watchdog : (1) delay in control execution (> 5ms), (0) control is well scheduled\n    state['adc_watchdog']        = s >> 29 & 1 # ADC Watchdog : (1) delay in uart2 dsr (> 5ms), (0) uart2 is good\n    state['com_watchdog']        = s >> 30 & 1 # Communication Watchdog : (1) com problem, (0) Com is ok\n    state['emergency']           = s >> 31 & 1 # Emergency landing : (0) no emergency, (1) emergency\n\n    data = dict()\n    data['state'] = state\n    data['header'] = _[0]\n    data['sequence'] = _[2]\n    data['vision'] = _[3]\n\n    offset += struct.calcsize('IIII')\n\n    demo_fields = [\n        'ctrl_state',\n        'battery',\n        'theta',\n        'phi',\n        'psi',\n        'altitude',\n        'vx',\n        'vy',\n        'vz',\n        'num_frames'\n    ]\n    angles = ['theta', 'phi', 'psi']\n    while True:\n        try:\n            id_nr, size = struct.unpack_from('HH', packet, offset)\n            offset += struct.calcsize('HH')\n        except struct.error:\n            break\n\n        values = []\n        for i in range(size - struct.calcsize('HH')):\n            values.append(struct.unpack_from('c', packet, offset)[0])\n            offset += struct.calcsize('c')\n\n        if id_nr == 0:\n            values = struct.unpack_from('IIfffIfffI', b''.join(values))\n            demo = dict(zip(demo_fields, values))\n            for a in angles:\n                demo[a] = int(demo[a] / 1000)\n\n            data['demo'] = demo\n\n    return data", "response": "Decode a navdata packet into a base - 16 state."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the current state of the object to a file.", "response": "def tofile(self, filename, format = 'ascii'):\n        \"\"\"Save VTK data to file.\n        \"\"\"\n        if not common.is_string(filename):\n            raise TypeError('argument filename must be string but got %s'%(type(filename)))\n        if format not in ['ascii','binary']:\n            raise TypeError('argument format must be ascii | binary')\n        filename = filename.strip()\n        if not filename:\n            raise ValueError('filename must be non-empty string')\n        if filename[-4:]!='.vtk':\n            filename += '.vtk'\n        f = open(filename,'wb')\n        f.write(self.to_string(format))\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naudits the provided customer s subscription against stripe and returns a pair of zebra_resource_id and zebra_resource_id.", "response": "def audit_customer_subscription(customer, unknown=True):\n    \"\"\"\n    Audits the provided customer's subscription against stripe and returns a pair\n    that contains a boolean and a result type.\n\n    Default result types can be found in zebra.conf.defaults and can be\n    overridden in your project's settings.\n    \"\"\"\n    if (hasattr(customer, 'suspended') and customer.suspended):\n        result = AUDIT_RESULTS['suspended']\n    else:\n        if hasattr(customer, 'subscription'):\n            try:\n                result = AUDIT_RESULTS[customer.subscription.status]\n            except KeyError, err:\n                # TODO should this be a more specific exception class?\n                raise Exception(\"Unable to locate a result set for \\\nsubscription status %s in ZEBRA_AUDIT_RESULTS\") % str(err)\n        else:\n            result = AUDIT_RESULTS['no_subscription']\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing VtkData ( <filename >.", "response": "def polydata_fromfile(f, self):\n    \"\"\"Use VtkData(<filename>).\"\"\"\n    points = []\n    data = dict(vertices=[], lines=[], polygons=[], triangle_strips=[])\n    l = common._getline(f).decode('ascii')\n    k,n,datatype = [s.strip().lower() for s in l.split(' ')]\n    if k!='points':\n        raise ValueError('expected points but got %s'%(repr(k)))\n    n = int(n)\n    assert datatype in ['bit','unsigned_char','char','unsigned_short','short','unsigned_int','int','unsigned_long','long','float','double'],repr(datatype)\n\n    log.debug('\\tgetting %s points'%n)\n    while len(points) < 3*n:\n        l = common._getline(f).decode('ascii')\n        points += map(eval,l.split(' '))\n    assert len(points)==3*n\n    while 1:\n        l = common._getline(f)\n        if l is None:\n            break\n        l = l.decode('ascii')\n        sl = l.split(' ')\n        k = sl[0].strip().lower()\n        if k not in ['vertices','lines','polygons','triangle_strips']:\n            break\n        assert len(sl)==3\n        n = int(sl[1])\n        size = int(sl[2])\n        lst = []\n        while len(lst) < size:\n            l = common._getline(f).decode('ascii')\n            lst += map(eval, l.split(' '))\n        assert len(lst)==size\n        lst2 = []\n        j = 0\n        for i in range(n):\n            lst2.append(lst[j+1:j+lst[j]+1])\n            j += lst[j]+1\n        data[k] = lst2\n\n    return PolyData(points,data['vertices'], data['lines'], data['polygons'], data['triangle_strips']), l.encode()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef webhooks(request):\n\n    if request.method != \"POST\":\n        return HttpResponse(\"Invalid Request.\", status=400)\n\n    json = simplejson.loads(request.POST[\"json\"])\n\n    if json[\"event\"] == \"recurring_payment_failed\":\n        zebra_webhook_recurring_payment_failed.send(sender=None, customer=_try_to_get_customer_from_customer_id(json[\"customer\"]), full_json=json)\n\n    elif json[\"event\"] == \"invoice_ready\":\n        zebra_webhook_invoice_ready.send(sender=None, customer=_try_to_get_customer_from_customer_id(json[\"customer\"]), full_json=json)\n\n    elif json[\"event\"] == \"recurring_payment_succeeded\":\n        zebra_webhook_recurring_payment_succeeded.send(sender=None, customer=_try_to_get_customer_from_customer_id(json[\"customer\"]), full_json=json)\n\n    elif json[\"event\"] == \"subscription_trial_ending\":\n        zebra_webhook_subscription_trial_ending.send(sender=None, customer=_try_to_get_customer_from_customer_id(json[\"customer\"]), full_json=json)\n\n    elif json[\"event\"] == \"subscription_final_payment_attempt_failed\":\n        zebra_webhook_subscription_final_payment_attempt_failed.send(sender=None, customer=_try_to_get_customer_from_customer_id(json[\"customer\"]), full_json=json)\n\n    elif json[\"event\"] == \"ping\":\n        zebra_webhook_subscription_ping_sent.send(sender=None)\n\n    else:\n        return HttpResponse(status=400)\n\n    return HttpResponse(status=200)", "response": "Handles all known webhooks from stripe and calls signals."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef webhooks_v2(request):\n    if request.method != \"POST\":\n        return HttpResponse(\"Invalid Request.\", status=400)\n\n    try:\n        event_json = simplejson.loads(request.body)\n    except AttributeError:\n        # Backwords compatibility\n        # Prior to Django 1.4, request.body was named request.raw_post_data\n        event_json = simplejson.loads(request.raw_post_data)\n    event_key = event_json['type'].replace('.', '_')\n\n    if event_key in WEBHOOK_MAP:\n        WEBHOOK_MAP[event_key].send(sender=None, full_json=event_json)\n\n    return HttpResponse(status=200)", "response": "Handles all known webhooks from stripe and calls signals."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_number(obj):\n    return isinstance(obj, (int, float, np.int_, np.float_))", "response": "Check if obj is number."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns sequence of sequences.", "response": "def get_seq_seq(self,obj,default=None):\n        \"\"\"Return sequence of sequences.\"\"\"\n        if is_sequence2(obj):\n            return [self.get_seq(o,default) for o in obj]\n        else:\n            return [self.get_seq(obj,default)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn 3 - tuple from a sequence number or number or None.", "response": "def get_3_tuple(self,obj,default=None):\n        \"\"\"Return 3-tuple from\n        number -> (obj,default[1],default[2])\n        0-sequence|None -> default\n        1-sequence -> (obj[0],default[1],default[2])\n        2-sequence -> (obj[0],obj[1],default[2])\n        (3 or more)-sequence -> (obj[0],obj[1],obj[2])\n        \"\"\"\n        if not (default is not None \\\n                and type(default) is tuple \\\n                and len(default)==3):\n            raise ValueError('argument default must be 3-tuple|None but got %s'%(default))\n        if is_sequence(obj):\n            n = len(obj)\n            if n>3:\n                log.warning('expected 3-sequence but got %s-%s'%(n,type(obj)))\n            if n>=3:\n                return tuple(obj)\n            log.warning('filling with default value (%s) to obtain size=3'%(default[0]))\n            if default is not None:\n                if n==0:\n                    return default\n                elif n==1:\n                    return (obj[0],default[1],default[2])\n                elif n==2:\n                    return (obj[0],obj[1],default[2])\n        elif is_number(obj) and default is not None:\n            log.warning('filling with default value (%s) to obtain size=3'%(default[0]))\n            return (obj,default[1],default[2])\n        elif obj is None and default is not None:\n            log.warning('filling with default value (%s) to obtain size=3'%(default[0]))\n            return default\n        raise ValueError('failed to construct 3-tuple from %s-%s'%(n,type(obj)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list of 3 - tuples from a sequence of 3 - elements", "response": "def get_3_tuple_list(self,obj,default=None):\n        \"\"\"Return list of 3-tuples from\n        sequence of a sequence,\n        sequence - it is mapped to sequence of 3-sequences if possible\n        number\n        \"\"\"\n        if is_sequence2(obj):\n            return [self.get_3_tuple(o,default) for o in obj]\n        elif is_sequence(obj):\n            return [self.get_3_tuple(obj[i:i+3],default) for i in range(0,len(obj),3)]\n        else:\n            return [self.get_3_tuple(obj,default)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning tuple of 3 - tuples", "response": "def get_3_3_tuple(self,obj,default=None):\n        \"\"\"Return tuple of 3-tuples\n        \"\"\"\n        if is_sequence2(obj):\n            ret = []\n            for i in range(3):\n                if i<len(obj):\n                    ret.append(self.get_3_tuple(obj[i],default))\n                else:\n                    ret.append(self.get_3_tuple(default,default))\n            return tuple(ret)\n        if is_sequence(obj):\n            if len(obj)>9:\n                log.warning('ignoring elements obj[i], i>=9')\n            r = obj[:9]\n            r = [self.get_3_tuple(r[j:j+3],default) for j in range(0,len(r),3)]\n            if len(r)<3:\n                log.warning('filling with default value (%s) to obtain size=3'%(default[0]))\n            while len(r)<3:\n                r.append(self.get_3_tuple(default,default))\n            return tuple(r)\n        log.warning('filling with default value (%s) to obtain size=3'%(default[0]))\n        r1 = self.get_3_tuple(obj,default)\n        r2 = self.get_3_tuple(default,default)\n        r3 = self.get_3_tuple(default,default)\n        return (r1,r2,r3)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of 3x3 - tuples.", "response": "def get_3_3_tuple_list(self,obj,default=None):\n        \"\"\"Return list of 3x3-tuples.\n        \"\"\"\n        if is_sequence3(obj):\n            return [self.get_3_3_tuple(o,default) for o in obj]\n        return [self.get_3_3_tuple(obj,default)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects to the current application and instantiate the services.", "response": "def connect(self):\n        \"\"\"Iterate through the application configuration and instantiate\n        the services.\n        \"\"\"\n        requested_services = set(\n            svc.lower() for svc in current_app.config.get('BOTO3_SERVICES', [])\n        )\n\n        region = current_app.config.get('BOTO3_REGION')\n        sess_params = {\n            'aws_access_key_id': current_app.config.get('BOTO3_ACCESS_KEY'),\n            'aws_secret_access_key': current_app.config.get('BOTO3_SECRET_KEY'),\n            'profile_name': current_app.config.get('BOTO3_PROFILE'),\n            'region_name': region\n        }\n        sess = boto3.session.Session(**sess_params)\n\n        try:\n            cns = {}\n            for svc in requested_services:\n                # Check for optional parameters\n                params = current_app.config.get(\n                    'BOTO3_OPTIONAL_PARAMS', {}\n                ).get(svc, {})\n\n                # Get session params and override them with kwargs\n                # `profile_name` cannot be passed to clients and resources\n                kwargs = sess_params.copy()\n                kwargs.update(params.get('kwargs', {}))\n                del kwargs['profile_name']\n\n                # Override the region if one is defined as an argument\n                args = params.get('args', [])\n                if len(args) >= 1:\n                    del kwargs['region_name']\n\n                if not(isinstance(args, list) or isinstance(args, tuple)):\n                    args = [args]\n\n                # Create resource or client\n                if svc in sess.get_available_resources():\n                    cns.update({svc: sess.resource(svc, *args, **kwargs)})\n                else:\n                    cns.update({svc: sess.client(svc, *args, **kwargs)})\n        except UnknownServiceError:\n            raise\n        return cns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clients(self):\n        clients = {}\n        for k, v in self.connections.items():\n            if hasattr(v.meta, 'client'):       # has boto3 resource\n                clients[k] = v.meta.client\n            else:                               # no boto3 resource\n                clients[k] = v\n        return clients", "response": "Get all clients with and without associated resources"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_kerberos(app, service='HTTP', hostname=gethostname()):\n    '''\n    Configure the GSSAPI service name, and validate the presence of the\n    appropriate principal in the kerberos keytab.\n\n    :param app: a flask application\n    :type app: flask.Flask\n    :param service: GSSAPI service name\n    :type service: str\n    :param hostname: hostname the service runs under\n    :type hostname: str\n    '''\n    global _SERVICE_NAME\n    _SERVICE_NAME = \"%s@%s\" % (service, hostname)\n\n    if 'KRB5_KTNAME' not in environ:\n        app.logger.warn(\"Kerberos: set KRB5_KTNAME to your keytab file\")\n    else:\n        try:\n            principal = kerberos.getServerPrincipalDetails(service, hostname)\n        except kerberos.KrbError as exc:\n            app.logger.warn(\"Kerberos: %s\" % exc.message[0])\n        else:\n            app.logger.info(\"Kerberos: server is %s\" % principal)", "response": "Initialize the Kerberos keytab."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef date_to_timestamp(date):\n    date_tuple = date.timetuple()\n    timestamp = calendar.timegm(date_tuple) * 1000\n    return timestamp", "response": "converts a date to unix timestamp in milliseconds"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef random_date(dt_from, dt_to):\n    delta = dt_to - dt_from\n    int_delta = (delta.days * 24 * 60 * 60) + delta.seconds\n    random_second = randrange(int_delta)\n    return dt_from + datetime.timedelta(seconds=random_second)", "response": "This function will return a random datetime between two datetime objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef object_to_json(obj, indent=2):\n    instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder)\n    return instance_json", "response": "transform object to json"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qs_to_json(qs, fields=None):\n    if not fields :\n        fields = [f.name for f in qs.model._meta.fields]\n\n\n    # \u0441\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043b\u044f \u0441\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n    objects = []\n    for value_dict in qs.values(*fields):\n        # \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u043c \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043f\u043e\u043b\u0435\u0439, \u043a\u0430\u043a \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043e \u0432 \u043c\u043e\u0434\u0435\u043b\u0435\n        o = OrderedDict()\n        for f in fields:\n            o[f] = value_dict[f]\n        objects.append(o)\n\n    # \u0441\u0435\u0440\u0438\u0430\u043b\u0438\u0437\u0443\u0435\u043c\n    json_qs = json.dumps(objects, indent=2, ensure_ascii=False, cls=DjangoJSONEncoder)\n    return json_qs", "response": "transform QuerySet to json"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mongoqs_to_json(qs, fields=None):\n\n    l = list(qs.as_pymongo())\n\n    for element in l:\n        element.pop('_cls')\n\n    # use DjangoJSONEncoder for transform date data type to datetime\n    json_qs = json.dumps(l, indent=2, ensure_ascii=False, cls=DjangoJSONEncoder)\n    return json_qs", "response": "transform mongoengine. QuerySet to json"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef url_path(request, base_url=None, is_full=False, *args, **kwargs):\n    if not base_url:\n        base_url = request.path\n        if is_full:\n            protocol = 'https' if request.is_secure() else 'http'\n            base_url = '%s://%s%s' % (protocol, request.get_host(), base_url)\n\n    params = url_params(request, *args, **kwargs)\n    url = '%s%s' % (base_url, params)\n    return url", "response": "Returns the full url path for the current page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating string with GET - params of the current resource", "response": "def url_params(request, except_params=None, as_is=False):\n    \"\"\"\n    create string with GET-params of request\n\n    usage example:\n        c['sort_url'] = url_params(request, except_params=('sort',))\n        ...\n        <a href=\"{{ sort_url }}&sort=lab_number\">\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440</a>\n    \"\"\"\n    if not request.GET:\n        return ''\n    params = []\n    for key, value in request.GET.items():\n        if except_params and key not in except_params:\n            for v in request.GET.getlist(key):\n                params.append('%s=%s' % (key, urlquote(v)))\n\n    if as_is:\n        str_params = '?' + '&'.join(params)\n    else:\n        str_params = '?' + '&'.join(params)\n        str_params = urlquote(str_params)\n    return mark_safe(str_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares sort parameters for order.", "response": "def prepare_sort_params(params, request, sort_key='sort', revers_sort=None, except_params=None):\n    \"\"\"\n        Prepare sort params. Add revers '-' if need.\n        Params:\n            params - list of sort parameters\n            request\n            sort_key\n            revers_sort - list or set with keys that need reverse default sort direction\n            except_params - GET-params that will be ignored\n        Example:\n            view:\n                c['sort_params'] = prepare_sort_params(\n                    ('order__lab_number', 'order__client__lname', 'organization', 'city', 'street', ),\n                    request,\n                )\n            template:\n                   <th><a href=\"{{ sort_params.order__lab_number.url }}\">\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440</a></th>\n               or\n                    {% load djutils %}\n                    ...\n                    {% sort_th 'order__lab_number' '\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440' %}\n\n\n    \"\"\"\n    current_param, current_reversed = sort_key_process(request, sort_key)\n\n    except_params = except_params or []\n    except_params.append(sort_key)\n\n    base_url = url_params(request, except_params=except_params, as_is=True)\n\n    sort_params = {}\n    revers_sort = revers_sort or set()\n    url_connector = '?' if request.get_full_path() == request.path else \"&\"\n    for p in params:\n        sort_params[p] = {}\n        if current_param and p == current_param:\n            prefix = '' if current_reversed else '-'\n            sort_params[p]['url'] = base_url + \"%s%s=%s\" % (url_connector, sort_key, prefix + current_param)\n            sort_params[p]['is_reversed'] = current_reversed\n            sort_params[p]['is_current'] = True\n        else:\n            default_direction = '-' if p in revers_sort else ''\n            sort_params[p]['url'] = base_url + \"%s%s=%s%s\" % (url_connector, sort_key, default_direction, p)\n            sort_params[p]['is_reversed'] = False\n            sort_params[p]['is_current'] = False\n\n    return sort_params"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprocessing sort key for sorting", "response": "def sort_key_process(request, sort_key='sort'):\n    \"\"\"\n        process sort-parameter value (for example, \"-name\")\n        return:\n            current_param - field for sorting (\"name)\n            current_reversed - revers flag (True)\n    \"\"\"\n    current = request.GET.get(sort_key)\n    current_reversed = False\n    current_param = None\n    if current:\n        mo = re.match(r'^(-?)(\\w+)$', current)    # exclude first \"-\" (if exist)\n        if mo:\n            current_reversed = mo.group(1) == '-'\n            current_param = mo.group(2)\n\n    return current_param, current_reversed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transform_form_error(form, verbose=True):\n    errors = []\n    for field, err_msg in form.errors.items():\n        if field == '__all__':  # general errors\n            errors.append(', '.join(err_msg))\n        else:                   # field errors\n            field_name = field\n            if verbose and field in form.fields:\n                field_name = form.fields[field].label or field\n            errors.append('%s: %s' % (field_name, ', '.join(err_msg)))\n    return errors", "response": "transform form errors to list like\n articles"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_date_from_to_options(options, to_datetime=False, default_dt_to=False):\n    start_time = datetime.datetime.now()\n\n    if options.get('last_week'):\n        dt_from = start_time - datetime.timedelta(days=7)\n        dt_to = start_time\n\n    elif options.get('last_day'):\n        dt_from = start_time - datetime.timedelta(days=1)\n        dt_to = start_time\n\n    elif options.get('last_2hours'):\n        dt_from = start_time - datetime.timedelta(hours=2)\n        dt_to = start_time\n\n    else:\n        from_str = options.get('from')\n        if from_str:\n            try:\n                dt_from = iso_to_datetime(from_str)\n            except:\n                dt_from = iso_to_date(from_str)\n        else:\n            dt_from = None\n\n        to_str = options.get('to')\n        if to_str:\n            try:\n                dt_to = iso_to_datetime(to_str)\n            except:\n                dt_to = iso_to_date(to_str)\n        else:\n            dt_to = None\n\n    if default_dt_to and not dt_to:\n        dt_to = datetime.datetime(2100, 1, 1)\n\n    if to_datetime:\n        if isinstance(dt_from, datetime.date):\n            dt_from = date_to_datetime(dt_from)\n        if isinstance(dt_to, datetime.date):\n            dt_to = date_to_datetime_lte(dt_to)\n\n    return dt_from, dt_to", "response": "Process date from options to options dt_to"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding n items from iterable into n - sized lists.", "response": "def _chunked(iterable, n):\n    \"\"\"\n    Collect data into chunks of up to length n.\n    :type iterable: Iterable[T]\n    :type n: int\n    :rtype: Iterator[list[T]]\n    \"\"\"\n    it = iter(iterable)\n    while True:\n        chunk = list(islice(it, n))\n        if chunk:\n            yield chunk\n        else:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets gender information for a list of names.", "response": "def get(self, names, country_id=None, language_id=None, retheader=False):\n        \"\"\"\n        Look up gender for a list of names.\n        Can optionally refine search with locale info.\n        May make multiple requests if there are more names than\n        can be retrieved in one call.\n\n        :param names: List of names.\n        :type names: Iterable[str]\n        :param country_id: Optional ISO 3166-1 alpha-2 country code.\n        :type country_id: Optional[str]\n        :param language_id: Optional ISO 639-1 language code.\n        :type language_id: Optional[str]\n        :param retheader: Optional\n        :type retheader: Optional[boolean]\n        :return:\n        If retheader is False:\n            List of dicts containing 'name', 'gender',\n                     'probability', 'count' keys. If 'gender' is None,\n                     'probability' and 'count' will be omitted.\n        else:\n            A dict containing 'data' and 'headers' keys.\n            Data is the same as when retheader is False.\n            Headers are the response header\n            (a requests.structures.CaseInsensitiveDict).\n            If multiple requests were made,\n            the header will be from the last one.\n        :rtype: Union[dict, Sequence[dict]]\n        :raises GenderizeException: if API server returns HTTP error code.\n        \"\"\"\n        responses = [\n            self._get_chunk(name_chunk, country_id, language_id)\n            for name_chunk\n            in _chunked(names, Genderize.BATCH_SIZE)\n        ]\n        data = list(chain.from_iterable(\n            response.data for response in responses\n        ))\n        if retheader:\n            return {\n                \"data\": data,\n                \"headers\": responses[-1].headers,\n            }\n        else:\n            return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlooking up gender for a single name.", "response": "def get1(self, name, **kwargs):\n        \"\"\"\n        Look up gender for a single name.\n        See :py:meth:`get`.\n        Doesn't support retheader option.\n        \"\"\"\n        if 'retheader' in kwargs:\n            raise GenderizeException(\n                \"get1() doesn't support the retheader option.\")\n        return self.get([name], **kwargs)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a proxy for a variable.", "response": "def _make_proxy(self, varname, parent=None, constructor=MlabObjectProxy):\n        \"\"\"Creates a proxy for a variable.\n\n        XXX create and cache nested proxies also here.\n        \"\"\"\n        # FIXME why not just use gensym here?\n        proxy_val_name = \"PROXY_VAL%d__\" % self._proxy_count\n        self._proxy_count += 1\n        mlabraw.eval(self._session, \"%s = %s;\" % (proxy_val_name, varname))\n        res = constructor(self, proxy_val_name, parent)\n        self._proxies[proxy_val_name] = res\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get(self, name, remove=False):\n        # FIXME should this really be needed in normal operation?\n        if name in self._proxies: return self._proxies[name]\n        varname = name\n        vartype = self._var_type(varname)\n        if vartype in self._mlabraw_can_convert:\n            var = mlabraw.get(self._session, varname)\n            if isinstance(var, ndarray):\n                if self._flatten_row_vecs and numpy.shape(var)[0] == 1:\n                    var.shape = var.shape[1:2]\n                elif self._flatten_col_vecs and numpy.shape(var)[1] == 1:\n                    var.shape = var.shape[0:1]\n                if self._array_cast:\n                    var = self._array_cast(var)\n        else:\n            var = None\n            if self._dont_proxy.get(vartype):\n                # manual conversions may fail (e.g. for multidimensional\n                # cell arrays), in that case just fall back on proxying.\n                try:\n                    var = self._manually_convert(varname, vartype)\n                except MlabConversionError: pass\n            if var is None:\n                # we can't convert this to a python object, so we just\n                # create a proxy, and don't delete the real matlab\n                # reference until the proxy is garbage collected\n                var = self._make_proxy(varname)\n        if remove:\n            mlabraw.eval(self._session, \"clear('%s');\" % varname)\n        return var", "response": "Directly access a variable in matlab space."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(self, visible=False):\n    if self.client:\n      raise MatlabConnectionError('Matlab(TM) COM client is still active. Use close to '\n                      'close it')\n    self.client = win32com.client.Dispatch('matlab.application')\n    self.client.visible = visible", "response": "Open the current COM client."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eval(self, expression, identify_erros=True):\n    #print expression\n    self._check_open()\n    ret = self.client.Execute(expression)\n    #print ret\n    if identify_erros and ret.rfind('???') != -1:\n      begin = ret.rfind('???') + 4\n      raise MatlabError(ret[begin:])\n    return ret", "response": "Evaluates a matlab expression synchronously."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, names_to_get, convert_to_numpy=True):\n    self._check_open()\n    single_itme = isinstance(names_to_get, (unicode, str))\n    if single_itme:\n      names_to_get = [names_to_get]\n    ret = {}\n    for name in names_to_get:\n      ret[name] = self.client.GetWorkspaceData(name, 'base')\n      # TODO(daniv): Do we really want to reduce dimensions like that? what if this a row vector?\n      while isinstance(ret[name], (tuple, list)) and len(ret[name]) == 1:\n        ret[name] = ret[name][0]\n      if convert_to_numpy and isinstance(ret[name], (tuple, list)):\n        ret[name] = np.array(ret[name])\n    if single_itme:\n      return ret.values()[0]\n    return ret", "response": "Loads the requested variables from the matlab com client."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put(self, name_to_val):\n    self._check_open()\n    for name, val in name_to_val.iteritems():\n      # First try to put data as a matrix:\n      try:\n        self.client.PutFullMatrix(name, 'base', val, None)\n      except:\n        self.client.PutWorkspaceData(name, 'base', val)", "response": "Loads a dictionary of variable names into the matlab com client."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens MATLAB using specified connection or DCOM + protocol on Windows where matlab_location is set.", "response": "def open():\n    global _MATLAB_RELEASE\n    '''Opens MATLAB using specified connection (or DCOM+ protocol on Windows)where matlab_location  '''\n    if is_win:\n        ret = MatlabConnection()\n        ret.open()\n        return ret\n    else:\n        if settings.MATLAB_PATH != 'guess':\n            matlab_path = settings.MATLAB_PATH + '/bin/matlab'\n        elif _MATLAB_RELEASE != 'latest':\n            matlab_path = discover_location(_MATLAB_RELEASE)\n        else:\n            # Latest release is found in __init__.by, i.e. higher logical level\n            raise MatlabReleaseNotFound('Please select a matlab release or set its location.')\n        try:\n            ret = MatlabConnection(matlab_path)\n            ret.open()\n        except Exception:\n            #traceback.print_exc(file=sys.stderr)\n            raise MatlabReleaseNotFound('Could not open matlab, is it in %s?' % matlab_path)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _list_releases():\n    '''\n    Tries to guess matlab process release version and location path on\n    osx machines.\n\n    The paths we will search are in the format:\n    /Applications/MATLAB_R[YEAR][VERSION].app/bin/matlab\n    We will try the latest version first. If no path is found, None is reutrned.\n    '''\n    if is_linux():\n        base_path = '/usr/local/MATLAB/R%d%s/bin/matlab'\n    else:\n        # assume mac\n        base_path = '/Applications/MATLAB_R%d%s.app/bin/matlab'\n    years = range(2050,1990,-1)\n    release_letters = ('h', 'g', 'f', 'e', 'd', 'c', 'b', 'a')\n    for year in years:\n        for letter in release_letters:\n            release = 'R%d%s' % (year, letter)\n            matlab_path = base_path % (year, letter)\n            if os.path.exists(matlab_path):\n                yield (release, matlab_path)", "response": "Yields a list of all available MATLAB process releases and location paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_valid_release_version(version):\n    '''Checks that the given version code is valid.'''\n    return version is not None and len(version) == 6 and version[0] == 'R' \\\n            and int(version[1:5]) in range(1990, 2050) \\\n            and version[5] in ('h', 'g', 'f', 'e', 'd', 'c', 'b', 'a')", "response": "Checks that the given version code is valid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_matlab_version(process_path):\n    bin_path = os.path.dirname(process_path)\n    matlab_path = os.path.dirname(bin_path)\n    matlab_dir_name = os.path.basename(matlab_path)\n    version = matlab_dir_name\n    if not is_linux():\n        version = matlab_dir_name.replace('MATLAB_', '').replace('.app', '')\n    if not is_valid_release_version(version):\n        return None\n    return version", "response": "Tries to guess matlab s version according to its process path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self, print_matlab_welcome=False):\n        '''Opens the matlab process.'''\n        if self.process and not self.process.returncode:\n            raise MatlabConnectionError('Matlab(TM) process is still active. Use close to '\n                                            'close it')\n        self.process = subprocess.Popen(\n                [self.matlab_process_path, '-nojvm', '-nodesktop'],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        flags = fcntl.fcntl(self.process.stdout, fcntl.F_GETFL)\n        fcntl.fcntl(self.process.stdout, fcntl.F_SETFL, flags| os.O_NONBLOCK)\n\n        if print_matlab_welcome:\n            self._sync_output()\n        else:\n            self._sync_output(None)", "response": "Opens the matlab process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nevaluates a matlab expression synchronously.", "response": "def eval(self,\n                     expression,\n                     identify_errors=True,\n                     print_expression=True,\n                     on_new_output=sys.stdout.write):\n        \"\"\" Evaluates a matlab expression synchronously.\n\n        If identify_erros is true, and the last output line after evaluating the\n        expressions begins with '???' and excpetion is thrown with the matlab error\n        following the '???'.\n        If on_new_output is not None, it will be called whenever a new output is\n        encountered. The default value prints the new output to the screen.\n        The return value of the function is the matlab output following the call.\n        \"\"\"\n        self._check_open()\n        if print_expression:\n            print expression\n        self.process.stdin.write(expression)\n        self.process.stdin.write('\\n')\n        ret = self._sync_output(on_new_output)\n        # TODO(dani): Use stderr to identify errors.\n        if identify_errors and ret.rfind('???') != -1:\n            begin = ret.rfind('???') + 4\n            end = ret.find('\\n', begin)\n            raise MatlabError(ret[begin:end])\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put(self, name_to_val, oned_as='row', on_new_output=None):\n        self._check_open()\n        # We can't give stdin to mlabio.savemat because it needs random access :(\n        temp = StringIO()\n        mlabio.savemat(temp, name_to_val, oned_as=oned_as)\n        temp.seek(0)\n        temp_str = temp.read()\n        temp.close()\n        self.process.stdin.write('load stdio;\\n')\n        self._read_until('ack load stdio\\n', on_new_output=on_new_output)\n        self.process.stdin.write(temp_str)\n        #print 'sent %d kb' % (len(temp_str) / 1024)\n        self._read_until('ack load finished\\n', on_new_output=on_new_output)\n        self._sync_output(on_new_output=on_new_output)", "response": "Loads a dictionary of variable names into the matlab shell."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self,\n                    names_to_get,\n                    extract_numpy_scalars=True,\n                    on_new_output=None):\n        \"\"\" Loads the requested variables from the matlab shell.\n\n        names_to_get can be either a variable name, a list of variable names, or\n        None.\n        If it is a variable name, the values is returned.\n        If it is a list, a dictionary of variable_name -> value is returned.\n        If it is None, a dictionary with all variables is returned.\n\n        If extract_numpy_scalars is true, the method will convert numpy scalars\n        (0-dimension arrays) to a regular python variable.\n        \"\"\"\n        self._check_open()\n        single_item = isinstance(names_to_get, (unicode, str))\n        if single_item:\n            names_to_get = [names_to_get]\n        if names_to_get == None:\n            self.process.stdin.write('save stdio;\\n')\n        else:\n            # Make sure that we throw an excpetion if the names are not defined.\n            for name in names_to_get:\n                self.eval('%s;' % name, print_expression=False, on_new_output=on_new_output)\n            #print 'save(\\'stdio\\', \\'%s\\');\\n' % '\\', \\''.join(names_to_get)\n            self.process.stdin.write(\n                \"save('stdio', '%s', '-v7');\\n\" % '\\', \\''.join(names_to_get))\n        # We have to read to a temp buffer because mlabio.loadmat needs\n        # random access :(\n        self._read_until('start_binary\\n', on_new_output=on_new_output)\n        #print 'got start_binary'\n        temp_str = self._sync_output(on_new_output=on_new_output)\n        #print 'got all outout'\n        # Remove expected output and \"\\n>>\"\n        # TODO(dani): Get rid of the unecessary copy.\n        # MATLAB 2010a adds an extra >> so we need to remove more spaces.\n        if self.matlab_version == (2010, 'a'):\n            temp_str = temp_str[:-len(self.expected_output_end)-6]\n        else:\n            temp_str = temp_str[:-len(self.expected_output_end)-3]\n        temp = StringIO(temp_str)\n        #print ('____')\n        #print len(temp_str)\n        #print ('____')\n        ret = mlabio.loadmat(temp, chars_as_strings=True, squeeze_me=True)\n        #print '******'\n        #print ret\n        #print '******'\n        temp.close()\n        if single_item:\n            return ret.values()[0]\n        for key in ret.iterkeys():\n            while ret[key].shape and ret[key].shape[-1] == 1:\n                ret[key] = ret[key][0]\n            if extract_numpy_scalars:\n                if isinstance(ret[key], np.ndarray) and not ret[key].shape:\n                    ret[key] = ret[key].tolist()\n        #print 'done'\n        return ret", "response": "Loads the requested variables from the matlab shell."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the named groups in a regular expression compiled or as string", "response": "def rexGroups(rex):\n    \"\"\"Return the named groups in a regular expression (compiled or as string)\n    in occuring order.\n\n    >>> rexGroups(r'(?P<name>\\w+) +(?P<surname>\\w+)')\n    ('name', 'surname')\n\n    \"\"\"\n    if isinstance(rex,basestring): rex = re.compile(rex)\n    return zip(*sorted([(n,g) for (g,n) in rex.groupindex.items()]))[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef div(a,b):\n    res, fail = divmod(a,b)\n    if fail:\n        raise ValueError(\"%r does not divide %r\" % (b,a))\n    else:\n        return res", "response": "divide two lists of items"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ipshuffle(l, random=None):\n    import random as _random\n    _random.shuffle(l, random)\n    return l", "response": "r Shuffle list l inplace and return it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npass file to func and ensure the file is closed afterwards.", "response": "def withFile(file, func, mode='r', expand=False):\n    \"\"\"Pass `file` to `func` and ensure the file is closed afterwards. If\n       `file` is a string, open according to `mode`; if `expand` is true also\n       expand user and vars.\n    \"\"\"\n    file = _normalizeToFile(file, mode=mode, expand=expand)\n    try:      return func(file)\n    finally:  file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef slurpLines(file, expand=False):\n    file = _normalizeToFile(file, \"r\", expand)\n    try:     return file.readlines()\n    finally: file.close()", "response": "r Read in a complete file and return a list of lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef slurpChompedLines(file, expand=False):\n    f=_normalizeToFile(file, \"r\", expand)\n    try: return list(chompLines(f))\n    finally: f.close()", "response": "r Return file a list of chomped lines. See slurpLines."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new tempfile write s to it and return the filename.", "response": "def strToTempfile(s, suffix=None, prefix=None, dir=None, binary=False):\n    \"\"\"Create a new tempfile, write ``s`` to it and return the filename.\n    `suffix`, `prefix` and `dir` are like in `tempfile.mkstemp`.\n    \"\"\"\n    fd, filename = tempfile.mkstemp(**dict((k,v) for (k,v) in\n                                           [('suffix',suffix),('prefix',prefix),('dir', dir)]\n                                           if v is not None))\n    spitOut(s, fd, binary)\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spitOutLines(lines, file, expand=False):\n    file = _normalizeToFile(file, mode=\"w\", expand=expand)\n    try:     file.writelines(lines)\n    finally: file.close()", "response": "r Write all the lines to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readProcess(cmd, *args):\n    import popen2\n    BUFSIZE=1024\n    import select\n    popen = popen2.Popen3((cmd,) + args, capturestderr=True)\n    which = {id(popen.fromchild): [],\n             id(popen.childerr):  []}\n    select = Result(select.select)\n    read   = Result(os.read)\n    try:\n        popen.tochild.close() # XXX make sure we're not waiting forever\n        while select([popen.fromchild, popen.childerr], [], []):\n            readSomething = False\n            for f in select.result[0]:\n                while read(f.fileno(), BUFSIZE):\n                    which[id(f)].append(read.result)\n                    readSomething = True\n            if not readSomething:\n                break\n        out, err = [\"\".join(which[id(f)])\n                    for f in [popen.fromchild, popen.childerr]]\n        returncode = popen.wait()\n\n        if os.WIFEXITED(returncode):\n            exit = os.WEXITSTATUS(returncode)\n        else:\n            exit = returncode or 1 # HACK: ensure non-zero\n    finally:\n        try:\n            popen.fromchild.close()\n        finally:\n            popen.childerr.close()\n    return out or \"\", err or \"\", exit", "response": "r Similar to os. popen2. popen3 but returns 2 strings stdout and exit code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef runProcess(cmd, *args):\n    from os import spawnvp, P_WAIT\n    return spawnvp(P_WAIT, cmd, (cmd,) + args)", "response": "Run a process in the executable path with the given args and return the exit status."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlike os. path. splitext but does not treat dotfiles as extensions.", "response": "def splitext(p):\n    r\"\"\"Like the normal splitext (in posixpath), but doesn't treat dotfiles\n    (e.g. .emacs) as extensions. Also uses os.sep instead of '/'.\"\"\"\n\n    root, ext = os.path.splitext(p)\n    # check for dotfiles\n    if (not root or root[-1] == os.sep): # XXX: use '/' or os.sep here???\n        return (root + ext, \"\")\n    else:\n        return root, ext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bipart(func, seq):\n\n    if func is None: func = bool\n    res = [[],[]]\n    for i in seq: res[not not func(i)].append(i)\n    return res", "response": "r Like a partitioning version of filter. Returns\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef notUnique(iterable, reportMax=INF):\n    hash = {}\n    n=0\n    if reportMax < 1:\n        raise ValueError(\"`reportMax` must be >= 1 and is %r\" % reportMax)\n    for item in iterable:\n        count = hash[item] = hash.get(item, 0) + 1\n        if count > 1:\n            yield item\n            n += 1\n            if n >= reportMax:\n                return", "response": "Returns the elements in iterable that aren t unique ; stops after it found\n    reportMax non - unique elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unweave(iterable, n=2):\n    res = [[] for i in range(n)]\n    i = 0\n    for x in iterable:\n        res[i % n].append(x)\n        i += 1\n    return res", "response": "r Divide iterable in n lists so that every nth element belongs to\n    list n."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef weave(*iterables):\n    iterables = map(iter, iterables)\n    while True:\n        for it in iterables: yield it.next()", "response": "r Returns a sequence that can be used to generate a sequence from the given iterable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef atIndices(indexable, indices, default=__unique):\n    if default is __unique:\n        return [indexable[i] for i in indices]\n    else:\n        res = []\n        for i in indices:\n            try:\n                res.append(indexable[i])\n            except (IndexError, KeyError):\n                res.append(default)\n        return res", "response": "r Return a list of items in indexable at positions indices."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iterate(f, n=None, last=__unique):\n    if n is not None:\n        def funciter(start):\n            for i in xrange(n): yield start; start = f(start)\n    else:\n        def funciter(start):\n            while True:\n                yield start\n                last = f(start)\n                if last == start: return\n                last, start = start, last\n    return funciter", "response": "Iterate over the elements of a sequence of elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stretch(iterable, n=2):\n    times = range(n)\n    for item in iterable:\n        for i in times: yield item", "response": "r Repeat each item in iterable n times."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef splitAt(iterable, indices):\n    iterable = iter(iterable)\n    now = 0\n    for to in indices:\n        try:\n            res = []\n            for i in range(now, to): res.append(iterable.next())\n        except StopIteration: yield res; return\n        yield res\n        now = to\n    res = list(iterable)\n    if res: yield res", "response": "r Yields chunks of iterable split at the points in indices."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a copy of dict d updated with dict e.", "response": "def update(d, e):\n    \"\"\"Return a copy of dict `d` updated with dict `e`.\"\"\"\n    res = copy.copy(d)\n    res.update(e)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef invertDict(d, allowManyToOne=False):\n    res = dict(izip(d.itervalues(), d.iterkeys()))\n    if not allowManyToOne and len(res) != len(d):\n        raise ValueError(\"d can't be inverted!\")\n    return res", "response": "r Return an inverted version of dict d so that values become keys and\n    vice versa."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten(seq, isSeq=isSeq):\n    return [a for elt in seq\n            for a in (isSeq(elt) and flatten(elt, isSeq) or\n                      [elt])]", "response": "r Returns a flattened version of a sequence seq as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef without(seq1, seq2):\n    if isSet(seq2): d2 = seq2\n    else: d2 = set(seq2)\n    return [elt for elt in seq1 if elt not in d2]", "response": "r Returns a list with all elements in seq2 removed from seq1."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef some(predicate, *seqs):\n    try:\n        if len(seqs) == 1: return ifilter(bool,imap(predicate, seqs[0])).next()\n        else:             return ifilter(bool,starmap(predicate, izip(*seqs))).next()\n    except StopIteration: return False", "response": "True if all elements in the sequence pass the predicate."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef every(predicate, *iterables):\n    try:\n        if len(iterables) == 1: ifilterfalse(predicate, iterables[0]).next()\n        else:                  ifilterfalse(bool, starmap(predicate, izip(*iterables))).next()\n    except StopIteration: return True\n    else: return False", "response": "r Like some but only returns True if all the elements of iterables satisfy predicate."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timeCall(*funcAndArgs, **kwargs):\n\n    func, args = funcAndArgs[0], funcAndArgs[1:]\n    start = time.time()\n    func(*args, **kwargs)\n    return time.time() - start", "response": "r Returns the time it takes to call a function with the remaining arguments and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unescape(s):\n    if re.search(r'(?<!\\\\)\\\\(\\\\\\\\)*[uU]', s) or isinstance(s, unicode):\n        return unescapeUnicode(s)\n    else:\n        return unescapeAscii(s)", "response": "r\"\"\"Inverse of `escape`.\n    >>> unescape(r'\\x41\\n\\x42\\n\\x43')\n    'A\\nB\\nC'\n    >>> unescape(r'\\u86c7')\n    u'\\u86c7'\n    >>> unescape(u'ah')\n    u'ah'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lineAndColumnAt(s, pos):\n    if pos >= len(s):\n        raise IndexError(\"`pos` %d not in string\" % pos)\n    # *don't* count last '\\n', if it is at pos!\n    line = s.count('\\n',0,pos)\n    if line:\n        return line + 1, pos - s.rfind('\\n',0,pos) - 1\n    else:\n        return 1, pos", "response": "r Return line and column of pos in s. Lines start with 1 columns with 0."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prin(*args, **kwargs):\n    print >> kwargs.get('out',None), \" \".join([str(arg) for arg in args])", "response": "r Prints out all arguments as\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addVars(filename, varNamesStr, outOf=None):\n    filename, varnames, outOf = __saveVarsHelper(filename, varNamesStr, outOf)\n    f = None\n    try:\n        f = open(filename, \"rb\")\n        h = cPickle.load(f)\n        f.close()\n\n        h.update(dict(zip(varnames, atIndices(outOf, varnames))))\n        f = open(filename, \"wb\")\n        cPickle.dump( h, f , 1 )\n    finally:\n        if f: f.close()", "response": "r Like saveVars but appends additional variables to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef loadDict(filename):\n    filename = os.path.expanduser(filename)\n    if not splitext(filename)[1]: filename += \".bpickle\"\n    f = None\n    try:\n        f = open(filename, \"rb\")\n        varH = cPickle.load(f)\n    finally:\n        if f: f.close()\n    return varH", "response": "Return the variables pickled into filename with saveVars\n    as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef loadVars(filename, ask=True, into=None, only=None):\n\n    filename = os.path.expanduser(filename)\n    if into is None: into = magicGlobals()\n    varH = loadDict(filename)\n    toUnpickle = only or varH.keys()\n    alreadyDefined = filter(into.has_key, toUnpickle)\n    if alreadyDefined and ask:\n\tprint \"The following vars already exist; overwrite (yes/NO)?\\n\",\\\n\t      \"\\n\".join(alreadyDefined)\n\tif raw_input() != \"yes\":\n\t    toUnpickle = without(toUnpickle, alreadyDefined)\n    if not toUnpickle:\n\tprint \"nothing to unpickle\"\n\treturn None\n    print \"unpickling:\\n\",\\\n\t  \"\\n\".join(sorted(toUnpickle))\n    for k in varH.keys():\n        if k not in toUnpickle:\n            del varH[k]\n    into.update(varH)", "response": "r Loads the variables from a file into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef makePrintReturner(pre=\"\", post=\"\" ,out=None):\n    def printReturner(arg):\n        myArgs = [pre, arg, post]\n        prin(*myArgs, **{'out':out})\n        return arg\n    return printReturner", "response": "r Returns a function that prints out their argument and returns it unmodified."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a verbose version of the given container instance.", "response": "def asVerboseContainer(cont, onGet=None, onSet=None, onDel=None):\n    \"\"\"Returns a 'verbose' version of container instance `cont`, that will\n       execute `onGet`, `onSet` and `onDel` (if not `None`) every time\n       __getitem__, __setitem__ and __delitem__ are called, passing `self`, `key`\n       (and `value` in the case of set). E.g:\n\n       >>> l = [1,2,3]\n       >>> l = asVerboseContainer(l,\n       ...                onGet=lambda s,k:k==2 and prin('Got two:', k),\n       ...                onSet=lambda s,k,v:k == v and prin('k == v:', k, v),\n       ...                onDel=lambda s,k:k == 1 and prin('Deleting one:', k))\n       >>> l\n       [1, 2, 3]\n       >>> l[1]\n       2\n       >>> l[2]\n       Got two: 2\n       3\n       >>> l[2] = 22\n       >>> l[2] = 2\n       k == v: 2 2\n       >>> del l[2]\n       >>> del l[1]\n       Deleting one: 1\n\n    \"\"\"\n    class VerboseContainer(type(cont)):\n        if onGet:\n            def __getitem__(self, key):\n                onGet(self, key)\n                return super(VerboseContainer, self).__getitem__(key)\n        if onSet:\n            def __setitem__(self, key, value):\n                onSet(self, key, value)\n                return super(VerboseContainer, self).__setitem__(key, value)\n        if onDel:\n            def __delitem__(self, key):\n                onDel(self, key)\n                return super(VerboseContainer, self).__delitem__(key)\n    return VerboseContainer(cont)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef d2attrs(*args, **kwargs):\n    (d, self), args = args[:2], args[2:]\n    if args[0] == 'all!':\n        assert len(args) == 1\n        for k in d: setattr(self, k, d[k])\n    else:\n        if len(args) != len(set(args)) or set(kwargs) & set(args):\n            raise ValueError('Duplicate keys: %s' %\n                             list(notUnique(args)) + list(set(kwargs) & set(args)))\n        for k in args:\n            if k in kwargs: raise ValueError('%s specified twice' % k)\n            setattr(self, k, d[k])\n        for dk in kwargs:\n            setattr(self, dk, d.get(dk, kwargs[dk]))", "response": "Utility function to remove attributes from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the index of the first element in an iterable.", "response": "def argmax(iterable, key=None, both=False):\n    \"\"\"\n    >>> argmax([4,2,-5])\n    0\n    >>> argmax([4,2,-5], key=abs)\n    2\n    >>> argmax([4,2,-5], key=abs, both=True)\n    (2, 5)\n    \"\"\"\n    if key is not None:\n        it = imap(key, iterable)\n    else:\n        it = iter(iterable)\n    score, argmax = reduce(max, izip(it, count()))\n    if both:\n        return argmax, score\n    return argmax"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns true if num is an integer.", "response": "def isInt(num):\n    \"\"\"Returns true if `num` is (sort of) an integer.\n    >>> isInt(3) == isInt(3.0) == 1\n    True\n    >>> isInt(3.2)\n    False\n    >>> import numpy\n    >>> isInt(numpy.array(1))\n    True\n    >>> isInt(numpy.array([1]))\n    False\n    \"\"\"\n    try:\n        len(num) # FIXME fails for Numeric but Numeric is obsolete\n    except:\n        try:\n            return (num - math.floor(num) == 0) == True\n        except: return False\n    else: return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mapConcat(func, *iterables):\n    return [e for l in imap(func, *iterables) for e in l]", "response": "Similar to map but uses a list of lists to produce a new list of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunfold a set of items into a list of items.", "response": "def unfold(seed, by, last = __unique):\n    \"\"\"\n    >>> list(unfold(1234, lambda x: divmod(x,10)))[::-1]\n    [1, 2, 3, 4]\n    >>> sum(imap(operator.mul,unfold(1234, lambda x:divmod(x,10)), iterate(lambda x:x*10)(1)))\n    1234\n    >>> g = unfold(1234, lambda x:divmod(x,10))\n    >>> reduce((lambda (total,pow),digit:(total+pow*digit, 10*pow)), g, (0,1))\n    (1234, 10000)\n    \"\"\"\n\n    while True:\n        seed, val = by(seed);\n        if last == seed: return\n        last = seed; yield val"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreducing a sequence of numbers.", "response": "def reduceR(f, sequence, initial=__unique):\n    \"\"\"*R*ight reduce.\n    >>> reduceR(lambda x,y:x/y, [1.,2.,3.,4]) == 1./(2./(3./4.)) == (1./2.)*(3./4.)\n    True\n    >>> reduceR(lambda x,y:x-y, iter([1,2,3]),4) == 1-(2-(3-4)) == (1-2)+(3-4)\n    True\n    \"\"\"\n    try: rev = reversed(sequence)\n    except TypeError: rev = reversed(list(sequence))\n    if initial is __unique: return reduce(lambda x,y:f(y,x), rev)\n    else:                   return reduce(lambda x,y:f(y,x), rev, initial)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomposes a list of functions to a single function.", "response": "def compose(*funcs):\n    \"\"\"Compose `funcs` to a single function.\n\n    >>> compose(operator.abs, operator.add)(-2,-3)\n    5\n    >>> compose()('nada')\n    'nada'\n    >>> compose(sorted, set, partial(filter, None))(range(3)[::-1]*2)\n    [1, 2]\n    \"\"\"\n    # slightly optimized for most common cases and hence verbose\n    if len(funcs) == 2: f0,f1=funcs; return lambda *a,**kw: f0(f1(*a,**kw))\n    elif len(funcs) == 3: f0,f1,f2=funcs; return lambda *a,**kw: f0(f1(f2(*a,**kw)))\n    elif len(funcs) == 0: return lambda x:x     # XXX single kwarg\n    elif len(funcs) == 1: return funcs[0]\n    else:\n        def composed(*args,**kwargs):\n            y = funcs[-1](*args,**kwargs)\n            for f in funcs[:0:-1]: y = f(y)\n            return y\n        return composed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef romanNumeral(n):\n    if 0 > n > 4000: raise ValueError('``n`` must lie between 1 and 3999: %d' % n)\n    roman   = 'I IV  V  IX  X  XL   L  XC    C   CD    D   CM     M'.split()\n    arabic  = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n    res = []\n    while n>0:\n        pos = bisect.bisect_right(arabic, n)-1\n        fit = n//arabic[pos]\n        res.append(roman[pos]*fit); n -= fit * arabic[pos]\n    return \"\".join(res)", "response": "Returns a roman numeral string for the given integer n."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first n elements of an iterable.", "response": "def first(n, it, constructor=list):\n    \"\"\"\n    >>> first(3,iter([1,2,3,4]))\n    [1, 2, 3]\n    >>> first(3,iter([1,2,3,4]), iter) #doctest: +ELLIPSIS\n    <itertools.islice object at ...>\n    >>> first(3,iter([1,2,3,4]), tuple)\n    (1, 2, 3)\n    \"\"\"\n    return constructor(itertools.islice(it,n))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef drop(n, it, constructor=list):\n    return constructor(itertools.islice(it,n,None))", "response": "Drop n elements from an iterable."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, func, *args, **kwargs):\n        if self.dry:\n            return self.dryRun(func, *args, **kwargs)\n        else:\n            return self.wetRun(func, *args, **kwargs)", "response": "Same as self. run except that it will return the result of the function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dryRun(self, func, *args, **kwargs):\n\n        print >> self.out, \\\n              self.formatterDict.get(func, self.defaultFormatter)(func, *args, **kwargs)", "response": "Instead of running function with * args and ** kwargs just print\n           out the function call."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over all the bridges in the system.", "response": "def iterbridges():\n    ''' Iterate over all the bridges in the system. '''\n    net_files = os.listdir(SYSFS_NET_PATH)\n    for d in net_files:\n        path = os.path.join(SYSFS_NET_PATH, d)\n        if not os.path.isdir(path):\n            continue\n        if os.path.exists(os.path.join(path, b\"bridge\")):\n            yield Bridge(d)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addbr(name):\n    ''' Create new bridge with the given name '''\n    fcntl.ioctl(ifconfig.sockfd, SIOCBRADDBR, name)\n    return Bridge(name)", "response": "Create a new bridge with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over all the interfaces in this bridge.", "response": "def iterifs(self):\n        ''' Iterate over all the interfaces in this bridge. '''\n        if_path = os.path.join(SYSFS_NET_PATH, self.name, b\"brif\")\n        net_files = os.listdir(if_path)\n        for iface in net_files:\n            yield iface"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addif(self, iface):\n        ''' Add the interface with the given name to this bridge. Equivalent to\n            brctl addif [bridge] [interface]. '''\n        if type(iface) == ifconfig.Interface:\n            devindex = iface.index\n        else:\n            devindex = ifconfig.Interface(iface).index\n        ifreq = struct.pack('16si', self.name, devindex)\n        fcntl.ioctl(ifconfig.sockfd, SIOCBRADDIF, ifreq)\n        return self", "response": "Add the given interface to this bridge. Equivalent to calling brctl addif."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the interface with the given name from this bridge.", "response": "def delif(self, iface):\n        ''' Remove the interface with the given name from this bridge.\n            Equivalent to brctl delif [bridge] [interface]'''\n        if type(iface) == ifconfig.Interface:\n            devindex = iface.index\n        else:\n            devindex = ifconfig.Interface(iface).index\n        ifreq = struct.pack('16si', self.name, devindex)\n        fcntl.ioctl(ifconfig.sockfd, SIOCBRDELIF, ifreq)    \n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self):\n        ''' Brings down the bridge interface, and removes it. Equivalent to\n        ifconfig [bridge] down && brctl delbr [bridge]. '''\n        self.down()\n        fcntl.ioctl(ifconfig.sockfd, SIOCBRDELBR, self.name)\n        return self", "response": "Delete the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a random string identifier", "response": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a filename of a built - in library file.", "response": "def get_lib_filename(category, name):\n    \"\"\" Get a filename of a built-in library file. \"\"\"\n    base_dir = os.path.dirname(os.path.abspath(__file__))\n    if category == 'js':\n        filename = os.path.join('js', '{0}.js'.format(name))\n    elif category == 'css':\n        filename = os.path.join('css', '{0}.css'.format(name))\n    elif category == 'html':\n        filename = os.path.join('html', '{0}.html'.format(name))\n    else:\n        raise ValueError(\"Unknown category\")\n    return os.path.join(base_dir, 'lib', filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noutputs the Jupyter Notebook.", "response": "def output_notebook(\n        d3js_url=\"//d3js.org/d3.v3.min\",\n        requirejs_url=\"//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js\",\n        html_template=None\n):\n    \"\"\" Import required Javascript libraries to Jupyter Notebook. \"\"\"\n\n    if html_template is None:\n        html_template = read_lib('html', 'setup')\n\n    setup_html = populate_template(\n        html_template,\n        d3js=d3js_url,\n        requirejs=requirejs_url\n    )\n\n    display_html(setup_html)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate HTML code block given the graph Javascript and CSS.", "response": "def create_graph_html(js_template, css_template, html_template=None):\n    \"\"\" Create HTML code block given the graph Javascript and CSS. \"\"\"\n    if html_template is None:\n        html_template = read_lib('html', 'graph')\n\n    # Create div ID for the graph and give it to the JS and CSS templates so\n    # they can reference the graph.\n    graph_id = 'graph-{0}'.format(_get_random_id())\n    js = populate_template(js_template, graph_id=graph_id)\n    css = populate_template(css_template, graph_id=graph_id)\n\n    return populate_template(\n        html_template,\n        graph_id=graph_id,\n        css=css,\n        js=js\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning newest compatible version.", "response": "def get_newest_possible_languagetool_version():\n    \"\"\"Return newest compatible version.\n\n    >>> version = get_newest_possible_languagetool_version()\n    >>> version in [JAVA_6_COMPATIBLE_VERSION, LATEST_VERSION]\n    True\n\n    \"\"\"\n    java_path = find_executable('java')\n    if not java_path:\n        # Just ignore this and assume an old version of Java. It might not be\n        # found because of a PATHEXT-related issue\n        # (https://bugs.python.org/issue2200).\n        return JAVA_6_COMPATIBLE_VERSION\n\n    output = subprocess.check_output([java_path, '-version'],\n                                     stderr=subprocess.STDOUT,\n                                     universal_newlines=True)\n    # https://www.oracle.com/technetwork/java/javase/versioning-naming-139433.html\n    match = re.search(\n        r'^java version \"(?P<major1>\\d+)\\.(?P<major2>\\d+)\\.[^\"]+\"$',\n        output,\n        re.MULTILINE)\n    if not match:\n        raise SystemExit(\n            'Could not parse Java version from \"\"\"{}\"\"\".'.format(output))\n\n    java_version = (int(match.group('major1')), int(match.group('major2')))\n    if java_version >= (1, 7):\n        return LATEST_VERSION\n    elif java_version >= (1, 6):\n        warn('grammar-check would be able to use a newer version of '\n             'LanguageTool if you had Java 7 or newer installed')\n        return JAVA_6_COMPATIBLE_VERSION\n    else:\n        raise SystemExit(\n            'You need at least Java 6 to use grammar-check')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over all the interfaces in the system.", "response": "def iterifs(physical=True):\n    ''' Iterate over all the interfaces in the system. If physical is\n        true, then return only real physical interfaces (not 'lo', etc).'''\n    net_files = os.listdir(SYSFS_NET_PATH)\n    interfaces = set()\n    virtual = set()\n    for d in net_files:\n        path = os.path.join(SYSFS_NET_PATH, d)\n        if not os.path.isdir(path):\n            continue\n        if not os.path.exists(os.path.join(path, b\"device\")):\n            virtual.add(d)\n        interfaces.add(d)\n\n    # Some virtual interfaces don't show up in the above search, for example,\n    # subinterfaces (e.g. eth0:1). To find those, we have to do an ioctl\n    if not physical:\n        # ifconfig gets a max of 30 interfaces. Good enough for us too.\n        ifreqs = array.array(\"B\", b\"\\x00\" * SIZE_OF_IFREQ * 30)\n        buf_addr, _buf_len = ifreqs.buffer_info()\n        ifconf = struct.pack(\"iP\", SIZE_OF_IFREQ * 30, buf_addr)\n        ifconf_res = fcntl.ioctl(sockfd, SIOCGIFCONF, ifconf)\n        ifreqs_len, _ = struct.unpack(\"iP\", ifconf_res)\n\n        assert ifreqs_len % SIZE_OF_IFREQ == 0, (\n            \"Unexpected amount of data returned from ioctl. \"\n            \"You're probably running on an unexpected architecture\")\n\n        res = ifreqs.tostring()\n        for i in range(0, ifreqs_len, SIZE_OF_IFREQ):\n            d = res[i:i+16].strip(b'\\0')\n            interfaces.add(d)\n\n    results = interfaces - virtual if physical else interfaces\n    for d in results:\n        yield Interface(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef up(self):\n        ''' Bring up the bridge interface. Equivalent to ifconfig [iface] up. '''\n\n        # Get existing device flags\n        ifreq = struct.pack('16sh', self.name, 0)\n        flags = struct.unpack('16sh', fcntl.ioctl(sockfd, SIOCGIFFLAGS, ifreq))[1]\n\n        # Set new flags\n        flags = flags | IFF_UP\n        ifreq = struct.pack('16sh', self.name, flags)\n        fcntl.ioctl(sockfd, SIOCSIFFLAGS, ifreq)", "response": "Bring up the bridge interface. Equivalent to ifconfig [ iface up."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_up(self):\n        ''' Return True if the interface is up, False otherwise. '''\n\n        # Get existing device flags\n        ifreq = struct.pack('16sh', self.name, 0)\n        flags = struct.unpack('16sh', fcntl.ioctl(sockfd, SIOCGIFFLAGS, ifreq))[1]\n\n        # Set new flags\n        if flags & IFF_UP:\n            return True\n        else:\n            return False", "response": "Return True if the interface is up False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_mac(self):\n        ''' Obtain the device's mac address. '''\n        ifreq = struct.pack('16sH14s', self.name, AF_UNIX, b'\\x00'*14)\n        res = fcntl.ioctl(sockfd, SIOCGIFHWADDR, ifreq)\n        address = struct.unpack('16sH14s', res)[2]\n        mac = struct.unpack('6B8x', address)\n\n        return \":\".join(['%02X' % i for i in mac])", "response": "Obtain the device s mac address."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_mac(self, newmac):\n        ''' Set the device's mac address. Device must be down for this to\n            succeed. '''\n        macbytes = [int(i, 16) for i in newmac.split(':')]\n        ifreq = struct.pack('16sH6B8x', self.name, AF_UNIX, *macbytes)\n        fcntl.ioctl(sockfd, SIOCSIFHWADDR, ifreq)", "response": "Set the device s mac address."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_index(self):\n        ''' Convert an interface name to an index value. '''\n        ifreq = struct.pack('16si', self.name, 0)\n        res = fcntl.ioctl(sockfd, SIOCGIFINDEX, ifreq)\n        return struct.unpack(\"16si\", res)[1]", "response": "Convert an interface name to an index value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_pause_param(self, autoneg, rx_pause, tx_pause):\n        # create a struct ethtool_pauseparm\n        # create a struct ifreq with its .ifr_data pointing at the above\n        ecmd = array.array('B', struct.pack('IIII',\n            ETHTOOL_SPAUSEPARAM, bool(autoneg), bool(rx_pause), bool(tx_pause)))\n        buf_addr, _buf_len = ecmd.buffer_info()\n        ifreq = struct.pack('16sP', self.name, buf_addr)\n        fcntl.ioctl(sockfd, SIOCETHTOOL, ifreq)", "response": "Set the pause parameter for the current set of inter - frame types."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit a string with comma or space - separated elements into a list.", "response": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates Python 2 code from Python 3 code.", "response": "def generate_py2k(config, py2k_dir=PY2K_DIR, run_tests=False):\n    \"\"\"Generate Python 2 code from Python 3 code.\"\"\"\n    def copy(src, dst):\n        if (not os.path.isfile(dst) or\n                os.path.getmtime(src) > os.path.getmtime(dst)):\n            shutil.copy(src, dst)\n            return dst\n        return None\n\n    def copy_data(src, dst):\n        if (not os.path.isfile(dst) or\n                os.path.getmtime(src) > os.path.getmtime(dst) or\n                os.path.getsize(src) != os.path.getsize(dst)):\n            shutil.copy(src, dst)\n            return dst\n        return None\n\n    copied_py_files = []\n    test_scripts = []\n\n    if not os.path.isdir(py2k_dir):\n        os.makedirs(py2k_dir)\n\n    packages_root = get_cfg_value(config, 'files', 'packages_root')\n\n    for name in get_cfg_value(config, 'files', 'packages'):\n        name = name.replace('.', os.path.sep)\n        py3k_path = os.path.join(packages_root, name)\n        py2k_path = os.path.join(py2k_dir, py3k_path)\n        if not os.path.isdir(py2k_path):\n            os.makedirs(py2k_path)\n        for fn in os.listdir(py3k_path):\n            path = os.path.join(py3k_path, fn)\n            if not os.path.isfile(path):\n                continue\n            if not os.path.splitext(path)[1].lower() == '.py':\n                continue\n            new_path = os.path.join(py2k_path, fn)\n            if copy(path, new_path):\n                copied_py_files.append(new_path)\n\n    for name in get_cfg_value(config, 'files', 'modules'):\n        name = name.replace('.', os.path.sep) + '.py'\n        py3k_path = os.path.join(packages_root, name)\n        py2k_path = os.path.join(py2k_dir, py3k_path)\n        dirname = os.path.dirname(py2k_path)\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        if copy(py3k_path, py2k_path):\n            copied_py_files.append(py2k_path)\n\n    for name in get_cfg_value(config, 'files', 'scripts'):\n        py3k_path = os.path.join(packages_root, name)\n        py2k_path = os.path.join(py2k_dir, py3k_path)\n        dirname = os.path.dirname(py2k_path)\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        if copy(py3k_path, py2k_path):\n            copied_py_files.append(py2k_path)\n\n    setup_py_path = os.path.abspath(__file__)\n\n    for pattern in get_cfg_value(config, 'files', 'extra_files'):\n        for path in glob.glob(pattern):\n            if os.path.abspath(path) == setup_py_path:\n                continue\n            py2k_path = os.path.join(py2k_dir, path)\n            py2k_dirname = os.path.dirname(py2k_path)\n            if not os.path.isdir(py2k_dirname):\n                os.makedirs(py2k_dirname)\n            filename = os.path.split(path)[1]\n            ext = os.path.splitext(filename)[1].lower()\n            if ext == '.py':\n                if copy(path, py2k_path):\n                    copied_py_files.append(py2k_path)\n            else:\n                copy_data(path, py2k_path)\n            if (os.access(py2k_path, os.X_OK) and\n                    re.search(r\"\\btest\\b|_test\\b|\\btest_\", filename)):\n                test_scripts.append(py2k_path)\n\n    for package, patterns in get_package_data(\n            get_cfg_value(config, 'files', 'package_data')).items():\n        for pattern in patterns:\n            py3k_pattern = os.path.join(packages_root, package, pattern)\n            for py3k_path in glob.glob(py3k_pattern):\n                py2k_path = os.path.join(py2k_dir, py3k_path)\n                py2k_dirname = os.path.dirname(py2k_path)\n                if not os.path.isdir(py2k_dirname):\n                    os.makedirs(py2k_dirname)\n                copy_data(py3k_path, py2k_path)\n\n    if copied_py_files:\n        copied_py_files.sort()\n        try:\n            run_3to2(copied_py_files)\n            write_py2k_header(copied_py_files)\n        except:\n            shutil.rmtree(py2k_dir)\n            raise\n\n    if run_tests:\n        for script in test_scripts:\n            subprocess.check_call([script])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_default_if():\n    f = open ('/proc/net/route', 'r')\n    for line in f:\n        words = line.split()\n        dest = words[1]\n        try:\n            if (int (dest) == 0):\n                interf = words[0]\n                break\n        except ValueError:\n            pass\n    return interf", "response": "Returns the default interface if the route is not set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_default_gw():\n    octet_list = []\n    gw_from_route = None\n    f = open ('/proc/net/route', 'r')\n    for line in f:\n        words = line.split()\n        dest = words[1]\n        try:\n            if (int (dest) == 0):\n                gw_from_route = words[2]\n                break\n        except ValueError:\n            pass\n        \n    if not gw_from_route:\n        return None \n    \n    for i in range(8, 1, -2):\n        octet = gw_from_route[i-2:i]\n        octet = int(octet, 16)\n        octet_list.append(str(octet)) \n    \n    gw_ip = \".\".join(octet_list)\n            \n    return gw_ip", "response": "Returns the default gateway"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the module instance of the GraphiteClient.", "response": "def init(init_type='plaintext_tcp', *args, **kwargs):\n    \"\"\"\n    Create the module instance of the GraphiteClient.\n    \"\"\"\n    global _module_instance\n    reset()\n\n    validate_init_types = ['plaintext_tcp', 'plaintext', 'pickle_tcp',\n                           'pickle', 'plain']\n\n    if init_type not in validate_init_types:\n        raise GraphiteSendException(\n            \"Invalid init_type '%s', must be one of: %s\" %\n            (init_type, \", \".join(validate_init_types)))\n\n    # Use TCP to send data to the plain text receiver on the graphite server.\n    if init_type in ['plaintext_tcp', 'plaintext', 'plain']:\n        _module_instance = GraphiteClient(*args, **kwargs)\n\n    # Use TCP to send pickled data to the pickle receiver on the graphite\n    # server.\n    if init_type in ['pickle_tcp', 'pickle']:\n        _module_instance = GraphitePickleClient(*args, **kwargs)\n\n    return _module_instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend the metrics to the graphite server.", "response": "def send(*args, **kwargs):\n    \"\"\" Make sure that we have an instance of the GraphiteClient.\n    Then send the metrics to the graphite server.\n    User consumable method.\n    \"\"\"\n    if not _module_instance:\n        raise GraphiteSendException(\n            \"Must call graphitesend.init() before sending\")\n\n    _module_instance.send(*args, **kwargs)\n    return _module_instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_dict(*args, **kwargs):\n    if not _module_instance:\n        raise GraphiteSendException(\n            \"Must call graphitesend.init() before sending\")\n    _module_instance.send_dict(*args, **kwargs)\n    return _module_instance", "response": "Send the metrics to the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_list(*args, **kwargs):\n    if not _module_instance:\n        raise GraphiteSendException(\n            \"Must call graphitesend.init() before sending\")\n    _module_instance.send_list(*args, **kwargs)\n    return _module_instance", "response": "Send a list of metrics to the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nallow the module to be called from the cli.", "response": "def cli():\n    \"\"\" Allow the module to be called from the cli. \"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(description='Send data to graphite')\n\n    # Core of the application is to accept a metric and a value.\n    parser.add_argument('metric', metavar='metric', type=str,\n                        help='name.of.metric')\n    parser.add_argument('value', metavar='value', type=int,\n                        help='value of metric as int')\n\n    args = parser.parse_args()\n    metric = args.metric\n    value = args.value\n\n    graphitesend_instance = init()\n    graphitesend_instance.send(metric, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        self.socket = socket.socket()\n        self.socket.settimeout(self.timeout_in_seconds)\n        try:\n            self.socket.connect(self.addr)\n        except socket.timeout:\n            raise GraphiteSendException(\n                \"Took over %d second(s) to connect to %s\" %\n                (self.timeout_in_seconds, self.addr))\n        except socket.gaierror:\n            raise GraphiteSendException(\n                \"No address associated with hostname %s:%s\" % self.addr)\n        except Exception as error:\n            raise GraphiteSendException(\n                \"unknown exception while connecting to %s - %s\" %\n                (self.addr, error)\n            )\n\n        return self.socket", "response": "Connect to the graphite server and return a socket object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef autoreconnect(self, sleep=1, attempt=3, exponential=True, jitter=5):\n\n        p = 0\n\n        while attempt is None or attempt > 0:\n            try:\n                self.reconnect()\n                return True\n            except GraphiteSendException:\n\n                if exponential:\n                    p += 1\n                    time.sleep(pow(sleep, p) + random.randint(1, jitter))\n                else:\n                    time.sleep(sleep)\n\n                attempt -= 1\n\n        return False", "response": "Attempts to reconnect with some delay between two attempts and exponential growing sleep seconds between two attempts each try\n        exponential = False will attempt to reconnect with some delay in range 1.. jitter 5 will attempt to reconnect with some delay"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef disconnect(self):\n        try:\n            self.socket.shutdown(1)\n\n        # If its currently a socket, set it to None\n        except AttributeError:\n            self.socket = None\n        except Exception:\n            self.socket = None\n\n        # Set the self.socket to None, no matter what.\n        finally:\n            self.socket = None", "response": "Disconnects from the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dispatch_send(self, message):\n\n        if self.dryrun:\n            return message\n\n        if not self.socket:\n            raise GraphiteSendException(\n                \"Socket was not created before send\"\n            )\n\n        sending_function = self._send\n        if self._autoreconnect:\n            sending_function = self._send_and_reconnect\n\n        try:\n            if self.asynchronous and gevent:\n                gevent.spawn(sending_function, message)\n            else:\n                sending_function(message)\n        except Exception as e:\n            self._handle_send_error(e)\n\n        return \"sent {0} long message: {1}\".format(len(message), message[:75])", "response": "Dispatch the different steps of sending to the specified message"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends _message_ to Graphite Server and attempt to reconnect on failure.", "response": "def _send_and_reconnect(self, message):\n        \"\"\"Send _message_ to Graphite Server and attempt reconnect on failure.\n\n        If _autoreconnect_ was specified, attempt to reconnect if first send\n        fails.\n\n        :raises AttributeError: When the socket has not been set.\n        :raises socket.error: When the socket connection is no longer valid.\n        \"\"\"\n        try:\n            self.socket.sendall(message.encode(\"ascii\"))\n        except (AttributeError, socket.error):\n            if not self.autoreconnect():\n                raise\n            else:\n                self.socket.sendall(message.encode(\"ascii\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(self, metric, value, timestamp=None, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n        message = formatter(metric, value, timestamp)\n        message = self. _presend(message)\n        return self._dispatch_send(message)", "response": "Format a single metric value pair and send it to the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_dict(self, data, timestamp=None, formatter=None):\n        if formatter is None:\n            formatter = self.formatter\n\n        metric_list = []\n\n        for metric, value in data.items():\n            tmp_message = formatter(metric, value, timestamp)\n            metric_list.append(tmp_message)\n\n        message = \"\".join(metric_list)\n        return self._dispatch_send(message)", "response": "Format a dict of metric name and value pairs and send them all to the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if socket has been monkey patched by gevent and if so enable asynchronous mode.", "response": "def enable_asynchronous(self):\n        \"\"\"Check if socket have been monkey patched by gevent\"\"\"\n\n        def is_monkey_patched():\n            try:\n                from gevent import monkey, socket\n            except ImportError:\n                return False\n            if hasattr(monkey, \"saved\"):\n                return \"socket\" in monkey.saved\n            return gevent.socket.socket == socket.socket\n\n        if not is_monkey_patched():\n            raise Exception(\"To activate asynchonoucity, please monkey patch\"\n                            \" the socket module with gevent\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef str2listtuple(self, string_message):\n        \"Covert a string that is ready to be sent to graphite into a tuple\"\n\n        if type(string_message).__name__ not in ('str', 'unicode'):\n            raise TypeError(\"Must provide a string or unicode\")\n\n        if not string_message.endswith('\\n'):\n            string_message += \"\\n\"\n\n        tpl_list = []\n        for line in string_message.split('\\n'):\n            line = line.strip()\n            if not line:\n                continue\n            path, metric, timestamp = (None, None, None)\n            try:\n                (path, metric, timestamp) = line.split()\n            except ValueError:\n                raise ValueError(\n                    \"message must contain - metric_name, value and timestamp '%s'\"\n                    % line)\n            try:\n                timestamp = float(timestamp)\n            except ValueError:\n                raise ValueError(\"Timestamp must be float or int\")\n\n            tpl_list.append((path, (timestamp, metric)))\n\n        if len(tpl_list) == 0:\n            raise GraphiteSendException(\"No messages to send\")\n\n        payload = pickle.dumps(tpl_list)\n        header = struct.pack(\"!L\", len(payload))\n        message = header + payload\n\n        return message", "response": "Covert a string that is ready to be sent to graphite into a tuple"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _send(self, message):\n\n        # An option to lowercase the entire message\n        if self.lowercase_metric_names:\n            message = message.lower()\n\n        # convert the message into a pickled payload.\n        message = self.str2listtuple(message)\n\n        try:\n            self.socket.sendall(message)\n        # Capture missing socket.\n        except socket.gaierror as error:\n            raise GraphiteSendException(\n                \"Failed to send data to %s, with error: %s\" %\n                (self.addr, error))  # noqa\n\n        # Capture socket closure before send.\n        except socket.error as error:\n            raise GraphiteSendException(\n                \"Socket closed before able to send data to %s, \"\n                \"with error: %s\" %\n                (self.addr, error))  # noqa\n\n        except Exception as error:\n            raise GraphiteSendException(\n                \"Unknown error while trying to send data down socket to %s, \"\n                \"error: %s\" %\n                (self.addr, error))  # noqa\n\n        return \"sent %d long pickled message\" % len(message)", "response": "Given a message send it to the graphite server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean_metric_name(self, metric_name):\n        if not self._clean_metric_name:\n            return metric_name\n        metric_name = str(metric_name)\n        for _from, _to in self.cleaning_replacement_list:\n            metric_name = metric_name.replace(_from, _to)\n        return metric_name", "response": "Clean the metric name to remove any characters that are not free of control chars spaces tabs etc."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_languages(cls) -> set:\n        if not cls._server_is_alive():\n            cls._start_server_on_free_port()\n        url = urllib.parse.urljoin(cls._url, 'Languages')\n        languages = set()\n        for e in cls._get_root(url, num_tries=1):\n            languages.add(e.get('abbr'))\n            languages.add(e.get('abbrWithVariant'))\n        return languages", "response": "Get supported languages by querying the server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget matches element attributes.", "response": "def _get_attrib(cls):\n        \"\"\"Get matches element attributes.\"\"\"\n        if not cls._server_is_alive():\n            cls._start_server_on_free_port()\n        params = {'language': FAILSAFE_LANGUAGE, 'text': ''}\n        data = urllib.parse.urlencode(params).encode()\n        root = cls._get_root(cls._url, data, num_tries=1)\n        return root.attrib"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npatches method for PageAdmin. get_form.", "response": "def get_form(self, request, obj=None, **kwargs):\n    \"\"\"\n    Patched method for PageAdmin.get_form.\n\n    Returns a page form without the base field 'meta_description' which is\n    overridden in djangocms-page-meta.\n\n    This is triggered in the page add view and in the change view if\n    the meta description of the page is empty.\n    \"\"\"\n    language = get_language_from_request(request, obj)\n    form = _BASE_PAGEADMIN__GET_FORM(self, request, obj, **kwargs)\n    if not obj or not obj.get_meta_description(language=language):\n        form.base_fields.pop('meta_description', None)\n\n    return form"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the cache key for the current page and language", "response": "def get_cache_key(page, language):\n    \"\"\"\n    Create the cache key for the current page and language\n    \"\"\"\n    from cms.cache import _get_cache_key\n    try:\n        site_id = page.node.site_id\n    except AttributeError:  # CMS_3_4\n        site_id = page.site_id\n    return _get_cache_key('page_meta', page, language, site_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_page_meta(page, language):\n    from django.core.cache import cache\n    from meta.views import Meta\n    from .models import PageMeta, TitleMeta\n\n    try:\n        meta_key = get_cache_key(page, language)\n    except AttributeError:\n        return None\n    gplus_server = 'https://plus.google.com'\n    meta = cache.get(meta_key)\n    if not meta:\n        meta = Meta()\n        title = page.get_title_obj(language)\n        meta.extra_custom_props = []\n\n        meta.title = page.get_page_title(language)\n        if not meta.title:\n            meta.title = page.get_title(language)\n\n        if title.meta_description:\n            meta.description = title.meta_description.strip()\n        try:\n            titlemeta = title.titlemeta\n            if titlemeta.description:\n                meta.description = titlemeta.description.strip()\n            if titlemeta.keywords:\n                meta.keywords = titlemeta.keywords.strip().split(',')\n            meta.locale = titlemeta.locale\n            meta.og_description = titlemeta.og_description.strip()\n            if not meta.og_description:\n                meta.og_description = meta.description\n            meta.twitter_description = titlemeta.twitter_description.strip()\n            if not meta.twitter_description:\n                meta.twitter_description = meta.description\n            meta.gplus_description = titlemeta.gplus_description.strip()\n            if not meta.gplus_description:\n                meta.gplus_description = meta.description\n            if titlemeta.image:\n                meta.image = title.titlemeta.image.canonical_url or title.titlemeta.image.url\n            for item in titlemeta.extra.all():\n                attribute = item.attribute\n                if not attribute:\n                    attribute = item.DEFAULT_ATTRIBUTE\n                meta.extra_custom_props.append((attribute, item.name, item.value))\n        except (TitleMeta.DoesNotExist, AttributeError):\n            # Skipping title-level metas\n            if meta.description:\n                meta.og_description = meta.description\n                meta.twitter_description = meta.description\n                meta.gplus_description = meta.description\n        defaults = {\n            'object_type': meta_settings.FB_TYPE,\n            'og_type': meta_settings.FB_TYPE,\n            'og_app_id': meta_settings.FB_APPID,\n            'fb_pages': meta_settings.FB_PAGES,\n            'og_profile_id': meta_settings.FB_PROFILE_ID,\n            'og_publisher': meta_settings.FB_PUBLISHER,\n            'og_author_url': meta_settings.FB_AUTHOR_URL,\n            'twitter_type': meta_settings.TWITTER_TYPE,\n            'twitter_site': meta_settings.TWITTER_SITE,\n            'twitter_author': meta_settings.TWITTER_AUTHOR,\n            'gplus_type': meta_settings.GPLUS_TYPE,\n            'gplus_author': meta_settings.GPLUS_AUTHOR,\n        }\n        try:\n            pagemeta = page.pagemeta\n            meta.object_type = pagemeta.og_type\n            meta.og_type = pagemeta.og_type\n            meta.og_app_id = pagemeta.og_app_id\n            meta.fb_pages = pagemeta.fb_pages\n            meta.og_profile_id = pagemeta.og_author_fbid\n            meta.twitter_type = pagemeta.twitter_type\n            meta.twitter_site = pagemeta.twitter_site\n            meta.twitter_author = pagemeta.twitter_author\n            meta.gplus_type = pagemeta.gplus_type\n            meta.gplus_author = pagemeta.gplus_author\n            if meta.og_type == 'article':\n                meta.og_publisher = pagemeta.og_publisher\n                meta.og_author_url = pagemeta.og_author_url\n                try:\n                    from djangocms_page_tags.utils import get_title_tags, get_page_tags\n                    tags = list(get_title_tags(page, language))\n                    tags += list(get_page_tags(page))\n                    meta.tag = ','.join([tag.name for tag in tags])\n                except ImportError:\n                    # djangocms-page-tags not available\n                    pass\n            if not meta.image and pagemeta.image:\n                meta.image = pagemeta.image.canonical_url or pagemeta.image.url\n            for item in pagemeta.extra.all():\n                attribute = item.attribute\n                if not attribute:\n                    attribute = item.DEFAULT_ATTRIBUTE\n                meta.extra_custom_props.append((attribute, item.name, item.value))\n        except PageMeta.DoesNotExist:\n            pass\n        if meta.gplus_author and not meta.gplus_author.startswith('http'):\n            if not meta.gplus_author.startswith('/'):\n                meta.gplus_author = '{0}/{1}'.format(gplus_server, meta.gplus_author)\n            else:\n                meta.gplus_author = '{0}{1}'.format(gplus_server, meta.gplus_author)\n        if page.publication_date:\n            meta.published_time = page.publication_date.isoformat()\n        if page.changed_date:\n            meta.modified_time = page.changed_date.isoformat()\n        if page.publication_end_date:\n            meta.expiration_time = page.publication_end_date.isoformat()\n        for attr, val in defaults.items():\n            if not getattr(meta, attr, '') and val:\n                setattr(meta, attr, val)\n        meta.url = page.get_absolute_url(language)\n    return meta", "response": "Returns all the meta information for the given page in the given language."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef begin(self, address=MPR121_I2CADDR_DEFAULT, i2c=None, **kwargs):\n        # Assume we're using platform's default I2C bus if none is specified.\n        if i2c is None:\n            import Adafruit_GPIO.I2C as I2C\n            i2c = I2C\n            # Require repeated start conditions for I2C register reads.  Unfortunately\n            # the MPR121 is very sensitive and requires repeated starts to read all\n            # the registers.\n            I2C.require_repeated_start()\n        # Save a reference to the I2C device instance for later communication.\n        self._device = i2c.get_i2c_device(address, **kwargs)\n        return self._reset()", "response": "Initialize communication with the MPR121. \n\n        Can specify a custom I2C address for the device using the address \n        parameter (defaults to 0x5A). Optional i2c parameter allows specifying a \n        custom I2C bus source (defaults to platform's I2C bus).\n\n        Returns True if communication with the MPR121 was established, otherwise\n        returns False."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_thresholds(self, touch, release):\n        assert touch >= 0 and touch <= 255, 'touch must be between 0-255 (inclusive)'\n        assert release >= 0 and release <= 255, 'release must be between 0-255 (inclusive)'\n        # Set the touch and release register value for all the inputs.\n        for i in range(12):\n            self._i2c_retry(self._device.write8, MPR121_TOUCHTH_0 + 2*i, touch)\n            self._i2c_retry(self._device.write8, MPR121_RELEASETH_0 + 2*i, release)", "response": "Set the touch and release threshold for all inputs to the provided\n        values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filtered_data(self, pin):\n        assert pin >= 0 and pin < 12, 'pin must be between 0-11 (inclusive)'\n        return self._i2c_retry(self._device.readU16LE, MPR121_FILTDATA_0L + pin*2)", "response": "Return the value of the MPR121_FILTDATA register for the provided pin. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the baseline data register value for the provided pin. Useful for debugging.", "response": "def baseline_data(self, pin):\n        \"\"\"Return baseline data register value for the provided pin (0-11).\n        Useful for debugging.\n        \"\"\"\n        assert pin >= 0 and pin < 12, 'pin must be between 0-11 (inclusive)'\n        bl = self._i2c_retry(self._device.readU8, MPR121_BASELINE_0 + pin)\n        return bl << 2"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef touched(self):\n        t = self._i2c_retry(self._device.readU16LE, MPR121_TOUCHSTATUS_L)\n        return t & 0x0FFF", "response": "Return touch state of all pins as a 12 - bit value where each bit \n        represents a pin and 0 not being touched."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_touched(self, pin):\n        assert pin >= 0 and pin < 12, 'pin must be between 0-11 (inclusive)'\n        t = self.touched()\n        return (t & (1 << pin)) > 0", "response": "Returns True if the specified pin is being touched otherwise returns\n        False."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef profileit(func):\n    def wrapper(*args, **kwargs):\n        datafn = func.__name__ + \".profile\" # Name the data file sensibly\n        prof = cProfile.Profile()\n        prof.enable()\n        retval = prof.runcall(func, *args, **kwargs)\n        prof.disable()\n        stats = pstats.Stats(prof)\n        try:\n            stats.sort_stats('cumtime').print_stats()\n        except KeyError:\n            pass  # breaks in python 2.6\n        return retval\n\n    return wrapper", "response": "Decorator straight up stolen from stackoverflow\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a function that filters log lines by the provided IP range.", "response": "def filter_ip_range(ip_range):\n    \"\"\"Filter :class:`.Line` objects by IP range.\n\n    Both *192.168.1.203* and *192.168.1.10* are valid if the provided ip\n    range is ``192.168.1`` whereas *192.168.2.103* is not valid (note the\n    *.2.*).\n\n    :param ip_range: IP range that you want to filter to.\n    :type ip_range: string\n    :returns: a function that filters by the provided IP range.\n    :rtype: function\n    \"\"\"\n    def filter_func(log_line):\n        ip = log_line.get_ip()\n        if ip:\n            return ip.startswith(ip_range)\n\n    return filter_func"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters log lines by their response time.", "response": "def filter_slow_requests(slowness):\n    \"\"\"Filter :class:`.Line` objects by their response time.\n\n    :param slowness: minimum time, in milliseconds, a server needs to answer\n      a request. If the server takes more time than that the log line is\n      accepted.\n    :type slowness: string\n    :returns: a function that filters by the server response time.\n    :rtype: function\n    \"\"\"\n    def filter_func(log_line):\n        slowness_int = int(slowness)\n        return slowness_int <= log_line.time_wait_response\n\n    return filter_func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiltering out log lines that have a waiting time less than max_waiting time.", "response": "def filter_wait_on_queues(max_waiting):\n    \"\"\"Filter :class:`.Line` objects by their queueing time in\n    HAProxy.\n\n    :param max_waiting: maximum time, in milliseconds, a request is waiting on\n      HAProxy prior to be delivered to a backend server. If HAProxy takes less\n      than that time the log line is counted.\n    :type max_waiting: string\n    :returns: a function that filters by HAProxy queueing time.\n    :rtype: function\n    \"\"\"\n    def filter_func(log_line):\n        waiting = int(max_waiting)\n        return waiting >= log_line.time_wait_queues\n\n    return filter_func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_time_frame(start, delta):\n    start_value = start\n    delta_value = delta\n    end_value = None\n\n    if start_value is not '':\n        start_value = _date_str_to_datetime(start_value)\n\n    if delta_value is not '':\n        delta_value = _delta_str_to_timedelta(delta_value)\n\n    if start_value is not '' and delta_value is not '':\n        end_value = start_value + delta_value\n\n    def filter_func(log_line):\n        if start_value is '':\n            return True\n        elif start_value > log_line.accept_date:\n            return False\n\n        if end_value is None:\n            return True\n        elif end_value < log_line.accept_date:\n            return False\n\n        return True\n\n    return filter_func", "response": "Filter log lines by their connection time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter the log lines by the response size.", "response": "def filter_response_size(size):\n    \"\"\"Filter :class:`.Line` objects by the response size (in bytes).\n\n    Specially useful when looking for big file downloads.\n\n    :param size: Minimum amount of bytes a response body weighted.\n    :type size: string\n    :returns: a function that filters by the response size.\n    :rtype: function\n    \"\"\"\n    if size.startswith('+'):\n        size_value = int(size[1:])\n    else:\n        size_value = int(size)\n\n    def filter_func(log_line):\n        bytes_read = log_line.bytes_read\n        if bytes_read.startswith('+'):\n            bytes_read = int(bytes_read[1:])\n        else:\n            bytes_read = int(bytes_read)\n\n        return bytes_read >= size_value\n\n    return filter_func"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_fields_for_model(model):\n    fields = []\n    for name in model._sa_class_manager:\n        prop = getattr(model, name)\n        if isinstance(prop.property, RelationshipProperty):\n            for pk in prop.property.mapper.primary_key:\n                fields.append('{0}.{1}'.format(name, pk.name))\n        else:\n            fields.append(name)\n    return tuple(fields)", "response": "Gets all of the fields on the model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the necessary relationships for the resource by inspecting the SQLAlchemy ORM model for relationships.", "response": "def _get_relationships(model):\n    \"\"\"\n    Gets the necessary relationships for the resource\n    by inspecting the sqlalchemy model for relationships.\n\n    :param DeclarativeMeta model: The SQLAlchemy ORM model.\n    :return: A tuple of Relationship/ListRelationship instances\n        corresponding to the relationships on the Model.\n    :rtype: tuple\n    \"\"\"\n    relationships = []\n    for name, relationship in inspect(model).relationships.items():\n        class_ = relationship.mapper.class_\n        if relationship.uselist:\n            rel = ListRelationship(name, relation=class_.__name__)\n        else:\n            rel = Relationship(name, relation=class_.__name__)\n        relationships.append(rel)\n    return tuple(relationships)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_resource(model, session_handler, resource_bases=(CRUDL,),\n                    relationships=None, links=None, preprocessors=None,\n                    postprocessors=None, fields=None, paginate_by=100,\n                    auto_relationships=True, pks=None, create_fields=None,\n                    update_fields=None, list_fields=None, append_slash=False):\n        \"\"\"\n        Creates a ResourceBase subclass by inspecting a SQLAlchemy\n        Model. This is somewhat more restrictive than explicitly\n        creating managers and resources.  However, if you only need\n        any of the basic CRUD+L operations,\n\n        :param sqlalchemy.Model model:  This is the model that\n            will be inspected to create a Resource and Manager from.\n            By default, all of it's fields will be exposed, although\n            this can be overridden using the fields attribute.\n        :param tuple resource_bases: A tuple of ResourceBase subclasses.\n            Defaults to the restmixins.CRUDL class only.  However if you only\n            wanted Update and Delete you could pass in\n            ```(restmixins.Update,  restmixins.Delete)``` which\n            would cause the resource to inherit from those two.\n            Additionally, you could create your own mixins and pass them in\n            as the resource_bases\n        :param tuple relationships: extra relationships to pass\n            into the ResourceBase constructor.  If auto_relationships\n            is set to True, then they will be appended to these relationships.\n        :param tuple links: Extra links to pass into the ResourceBase as\n            the class _links attribute.  Defaults to an empty tuple.\n        :param tuple preprocessors: Preprocessors for the resource class attribute.\n        :param tuple postprocessors: Postprocessors for the resource class attribute.\n        :param ripozo_sqlalchemy.SessionHandler|ripozo_sqlalchemy.ScopedSessionHandler session_handler: A session handler\n            to use when instantiating an instance of the Manager class created\n            from the model.  This is responsible for getting and handling\n            sessions in both normal cases and exceptions.\n        :param tuple fields: The fields to expose on the api.  Defaults to\n            all of the fields on the model.\n        :param bool auto_relationships: If True, then the SQLAlchemy Model\n            will be inspected for relationships and they will be automatically\n            appended to the relationships on the resource class attribute.\n        :param list create_fields: A list of the fields that are valid when\n            creating a resource.  By default this will be the fields without\n            any primary keys included\n        :param list update_fields: A list of the fields that are valid when\n            updating a resource.  By default this will be the fields without\n            any primary keys included\n        :param list list_fields: A list of the fields that will be returned\n            when the list endpoint is requested.  Defaults to the fields\n            attribute.\n        :param bool append_slash: A flag to forcibly append slashes to\n            the end of urls.\n        :return: A ResourceBase subclass and AlchemyManager subclass\n        :rtype: ResourceMetaClass\n        \"\"\"\n        relationships = relationships or tuple()\n        if auto_relationships:\n            relationships += _get_relationships(model)\n        links = links or tuple()\n        preprocessors = preprocessors or tuple()\n        postprocessors = postprocessors or tuple()\n        pks = pks or _get_pks(model)\n        fields = fields or _get_fields_for_model(model)\n        list_fields = list_fields or fields\n\n        create_fields = create_fields or [x for x in fields if x not in set(pks)]\n        update_fields = update_fields or [x for x in fields if x not in set(pks)]\n\n        manager_cls_attrs = dict(paginate_by=paginate_by, fields=fields, model=model,\n                                 list_fields=list_fields, create_fields=create_fields,\n                                 update_fields=update_fields)\n        manager_class = type(str(model.__name__), (AlchemyManager,), manager_cls_attrs)\n        manager = manager_class(session_handler)\n\n        resource_cls_attrs = dict(preprocessors=preprocessors,\n                                  postprocessors=postprocessors,\n                                  _relationships=relationships, _links=links,\n                                  pks=pks, manager=manager, append_slash=append_slash)\n        res_class = ResourceMetaClass(str(model.__name__), resource_bases, resource_cls_attrs)\n        return res_class", "response": "Creates a new ResourceBase subclass from a SQLAlchemy model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_pickle_valid(self):\n        if not os.path.exists(self._pickle_file):\n            return False\n        else:\n            file_mtime = os.path.getmtime(self.logfile)\n            pickle_mtime = os.path.getmtime(self._pickle_file)\n            if file_mtime > pickle_mtime:\n                return False\n        return True", "response": "Logic to decide if the file should be processed or just needs to\n            be loaded from its pickle data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload data from a pickle file.", "response": "def _load(self):\n        \"\"\"Load data from a pickle file. \"\"\"\n        with open(self._pickle_file, 'rb') as source:\n            pickler = pickle.Unpickler(source)\n\n            for attribute in self._pickle_attributes:\n                pickle_data = pickler.load()\n                setattr(self, attribute, pickle_data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _save(self):\n        with open(self._pickle_file, 'wb') as source:\n            pickler = pickle.Pickler(source, pickle.HIGHEST_PROTOCOL)\n\n            for attribute in self._pickle_attributes:\n                attr = getattr(self, attribute, None)\n                pickler.dump(attr)", "response": "Save the attributes defined on _pickle_attributes in a pickle file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse data from data stream and replace object lines.", "response": "def parse_data(self, logfile):\n        \"\"\"Parse data from data stream and replace object lines.\n\n        :param logfile: [required] Log file data stream.\n        :type logfile: str\n        \"\"\"\n\n        for line in logfile:\n            stripped_line = line.strip()\n            parsed_line = Line(stripped_line)\n\n            if parsed_line.valid:\n                self._valid_lines.append(parsed_line)\n            else:\n                self._invalid_lines.append(stripped_line)\n        self.total_lines = len(self._valid_lines) + len(self._invalid_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering the log lines by a given function.", "response": "def filter(self, filter_func, reverse=False):\n        \"\"\"Filter current log lines by a given filter function.\n\n        This allows to drill down data out of the log file by filtering the\n        relevant log lines to analyze.\n\n        For example, filter by a given IP so only log lines for that IP are\n        further processed with commands (top paths, http status counter...).\n\n        :param filter_func: [required] Filter method, see filters.py for all\n          available filters.\n        :type filter_func: function\n        :param reverse: negate the filter (so accept all log lines that return\n          ``False``).\n        :type reverse: boolean\n        :returns: a new instance of Log containing only log lines\n          that passed the filter function.\n        :rtype: :class:`Log`\n        \"\"\"\n        new_log_file = Log()\n        new_log_file.logfile = self.logfile\n\n        new_log_file.total_lines = 0\n\n        new_log_file._valid_lines = []\n        new_log_file._invalid_lines = self._invalid_lines[:]\n\n        # add the reverse conditional outside the loop to keep the loop as\n        # straightforward as possible\n        if not reverse:\n            for i in self._valid_lines:\n                if filter_func(i):\n                    new_log_file.total_lines += 1\n                    new_log_file._valid_lines.append(i)\n        else:\n            for i in self._valid_lines:\n                if not filter_func(i):\n                    new_log_file.total_lines += 1\n                    new_log_file._valid_lines.append(i)\n\n        return new_log_file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef commands(cls):\n        cmds = [cmd[4:] for cmd in dir(cls) if cmd.startswith('cmd_')]\n        return cmds", "response": "Returns a list of all methods that start with cmd_."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_http_methods(self):\n        methods = defaultdict(int)\n        for line in self._valid_lines:\n            methods[line.http_request_method] += 1\n        return methods", "response": "Reports a breakdown of how many HTTP methods have been made per HTTPHTTPMethod."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreport a breakdown of how many requests have been made per IP.", "response": "def cmd_ip_counter(self):\n        \"\"\"Reports a breakdown of how many requests have been made per IP.\n\n        .. note::\n          To enable this command requests need to provide a header with the\n          forwarded IP (usually X-Forwarded-For) and be it the only header\n          being captured.\n        \"\"\"\n        ip_counter = defaultdict(int)\n        for line in self._valid_lines:\n            ip = line.get_ip()\n            if ip is not None:\n                ip_counter[ip] += 1\n        return ip_counter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_status_codes_counter(self):\n        status_codes = defaultdict(int)\n        for line in self._valid_lines:\n            status_codes[line.status_code] += 1\n        return status_codes", "response": "Generate statistics about HTTP status codes. 404 500 and so on."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate statistics about HTTP requests path.", "response": "def cmd_request_path_counter(self):\n        \"\"\"Generate statistics about HTTP requests' path.\"\"\"\n        paths = defaultdict(int)\n        for line in self._valid_lines:\n            paths[line.http_request_path] += 1\n        return paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_slow_requests(self):\n        slow_requests = [\n            line.time_wait_response\n            for line in self._valid_lines\n            if line.time_wait_response > 1000\n        ]\n        return slow_requests", "response": "List all requests that took a certain amount of time to be\n        processed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cmd_average_response_time(self):\n        average = [\n            line.time_wait_response\n            for line in self._valid_lines\n            if line.time_wait_response >= 0\n        ]\n\n        divisor = float(len(average))\n        if divisor > 0:\n            return sum(average) / float(len(average))\n        return 0", "response": "Returns the average response time of all non aborted requests."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the average queue time of all non aborted requests.", "response": "def cmd_average_waiting_time(self):\n        \"\"\"Returns the average queue time of all, non aborted, requests.\"\"\"\n        average = [\n            line.time_wait_queues\n            for line in self._valid_lines\n            if line.time_wait_queues >= 0\n        ]\n\n        divisor = float(len(average))\n        if divisor > 0:\n            return sum(average) / float(len(average))\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating statistics regarding how many requests were processed by each downstream server.", "response": "def cmd_server_load(self):\n        \"\"\"Generate statistics regarding how many requests were processed by\n        each downstream server.\n        \"\"\"\n        servers = defaultdict(int)\n        for line in self._valid_lines:\n            servers[line.server_name] += 1\n        return servers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmd_queue_peaks(self):\n        threshold = 1\n        peaks = []\n        current_peak = 0\n        current_queue = 0\n\n        current_span = 0\n        first_on_queue = None\n\n        for line in self._valid_lines:\n            current_queue = line.queue_backend\n\n            if current_queue > 0:\n                current_span += 1\n\n                if first_on_queue is None:\n                    first_on_queue = line.accept_date\n\n            if current_queue == 0 and current_peak > threshold:\n                data = {\n                    'peak': current_peak,\n                    'span': current_span,\n                    'first': first_on_queue,\n                    'last': line.accept_date,\n                }\n                peaks.append(data)\n                current_peak = 0\n                current_span = 0\n                first_on_queue = None\n\n            if current_queue > current_peak:\n                current_peak = current_queue\n\n        # case of a series that does not end\n        if current_queue > 0 and current_peak > threshold:\n            data = {\n                'peak': current_peak,\n                'span': current_span,\n                'first': first_on_queue,\n                'last': line.accept_date,\n            }\n            peaks.append(data)\n\n        return peaks", "response": "Generate a list of the requests peaks on the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating statistics on how many requests are made via HTTP and how many requests are made via SSL.", "response": "def cmd_connection_type(self):\n        \"\"\"Generates statistics on how many requests are made via HTTP and how\n        many are made via SSL.\n\n        .. note::\n          This only works if the request path contains the default port for\n          SSL (443).\n\n        .. warning::\n          The ports are hardcoded, they should be configurable.\n        \"\"\"\n        https = 0\n        non_https = 0\n        for line in self._valid_lines:\n            if line.is_https():\n                https += 1\n            else:\n                non_https += 1\n        return https, non_https"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_requests_per_minute(self):\n        if len(self._valid_lines) == 0:\n            return\n\n        current_minute = self._valid_lines[0].accept_date\n        current_minute_counter = 0\n        requests = []\n        one_minute = timedelta(minutes=1)\n\n        def format_and_append(append_to, date, counter):\n            seconds_and_micro = timedelta(\n                seconds=date.second,\n                microseconds=date.microsecond,\n            )\n            minute_formatted = date - seconds_and_micro\n            append_to.append((minute_formatted, counter))\n\n        # note that _valid_lines is kept sorted by date\n        for line in self._valid_lines:\n            line_date = line.accept_date\n            if line_date - current_minute < one_minute and \\\n                    line_date.minute == current_minute.minute:\n                current_minute_counter += 1\n\n            else:\n                format_and_append(\n                    requests,\n                    current_minute,\n                    current_minute_counter,\n                )\n                current_minute_counter = 1\n                current_minute = line_date\n\n        if current_minute_counter > 0:\n            format_and_append(\n                requests,\n                current_minute,\n                current_minute_counter,\n            )\n\n        return requests", "response": "Generates statistics on how many requests were made per minute."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd_print(self):\n        if not self._valid_lines:\n            return ''\n        return '\\n'.join([line.raw_line for line in self._valid_lines]) + '\\n'", "response": "Returns the raw lines to be printed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting the log lines by the accept date.", "response": "def _sort_lines(self):\n        \"\"\"Haproxy writes its logs after having gathered all information\n        related to each specific connection. A simple request can be\n        really quick but others can be really slow, thus even if one connection\n        is logged later, it could have been accepted before others that are\n        already processed and logged.\n\n        This method sorts all valid log lines by their acceptance date,\n        providing the real order in which connections where made to the server.\n        \"\"\"\n        self._valid_lines = sorted(\n            self._valid_lines,\n            key=lambda line: line.accept_date,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsorting a dictionary with at least two fields on each of them sorting by the second element.", "response": "def _sort_and_trim(data, reverse=False):\n        \"\"\"Sorts a dictionary with at least two fields on each of them sorting\n        by the second element.\n\n        .. warning::\n          Right now is hardcoded to 10 elements, improve the command line\n          interface to allow to send parameters to each command or globally.\n        \"\"\"\n        threshold = 10\n        data_list = data.items()\n        data_list = sorted(\n            data_list,\n            key=lambda data_info: data_info[1],\n            reverse=reverse,\n        )\n        return data_list[:threshold]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap a function that actually accesses the database. It injects a session into the method and attempts to handle it after the function has run. :param method func: The method that is interacting with the database.", "response": "def db_access_point(func):\n    \"\"\"\n    Wraps a function that actually accesses the database.\n    It injects a session into the method and attempts to handle\n    it after the function has run.\n\n    :param method func: The method that is interacting with the database.\n    \"\"\"\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        \"\"\"\n        Wrapper responsible for handling\n        sessions\n        \"\"\"\n        session = self.session_handler.get_session()\n        try:\n            resp = func(self, session, *args, **kwargs)\n        except Exception as exc:\n            self.session_handler.handle_session(session, exc=exc)\n            raise exc\n        else:\n            self.session_handler.handle_session(session)\n            return resp\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the python type of the column with the given name.", "response": "def _get_field_python_type(model, name):\n        \"\"\"\n        Gets the python type for the attribute on the model\n        with the name provided.\n\n        :param Model model: The SqlAlchemy model class.\n        :param unicode name: The column name on the model\n            that you are attempting to get the python type.\n        :return: The python type of the column\n        :rtype: type\n        \"\"\"\n        try:\n            return getattr(model, name).property.columns[0].type.python_type\n        except AttributeError:  # It's a relationship\n            parts = name.split('.')\n            model = getattr(model, parts.pop(0)).comparator.mapper.class_\n            return AlchemyManager._get_field_python_type(model, '.'.join(parts))\n        except NotImplementedError:\n            # This is for pickle type columns.\n            return object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a field name and returns an appropriate BaseField instance for that column.", "response": "def get_field_type(cls, name):\n        \"\"\"\n        Takes a field name and gets an appropriate BaseField instance\n        for that column.  It inspects the Model that is set on the manager\n        to determine what the BaseField subclass should be.\n\n        :param unicode name:\n        :return: A BaseField subclass that is appropriate for\n            translating a string input into the appropriate format.\n        :rtype: ripozo.viewsets.fields.base.BaseField\n        \"\"\"\n        python_type = cls._get_field_python_type(cls.model, name)\n        if python_type in _COLUMN_FIELD_MAP:\n            field_class = _COLUMN_FIELD_MAP[python_type]\n            return field_class(name)\n        return BaseField(name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new instance of the self. model and persists it to the database.", "response": "def create(self, session, values, *args, **kwargs):\n        \"\"\"\n        Creates a new instance of the self.model\n        and persists it to the database.\n\n        :param dict values: The dictionary of values to\n            set on the model.  The key is the column name\n            and the value is what it will be set to.  If\n            the cls._create_fields is defined then it will\n            use those fields.  Otherwise, it will use the\n            fields defined in cls.fields\n        :param Session session: The sqlalchemy session\n        :return: The serialized model.  It will use the self.fields\n            attribute for this.\n        :rtype: dict\n        \"\"\"\n        model = self.model()\n        model = self._set_values_on_model(model, values, fields=self.create_fields)\n        session.add(model)\n        session.commit()\n        return self.serialize_model(model)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retrieve(self, session, lookup_keys, *args, **kwargs):\n        model = self._get_model(lookup_keys, session)\n        return self.serialize_model(model)", "response": "Retrieves a model using the lookup keys provided."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a list of the models for this manager.", "response": "def retrieve_list(self, session, filters, *args, **kwargs):\n        \"\"\"\n        Retrieves a list of the model for this manager.\n        It is restricted by the filters provided.\n\n        :param Session session: The SQLAlchemy session to use\n        :param dict filters: The filters to restrict the returned\n            models on\n        :return: A tuple of the list of dictionary representation\n            of the models and the dictionary of meta data\n        :rtype: list, dict\n        \"\"\"\n        query = self.queryset(session)\n        translator = IntegerField('tmp')\n        pagination_count = translator.translate(\n            filters.pop(self.pagination_count_query_arg, self.paginate_by)\n        )\n        pagination_pk = translator.translate(\n            filters.pop(self.pagination_pk_query_arg, 1)\n        )\n        pagination_pk -= 1  # logic works zero based. Pagination shouldn't be though\n\n        query = query.filter_by(**filters)\n\n        if pagination_pk:\n            query = query.offset(pagination_pk * pagination_count)\n        if pagination_count:\n            query = query.limit(pagination_count + 1)\n\n        count = query.count()\n        next_link = None\n        previous_link = None\n        if count > pagination_count:\n            next_link = {self.pagination_pk_query_arg: pagination_pk + 2,\n                         self.pagination_count_query_arg: pagination_count}\n        if pagination_pk > 0:\n            previous_link = {self.pagination_pk_query_arg: pagination_pk,\n                             self.pagination_count_query_arg: pagination_count}\n\n        field_dict = self.dot_field_list_to_dict(self.list_fields)\n        props = self.serialize_model(query[:pagination_count], field_dict=field_dict)\n        meta = dict(links=dict(next=next_link, previous=previous_link))\n        return props, meta"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the model with the specified lookup_keys and returns the dictified object.", "response": "def update(self, session, lookup_keys, updates, *args, **kwargs):\n        \"\"\"\n        Updates the model with the specified lookup_keys and returns\n        the dictified object.\n\n        :param Session session: The SQLAlchemy session to use\n        :param dict lookup_keys: A dictionary mapping the fields\n            and their expected values\n        :param dict updates: The columns and the values to update\n            them to.\n        :return: The dictionary of keys and values for the retrieved\n            model.  The only values returned will be those specified by\n            fields attrbute on the class\n        :rtype: dict\n        :raises: NotFoundException\n        \"\"\"\n        model = self._get_model(lookup_keys, session)\n        model = self._set_values_on_model(model, updates, fields=self.update_fields)\n        session.commit()\n        return self.serialize_model(model)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self, session, lookup_keys, *args, **kwargs):\n        model = self._get_model(lookup_keys, session)\n        session.delete(model)\n        session.commit()\n        return {}", "response": "Deletes the model found using the lookup_keys\n            and returns the deleted dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize_model(self, model, field_dict=None):\n        response = self._serialize_model_helper(model, field_dict=field_dict)\n        return make_json_safe(response)", "response": "Takes a model and serializes the fields provided into\n        a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_model(self, lookup_keys, session):\n        try:\n            return self.queryset(session).filter_by(**lookup_keys).one()\n        except NoResultFound:\n            raise NotFoundException('No model of type {0} was found using '\n                                    'lookup_keys {1}'.format(self.model.__name__, lookup_keys))", "response": "Gets the sqlalchemy Model instance associated with the given lookup keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_values_on_model(self, model, values, fields=None):\n        fields = fields or self.fields\n        for name, val in six.iteritems(values):\n            if name not in fields:\n                continue\n            setattr(model, name, val)\n        return model", "response": "Updates the values of the model instance with the specified values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting all available commands from the Log with their ridge description.", "response": "def print_commands():\n    \"\"\"Prints all commands available from Log with their\n    description.\n    \"\"\"\n    dummy_log_file = Log()\n    commands = Log.commands()\n    commands.sort()\n\n    for cmd in commands:\n        cmd = getattr(dummy_log_file, 'cmd_{0}'.format(cmd))\n        description = cmd.__doc__\n        if description:\n            description = re.sub(r'\\n\\s+', ' ', description)\n            description = description.strip()\n\n        print('{0}: {1}\\n'.format(cmd.__name__, description))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_filters():\n    for filter_name in VALID_FILTERS:\n        filter_func = getattr(filters, 'filter_{0}'.format(filter_name))\n        description = filter_func.__doc__\n        if description:\n            description = re.sub(r'\\n\\s+', ' ', description)\n            description.strip()\n\n        print('{0}: {1}\\n'.format(filter_name, description))", "response": "Prints all filters available with their description."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_observer(self, observer):\n        if not isinstance(observer, PowerManagementObserver):\n            raise TypeError(\"observer MUST conform to power.PowerManagementObserver\")\n        self._weak_observers.append(weakref.ref(observer))", "response": "Adds an observer to the list of observers that can be used to manage the current time - of - day."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves all registered observers.", "response": "def remove_all_observers(self):\n        \"\"\"\n        Removes all registered observers.\n        \"\"\"\n        for weak_observer in self._weak_observers:\n            observer = weak_observer()\n            if observer:\n                self.remove_observer(observer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nspawning new NSThread to handle notifications.", "response": "def startThread(self):\n        \"\"\"Spawns new NSThread to handle notifications.\"\"\"\n        if self._thread is not None:\n            return\n        self._thread = NSThread.alloc().initWithTarget_selector_object_(self, 'runPowerNotificationsThread', None)\n        self._thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef runPowerNotificationsThread(self):\n        pool = NSAutoreleasePool.alloc().init()\n\n        @objc.callbackFor(IOPSNotificationCreateRunLoopSource)\n        def on_power_source_notification(context):\n            with self._lock:\n                for weak_observer in self._weak_observers:\n                    observer = weak_observer()\n                    if observer:\n                        observer.on_power_source_notification()\n\n        self._source = IOPSNotificationCreateRunLoopSource(on_power_source_notification, None)\n        CFRunLoopAddSource(NSRunLoop.currentRunLoop().getCFRunLoop(), self._source, kCFRunLoopDefaultMode)\n        while not NSThread.currentThread().isCancelled():\n            NSRunLoop.currentRunLoop().runMode_beforeDate_(NSDefaultRunLoopMode, NSDate.distantFuture())\n        del pool", "response": "Registers run loop source and runs current NSRunLoop."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stopPowerNotificationsThread(self):\n        assert NSThread.currentThread() == self._thread\n\n        CFRunLoopSourceInvalidate(self._source)\n        self._source = None\n        NSThread.currentThread().cancel()", "response": "Removes the only source from NSRunLoop and cancels thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addObserver(self, observer):\n        with self._lock:\n            self._weak_observers.append(weakref.ref(observer))\n            if len(self._weak_observers) == 1:\n                self.startThread()", "response": "Adds an observer to the list of observers that implement on_power_source_notification."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef removeObserver(self, observer):\n        with self._lock:\n            self._weak_observers.remove(weakref.ref(observer))\n            if len(self._weak_observers) == 0:\n                self.stopThread()", "response": "Removes an observer from the list of observers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_power_source_notification(self):\n        for weak_observer in self._weak_observers:\n            observer = weak_observer()\n            if observer:\n                observer.on_power_sources_change(self)\n                observer.on_time_remaining_change(self)", "response": "Called in response to IOPSNotificationCreateRunLoopSource event."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the time remaining estimate of the current system.", "response": "def get_time_remaining_estimate(self):\n        \"\"\"\n        In Mac OS X 10.7+\n        Uses IOPSGetTimeRemainingEstimate to get time remaining estimate.\n\n        In Mac OS X 10.6\n        IOPSGetTimeRemainingEstimate is not available.\n        If providing power source type is AC, returns TIME_REMAINING_UNLIMITED.\n        Otherwise looks through all power sources returned by IOPSGetProvidingPowerSourceType\n        and returns total estimate.\n        \"\"\"\n        if IOPSGetTimeRemainingEstimate is not None: # Mac OS X 10.7+\n            estimate = float(IOPSGetTimeRemainingEstimate())\n            if estimate == -1.0:\n                return common.TIME_REMAINING_UNKNOWN\n            elif estimate == -2.0:\n                return common.TIME_REMAINING_UNLIMITED\n            else:\n                return estimate / 60.0\n        else: # Mac OS X 10.6\n            warnings.warn(\"IOPSGetTimeRemainingEstimate is not preset\", RuntimeWarning)\n            blob = IOPSCopyPowerSourcesInfo()\n            type = IOPSGetProvidingPowerSourceType(blob)\n            if type == common.POWER_TYPE_AC:\n                return common.TIME_REMAINING_UNLIMITED\n            else:\n                estimate = 0.0\n                for source in IOPSCopyPowerSourcesList(blob):\n                    description = IOPSGetPowerSourceDescription(blob, source)\n                    if kIOPSIsPresentKey in description and description[kIOPSIsPresentKey] and kIOPSTimeToEmptyKey in description and description[kIOPSTimeToEmptyKey] > 0.0:\n                        estimate += float(description[kIOPSTimeToEmptyKey])\n                if estimate > 0.0:\n                    return float(estimate)\n                else:\n                    return common.TIME_REMAINING_UNKNOWN"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_observer(self, observer):\n        super(PowerManagement, self).add_observer(observer)\n        if len(self._weak_observers) == 1:\n            if not self._cf_run_loop:\n                PowerManagement.notifications_observer.addObserver(self)\n            else:\n                @objc.callbackFor(IOPSNotificationCreateRunLoopSource)\n                def on_power_sources_change(context):\n                    self.on_power_source_notification()\n\n                self._source = IOPSNotificationCreateRunLoopSource(on_power_sources_change, None)\n                CFRunLoopAddSource(self._cf_run_loop, self._source, kCFRunLoopDefaultMode)", "response": "Adds an observer to the list of observers that are added to the main CFRunLoop."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_observer(self, observer):\n        super(PowerManagement, self).remove_observer(observer)\n        if len(self._weak_observers) == 0:\n            if not self._cf_run_loop:\n                PowerManagement.notifications_observer.removeObserver(self)\n            else:\n                CFRunLoopSourceInvalidate(self._source)\n                self._source = None", "response": "Removes an observer from the list of observers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the type of power source that the system is currently using.", "response": "def get_providing_power_source_type(self):\n        \"\"\"\n        Returns GetSystemPowerStatus().ACLineStatus\n\n        @raise: WindowsError if any underlying error occures.\n        \"\"\"\n        power_status = SYSTEM_POWER_STATUS()\n        if not GetSystemPowerStatus(pointer(power_status)):\n            raise WinError()\n        return POWER_TYPE_MAP[power_status.ACLineStatus]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_low_battery_warning_level(self):\n        power_status = SYSTEM_POWER_STATUS()\n        if not GetSystemPowerStatus(pointer(power_status)):\n            raise WinError()\n\n        if POWER_TYPE_MAP[power_status.ACLineStatus] == common.POWER_TYPE_AC:\n            return common.LOW_BATTERY_WARNING_NONE\n        else:\n            if power_status.BatteryLifeTime != -1 and power_status.BatteryLifeTime <= 600:\n                return common.LOW_BATTERY_WARNING_FINAL\n            elif power_status.BatteryLifePercent <= 22:\n                return common.LOW_BATTERY_WARNING_EARLY\n            else:\n                return common.LOW_BATTERY_WARNING_NONE", "response": "Returns warning according to GetSystemPowerStatus. BatteryLifeTime and BatteryLifePercent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_time_remaining_estimate(self):\n        power_status = SYSTEM_POWER_STATUS()\n        if not GetSystemPowerStatus(pointer(power_status)):\n            raise WinError()\n\n        if POWER_TYPE_MAP[power_status.ACLineStatus] == common.POWER_TYPE_AC:\n            return common.TIME_REMAINING_UNLIMITED\n        elif power_status.BatteryLifeTime == -1:\n            return common.TIME_REMAINING_UNKNOWN\n        else:\n            return float(power_status.BatteryLifeTime) / 60.0", "response": "Returns the time remaining estimate according to GetSystemPowerStatus. BatteryLifeTime\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef power_source_type():\n        try:\n            supply=int(subprocess.check_output([\"sysctl\",\"-n\",\"hw.acpi.acline\"]))\n        except:\n            return common.POWER_TYPE_AC\n \n        if supply == 1:\n            return common.POWER_TYPE_AC\n        elif supply == 0:\n            return common.POWER_TYPE_BATTERY\n        else:\n            raise RuntimeError(\"Unknown power source type!\")", "response": "Return the type of power source that is currently supported by the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_battery_state():\n        energy_now = float(100.0)\n        power_now = float(100.0)\n        energy_full = float(100.0)\n        return energy_full, energy_now, power_now", "response": "Get the current battery state of the current resource store."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_providing_power_source_type(self):\n        type = self.power_source_type()\n        if type == common.POWER_TYPE_AC:\n            if self.is_ac_online():\n                return common.POWER_TYPE_AC\n            elif type == common.POWER_TYPE_BATTERY:\n                if self.is_battery_present() and self.is_battery_discharging():\n                    return common.POWER_TYPE_BATTERY\n                else:\n                    warnings.warn(\"UPS is not supported.\")\n        return common.POWER_TYPE_AC", "response": "Returns the type of power source that is being used for this power source."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_low_battery_warning_level(self):\n        all_energy_full = []\n        all_energy_now = []\n        all_power_now = []\n        try:\n            type = self.power_source_type()\n            if type == common.POWER_TYPE_AC:\n                if self.is_ac_online():\n                    return common.LOW_BATTERY_WARNING_NONE\n            elif type == common.POWER_TYPE_BATTERY:\n                if self.is_battery_present() and self.is_battery_discharging():\n                    energy_full, energy_now, power_now = self.get_battery_state()\n                    all_energy_full.append(energy_full)\n                    all_energy_now.append(energy_now)\n                    all_power_now.append(power_now)\n            else:\n                warnings.warn(\"UPS is not supported.\")\n        except (RuntimeError, IOError) as e:\n            warnings.warn(\"Unable to read system power information!\", category=RuntimeWarning)\n\n        try:\n            total_percentage = sum(all_energy_full) / sum(all_energy_now)\n            total_time = sum([energy_now / power_now * 60.0 for energy_now, power_now in zip(all_energy_now, all_power_now)])\n            if total_time <= 10.0:\n                return common.LOW_BATTERY_WARNING_FINAL\n            elif total_percentage <= 22.0:\n                return common.LOW_BATTERY_WARNING_EARLY\n            else:\n                return common.LOW_BATTERY_WARNING_NONE\n        except ZeroDivisionError as e:\n            warnings.warn(\"Unable to calculate low battery level: {0}\".format(e), category=RuntimeWarning)\n            return common.LOW_BATTERY_WARNING_NONE", "response": "Returns the low battery warning level of the system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_time_remaining_estimate(self):\n        all_energy_now = []\n        all_power_now = []\n        try:\n            type = self.power_source_type()\n            if type == common.POWER_TYPE_AC:\n                if self.is_ac_online(supply_path):\n                    return common.TIME_REMAINING_UNLIMITED\n            elif type == common.POWER_TYPE_BATTERY:\n                if self.is_battery_present() and self.is_battery_discharging():\n                    energy_full, energy_now, power_now = self.get_battery_state()\n                    all_energy_now.append(energy_now)\n                    all_power_now.append(power_now)\n            else:\n                warnings.warn(\"UPS is not supported.\")\n        except (RuntimeError, IOError) as e:\n            warnings.warn(\"Unable to read system power information!\", category=RuntimeWarning)\n\n        if len(all_energy_now) > 0:\n            try:\n                return sum([energy_now / power_now * 60.0 for energy_now, power_now in zip(all_energy_now, all_power_now)])\n            except ZeroDivisionError as e:\n                warnings.warn(\"Unable to calculate time remaining estimate: {0}\".format(e), category=RuntimeWarning)\n                return common.TIME_REMAINING_UNKNOWN\n        else:\n            return common.TIME_REMAINING_UNKNOWN", "response": "Returns the total time remaining estimate of the system power."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the type of power source that is being used for the power source.", "response": "def get_providing_power_source_type(self):\n        \"\"\"\n        Looks through all power supplies in POWER_SUPPLY_PATH.\n        If there is an AC adapter online returns POWER_TYPE_AC.\n        If there is a discharging battery, returns POWER_TYPE_BATTERY.\n        Since the order of supplies is arbitrary, whatever found first is returned.\n        \"\"\"\n        for supply in os.listdir(POWER_SUPPLY_PATH):\n            supply_path = os.path.join(POWER_SUPPLY_PATH, supply)\n            try:\n                type = self.power_source_type(supply_path)\n                if type == common.POWER_TYPE_AC:\n                    if self.is_ac_online(supply_path):\n                        return common.POWER_TYPE_AC\n                elif type == common.POWER_TYPE_BATTERY:\n                    if self.is_battery_present(supply_path) and self.is_battery_discharging(supply_path):\n                        return common.POWER_TYPE_BATTERY\n                else:\n                    warnings.warn(\"UPS is not supported.\")\n            except (RuntimeError, IOError) as e:\n                warnings.warn(\"Unable to read properties of {0}: {1}\".format(supply_path, e), category=RuntimeWarning)\n\n        return common.POWER_TYPE_AC"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the total time remaining estimate of all power sources.", "response": "def get_time_remaining_estimate(self):\n        \"\"\"\n        Looks through all power sources and returns total time remaining estimate\n        or TIME_REMAINING_UNLIMITED if ac power supply is online.\n        \"\"\"\n        all_energy_now = []\n        all_energy_not_discharging = []\n        all_power_now = []\n        for supply in os.listdir(POWER_SUPPLY_PATH):\n            supply_path = os.path.join(POWER_SUPPLY_PATH, supply)\n            try:\n                type = self.power_source_type(supply_path)\n                if type == common.POWER_TYPE_AC:\n                    if self.is_ac_online(supply_path):\n                        return common.TIME_REMAINING_UNLIMITED\n                elif type == common.POWER_TYPE_BATTERY:\n                    if self.is_battery_present(supply_path) and self.is_battery_discharging(supply_path):\n                        energy_full, energy_now, power_now = self.get_battery_state(supply_path)\n                        all_energy_now.append(energy_now)\n                        all_power_now.append(power_now)\n                    elif self.is_battery_present(supply_path) and not self.is_battery_discharging(supply_path):\n                        energy_now = self.get_battery_state(supply_path)[1]\n                        all_energy_not_discharging.append(energy_now)\n                else:\n                    warnings.warn(\"UPS is not supported.\")\n            except (RuntimeError, IOError) as e:\n                warnings.warn(\"Unable to read properties of {0}: {1}\".format(supply_path, e), category=RuntimeWarning)\n\n        if len(all_energy_now) > 0:\n            try:\n                return sum([energy_now / power_now * 60.0 for energy_now, power_now in zip(all_energy_now, all_power_now)])\\\n                    + sum(all_energy_not_discharging) / (sum(all_power_now) / len(all_power_now)) * 60.0\n            except ZeroDivisionError as e:\n                warnings.warn(\"Unable to calculate time remaining estimate: {0}\".format(e), category=RuntimeWarning)\n                return common.TIME_REMAINING_UNKNOWN\n        else:\n            return common.TIME_REMAINING_UNKNOWN"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npack a message according to Scratch message specification and appends length prefix to msg.", "response": "def _pack(self, msg):\n        \"\"\"\n        Packages msg according to Scratch message specification (encodes and \n        appends length prefix to msg). Credit to chalkmarrow from the \n        scratch.mit.edu forums for the prefix encoding code.\n        \"\"\"\n        n = len(msg) \n        a = array.array('c')\n        a.append(chr((n >> 24) & 0xFF))\n        a.append(chr((n >> 16) & 0xFF))\n        a.append(chr((n >>  8) & 0xFF))\n        a.append(chr(n & 0xFF))\n        return a.tostring() + msg"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_type(self, s):\n        # TODO: what if the number is bigger than an int or float?\n        if s.startswith('\"') and s.endswith('\"'):\n            return s[1:-1]\n        elif s.find('.') != -1: \n            return float(s) \n        else: \n            return int(s)", "response": "Converts a string from Scratch to its proper type in Python."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _escape(self, msg):\n        escaped = ''\t\n        for c in msg: \n            escaped += c\n            if c == '\"':\n                escaped += '\"'\n        return escaped", "response": "Escapes double quotes by adding another double quote as per the Scratch\n        protocol."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _unescape(self, msg):\n        if isinstance(msg, (int, float, long)):\n            return msg\n\n        unescaped = ''\n        i = 0\n        while i < len(msg):\n            unescaped += msg[i]\n            if msg[i] == '\"':\n                i+=1\n            i+=1\n        return unescaped", "response": "Unescapes double quotes that were used to escape double quotes. Returns a new string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_msg(self, msg):\n        if not msg or len(msg) < self.prefix_len:\n            return False\n        length = self._extract_len(msg[:self.prefix_len])\n        msg_type = msg[self.prefix_len:].split(' ', 1)[0]\n        if length == len(msg[self.prefix_len:]) and msg_type in self.msg_types:\n            return True\n        return False", "response": "Returns True if the message is a proper Scratch message else return False."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a broacast message returns the message that was broadcast.", "response": "def _parse_broadcast(self, msg):\n        \"\"\"\n        Given a broacast message, returns the message that was broadcast.\n        \"\"\"\n        # get message, remove surrounding quotes, and unescape\n        return self._unescape(self._get_type(msg[self.broadcast_prefix_len:]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a sensorupdate message returns the sensors and variables that were updated as a dict that maps sensors and variables to their updated values.", "response": "def _parse_sensorupdate(self, msg):\n        \"\"\"\n        Given a sensor-update message, returns the sensors/variables that were\n        updated as a dict that maps sensors/variables to their updated values.\n        \"\"\"\n        update = msg[self.sensorupdate_prefix_len:]\n        parsed = [] # each element is either a sensor (key) or a sensor value\n        curr_seg = '' # current segment (i.e. key or value) being formed\n        numq = 0 # number of double quotes in current segment\n        for seg in update.split(' ')[:-1]: # last char in update is a space\n            numq += seg.count('\"')\n            curr_seg += seg\n            # even number of quotes means we've finished parsing a segment\n            if numq % 2 == 0: \n                parsed.append(curr_seg)\n                curr_seg = ''\n                numq = 0\n            else: # segment has a space inside, so add back it in\n                curr_seg += ' '\n        unescaped = [self._unescape(self._get_type(x)) for x in parsed]\n        # combine into a dict using iterators (both elements in the list\n        # inputted to izip have a reference to the same iterator). even \n        # elements are keys, odd are values\n        return dict(itertools.izip(*[iter(unescaped)]*2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse(self, msg):\n        if not self._is_msg(msg):\n            return None\n        msg_type = msg[self.prefix_len:].split(' ')[0]\n        if msg_type == 'broadcast':\n            return ('broadcast', self._parse_broadcast(msg))\n        else:\n            return ('sensor-update', self._parse_sensorupdate(msg))", "response": "Parses a Scratch message and returns a tuple with the first element as the message type and the second element as the message payload."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting string data out to Scratch", "response": "def _write(self, data):\n        \"\"\"\n        Writes string data out to Scratch\n        \"\"\"\n        total_sent = 0\n        length = len(data)\n        while total_sent < length:\n            try:\n                sent = self.socket.send(data[total_sent:])\n            except socket.error as (err, msg):\n                self.connected = False\n                raise ScratchError(\"[Errno %d] %s\" % (err, msg))\n            if sent == 0:\n                self.connected = False\n                raise ScratchConnectionError(\"Connection broken\")\n            total_sent += sent"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read(self, size):\n        data = ''\n        while len(data) < size:\n            try:\n                chunk = self.socket.recv(size-len(data))\n            except socket.error as (err, msg):\n                self.connected = False\n                raise ScratchError(\"[Errno %d] %s\" % (err, msg))\n            if chunk == '':\n                self.connected = False\n                raise ScratchConnectionError(\"Connection broken\")\n            data += chunk\n        return data", "response": "Reads size number of bytes from Scratch and returns data as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _recv(self):\n        prefix = self._read(self.prefix_len)\n        msg = self._read(self._extract_len(prefix))\n        return prefix + msg", "response": "Receives and returns a message from Scratch\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disconnect(self):\n        try: # connection may already be disconnected, so catch exceptions\n            self.socket.shutdown(socket.SHUT_RDWR) # a proper disconnect\n        except socket.error:\n            pass\n        self.socket.close()\n        self.connected = False", "response": "Closes connection to Scratch\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the sensors with the values in Scratch.", "response": "def sensorupdate(self, data):\n        \"\"\"\n        Given a dict of sensors and values, updates those sensors with the \n        values in Scratch.\n        \"\"\"\n        if not isinstance(data, dict):\n            raise TypeError('Expected a dict')\n        msg = 'sensor-update '\n        for key in data.keys():\n            msg += '\"%s\" \"%s\" ' % (self._escape(str(key)), \n                                    self._escape(str(data[key])))\n        self._send(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef broadcast(self, msg):\n        if getattr(msg, '__iter__', False): # iterable\n            for m in msg:\n                self._send('broadcast \"%s\"' % self._escape(str(m)))\n        else: # probably a string or number\n            self._send('broadcast \"%s\"' % self._escape(str(msg)))", "response": "Broadcasts msg to Scratch. msg can be a string list tuple set generator etc."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_simple_topology(cls, config, emitters, result_type=NAMEDTUPLE, max_spout_emits=None):\n        \n        # The config is almost always required. The only known reason to pass\n        # None is when calling run_simple_topology() multiple times for the\n        # same components. This can be useful for testing spout ack() and fail()\n        # behavior.\n        if config is not None:\n            for emitter in emitters:\n                emitter.initialize(config, {})\n\n        with cls() as self:\n            # Read from the spout.\n            spout = emitters[0]\n            spout_id = self.emitter_id(spout)\n            old_length = -1\n            length = len(self.pending[spout_id])\n            while length > old_length and (max_spout_emits is None or length < max_spout_emits):\n                old_length = length \n                self.activate(spout)\n                spout.nextTuple()\n                length = len(self.pending[spout_id])\n\n            # For each bolt in the sequence, consume all upstream input.\n            for i, bolt in enumerate(emitters[1:]):\n                previous = emitters[i]\n                self.activate(bolt)\n                while len(self.pending[self.emitter_id(previous)]) > 0:\n                    bolt.process(self.read(previous))\n\n        def make_storm_tuple(t, emitter):\n            return t\n        \n        def make_python_list(t, emitter):\n            return list(t.values)\n        \n        def make_python_tuple(t, emitter):\n            return tuple(t.values)\n\n        def make_named_tuple(t, emitter):\n            return self.get_output_type(emitter)(*t.values)\n\n        if result_type == STORM_TUPLE:\n            make = make_storm_tuple\n        elif result_type == LIST:\n            make = make_python_list\n        elif result_type == NAMEDTUPLE:\n            make = make_named_tuple\n        else:\n            assert False, 'Invalid result type specified: %s' % result_type\n\n        result_values = \\\n            [ [ make(t, emitter) for t in self.processed[self.emitter_id(emitter)]] for emitter in emitters[:-1] ] + \\\n            [ [ make(t, emitters[-1]) for t in self.pending[self.emitter_id(emitters[-1])] ] ]\n        return dict((k, v) for k, v in zip(emitters, result_values))", "response": "Tests a simple topology."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, stream):\n        topology = self.createTopology()\n        def write_it(stream):\n            transportOut = TMemoryBuffer()\n            protocolOut = TBinaryProtocol.TBinaryProtocol(transportOut)\n            topology.write(protocolOut)\n            bytes = transportOut.getvalue()\n            stream.write(bytes)\n\n        if isinstance(stream, six.string_types):\n            with open(stream, 'wb') as f:\n                write_it(f)\n        else:\n            write_it(stream)\n            \n        return topology", "response": "Writes the topology to a stream or file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, stream):\n        def read_it(stream):\n            bytes = stream.read()\n            transportIn = TMemoryBuffer(bytes)\n            protocolIn = TBinaryProtocol.TBinaryProtocol(transportIn)\n            topology = StormTopology()\n            topology.read(protocolIn)\n            return topology\n            \n        if isinstance(stream, six.string_types):\n            with open(stream, 'rb') as f:\n                return read_it(f)\n        else:\n            return read_it(stream)", "response": "Reads the topology from a stream or file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_jar(source_jar_path, dest_jar_path, config, venv=None, definition=None, logdir=None):\n\n    if definition is None:\n        definition = 'create.create'\n\n    # Prepare data we'll use later for configuring parallelism.\n    config_yaml = read_yaml(config)\n    parallelism = dict((k.split('.')[-1], v) for k, v in six.iteritems(config_yaml)\n        if k.startswith('petrel.parallelism'))\n\n    pip_options = config_yaml.get('petrel.pip_options', '')\n\n    module_name, dummy, function_name = definition.rpartition('.')\n    \n    topology_dir = os.getcwd()\n\n    # Make a copy of the input \"jvmpetrel\" jar. This jar acts as a generic\n    # starting point for all Petrel topologies.\n    source_jar_path = os.path.abspath(source_jar_path)\n    dest_jar_path = os.path.abspath(dest_jar_path)\n    if source_jar_path == dest_jar_path:\n        raise ValueError(\"Error: Destination and source path are the same.\")\n    shutil.copy(source_jar_path, dest_jar_path)\n    jar = zipfile.ZipFile(dest_jar_path, 'a', compression=zipfile.ZIP_DEFLATED)\n    \n    added_path_entry = False\n    try:\n        # Add the files listed in manifest.txt to the jar.\n        with open(os.path.join(topology_dir, MANIFEST), 'r') as f:\n            for fn in f.readlines():\n                # Ignore blank and comment lines.\n                fn = fn.strip()\n                if len(fn) and not fn.startswith('#'):\n\n                    add_item_to_jar(jar, os.path.expandvars(fn.strip()))\n\n        # Add user and machine information to the jar.\n        add_to_jar(jar, '__submitter__.yaml', '''\npetrel.user: %s\npetrel.host: %s\n''' % (getpass.getuser(),socket.gethostname()))\n        \n        # Also add the topology configuration to the jar.\n        with open(config, 'r') as f:\n            config_text = f.read()\n        add_to_jar(jar, '__topology__.yaml', config_text)\n    \n        # Call module_name/function_name to populate a Thrift topology object.\n        builder = TopologyBuilder()\n        module_dir = os.path.abspath(topology_dir)\n        if module_dir not in sys.path:\n            sys.path[:0] = [ module_dir ]\n            added_path_entry = True\n        module = __import__(module_name)\n        getattr(module, function_name)(builder)\n\n        # Add the spout and bolt Python scripts to the jar. Create a\n        # setup_<script>.sh for each Python script.\n\n        # Add Python scripts and any other per-script resources.\n        for k, v in chain(six.iteritems(builder._spouts), six.iteritems(builder._bolts)):\n            add_file_to_jar(jar, topology_dir, v.script)\n\n            # Create a bootstrap script.\n            if venv is not None:\n                # Allow overriding the execution command from the \"petrel\"\n                # command line. This is handy if the server already has a\n                # virtualenv set up with the necessary libraries.\n                v.execution_command = os.path.join(venv, 'bin/python')\n\n            # If a parallelism value was specified in the configuration YAML,\n            # override any setting provided in the topology definition script.\n            if k in parallelism:\n                builder._commons[k].parallelism_hint = int(parallelism.pop(k))\n\n            v.execution_command, v.script = \\\n                intercept(venv, v.execution_command, os.path.splitext(v.script)[0],\n                          jar, pip_options, logdir)\n\n        if len(parallelism):\n            raise ValueError(\n                'Parallelism settings error: There are no components named: %s' %\n                ','.join(parallelism.keys()))\n\n        # Build the Thrift topology object and serialize it to the .jar. Must do\n        # this *after* the intercept step above since that step may modify the\n        # topology definition.\n        buf = io.BytesIO()\n        builder.write(buf)\n        add_to_jar(jar, 'topology.ser', buf.getvalue())\n    finally:\n        jar.close()\n        if added_path_entry:\n            # Undo our sys.path change.\n            sys.path[:] = sys.path[1:]", "response": "Build a StormTopology. jar which encapsulates the topology defined in the topology_dir. Optionally override the module and function names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef emitMany(*args, **kwargs):\n    global MODE\n    if MODE == Bolt:\n        emitManyBolt(*args, **kwargs)\n    elif MODE == Spout:\n        emitManySpout(*args, **kwargs)", "response": "A more efficient way to emit a number of tuples at once."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remote_debug(sig,frame):\n    def _raiseEx(ex):\n        \"\"\"Raise specified exception in the remote process\"\"\"\n        _raiseEx.ex = ex\n    _raiseEx.ex = None\n    \n    try:\n        # Provide some useful functions.\n        locs = {'_raiseEx' : _raiseEx}\n        locs.update(frame.f_locals)  # Unless shadowed.\n        globs = frame.f_globals\n        \n        pid = os.getpid()  # Use pipe name based on pid\n        pipe = NamedPipe(pipename(pid))\n    \n        old_stdout, old_stderr = sys.stdout, sys.stderr\n        txt = ''\n        pipe.put(\"Interrupting process at following point:\\n\" + \n               ''.join(traceback.format_stack(frame)) + \">>> \")\n        \n        try:\n            while pipe.is_open() and _raiseEx.ex is None:\n                line = pipe.get()\n                if line is None: continue # EOF\n                txt += line\n                try:\n                    code = codeop.compile_command(txt)\n                    if code:\n                        sys.stdout = six.StringIO()\n                        sys.stderr = sys.stdout\n                        six.exec_(code, globs, locs)\n                        txt = ''\n                        pipe.put(sys.stdout.getvalue() + '>>> ')\n                    else:\n                        pipe.put('... ')\n                except:\n                    txt='' # May be syntax err.\n                    sys.stdout = six.StringIO()\n                    sys.stderr = sys.stdout\n                    traceback.print_exc()\n                    pipe.put(sys.stdout.getvalue() + '>>> ')\n        finally:\n            sys.stdout = old_stdout # Restore redirected output.\n            sys.stderr = old_stderr\n            pipe.close()\n\n    except Exception:  # Don't allow debug exceptions to propogate to real program.\n        traceback.print_exc()\n        \n    if _raiseEx.ex is not None: raise _raiseEx.ex", "response": "Handler to allow process to be remotely debugged."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninterrupting a running process and debug it.", "response": "def debug_process(pid):\n    \"\"\"Interrupt a running process and debug it.\"\"\"\n    os.kill(pid, signal.SIGUSR1)  # Signal process.\n    pipe = NamedPipe(pipename(pid), 1)\n    try:\n        while pipe.is_open():\n            txt=raw_input(pipe.get()) + '\\n'\n            pipe.put(txt)\n    except EOFError:\n        pass # Exit.\n    pipe.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _encode_utf8(self, **kwargs):\n        if is_py3:\n            # This is only valid for Python 2. In Python 3, unicode is\n            # everywhere (yay).\n            return kwargs\n\n        unencoded_pairs = kwargs\n        for i in unencoded_pairs.keys():\n            #noinspection PyUnresolvedReferences\n            if isinstance(unencoded_pairs[i], types.UnicodeType):\n                unencoded_pairs[i] = unencoded_pairs[i].encode('utf-8')\n        return unencoded_pairs", "response": "Encode all of the NVP values in kwargs to UTF - 8."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the required values are present in kwargs.", "response": "def _check_required(self, requires, **kwargs):\n        \"\"\"\n        Checks kwargs for the values specified in 'requires', which is a tuple\n        of strings. These strings are the NVP names of the required values.\n        \"\"\"\n        for req in requires:\n            # PayPal api is never mixed-case.\n            if req.lower() not in kwargs and req.upper() not in kwargs:\n                raise PayPalError('missing required : %s' % req)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps method for executing all API commands over HTTP.", "response": "def _call(self, method, **kwargs):\n        \"\"\"\n        Wrapper method for executing all API commands over HTTP. This method is\n        further used to implement wrapper methods listed here:\n\n        https://www.x.com/docs/DOC-1374\n\n        ``method`` must be a supported NVP method listed at the above address.\n        ``kwargs`` the actual call parameters\n        \"\"\"\n        post_params = self._get_call_params(method, **kwargs)\n        payload = post_params['data']\n        api_endpoint = post_params['url']\n\n        # This shows all of the key/val pairs we're sending to PayPal.\n        if logger.isEnabledFor(logging.DEBUG):\n            logger.debug('PayPal NVP Query Key/Vals:\\n%s' % pformat(payload))\n\n        http_response = requests.post(**post_params)\n        response = PayPalResponse(http_response.text, self.config)\n        logger.debug('PayPal NVP API Endpoint: %s' % api_endpoint)\n\n        if not response.success:\n            raise PayPalAPIResponseError(response)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_call_params(self, method, **kwargs):\n        payload = {'METHOD': method,\n                   'VERSION': self.config.API_VERSION}\n        certificate = None\n\n        if self.config.API_AUTHENTICATION_MODE == \"3TOKEN\":\n            payload['USER'] = self.config.API_USERNAME\n            payload['PWD'] = self.config.API_PASSWORD\n            payload['SIGNATURE'] = self.config.API_SIGNATURE\n        elif self.config.API_AUTHENTICATION_MODE == \"CERTIFICATE\":\n            payload['USER'] = self.config.API_USERNAME\n            payload['PWD'] = self.config.API_PASSWORD\n            certificate = (self.config.API_CERTIFICATE_FILENAME,\n                           self.config.API_KEY_FILENAME)\n        elif self.config.API_AUTHENTICATION_MODE == \"UNIPAY\":\n            payload['SUBJECT'] = self.config.UNIPAY_SUBJECT\n\n        none_configs = [config for config, value in payload.items()\n                        if value is None]\n        if none_configs:\n            raise PayPalConfigError(\n                \"Config(s) %s cannot be None. Please, check this \"\n                \"interface's config.\" % none_configs)\n\n        # all keys in the payload must be uppercase\n        for key, value in kwargs.items():\n            payload[key.upper()] = value\n\n        return {'data': payload,\n                'cert': certificate,\n                'url': self.config.API_ENDPOINT,\n                'timeout': self.config.HTTP_TIMEOUT,\n                'verify': self.config.API_CA_CERTS}", "response": "Returns the prepared call parameters. Mind the method and kwargs will be keyword arguments to requests. post."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef address_verify(self, email, street, zip):\n        args = self._sanitize_locals(locals())\n        return self._call('AddressVerify', **args)", "response": "Shortcut for the AddressVerify method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_authorization(self, transactionid, amt):\n        args = self._sanitize_locals(locals())\n        return self._call('DoAuthorization', **args)", "response": "Shortcut for the DoAuthorization method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_capture(self, authorizationid, amt, completetype='Complete',\n                   **kwargs):\n        \"\"\"Shortcut for the DoCapture method.\n\n        Use the TRANSACTIONID from DoAuthorization, DoDirectPayment or\n        DoExpressCheckoutPayment for the ``authorizationid``.\n\n        The `amt` should be the same as the authorized transaction.\n        \"\"\"\n        kwargs.update(self._sanitize_locals(locals()))\n        return self._call('DoCapture', **kwargs)", "response": "Shortcut for the DoCapture method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transaction_search(self, **kwargs):\n        plain = self._call('TransactionSearch', **kwargs)\n        return PayPalResponseList(plain.raw, self.config)", "response": "Shortcut for the TransactionSearch method. Returns a PayPalResponseList object which merges the L_ syntax list\n        to a list of dictionaries with properly named keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refund_transaction(self, transactionid=None, payerid=None, **kwargs):\n        # This line seems like a complete waste of time... kwargs should not\n        # be populated\n        if (transactionid is None) and (payerid is None):\n            raise PayPalError(\n                'RefundTransaction requires either a transactionid or '\n                'a payerid')\n        if (transactionid is not None) and (payerid is not None):\n            raise PayPalError(\n                'RefundTransaction requires only one of transactionid %s '\n                'and payerid %s' % (transactionid, payerid))\n        if transactionid is not None:\n            kwargs['TRANSACTIONID'] = transactionid\n        else:\n            kwargs['PAYERID'] = payerid\n\n        return self._call('RefundTransaction', **kwargs)", "response": "Shortcut for RefundTransaction method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_express_checkout_redirect_url(self, token, useraction=None):\n        url_vars = (self.config.PAYPAL_URL_BASE, token)\n        url = \"%s?cmd=_express-checkout&token=%s\" % url_vars\n        if useraction:\n            if not useraction.lower() in ('commit', 'continue'):\n                warnings.warn('useraction=%s is not documented' % useraction,\n                              RuntimeWarning)\n            url += '&useraction=%s' % useraction\n        return url", "response": "Generates the URL to redirect the user to for the Express checkout."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a URL to redirect to the cart upload page.", "response": "def generate_cart_upload_redirect_url(self, **kwargs):\n        \"\"\"https://www.sandbox.paypal.com/webscr\n            ?cmd=_cart\n            &upload=1\n        \"\"\"\n        required_vals = ('business', 'item_name_1', 'amount_1', 'quantity_1')\n        self._check_required(required_vals, **kwargs)\n        url = \"%s?cmd=_cart&upload=1\" % self.config.PAYPAL_URL_BASE\n        additional = self._encode_utf8(**kwargs)\n        additional = urlencode(additional)\n        return url + \"&\" + additional"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef manage_recurring_payments_profile_status(self, profileid, action,\n                                                 note=None):\n        \"\"\"Shortcut to the ManageRecurringPaymentsProfileStatus method.\n\n        ``profileid`` is the same profile id used for getting profile details.\n        ``action`` should be either 'Cancel', 'Suspend', or 'Reactivate'.\n        ``note`` is optional and is visible to the user. It contains the\n            reason for the change in status.\n        \"\"\"\n        args = self._sanitize_locals(locals())\n        if not note:\n            del args['note']\n        return self._call('ManageRecurringPaymentsProfileStatus', **args)", "response": "Shortcut to the ManageRecurringPaymentsProfileStatus method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_recurring_payments_profile(self, profileid, **kwargs):\n        kwargs.update(self._sanitize_locals(locals()))\n        return self._call('UpdateRecurringPaymentsProfile', **kwargs)", "response": "Shortcut to the UpdateRecurringPaymentsProfile method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef success(self):\n        return self.ack.upper() in (self.config.ACK_SUCCESS,\n                                    self.config.ACK_SUCCESS_WITH_WARNING)", "response": "Checks if the response from PayPal is successful. Returns True if all is well False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_valid_country_abbrev(abbrev, case_sensitive=False):\n    if case_sensitive:\n        country_code = abbrev\n    else:\n        country_code = abbrev.upper()\n\n    for code, full_name in COUNTRY_TUPLES:\n        if country_code == code:\n            return True\n\n    return False", "response": "Checks to see if a country code abbreviation matches the country table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_name_from_abbrev(abbrev, case_sensitive=False):\n    if case_sensitive:\n        country_code = abbrev\n    else:\n        country_code = abbrev.upper()\n\n    for code, full_name in COUNTRY_TUPLES:\n        if country_code == code:\n            return full_name\n\n    raise KeyError('No country with that country code.')", "response": "Given a country code abbreviation get the full name of that language."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates declared fields with fields converted from the Mongoengine model passed as the model class Meta option.", "response": "def get_declared_fields(mcs, klass, *args, **kwargs):\n        \"\"\"Updates declared fields with fields converted from the\n        Mongoengine model passed as the `model` class Meta option.\n        \"\"\"\n        declared_fields = kwargs.get('dict_class', dict)()\n        # Generate the fields provided through inheritance\n        opts = klass.opts\n        model = getattr(opts, 'model', None)\n        if model:\n            converter = opts.model_converter()\n            declared_fields.update(converter.fields_for_model(\n                model,\n                fields=opts.fields\n            ))\n        # Generate the fields provided in the current class\n        base_fields = super(SchemaMeta, mcs).get_declared_fields(\n            klass, *args, **kwargs\n        )\n        declared_fields.update(base_fields)\n        # Customize fields with provided kwargs\n        for field_name, field_kwargs in klass.opts.model_fields_kwargs.items():\n            field = declared_fields.get(field_name, None)\n            if field:\n                # Copy to prevent alteration of a possible parent class's field\n                field = copy.copy(field)\n                for key, value in field_kwargs.items():\n                    setattr(field, key, value)\n                declared_fields[field_name] = field\n        if opts.model_dump_only_pk and opts.model:\n            # If primary key is automatically generated (nominal case), we\n            # must make sure this field is read-only\n            if opts.model._auto_id_field is True:\n                field_name = opts.model._meta['id_field']\n                id_field = declared_fields.get(field_name)\n                if id_field:\n                    # Copy to prevent alteration of a possible parent class's field\n                    id_field = copy.copy(id_field)\n                    id_field.dump_only = True\n                    declared_fields[field_name] = id_field\n        return declared_fields"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, obj, data):\n        # TODO: find a cleaner way to skip required validation on update\n        required_fields = [k for k, f in self.fields.items() if f.required]\n        for field in required_fields:\n            self.fields[field].required = False\n        loaded_data, errors = self._do_load(data, postprocess=False)\n        for field in required_fields:\n            self.fields[field].required = True\n        if not errors:\n            # Update the given obj fields\n            for k, v in loaded_data.items():\n                # Skip default values that have been automatically\n                # added during unserialization\n                if k in data:\n                    setattr(obj, k, v)\n        return ma.UnmarshalResult(data=obj, errors=errors)", "response": "Helper function to update an already existing document\n    instead of creating a new one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbind a marshmallow field to it corresponding marshmallow field", "response": "def register_field(mongo_field_cls, marshmallow_field_cls,\n                   available_params=()):\n    \"\"\"\n    Bind a marshmallow field to it corresponding mongoengine field\n    :param mongo_field_cls: Mongoengine Field\n    :param marshmallow_field_cls: Marshmallow Field\n    :param available_params: List of :class marshmallow_mongoengine.cnoversion.params.MetaParam:\n        instances to import the mongoengine field config to marshmallow\n    \"\"\"\n    class Builder(MetaFieldBuilder):\n        AVAILABLE_PARAMS = available_params\n        MARSHMALLOW_FIELD_CLS = marshmallow_field_cls\n    register_field_builder(mongo_field_cls, Builder)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_marshmallow_field(self, **kwargs):\n        field_kwargs = None\n        for param in self.params:\n            field_kwargs = param.apply(field_kwargs)\n        field_kwargs.update(kwargs)\n        return self.marshmallow_field_cls(**field_kwargs)", "response": "Build and return a Marshmallow Field instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend keepalive if necessary.", "response": "def check_keepalive(self):\n        \"\"\"Send keepalive/PING if necessary.\"\"\"\n        if self.sock != NC.INVALID_SOCKET and time.time() - self.last_msg_out >= self.keep_alive:\n            if self.state == NC.CS_CONNECTED:\n                self.send_pingreq()\n            else:\n                self.socket_close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsubscribe to some topic.", "response": "def subscribe(self, topic, qos):\n        \"\"\"Subscribe to some topic.\"\"\"\n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN\n        \n        self.logger.info(\"SUBSCRIBE: %s\", topic)\n        return self.send_subscribe(False, [(utf8encode(topic), qos)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subscribe_multi(self, topics):\n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN\n        \n        self.logger.info(\"SUBSCRIBE: %s\", ', '.join([t for (t,q) in topics]))\n        return self.send_subscribe(False, [(utf8encode(topic), qos) for (topic, qos) in topics])", "response": "Subscribe to some topics."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends subscribe COMMAND to server.", "response": "def send_subscribe(self, dup, topics):\n        \"\"\"Send subscribe COMMAND to server.\"\"\"\n        pkt = MqttPkt()\n        \n        pktlen = 2 + sum([2+len(topic)+1 for (topic, qos) in topics])\n        pkt.command = NC.CMD_SUBSCRIBE | (dup << 3) | (1 << 1)\n        pkt.remaining_length = pktlen\n        \n        ret = pkt.alloc()\n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        #variable header\n        mid = self.mid_generate()\n        pkt.write_uint16(mid)\n        \n        #payload\n        for (topic, qos) in topics:\n            pkt.write_string(topic)\n            pkt.write_byte(qos)\n        \n        return self.packet_queue(pkt)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_unsubscribe(self, dup, topics):\n        pkt = MqttPkt()\n        \n        pktlen = 2 + sum([2+len(topic) for topic in topics])\n        pkt.command = NC.CMD_UNSUBSCRIBE | (dup << 3) | (1 << 1)\n        pkt.remaining_length = pktlen\n        \n        ret = pkt.alloc()\n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        #variable header\n        mid = self.mid_generate()\n        pkt.write_uint16(mid)\n        \n        #payload\n        for topic in topics:\n            pkt.write_string(topic)\n        \n        return self.packet_queue(pkt)", "response": "Send unsubscribe COMMAND to server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef publish(self, topic, payload = None, qos = 0, retain = False):\n        #print \"PUBLISHING (\",topic,\"): \", payload\n        payloadlen = len(payload)\n        if topic is None or qos < 0 or qos > 2:\n            print \"PUBLISH:err inval\"\n            return NC.ERR_INVAL\n        \n        #payloadlen <= 250MB\n        if payloadlen > (250 * 1024 * 1204):\n            self.logger.error(\"PUBLISH:err payload len:%d\", payloadlen)\n            return NC.ERR_PAYLOAD_SIZE\n        \n        #wildcard check : TODO\n        mid = self.mid_generate()\n        \n        if qos in (0,1,2):\n            return self.send_publish(mid, topic, payload, qos, retain, False)\n\n        else:\n            self.logger.error(\"Unsupport QoS= %d\", qos)\n    \n        return NC.ERR_NOT_SUPPORTED", "response": "Publish some payload to server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles incoming CONNACK command.", "response": "def handle_connack(self):\n        \"\"\"Handle incoming CONNACK command.\"\"\"\n        self.logger.info(\"CONNACK reveived\")\n        ret, flags = self.in_packet.read_byte()\n        if ret != NC.ERR_SUCCESS:\n            self.logger.error(\"error read byte\")\n            return ret\n        \n        # useful for v3.1.1 only\n        session_present = flags & 0x01\n\n        ret, retcode = self.in_packet.read_byte()\n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        evt = event.EventConnack(retcode, session_present)\n        self.push_event(evt)\n        \n        if retcode == NC.CONNECT_ACCEPTED:\n            self.state = NC.CS_CONNECTED\n            return NC.ERR_SUCCESS\n        \n        elif retcode >= 1 and retcode <= 5:\n            return NC.ERR_CONN_REFUSED\n        else:\n            return NC.ERR_PROTOCOL"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles incoming PINGRESP packet.", "response": "def handle_pingresp(self):\n        \"\"\"Handle incoming PINGRESP packet.\"\"\"\n        self.logger.debug(\"PINGRESP received\")\n        self.push_event(event.EventPingResp())\n        return NC.ERR_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_suback(self):\n        self.logger.info(\"SUBACK received\")\n        \n        ret, mid = self.in_packet.read_uint16()\n        \n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        qos_count = self.in_packet.remaining_length - self.in_packet.pos\n        granted_qos = bytearray(qos_count)\n        \n        if granted_qos is None:\n            return NC.ERR_NO_MEM\n        \n        i = 0\n        while self.in_packet.pos < self.in_packet.remaining_length:\n            ret, byte = self.in_packet.read_byte()\n            \n            if ret != NC.ERR_SUCCESS:\n                granted_qos = None\n                return ret\n            \n            granted_qos[i] = byte\n            \n            i += 1\n        \n        evt = event.EventSuback(mid, list(granted_qos))\n        self.push_event(evt)\n        \n        granted_qos = None\n        \n        return NC.ERR_SUCCESS", "response": "Handle incoming SUBACK packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_unsuback(self):\n        self.logger.info(\"UNSUBACK received\")\n\n        ret, mid = self.in_packet.read_uint16()\n\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        evt = event.EventUnsuback(mid)\n        self.push_event(evt)\n\n        return NC.ERR_SUCCESS", "response": "Handle incoming UNSUBACK packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_publish(self):\n        self.logger.debug(\"PUBLISH received\")\n        \n        header = self.in_packet.command\n        \n        message = NyamukMsgAll()\n        message.direction = NC.DIRECTION_IN\n        message.dup = (header & 0x08) >> 3\n        message.msg.qos = (header & 0x06) >> 1\n        message.msg.retain = (header & 0x01)\n        \n        ret, ba_data = self.in_packet.read_string()\n        message.msg.topic = ba_data.decode('utf8')\n        \n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        #fix_sub_topic TODO\n        if message.msg.qos > 0:\n            ret, word = self.in_packet.read_uint16()\n            message.msg.mid = word\n            if ret != NC.ERR_SUCCESS:\n                return ret\n        \n        message.msg.payloadlen = self.in_packet.remaining_length - self.in_packet.pos\n        \n        if message.msg.payloadlen > 0:\n            ret, message.msg.payload = self.in_packet.read_bytes(message.msg.payloadlen)\n            if ret != NC.ERR_SUCCESS:\n                return ret\n       \n        self.logger.debug(\"Received PUBLISH(dup = %d,qos=%d,retain=%s\", message.dup, message.msg.qos, message.msg.retain)\n        self.logger.debug(\"\\tmid=%d, topic=%s, payloadlen=%d\", message.msg.mid, message.msg.topic, message.msg.payloadlen)\n\n        message.timestamp = time.time()\n        \n        qos = message.msg.qos\n        \n        if qos in (0,1,2):\n            evt = event.EventPublish(message.msg)\n            self.push_event(evt)\n\n            return NC.ERR_SUCCESS\n        \n        else:\n            return NC.ERR_PROTOCOL\n        \n        return NC.ERR_SUCCESS", "response": "Handle incoming PUBLISH packet."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a PUBLISH message.", "response": "def send_publish(self, mid, topic, payload, qos, retain, dup):\n        \"\"\"Send PUBLISH.\"\"\"\n        self.logger.debug(\"Send PUBLISH\")\n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN\n\n        #NOTE: payload may be any kind of data\n        #      yet if it is a unicode string we utf8-encode it as convenience\n        return self._do_send_publish(mid, utf8encode(topic), utf8encode(payload), qos, retain, dup)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_puback(self):\n        self.logger.info(\"PUBACK received\")\n\n        ret, mid = self.in_packet.read_uint16()\n\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        evt = event.EventPuback(mid)\n        self.push_event(evt)\n\n        return NC.ERR_SUCCESS", "response": "Handle incoming PUBACK packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles incoming PUBREC packet.", "response": "def handle_pubrec(self):\n        \"\"\"Handle incoming PUBREC packet.\"\"\"\n        self.logger.info(\"PUBREC received\")\n\n        ret, mid = self.in_packet.read_uint16()\n\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        evt = event.EventPubrec(mid)\n        self.push_event(evt)\n\n        return NC.ERR_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_pubrel(self):\n        self.logger.info(\"PUBREL received\")\n\n        ret, mid = self.in_packet.read_uint16()\n\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        evt = event.EventPubrel(mid)\n        self.push_event(evt)\n\n        return NC.ERR_SUCCESS", "response": "Handle incoming PUBREL packet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_pubcomp(self):\n        self.logger.info(\"PUBCOMP received\")\n\n        ret, mid = self.in_packet.read_uint16()\n\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        evt = event.EventPubcomp(mid)\n        self.push_event(evt)\n\n        return NC.ERR_SUCCESS", "response": "Handle incoming PUBCOMP packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pubrec(self, mid):\n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN\n\n        self.logger.info(\"Send PUBREC (msgid=%s)\", mid)\n        pkt = MqttPkt()\n\n        pkt.command = NC.CMD_PUBREC\n        pkt.remaining_length = 2\n\n        ret = pkt.alloc()\n        if ret != NC.ERR_SUCCESS:\n            return ret\n\n        #variable header: acknowledged message id\n        pkt.write_uint16(mid)\n\n        return self.packet_queue(pkt)", "response": "Send PUBREC response to server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(sock, addr):\n    try:\n        sock.connect(addr)\n    except ssl.SSLError as e:\n        return (ssl.SSLError, e.strerror if e.strerror else e.message)\n    except socket.herror as (_, msg):\n        return (socket.herror, msg)\n    except socket.gaierror as (_, msg):\n        return (socket.gaierror, msg)\n    except socket.timeout:\n        return (socket.timeout, \"timeout\")\n    except socket.error as e:\n        return (socket.error, e.strerror if e.strerror else e.message)\n    \n    return None", "response": "Connect to some addr."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread from socket and return it s byte array representation.", "response": "def read(sock, count):\n    \"\"\"Read from socket and return it's byte array representation.\n    count = number of bytes to read\n    \"\"\"\n    data = None\n\n    try:\n        data = sock.recv(count)\n    except ssl.SSLError as e:\n        return data, e.errno, e.strerror if strerror else e.message\n    except socket.herror as (errnum, errmsg):\n        return data, errnum, errmsg\n    except socket.gaierror as (errnum, errmsg):\n        return data, errnum, errmsg\n    except socket.timeout:\n        return data, errno.ETIMEDOUT, \"Connection timed out\"\n    except socket.error as (errnum, errmsg):\n        return data, errnum, errmsg\n    \n    ba_data = bytearray(data)\n    \n    if len(ba_data) == 0:\n        return ba_data, errno.ECONNRESET, \"Connection closed\"\n    \n    return ba_data, 0, \"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting payload to socket.", "response": "def write(sock, payload):\n    \"\"\"Write payload to socket.\"\"\"\n    try:\n        length = sock.send(payload)\n    except ssl.SSLError as e:\n        return -1, (ssl.SSLError, e.strerror if strerror else e.message)\n    except socket.herror as (_, msg):\n        return -1, (socket.error, msg)\n    except socket.gaierror as (_, msg):\n        return -1, (socket.gaierror, msg)\n    except socket.timeout:\n        return -1, (socket.timeout, \"timeout\")\n    except socket.error as (_, msg):\n        return -1, (socket.error, msg)\n    \n    return length, None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump(self):\n        print \"-----MqttPkt------\"\n        print \"command = \", self.command\n        print \"have_remaining = \", self.have_remaining\n        print \"remaining_count = \", self.remaining_count\n        print \"mid = \", self.mid\n        print \"remaining_mult = \", self.remaining_mult\n        print \"remaining_length = \", self.remaining_length\n        print \"packet_length = \", self.packet_length\n        print \"to_process = \", self.to_process\n        print \"pos = \", self.pos\n        print \"payload = \", self.payload\n        print \"------------------\"", "response": "Print the contents of the current packet."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a CONNECT packet.", "response": "def connect_build(self, nyamuk, keepalive, clean_session, retain = 0, dup = 0, version = 3):\n        \"\"\"Build packet for CONNECT command.\"\"\"\n        will = 0; will_topic = None\n        byte = 0\n\n        client_id = utf8encode(nyamuk.client_id)\n        username  = utf8encode(nyamuk.username) if nyamuk.username is not None else None\n        password  = utf8encode(nyamuk.password) if nyamuk.password is not None else None\n\n        #payload len\n        payload_len = 2 + len(client_id)\n        if nyamuk.will is not None:\n            will = 1\n            will_topic = utf8encode(nyamuk.will.topic)\n\n            payload_len = payload_len + 2 + len(will_topic) + 2 + nyamuk.will.payloadlen\n        \n        if username is not None:\n            payload_len = payload_len + 2 + len(username)\n            if password != None:\n                payload_len = payload_len + 2 + len(password)\n        \n        self.command = NC.CMD_CONNECT\n        self.remaining_length = 12 + payload_len\n    \n        rc = self.alloc()\n        if rc != NC.ERR_SUCCESS:\n            return rc\n         \n        #var header\n        self.write_string(getattr(NC, 'PROTOCOL_NAME_{0}'.format(version)))\n        self.write_byte(  getattr(NC, 'PROTOCOL_VERSION_{0}'.format(version)))\n        \n        byte = (clean_session & 0x1) << 1\n        \n        if will:\n            byte = byte | ((nyamuk.will.retain & 0x1) << 5) | ((nyamuk.will.qos & 0x3) << 3) | ((will & 0x1) << 2)\n        \n        if nyamuk.username is not None:\n            byte = byte | 0x1 << 7\n            if nyamuk.password is not None:\n                byte = byte | 0x1 << 6\n        \n        self.write_byte(byte)\n        self.write_uint16(keepalive)\n        #payload\n        self.write_string(client_id)\n        \n        if will:\n            self.write_string(will_topic)\n            self.write_string(nyamuk.will.payload)\n\n        if username is not None:\n            self.write_string(username)\n            if password is not None:\n                self.write_string(password)\n            \n        nyamuk.keep_alive = keepalive\n        \n        return NC.ERR_SUCCESS"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_string(self, string):\n        self.write_uint16(len(string))\n        self.write_bytes(string, len(string))", "response": "Write a string to this packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites 2 bytes to the stream.", "response": "def write_uint16(self, word):\n        \"\"\"Write 2 bytes.\"\"\"\n        self.write_byte(nyamuk_net.MOSQ_MSB(word))\n        self.write_byte(nyamuk_net.MOSQ_LSB(word))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites one byte to the payload.", "response": "def write_byte(self, byte):\n        \"\"\"Write one byte.\"\"\"\n        self.payload[self.pos] = byte\n        self.pos = self.pos + 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_bytes(self, data, n):\n        for pos in xrange(0, n):\n            self.payload[self.pos + pos] = data[pos]\n            \n        self.pos += n", "response": "Write n number of bytes to this packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a byte from the payload.", "response": "def read_byte(self):\n        \"\"\"Read a byte.\"\"\"\n        if self.pos + 1 > self.remaining_length:\n            return NC.ERR_PROTOCOL, None\n        \n        byte = self.payload[self.pos]\n        self.pos += 1\n        \n        return NC.ERR_SUCCESS, byte"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_bytes(self, count):\n        if self.pos + count > self.remaining_length:\n            return NC.ERR_PROTOCOL, None\n        \n        ba = bytearray(count)\n        for x in xrange(0, count):\n            ba[x] = self.payload[self.pos]\n            self.pos += 1\n        \n        return NC.ERR_SUCCESS, ba", "response": "Read count number of bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop_event(self):\n        if len(self.event_list) > 0:\n            evt = self.event_list.pop(0)\n            return evt\n        return None", "response": "Pop an event from event_list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mid_generate(self):\n        self.last_mid += 1\n        if self.last_mid == 0:\n            self.last_mid += 1\n        return self.last_mid", "response": "Generate a unique ID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting packet to network.", "response": "def packet_write(self):\n        \"\"\"Write packet to network.\"\"\"\n        bytes_written = 0\n        \n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN, bytes_written\n        \n        while len(self.out_packet) > 0:\n            pkt = self.out_packet[0]\n            write_length, status = nyamuk_net.write(self.sock, pkt.payload)\n            if write_length > 0:\n                pkt.to_process -= write_length\n                pkt.pos += write_length\n                \n                bytes_written += write_length\n                \n                if pkt.to_process > 0:\n                    return NC.ERR_SUCCESS, bytes_written\n            else:\n                if status == errno.EAGAIN or status == errno.EWOULDBLOCK:\n                    return NC.ERR_SUCCESS, bytes_written\n                elif status == errno.ECONNRESET:\n                    return NC.ERR_CONN_LOST, bytes_written\n                else:\n                    return NC.ERR_UNKNOWN, bytes_written\n            \n            \"\"\"\n            if pkt.command & 0xF6 == NC.CMD_PUBLISH and self.on_publish is not None:\n                self.in_callback = True\n                self.on_publish(pkt.mid)\n                self.in_callback = False\n            \"\"\"\n            \n            #next\n            del self.out_packet[0]\n            \n            #free data (unnecessary)\n            \n            self.last_msg_out = time.time()\n            \n        \n        return NC.ERR_SUCCESS, bytes_written"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef packet_read(self):\n        bytes_received = 0\n        \n        if self.sock == NC.INVALID_SOCKET:\n            return NC.ERR_NO_CONN\n        \n        if self.in_packet.command == 0:\n            ba_data, errnum, errmsg = nyamuk_net.read(self.sock, 1)\n            if errnum == 0 and len(ba_data) == 1:\n                bytes_received += 1\n                byte = ba_data[0]\n                self.in_packet.command = byte\n                \n                if self.as_broker:\n                    if self.bridge is None and self.state == NC.CS_NEW and (byte & 0xF0) != NC.CMD_CONNECT:\n                        print \"RETURN ERR_PROTOCOL\"\n                        return NC.ERR_PROTOCOL, bytes_received\n            else:\n                if errnum == errno.EAGAIN or errnum == errno.EWOULDBLOCK:\n                    return NC.ERR_SUCCESS, bytes_received\n                elif errnum == 0 and len(ba_data) == 0 or errnum == errno.ECONNRESET:\n                    return NC.ERR_CONN_LOST, bytes_received\n                else:\n                    evt = event.EventNeterr(errnum, errmsg)\n                    self.push_event(evt)\n                    return NC.ERR_UNKNOWN, bytes_received\n        \n        if not self.in_packet.have_remaining:\n            loop_flag = True\n            while loop_flag:\n                ba_data, errnum, errmsg = nyamuk_net.read(self.sock, 1)\n                \n                if errnum == 0 and len(ba_data) == 1:       \n                    byte = ba_data[0]\n                    bytes_received += 1\n                    self.in_packet.remaining_count += 1\n                    if self.in_packet.remaining_count > 4:\n                        return NC.ERR_PROTOCOL, bytes_received\n                    \n                    self.in_packet.remaining_length += (byte & 127) * self.in_packet.remaining_mult\n                    self.in_packet.remaining_mult *= 128\n                else:\n                    if errnum == errno.EAGAIN or errnum == errno.EWOULDBLOCK:\n                        return NC.ERR_SUCCESS, bytes_received\n                    elif errnum == 0 and len(ba_data) == 0 or errnum == errno.ECONNRESET:\n                        return NC.ERR_CONN_LOST, bytes_received\n                    else:\n                        evt = event.EventNeterr(errnum, errmsg)\n                        self.push_event(evt)\n                        return NC.ERR_UNKNOWN, bytes_received\n                \n                if (byte & 128) == 0:\n                    loop_flag = False\n            \n            if self.in_packet.remaining_length > 0:\n                self.in_packet.payload = bytearray(self.in_packet.remaining_length)\n                if self.in_packet.payload is None:\n                    return NC.ERR_NO_MEM, bytes_received\n                self.in_packet.to_process = self.in_packet.remaining_length\n            \n            self.in_packet.have_remaining = True\n        \n        if self.in_packet.to_process > 0:\n            ba_data, errnum, errmsg = nyamuk_net.read(self.sock, self.in_packet.to_process)\n            if errnum == 0 and len(ba_data) > 0:\n                readlen = len(ba_data)\n                bytes_received += readlen\n                for idx in xrange(0, readlen):\n                    self.in_packet.payload[self.in_packet.pos] = ba_data[idx]\n                    self.in_packet.pos += 1\n                    self.in_packet.to_process -= 1\n            else:\n                if errnum == errno.EAGAIN or errnum == errno.EWOULDBLOCK:\n                        return NC.ERR_SUCCESS, bytes_received\n                elif errnum == 0 and len(ba_data) == 0 or errnum == errno.ECONNRESET:\n                    return NC.ERR_CONN_LOST, bytes_received\n                else:\n                    evt = event.EventNeterr(errnum, errmsg)\n                    self.push_event(evt)\n                    return NC.ERR_UNKNOWN, bytes_received\n\n        #all data for this packet is read\n        self.in_packet.pos = 0\n        \n        ret = self.packet_handle()\n        \n        self.in_packet.packet_cleanup()\n        \n        self.last_msg_in = time.time()\n        \n        return ret, bytes_received", "response": "Read packet from network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a simple mqtt command.", "response": "def send_simple_command(self, cmd):\n        \"\"\"Send simple mqtt commands.\"\"\"\n        pkt = MqttPkt()\n        \n        pkt.command = cmd\n        pkt.remaining_length = 0\n        \n        ret = pkt.alloc()\n        if ret != NC.ERR_SUCCESS:\n            return ret\n        \n        return self.packet_queue(pkt)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef real_ip(self):\n        if self._real_ip is None:\n            response = get(ICANHAZIP)\n            self._real_ip = self._get_response_text(response)\n\n        return self._real_ip", "response": "The actual public IP of this host."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_current_ip(self):\n        response = get(ICANHAZIP, proxies={\"http\": self.local_http_proxy})\n\n        if response.ok:\n            return self._get_response_text(response)\n\n        raise TorIpError(\"Failed to get the current Tor IP\")", "response": "Get the current IP Tor is using."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_new_ip(self):\n        attempts = 0\n\n        while True:\n            if attempts == self.new_ip_max_attempts:\n                raise TorIpError(\"Failed to obtain a new usable Tor IP\")\n\n            attempts += 1\n\n            try:\n                current_ip = self.get_current_ip()\n            except (RequestException, TorIpError):\n                self._obtain_new_ip()\n                continue\n\n            if not self._ip_is_usable(current_ip):\n                self._obtain_new_ip()\n                continue\n\n            self._manage_used_ips(current_ip)\n            break\n\n        return current_ip", "response": "Try to obtain a new usable TOR IP."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the current Tor s IP is usable.", "response": "def _ip_is_usable(self, current_ip):\n        \"\"\"\n        Check if the current Tor's IP is usable.\n\n        :argument current_ip: current Tor IP\n        :type current_ip: str\n\n        :returns bool\n        \"\"\"\n        # Consider IP addresses only.\n        try:\n            ipaddress.ip_address(current_ip)\n        except ValueError:\n            return False\n\n        # Never use real IP.\n        if current_ip == self.real_ip:\n            return False\n\n        # Do dot allow IP reuse.\n        if not self._ip_is_safe(current_ip):\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling registering and releasing used Tor IPs.", "response": "def _manage_used_ips(self, current_ip):\n        \"\"\"\n        Handle registering and releasing used Tor IPs.\n\n        :argument current_ip: current Tor IP\n        :type current_ip: str\n        \"\"\"\n        # Register current IP.\n        self.used_ips.append(current_ip)\n\n        # Release the oldest registred IP.\n        if self.reuse_threshold:\n            if len(self.used_ips) > self.reuse_threshold:\n                del self.used_ips[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_local_subsection(command_dict):\n    for local_com in ['if ', 'for ', 'else ']:\n        if list(command_dict.keys())[0].startswith(local_com):\n            return True\n    return False", "response": "Returns True if command dict is local subsection meaning\n    that it is local subsection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a processed request or raises an exception", "response": "def _process_req_txt(req):\n    '''Returns a processed request or raises an exception'''\n    if req.status_code == 404:\n        return ''\n    if req.status_code != 200:\n        raise DapiCommError('Response of the server was {code}'.format(code=req.status_code))\n    return req.text"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_from_dapi_or_mirror(link):\n    '''Tries to get the link form DAPI or the mirror'''\n    exception = False\n    try:\n        req = requests.get(_api_url() + link, timeout=5)\n    except requests.exceptions.RequestException:\n        exception = True\n    attempts = 1\n\n    while exception or str(req.status_code).startswith('5'):\n        if attempts > 5:\n            raise DapiCommError('Could not connect to the API endpoint, sorry.')\n        exception = False\n        try:\n            # Every second attempt, use the mirror\n            req = requests.get(_api_url(attempts % 2) + link, timeout=5*attempts)\n        except requests.exceptions.RequestException:\n            exception = True\n        attempts += 1\n\n    return req", "response": "Tries to get the link form DAPI or the mirror"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _remove_api_url_from_link(link):\n    '''Remove the API URL from the link if it is there'''\n    if link.startswith(_api_url()):\n        link = link[len(_api_url()):]\n    if link.startswith(_api_url(mirror=True)):\n        link = link[len(_api_url(mirror=True)):]\n    return link", "response": "Remove the API URL from the link if it is there"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary from a requested link", "response": "def data(link):\n    '''Returns a dictionary from requested link'''\n    link = _remove_api_url_from_link(link)\n    req = _get_from_dapi_or_mirror(link)\n    return _process_req(req)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary with all <what > unpaginated", "response": "def _unpaginated(what):\n    '''Returns a dictionary with all <what>, unpaginated'''\n    page = data(what)\n    results = page['results']\n    count = page['count']\n    while page['next']:\n        page = data(page['next'])\n        results += page['results']\n        count += page['count']\n    return {'results': results, 'count': count}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(q, **kwargs):\n    '''Returns a dictionary with the search results'''\n    data = {'q': q}\n    for key, value in kwargs.items():\n        if value:\n            if type(value) == bool:\n                data[key] = 'on'\n            else:\n                data[key] = value\n    return _unpaginated('search/?' + urlencode(data))", "response": "Returns a dictionary with the search results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a list of users available on Dapi", "response": "def format_users():\n    '''Formats a list of users available on Dapi'''\n    lines = []\n    u = users()\n    count = u['count']\n    if not count:\n        raise DapiCommError('Could not find any users on DAPI.')\n    for user in u['results']:\n        line = user['username']\n        if user['full_name']:\n            line += ' (' + user['full_name'] + ')'\n        lines.append(line)\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a list of metadaps available on Dapi", "response": "def format_daps(simple=False, skip_installed=False):\n    '''Formats a list of metadaps available on Dapi'''\n    lines= []\n    m = metadaps()\n    if not m['count']:\n        logger.info('Could not find any daps')\n        return\n    for mdap in sorted(m['results'], key=lambda mdap: mdap['package_name']):\n        if skip_installed and mdap['package_name'] in get_installed_daps():\n            continue\n        if simple:\n            logger.info(mdap['package_name'])\n        else:\n            for line in _format_dap_with_description(mdap):\n                lines.append(line)\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_metadap_dap(name, version=''):\n    '''Return data for dap of given or latest version.'''\n    m = metadap(name)\n    if not m:\n        raise DapiCommError('DAP {dap} not found.'.format(dap=name))\n    if not version:\n        d = m['latest_stable'] or m['latest']\n        if d:\n            d = data(d)\n    else:\n        d = dap(name, version)\n        if not d:\n            raise DapiCommError(\n                'DAP {dap} doesn\\'t have version {version}.'.format(dap=name, version=version))\n    return m, d", "response": "Return data for given dap of given or latest version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting information about given DAP from DAPI in a human readable form to list of lines", "response": "def format_dap_from_dapi(name, version='', full=False):\n    '''Formats information about given DAP from DAPI in a human readable form to list of lines'''\n    lines = []\n    m, d = _get_metadap_dap(name, version)\n\n    if d:\n        # Determining label width\n        labels = BASIC_LABELS + ['average_rank'] # average_rank comes from m, not d\n        if full:\n            labels.extend(EXTRA_LABELS)\n        label_width = dapi.DapFormatter.calculate_offset(labels)\n\n        # Metadata\n        lines += dapi.DapFormatter.format_meta_lines(d, labels=labels, offset=label_width)\n        lines.append(dapi.DapFormatter.format_dapi_score(m, offset=label_width))\n\n        if 'assistants' in d:\n            # Assistants\n            assistants = sorted([a for a in d['assistants'] if a.startswith('assistants')])\n            lines.append('')\n            for line in dapi.DapFormatter.format_assistants_lines(assistants):\n                lines.append(line)\n\n            # Snippets\n            if full:\n                snippets = sorted([a for a in d['assistants'] if a.startswith('snippets')])\n                lines.append('')\n                lines += dapi.DapFormatter.format_snippets(snippets)\n\n        # Supported platforms\n        if d.get('supported_platforms', ''):\n            lines.append('')\n            lines += dapi.DapFormatter.format_platforms(d['supported_platforms'])\n\n        lines.append('')\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_local_dap(dap, full=False, **kwargs):\n    '''Formaqts information about the given local DAP in a human readable form to list of lines'''\n    lines = []\n\n    # Determining label width\n    label_width = dapi.DapFormatter.calculate_offset(BASIC_LABELS)\n\n    # Metadata\n    lines.append(dapi.DapFormatter.format_meta(dap.meta, labels=BASIC_LABELS,\n                                               offset=label_width, **kwargs))\n\n    # Assistants\n    lines.append('')\n    lines.append(dapi.DapFormatter.format_assistants(dap.assistants))\n\n    # Snippets\n    if full:\n        lines.append('')\n        lines.append(dapi.DapFormatter.format_snippets(dap.snippets))\n\n    # Supported platforms\n    if 'supported_platforms' in dap.meta:\n        lines.append('')\n        lines.append(dapi.DapFormatter.format_platforms(dap.meta['supported_platforms']))\n\n    lines.append()\n    return lines", "response": "Format a local DAP in a human readable form to list of lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_installed_dap(name, full=False):\n    '''Formats information about an installed DAP in a human readable form to list of lines'''\n    dap_data = get_installed_daps_detailed().get(name)\n    if not dap_data:\n        raise DapiLocalError('DAP \"{dap}\" is not installed, can not query for info.'.format(dap=name))\n\n    locations = [os.path.join(data['location'], '') for data in dap_data]\n    for location in locations:\n        dap = dapi.Dap(None, fake=True, mimic_filename=name)\n        meta_path = os.path.join(location, 'meta', name + '.yaml')\n        with open(meta_path, 'r') as fh:\n            dap.meta = dap._load_meta(fh)\n        dap.files = _get_assistants_snippets(location, name)\n        dap._find_bad_meta()\n\n        format_local_dap(dap, full=full, custom_location=os.path.dirname(location))", "response": "Formats information about an installed DAP in a human readable form to list of lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_installed_dap_list(simple=False):\n    '''Formats all installed DAPs in a human readable form to list of lines'''\n    lines = []\n    if simple:\n        for pkg in sorted(get_installed_daps()):\n            lines.append(pkg)\n    else:\n        for pkg, instances in sorted(get_installed_daps_detailed().items()):\n            versions = []\n            for instance in instances:\n                location = utils.unexpanduser(instance['location'])\n                version = instance['version']\n                if not versions:  # if this is the first\n                    version = utils.bold(version)\n                versions.append('{v}:{p}'.format(v=version, p=location))\n            pkg = utils.bold(pkg)\n            lines.append('{pkg} ({versions})'.format(pkg=pkg, versions=' '.join(versions)))\n    return lines", "response": "Formats all installed DAPs in a human readable form to list of lines"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting Assistants and Snippets for a given DAP name on a given path", "response": "def _get_assistants_snippets(path, name):\n    '''Get Assistants and Snippets for a given DAP name on a given path'''\n    result = []\n    subdirs = {'assistants': 2, 'snippets': 1} # Values used for stripping leading path tokens\n\n    for loc in subdirs:\n        for root, dirs, files in os.walk(os.path.join(path, loc)):\n            for filename in [utils.strip_prefix(os.path.join(root, f), path) for f in files]:\n                stripped = os.path.sep.join(filename.split(os.path.sep)[subdirs[loc]:])\n                if stripped.startswith(os.path.join(name, '')) or stripped == name + '.yaml':\n                    result.append(os.path.join('fakeroot', filename))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_search(q, **kwargs):\n    '''Formats the results of a search'''\n    m = search(q, **kwargs)\n    count = m['count']\n    if not count:\n        raise DapiCommError('Could not find any DAP packages for your query.')\n        return\n    for mdap in m['results']:\n        mdap = mdap['content_object']\n        return _format_dap_with_description(mdap)", "response": "Formats the results of a search"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a set of all installed daps Either in the given location or in all of them", "response": "def get_installed_daps(location=None, skip_distro=False):\n    '''Returns a set of all installed daps\n    Either in the given location or in all of them'''\n    if location:\n        locations = [location]\n    else:\n        locations = _data_dirs()\n    s = set()\n    for loc in locations:\n        if skip_distro and loc == DISTRO_DIRECTORY:\n            continue\n        g = glob.glob('{d}/meta/*.yaml'.format(d=loc))\n        for meta in g:\n            s.add(meta.split('/')[-1][:-len('.yaml')])\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_installed_daps_detailed():\n    '''Returns a dictionary with all installed daps and their versions and locations\n    First version and location in the dap's list is the one that is preferred'''\n    daps = {}\n    for loc in _data_dirs():\n        s = get_installed_daps(loc)\n        for dap in s:\n            if dap not in daps:\n                daps[dap] = []\n            daps[dap].append({'version': get_installed_version_of(dap, loc), 'location': loc})\n    return daps", "response": "Returns a dictionary with all installed daps and their versions and locations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_dap(name, version='', d='', directory=''):\n    '''Download a dap to a given or temporary directory\n    Return a path to that file together with information if the directory should be later deleted\n    '''\n    if not d:\n        m, d = _get_metadap_dap(name, version)\n    if directory:\n        _dir = directory\n    else:\n        _dir = tempfile.mkdtemp()\n    try:\n        url = d['download']\n    except TypeError:\n        raise DapiCommError('DAP {dap} has no version to download.'.format(dap=name))\n    filename = url.split('/')[-1]\n    path = os.path.join(_dir, filename)\n    urllib.request.urlretrieve(url, path)\n    dapisum = d['sha256sum']\n    downloadedsum = hashlib.sha256(open(path, 'rb').read()).hexdigest()\n    if dapisum != downloadedsum:\n        os.remove(path)\n        raise DapiLocalError(\n            'DAP {dap} has incorrect sha256sum (DAPI: {dapi}, downloaded: {downloaded})'.\n            format(dap=name, dapi=dapisum, downloaded=downloadedsum))\n    return path, not bool(directory)", "response": "Download a dap to a given or temporary directory returning a path to that file together with information if the directory should be later deleted\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls a dap from a given path.", "response": "def install_dap_from_path(path, update=False, update_allpaths=False, first=True,\n                          force=False, nodeps=False, reinstall=False, __ui__=''):\n    '''Installs a dap from a given path'''\n    will_uninstall = False\n    dap_obj = dapi.Dap(path)\n    name = dap_obj.meta['package_name']\n\n    if name in get_installed_daps():\n        if not update and not reinstall:\n            raise DapiLocalError(\n                'DAP {name} is already installed. '\n                'Run `da pkg list` to see it\\'s location, or use --reinstall to ignore this check.'\n                .format(name=name))\n        elif not update_allpaths and name in get_installed_daps(_install_path()):\n            will_uninstall = True\n        elif update_allpaths and name in get_installed_daps():\n            will_uninstall = True\n\n    if update and update_allpaths:\n        install_locations = []\n        for pair in get_installed_daps_detailed()[name]:\n            install_locations.append(pair['location'])\n    else:\n        install_locations = [_install_path()]\n\n    # This should not happen unless someone did it on purpose\n    for location in install_locations:\n        if os.path.isfile(location):\n            raise DapiLocalError(\n                '{i} is a file, not a directory.'.format(i=_install_path()))\n\n    _dir = tempfile.mkdtemp()\n\n    old_level = logger.getEffectiveLevel()\n    logger.setLevel(logging.ERROR)\n    ok = dapi.DapChecker.check(dap_obj)\n    logger.setLevel(old_level)\n\n    if not ok:\n        raise DapiLocalError('The DAP you want to install has errors, not installing.')\n\n    installed = []\n    if first:\n        if not force and not _is_supported_here(dap_obj.meta):\n            raise DapiLocalError(\n                '{0} is not supported on this platform (use --force to suppress this check)'.\n                format(name))\n\n        deps = set()\n        if 'dependencies' in dap_obj.meta and not nodeps:\n            for dep in dap_obj.meta['dependencies']:\n                dep = _strip_version_from_dependency(dep)\n                if dep not in get_installed_daps():\n                    deps |= _get_all_dependencies_of(dep, force=force)\n            for dep in deps:\n                if dep not in get_installed_daps():\n                    installed += install_dap(dep, first=False, __ui__=__ui__)\n\n    dap_obj.extract(_dir)\n\n    if will_uninstall:\n        uninstall_dap(name, allpaths=update_allpaths, __ui__=__ui__)\n\n    _dapdir = os.path.join(_dir, name + '-' + dap_obj.meta['version'])\n\n    if not os.path.isdir(_install_path()):\n        os.makedirs(_install_path())\n\n    os.mkdir(os.path.join(_dapdir, 'meta'))\n    os.rename(os.path.join(_dapdir, 'meta.yaml'),\n              os.path.join(_dapdir, 'meta', name + '.yaml'))\n\n    for location in install_locations:\n        for f in glob.glob(_dapdir + '/*'):\n            dst = os.path.join(location, os.path.basename(f))\n            if os.path.isdir(f):\n                if not os.path.exists(dst):\n                    os.mkdir(dst)\n                for src_dir, dirs, files in os.walk(f):\n                    dst_dir = src_dir.replace(f, dst)\n                    if not os.path.exists(dst_dir):\n                        os.mkdir(dst_dir)\n                    for file_ in files:\n                        src_file = os.path.join(src_dir, file_)\n                        dst_file = os.path.join(dst_dir, file_)\n                        shutil.copyfile(src_file, dst_file)\n            else:\n                shutil.copyfile(f, dst)\n    try:\n        shutil.rmtree(_dir)\n    except:\n        pass\n\n    return [name] + installed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_installed_version_of(name, location=None):\n    '''Gets the installed version of the given dap or None if not installed\n    Searches in all dirs by default, otherwise in the given one'''\n    if location:\n        locations = [location]\n    else:\n        locations = _data_dirs()\n\n    for loc in locations:\n        if name not in get_installed_daps(loc):\n            continue\n        meta = '{d}/meta/{dap}.yaml'.format(d=loc, dap=name)\n        data = yaml.load(open(meta), Loader=Loader)\n        return str(data['version'])\n    return None", "response": "Gets the installed version of the given dap or None if not installed\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns list of first level dependencies of the given dap or dap from Dapi", "response": "def _get_dependencies_of(name, location=None):\n    '''\n    Returns list of first level dependencies of the given installed dap\n    or dap from Dapi  if not installed\n    If a location is specified, this only checks for dap installed in that path\n    and return [] if the dap is not located there\n    '''\n    if not location:\n        detailed_dap_list = get_installed_daps_detailed()\n        if name not in detailed_dap_list:\n            return _get_api_dependencies_of(name)\n        location = detailed_dap_list[name][0]['location']\n\n    meta = '{d}/meta/{dap}.yaml'.format(d=location, dap=name)\n    try:\n        data = yaml.load(open(meta), Loader=Loader)\n    except IOError:\n        return []\n    return data.get('dependencies', [])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns list of dependencies of the given dap from Dapi recursively", "response": "def _get_all_dependencies_of(name, deps=set(), force=False):\n    '''Returns list of dependencies of the given dap from Dapi recursively'''\n    first_deps = _get_api_dependencies_of(name, force=force)\n    for dep in first_deps:\n        dep = _strip_version_from_dependency(dep)\n        if dep in deps:\n            continue\n        # we do the following not to resolve the dependencies of already installed daps\n        if dap in get_installed_daps():\n            continue\n        deps |= _get_all_dependencies_of(dep, deps)\n    return deps | set([name])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list of first level dependencies of the given dap from Dapi", "response": "def _get_api_dependencies_of(name, version='', force=False):\n    '''Returns list of first level dependencies of the given dap from Dapi'''\n    m, d = _get_metadap_dap(name, version=version)\n    # We need the dependencies to install the dap,\n    # if the dap is unsupported, raise an exception here\n    if not force and not _is_supported_here(d):\n        raise DapiLocalError(\n            '{0} is not supported on this platform (use --force to suppress this check).'.\n            format(name))\n    return d.get('dependencies', [])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninstalling a dap from dapi", "response": "def install_dap(name, version='', update=False, update_allpaths=False, first=True,\n                force=False, nodeps=False, reinstall=False, __ui__=''):\n    '''Install a dap from dapi\n    If update is True, it will remove previously installed daps of the same name'''\n    m, d = _get_metadap_dap(name, version)\n    if update:\n        available = d['version']\n        current = get_installed_version_of(name)\n        if not current:\n            raise DapiLocalError('Cannot update not yet installed DAP.')\n        if dapver.compare(available, current) <= 0:\n            return []\n    path, remove_dir = download_dap(name, d=d)\n\n    ret = install_dap_from_path(path, update=update, update_allpaths=update_allpaths, first=first,\n                                force=force, nodeps=nodeps, reinstall=reinstall, __ui__=__ui__)\n\n    try:\n        if remove_dir:\n            shutil.rmtree(os.dirname(path))\n        else:\n            os.remove(path)\n    except:\n        pass\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_dependency_metadata():\n    '''Returns list of strings with dependency metadata from Dapi'''\n    link = os.path.join(_api_url(), 'meta.txt')\n    return _process_req_txt(requests.get(link)).split('\\n')", "response": "Returns list of strings with dependency metadata from Dapi"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_box(self, orientation=Gtk.Orientation.HORIZONTAL, spacing=0):\n        h_box = Gtk.Box(orientation=orientation, spacing=spacing)\n        h_box.set_homogeneous(False)\n        return h_box", "response": "Function creates box based on orientation\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef button_with_label(self, description, assistants=None):\n        btn = self.create_button()\n        label = self.create_label(description)\n        if assistants is not None:\n            h_box = self.create_box(orientation=Gtk.Orientation.VERTICAL)\n            h_box.pack_start(label, False, False, 0)\n            label_ass = self.create_label(\n                assistants, justify=Gtk.Justification.LEFT\n            )\n            label_ass.set_alignment(0, 0)\n            h_box.pack_start(label_ass, False, False, 12)\n            btn.add(h_box)\n        else:\n            btn.add(label)\n        return btn", "response": "Function creates a button with label"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a button with image", "response": "def button_with_image(self, description, image=None, sensitive=True):\n        \"\"\"\n            The function creates a button with image\n        \"\"\"\n        btn = self.create_button()\n        btn.set_sensitive(sensitive)\n        h_box = self.create_box()\n        try:\n            img = self.create_image(image_name=image,\n                                    scale_ratio=btn.get_scale_factor(),\n                                    window=btn.get_window())\n        except: # Older GTK+ than 3.10\n            img = self.create_image(image_name=image)\n        h_box.pack_start(img, False, False, 12)\n        label = self.create_label(description)\n        h_box.pack_start(label, False, False, 0)\n        btn.add(h_box)\n        return btn"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef checkbutton_with_label(self, description):\n        act_btn = Gtk.CheckButton(description)\n        align = self.create_alignment()\n        act_btn.add(align)\n        return align", "response": "Function creates a checkbutton with label"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_checkbox(self, name, margin=10):\n        chk_btn = Gtk.CheckButton(name)\n        chk_btn.set_margin_right(margin)\n        return chk_btn", "response": "Function creates a checkbox with his name and margin right"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_entry(self, text=\"\", sensitive=\"False\"):\n        text_entry = Gtk.Entry()\n        text_entry.set_sensitive(sensitive)\n        text_entry.set_text(text)\n        return text_entry", "response": "Function creates an Entry with corresponding text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_link_button(self, text=\"None\", uri=\"None\"):\n        link_btn = Gtk.LinkButton(uri, text)\n        return link_btn", "response": "Function creates a link button with corresponding text and uri"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_button(self, style=Gtk.ReliefStyle.NORMAL):\n        btn = Gtk.Button()\n        btn.set_relief(style)\n        return btn", "response": "This method creates a Gtk. Button object with the specified style."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction creates a menu item with an image", "response": "def create_image_menu_item(self, text, image_name):\n        \"\"\"\n        Function creates a menu item with an image\n        \"\"\"\n        menu_item = Gtk.ImageMenuItem(text)\n        img = self.create_image(image_name)\n        menu_item.set_image(img)\n        return menu_item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_label(self, name, justify=Gtk.Justification.CENTER, wrap_mode=True, tooltip=None):\n        label = Gtk.Label()\n        name = name.replace('|', '\\n')\n        label.set_markup(name)\n        label.set_justify(justify)\n        label.set_line_wrap(wrap_mode)\n        if tooltip is not None:\n            label.set_has_tooltip(True)\n            label.connect(\"query-tooltip\", self.parent.tooltip_queries, tooltip)\n        return label", "response": "Function creates a label with the given name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_install_button(self, grid_lang, row, column):\n        btn = self.button_with_label('<b>Install more...</b>')\n        if row == 0 and column == 0:\n            grid_lang.add(btn)\n        else:\n            grid_lang.attach(btn, column, row, 1, 1)\n        btn.connect(\"clicked\", self.parent.install_btn_clicked)\n        return btn", "response": "Add button that opens the window for installing more assistants"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a menu item based on the given assistant and path.", "response": "def menu_item(self, sub_assistant, path):\n        \"\"\"\n        The function creates a menu item\n        and assigns signal like select and button-press-event for\n        manipulation with menu_item. sub_assistant and path\n        \"\"\"\n        if not sub_assistant[0].icon_path:\n            menu_item = self.create_menu_item(sub_assistant[0].fullname)\n        else:\n            menu_item = self.create_image_menu_item(\n                sub_assistant[0].fullname, sub_assistant[0].icon_path\n            )\n        if sub_assistant[0].description:\n            menu_item.set_has_tooltip(True)\n            menu_item.connect(\"query-tooltip\",\n                              self.parent.tooltip_queries,\n                              self.get_formatted_description(sub_assistant[0].description),\n            )\n        menu_item.connect(\"select\", self.parent.sub_menu_select, path)\n        menu_item.connect(\"button-press-event\", self.parent.sub_menu_pressed)\n        menu_item.show()\n        return menu_item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_menu(self, ass, text, path=None, level=0):\n        menu = self.create_menu()\n        for index, sub in enumerate(sorted(ass[1], key=lambda y: y[0].fullname.lower())):\n            if index != 0:\n                text += \"|\"\n            text += \"- \" + sub[0].fullname\n            new_path = list(path)\n            if level == 0:\n                new_path.append(ass[0].name)\n            new_path.append(sub[0].name)\n            menu_item = self.menu_item(sub, new_path)\n            if sub[1]:\n                # If assistant has subassistants\n                (sub_menu, txt) = self.generate_menu(sub, text, new_path, level=level + 1)\n                menu_item.set_submenu(sub_menu)\n            menu.append(menu_item)\n        return menu, text", "response": "Function generates menu based on assistant parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_submenu(self, grid_lang, ass, row, column):\n        text = \"Available subassistants:\\n\"\n        # Generate menus\n        path = []\n        (menu, text) = self.generate_menu(ass, text, path=path)\n        menu.show_all()\n        if ass[0].description:\n            description = self.get_formatted_description(ass[0].description) + \"\\n\\n\"\n        else:\n            description = \"\"\n        description += text.replace('|', '\\n')\n        image_name = ass[0].icon_path\n        lbl_text = \"<b>\" + ass[0].fullname + \"</b>\"\n        if not image_name:\n            btn = self.button_with_label(lbl_text)\n        else:\n            btn = self.button_with_image(lbl_text, image=image_name)\n        btn.set_has_tooltip(True)\n        btn.connect(\"query-tooltip\",\n                    self.parent.tooltip_queries,\n                    description\n        )\n        btn.connect_object(\"event\", self.parent.btn_press_event, menu)\n        if row == 0 and column == 0:\n            grid_lang.add(btn)\n        else:\n            grid_lang.attach(btn, column, row, 1, 1)", "response": "Function is used for creating a menu and submenu."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning creates a scrolled window with a layout manager", "response": "def create_scrolled_window(self, layout_manager, horizontal=Gtk.PolicyType.NEVER, vertical=Gtk.PolicyType.ALWAYS):\n        \"\"\"\n        Function creates a scrolled window with layout manager\n        \"\"\"\n        scrolled_window = Gtk.ScrolledWindow()\n        scrolled_window.add(layout_manager)\n        scrolled_window.set_policy(horizontal, vertical)\n        return scrolled_window"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_gtk_grid(self, row_spacing=6, col_spacing=6, row_homogenous=False, col_homogenous=True):\n        grid_lang = Gtk.Grid()\n        grid_lang.set_column_spacing(row_spacing)\n        grid_lang.set_row_spacing(col_spacing)\n        grid_lang.set_border_width(12)\n        grid_lang.set_row_homogeneous(row_homogenous)\n        grid_lang.set_column_homogeneous(col_homogenous)\n        return grid_lang", "response": "Function creates a Gtk Grid with spacing row_spacing and col_spacing and homogeous tags\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions creates a notebook", "response": "def create_notebook(self, position=Gtk.PositionType.TOP):\n        \"\"\"\n        Function creates a notebook\n        \"\"\"\n        notebook = Gtk.Notebook()\n        notebook.set_tab_pos(position)\n        notebook.set_show_border(True)\n        return notebook"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_message_dialog(self, text, buttons=Gtk.ButtonsType.CLOSE, icon=Gtk.MessageType.WARNING):\n        dialog = Gtk.MessageDialog(None,\n                                   Gtk.DialogFlags.DESTROY_WITH_PARENT,\n                                   icon,\n                                   buttons,\n                                   text\n        )\n        return dialog", "response": "Function creates a message dialog with text and buttons"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction creates a question dialog with title text and second_text", "response": "def create_question_dialog(self, text, second_text):\n        \"\"\"\n        Function creates a question dialog with title text\n        and second_text\n        \"\"\"\n        dialog = self.create_message_dialog(\n            text, buttons=Gtk.ButtonsType.YES_NO, icon=Gtk.MessageType.QUESTION\n        )\n        dialog.format_secondary_text(second_text)\n        response = dialog.run()\n        dialog.destroy()\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning executes a dialog", "response": "def execute_dialog(self, title):\n        \"\"\"\n        Function executes a dialog\n        \"\"\"\n        msg_dlg = self.create_message_dialog(title)\n        msg_dlg.run()\n        msg_dlg.destroy()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction creates a file chooser dialog with title text", "response": "def create_file_chooser_dialog(self, text, parent, name=Gtk.STOCK_OPEN):\n        \"\"\"\n        Function creates a file chooser dialog with title text\n        \"\"\"\n        text = None\n        dialog = Gtk.FileChooserDialog(\n            text, parent,\n            Gtk.FileChooserAction.SELECT_FOLDER,\n            (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, name, Gtk.ResponseType.OK)\n        )\n        response = dialog.run()\n        if response == Gtk.ResponseType.OK:\n            text = dialog.get_filename()\n        dialog.destroy()\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions creates an alignment", "response": "def create_alignment(self, x_align=0, y_align=0, x_scale=0, y_scale=0):\n        \"\"\"\n        Function creates an alignment\n        \"\"\"\n        align = Gtk.Alignment()\n        align.set(x_align, y_align, x_scale, y_scale)\n        return align"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_textview(self, wrap_mode=Gtk.WrapMode.WORD_CHAR, justify=Gtk.Justification.LEFT, visible=True, editable=True):\n        text_view = Gtk.TextView()\n        text_view.set_wrap_mode(wrap_mode)\n        text_view.set_editable(editable)\n        if not editable:\n            text_view.set_cursor_visible(False)\n        else:\n            text_view.set_cursor_visible(visible)\n        text_view.set_justification(justify)\n        return text_view", "response": "Function creates a text view with wrap_mode and justification"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction creates a tree_view with model", "response": "def create_tree_view(self, model=None):\n        \"\"\"\n        Function creates a tree_view with model\n        \"\"\"\n        tree_view = Gtk.TreeView()\n        if model is not None:\n            tree_view.set_model(model)\n        return tree_view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_cell_renderer_text(self, tree_view, title=\"title\", assign=0, editable=False):\n        renderer = Gtk.CellRendererText()\n        renderer.set_property('editable', editable)\n        column = Gtk.TreeViewColumn(title, renderer, text=assign)\n        tree_view.append_column(column)", "response": "Function creates a CellRendererText with title"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction creates a CellRendererCombo with title model and function", "response": "def create_cell_renderer_combo(self, tree_view, title=\"title\", assign=0, editable=False, model=None, function=None):\n        \"\"\"'\n        Function creates a CellRendererCombo with title, model\n        \"\"\"\n        renderer_combo = Gtk.CellRendererCombo()\n        renderer_combo.set_property('editable', editable)\n        if model:\n            renderer_combo.set_property('model', model)\n        if function:\n            renderer_combo.connect(\"edited\", function)\n        renderer_combo.set_property(\"text-column\", 0)\n        renderer_combo.set_property(\"has-entry\", False)\n        column = Gtk.TreeViewColumn(title, renderer_combo, text=assign)\n        tree_view.append_column(column)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction creates a clipboard with text", "response": "def create_clipboard(self, text, selection=Gdk.SELECTION_CLIPBOARD):\n        \"\"\"\n        Function creates a clipboard\n        \"\"\"\n        clipboard = Gtk.Clipboard.get(selection)\n        clipboard.set_text('\\n'.join(text), -1)\n        clipboard.store()\n        return clipboard"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_command(cls,\n                    cmd_str,\n                    log_level=logging.DEBUG,\n                    ignore_sigint=False,\n                    output_callback=None,\n                    as_user=None,\n                    log_secret=False,\n                    env=None):\n        \"\"\"Runs a command from string, e.g. \"cp foo bar\"\n        Args:\n            cmd_str: the command to run as string\n            log_level: level at which to log command output (DEBUG by default)\n            ignore_sigint: should we ignore sigint during this command (False by default)\n            output_callback: function that gets called with every line of output as argument\n            as_user: run as specified user (the best way to do this will be deduced by DA)\n                runs as current user if as_user == None\n            log_secret: if True, the command invocation will only be logged as\n                \"LOGGING PREVENTED FOR SECURITY REASONS\", no output will be logged\n            env: if not None, pass to subprocess as shell environment; else use\n                original DevAssistant environment\n        \"\"\"\n        # run format processors on cmd_str\n        for name, cmd_proc in cls.command_processors.items():\n            cmd_str = cmd_proc(cmd_str)\n\n        # TODO: how to do cd with as_user?\n        if as_user and not cmd_str.startswith('cd '):\n            cmd_str = cls.format_for_another_user(cmd_str, as_user)\n        cls.log(log_level, cmd_str, 'cmd_call', log_secret)\n\n        if cmd_str.startswith('cd '):\n            # special-case cd to behave like shell cd and stay in the directory\n            try:\n                directory = cmd_str[3:]\n                # delete any quotes, os.chdir doesn't split words like sh does\n                if directory[0] == directory[-1] == '\"':\n                    directory = directory[1:-1]\n                os.chdir(directory)\n            except OSError as e:\n                raise exceptions.ClException(cmd_str, 1, six.text_type(e))\n            return ''\n\n        stdin_pipe = None\n        stdout_pipe = subprocess.PIPE\n        stderr_pipe = subprocess.STDOUT\n        preexec_fn = cls.ignore_sigint if ignore_sigint else None\n        env = os.environ if env is None else env\n        proc = subprocess.Popen(cmd_str,\n                                stdin=stdin_pipe,\n                                stdout=stdout_pipe,\n                                stderr=stderr_pipe,\n                                shell=True,\n                                preexec_fn=preexec_fn,\n                                env=env)\n        # register process to cls.subprocesses\n        cls.subprocesses[proc.pid] = proc\n\n        stdout = []\n        while proc.poll() is None:\n            try:\n                output = proc.stdout.readline().decode(utils.defenc)\n                if output:\n                    output = output.strip()\n                    stdout.append(output)\n                    cls.log(log_level, output, 'cmd_out', log_secret)\n                if output_callback:\n                    output_callback(output)\n            except IOError as e:\n                if e.errno == errno.EINTR:  # Interrupted system call in Python 2.6\n                    sys.stderr.write('Can\\'t interrupt this process!\\n')\n                else:\n                    raise e\n\n        # remove process from cls.subprocesses\n        cls.subprocesses.pop(proc.pid)\n\n        # add a newline to the end - if there is more output in output_rest, we'll be appending\n        # it line by line; if there's no more output, we strip anyway\n        stdout = '\\n'.join(stdout) + '\\n'\n        # there may be some remains not read after exiting the previous loop\n        output_rest = proc.stdout.read().strip().decode(utils.defenc)\n        # we want to log lines separately, not as one big chunk\n        output_rest_lines = output_rest.splitlines()\n        for i, l in enumerate(output_rest_lines):\n            cls.log(log_level, l, 'cmd_out', log_secret)\n            # add newline for every line - for last line, only add it if it was originally present\n            if i != len(output_rest_lines) - 1 or output_rest.endswith('\\n'):\n                l += '\\n'\n            stdout += l\n            if output_callback:\n                output_callback(l)\n\n        # log return code always on debug level\n        cls.log(logging.DEBUG, proc.returncode, 'cmd_retcode', log_secret)\n        stdout = stdout.strip()\n\n        if proc.returncode == 0:\n            return stdout\n        else:\n            raise exceptions.ClException(cmd_str,\n                                         proc.returncode,\n                                         stdout)", "response": "Runs a command from string and returns a dictionary of the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nasks user for a password", "response": "def ask_for_password(cls, ui, prompt='Provide your password:', **options):\n        \"\"\"Returns the password typed by user as a string or None if user cancels the request\n        (e.g. presses Ctrl + D on commandline or presses Cancel in GUI.\n        \"\"\"\n        # optionally set title, that may be used by some helpers like zenity\n        return cls.get_appropriate_helper(ui).ask_for_password(prompt,\n                                                               title=options.get('title', prompt))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nasking user for confirmation with message", "response": "def ask_for_confirm_with_message(cls, ui, prompt='Do you agree?', message='', **options):\n        \"\"\"Returns True if user agrees, False otherwise\"\"\"\n        return cls.get_appropriate_helper(ui).ask_for_confirm_with_message(prompt, message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nasking user for written input with prompt", "response": "def ask_for_input_with_prompt(cls, ui, prompt='', **options):\n        \"\"\"Ask user for written input with prompt\"\"\"\n        return cls.get_appropriate_helper(ui).ask_for_input_with_prompt(prompt=prompt, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuses by cli to add this as an argument to parser.", "response": "def add_argument_to(self, parser):\n        \"\"\"Used by cli to add this as an argument to argparse parser.\n\n        Args:\n            parser: parser to add this argument to\n        \"\"\"\n        from devassistant.cli.devassistant_argparse import DefaultIffUsedActionFactory\n        if isinstance(self.kwargs.get('action', ''), list):\n            # see documentation of DefaultIffUsedActionFactory to see why this is necessary\n            if self.kwargs['action'][0] == 'default_iff_used':\n                self.kwargs['action'] = DefaultIffUsedActionFactory.generate_action(\n                    self.kwargs['action'][1])\n        # In cli 'preserved' is not supported.\n        # It needs to be removed because it is unknown for argparse.\n        self.kwargs.pop('preserved', None)\n        try:\n            parser.add_argument(*self.flags, **self.kwargs)\n        except Exception as ex:\n            problem = \"Error while adding argument '{name}': {error}\".\\\n                format(name=self.name, error=repr(ex))\n            raise exceptions.ExecutionException(problem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the value for the specified gui hint.", "response": "def get_gui_hint(self, hint):\n        \"\"\"Returns the value for specified gui hint (or a sensible default value,\n        if this argument doesn't specify the hint).\n\n        Args:\n            hint: name of the hint to get value for\n        Returns:\n            value of the hint specified in yaml or a sensible default\n        \"\"\"\n        if hint == 'type':\n            # 'self.kwargs.get('nargs') == 0' is there for default_iff_used, which may\n            # have nargs: 0, so that it works similarly to 'store_const'\n            if self.kwargs.get('action') == 'store_true' or self.kwargs.get('nargs') == 0:\n                return 'bool'\n            # store_const is represented by checkbox, but computes default differently\n            elif self.kwargs.get('action') == 'store_const':\n                return 'const'\n            return self.gui_hints.get('type', 'str')\n        elif hint == 'default':\n            hint_type = self.get_gui_hint('type')\n            hint_default = self.gui_hints.get('default', None)\n            arg_default = self.kwargs.get('default', None)\n            preserved_value = None\n            if 'preserved' in self.kwargs:\n                preserved_value = config_manager.get_config_value(self.kwargs['preserved'])\n\n            if hint_type == 'path':\n                if preserved_value is not None:\n                    default = preserved_value\n                elif hint_default is not None:\n                    default = hint_default.replace('$(pwd)', utils.get_cwd_or_homedir())\n                else:\n                    default = arg_default or '~'\n                return os.path.abspath(os.path.expanduser(default))\n            elif hint_type == 'bool':\n                return hint_default or arg_default or False\n            elif hint_type == 'const':\n                return hint_default or arg_default\n            else:\n                if hint_default == '$(whoami)':\n                    hint_default = getpass.getuser()\n                return preserved_value or hint_default or arg_default or ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef construct_arg(cls, name, params):\n        use_snippet = params.pop('use', None)\n        if use_snippet:\n            # if snippet is used, take this parameter from snippet and update\n            # it with current params, if any\n            try:\n                problem = None\n                snippet = yaml_snippet_loader.YamlSnippetLoader.get_snippet_by_name(use_snippet)\n                # this works much like snippet.args.pop(arg_name).update(arg_params),\n                # but unlike it, this actually returns the updated dict\n                params = dict(snippet.args.pop(name), **params)\n                # if there is SnippetNotFoundException, just let it be raised\n            except KeyError:  # snippet doesn't have the requested argument\n                problem = 'Couldn\\'t find arg {arg} in snippet {snip}.'.\\\n                    format(arg=name, snip=snippet.name)\n                raise exceptions.ExecutionException(problem)\n\n        if 'flags' not in params:\n            msg = 'Couldn\\'t find \"flags\" in arg {arg}'.format(arg=name)\n            raise exceptions.ExecutionException(msg)\n        return cls(name, *params.pop('flags'), **params)", "response": "Construct an argument from name and params."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_subassistants(self):\n        if not hasattr(self, '_subassistants'):\n            self._subassistants = []\n            # we want to know, if type(self) defines 'get_subassistant_classes',\n            # we don't want to inherit it from superclass (would cause recursion)\n            if 'get_subassistant_classes' in vars(type(self)):\n                for a in self.get_subassistant_classes():\n                    self._subassistants.append(a())\n        return self._subassistants", "response": "Return list of instantiated subassistants. Usually this needs not be overriden in subclasses you should just override get_subassistant_classes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subassistant_tree(self):\n        if '_tree' not in dir(self):\n            subassistant_tree = []\n            subassistants = self.get_subassistants()\n            for subassistant in subassistants:\n                subassistant_tree.append(subassistant.get_subassistant_tree())\n            self._tree = (self, subassistant_tree)\n        return self._tree", "response": "Returns a tree - like structure representing the assistant hierarchy going down\n            from this assistant to the leaf assistants."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_run_as_leaf(self, **kwargs):\n        # find the last subassistant_N\n        i = 0\n        while i < len(kwargs):  # len(kwargs) is maximum of subassistant_N keys\n            if settings.SUBASSISTANT_N_STRING.format(i) in kwargs:\n                leaf_name = kwargs[settings.SUBASSISTANT_N_STRING.format(i)]\n            i += 1\n\n        return self.name == leaf_name", "response": "Returns True if this assistant was run as last in path False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_all_yamls(cls, directories):\n        yaml_files = []\n        loaded_yamls = {}\n\n        for d in directories:\n            if d.startswith('/home') and not os.path.exists(d):\n                os.makedirs(d)\n            for dirname, subdirs, files in os.walk(d):\n                yaml_files.extend(map(lambda x: os.path.join(dirname, x),\n                                      filter(lambda x: x.endswith('.yaml'), files)))\n\n        for f in yaml_files:\n            loaded_yamls[f] = cls.load_yaml_by_path(f)\n\n        return loaded_yamls", "response": "Loads yaml files from all given directories."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a yaml file with path that is relative to one of given directories.", "response": "def load_yaml_by_relpath(cls, directories, rel_path, log_debug=False):\n        \"\"\"Load a yaml file with path that is relative to one of given directories.\n\n        Args:\n            directories: list of directories to search\n            name: relative path of the yaml file to load\n            log_debug: log all messages as debug\n        Returns:\n            tuple (fullpath, loaded yaml structure) or None if not found\n        \"\"\"\n        for d in directories:\n            if d.startswith(os.path.expanduser('~')) and not os.path.exists(d):\n                os.makedirs(d)\n            possible_path = os.path.join(d, rel_path)\n            if os.path.exists(possible_path):\n                loaded = cls.load_yaml_by_path(possible_path, log_debug=log_debug)\n                if loaded is not None:\n                    return (possible_path, cls.load_yaml_by_path(possible_path))\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_yaml_by_path(cls, path, log_debug=False):\n        try:\n            if isinstance(path, six.string_types):\n                return yaml.load(open(path, 'r'), Loader=Loader) or {}\n            else:\n                return yaml.load(path, Loader=Loader) or {}\n        except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:\n            log_level = logging.DEBUG if log_debug else logging.WARNING\n            logger.log(log_level, 'Yaml error in {path} (line {ln}, column {col}): {err}'.\n                       format(path=path,\n                              ln=e.problem_mark.line,\n                              col=e.problem_mark.column,\n                              err=e.problem))\n            return None", "response": "Load a yaml file that is at given path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run_path_dependencies(self, parsed_args):\n        deps = self.path[-1].dependencies(parsed_args)\n\n        lang.Command('dependencies', deps, parsed_args).run()", "response": "Installs dependencies from the leaf assistant."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        error = None\n        # run 'pre_run', 'logging', 'dependencies' and 'run'\n        try:  # serve as a central place for error logging\n            self._logging(self.parsed_args)\n            if 'deps_only' not in self.parsed_args:\n                self._run_path_run('pre', self.parsed_args)\n            self._run_path_dependencies(self.parsed_args)\n            if 'deps_only' not in self.parsed_args:\n                self._run_path_run('', self.parsed_args)\n        except exceptions.ExecutionException as e:\n            error = self._log_if_not_logged(e)\n            if isinstance(e, exceptions.YamlError):  # if there's a yaml error, just shut down\n                raise e\n\n        # in any case, run post_run\n        try:  # serve as a central place for error logging\n            self._run_path_run('post', self.parsed_args)\n        except exceptions.ExecutionException as e:\n            error = self._log_if_not_logged(e)\n\n        # exitfuncs are run all regardless of exceptions; if there is an exception in one\n        #  of them, this function will raise it at the end\n        try:\n            utils.run_exitfuncs()\n        except exceptions.ExecutionException as e:\n            error = self._log_if_not_logged(e)\n\n        if error:\n            raise error", "response": "Runs all errors dependencies and run methods of all Assistant objects in self. path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the maximum length of the provided strings that have a nice variant in DapFormatter. _nice_strings", "response": "def calculate_offset(cls, labels):\n        '''Return the maximum length of the provided strings that have a nice\n        variant in DapFormatter._nice_strings'''\n        used_strings = set(cls._nice_strings.keys()) & set(labels)\n        return max([len(cls._nice_strings[s]) for s in used_strings])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the line with DAPI user rating and number of votes", "response": "def format_dapi_score(cls, meta, offset):\n        '''Format the line with DAPI user rating and number of votes'''\n        if 'average_rank' and 'rank_count' in meta:\n            label = (cls._nice_strings['average_rank'] + ':').ljust(offset + 2)\n            score = cls._format_field(meta['average_rank'])\n            votes = ' ({num} votes)'.format(num=meta['rank_count'])\n            return label + score + votes\n        else:\n            return ''"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_meta_lines(cls, meta, labels, offset, **kwargs):\n        '''Return all information from a given meta dictionary in a list of lines'''\n        lines = []\n\n        # Name and underline\n        name = meta['package_name']\n        if 'version' in meta:\n            name += '-' + meta['version']\n        if 'custom_location' in kwargs:\n            name += ' ({loc})'.format(loc=kwargs['custom_location'])\n\n        lines.append(name)\n        lines.append(len(name)*'=')\n        lines.append('')\n\n        # Summary\n        lines.extend(meta['summary'].splitlines())\n        lines.append('')\n\n        # Description\n        if meta.get('description', ''):\n            lines.extend(meta['description'].splitlines())\n            lines.append('')\n\n\n        # Other metadata\n        data = []\n        for item in labels:\n            if meta.get(item, '') != '': # We want to process False and 0\n                label = (cls._nice_strings[item] + ':').ljust(offset + 2)\n                data.append(label + cls._format_field(meta[item]))\n\n        lines.extend(data)\n\n        return lines", "response": "Return all information from a given meta dictionary in a list of lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats the list of files in this DAP", "response": "def _format_files(cls, files, kind):\n        '''Format the list of files (e. g. assistants or snippets'''\n        lines = []\n        if files:\n            lines.append('The following {kind} are contained in this DAP:'.format(kind=kind.title()))\n            for f in files:\n                lines.append('* ' + strip_prefix(f, kind).replace(os.path.sep, ' ').strip())\n            return lines\n        else:\n            return ['No {kind} are contained in this DAP'.format(kind=kind.title())]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning formatted assistants from the given list in human readable form.", "response": "def format_assistants_lines(cls, assistants):\n        '''Return formatted assistants from the given list in human readable form.'''\n        lines = cls._format_files(assistants, 'assistants')\n\n        # Assistant help\n        if assistants:\n            lines.append('')\n            assistant = strip_prefix(random.choice(assistants), 'assistants').replace(os.path.sep, ' ').strip()\n            if len(assistants) == 1:\n                strings = ['After you install this DAP, you can find help about the Assistant',\n                           'by running \"da {a} -h\" .']\n            else:\n                strings = ['After you install this DAP, you can find help, for example about the Assistant',\n                           '\"{a}\", by running \"da {a} -h\".']\n            lines.extend([l.format(a=assistant) for l in strings])\n\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats supported platforms in human readable form", "response": "def format_platforms(cls, platforms):\n        '''Formats supported platforms in human readable form'''\n        lines = []\n        if platforms:\n            lines.append('This DAP is only supported on the following platforms:')\n            lines.extend([' * ' + platform for platform in platforms])\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the dap is valid reports problems", "response": "def check(cls, dap, network=False, yamls=True, raises=False, logger=logger):\n        '''Checks if the dap is valid, reports problems\n\n        Parameters:\n            network -- whether to run checks that requires network connection\n            output -- where to write() problems, might be None\n            raises -- whether to raise an exception immediately after problem is detected'''\n        dap._check_raises = raises\n        dap._problematic = False\n        dap._logger = logger\n        problems = list()\n\n        problems += cls.check_meta(dap)\n        problems += cls.check_no_self_dependency(dap)\n        problems += cls.check_topdir(dap)\n        problems += cls.check_files(dap)\n\n        if yamls:\n            problems += cls.check_yamls(dap)\n\n        if network:\n            problems += cls.check_name_not_on_dapi(dap)\n\n        for problem in problems:\n            dap._report_problem(problem.message, problem.level)\n\n        del dap._check_raises\n        return not dap._problematic"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_meta(cls, dap):\n        '''Check the meta.yaml in the dap.\n\n        Return a list of DapProblems.'''\n        problems = list()\n\n        # Check for non array-like metadata\n        for datatype in (Dap._required_meta | Dap._optional_meta) - Dap._array_meta:\n            if not dap._isvalid(datatype):\n                msg = datatype + ' is not valid (or required and unspecified)'\n                problems.append(DapProblem(msg))\n\n        # Check for the array-like metadata\n        for datatype in Dap._array_meta:\n            ok, bads = dap._arevalid(datatype)\n            if not ok:\n                if not bads:\n                    msg = datatype + ' is not a valid non-empty list'\n                    problems.append(DapProblem(msg))\n                else:\n                    for bad in bads:\n                        msg = bad + ' in ' + datatype + ' is not valid or is a duplicate'\n                        problems.append(DapProblem(msg))\n\n        # Check that there is no unknown metadata\n        leftovers = set(dap.meta.keys()) - (Dap._required_meta | Dap._optional_meta)\n        if leftovers:\n            msg = 'Unknown metadata: ' + str(leftovers)\n            problems.append(DapProblem(msg))\n\n        # Check that package_name is not longer than 200 characters\n        if len(dap.meta.get('package_name', '')) > 200:\n            msg = 'Package name is too long. It must not exceed 200 characters.'\n            problems.append(DapProblem(msg))\n\n        return problems", "response": "Check the meta. yaml in the dap."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that everything is in the correct top - level directory.", "response": "def check_topdir(cls, dap):\n        '''Check that everything is in the correct top-level directory.\n\n        Return a list of DapProblems'''\n        problems = list()\n        dirname = os.path.dirname(dap._meta_location)\n\n        if not dirname:\n            msg = 'meta.yaml is not in top-level directory'\n            problems.append(DapProblem(msg))\n\n        else:\n            for path in dap.files:\n                if not path.startswith(dirname):\n                    msg = path + ' is outside of ' + dirname + ' top-level directory'\n                    problems.append(DapProblem(msg))\n\n        if dap.meta['package_name'] and dap.meta['version']:\n            desired_dirname = dap._dirname()\n            desired_filename = desired_dirname + '.dap'\n\n            if dirname and dirname != desired_dirname:\n                msg = 'Top-level directory with meta.yaml is not named ' + desired_dirname\n                problems.append(DapProblem(msg))\n\n            if dap.basename != desired_filename:\n                msg = 'The dap filename is not ' + desired_filename\n                problems.append(DapProblem(msg))\n\n        return problems"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_no_self_dependency(cls, dap):\n        '''Check that the package does not depend on itself.\n\n        Return a list of problems.'''\n        problems = list()\n\n        if 'package_name' in dap.meta and 'dependencies' in dap.meta:\n            dependencies = set()\n\n            for dependency in dap.meta['dependencies']:\n                if 'dependencies' in dap._badmeta and dependency in dap._badmeta['dependencies']:\n                    continue\n\n                # No version specified\n                if not re.search(r'[<=>]', dependency):\n                    dependencies.add(dependency)\n\n                # Version specified\n                for mark in ['==', '>=', '<=', '<', '>']:\n                    dep = dependency.split(mark)\n                    if len(dep) == 2:\n                        dependencies.add(dep[0].strip())\n                        break\n\n            if dap.meta['package_name'] in dependencies:\n                msg = 'Depends on dap with the same name as itself'\n                problems.append(DapProblem(msg))\n\n        return problems", "response": "Check that the package does not depend on itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_name_not_on_dapi(cls, dap):\n        '''Check that the package_name is not registered on Dapi.\n\n        Return list of problems.'''\n        problems = list()\n\n        if dap.meta['package_name']:\n            from . import dapicli\n            d = dapicli.metadap(dap.meta['package_name'])\n            if d:\n                problems.append(DapProblem('This dap name is already registered on Dapi',\n                                           level=logging.WARNING))\n        return problems", "response": "Check that the package_name is not registered on Dapi."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_files(cls, dap):\n        '''Check that there are only those files the standard accepts.\n\n        Return list of DapProblems.'''\n        problems = list()\n        dirname = os.path.dirname(dap._meta_location)\n\n        if dirname:\n            dirname += '/'\n        files = [f for f in dap.files if f.startswith(dirname)]\n        if len(files) == 1:\n            msg = 'Only meta.yaml in dap'\n            problems.append(DapProblem(msg, level=logging.WARNING))\n            return problems\n\n        files.remove(dirname + 'meta.yaml')\n\n        # Report and remove empty directories until no more are found\n        emptydirs = dap._get_emptydirs(files)\n        while emptydirs:\n            for ed in emptydirs:\n                msg = ed + ' is empty directory (may be nested)'\n                problems.append(DapProblem(msg, logging.WARNING))\n                files.remove(ed)\n            emptydirs = dap._get_emptydirs(files)\n\n        if dap.meta['package_name']:\n            name = dap.meta['package_name']\n\n            dirs = re.compile('^' + dirname + '((assistants(/(crt|twk|prep|extra))?|snippets)(/' +\n                              name + ')?|icons(/(crt|twk|prep|extra|snippets)(/' + name +\n                              ')?)?|files|(files/(crt|twk|prep|extra|snippets)|doc)(/' + name +\n                              '(/.+)?)?)$')\n            regs = re.compile('^' + dirname + '((assistants(/(crt|twk|prep|extra))|snippets)/' +\n                              name + r'(/[^/]+)?\\.yaml|icons/(crt|twk|prep|extra|snippets)/' +\n                              name + r'(/[^/]+)?\\.(' + Dap._icons_ext +\n                              ')|(files/(crt|twk|prep|extra|snippets)|doc)/' + name + '/.+)$')\n\n            to_remove = []\n            for f in files:\n                if dap._is_dir(f) and not dirs.match(f):\n                    msg = f + '/ is not allowed directory'\n                    problems.append(DapProblem(msg))\n                    to_remove.append(f)\n                elif not dap._is_dir(f) and not regs.match(f):\n                    msg = f + ' is not allowed file'\n                    problems.append(DapProblem(msg))\n                    to_remove.append(f)\n            for r in to_remove:\n                files.remove(r)\n\n            # Subdir yamls need a chief\n            for directory in ['assistants/' + t for t in 'crt twk prep extra'.split()] + \\\n                    ['snippets']:\n                prefix = dirname + directory + '/'\n                for f in files:\n                    if f.startswith(prefix) and dap._is_dir(f) and f + '.yaml' not in files:\n                        msg = f + '/ present, but ' + f + '.yaml missing'\n                        problems.append(DapProblem(msg))\n\n        # Missing assistants and/or snippets\n        if not dap.assistants_and_snippets:\n            msg = 'No Assistants or Snippets found'\n            problems.append(DapProblem(msg, level=logging.WARNING))\n\n        # Icons\n        icons = [dap._strip_leading_dirname(i) for i in dap.icons(strip_ext=True)] # we need to report duplicates\n        assistants = set([dap._strip_leading_dirname(a) for a in dap.assistants])  # duplicates are fine here\n\n        duplicates = set([i for i in icons if icons.count(i) > 1])\n        for d in duplicates:\n            msg = 'Duplicate icon for ' + f\n            problems.append(DapProblem(msg, level=logging.WARNING))\n\n        icons = set(icons)\n        for i in icons - assistants:\n            msg = 'Useless icon for non-exisiting assistant ' + i\n            problems.append(DapProblem(msg, level=logging.WARNING))\n\n        for a in assistants - icons:\n            msg = 'Missing icon for assistant ' + a\n            problems.append(DapProblem(msg, level=logging.WARNING))\n\n        # Source files\n        for f in cls._get_files_without_assistants(dap, dirname, files):\n            msg = 'Useless files for non-exisiting assistant ' + f\n            problems.append(DapProblem(msg, level=logging.WARNING))\n\n        return problems", "response": "Check that there are only those files the standard accepts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_yamls(cls, dap):\n        '''Check that all assistants and snippets are valid.\n\n        Return list of DapProblems.'''\n        problems = list()\n\n        for yaml in dap.assistants_and_snippets:\n            path = yaml + '.yaml'\n            parsed_yaml = YamlLoader.load_yaml_by_path(dap._get_file(path, prepend=True))\n            if parsed_yaml:\n                try:\n                    yaml_checker.check(path, parsed_yaml)\n                except YamlError as e:\n                    problems.append(DapProblem(exc_as_decoded_string(e), level=logging.ERROR))\n            else:\n                problems.append(DapProblem('Empty YAML ' + path, level=logging.WARNING))\n\n        return problems", "response": "Check that all assistants and snippets are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstrips leading directory name from the given path", "response": "def _strip_leading_dirname(self, path):\n        '''Strip leading directory name from the given path'''\n        return os.path.sep.join(path.split(os.path.sep)[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assistants(self):\n        '''Get all assistants in this DAP'''\n        return [strip_suffix(f, '.yaml') for f in self._stripped_files if self._assistants_pattern.match(f)]", "response": "Get all assistants in this DAP"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget all snippets in this DAP", "response": "def snippets(self):\n        '''Get all snippets in this DAP'''\n        return [strip_suffix(f, '.yaml') for f in self._stripped_files if self._snippets_pattern.match(f)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef icons(self, strip_ext=False):\n        '''Get all icons in this DAP, optionally strip extensions'''\n        result =  [f for f in self._stripped_files if self._icons_pattern.match(f)]\n        if strip_ext:\n            result = [strip_suffix(f, '\\.({ext})'.format(ext=self._icons_ext), regex=True) for f in result]\n\n        return result", "response": "Get all icons in this DAP optionally strip extensions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfilling self. _badmeta with meta datatypes that are invalid", "response": "def _find_bad_meta(self):\n        '''Fill self._badmeta with meta datatypes that are invalid'''\n        self._badmeta = dict()\n\n        for datatype in self.meta:\n            for item in self.meta[datatype]:\n                if not Dap._meta_valid[datatype].match(item):\n                    if datatype not in self._badmeta:\n                        self._badmeta[datatype] = []\n                    self._badmeta[datatype].append(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts a file from dap to a file - like object", "response": "def _get_file(self, path, prepend=False):\n        '''Extracts a file from dap to a file-like object'''\n        if prepend:\n            path = os.path.join(self._dirname(), path)\n        extracted = self._tar.extractfile(path)\n        if extracted:\n            return extracted\n        raise DapFileError(('Could not read %s from %s, maybe it\\'s a directory,' +\n            'bad link or the dap file is corrupted') % (path, self.basename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads data from meta. yaml to a dictionary", "response": "def _load_meta(self, meta):\n        '''Load data from meta.yaml to a dictionary'''\n        meta = yaml.load(meta, Loader=Loader)\n\n        # Versions are often specified in a format that is convertible to an\n        # int or a float, so we want to make sure it is interpreted as a str.\n        # Fix for the bug #300.\n        if 'version' in meta:\n            meta['version'] = str(meta['version'])\n\n        return meta"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _report_problem(self, problem, level=logging.ERROR):\n        '''Report a given problem'''\n        problem = self.basename + ': ' + problem\n        if self._logger.isEnabledFor(level):\n            self._problematic = True\n        if self._check_raises:\n            raise DapInvalid(problem)\n        self._logger.log(level, problem)", "response": "Report a given problem"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the given datatype is valid in meta", "response": "def _isvalid(self, datatype):\n        '''Checks if the given datatype is valid in meta'''\n        if datatype in self.meta:\n            return bool(Dap._meta_valid[datatype].match(self.meta[datatype]))\n        else:\n            return datatype in Dap._optional_meta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the given datatype is valid in meta ( for array - like types )", "response": "def _arevalid(self, datatype):\n        '''Checks if the given datatype is valid in meta (for array-like types)'''\n        # Datatype not specified\n        if datatype not in self.meta:\n            return datatype in Dap._optional_meta, []\n\n        # Required datatype empty\n        if datatype in self._required_meta and not self.meta[datatype]:\n            return False, []\n\n        # Datatype not a list\n        if not isinstance(self.meta[datatype], list):\n            return False, []\n\n        # Duplicates found\n        duplicates = set([x for x in self.meta[datatype] if self.meta[datatype].count(x) > 1])\n        if duplicates:\n            return False, list(duplicates)\n\n        if datatype in self._badmeta:\n            return False, self._badmeta[datatype]\n        else:\n            return True, []\n\n        # Checking if all items are valid\n        bad = []\n        for item in self.meta[datatype]:\n            if not Dap._meta_valid[datatype].match(item):\n                bad.append(item)\n        return len(bad) == 0, bad"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the given in -dap file is a directory", "response": "def _is_dir(self, f):\n        '''Check if the given in-dap file is a directory'''\n        return self._tar.getmember(f).type == tarfile.DIRTYPE"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_emptydirs(self, files):\n        '''Find empty directories and return them\n        Only works for actual files in dap'''\n        emptydirs = []\n        for f in files:\n            if self._is_dir(f):\n                empty = True\n                for ff in files:\n                    if ff.startswith(f + '/'):\n                        empty = False\n                        break\n                if empty:\n                    emptydirs.append(f)\n        return emptydirs", "response": "Find empty directories and return them\n        Only works for actual files in dap"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads all configuration from file", "response": "def load_configuration_file(self):\n        \"\"\"\n        Load all configuration from file\n        \"\"\"\n        if not os.path.exists(self.config_file):\n            return\n        try:\n            with open(self.config_file, 'r') as file:\n                csvreader = csv.reader(file, delimiter='=',\n                                       escapechar='\\\\', quoting=csv.QUOTE_NONE)\n                for line in csvreader:\n                    if len(line) == 2:\n                        key, value = line\n                        self.config_dict[key] = value\n                    else:\n                        self.config_dict = dict()\n                        self.logger.warning(\"Malformed configuration file {0}, ignoring it.\".\n                                            format(self.config_file))\n                        return\n        except (OSError, IOError) as e:\n            self.logger.warning(\"Could not load configuration file: {0}\".\\\n                format(utils.exc_as_decoded_string(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_configuration_file(self):\n        if os.path.exists(self.config_file) and not self.config_changed:\n            return\n        dirname = os.path.dirname(self.config_file)\n        try:\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n        except (OSError, IOError) as e:\n            self.logger.warning(\"Could not make directory for configuration file: {0}\".\n                                format(utils.exc_as_decoded_string(e)))\n            return\n        try:\n            with open(self.config_file, 'w') as file:\n                csvwriter = csv.writer(file, delimiter='=', escapechar='\\\\',\n                                       lineterminator='\\n', quoting=csv.QUOTE_NONE)\n                for key, value in self.config_dict.items():\n                    csvwriter.writerow([key, value])\n            self.config_changed = False\n        except (OSError, IOError) as e:\n            self.logger.warning(\"Could not save configuration file: {0}\".\\\n                format(utils.exc_as_decoded_string(e)))", "response": "Save all configuration into file\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_config_value(self, name, value):\n        if value is True:\n            value = \"True\"\n        elif value is False:\n            if name in self.config_dict:\n                del self.config_dict[name]\n                self.config_changed = True\n            return\n        if name not in self.config_dict or self.config_dict[name] != value:\n            self.config_changed = True\n            self.config_dict[name] = value", "response": "Set the configuration value with given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _open_path_window(self):\n        self.data['top_assistant'] = self.top_assistant\n        self.data['current_main_assistant'] = self.get_current_main_assistant()\n        self.data['kwargs'] = self.kwargs\n        self.path_window.open_window(self.data)\n        self.main_win.hide()", "response": "Hides this window and opens path window.\n        Passes all needed data and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions serves for getting full assistant path and collects the information from GUI", "response": "def sub_menu_pressed(self, widget, event):\n        \"\"\"\n        Function serves for getting full assistant path and\n        collects the information from GUI\n        \"\"\"\n        for index, data in enumerate(self.dev_assistant_path):\n            index += 1\n            if settings.SUBASSISTANT_N_STRING.format(index) in self.kwargs:\n                del self.kwargs[settings.SUBASSISTANT_N_STRING.format(index)]\n            self.kwargs[settings.SUBASSISTANT_N_STRING.format(index)] = data\n        self.kwargs['subassistant_0'] = self.get_current_main_assistant().name\n        self._open_path_window()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_current_main_assistant(self):\n        current_page = self.notebook.get_nth_page(self.notebook.get_current_page())\n        return current_page.main_assistant", "response": "Function returns current main assistant"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef btn_clicked(self, widget, data=None):\n        self.kwargs['subassistant_0'] = self.get_current_main_assistant().name\n        self.kwargs['subassistant_1'] = data\n        if 'subassistant_2' in self.kwargs:\n            del self.kwargs['subassistant_2']\n        self._open_path_window()", "response": "Function is used for case that assistant has no any duplicate assistants"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_window(self, widget, data=None):\n        if data is not None:\n            self.data = data\n        os.chdir(os.path.expanduser('~'))\n        self.kwargs = dict()\n        self.main_win.show_all()", "response": "Function opens main window"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef btn_press_event(self, widget, event):\n        if event.type == Gdk.EventType.BUTTON_PRESS:\n            if event.button.button == 1:\n                widget.popup(None, None, None, None,\n                             event.button.button, event.time)\n            return True\n        return False", "response": "Function is used for showing Popup menu"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions for running DevAssistant GUI", "response": "def run_gui():\n    \"\"\"\n    Function for running DevAssistant GUI\n    \"\"\"\n    try:\n        from gi.repository import Gtk\n    except ImportError as ie:\n        pass\n    except RuntimeError as e:\n        sys.stderr.write(GUI_MESSAGE)\n        sys.stderr.write(\"%s: %r\" % (e.__class__.__name__, utils.exc_as_decoded_string(e)))\n        sys.stderr.flush()\n        sys.exit(1)\n\n    if not os.environ.get('DISPLAY'):\n        sys.stderr.write(\"%s %s\" % (GUI_MESSAGE, GUI_MESSAGE_DISPLAY))\n        sys.stderr.flush()\n        sys.exit(1)\n\n    # For GNOME 3 icon:\n    #  because this is invoked as da-gui and the desktop file is called devassistant\n    try:\n        from gi.repository import GLib\n        GLib.set_prgname(PRGNAME)\n    except ImportError:\n        pass\n\n    parser = argparse.ArgumentParser(description='Run DevAssistant GUI.')\n    utils.add_no_cache_argument(parser)\n    # now we only have \"--no-cache\" argument, which we don't actually need to remember,\n    #  see add_no_cache_argument help; so we only run parse_args to determine if\n    #  the invocation was correct\n    parser.parse_args()\n\n    settings.USE_CACHE = False if '--no-cache' in sys.argv else True\n    from devassistant.gui import main_window\n    main_window.MainWindow()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef needs_fully_loaded(method):\n    @functools.wraps(method)\n    def inner(self, *args, **kwargs):\n        if not self.fully_loaded:\n            loaded_yaml = yaml_loader.YamlLoader.load_yaml_by_path(self.path)\n            self.parsed_yaml = loaded_yaml\n            self.fully_loaded = True\n        return method(self, *args, **kwargs)\n\n    return inner", "response": "Decorator that ensures that the assistant is fully loaded."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the default path to icon of this assistant.", "response": "def default_icon_path(self):\n        \"\"\"Returns default path to icon of this assistant.\n\n        Assuming self.path == \"/foo/assistants/crt/python/django.yaml\"\n        For image format in [png, svg]:\n            1) Take the path of this assistant and strip it of load path\n               (=> \"crt/python/django.yaml\")\n            2) Substitute its extension for <image format>\n               (=> \"crt/python/django.<image format>\")\n            3) Prepend self.load_path + 'icons'\n               (=> \"/foo/icons/crt/python/django.<image format>\")\n            4) If file from 3) exists, return it\n        Return empty string if no icon found.\n        \"\"\"\n        supported_exts = ['.png', '.svg']\n        stripped = self.path.replace(os.path.join(self.load_path, 'assistants'), '').strip(os.sep)\n        for ext in supported_exts:\n            icon_with_ext = os.path.splitext(stripped)[0] + ext\n            icon_fullpath = os.path.join(self.load_path, 'icons', icon_with_ext)\n            if os.path.exists(icon_fullpath):\n                return icon_fullpath\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef proper_kwargs(self, section, kwargs):\n        kwargs['__section__'] = section\n        kwargs['__assistant__'] = self\n        kwargs['__env__'] = copy.deepcopy(os.environ)\n        kwargs['__files__'] = [self._files]\n        kwargs['__files_dir__'] = [self.files_dir]\n        kwargs['__sourcefiles__'] = [self.path]\n        # if any of the following fails, DA should keep running\n        for i in ['system_name', 'system_version', 'distro_name', 'distro_version']:\n            try:\n                val = getattr(utils, 'get_' + i)()\n            except:\n                val = ''\n            kwargs['__' + i + '__'] = val", "response": "Returns kwargs updated with proper meta variables like __assistant__."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dependencies(self, kwargs=None, expand_only=False):\n        # we can't use {} as a default for kwargs, as that initializes the dict only once in Python\n        # and uses the same dict in all subsequent calls of this method\n        if not kwargs:\n            kwargs = {}\n\n        self.proper_kwargs('dependencies', kwargs)\n        sections = self._get_dependency_sections_to_use(kwargs)\n        deps = []\n\n        for sect in sections:\n            if expand_only:\n                deps.extend(lang.expand_dependencies_section(sect, kwargs))\n            else:\n                deps.extend(lang.dependencies_section(sect, kwargs, runner=self))\n\n        return deps", "response": "Returns all dependencies of this assistant with regards to specified kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_perm_prompt(cls, package_list):\n        if cls == PackageManager:\n            raise NotImplementedError()\n        ln = len(package_list)\n        plural = 's' if ln > 1 else ''\n        return cls.permission_prompt.format(num=ln, plural=plural)", "response": "Return text for prompt to install given packages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to detect a package manager used in a current Gentoo system.", "response": "def _try_get_current_manager(cls):\n        \"\"\" Try to detect a package manager used in a current Gentoo system. \"\"\"\n        if utils.get_distro_name().find('gentoo') == -1:\n            return None\n        if 'PACKAGE_MANAGER' in os.environ:\n            pm = os.environ['PACKAGE_MANAGER']\n            if pm == 'paludis':\n                # Try to import paludis module\n                try:\n                    import paludis\n                    return GentooPackageManager.PALUDIS\n                except ImportError:\n                    # TODO Environment tells that paludis must be used, but\n                    # it seems latter was build w/o USE=python...\n                    # Need to report an error!!??\n                    cls._debug_doesnt_work('can\\'t import paludis', name='PaludisPackageManager')\n                    return None\n            elif pm == 'portage':\n                # Fallback to default: portage\n                pass\n            else:\n                # ATTENTION Some unknown package manager?! Which one?\n                return None\n\n        # Try to import portage module\n        try:\n            import portage\n            return GentooPackageManager.PORTAGE\n        except ImportError:\n            cls._debug_doesnt_work('can\\'t import portage', name='EmergePackageManager')\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_current_manager_equals_to(cls, pm):\n        if hasattr(cls, 'works_result'):\n            return cls.works_result\n        is_ok = bool(cls._try_get_current_manager() == pm)\n        setattr(cls, 'works_result', is_ok)\n        return is_ok", "response": "Returns True if this package manager is usable False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchoose proper package manager and return it.", "response": "def get_package_manager(self, dep_t):\n        \"\"\"Choose proper package manager and return it.\"\"\"\n        mgrs = managers.get(dep_t, [])\n        for manager in mgrs:\n            if manager.works():\n                return manager\n        if not mgrs:\n            err = 'No package manager for dependency type \"{dep_t}\"'.format(dep_t=dep_t)\n            raise exceptions.NoPackageManagerException(err)\n        else:\n            mgrs_nice = ', '.join([mgr.__name__ for mgr in mgrs])\n            err = 'No working package manager for \"{dep_t}\" in: {mgrs}'.format(dep_t=dep_t,\n                                                                              mgrs=mgrs_nice)\n            raise exceptions.NoPackageManagerOperationalException(err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_dependency(self, dep_t, dep_l):\n        if dep_t not in managers:\n            err = 'No package manager for dependency type \"{dep_t}\"'.format(dep_t=dep_t)\n            raise exceptions.NoPackageManagerException(err)\n        # try to get list of distros where the dependency type is system type\n        distros = settings.SYSTEM_DEPTYPES_SHORTCUTS.get(dep_t, None)\n        if not distros:  # non-distro dependency type\n            sysdep_t = self.get_system_deptype_shortcut()\n            # for now, just take the first manager that can install dep_t and install this manager\n            self._process_dependency(sysdep_t,\n                                     managers[dep_t][0].get_distro_dependencies(sysdep_t))\n        else:\n            local_distro = utils.get_distro_name()\n            found = False\n            for distro in distros:\n                if distro in local_distro:\n                    found = True\n                    break\n            if not found:  # distro dependency type, but for another distro\n                return\n        self.__add_dependencies(dep_t, dep_l)", "response": "Add dependencies into self. dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ask_to_confirm(self, ui, pac_man, *to_install):\n        ret = DialogHelper.ask_for_package_list_confirm(\n            ui, prompt=pac_man.get_perm_prompt(to_install),\n            package_list=to_install,\n        )\n        return bool(ret)", "response": "Return True if user wants to install packages False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck and refreshes all assistants with given role.", "response": "def refresh_role(self, role, file_hierarchy):\n        \"\"\"Checks and refreshes (if needed) all assistants with given role.\n\n        Args:\n            role: role of assistants to refresh\n            file_hierarchy: hierarchy as returned by devassistant.yaml_assistant_loader.\\\n                            YamlAssistantLoader.get_assistants_file_hierarchy\n        \"\"\"\n        if role not in self.cache:\n            self.cache[role] = {}\n        was_change = self._refresh_hierarchy_recursive(self.cache[role], file_hierarchy)\n        if was_change:\n            cf = open(self.cache_file, 'w')\n            yaml.dump(self.cache, cf, Dumper=Dumper)\n            cf.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ass_needs_refresh(self, cached_ass, file_ass):\n        if cached_ass['source'] != file_ass['source']:\n            return True\n        if os.path.getctime(file_ass['source']) > cached_ass.get('ctime', 0.0):\n            return True\n        if set(cached_ass['subhierarchy'].keys()) != set(set(file_ass['subhierarchy'].keys())):\n            return True\n        for snip_name, snip_ctime in cached_ass['snippets'].items():\n            if self._get_snippet_ctime(snip_name) > snip_ctime:\n                return True\n\n        return False", "response": "Checks if assistant needs refresh"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ass_refresh_attrs(self, cached_ass, file_ass):\n        # we need to process assistant in custom way to see unexpanded args, etc.\n        loaded_ass = yaml_loader.YamlLoader.load_yaml_by_path(file_ass['source'], log_debug=True)\n        attrs = loaded_ass\n        yaml_checker.check(file_ass['source'], attrs)\n        cached_ass['source'] = file_ass['source']\n        cached_ass['ctime'] = os.path.getctime(file_ass['source'])\n        cached_ass['attrs'] = {}\n        cached_ass['snippets'] = {}\n        # only cache these attributes if they're actually found in assistant\n        # we do this to specify the default values for them just in one place\n        # which is currently YamlAssistant.parsed_yaml property setter\n        for a in ['fullname', 'description', 'icon_path']:\n            if a in attrs:\n                cached_ass['attrs'][a] = attrs.get(a)\n        # args have different processing, we can't just take them from assistant\n        if 'args' in attrs:\n            cached_ass['attrs']['args'] = {}\n        for argname, argparams in attrs.get('args', {}).items():\n            if 'use' in argparams or 'snippet' in argparams:\n                snippet_name = argparams.pop('use', None) or argparams.pop('snippet')\n                snippet = yaml_snippet_loader.YamlSnippetLoader.get_snippet_by_name(snippet_name)\n                cached_ass['attrs']['args'][argname] = snippet.get_arg_by_name(argname)\n                cached_ass['attrs']['args'][argname].update(argparams)\n                cached_ass['snippets'][snippet.name] = self._get_snippet_ctime(snippet.name)\n            else:\n                cached_ass['attrs']['args'][argname] = argparams", "response": "Completely refreshes cached attributes from file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a completely new cache hierarchy for given assistant file.", "response": "def _new_ass_hierarchy(self, file_ass):\n        \"\"\"Returns a completely new cache hierarchy for given assistant file.\n\n        Args:\n             file_ass: the assistant from filesystem hierarchy to create cache hierarchy for\n                      (for format see what refresh_role accepts)\n        Returns:\n            the newly created cache hierarchy\n        \"\"\"\n        ret_struct = {'source': '',\n                      'subhierarchy': {},\n                      'attrs': {},\n                      'snippets': {}}\n        ret_struct['source'] = file_ass['source']\n        self._ass_refresh_attrs(ret_struct, file_ass)\n\n        for name, subhierarchy in file_ass['subhierarchy'].items():\n            ret_struct['subhierarchy'][name] = self._new_ass_hierarchy(subhierarchy)\n\n        return ret_struct"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns and remembers last ctime of given snippet.", "response": "def _get_snippet_ctime(self, snip_name):\n        \"\"\"Returns and remembers (during this DevAssistant invocation) last ctime of given\n        snippet.\n\n        Calling ctime costs lost of time and some snippets, like common_args, are used widely,\n        so we don't want to call ctime bazillion times on them during one invocation.\n\n        Args:\n            snip_name: name of snippet to get ctime for\n        Returns:\n            ctime of the snippet\n        \"\"\"\n        if snip_name not in self.snip_ctimes:\n            snippet = yaml_snippet_loader.YamlSnippetLoader.get_snippet_by_name(snip_name)\n            self.snip_ctimes[snip_name] = os.path.getctime(snippet.path)\n        return self.snip_ctimes[snip_name]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expand_dependencies_section(section, kwargs):\n    deps = []\n\n    for dep in section:\n        for dep_type, dep_list in dep.items():\n            if dep_type in ['call', 'use']:\n                deps.extend(Command(dep_type, dep_list, kwargs).run())\n            elif dep_type.startswith('if ') or dep_type == 'else':\n                deps.append({dep_type: expand_dependencies_section(dep_list, kwargs)})\n            else:\n                deps.append({dep_type: dep_list})\n\n    return deps", "response": "Expands dependency section e. g. substitues use : foo for its contents but\n    doesn t evaluate conditions nor substitues variables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_for(control_line):\n    error = 'For loop call must be in form \\'for $var in expression\\', got: ' + control_line\n    regex = re.compile(r'for\\s+(\\${?\\S+}?)(?:\\s*,\\s+(\\${?\\S+}?))?\\s+(in|word_in)\\s+(\\S.+)')\n    res = regex.match(control_line)\n    if not res:\n        raise exceptions.YamlSyntaxError(error)\n\n    groups = res.groups()\n    control_vars = []\n    control_vars.append(get_var_name(groups[0]))\n    if groups[1]:\n        control_vars.append(get_var_name(groups[1]))\n    iter_type = groups[2]\n    expr = groups[3]\n\n    return (control_vars, iter_type, expr)", "response": "Parses a for loop control line and returns a tuple of variable names iteration type and expression to iterate on."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn tuple that consists of control variable name and iterable that is result of evaluated expression of given for loop.", "response": "def get_for_control_var_and_eval_expr(comm_type, kwargs):\n    \"\"\"Returns tuple that consists of control variable name and iterable that is result\n    of evaluated expression of given for loop.\n\n    For example:\n    - given 'for $i in $(echo \"foo bar\")' it returns (['i'], ['foo', 'bar'])\n    - given 'for $i, $j in $foo' it returns (['i', 'j'], [('foo', 'bar')])\n    \"\"\"\n    # let possible exceptions bubble up\n    control_vars, iter_type, expression = parse_for(comm_type)\n    eval_expression = evaluate_expression(expression, kwargs)[1]\n\n    iterval = []\n    if len(control_vars) == 2:\n        if not isinstance(eval_expression, dict):\n            raise exceptions.YamlSyntaxError('Can\\'t expand {t} to two control variables.'.\n                                             format(t=type(eval_expression)))\n        else:\n            iterval = list(eval_expression.items())\n    elif isinstance(eval_expression, six.string_types):\n        if iter_type == 'word_in':\n            iterval = eval_expression.split()\n        else:\n            iterval = eval_expression\n    else:\n        iterval = eval_expression\n\n    return control_vars, iterval"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_section_from_condition(if_section, else_section, kwargs):\n    # check if else section is really else\n    skip = True if else_section is not None and else_section[0] == 'else' else False\n    if evaluate_expression(if_section[0][2:].strip(), kwargs)[0]:\n        return (0, skip, if_section[1])\n    else:\n        return (1, skip, else_section[1]) if skip else (1, skip, None)", "response": "Returns the section that should be used from given if section and if clause."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_catch_vars(catch):\n    catch_re = re.compile(r'catch\\s+(\\${?\\S+}?),\\s*(\\${?\\S+}?)')\n    res = catch_re.match(catch)\n    if res is None:\n        err = 'Catch must have format \"catch $x, $y\", got \"{0}\"'.format(catch)\n        raise exceptions.YamlSyntaxError(err)\n    return get_var_name(res.group(1)), get_var_name(res.group(2))", "response": "Returns 2 - tuple with names of catch control vars e. g. for catch x and y catch x returns ('was_exc', err )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assign_variable(variable, log_res, res, kwargs):\n    if variable.endswith('~'):\n        variable = variable[:-1]\n    comma_count = variable.count(',')\n    if comma_count > 1:\n        raise exceptions.YamlSyntaxError('Max two variables allowed on left side.')\n\n    if comma_count == 1:\n        var1, var2 = map(lambda v: get_var_name(v), variable.split(','))\n        kwargs[var1] = log_res\n    else:\n        var2 = get_var_name(variable)\n    kwargs[var2] = res\n    return log_res, res", "response": "Assigns given result to a variable in a log_res and res."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef symbol(self, id, bp=0):\n\n        try:\n            s = self.symbol_table[id]\n        except KeyError:\n            class s(self.symbol_base):\n                pass\n            s.id = id\n            s.lbp = bp\n            self.symbol_table[id] = s\n        else:\n            s.lbp = max(bp, s.lbp)\n        return s", "response": "Returns a new symbol class for the given id and binding power."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef advance(self, id=None):\n\n        if id and self.token.id != id:\n            raise SyntaxError(\"Expected {0}\".format(id))\n        self.token = self.next()", "response": "Advance to next token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef method(self, symbol_name):\n\n        s = self.symbol(symbol_name)\n\n        def bind(fn):\n            setattr(s, fn.__name__, fn)\n        return bind", "response": "A decorator that adds the decorated method to symbol symbol_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self, expression):\n        if isinstance(expression, (list, dict)):\n            return (True if expression else False, expression)\n        if sys.version_info[0] > 2:\n            self.next = self.tokenize(expression).__next__\n        else:\n            self.next = self.tokenize(expression).next\n        self.token = self.next()\n        return self.expression()", "response": "Evaluate expression and returns it s value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_platforms_set():\n    '''Returns set of all possible platforms'''\n    # arch and mageia are not in Py2 _supported_dists, so we add them manually\n    # Ubuntu adds itself to the list on Ubuntu\n    platforms = set([x.lower() for x in platform._supported_dists])\n    platforms |= set(['darwin', 'arch', 'mageia', 'ubuntu'])\n    return platforms", "response": "Returns set of all possible platforms"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_file_in_load_dirs(relpath):\n    if relpath.startswith(os.path.sep):\n        relpath = relpath.lstrip(os.path.sep)\n\n    for ld in settings.DATA_DIRECTORIES:\n        possible_path = os.path.join(ld, relpath)\n        if os.path.exists(possible_path):\n            return possible_path", "response": "Find a file in one of the DevAssistant load directories."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_exitfuncs():\n    exc_info = None\n    for func, targs, kargs in _exithandlers:\n        try:\n            func(*targs, **kargs)\n        except SystemExit:\n            exc_info = sys.exc_info()\n        except:\n            exc_info = sys.exc_info()\n\n    if exc_info is not None:\n        six.reraise(exc_info[0], exc_info[1], exc_info[2])", "response": "Function that behaves like Python s atexit but runs atexit functions\n    in the order in which they were registered not reversed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_prefix(string, prefix, regex=False):\n    if not isinstance(string, six.string_types) or not isinstance(prefix, six.string_types):\n        msg = 'Arguments to strip_prefix must be string types. Are: {s}, {p}'\\\n              .format(s=type(string), p=type(prefix))\n        raise TypeError(msg)\n\n    if not regex:\n        prefix = re.escape(prefix)\n    if not prefix.startswith('^'):\n        prefix = '^({s})'.format(s=prefix)\n    return _strip(string, prefix)", "response": "Strip the prefix from the string\n    If regex is specified the prefix is understood as a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strip_suffix(string, suffix, regex=False):\n    if not isinstance(string, six.string_types) or not isinstance(suffix, six.string_types):\n        msg = 'Arguments to strip_suffix must be string types. Are: {s}, {p}'\\\n              .format(s=type(string), p=type(suffix))\n        raise TypeError(msg)\n\n    if not regex:\n        suffix = re.escape(suffix)\n    if not suffix.endswith('$'):\n        suffix = '({s})$'.format(s=suffix)\n    return _strip(string, suffix)", "response": "Strip the suffix from the string. If regex is specified the suffix is understood as a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns complement of pattern in string", "response": "def _strip(string, pattern):\n    \"\"\"Return complement of pattern in string\"\"\"\n    m = re.compile(pattern).search(string)\n\n    if m:\n        return string[0:m.start()] + string[m.end():len(string)]\n    else:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_console_logging_handler(cls, lgr, level=logging.INFO):\n        console_handler = logger.DevassistantClHandler(sys.stdout)\n        if console_handler.stream.isatty():\n            console_handler.setFormatter(logger.DevassistantClColorFormatter())\n        else:\n            console_handler.setFormatter(logger.DevassistantClFormatter())\n        console_handler.setLevel(level)\n        cls.cur_handler = console_handler\n        lgr.addHandler(console_handler)", "response": "Registers console logging handler to given logger."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(cls):\n        sigint_handler.override()\n        # set settings.USE_CACHE before constructing parser, since constructing\n        # parser requires loaded assistants\n        settings.USE_CACHE = False if '--no-cache' in sys.argv else True\n        cls.register_console_logging_handler(logger.logger)\n        is_log_file = logger.add_log_file_handler(settings.LOG_FILE)\n        if not is_log_file:\n            logger.logger.warning(\"Could not create log file '{0}'.\".format(settings.LOG_FILE))\n        cls.inform_of_short_bin_name(sys.argv[0])\n        top_assistant = bin.TopAssistant()\n        tree = top_assistant.get_subassistant_tree()\n        argparser = argparse_generator.ArgparseGenerator.\\\n            generate_argument_parser(tree, actions=actions.actions)\n        parsed_args = vars(argparser.parse_args())\n\n        parsed_args_decoded = dict()\n        for k, v in parsed_args.items():\n            parsed_args_decoded[k] = \\\n                v.decode(utils.defenc) if not six.PY3 and isinstance(v, str) else v\n        parsed_args_decoded['__ui__'] = 'cli'\n\n        if parsed_args.get('da_debug'):\n            cls.change_logging_level(logging.DEBUG)\n\n        # Prepare Action/PathRunner\n        if actions.is_action_run(**parsed_args_decoded):\n            to_run = actions.get_action_to_run(**parsed_args_decoded)(**parsed_args_decoded)\n        else:\n            parsed_args = cls.transform_executable_assistant_alias(parsed_args_decoded)\n            path = top_assistant.get_selected_subassistant_path(**parsed_args_decoded)\n            to_run = path_runner.PathRunner(path, parsed_args_decoded)\n\n        try:\n            to_run.run()\n        except exceptions.ExecutionException:\n            # error is already logged, just catch it and silently exit here\n            sys.exit(1)", "response": "Runs the whole CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_full_dir_name(self):\n        return os.path.join(self.dir_name.get_text(), self.entry_project_name.get_text())", "response": "Function returns a full dir name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions opens the run Window who executes the assistant project creation", "response": "def next_window(self, widget, data=None):\n        \"\"\"\n        Function opens the run Window who executes the\n        assistant project creation\n        \"\"\"\n        # check whether deps-only is selected\n        deps_only = ('deps_only' in self.args and self.args['deps_only']['checkbox'].get_active())\n\n        # preserve argument value if it is needed to be preserved\n        for arg_dict in [x for x in self.args.values() if 'preserved' in x['arg'].kwargs]:\n            preserve_key = arg_dict['arg'].kwargs['preserved']\n            # preserve entry text (string value)\n            if 'entry' in arg_dict:\n                if self.arg_is_selected(arg_dict):\n                    config_manager.set_config_value(preserve_key, arg_dict['entry'].get_text())\n            # preserve if checkbox is ticked (boolean value)\n            else:\n                config_manager.set_config_value(preserve_key, self.arg_is_selected(arg_dict))\n\n        # save configuration into file\n        config_manager.save_configuration_file()\n        # get project directory and name\n        project_dir = self.dir_name.get_text()\n        full_name = self.get_full_dir_name()\n\n        # check whether project directory and name is properly set\n        if not deps_only and self.current_main_assistant.name == 'crt':\n            if project_dir == \"\":\n                return self.gui_helper.execute_dialog(\"Specify directory for project\")\n            else:\n                # check whether directory is existing\n                if not os.path.isdir(project_dir):\n                    response = self.gui_helper.create_question_dialog(\n                        \"Directory {0} does not exists\".format(project_dir),\n                        \"Do you want to create them?\"\n                    )\n                    if response == Gtk.ResponseType.NO:\n                        # User do not want to create a directory\n                        return\n                    else:\n                        # Create directory\n                        try:\n                            os.makedirs(project_dir)\n                        except OSError as os_err:\n                            return self.gui_helper.execute_dialog(\"{0}\".format(os_err))\n                elif os.path.isdir(full_name):\n                    return self.check_for_directory(full_name)\n\n        if not self._build_flags():\n            return\n\n        if not deps_only and self.current_main_assistant.name == 'crt':\n            self.kwargs['name'] = full_name\n        self.kwargs['__ui__'] = 'gui_gtk+'\n\n        self.data['kwargs'] = self.kwargs\n        self.data['top_assistant'] = self.top_assistant\n        self.data['current_main_assistant'] = self.current_main_assistant\n        self.parent.run_window.open_window(widget, self.data)\n        self.path_window.hide()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction builds kwargs variable for run_window", "response": "def _build_flags(self):\n        \"\"\"\n        Function builds kwargs variable for run_window\n        \"\"\"\n        # Check if all entries for selected arguments are nonempty\n        for arg_dict in [x for x in self.args.values() if self.arg_is_selected(x)]:\n            if 'entry' in arg_dict and not arg_dict['entry'].get_text():\n                self.gui_helper.execute_dialog(\"Entry {0} is empty\".format(arg_dict['label']))\n                return False\n\n        # Check for active CheckButtons\n        for arg_dict in [x for x in self.args.values() if self.arg_is_selected(x)]:\n            arg_name = arg_dict['arg'].get_dest()\n            if 'entry' in arg_dict:\n                self.kwargs[arg_name] = arg_dict['entry'].get_text()\n            else:\n                if arg_dict['arg'].get_gui_hint('type') == 'const':\n                    self.kwargs[arg_name] = arg_dict['arg'].kwargs['const']\n                else:\n                    self.kwargs[arg_name] = True\n\n        # Check for non active CheckButtons but with defaults flag\n        for arg_dict in [x for x in self.args.values() if not self.arg_is_selected(x)]:\n            arg_name = arg_dict['arg'].get_dest()\n            if 'default' in arg_dict['arg'].kwargs:\n                self.kwargs[arg_name] = arg_dict['arg'].get_gui_hint('default')\n            elif arg_name in self.kwargs:\n                del self.kwargs[arg_name]\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open_window(self, data=None):\n        self.args = dict()\n        if data is not None:\n            self.top_assistant = data.get('top_assistant', None)\n            self.current_main_assistant = data.get('current_main_assistant', None)\n            self.kwargs = data.get('kwargs', None)\n            self.data['debugging'] = data.get('debugging', False)\n        project_dir = self.get_default_project_dir()\n        self.dir_name.set_text(project_dir)\n        self.label_full_prj_dir.set_text(project_dir)\n        self.dir_name.set_sensitive(True)\n        self.dir_name_browse_btn.set_sensitive(True)\n        self._remove_widget_items()\n        if self.current_main_assistant.name != 'crt' and self.project_name_shown:\n            self.box6.remove(self.box_project)\n            self.project_name_shown = False\n        elif self.current_main_assistant.name == 'crt' and not self.project_name_shown:\n            self.box6.remove(self.box_path_main)\n            self.box6.pack_start(self.box_project, False, False, 0)\n            self.box6.pack_end(self.box_path_main, False, False, 0)\n            self.project_name_shown = True\n        caption_text = \"Project: \"\n        row = 0\n        # get selectected assistants, but without TopAssistant itself\n        path = self.top_assistant.get_selected_subassistant_path(**self.kwargs)[1:]\n        caption_parts = []\n\n        # Finds any dependencies\n        found_deps = [x for x in path if x.dependencies()]\n        # This bool variable is used for showing text \"Available options:\"\n        any_options = False\n        for assistant in path:\n            caption_parts.append(\"<b>\" + assistant.fullname + \"</b>\")\n            for arg in sorted([x for x in assistant.args if not '--name' in x.flags], key=lambda y: y.flags):\n                if not (arg.name == \"deps_only\" and not found_deps):\n                    row = self._add_table_row(arg, len(arg.flags) - 1, row) + 1\n                    any_options = True\n        if not any_options:\n            self.title.set_text(\"\")\n        else:\n            self.title.set_text(\"Available options:\")\n        caption_text += ' -> '.join(caption_parts)\n        self.label_caption.set_markup(caption_text)\n        self.path_window.show_all()\n        self.entry_project_name.set_text(os.path.basename(self.kwargs.get('name', '')))\n        self.entry_project_name.set_sensitive(True)\n        self.run_btn.set_sensitive(not self.project_name_shown or self.entry_project_name.get_text() != \"\")\n        if 'name' in self.kwargs:\n            self.dir_name.set_text(os.path.dirname(self.kwargs.get('name', '')))\n        for arg_name, arg_dict in [(k, v) for (k, v) in self.args.items() if self.kwargs.get(k)]:\n            if 'checkbox' in arg_dict:\n                arg_dict['checkbox'].set_active(True)\n            if 'entry' in arg_dict:\n                arg_dict['entry'].set_sensitive(True)\n                arg_dict['entry'].set_text(self.kwargs[arg_name])\n            if 'browse_btn' in arg_dict:\n                arg_dict['browse_btn'].set_sensitive(True)", "response": "Function opens the Options dialog"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions manipulates with entries and buttons.", "response": "def _check_box_toggled(self, widget, data=None):\n        \"\"\"\n        Function manipulates with entries and buttons.\n        \"\"\"\n        active = widget.get_active()\n        arg_name = data\n\n        if 'entry' in self.args[arg_name]:\n            self.args[arg_name]['entry'].set_sensitive(active)\n        if 'browse_btn' in self.args[arg_name]:\n            self.args[arg_name]['browse_btn'].set_sensitive(active)\n\n        self.path_window.show_all()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _deps_only_toggled(self, widget, data=None):\n        active = widget.get_active()\n        self.dir_name.set_sensitive(not active)\n        self.entry_project_name.set_sensitive(not active)\n        self.dir_name_browse_btn.set_sensitive(not active)\n        self.run_btn.set_sensitive(active or not self.project_name_shown or self.entry_project_name.get_text() != \"\")", "response": "Function deactivate options in case of deps_only and opposite\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prev_window(self, widget, data=None):\n        self.path_window.hide()\n        self.parent.open_window(widget, self.data)", "response": "Function returns to Main Window"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning opens the file chooser dialog for settings project dir", "response": "def browse_path(self, window):\n        \"\"\"\n        Function opens the file chooser dialog for settings project dir\n        \"\"\"\n        text = self.gui_helper.create_file_chooser_dialog(\"Choose project directory\", self.path_window, name=\"Select\")\n        if text is not None:\n            self.dir_name.set_text(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_table_row(self, arg, number, row):\n        self.args[arg.name] = dict()\n        self.args[arg.name]['arg'] = arg\n        check_box_title = arg.flags[number][2:].title()\n        self.args[arg.name]['label'] = check_box_title\n        align = self.gui_helper.create_alignment()\n        if arg.kwargs.get('required'):\n            # If argument is required then red star instead of checkbox\n            star_label = self.gui_helper.create_label('<span color=\"#FF0000\">*</span>')\n            star_label.set_padding(0, 3)\n            label = self.gui_helper.create_label(check_box_title)\n            box = self.gui_helper.create_box()\n            box.pack_start(star_label, False, False, 6)\n            box.pack_start(label, False, False, 6)\n            align.add(box)\n        else:\n            chbox = self.gui_helper.create_checkbox(check_box_title)\n            chbox.set_alignment(0, 0)\n            if arg.name == \"deps_only\":\n                chbox.connect(\"clicked\", self._deps_only_toggled)\n            else:\n                chbox.connect(\"clicked\", self._check_box_toggled, arg.name)\n            align.add(chbox)\n            self.args[arg.name]['checkbox'] = chbox\n        if row == 0:\n            self.grid.add(align)\n        else:\n            self.grid.attach(align, 0, row, 1, 1)\n        label = self.gui_helper.create_label(arg.kwargs['help'], justify=Gtk.Justification.LEFT)\n        label.set_alignment(0, 0)\n        label.set_padding(0, 3)\n        self.grid.attach(label, 1, row, 1, 1)\n        label_check_box = self.gui_helper.create_label(name=\"\")\n        self.grid.attach(label_check_box, 0, row, 1, 1)\n        if arg.get_gui_hint('type') not in ['bool', 'const']:\n            new_box = self.gui_helper.create_box(spacing=6)\n            entry = self.gui_helper.create_entry(text=\"\")\n            align = self.gui_helper.create_alignment()\n            align.add(entry)\n            new_box.pack_start(align, False, False, 6)\n            align_btn = self.gui_helper.create_alignment()\n            ''' If a button is needed please add there and in function\n                _check_box_toggled\n                Also do not forget to create a function for that button\n                This can not be done by any automatic tool from those reasons\n                Some fields needs a input user like user name for GitHub\n                and some fields needs to have interaction from user like selecting directory\n            '''\n            entry.set_text(arg.get_gui_hint('default'))\n            entry.set_sensitive(arg.kwargs.get('required') == True)\n\n            if arg.get_gui_hint('type') == 'path':\n                browse_btn = self.gui_helper.button_with_label(\"Browse\")\n                browse_btn.connect(\"clicked\", self.browse_clicked, entry)\n                browse_btn.set_sensitive(arg.kwargs.get('required') == True)\n                align_btn.add(browse_btn)\n                self.args[arg.name]['browse_btn'] = browse_btn\n            elif arg.get_gui_hint('type') == 'str':\n                if arg.name == 'github' or arg.name == 'github-login':\n                    link_button = self.gui_helper.create_link_button(text=\"For registration visit GitHub Homepage\",\n                                                                     uri=\"https://www.github.com\")\n                    align_btn.add(link_button)\n            new_box.pack_start(align_btn, False, False, 6)\n            row += 1\n            self.args[arg.name]['entry'] = entry\n            self.grid.attach(new_box, 1, row, 1, 1)\n        else:\n            if 'preserved' in arg.kwargs and config_manager.get_config_value(arg.kwargs['preserved']):\n                if 'checkbox' in self.args[arg.name]:\n                    self.args[arg.name]['checkbox'].set_active(True)\n        return row", "response": "Function adds options to a grid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef browse_clicked(self, widget, data=None):\n        text = self.gui_helper.create_file_chooser_dialog(\"Please select directory\", self.path_window)\n        if text is not None:\n            data.set_text(text)", "response": "Function sets the directory to entry\n            Function sets the text to be displayed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfunctioning controls whether the project name is changed", "response": "def project_name_changed(self, widget, data=None):\n        \"\"\"\n        Function controls whether run button is enabled\n        \"\"\"\n        if widget.get_text() != \"\":\n            self.run_btn.set_sensitive(True)\n        else:\n            self.run_btn.set_sensitive(False)\n        self.update_full_label()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning is used for controlling full directory project name and storing current project directory in configuration manager", "response": "def dir_name_changed(self, widget, data=None):\n        \"\"\"\n        Function is used for controlling\n        label Full Directory project name\n        and storing current project directory\n        in configuration manager\n        \"\"\"\n        config_manager.set_config_value(\"da.project_dir\", self.dir_name.get_text())\n        self.update_full_label()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(self):\n        if not isinstance(self.parsed_yaml, dict):\n            msg = 'In {0}:\\n'.format(self.sourcefile)\n            msg += 'Assistants and snippets must be Yaml mappings, not \"{0}\"!'.\\\n                format(self.parsed_yaml)\n            raise exceptions.YamlTypeError(msg)\n        self._check_fullname(self.sourcefile)\n        self._check_description(self.sourcefile)\n        self._check_section_names(self.sourcefile)\n        self._check_project_type(self.sourcefile)\n        self._check_args(self.sourcefile)\n        self._check_files(self.sourcefile)\n        self._check_dependencies(self.sourcefile)\n        self._check_run(self.sourcefile)", "response": "Checks whether loaded yaml is well - formed according to syntax defined for\n            version 0. 9. 0 and later."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_args(self, source):\n        '''Validate the argument section.\n\n        Args may be either a dict or a list (to allow multiple positional args).\n        '''\n        path = [source]\n        args = self.parsed_yaml.get('args', {})\n        self._assert_struct_type(args, 'args', (dict, list), path)\n        path.append('args')\n        if isinstance(args, dict):\n            for argn, argattrs in args.items():\n                self._check_one_arg(path, argn, argattrs)\n        else: # must be list - already asserted struct type\n            for argdict in args:\n                self._assert_command_dict(argdict, '[list-item]', path)\n                argn, argattrs = list(argdict.items())[0] # safe - length asserted on previous line\n                self._check_one_arg(path, argn, argattrs)", "response": "Validate the argument section.\n            Args may be either a dict or a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether struct is a command dict and has 1 key - value pair.", "response": "def _assert_command_dict(self, struct, name, path=None, extra_info=None):\n        \"\"\"Checks whether struct is a command dict (e.g. it's a dict and has 1 key-value pair.\"\"\"\n        self._assert_dict(struct, name, path, extra_info)\n        if len(struct) != 1:\n            err = [self._format_error_path(path + [name])]\n            err.append('Commands of run, dependencies, and argument sections must be mapping with '\n                       'exactly 1 key-value pair, got {0}: {1}'.format(len(struct), struct))\n            if extra_info:\n                err.append(extra_info)\n            raise exceptions.YamlSyntaxError('\\n'.join(err))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _assert_struct_type(self, struct, name, types, path=None, extra_info=None):\n        wanted_yaml_typenames = set()\n        for t in types:\n            wanted_yaml_typenames.add(self._get_yaml_typename(t))\n        wanted_yaml_typenames = ' or '.join(wanted_yaml_typenames)\n        actual_yaml_typename = self._get_yaml_typename(type(struct))\n        if not isinstance(struct, types):\n            err = []\n            if path:\n                err.append(self._format_error_path(path + [name]))\n            err.append('  Expected {w} value for \"{n}\", got value of type {a}: \"{v}\"'.\n                       format(w=wanted_yaml_typenames,\n                              n=name,\n                              a=actual_yaml_typename,\n                              v=struct))\n            if extra_info:\n                err.append('Tip: ' + extra_info)\n            raise exceptions.YamlTypeError('\\n'.join(err))", "response": "Asserts that given structure is of any of given types."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn all individual licenses in the input", "response": "def _split_license(license):\n    '''Returns all individual licenses in the input'''\n    return (x.strip() for x in (l for l in _regex.split(license) if l))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match(license):\n    '''Returns True if given license field is correct\n    Taken from rpmlint.\n\n    It's named match() to mimic a compiled regexp.'''\n    if license not in VALID_LICENSES:\n        for l1 in _split_license(license):\n            if l1 in VALID_LICENSES:\n                continue\n            for l2 in _split_license(l1):\n                if l2 not in VALID_LICENSES:\n                    return False\n                    valid_license = False\n    return True", "response": "Returns True if given license field is correct\n    Taken from rpmlint.\n    It s named match to mimic a compiled regexp."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compare(ver1, ver2):\n    '''Version comparing, returns 0 if are the same,\n    returns >0 if first is bigger, <0 if first is smaller,\n    excepts valid version'''\n    if ver1 == ver2:\n        return 0\n    ver1 = _cut(ver1)\n    ver2 = _cut(ver2)\n    # magic multiplier\n    m = 1\n    # if the first one is shorter, replace them\n    if len(ver1) < len(ver2):\n        ver1, ver2 = ver2, ver1\n        # and reverse magic multiplier\n        m = -1\n    # compare all items that both have\n    for i, part in enumerate(ver2):\n        if ver1[i] > ver2[i]:\n            return m * 1\n        if ver1[i] < ver2[i]:\n            return m * -1\n    # if the first \"extra\" item is not negative, it's bigger\n    if ver1[len(ver2)] >= 0:\n        return m * 1\n    else:\n        return m * -1", "response": "Version comparing returns 0 if are the same returns > 0 if first is bigger and < 0 if first is smaller"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncut the version to array excepts valid version", "response": "def _cut(ver):\n    '''Cuts the version to array, excepts valid version'''\n    ver = ver.split('.')\n    for i, part in enumerate(ver):\n        try:\n            ver[i] = int(part)\n        except:\n            if part[-len('dev'):] == 'dev':\n                ver[i] = int(part[:-len('dev')])\n                ver.append(-3)\n            else:\n                ver[i] = int(part[:-len('a')])\n                if part[-len('a'):] == 'a':\n                    ver.append(-2)\n                else:\n                    ver.append(-1)\n    return ver"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_argument_parser(cls, tree, actions={}):\n        cur_as, cur_subas = tree\n        parser = devassistant_argparse.ArgumentParser(argument_default=argparse.SUPPRESS,\n                                                      usage=argparse.SUPPRESS,\n                                                      add_help=False)\n\n        cls.add_default_arguments_to(parser)\n\n        # add any arguments of the top assistant\n        for arg in cur_as.args:\n            arg.add_argument_to(parser)\n\n        if cur_subas or actions:\n            # then add the subassistants as arguments\n            subparsers = cls._add_subparsers_required(parser,\n                dest=settings.SUBASSISTANT_N_STRING.format('0'))\n            for subas in sorted(cur_subas, key=lambda x: x[0].name):\n                for alias in [subas[0].name] + getattr(subas[0], 'aliases', []):\n                    cls.add_subassistants_to(subparsers, subas, level=1, alias=alias)\n\n            for action, subactions in sorted(actions.items(), key=lambda x: x[0].name):\n                cls.add_action_to(subparsers, action, subactions, level=1)\n\n        return parser", "response": "Generates an argument parser for given assistant tree and actions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_subassistants_to(cls, parser, assistant_tuple, level, alias=None):\n        name = alias or assistant_tuple[0].name\n        p = parser.add_parser(name,\n                              description=assistant_tuple[0].description,\n                              argument_default=argparse.SUPPRESS)\n        for arg in assistant_tuple[0].args:\n            arg.add_argument_to(p)\n\n        if len(assistant_tuple[1]) > 0:\n            subparsers = cls._add_subparsers_required(p,\n                dest=settings.SUBASSISTANT_N_STRING.format(level),\n                title=cls.subparsers_str,\n                description=cls.subparsers_desc)\n            for subas_tuple in sorted(assistant_tuple[1], key=lambda x: x[0].name):\n                cls.add_subassistants_to(subparsers, subas_tuple, level + 1)\n        elif level == 1:\n            subparsers = cls._add_subparsers_required(p,\n                dest=settings.SUBASSISTANT_N_STRING.format(level),\n                title=cls.subparsers_str,\n                description=devassistant_argparse.ArgumentParser.no_assistants_msg)", "response": "Adds assistant from given part of assistant tree and all its subassistants to given argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd given action to given parser.", "response": "def add_action_to(cls, parser, action, subactions, level):\n        \"\"\"Adds given action to given parser\n\n        Args:\n            parser: instance of devassistant_argparse.ArgumentParser\n            action: devassistant.actions.Action subclass\n            subactions: dict with subactions - {SubA: {SubB: {}}, SubC: {}}\n        \"\"\"\n        p = parser.add_parser(action.name,\n                              description=action.description,\n                              argument_default=argparse.SUPPRESS)\n        for arg in action.args:\n            arg.add_argument_to(p)\n\n        if subactions:\n            subparsers = cls._add_subparsers_required(p,\n                dest=settings.SUBASSISTANT_N_STRING.format(level),\n                title=cls.subactions_str,\n                description=cls.subactions_desc)\n            for subact, subsubacts in sorted(subactions.items(), key=lambda x: x[0].name):\n                cls.add_action_to(subparsers, subact, subsubacts, level + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat a log entry according to its level and context.", "response": "def format_entry(record, show_level=False, colorize=False):\n    \"\"\"\n    Format a log entry according to its level and context\n    \"\"\"\n    if show_level:\n        log_str = u'{}: {}'.format(record.levelname, record.getMessage())\n    else:\n        log_str = record.getMessage()\n\n    if colorize and record.levelname in LOG_COLORS:\n        log_str = u'<span color=\"{}\">'.format(LOG_COLORS[record.levelname]) + log_str + u'</span>'\n\n    return log_str"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef switch_cursor(cursor_type, parent_window):\n    watch = Gdk.Cursor(cursor_type)\n    window = parent_window.get_root_window()\n    window.set_cursor(watch)", "response": "Function switches the cursor to the given type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions inserts log messages to list_view", "response": "def emit(self, record):\n        \"\"\"\n        Function inserts log messages to list_view\n        \"\"\"\n        msg = record.getMessage()\n        list_store = self.list_view.get_model()\n        Gdk.threads_enter()\n        if msg:\n            # Underline URLs in the record message\n            msg = replace_markup_chars(record.getMessage())\n            record.msg = URL_FINDER.sub(r'<u>\\1</u>', msg)\n            self.parent.debug_logs['logs'].append(record)\n            # During execution if level is bigger then DEBUG\n            # then GUI shows the message.\n            event_type = getattr(record, 'event_type', '')\n            if event_type:\n                if event_type == 'dep_installation_start':\n                    switch_cursor(Gdk.CursorType.WATCH, self.parent.run_window)\n                    list_store.append([format_entry(record)])\n                if event_type == 'dep_installation_end':\n                    switch_cursor(Gdk.CursorType.ARROW, self.parent.run_window)\n            if not self.parent.debugging:\n                # We will show only INFO messages and messages who have no dep_ event_type\n                if int(record.levelno) > 10:\n                    if event_type == \"dep_check\" or event_type == \"dep_found\":\n                        list_store.append([format_entry(record)])\n                    elif not event_type.startswith(\"dep_\"):\n                        list_store.append([format_entry(record, colorize=True)])\n            if self.parent.debugging:\n                if event_type != \"cmd_retcode\":\n                    list_store.append([format_entry(record, show_level=True, colorize=True)])\n        Gdk.threads_leave()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open_window(self, widget, data=None):\n        if data is not None:\n            self.kwargs = data.get('kwargs', None)\n            self.top_assistant = data.get('top_assistant', None)\n            self.current_main_assistant = data.get('current_main_assistant', None)\n            self.debugging = data.get('debugging', False)\n            if not self.debugging:\n                self.debug_btn.set_label('Debug logs')\n            else:\n                self.debug_btn.set_label('Info logs')\n        self.store.clear()\n        self.debug_logs = dict()\n        self.debug_logs['logs'] = list()\n        self.thread = threading.Thread(target=self.dev_assistant_start)\n        # We need only project name for github\n        project_name = self.parent.path_window.get_data()[1]\n        if self.kwargs.get('github'):\n            self.link = self.gui_helper.create_link_button(\n                \"Link to project on Github\",\n                \"http://www.github.com/{0}/{1}\".format(self.kwargs.get('github'), project_name))\n            self.link.set_border_width(6)\n            self.link.set_sensitive(False)\n            self.info_box.pack_start(self.link, False, False, 12)\n        self.run_list_view.connect('size-allocate', self.list_view_changed)\n        # We need to be in /home directory before each project creations\n        os.chdir(os.path.expanduser('~'))\n        self.run_window.show_all()\n        self.disable_buttons()\n        self.thread.start()", "response": "Function opens the run window"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions removes link button from Run Window", "response": "def remove_link_button(self):\n        \"\"\"\n        Function removes link button from Run Window\n        \"\"\"\n        if self.link is not None:\n            self.info_box.remove(self.link)\n            self.link.destroy()\n            self.link = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_event(self, widget, event, data=None):\n        if not self.close_win:\n            if self.thread.isAlive():\n                dlg = self.gui_helper.create_message_dialog(\"Do you want to cancel project creation?\",\n                                                            buttons=Gtk.ButtonsType.YES_NO)\n                response = dlg.run()\n                if response == Gtk.ResponseType.YES:\n                    if self.thread.isAlive():\n                        self.info_label.set_label('<span color=\"#FFA500\">Cancelling...</span>')\n                        self.dev_assistant_runner.stop()\n                        self.project_canceled = True\n                    else:\n                        self.info_label.set_label('<span color=\"#008000\">Done</span>')\n                    self.allow_close_window()\n                dlg.destroy()\n                return True\n        else:\n            return False", "response": "Cancels the project creation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_view_changed(self, widget, event, data=None):\n        adj = self.scrolled_window.get_vadjustment()\n        adj.set_value(adj.get_upper() - adj.get_page_size())", "response": "Function shows last rows."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nthread executes devassistant API.", "response": "def dev_assistant_start(self):\n        \"\"\"\n        Thread executes devassistant API.\n        \"\"\"\n        #logger_gui.info(\"Thread run\")\n        path = self.top_assistant.get_selected_subassistant_path(**self.kwargs)\n        kwargs_decoded = dict()\n        for k, v in self.kwargs.items():\n            kwargs_decoded[k] = \\\n                v.decode(utils.defenc) if not six.PY3 and isinstance(v, str) else v\n        self.dev_assistant_runner = path_runner.PathRunner(path, kwargs_decoded)\n        try:\n            self.dev_assistant_runner.run()\n            Gdk.threads_enter()\n            if not self.project_canceled:\n                message = '<span color=\"#008000\">Done</span>'\n                link = True\n                back = False\n            else:\n                message = '<span color=\"#FF0000\">Failed</span>'\n                link = False\n                back = True\n            self.allow_buttons(message=message, link=link, back=back)\n            Gdk.threads_leave()\n        except exceptions.ClException as cle:\n            msg = replace_markup_chars(cle.message)\n            if not six.PY3:\n                msg = msg.encode(utils.defenc)\n            self.allow_buttons(back=True, link=False,\n                               message='<span color=\"#FF0000\">Failed: {0}</span>'.\n                               format(msg))\n        except exceptions.ExecutionException as exe:\n            msg = replace_markup_chars(six.text_type(exe))\n            if not six.PY3:\n                msg = msg.encode(utils.defenc)\n            self.allow_buttons(back=True, link=False,\n                               message='<span color=\"#FF0000\">Failed: {0}</span>'.\n                               format((msg[:80] + '...') if len(msg) > 80 else msg))\n        except IOError as ioe:\n            self.allow_buttons(back=True, link=False,\n                               message='<span color=\"#FF0000\">Failed: {0}</span>'.\n                               format((ioe.message[:80] + '...') if len(ioe.message) > 80 else ioe.message))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef debug_btn_clicked(self, widget, data=None):\n        self.store.clear()\n        self.thread = threading.Thread(target=self.logs_update)\n        self.thread.start()", "response": "Event in case that debug button is pressed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clipboard_btn_clicked(self, widget, data=None):\n        _clipboard_text = []\n        for record in self.debug_logs['logs']:\n            if self.debugging:\n                _clipboard_text.append(format_entry(record, show_level=True))\n            else:\n                if int(record.levelno) > 10:\n                    if getattr(record, 'event_type', ''):\n                        if not record.event_type.startswith(\"dep_\"):\n                            _clipboard_text.append(format_entry(record))\n                    else:\n                        _clipboard_text.append(format_entry(record))\n        self.gui_helper.create_clipboard(_clipboard_text)", "response": "Function copies logs to clipboard."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main_btn_clicked(self, widget, data=None):\n        self.remove_link_button()\n        data = dict()\n        data['debugging'] = self.debugging\n        self.run_window.hide()\n        self.parent.open_window(widget, data)", "response": "Main button is clicked."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction opens the firefox window with relevant link", "response": "def list_view_row_clicked(self, list_view, path, view_column):\n        \"\"\"\n        Function opens the firefox window with relevant link\n        \"\"\"\n        model = list_view.get_model()\n        text = model[path][0]\n        match = URL_FINDER.search(text)\n        if match is not None:\n            url = match.group(1)\n            import webbrowser\n\n            webbrowser.open(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates an authorization for a GitHub user using two - factor authentication.", "response": "def _github_create_twofactor_authorization(cls, ui):\n        \"\"\"Create an authorization for a GitHub user using two-factor\n           authentication. Unlike its non-two-factor counterpart, this method\n           does not traverse the available authentications as they are not\n           visible until the user logs in.\n\n           Please note: cls._user's attributes are not accessible until the\n           authorization is created due to the way (py)github works.\n        \"\"\"\n        try:\n            try: # This is necessary to trigger sending a 2FA key to the user\n                auth = cls._user.create_authorization()\n            except cls._gh_exceptions.GithubException:\n                onetime_pw = DialogHelper.ask_for_password(ui, prompt='Your one time password:')\n                auth = cls._user.create_authorization(scopes=['repo', 'user', 'admin:public_key'],\n                                            note=\"DevAssistant\",\n                                            onetime_password=onetime_pw)\n                cls._user = cls._gh_module.Github(login_or_token=auth.token).get_user()\n                logger.debug('Two-factor authorization for user \"{0}\" created'.format(cls._user.login))\n                cls._github_store_authorization(cls._user, auth)\n                logger.debug('Two-factor authorization token stored')\n        except cls._gh_exceptions.GithubException as e:\n            logger.warning('Creating two-factor authorization failed: {0}'.format(e))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a GitHub authorization for the given user in case they don t already have one.", "response": "def _github_create_simple_authorization(cls):\n        \"\"\"Create a GitHub authorization for the given user in case they don't\n           already have one.\n        \"\"\"\n        try:\n            auth = None\n            for a in cls._user.get_authorizations():\n                if a.note == 'DevAssistant':\n                    auth = a\n            if not auth:\n                auth = cls._user.create_authorization(\n                    scopes=['repo', 'user', 'admin:public_key'],\n                    note=\"DevAssistant\")\n                cls._github_store_authorization(cls._user, auth)\n        except cls._gh_exceptions.GithubException as e:\n            logger.warning('Creating authorization failed: {0}'.format(e))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstores an authorization token for the given GitHub user in the git global config file.", "response": "def _github_store_authorization(cls, user, auth):\n        \"\"\"Store an authorization token for the given GitHub user in the git\n           global config file.\n        \"\"\"\n        ClHelper.run_command(\"git config --global github.token.{login} {token}\".format(\n            login=user.login, token=auth.token), log_secret=True)\n        ClHelper.run_command(\"git config --global github.user.{login} {login}\".format(\n            login=user.login))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart ssh - agent and returns the environment variables related to it", "response": "def _start_ssh_agent(cls):\n        \"\"\"Starts ssh-agent and returns the environment variables related to it\"\"\"\n        env = dict()\n        stdout = ClHelper.run_command('ssh-agent -s')\n        lines = stdout.split('\\n')\n        for line in lines:\n            if not line or line.startswith('echo '):\n                continue\n            line = line.split(';')[0]\n            parts = line.split('=')\n            if len(parts) == 2:\n                env[parts[0]] = parts[1]\n        return env"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a local ssh key if it doesn t exist already and uploads it to Github.", "response": "def _github_create_ssh_key(cls):\n        \"\"\"Creates a local ssh key, if it doesn't exist already, and uploads it to Github.\"\"\"\n        try:\n            login = cls._user.login\n            pkey_path = '{home}/.ssh/{keyname}'.format(\n                home=os.path.expanduser('~'),\n                keyname=settings.GITHUB_SSH_KEYNAME.format(login=login))\n            # generate ssh key only if it doesn't exist\n            if not os.path.exists(pkey_path):\n                ClHelper.run_command('ssh-keygen -t rsa -f {pkey_path}\\\n                                     -N \\\"\\\" -C \\\"DevAssistant\\\"'.\n                                     format(pkey_path=pkey_path))\n            try:\n                ClHelper.run_command('ssh-add {pkey_path}'.format(pkey_path=pkey_path))\n            except exceptions.ClException:\n                # ssh agent might not be running\n                env = cls._start_ssh_agent()\n                ClHelper.run_command('ssh-add {pkey_path}'.format(pkey_path=pkey_path), env=env)\n            public_key = ClHelper.run_command('cat {pkey_path}.pub'.format(pkey_path=pkey_path))\n            cls._user.create_key(\"DevAssistant\", public_key)\n        except exceptions.ClException as e:\n            msg = 'Couldn\\'t create a new ssh key: {0}'.format(e)\n            raise exceptions.CommandException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _github_ssh_key_exists(cls):\n        remote_keys = map(lambda k: k._key, cls._user.get_keys())\n        found = False\n        pubkey_files = glob.glob(os.path.expanduser('~/.ssh/*.pub'))\n        for rk in remote_keys:\n            for pkf in pubkey_files:\n                local_key = io.open(pkf, encoding='utf-8').read()\n                # in PyGithub 1.23.0, remote key is an object, not string\n                rkval = rk if isinstance(rk, six.string_types) else rk.value\n                # don't use \"==\" because we have comments etc added in public_key\n                if rkval in local_key:\n                    found = True\n                    break\n        return found", "response": "Returns True if any key on Github matches a local key else False."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndoes user authentication, creates SSH keys if needed and injects \"_user\" attribute into class/object bound to the decorated function. Don't call any other methods of this class manually, this should be everything you need.", "response": "def github_authenticated(cls, func):\n        \"\"\"Does user authentication, creates SSH keys if needed and injects \"_user\" attribute\n        into class/object bound to the decorated function.\n        Don't call any other methods of this class manually, this should be everything you need.\n        \"\"\"\n        def inner(func_cls, *args, **kwargs):\n            if not cls._gh_module:\n                logger.warning('PyGithub not installed, skipping Github auth procedures.')\n            elif not func_cls._user:\n                # authenticate user, possibly also creating authentication for future use\n                login = kwargs['login'].encode(utils.defenc) if not six.PY3 else kwargs['login']\n                func_cls._user = cls._get_github_user(login, kwargs['ui'])\n                if func_cls._user is None:\n                    msg = 'Github authentication failed, skipping Github command.'\n                    logger.warning(msg)\n                    return (False, msg)\n                # create an ssh key for pushing if we don't have one\n                if not cls._github_ssh_key_exists():\n                    cls._github_create_ssh_key()\n                # next, create ~/.ssh/config entry for the key, if system username != GH login\n                if cls._ssh_key_needs_config_entry():\n                    cls._create_ssh_config_entry()\n            return func(func_cls, *args, **kwargs)\n\n        return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of assistants that are subassistants of given superassistants", "response": "def get_assistants(cls, superassistants):\n        \"\"\"Returns list of assistants that are subassistants of given superassistants\n        (I love this docstring).\n\n        Args:\n            roles: list of names of roles, defaults to all roles\n        Returns:\n            list of YamlAssistant instances with specified roles\n        \"\"\"\n        _assistants = cls.load_all_assistants(superassistants)\n        result = []\n        for supa in superassistants:\n            result.extend(_assistants[supa.name])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_all_assistants(cls, superassistants):\n        # mapping of assistant roles to lists of top-level assistant instances\n        _assistants = {}\n        # {'crt': CreatorAssistant, ...}\n        superas_dict = dict(map(lambda a: (a.name, a), superassistants))\n        to_load = set(superas_dict.keys())\n        for tl in to_load:\n            dirs = [os.path.join(d, tl) for d in cls.assistants_dirs]\n            file_hierarchy = cls.get_assistants_file_hierarchy(dirs)\n            # load all if we're not using cache or if we fail to load it\n            load_all = not settings.USE_CACHE\n            if settings.USE_CACHE:\n                try:\n                    cch = cache.Cache()\n                    cch.refresh_role(tl, file_hierarchy)\n                    _assistants[tl] = cls.get_assistants_from_cache_hierarchy(cch.cache[tl],\n                                                                                  superas_dict[tl],\n                                                                                  role=tl)\n                except BaseException as e:\n                    logger.debug('Failed to use DevAssistant cachefile {0}: {1}'.format(\n                        settings.CACHE_FILE, e))\n                    load_all = True\n            if load_all:\n                _assistants[tl] = cls.get_assistants_from_file_hierarchy(file_hierarchy,\n                                                                             superas_dict[tl],\n                                                                             role=tl)\n        return _assistants", "response": "Loads all assistants from a list of roles."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_assistants_from_cache_hierarchy(cls, cache_hierarchy, superassistant,\n                                            role=settings.DEFAULT_ASSISTANT_ROLE):\n        \"\"\"Accepts cache_hierarch as described in devassistant.cache and returns\n        instances of YamlAssistant (only with cached attributes) for loaded files\n\n        Args:\n            cache_hierarchy: structure as described in devassistant.cache\n            role: role of all assistants in this hierarchy (we could find\n                  this out dynamically but it's not worth the pain)\n        Returns:\n            list of top level assistants from given hierarchy; these assistants contain\n            references to instances of their subassistants (and their subassistants, ...)\n            Note, that the assistants are not fully loaded, but contain just cached attrs.\n        \"\"\"\n        result = []\n\n        for name, attrs in cache_hierarchy.items():\n            ass = cls.assistant_from_yaml(attrs['source'],\n                                          {name: attrs['attrs']},\n                                          superassistant,\n                                          fully_loaded=False,\n                                          role=role)\n            ass._subassistants = cls.get_assistants_from_cache_hierarchy(attrs['subhierarchy'],\n                                                                         ass,\n                                                                         role=role)\n            result.append(ass)\n\n        return result", "response": "Returns a list of all assistants in a given cache_hierarch"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_assistants_from_file_hierarchy(cls, file_hierarchy, superassistant,\n                                           role=settings.DEFAULT_ASSISTANT_ROLE):\n        \"\"\"Accepts file_hierarch as returned by cls.get_assistant_file_hierarchy and returns\n        instances of YamlAssistant for loaded files\n\n        Args:\n            file_hierarchy: structure as described in cls.get_assistants_file_hierarchy\n            role: role of all assistants in this hierarchy (we could find\n                  this out dynamically but it's not worth the pain)\n        Returns:\n            list of top level assistants from given hierarchy; these assistants contain\n            references to instances of their subassistants (and their subassistants, ...)\n        \"\"\"\n        result = []\n        warn_msg = 'Failed to load assistant {source}, skipping subassistants.'\n\n        for name, attrs in file_hierarchy.items():\n            loaded_yaml = yaml_loader.YamlLoader.load_yaml_by_path(attrs['source'])\n            if loaded_yaml is None:  # there was an error parsing yaml\n                logger.warning(warn_msg.format(source=attrs['source']))\n                continue\n            try:\n                ass = cls.assistant_from_yaml(attrs['source'],\n                                              loaded_yaml,\n                                              superassistant,\n                                              role=role)\n            except exceptions.YamlError as e:\n                logger.warning(e)\n                continue\n            ass._subassistants = cls.get_assistants_from_file_hierarchy(attrs['subhierarchy'],\n                                                                        ass,\n                                                                        role=role)\n            result.append(ass)\n\n        return result", "response": "Returns a list of all assistants in a given file_hierarch and returns a list of all the assistants in the given file_hierarch with the given role."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary containing the assistants file hierarchy for all given directories.", "response": "def get_assistants_file_hierarchy(cls, dirs):\n        \"\"\"Returns assistants file hierarchy structure (see below) representing assistant\n        hierarchy in given directories.\n\n        It works like this:\n        1. It goes through all *.yaml files in all given directories and adds them into\n           hierarchy (if there are two files with same name in more directories, the file\n           from first directory wins).\n        2. For each {name}.yaml file, it calls itself recursively for {name} subdirectories\n           of all given directories.\n\n        Args:\n            dirs: directories to search\n        Returns:\n            hierarchy structure that looks like this:\n            {'assistant1':\n                {'source': '/path/to/assistant1.yaml',\n                 'subhierarchy': {<hierarchy of subassistants>}},\n             'assistant2':\n                {'source': '/path/to/assistant2.yaml',\n                 'subhierarchy': {<another hierarchy of subassistants}}\n            }\n        \"\"\"\n        result = {}\n        for d in filter(lambda d: os.path.exists(d), dirs):\n            for f in filter(lambda f: f.endswith('.yaml'), os.listdir(d)):\n                assistant_name = f[:-5]\n                if assistant_name not in result:\n                    subas_dirs = [os.path.join(dr, assistant_name) for dr in dirs]\n                    result[assistant_name] = {'source': os.path.join(d, f),\n                                              'subhierarchy':\n                                              cls.get_assistants_file_hierarchy(subas_dirs)}\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assistant_from_yaml(cls, source, y, superassistant, fully_loaded=True,\n                            role=settings.DEFAULT_ASSISTANT_ROLE):\n        \"\"\"Constructs instance of YamlAssistant loaded from given structure y, loaded\n        from source file source.\n\n        Args:\n            source: path to assistant source file\n            y: loaded yaml structure\n            superassistant: superassistant of this assistant\n        Returns:\n            YamlAssistant instance constructed from y with source file source\n        Raises:\n            YamlError: if the assistant is malformed\n        \"\"\"\n        # In pre-0.9.0, we required assistant to be a mapping of {name: assistant_attributes}\n        # now we allow that, but we also allow omitting the assistant name and putting\n        # the attributes to top_level, too.\n        name = os.path.splitext(os.path.basename(source))[0]\n        yaml_checker.check(source, y)\n        assistant = yaml_assistant.YamlAssistant(name, y, source, superassistant,\n            fully_loaded=fully_loaded, role=role)\n\n        return assistant", "response": "Constructs an assistant from given yaml file source and given structure y."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_snippet_by_name(cls, name):\n        name_with_dir_separators = name.replace('.', os.path.sep)\n        loaded = yaml_loader.YamlLoader.load_yaml_by_relpath(cls.snippets_dirs,\n                                                             name_with_dir_separators + '.yaml')\n        if loaded:\n            return cls._create_snippet(name, *loaded)\n\n        raise exceptions.SnippetNotFoundException('no such snippet: {name}'.\n                                                  format(name=name_with_dir_separators))", "response": "Returns a new object of type IPagePagePageBase for the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef conforms(cntxt: Context, n: Node, S: ShExJ.Shape) -> bool:\n    # return semActsSatisfied(cntxt.schema.startActs, cntxt) and \\\n    #     all(reference_of(cntxt.schema, sa.shapeLabel) is not None and\n    #\n    return True", "response": "5. 6. 1 Schema Validation Requirement <http://shex. io / shex - semantics/#validation - requirement > _\n    \n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the legend of the current object", "response": "def set_legend(self, legend):\n        \"\"\"legend needs to be a list, tuple or None\"\"\"\n        assert(isinstance(legend, list) or isinstance(legend, tuple) or\n            legend is None)\n        if legend:\n            self.legend = [quote(a) for a in legend]\n        else:\n            self.legend = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_legend_position(self, legend_position):\n        if legend_position:\n            self.legend_position = quote(legend_position)\n        else:    \n            self.legend_position = None", "response": "Sets the legend position. Default is r."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef data_class_detection(self, data):\n        assert(isinstance(data, list) or isinstance(data, tuple))\n        if not isinstance(self, (LineChart, BarChart, ScatterChart)):\n            # From the link above:\n            #   Simple encoding is suitable for all other types of chart\n            #   regardless of size.\n            return SimpleData\n        elif self.height < 100:\n            # The link above indicates that line and bar charts less\n            # than 300px in size can be suitably represented with the\n            # simple encoding. I've found that this isn't sufficient,\n            # e.g. examples/line-xy-circle.png. Let's try 100px.\n            return SimpleData\n        else:\n            return ExtendedData", "response": "Determines the appropriate data encoding type to give satisfactory\n            resolution ( http://code. google. com / apis / chart/#chart_data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data_x_range(self):\n        try:\n            lower = min([min(self._filter_none(s))\n                         for type, s in self.annotated_data()\n                         if type == 'x'])\n            upper = max([max(self._filter_none(s))\n                         for type, s in self.annotated_data()\n                         if type == 'x'])\n            return (lower, upper)\n        except ValueError:\n            return None", "response": "Return a 2 - tuple giving the minimum and maximum x - axis\n        data range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscaling self. data as appropriate for the given data encoding the data class and return it.", "response": "def scaled_data(self, data_class, x_range=None, y_range=None):\n        \"\"\"Scale `self.data` as appropriate for the given data encoding\n        (data_class) and return it.\n\n        An optional `y_range` -- a 2-tuple (lower, upper) -- can be\n        given to specify the y-axis bounds. If not given, the range is\n        inferred from the data: (0, <max-value>) presuming no negative\n        values, or (<min-value>, <max-value>) if there are negative\n        values.  `self.scaled_y_range` is set to the actual lower and\n        upper scaling range.\n\n        Ditto for `x_range`. Note that some chart types don't have x-axis\n        data.\n        \"\"\"\n        self.scaled_data_class = data_class\n\n        # Determine the x-axis range for scaling.\n        if x_range is None:\n            x_range = self.data_x_range()\n            if x_range and x_range[0] > 0:\n                x_range = (x_range[0], x_range[1])\n        self.scaled_x_range = x_range\n\n        # Determine the y-axis range for scaling.\n        if y_range is None:\n            y_range = self.data_y_range()\n            if y_range and y_range[0] > 0:\n                y_range = (y_range[0], y_range[1])\n        self.scaled_y_range = y_range\n\n        scaled_data = []\n        for type, dataset in self.annotated_data():\n            if type == 'x':\n                scale_range = x_range\n            elif type == 'y':\n                scale_range = y_range\n            elif type == 'marker-size':\n                scale_range = (0, max(dataset))\n            scaled_dataset = []\n            for v in dataset:\n                if v is None:\n                    scaled_dataset.append(None)\n                else:\n                    scaled_dataset.append(\n                        data_class.scale_value(v, scale_range))\n            scaled_data.append(scaled_dataset)\n        return scaled_data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_codes(self, codes):\n        '''Set the country code map for the data.\n        Codes given in a list.\n\n        i.e. DE - Germany\n             AT - Austria\n             US - United States\n        '''\n\n        codemap = ''\n        \n        for cc in codes:\n            cc = cc.upper()\n            if cc in self.__ccodes:\n                codemap += cc\n            else:\n                raise UnknownCountryCodeException(cc)\n            \n        self.codes = codemap", "response": "Set the country code map for the data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_geo_area(self, area):\n        '''Sets the geo area for the map.\n\n        * africa\n        * asia\n        * europe\n        * middle_east\n        * south_america\n        * usa\n        * world\n        '''\n        \n        if area in self.__areas:\n            self.geo_area = area\n        else:\n            raise UnknownChartType('Unknown chart type for maps: %s' %area)", "response": "Sets the geo area for the map."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_data_dict(self, datadict):\n        '''Sets the data and country codes via a dictionary.\n\n        i.e. {'DE': 50, 'GB': 30, 'AT': 70}\n        '''\n\n        self.set_codes(list(datadict.keys()))\n        self.add_data(list(datadict.values()))", "response": "Sets the data and country codes via a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef can_cast_to(v: Literal, dt: str) -> bool:\n    # TODO: rdflib doesn't appear to pay any attention to lengths (e.g. 257 is a valid XSD.byte)\n    return v.value is not None and Literal(str(v), datatype=dt).value is not None", "response": "5. 4. 3 Datatype Constraints\n    Determine whether a value of the lexical form of n can be cast to the target type v per\n    XPath Functions 3. 1 section 19 Casting [ xpath - functions ]."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _map_xpath_flags_to_re(expr: str, xpath_flags: str) -> Tuple[int, str]:\n    python_flags: int = 0\n    modified_expr = expr\n    if xpath_flags is None:\n        xpath_flags = \"\"\n\n    if 's' in xpath_flags:\n        python_flags |= re.DOTALL\n    if 'm' in xpath_flags:\n        python_flags |= re.MULTILINE\n    if 'i' in xpath_flags:\n        python_flags |= re.IGNORECASE\n    if 'x' in xpath_flags:\n        modified_expr = re.sub(r'[\\t\\n\\r ]|\\[[^\\]]*\\]', _char_class_escape, modified_expr)\n    if 'q' in xpath_flags:\n        modified_expr = re.escape(modified_expr)\n\n    return python_flags, modified_expr", "response": "Map 5. 6. 2 Flags <https://www. w3. org / TR / xpath - functions - 31/#flags > _ to python flags and modified expr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmapping a JSON object to a ShEx object literal.", "response": "def map_object_literal(v: Union[str, jsonasobj.JsonObj]) -> ShExJ.ObjectLiteral:\n    \"\"\" `PyShEx.jsg <https://github.com/hsolbrig/ShExJSG/ShExJSG/ShExJ.jsg>`_ does not add identifying\n    types to ObjectLiterals.  This routine re-identifies the types\n    \"\"\"\n    # TODO: isinstance(v, JSGString) should work here, but it doesn't with IRIREF(http://a.example/v1)\n    return v if issubclass(type(v), JSGString) or (isinstance(v, JSGObject) and 'type' in v) else \\\n        ShExJ.IRIREF(v) if isinstance(v, str) else ShExJ.ObjectLiteral(**v._as_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenable the vext file.", "response": "def do_enable():\n    \"\"\"\n    Uncomment any lines that start with #import in the .pth file\n    \"\"\"\n    try:\n        _lines = []\n        with open(vext_pth, mode='r') as f:\n            for line in f.readlines():\n                if line.startswith('#') and line[1:].lstrip().startswith('import '):\n                    _lines.append(line[1:].lstrip())\n                else:\n                    _lines.append(line)\n\n        try:\n            os.unlink('%s.tmp' % vext_pth)\n        except:\n            pass\n\n        with open('%s.tmp' % vext_pth, mode='w+') as f:\n            f.writelines(_lines)\n\n        try:\n            os.unlink('%s~' % vext_pth)\n        except:\n            pass\n\n        os.rename(vext_pth, '%s~' % vext_pth)\n        os.rename('%s.tmp' % vext_pth, vext_pth)\n    except IOError as e:\n        if e.errno == 2:\n            # vext file doesn't exist, recreate it.\n            create_pth()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_check(vext_files):\n    import vext\n    # not efficient ... but then there shouldn't be many of these\n\n    all_specs = set(vext.gatekeeper.spec_files_flat())\n    if vext_files == ['*']:\n        vext_files = all_specs\n    unknown_specs = set(vext_files) - all_specs\n    for fn in unknown_specs:\n        print(\"%s is not an installed vext file.\" % fn, file=sys.stderr)\n\n    if unknown_specs:\n        return False\n\n    check_passed = True\n    for fn in [join(vext.gatekeeper.spec_dir(), fn) for fn in vext_files]:\n        f = open_spec(open(fn))\n        modules = f.get('test_import', [])\n        for success, module in vext.gatekeeper.test_imports(modules):\n            if not success:\n                check_passed = False\n            line = \"import %s: %s\" % (module, '[success]' if success else '[failed]')\n            print(line)\n        print('')\n\n    return check_passed", "response": "Checks if all vext files are installed and import them."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fix_path(p):\n    venv_lib = get_python_lib()\n\n    if p.startswith(venv_lib):\n        subdir = p[len(venv_lib) + 1:]\n\n        for sitedir in getsyssitepackages():\n            fixed_path = join(sitedir, subdir)\n            if isdir(fixed_path):\n                return fixed_path\n\n    return p", "response": "Convert path pointing subdirectory of virtualenv site - packages\n    to system site - packages."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fixup_paths():\n    original_paths = os.environ.get('PATH', \"\").split(os.path.pathsep)\n    original_dirs = set(added_dirs)\n    yield\n\n    # Fix PATH environment variable\n    current_paths = os.environ.get('PATH', \"\").split(os.path.pathsep)\n    if original_paths != current_paths:\n        changed_paths = set(current_paths).difference(set(original_paths))\n        # rebuild PATH env var\n        fixed_paths = []\n        for path in current_paths:\n            if path in changed_paths:\n                fixed_paths.append(env_t(fix_path(path)))\n            else:\n                fixed_paths.append(env_t(path))\n        os.environ['PATH'] = os.pathsep.join(fixed_paths)\n\n    # Fix added_dirs\n    if added_dirs != original_dirs:\n        for path in set(added_dirs.difference(original_dirs)):\n            fixed_path = fix_path(path)\n            if fixed_path != path:\n                print(\"Fix %s >> %s\" % (path, fixed_path))\n                added_dirs.remove(path)\n                added_dirs.add(fixed_path)\n\n                i = sys.path.index(path)  # not efficient... but shouldn't happen often\n                sys.path[i] = fixed_path\n\n                if env_t(fixed_path) not in os.environ['PATH']:\n                    os.environ['PATH'].append(os.pathsep + env_t(fixed_path))", "response": "Fixup paths added in. pth file that point to the virtualenv\n    instead of the system site packages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addpackage(sys_sitedir, pthfile, known_dirs):\n    with open(join(sys_sitedir, pthfile)) as f:\n        for n, line in enumerate(f):\n            if line.startswith(\"#\"):\n                continue\n            line = line.rstrip()\n            if line:\n                if line.startswith((\"import \", \"import\\t\")):\n                    exec (line, globals(), locals())\n                    continue\n                else:\n                    p_rel = join(sys_sitedir, line)\n                    p_abs = abspath(line)\n                    if isdir(p_rel):\n                        os.environ['PATH'] += env_t(os.pathsep + p_rel)\n                        sys.path.append(p_rel)\n                        added_dirs.add(p_rel)\n                    elif isdir(p_abs):\n                        os.environ['PATH'] += env_t(os.pathsep + p_abs)\n                        sys.path.append(p_abs)\n                        added_dirs.add(p_abs)\n\n    if isfile(pthfile):\n        site.addpackage(sys_sitedir, pthfile, known_dirs)\n    else:\n        logging.debug(\"pth file '%s' not found\")", "response": "Wrapper for site. addpackage\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a filename like html5lib - 0. 999. egg - info to html5lib - 0. 999. egg - info", "response": "def filename_to_module(filename):\n    \"\"\"\n    convert a filename like html5lib-0.999.egg-info to html5lib\n    \"\"\"\n    find = re.compile(r\"^[^.|-]*\")\n    name = re.search(find, filename).group(0)\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the PATH environment variable", "response": "def init_path():\n    \"\"\"\n    Add any new modules that are directories to the PATH\n    \"\"\"\n    sitedirs = getsyssitepackages()\n    for sitedir in sitedirs:\n        env_path = os.environ['PATH'].split(os.pathsep)\n        for module in allowed_modules:\n            p = join(sitedir, module)\n            if isdir(p) and not p in env_path:\n                os.environ['PATH'] += env_t(os.pathsep + p)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef install_importer():\n    logging.debug('install_importer')\n    if not in_venv():\n        logging.debug('No virtualenv active py:[%s]', sys.executable)\n        return False\n\n    if disable_vext:\n        logging.debug('Vext disabled by environment variable')\n        return False\n\n    if GatekeeperFinder.PATH_TRIGGER not in sys.path:\n        try:\n            load_specs()\n            sys.path.append(GatekeeperFinder.PATH_TRIGGER)\n            sys.path_hooks.append(GatekeeperFinder)\n        except Exception as e:\n            \"\"\"\n            Dont kill other programmes because of a vext error\n            \"\"\"\n            logger.info(str(e))\n            if logger.getEffectiveLevel() == logging.DEBUG:\n                raise\n\n        logging.debug(\"importer installed\")\n        return True", "response": "Installs the vext importer if not already installed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a module from the sys. modules dictionary.", "response": "def load_module(self, name):\n        \"\"\"\n        Only lets modules in allowed_modules be loaded, others\n        will get an ImportError\n        \"\"\"\n\n        # Get the name relative to SITEDIR ..\n        filepath = self.module_info[1]\n        fullname = splitext( \\\n            relpath(filepath, self.sitedir) \\\n            )[0].replace(os.sep, '.')\n\n        modulename = filename_to_module(fullname)\n        if modulename not in allowed_modules:\n            if remember_blocks:\n                blocked_imports.add(fullname)\n            if log_blocks:\n                raise ImportError(\"Vext blocked import of '%s'\" % modulename)\n            else:\n                # Standard error message\n                raise ImportError(\"No module named %s\" % modulename)\n\n        if name not in sys.modules:\n            try:\n                logger.debug(\"load_module %s %s\", name, self.module_info)\n                module = imp.load_module(name, *self.module_info)\n            except Exception as e:\n                logger.debug(e)\n                raise\n            sys.modules[fullname] = module\n\n        return sys.modules[fullname]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extra_paths():\n    # TODO - this is only tested on Ubuntu for now\n    #        there must be a better way of getting\n    #        the sip directory.\n    dirs = {}\n    try:\n        @vext.env.run_in_syspy\n        def run(*args):\n            import sipconfig\n            config = sipconfig.Configuration()\n            dirs = {\n                \"sip.default_sip_dir\": config.default_sip_dir,\n            }\n            return dirs\n        dirs = run()\n        return dirs\n    except ImportError:\n        return dirs", "response": "Returns extra paths for the available SIP directories."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef str_to_bytes(value):\n    if not isinstance(value, six.binary_type) and isinstance(value, six.string_types):\n        return value.encode()\n    return value", "response": "Convert a string type to bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evaluate(g: Graph,\n             schema: Union[str, ShExJ.Schema],\n             focus: Optional[Union[str, URIRef, IRIREF]],\n             start: Optional[Union[str, URIRef, IRIREF, START, START_TYPE]]=None,\n             debug_trace: bool = False) -> Tuple[bool, Optional[str]]:\n    \"\"\" Evaluate focus node `focus` in graph `g` against shape `shape` in ShEx schema `schema`\n\n    :param g: Graph containing RDF\n    :param schema: ShEx Schema -- if str, it will be parsed\n    :param focus: focus node in g. If not specified, all URI subjects in G will be evaluated.\n    :param start: Starting shape.  If omitted, the Schema start shape is used\n    :param debug_trace: Turn on debug tracing\n    :return: None if success or failure reason if failure\n    \"\"\"\n    if isinstance(schema, str):\n        schema = SchemaLoader().loads(schema)\n    if schema is None:\n        return False, \"Error parsing schema\"\n    if not isinstance(focus, URIRef):\n        focus = URIRef(str(focus))\n    if start is None:\n        start = str(schema.start) if schema.start else None\n    if start is None:\n        return False, \"No starting shape\"\n    if not isinstance(start, IRIREF) and start is not START and start is not START_TYPE:\n        start = IRIREF(str(start))\n    cntxt = Context(g, schema)\n    cntxt.debug_context.debug = debug_trace\n    map_ = FixedShapeMap()\n    map_.add(ShapeAssociation(focus, start))\n    test_result, reasons = isValid(cntxt, map_)\n    return test_result, '\\n'.join(reasons)", "response": "Evaluate focus node in graph g against shape in ShEx schema schema."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests if the expression G m satisfies the expression.", "response": "def isValid(cntxt: Context, m: FixedShapeMap) -> Tuple[bool, List[str]]:\n    \"\"\"`5.2 Validation Definition <http://shex.io/shex-semantics/#validation>`_\n\n    The expression isValid(G, m) indicates that for every nodeSelector/shapeLabel pair (n, s) in m, s has a\n        corresponding shape expression se and satisfies(n, se, G, m). satisfies is defined below for each form\n        of shape expression\n\n    :param cntxt: evaluation context - includes graph and schema\n    :param m: list of NodeShape pairs to test\n    :return: Success/failure indicator and, if fail, a list of failure reasons\n    \"\"\"\n    if not cntxt.is_valid:\n        return False, cntxt.error_list\n    parse_nodes = []\n    for nodeshapepair in m:\n        n = nodeshapepair.nodeSelector\n        if not isinstance_(n, Node):\n            return False, [f\"{n}: Triple patterns are not implemented\"]\n        # The third test below is because the spec asserts that completely empty graphs pass in certain circumstances\n        elif not (next(cntxt.graph.predicate_objects(nodeshapepair.nodeSelector), None) or\n                  next(cntxt.graph.subject_predicates(nodeshapepair.nodeSelector), None) or\n                  not next(cntxt.graph.triples((None, None, None)), None)):\n            return False, [f\"Focus: {nodeshapepair.nodeSelector} not in graph\"]\n        else:\n            s = cntxt.shapeExprFor(START if nodeshapepair.shapeLabel is None or nodeshapepair.shapeLabel is START\n                                   else nodeshapepair.shapeLabel)\n            cntxt.current_node = ParseNode(satisfies, s, n, cntxt)\n            if not s:\n                if nodeshapepair.shapeLabel is START or nodeshapepair.shapeLabel is None:\n                    cntxt.fail_reason = \"START node is not specified or is invalid\"\n                else:\n                    cntxt.fail_reason = f\"Shape: {nodeshapepair.shapeLabel} not found in Schema\"\n                return False, cntxt.process_reasons()\n            parse_nodes.append(cntxt.current_node)\n            if not satisfies(cntxt, n, s):\n                cntxt.current_node.result = False\n                return False, cntxt.process_reasons()\n            else:\n                cntxt.current_node.result = True\n    return True, []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_sysdeps(vext_files):\n\n    @run_in_syspy\n    def run(*modules):\n        result = {}\n        for m in modules:\n            if m:\n                try:\n                    __import__(m)\n                    result[m] = True\n                except ImportError:\n                    result[m] = False\n        return result\n\n    success = True\n    for vext_file in vext_files:\n        with open(vext_file) as f:\n            vext = open_spec(f)\n            install_hint = \" \".join(vext.get('install_hints', ['System dependencies not found']))\n\n            modules = vext.get('test_import', '')\n            logger.debug(\"%s test imports of: %s\", vext_file, modules)\n            result = run(*modules)\n            if logging.getLogger().getEffectiveLevel() == logging.DEBUG:\n                for k, v in result.items():\n                    logger.debug(\"%s: %s\", k, v)\n            if not all(result.values()):\n                success = False\n                print(install_hint)\n    return success", "response": "Check that sys. deps is available in test_imports succeed\n    otherwise display message in install_hints"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install_vexts(vext_files, verify=True):\n    if verify and not check_sysdeps(vext_files):\n        return\n\n    spec_dir = join(prefix, 'share/vext/specs')\n    try:\n        makedirs(spec_dir)\n    except OSError as e:\n        if not isdir(spec_dir):\n            logger.error(\"Error making spec directory [%s]: %r\" % (spec_dir, e))\n\n    for vext_file in vext_files:\n        dest = normpath(join(spec_dir, basename(vext_file)))\n        try:\n            logger.debug(\"%s > %s\" % (vext_file, dest))\n            copyfile(vext_file, dest)\n            yield vext_file, dest\n        except IOError as e:\n            logger.error(\"Could not copy %s %r\" % (vext_file, e))", "response": "Copy vext files to sys. prefix + '/share/vext/specs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_pth():\n    if prefix == '/usr':\n        print(\"Not creating PTH in real prefix: %s\" % prefix)\n        return False\n    with open(vext_pth, 'w') as f:\n        f.write(DEFAULT_PTH_CONTENT)\n    return True", "response": "Create the default PTH file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_collection(g: Graph, subj: Union[URIRef, BNode], max_entries: int = None, nentries: int = 0) -> Optional[List[str]]:\n    if subj == RDF.nil:\n        return [')']\n    if max_entries is not None and nentries >= max_entries:\n        return ['  ...', ')']\n    cadr = cdr = None\n    for p, o in g.predicate_objects(subj):\n        if p == RDF.first and cadr is None:\n            cadr = o\n        elif p == RDF.rest and cdr is None:\n            cdr = o\n        else:\n            return None\n    # technically this can't happen but it doesn't hurt to address it\n    if cadr == RDF.nil and cdr is None:\n        return []\n    elif cadr is not None and cdr is not None:\n        return [(' ' if nentries else '(') + cadr.n3(g.namespace_manager)] + format_collection(g, cdr, max_entries,\n                                                                                                   nentries+1)\n    else:\n        return None", "response": "Return the turtle representation of subj as a collection of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_extra_path(name):\n    # Paths are cached in path_cache\n    helper_name, _, key = name.partition(\".\")\n    helper = path_helpers.get(helper_name)\n    if not helper:\n        raise ValueError(\"Helper '{0}' not found.\".format(helper))\n    if name not in path_cache:\n        extra_paths = helper.extra_paths()\n        path_cache.update(extra_paths)\n    extra_path = path_cache.get(name)\n    if not extra_path:\n        raise ValueError(\"Helper '{0}' has no path called {1}\".format(helper_name, name))\n    return extra_path", "response": "Get the extra path for a given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upgrade_setuptools():\n    # Note - I tried including the higher version in\n    # setup_requires, but was still able to trigger\n    # the bug. - stu.axon\n    global MIN_SETUPTOOLS\n    r = None\n    try:\n        r = pkg_resources.require([\"setuptools\"])[0]\n    except DistributionNotFound:\n        # ok, setuptools will be installed later\n        return\n\n    if StrictVersion(r.version) >= StrictVersion(MIN_SETUPTOOLS):\n        return\n    else:\n        print(\"Upgrading setuptools...\")\n        subprocess.call(\"%s -mpip install 'setuptools>=%s'\" % (sys.executable, MIN_SETUPTOOLS), shell=True)", "response": "Upgrade setuptools to 18. 8"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef installed_packages(self):\n        packages = []\n        CMDLINE = [sys.executable, \"-mpip\", \"freeze\"]\n        try:\n            for package in subprocess.check_output(CMDLINE) \\\n                    .decode('utf-8'). \\\n                    splitlines():\n                for comparator in [\"==\", \">=\", \"<=\", \"<\", \">\"]:\n                    if comparator in package:\n                        # installed package names usually look like Pillow==2.8.1\n                        # ignore others, like external packages that pip show\n                        # won't understand\n                        name = package.partition(comparator)[0]\n                        packages.append(name)\n        except RuntimeError as e:\n            if logger.isEnabledFor(logging.DEBUG):\n                logger.debug(\"Exception checking existing packages.\")\n                logger.debug(\"cmdline: %s\", CMDLINE)\n                ex_type, ex, tb = sys.exc_info()\n                traceback.print_tb(tb)\n                logger.debug()\n        return packages", "response": "Returns a list of installed packages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef package_info(self):\n        import subprocess\n        # create a commandline like  pip show Pillow show\n        package_names = self.installed_packages()\n        if not package_names:\n            # No installed packages yet, so nothign to do here...\n            return []\n\n        cmdline = [sys.executable, \"-mpip\"]\n        for name in package_names:\n            cmdline.extend([\"show\", name])\n\n        output = subprocess.check_output(cmdline)\n        # Python 3 fix\n        if not isinstance(output, str):\n            # Some package info is encoded in Latin-1 or something other than\n            # UTF8.  Replace non-UTF characters with '?' instead of crashing.\n            output = str(output, encoding='UTF-8', errors='replace')\n\n        # parse output that looks like this example\n        \"\"\"\n        ---\n        Name: Pillow\n        Version: 2.8.1\n        Location: /mnt/data/home/stu/.virtualenvs/shoebot-setup/lib/python2.7/site-packages/Pillow-2.8.1-py2.7-linux-x86_64.egg\n        Requires:\n        ---\n        Name: vext.gi\n        Version: 0.5.6.25\n        Location: /mnt/data/home/stu/.virtualenvs/shoebot-setup/lib/python2.7/site-packages/vext.gi-0.5.6.25-py2.7.egg\n        Requires: vext\n\n        \"\"\"\n        results = []\n        for info in output[3:].split(\"---\"):\n            d = {}\n            for line in info[1:].splitlines():\n                arg, _, value = line.partition(': ')\n                arg = arg.lower()\n                if arg == 'requires':\n                    value = value.split(', ')\n                d[arg] = value\n            results.append(d)\n        return results", "response": "Returns a list of package info on installed packages"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depends_on(self, dependency):\n        packages = self.package_info()\n        return [package for package in packages if dependency in package.get(\"requires\", \"\")]", "response": "Returns a list of packages that depend on dependency"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an array of absolute paths to any provided vext files.", "response": "def find_vext_files(self):\n        \"\"\"\n        :return:  Absolute paths to any provided vext files\n        \"\"\"\n        packages = self.depends_on(\"vext\")\n        vext_files = []\n        for location in [package.get(\"location\") for package in packages]:\n            if not location:\n                continue\n            vext_files.extend(glob(join(location, \"*.vext\")))\n        return vext_files"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nneeding to find any pre-existing vext contained in dependent packages and install them example: you create a setup.py with install_requires[\"vext.gi\"]: - vext.gi gets installed using bdist_egg - vext itself is now called with bdist_egg and we end up here Vext now needs to find and install .vext files in vext.gi [or any other files that depend on vext] :return:", "response": "def run(self):\n        \"\"\"\n        Need to find any pre-existing vext contained in dependent packages\n        and install them\n\n        example:\n\n        you create a setup.py with install_requires[\"vext.gi\"]:\n\n        - vext.gi gets installed using bdist_egg\n        - vext itself is now called with bdist_egg and we end up here\n\n        Vext now needs to find and install .vext files in vext.gi\n        [or any other files that depend on vext]\n\n        :return:\n        \"\"\"\n        logger.debug(\"vext InstallLib [started]\")\n\n        # Find packages that depend on vext and check for .vext files...\n\n        logger.debug(\"find_vext_files\")\n        vext_files = self.find_vext_files()\n        logger.debug(\"manually_install_vext: \", vext_files)\n        self.manually_install_vext(vext_files)\n        logger.debug(\"enable vext\")\n        self.enable_vext()\n        logger.debug(\"install_lib.run\")\n        install_lib.run(self)\n        logger.debug(\"vext InstallLib [finished]\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flush_all(self, time=0):\n        returns = []\n        for server in self.servers:\n            returns.append(server.flush_all(time))\n\n        return any(returns)", "response": "Send a command to server flush | delete all keys."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stats(self, key=None):\n        # TODO: Stats with key is not working.\n\n        returns = {}\n        for server in self.servers:\n            returns[server.server] = server.stats(key)\n\n        return returns", "response": "Return server stats.\n\n        :param key: Optional if you want status from a key.\n        :type key: six.string_types\n        :return: A dict with server stats\n        :rtype: dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload the house explosions chart", "response": "def house_explosions():\n    \"\"\"\n    Data from http://indexed.blogspot.com/2007/12/meltdown-indeed.html\n    \"\"\"\n    chart = PieChart2D(int(settings.width * 1.7), settings.height)\n    chart.add_data([10, 10, 30, 200])\n    chart.set_pie_labels([\n        'Budding Chemists',\n        'Propane issues',\n        'Meth Labs',\n        'Attempts to escape morgage',\n        ])\n    chart.download('pie-house-explosions.png')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if n matches the objectValue vsv", "response": "def objectValueMatches(n: Node, vsv: ShExJ.objectValue) -> bool:\n    \"\"\" http://shex.io/shex-semantics/#values\n\n    Implements \"n = vsv\" where vsv is an objectValue and n is a Node\n\n    Note that IRIREF is a string pattern, so the matching type is str\n    \"\"\"\n    return \\\n        (isinstance(vsv, IRIREF) and isinstance(n, URIRef) and uriref_matches_iriref(n, vsv)) or \\\n        (isinstance(vsv, ShExJ.ObjectLiteral) and isinstance(n, Literal) and literal_matches_objectliteral(n, vsv))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompares two RDFRefs to see if they are equivalent.", "response": "def uriref_matches_iriref(v1: URIRef, v2: Union[str, ShExJ.IRIREF]) -> bool:\n    \"\"\" Compare :py:class:`rdflib.URIRef` value with :py:class:`ShExJ.IRIREF` value \"\"\"\n    return str(v1) == str(v2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining whether a URIRef value starts with the text of a ShEx IRIREF value.", "response": "def uriref_startswith_iriref(v1: URIRef, v2: Union[str, ShExJ.IRIREF]) -> bool:\n    \"\"\" Determine whether a :py:class:`rdflib.URIRef` value starts with the text of a :py:class:`ShExJ.IRIREF` value \"\"\"\n    return str(v1).startswith(str(v2))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef literal_matches_objectliteral(v1: Literal, v2: ShExJ.ObjectLiteral) -> bool:\n    v2_lit = Literal(str(v2.value), datatype=iriref_to_uriref(v2.type), lang=str(v2.language) if v2.language else None)\n    return v1 == v2_lit", "response": "Compare two objects literal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef satisfiesNodeConstraint(cntxt: Context, n: Node, nc: ShExJ.NodeConstraint, _: DebugContext) -> bool:\n    return nodeSatisfiesNodeKind(cntxt, n, nc) and nodeSatisfiesDataType(cntxt, n, nc) and \\\n        nodeSatisfiesStringFacet(cntxt, n, nc) and nodeSatisfiesNumericFacet(cntxt, n, nc) and \\\n        nodeSatisfiesValues(cntxt, n, nc)", "response": "Satisfies a node n and a node constraint nc"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nodeSatisfiesNodeKind(cntxt: Context, n: Node, nc: ShExJ.NodeConstraint, c: DebugContext) -> bool:\n    if c.debug and nc.nodeKind is not None:\n        print(f\" Kind: {nc.nodeKind}\")\n    if nc.nodeKind is None or \\\n        (nc.nodeKind == 'iri' and isinstance(n, URIRef)) or \\\n        (nc.nodeKind == 'bnode' and isinstance(n, BNode)) or \\\n        (nc.nodeKind == 'literal' and isinstance(n, Literal)) or \\\n        (nc.nodeKind == 'nonliteral' and isinstance(n, (URIRef, BNode))):\n        return True\n    cntxt.fail_reason = f\"Node kind mismatch have: {type(n).__name__} expected: {nc.nodeKind}\"\n    return False", "response": "5. 4. 2 Node Kind Constraints <http://shex. io / shex - semantics/#nodeKind > _ nodeSatisfiesNodeKind"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nodeSatisfiesDataType(cntxt: Context, n: Node, nc: ShExJ.NodeConstraint, c: DebugContext) -> bool:\n    if nc.datatype is None:\n        return True\n    if c.debug:\n        print(f\" Datatype: {nc.datatype}\")\n    if not isinstance(n, Literal):\n        cntxt.fail_reason = f\"Datatype constraint ({nc.datatype}) \" \\\n            f\"does not match {type(n).__name__} {cntxt.n3_mapper.n3(n)}\"\n        cntxt.dump_bnode(n)\n        return False\n    actual_datatype = _datatype(n)\n    if actual_datatype == str(nc.datatype) or \\\n        (is_sparql_operand_datatype(nc.datatype) and can_cast_to(n, nc.datatype)):\n        return True\n    cntxt.fail_reason = f\"Datatype mismatch - expected: {nc.datatype} actual: {actual_datatype}\"\n    return False", "response": "5. 4. 3 Datatype Constraints <http://shex. io / shex - semantics/#datatype > _nodeSatisfiesDataType"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntest if a node satisfies a numeric facet.", "response": "def nodeSatisfiesNumericFacet(cntxt: Context, n: Node, nc: ShExJ.NodeConstraint, _c: DebugContext) -> bool:\n    \"\"\" `5.4.5 XML Schema Numeric Facet Constraints <http://shex.io/shex-semantics/#xs-numeric>`_\n\n    Numeric facet constraints apply to the numeric value of RDF Literals with datatypes listed in SPARQL 1.1\n    Operand Data Types[sparql11-query]. Numeric constraints on non-numeric values fail. totaldigits and\n    fractiondigits constraints on values not derived from xsd:decimal fail.\n    \"\"\"\n    if nc.mininclusive is not None or nc.minexclusive is not None or nc.maxinclusive is not None \\\n            or nc.maxexclusive is not None or nc.totaldigits is not None or nc.fractiondigits is not None:\n        if is_numeric(n):\n            v = n.value\n            if isinstance(v, numbers.Number):\n                if (nc.mininclusive is None or v >= nc.mininclusive) and \\\n                   (nc.minexclusive is None or v > nc.minexclusive) and \\\n                   (nc.maxinclusive is None or v <= nc.maxinclusive) and \\\n                   (nc.maxexclusive is None or v < nc.maxexclusive) and \\\n                   (nc.totaldigits is None or (total_digits(n) is not None and\n                                                   total_digits(n) <= nc.totaldigits)) and \\\n                   (nc.fractiondigits is None or (fraction_digits(n) is not None and\n                                                      fraction_digits(n) <= nc.fractiondigits)):\n                    return True\n                else:\n                    if nc.mininclusive is not None and v < nc.mininclusive:\n                        cntxt.fail_reason = f\"Numeric value volation - minimum inclusive: \" \\\n                                                         f\"{nc.mininclusive} actual: {v}\"\n                    elif nc.minexclusive is not None and v <= nc.minexclusive:\n                        cntxt.fail_reason = f\"Numeric value volation - minimum exclusive: \" \\\n                                                         f\"{nc.minexclusive} actual: {v}\"\n                    elif nc.maxinclusive is not None and v > nc.maxinclusive:\n                        cntxt.fail_reason = f\"Numeric value volation - maximum inclusive: \" \\\n                                                         f\"{nc.maxinclusive} actual: {v}\"\n                    elif nc.maxexclusive is not None and v >= nc.maxexclusive:\n                        cntxt.fail_reason = f\"Numeric value volation - maximum exclusive: \" \\\n                                                         f\"{nc.maxexclusive} actual: {v}\"\n                    elif nc.totaldigits is not None and (total_digits(n) is None or\n                                                             total_digits(n) > nc.totaldigits):\n                        cntxt.fail_reason = f\"Numeric value volation - max total digits: \" \\\n                                                         f\"{nc.totaldigits} value: {v}\"\n                    elif nc.fractiondigits is not None and (fraction_digits(n) is None or\n                                                                total_digits(n) > nc.fractiondigits):\n                        cntxt.fail_reason = f\"Numeric value volation - max fractional digits: \" \\\n                                                         f\"{nc.fractiondigits} value: {v}\"\n                    else:\n                        cntxt.fail_reason = \"Impossible error - kick the programmer\"\n                    return False\n            else:\n                cntxt.fail_reason = \"Numeric test on non-number: {v}\"\n                return False\n        else:\n            cntxt.fail_reason = \"Numeric test on non-number: {n}\"\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if a node n matches any of the values in the value set nc.", "response": "def nodeSatisfiesValues(cntxt: Context, n: Node, nc: ShExJ.NodeConstraint, _c: DebugContext) -> bool:\n    \"\"\" `5.4.5 Values Constraint <http://shex.io/shex-semantics/#values>`_\n\n     For a node n and constraint value v, nodeSatisfies(n, v) if n matches some valueSetValue vsv in v.\n    \"\"\"\n    if nc.values is None:\n        return True\n    else:\n        if any(_nodeSatisfiesValue(cntxt, n, vsv) for vsv in nc.values):\n            return True\n        else:\n            cntxt.fail_reason = f\"Node: {cntxt.n3_mapper.n3(n)} not in value set:\\n\\t \" \\\n                f\"{as_json(cntxt.type_last(nc), indent=None)[:60]}...\"\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _nodeSatisfiesValue(cntxt: Context, n: Node, vsv: ShExJ.valueSetValue) -> bool:\n    vsv = map_object_literal(vsv)\n    if isinstance_(vsv, ShExJ.objectValue):\n        return objectValueMatches(n, vsv)\n\n    if isinstance(vsv, ShExJ.Language):\n        if vsv.languageTag is not None and isinstance(n, Literal) and n.language is not None:\n            return n.language == vsv.languageTag\n        else:\n            return False\n\n    if isinstance(vsv, ShExJ.IriStem):\n        return nodeInIriStem(cntxt, n, vsv.stem)\n\n    if isinstance(vsv, ShExJ.IriStemRange):\n        exclusions = vsv.exclusions if vsv.exclusions is not None else []\n        return nodeInIriStem(cntxt, n, vsv.stem) and not any(\n            (uriref_matches_iriref(n, excl) if isinstance(excl, ShExJ.IRIREF) else\n             uriref_startswith_iriref(n, excl.stem)) for excl in exclusions)\n\n    if isinstance(vsv, ShExJ.LiteralStem):\n        return nodeInLiteralStem(cntxt, n, vsv.stem)\n\n    if isinstance(vsv, ShExJ.LiteralStemRange):\n        exclusions = vsv.exclusions if vsv.exclusions is not None else []\n        return nodeInLiteralStem(cntxt, n, vsv.stem) and not any(str(n) == excl for excl in exclusions)\n\n    if isinstance(vsv, ShExJ.LanguageStem):\n        return nodeInLanguageStem(cntxt, n, vsv.stem)\n\n    if isinstance(vsv, ShExJ.LanguageStemRange):\n        exclusions = vsv.exclusions if vsv.exclusions is not None else []\n        return nodeInLanguageStem(cntxt, n, vsv.stem) and not any(str(n) == str(excl) for excl in exclusions)\n\n    return False", "response": "Returns True if the node n matches the given value set value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True iff n is in a set defined by a ShExJ. IriStem.", "response": "def nodeInIriStem(_: Context, n: Node, s: ShExJ.IriStem) -> bool:\n    \"\"\"\n       **nodeIn**: asserts that an RDF node n is equal to an RDF term s or is in a set defined by a\n       :py:class:`ShExJ.IriStem`, :py:class:`LiteralStem` or :py:class:`LanguageStem`.\n\n       The expression `nodeInIriStem(n, s)` is satisfied iff:\n        #) `s` is a :py:class:`ShExJ.WildCard` or\n        #) `n` is an :py:class:`rdflib.URIRef` and fn:starts-with(`n`, `s`)\n    \"\"\"\n    return isinstance(s, ShExJ.Wildcard) or \\\n        (isinstance(n, URIRef) and uriref_startswith_iriref(n, str(s)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nodeInLiteralStem(_: Context, n: Node, s: ShExJ.LiteralStem) -> bool:\n    return isinstance(s, ShExJ.Wildcard) or \\\n        (isinstance(n, Literal) and str(n.value).startswith(str(s)))", "response": "Checks that a node n is equal to an RDF term s."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks that a node n is in a set defined by a and that s is a language - tagged string and that n is a language - tagged string and s starts with s.", "response": "def nodeInLanguageStem(_: Context, n: Node, s: ShExJ.LanguageStem) -> bool:\n    \"\"\" http://shex.io/shex-semantics/#values\n\n        **nodeIn**: asserts that an RDF node n is equal to an RDF term s or is in a set defined by a\n        :py:class:`ShExJ.IriStem`, :py:class:`LiteralStem` or :py:class:`LanguageStem`.\n\n        The expression `nodeInLanguageStem(n, s)` is satisfied iff:\n         #) `s` is a :py:class:`ShExJ.WildCard` or\n         #) `n` is a language-tagged string and fn:starts-with(`n.language`, `s`)\n    \"\"\"\n    return isinstance(s, ShExJ.Wildcard) or \\\n        (isinstance(n, Literal) and n.language is not None and str(n.language).startswith(str(s)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nodeInBnodeStem(_cntxt: Context, _n: Node, _s: Union[str, ShExJ.Wildcard]) -> bool:\n    # TODO: resolve issue #79 to figure out how to do this\n    return False", "response": "Checks that a node n is equal to an RDF term s or is in a set defined by a\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_in_syspy(f):\n    fname = f.__name__\n    code_lines = inspect.getsource(f).splitlines()\n\n    code = dedent(\"\\n\".join(code_lines[1:]))  # strip this decorator\n\n    # add call to the function and print it's result\n    code += dedent(\"\"\"\\n\n        import sys\n        args = sys.argv[1:]\n        result = {fname}(*args)\n        print(\"%r\" % result)\n    \"\"\").format(fname=fname)\n\n    env = os.environ\n    python = findsyspy()\n    logger.debug(\"Create function for system python\\n%s\" % code)\n\n    def call_f(*args):\n        cmd = [python, '-c', code] + list(args)\n        output = subprocess.check_output(cmd, env=env).decode('utf-8')\n        result = ast.literal_eval(output)\n        return result\n\n    return call_f", "response": "Decorator to run a function in the system python\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef in_venv():\n    global _in_venv\n    if _in_venv is not None:\n        return _in_venv\n\n    if not (os.path.isfile(ORIG_PREFIX_TXT) or os.path.isfile(PY_VENV_CFG)):\n        logger.debug(\"in_venv no orig_prefix_txt [%s]\", ORIG_PREFIX_TXT)\n        logger.debug(\"in_venv no py_venv_cfg [%s]\", PY_VENV_CFG)\n        # TODO - check this is actually valid !\n        _in_venv = False\n        return _in_venv\n\n    if 'VIRTUAL_ENV' in os.environ:\n        logger.debug(\"in_venv VIRTUAL_ENV set.\")\n        _in_venv = True\n    else:\n        # Find first python in path ... if its not this one,\n        # ...we are in a different python\n        python = basename(sys.executable)\n        for p in os.environ['PATH'].split(os.pathsep):\n            py_path = join(p, python)\n            if isfile(py_path):\n                logger.debug(\"in_venv py_at [%s] return: %s\", (py_path, sys.executable != py_path))\n                _in_venv = sys.executable != py_path\n                break\n\n    return _in_venv", "response": "Returns True if in a virtualenv False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getsyssitepackages():\n    global _syssitepackages\n    if not _syssitepackages:\n        if not in_venv():\n            _syssitepackages = get_python_lib()\n            return _syssitepackages\n\n        @run_in_syspy\n        def run(*args):\n            import site\n            return site.getsitepackages()\n\n        output = run()\n        _syssitepackages = output\n        logger.debug(\"system site packages: %s\", _syssitepackages)\n    return _syssitepackages", "response": "Returns a list of site - packages from system python\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the system python executable.", "response": "def findsyspy():\n    \"\"\"\n    :return: system python executable\n    \"\"\"\n    if not in_venv():\n        return sys.executable\n\n    python = basename(realpath(sys.executable))\n    prefix = None\n    if HAS_ORIG_PREFIX_TXT:\n        with open(ORIG_PREFIX_TXT) as op:\n            prefix = op.read()\n    elif HAS_PY_VENV_CFG:\n        prefix = getattr(sys, \"_home\")\n\n    if not prefix:\n        return None\n\n    for folder in os.environ['PATH'].split(os.pathsep):\n        if folder and \\\n                normpath(normcase(folder)).startswith(normcase(normpath(prefix))) and \\\n                isfile(join(folder, python)):\n            return join(folder, python)\n\n    # OSX: Homebrew doesn't leave python in the PATH\n    if isfile(join(prefix, \"bin\", python)):\n        return join(prefix, \"bin\", python)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a key from the cache.", "response": "def delete(self, key, cas=0):\n        \"\"\"\n        Delete a key/value from server. If key does not exist, it returns True.\n\n        :param key: Key's name to be deleted\n        :param cas: CAS of the key\n        :return: True in case o success and False in case of failure.\n        \"\"\"\n        server = self._get_server(key)\n        return server.delete(key, cas)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a value for a key on server.", "response": "def set(self, key, value, time=0, compress_level=-1):\n        \"\"\"\n        Set a value for a key on server.\n\n        :param key: Key's name\n        :type key: str\n        :param value: A value to be stored on server.\n        :type value: object\n        :param time: Time in seconds that your key will expire.\n        :type time: int\n        :param compress_level: How much to compress.\n            0 = no compression, 1 = fastest, 9 = slowest but best,\n            -1 = default compression level.\n        :type compress_level: int\n        :return: True in case of success and False in case of failure\n        :rtype: bool\n        \"\"\"\n        server = self._get_server(key)\n        return server.set(key, value, time, compress_level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_multi(self, mappings, time=0, compress_level=-1):\n        returns = []\n        if not mappings:\n            return False\n        server_mappings = defaultdict(dict)\n        for key, value in mappings.items():\n            server_key = self._get_server(key)\n            server_mappings[server_key].update([(key, value)])\n        for server, m in server_mappings.items():\n            returns.append(server.set_multi(m, time, compress_level))\n\n        return all(returns)", "response": "Set multiple keys with it s values on server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, key, value, time=0, compress_level=-1):\n        server = self._get_server(key)\n        return server.add(key, value, time, compress_level)", "response": "Add a key value pair to the cache ony if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace(self, key, value, time=0, compress_level=-1):\n        server = self._get_server(key)\n        return server.replace(key, value, time, compress_level)", "response": "Replace a key value in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets multiple keys from server.", "response": "def get_multi(self, keys, get_cas=False):\n        \"\"\"\n        Get multiple keys from server.\n\n        :param keys: A list of keys to from server.\n        :type keys: list\n        :param get_cas: If get_cas is true, each value is (data, cas), with each result's CAS value.\n        :type get_cas: boolean\n        :return: A dict with all requested keys.\n        :rtype: dict\n        \"\"\"\n        servers = defaultdict(list)\n        d = {}\n        for key in keys:\n            server_key = self._get_server(key)\n            servers[server_key].append(key)\n        for server, keys in servers.items():\n            results = server.get_multi(keys)\n            if not get_cas:\n                # Remove CAS data\n                for key, (value, cas) in results.items():\n                    results[key] = value\n            d.update(results)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a value for a key on server if its CAS value matches cas.", "response": "def cas(self, key, value, cas, time=0, compress_level=-1):\n        \"\"\"\n        Set a value for a key on server if its CAS value matches cas.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: A value to be stored on server.\n        :type value: object\n        :param cas: The CAS value previously obtained from a call to get*.\n        :type cas: int\n        :param time: Time in seconds that your key will expire.\n        :type time: int\n        :param compress_level: How much to compress.\n            0 = no compression, 1 = fastest, 9 = slowest but best,\n            -1 = default compression level.\n        :type compress_level: int\n        :return: True in case of success and False in case of failure\n        :rtype: bool\n        \"\"\"\n        server = self._get_server(key)\n        return server.cas(key, value, cas, time, compress_level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nincrements a key s name by a given value.", "response": "def incr(self, key, value):\n        \"\"\"\n        Increment a key, if it exists, returns it's actual value, if it don't, return 0.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: Number to be incremented\n        :type value: int\n        :return: Actual value of the key on server\n        :rtype: int\n        \"\"\"\n        server = self._get_server(key)\n        return server.incr(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decr(self, key, value):\n        server = self._get_server(key)\n        return server.decr(key, value)", "response": "Decrements a key s value on the server. Returns 0 if the key doesn t exist returns value of the key on server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true iff n satisfies shape S.", "response": "def satisfiesShape(cntxt: Context, n: Node, S: ShExJ.Shape, c: DebugContext) -> bool:\n    \"\"\" `5.5.2 Semantics <http://shex.io/shex-semantics/#triple-expressions-semantics>`_\n\n    For a node `n`, shape `S`, graph `G`, and shapeMap `m`, `satisfies(n, S, G, m)` if and only if:\n\n    * `neigh(G, n)` can be partitioned into two sets matched and remainder such that\n      `matches(matched, expression, m)`. If expression is absent, remainder = `neigh(G, n)`.\n\n    :param n: focus node\n    :param S: Shape to be satisfied\n    :param cntxt: Evaluation context\n    :param c: Debug context\n    :return: true iff `satisfies(n, S, cntxt)`\n    \"\"\"\n\n    # Recursion detection.  If start_evaluating returns a boolean value, this is the assumed result of the shape\n    # evaluation.  If it returns None, then an initial evaluation is needed\n    rslt = cntxt.start_evaluating(n, S)\n\n    if rslt is None:\n        cntxt.evaluate_stack.append((n, S.id))\n        predicates = directed_predicates_in_expression(S, cntxt)\n        matchables = RDFGraph()\n\n        # Note: The code below does an \"over-slurp\" for the sake of expediency.  If you are interested in\n        #       getting EXACTLY the needed triples, set cntxt.over_slurp to false\n        if isinstance(cntxt.graph, SlurpyGraph) and cntxt.over_slurp:\n            with slurper(cntxt, n, S) as g:\n                _ = g.triples((n, None, None))\n\n        for predicate, direction in predicates.items():\n            with slurper(cntxt, n, S) as g:\n                matchables.add_triples(g.triples((n if direction.is_fwd else None,\n                                                  iriref_to_uriref(predicate),\n                                                  n if direction.is_rev else None)))\n\n        if c.debug:\n            print(c.i(1, \"predicates:\", sorted(cntxt.n3_mapper.n3(p) for p in predicates.keys())))\n            print(c.i(1, \"matchables:\", sorted(cntxt.n3_mapper.n3(m) for m in matchables)))\n            print()\n\n        if S.closed:\n            # TODO: Is this working correctly on reverse items?\n            non_matchables = RDFGraph([t for t in arcsOut(cntxt.graph, n) if t not in matchables])\n            if len(non_matchables):\n                cntxt.fail_reason = \"Unmatched triples in CLOSED shape:\"\n                cntxt.fail_reason = '\\n'.join(f\"\\t{t}\" for t in non_matchables)\n                if c.debug:\n                    print(c.i(0,\n                              f\"<--- Satisfies shape {c.d()} FAIL - \"\n                              f\"{len(non_matchables)} non-matching triples on a closed shape\"))\n                    print(c.i(1, \"\", list(non_matchables)))\n                    print()\n                return False\n\n\n        # Evaluate the actual expression.  Start assuming everything matches...\n        if S.expression:\n            if matches(cntxt, matchables, S.expression):\n                rslt = True\n            else:\n                extras = {iriref_to_uriref(e) for e in S.extra} if S.extra is not None else {}\n                if len(extras):\n                    permutable_matchables = RDFGraph([t for t in matchables if t.p in extras])\n                    non_permutable_matchables = RDFGraph([t for t in matchables if t not in permutable_matchables])\n                    if c.debug:\n                        print(c.i(1,\n                                  f\"Complete match failed -- evaluating extras\", list(extras)))\n                    for matched, remainder in partition_2(permutable_matchables):\n                        permutation = non_permutable_matchables.union(matched)\n                        if matches(cntxt, permutation, S.expression):\n                            rslt = True\n                            break\n                rslt = rslt or False\n        else:\n            rslt = True         # Empty shape\n\n        # If an assumption was made and the result doesn't match the assumption, switch directions and try again\n        done, consistent = cntxt.done_evaluating(n, S, rslt)\n        if not done:\n            rslt = satisfiesShape(cntxt, n, S)\n        rslt = rslt and consistent\n\n        cntxt.evaluate_stack.pop()\n    return rslt"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if remainder is valid.", "response": "def valid_remainder(cntxt: Context, n: Node, matchables: RDFGraph, S: ShExJ.Shape) -> bool:\n    \"\"\"\n    Let **outs** be the arcsOut in remainder: `outs = remainder \u2229 arcsOut(G, n)`.\n\n    Let **matchables** be the triples in outs whose predicate appears in a TripleConstraint in `expression`. If\n    `expression` is absent, matchables = \u00d8 (the empty set).\n\n    * There is no triple in **matchables** which matches a TripleConstraint in expression\n\n    * There is no triple in **matchables** whose predicate does not appear in extra.\n\n    * closed is false or unmatchables is empty\n\n    :param cntxt: evaluation context\n    :param n: focus node\n    :param matchables: non-matched triples\n    :param S: Shape being evaluated\n    :return: True if remainder is valid\n    \"\"\"\n    # TODO: Update this and satisfies to address the new algorithm\n    # Let **outs** be the arcsOut in remainder: `outs = remainder \u2229 arcsOut(G, n)`.\n    outs = arcsOut(cntxt.graph, n).intersection(matchables)\n\n    # predicates that in a TripleConstraint in `expression`\n    predicates = predicates_in_expression(S, cntxt)\n\n    # Let **matchables** be the triples in outs whose predicate appears in predicates. If\n    # `expression` is absent, matchables = \u00d8 (the empty set).\n    matchables = RDFGraph(t for t in outs if str(t.p) in predicates)\n\n    # There is no triple in **matchables** which matches a TripleConstraint in expression\n    if matchables and S.expression is not None:\n        tes = triple_constraints_in_expression(S.expression, cntxt)\n        for m in matchables:\n            if any(matchesTripleConstraint(cntxt, m, te) for te in tes):\n                return False\n\n    # There is no triple in **matchables** whose predicate does not appear in extra.\n    extras = {iriref_to_uriref(e) for e in S.extra} if S.extra is not None else {}\n    if any(t.p not in extras for t in matchables):\n        return False\n\n    # closed is false or unmatchables is empty.\n    return not S.closed.val or not bool(outs - matchables)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef matches(cntxt: Context, T: RDFGraph, expr: ShExJ.tripleExpr) -> bool:\n    if isinstance_(expr, ShExJ.tripleExprLabel):\n        return matchesExpr(cntxt, T, expr)\n    else:\n        return matchesCardinality(cntxt, T, expr) and (expr.semActs is None or semActsSatisfied(expr.semActs, cntxt))", "response": "Returns True if the given expression matches the neighbourhood of the given T."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef matchesCardinality(cntxt: Context, T: RDFGraph, expr: Union[ShExJ.tripleExpr, ShExJ.tripleExprLabel],\n                       c: DebugContext) -> bool:\n    \"\"\" Evaluate cardinality expression\n\n    expr has a cardinality of min and/or max not equal to 1, where a max of -1 is treated as unbounded, and\n    T can be partitioned into k subsets T1, T2,\u2026Tk such that min \u2264 k \u2264 max and for each Tn,\n    matches(Tn, expr, m) by the remaining rules in this list.\n    \"\"\"\n    # TODO: Cardinality defaults into spec\n    min_ = expr.min if expr.min is not None else 1\n    max_ = expr.max if expr.max is not None else 1\n\n    cardinality_text = f\"{{{min_},{'*' if max_ == -1 else max_}}}\"\n    if c.debug and (min_ != 0 or len(T) != 0):\n        print(f\"{cardinality_text} matching {len(T)} triples\")\n    if min_ == 0 and len(T) == 0:\n        return True\n    if isinstance(expr, ShExJ.TripleConstraint):\n        if len(T) < min_:\n            if len(T) > 0:\n                _fail_triples(cntxt, T)\n                cntxt.fail_reason = f\"   {len(T)} triples less than {cardinality_text}\"\n            else:\n                cntxt.fail_reason = f\"   No matching triples found for predicate {cntxt.n3_mapper.n3(expr.predicate)}\"\n            return False\n        elif 0 <= max_ < len(T):\n            _fail_triples(cntxt, T)\n            cntxt.fail_reason = f\"   {len(T)} triples exceeds max {cardinality_text}\"\n            return False\n        else:\n            return all(matchesTripleConstraint(cntxt, t, expr) for t in T)\n    else:\n        for partition in _partitions(T, min_, max_):\n            if all(matchesExpr(cntxt, part, expr) for part in partition):\n                return True\n        if min_ != 1 or max_ != 1:\n            _fail_triples(cntxt, T)\n            cntxt.fail_reason = f\"   {len(T)} triples cannot be partitioned into {cardinality_text} passing groups\"\n        return False", "response": "Evaluate cardinality expression and return True if all triples in T match expr."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if expr matches the context T.", "response": "def matchesOneOf(cntxt: Context, T: RDFGraph, expr: ShExJ.OneOf, _: DebugContext) -> bool:\n    \"\"\"\n    expr is a OneOf and there is some shape expression se2 in shapeExprs such that a matches(T, se2, m).\n    \"\"\"\n    return any(matches(cntxt, T, e) for e in expr.expressions)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if expr matches T.", "response": "def matchesEachOf(cntxt: Context, T: RDFGraph, expr: ShExJ.EachOf, _: DebugContext) -> bool:\n    \"\"\" expr is an EachOf and there is some partition of T into T1, T2,\u2026 such that for every expression\n     expr1, expr2,\u2026 in shapeExprs, matches(Tn, exprn, m).\n     \"\"\"\n\n    return EachOfEvaluator(cntxt, T, expr).evaluate(cntxt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef matchesTripleConstraint(cntxt: Context, t: RDFTriple, expr: ShExJ.TripleConstraint, c: DebugContext) -> bool:\n    from pyshex.shape_expressions_language.p5_3_shape_expressions import satisfies\n\n    if c.debug:\n        print(c.i(1, f\" triple: {t}\"))\n        print(c.i(1, '', expr._as_json_dumps().split('\\n')))\n\n    if uriref_matches_iriref(t.p, expr.predicate):\n        value = t.s if expr.inverse else t.o\n        return expr.valueExpr is None or satisfies(cntxt, value, expr.valueExpr)\n    else:\n        cntxt.fail_reason = f\"Predicate mismatch: {t.p} \u2260 {expr.predicate}\"\n        return False", "response": "Return True if the triple t matches expr."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the given tripleExprRef is a valid tripleExprRef.", "response": "def matchesTripleExprRef(cntxt: Context, T: RDFGraph, expr: ShExJ.tripleExprLabel, _: DebugContext) -> bool:\n    \"\"\"\n    expr is an tripleExprRef and satisfies(value, tripleExprWithId(tripleExprRef), G, m).\n    The tripleExprWithId function is defined in Triple Expression Reference Requirement below.\n    \"\"\"\n    expr = cntxt.tripleExprFor(expr)\n    if expr is None:\n        cntxt.fail_reason = \"{expr}: Reference not found\"\n        return False\n    return matchesExpr(cntxt, T, expr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, key, get_cas=False):\n        for server in self.servers:\n            value, cas = server.get(key)\n            if value is not None:\n                if get_cas:\n                    return value, cas\n                else:\n                    return value\n        if get_cas:\n            return None, None", "response": "Get a key from server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a key from server returning the value and its CAS key.", "response": "def gets(self, key):\n        \"\"\"\n        Get a key from server, returning the value and its CAS key.\n\n        This method is for API compatibility with other implementations.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :return: Returns (key data, value), or (None, None) if the value is not in cache.\n        :rtype: object\n        \"\"\"\n        for server in self.servers:\n            value, cas = server.get(key)\n            if value is not None:\n                return value, cas\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_multi(self, keys, get_cas=False):\n        d = {}\n        if keys:\n            for server in self.servers:\n                results = server.get_multi(keys)\n                if not get_cas:\n                    # Remove CAS data\n                    for key, (value, cas) in results.items():\n                        results[key] = value\n                d.update(results)\n                keys = [_ for _ in keys if _ not in d]\n                if not keys:\n                    break\n        return d", "response": "Get multiple keys from server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set(self, key, value, time=0, compress_level=-1):\n        returns = []\n        for server in self.servers:\n            returns.append(server.set(key, value, time, compress_level=compress_level))\n\n        return any(returns)", "response": "Set a value for a key on server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_multi(self, mappings, time=0, compress_level=-1):\n        returns = []\n        if mappings:\n            for server in self.servers:\n                returns.append(server.set_multi(mappings, time, compress_level=compress_level))\n\n        return all(returns)", "response": "Set multiple keys with it s values on server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting a key from server.", "response": "def delete(self, key, cas=0):\n        \"\"\"\n        Delete a key/value from server. If key does not exist, it returns True.\n\n        :param key: Key's name to be deleted\n        :param cas: CAS of the key\n        :return: True in case o success and False in case of failure.\n        \"\"\"\n        returns = []\n        for server in self.servers:\n            returns.append(server.delete(key, cas))\n\n        return any(returns)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef incr(self, key, value):\n        returns = []\n        for server in self.servers:\n            returns.append(server.incr(key, value))\n\n        return returns[0]", "response": "Increment a key on a server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decr(self, key, value):\n        returns = []\n        for server in self.servers:\n            returns.append(server.decr(key, value))\n\n        return returns[0]", "response": "Decrements a key on a server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_result(self, rval: bool) -> None:\n        self.result = rval\n        if self.result:\n            self.nodes = [pn for pn in self.nodes if pn.result]", "response": "Set the result of the evaluation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the shape expression in the schema referenced by selector if any", "response": "def reference_of(selector: shapeLabel, cntxt: Union[Context, ShExJ.Schema] ) -> Optional[ShExJ.shapeExpr]:\n    \"\"\" Return the shape expression in the schema referenced by selector, if any\n\n    :param cntxt: Context node or ShEx Schema\n    :param selector: identifier of element to select within the schema\n    :return:\n    \"\"\"\n    schema = cntxt.schema if isinstance(cntxt, Context) else cntxt\n    if selector is START:\n        return schema.start\n    for expr in schema.shapes:\n        if not isinstance(expr, ShExJ.ShapeExternal) and expr.id == selector:\n            return expr\n    return schema.start if schema.start is not None and schema.start.id == selector else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching for the label in a Schema", "response": "def triple_reference_of(label: ShExJ.tripleExprLabel, cntxt: Context) -> Optional[ShExJ.tripleExpr]:\n    \"\"\" Search for the label in a Schema \"\"\"\n    te: Optional[ShExJ.tripleExpr] = None\n    if cntxt.schema.start is not None:\n        te = triple_in_shape(cntxt.schema.start, label, cntxt)\n    if te is None:\n        for shapeExpr in cntxt.schema.shapes:\n            te = triple_in_shape(shapeExpr, label, cntxt)\n            if te:\n                break\n    return te"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef triple_in_shape(expr: ShExJ.shapeExpr, label: ShExJ.tripleExprLabel, cntxt: Context) \\\n        -> Optional[ShExJ.tripleExpr]:\n    \"\"\" Search for the label in a shape expression \"\"\"\n    te = None\n    if isinstance(expr, (ShExJ.ShapeOr, ShExJ.ShapeAnd)):\n        for expr2 in expr.shapeExprs:\n            te = triple_in_shape(expr2, label, cntxt)\n            if te is not None:\n                break\n    elif isinstance(expr, ShExJ.ShapeNot):\n        te = triple_in_shape(expr.shapeExpr, label, cntxt)\n    elif isinstance(expr, ShExJ.shapeExprLabel):\n        se = reference_of(expr, cntxt)\n        if se is not None:\n            te = triple_in_shape(se, label, cntxt)\n    return te", "response": "Search for the label in a shape expression"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the set of predicates that appear in a TripleConstraint in an expression", "response": "def predicates_in_expression(expression: ShExJ.shapeExpr, cntxt: Context) -> List[IRIREF]:\n    \"\"\" Return the set of predicates that \"appears in a TripleConstraint in an expression\n    \n    See: `5.5.2 Semantics <http://shex.io/shex-semantics/#triple-expressions-semantics>`_ for details\n\n    :param expression: Expression to scan for predicates\n    :param cntxt: Context of evaluation\n    :return: List of predicates\n    \"\"\"\n    return list(directed_predicates_in_expression(expression, cntxt).keys())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndirecting predicates in expression -- return all predicates in shapeExpr along with which direction they evaluate", "response": "def directed_predicates_in_expression(expression: ShExJ.shapeExpr, cntxt: Context) -> Dict[IRIREF, PredDirection]:\n    \"\"\" Directed predicates in expression -- return all predicates in shapeExpr along with which direction(s) they\n    evaluate\n\n    :param expression: Expression to scan\n    :param cntxt:\n    :return:\n    \"\"\"\n    dir_predicates: Dict[IRIREF, PredDirection] = {}\n\n    def predicate_finder(predicates: Dict[IRIREF, PredDirection], tc: ShExJ.TripleConstraint, _: Context) -> None:\n        if isinstance(tc, ShExJ.TripleConstraint):\n            predicates.setdefault(tc.predicate, PredDirection()).dir(tc.inverse is None or not tc.inverse)\n\n    def triple_expr_finder(predicates: Dict[IRIREF, PredDirection], expr: ShExJ.shapeExpr, cntxt_: Context) -> None:\n        if isinstance(expr, ShExJ.Shape) and expr.expression is not None:\n            cntxt_.visit_triple_expressions(expr.expression, predicate_finder, predicates)\n\n    # TODO: follow_inner_shapes as True probably goes too far, but we definitely need to cross shape/triplecons\n    cntxt.visit_shapes(expression, triple_expr_finder, dir_predicates, follow_inner_shapes=False)\n    return dir_predicates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking from `Stack Overflow <https://codereview.stackexchange.com/questions/1526/finding-all-k-subset-partitions>`_", "response": "def algorithm_u(ns, m):\n    \"\"\"\n    taken from `Stack Overflow <https://codereview.stackexchange.com/questions/1526/finding-all-k-subset-partitions>`_\n\n    \"\"\"\n    def visit(nv, av):\n        ps = [[] for _ in range(m)]\n        for jv in range(nv):\n            ps[av[jv + 1]].append(ns[jv])\n        return ps\n\n    def f(mu, nu, sigma, n, a):\n        if mu == 2:\n            yield visit(n, a)\n        else:\n            for v in f(mu - 1, nu - 1, (mu + sigma) % 2, n, a):\n                yield v\n        if nu == mu + 1:\n            a[mu] = mu - 1\n            yield visit(n, a)\n            while a[nu] > 0:\n                a[nu] = a[nu] - 1\n                yield visit(n, a)\n        elif nu > mu + 1:\n            if (mu + sigma) % 2 == 1:\n                a[nu - 1] = mu - 1\n            else:\n                a[mu] = mu - 1\n            if (a[nu] + sigma) % 2 == 1:\n                for v in b(mu, nu - 1, 0, n, a):\n                    yield v\n            else:\n                for v in f(mu, nu - 1, 0, n, a):\n                    yield v\n            while a[nu] > 0:\n                a[nu] = a[nu] - 1\n                if (a[nu] + sigma) % 2 == 1:\n                    for v in b(mu, nu - 1, 0, n, a):\n                        yield v\n                else:\n                    for v in f(mu, nu - 1, 0, n, a):\n                        yield v\n\n    def b(mu, nu, sigma, n, a):\n        if nu == mu + 1:\n            while a[nu] < mu - 1:\n                yield visit(n, a)\n                a[nu] = a[nu] + 1\n            yield visit(n, a)\n            a[mu] = 0\n        elif nu > mu + 1:\n            if (a[nu] + sigma) % 2 == 1:\n                for v in f(mu, nu - 1, 0, n, a):\n                    yield v\n            else:\n                for v in b(mu, nu - 1, 0, n, a):\n                    yield v\n            while a[nu] < mu - 1:\n                a[nu] = a[nu] + 1\n                if (a[nu] + sigma) % 2 == 1:\n                    for v in f(mu, nu - 1, 0, n, a):\n                        yield v\n                else:\n                    for v in b(mu, nu - 1, 0, n, a):\n                        yield v\n            if (mu + sigma) % 2 == 1:\n                a[nu - 1] = 0\n            else:\n                a[mu] = 0\n        if mu == 2:\n            yield visit(n, a)\n        else:\n            for v in b(mu - 1, nu - 1, (mu + sigma) % 2, n, a):\n                yield v\n\n    ng = len(ns)\n    ag = [0] * (ng + 1)\n    for j in range(1, m + 1):\n        ag[ng - m + j] = j - 1\n    return f(m, ng, 0, ng, ag) if m > 1 else [[ns]]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef integer_partition(size: int, nparts: int) -> Iterator[List[List[int]]]:\n    for part in algorithm_u(range(size), nparts):\n        yield part", "response": "Partition a list of integers into a list of partitions"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npartitions T into all possible partitions of nparts of T.", "response": "def partition_t(T: RDFGraph, nparts: int) -> Iterator[Tuple[RDFGraph, ...]]:\n    \"\"\"\n    Partition T into all possible partitions of T of size nparts\n    :param T: Set of RDF triples to be partitioned\n    :param nparts: number of partitions (e.g. 2 means return all possible 2 set partitions\n    :return: Iterator that returns partitions\n\n    We don't actually partition the triples directly -- instead, we partition a set of integers that\n    reference elements in the (ordered) set and return those\n    \"\"\"\n    def partition_map(partition: List[List[int]]) -> Tuple[RDFGraph, ...]:\n        rval: List[RDFGraph, ...] = []\n        for part in partition:\n            if len(part) == 1 and part[0] >= t_list_len:\n                rval.append(RDFGraph())\n            else:\n                rval.append(RDFGraph([t_list[e] for e in part if e < t_list_len]))\n        return tuple(rval)\n\n    t_list = sorted(list(T))      # Sorted not strictly necessary, but aids testing\n    t_list_len = len(t_list)\n    return map(lambda partition: partition_map(partition), filtered_integer_partition(t_list_len, nparts))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npartitioning T into all possible combinations of two subsets of T.", "response": "def partition_2(T: RDFGraph) -> List[Tuple[RDFGraph, RDFGraph]]:\n    \"\"\"\n    Partition T into all possible combinations of two subsets\n    :param T: RDF Graph to partition\n    :return:\n    \"\"\"\n    for p in partition_t(T, 2):\n        yield p"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns true if the node n is a numeric type.", "response": "def is_strict_numeric(n: Node) -> bool:\n    \"\"\" numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double. \"\"\"\n    return is_typed_literal(n) and cast(Literal, n).datatype in [XSD.integer, XSD.decimal, XSD.float, XSD.double]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn true if n is a simple literal.", "response": "def is_simple_literal(n: Node) -> bool:\n    \"\"\" simple literal denotes a plain literal with no language tag. \"\"\"\n    return is_typed_literal(n) and cast(Literal, n).datatype is None and cast(Literal, n).language is None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef semActsSatisfied(acts: Optional[List[ShExJ.SemAct]], cntxt: Context) -> bool:\n    return True", "response": "5. 7. 1 Semantic Actions Semantics <http://shex. io / shex - semantics/#semantic - actions - semantic > _semActsSatisfied"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset(self) -> None:\n        self.evaluating = set()\n        self.assumptions = {}\n        self.known_results = {}\n        self.current_node = None\n        self.evaluate_stack = []\n        self.bnode_map = {}", "response": "Reset the context before an evaluation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the schema_id_map for the given root shape expression.", "response": "def _gen_schema_xref(self, expr: Optional[Union[ShExJ.shapeExprLabel, ShExJ.shapeExpr]]) -> None:\n        \"\"\"\n        Generate the schema_id_map\n\n        :param expr: root shape expression\n        \"\"\"\n        if expr is not None and not isinstance_(expr, ShExJ.shapeExprLabel) and 'id' in expr and expr.id is not None:\n            abs_id = self._resolve_relative_uri(expr.id)\n            if abs_id not in self.schema_id_map:\n                self.schema_id_map[abs_id] = expr\n                if isinstance(expr, (ShExJ.ShapeOr, ShExJ.ShapeAnd)):\n                    for expr2 in expr.shapeExprs:\n                        self._gen_schema_xref(expr2)\n                elif isinstance(expr, ShExJ.ShapeNot):\n                    self._gen_schema_xref(expr.shapeExpr)\n                elif isinstance(expr, ShExJ.Shape):\n                    if expr.expression is not None:\n                        self._gen_te_xref(expr.expression)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _gen_te_xref(self, expr: Union[ShExJ.tripleExpr, ShExJ.tripleExprLabel]) -> None:\n        if expr is not None and not isinstance_(expr, ShExJ.tripleExprLabel) and 'id' in expr and expr.id is not None:\n            if expr.id in self.te_id_map:\n                return\n            else:\n                self.te_id_map[self._resolve_relative_uri(expr.id)] = expr\n        if isinstance(expr, (ShExJ.OneOf, ShExJ.EachOf)):\n            for expr2 in expr.expressions:\n                self._gen_te_xref(expr2)\n        elif isinstance(expr, ShExJ.TripleConstraint):\n            if expr.valueExpr is not None:\n                self._gen_schema_xref(expr.valueExpr)", "response": "Generate the triple expression id - > TE ID mapping"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the triple expression that corresponds to the given id", "response": "def tripleExprFor(self, id_: ShExJ.tripleExprLabel) -> ShExJ.tripleExpr:\n        \"\"\" Return the triple expression that corresponds to id \"\"\"\n        return self.te_id_map.get(id_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef shapeExprFor(self, id_: Union[ShExJ.shapeExprLabel, START]) -> Optional[ShExJ.shapeExpr]:\n        rval = self.schema.start if id_ is START else self.schema_id_map.get(str(id_))\n        return rval", "response": "Return the shape expression that corresponds to id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_shapes(self, expr: ShExJ.shapeExpr, f: Callable[[Any, ShExJ.shapeExpr, \"Context\"], None], arg_cntxt: Any,\n                     visit_center: _VisitorCenter = None, follow_inner_shapes: bool=True) -> None:\n        \"\"\"\n        Visit expr and all of its \"descendant\" shapes.\n\n        :param expr: root shape expression\n        :param f: visitor function\n        :param arg_cntxt: accompanying context for the visitor function\n        :param visit_center: Recursive visit context.  (Not normally supplied on an external call)\n        :param follow_inner_shapes: Follow nested shapes or just visit on outer level\n        \"\"\"\n        if visit_center is None:\n            visit_center = _VisitorCenter(f, arg_cntxt)\n        has_id = getattr(expr, 'id', None) is not None\n        if not has_id or not (visit_center.already_seen_shape(expr.id)\n                              or visit_center.actively_visiting_shape(expr.id)):\n\n            # Visit the root expression\n            if has_id:\n                visit_center.start_visiting_shape(expr.id)\n            f(arg_cntxt, expr, self)\n\n            # Traverse the expression and visit its components\n            if isinstance(expr, (ShExJ.ShapeOr, ShExJ.ShapeAnd)):\n                for expr2 in expr.shapeExprs:\n                    self.visit_shapes(expr2, f, arg_cntxt, visit_center, follow_inner_shapes=follow_inner_shapes)\n            elif isinstance(expr, ShExJ.ShapeNot):\n                self.visit_shapes(expr.shapeExpr, f, arg_cntxt, visit_center, follow_inner_shapes=follow_inner_shapes)\n            elif isinstance(expr, ShExJ.Shape):\n                if expr.expression is not None and follow_inner_shapes:\n                    self.visit_triple_expressions(expr.expression,\n                                                  lambda ac, te, cntxt: self._visit_shape_te(te, visit_center),\n                                                  arg_cntxt,\n                                                  visit_center)\n            elif isinstance_(expr, ShExJ.shapeExprLabel):\n                if not visit_center.actively_visiting_shape(str(expr)) and follow_inner_shapes:\n                    visit_center.start_visiting_shape(str(expr))\n                    self.visit_shapes(self.shapeExprFor(expr), f, arg_cntxt, visit_center)\n                    visit_center.done_visiting_shape(str(expr))\n            if has_id:\n                visit_center.done_visiting_shape(expr.id)", "response": "Visit the expression and all of its descendant shapes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _visit_shape_te(self, te: ShExJ.tripleExpr, visit_center: _VisitorCenter) -> None:\n        if isinstance(te, ShExJ.TripleConstraint) and te.valueExpr is not None:\n            visit_center.f(visit_center.arg_cntxt, te.valueExpr, self)", "response": "Visit a shape triple expression that was reached through a shape."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _visit_te_shape(self, shape: ShExJ.shapeExpr, visit_center: _VisitorCenter) -> None:\n        if isinstance(shape, ShExJ.Shape) and shape.expression is not None:\n            visit_center.f(visit_center.arg_cntxt, shape.expression, self)", "response": "Visit a shape expression that was reached through a triple expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nindicate that we are beginning to evaluate n according to shape expression s.", "response": "def start_evaluating(self, n: Node, s: ShExJ.shapeExpr) -> Optional[bool]:\n        \"\"\"Indicate that we are beginning to evaluate n according to shape expression s.\n        If we are already in the process of evaluating (n,s), as indicated self.evaluating, we return our current\n        guess as to the result.\n\n        :param n: Node to be evaluated\n        :param s: expression for node evaluation\n        :return: Assumed evaluation result.  If None, evaluation must be performed\n        \"\"\"\n        if not s.id:\n            s.id = str(BNode())                 # Random permanant id\n        key = (n, s.id)\n\n        # We only evaluate a node once\n        if key in self.known_results:\n            return self.known_results[key]\n\n        if key not in self.evaluating:\n            self.evaluating.add(key)\n            return None\n        elif key not in self.assumptions:\n            self.assumptions[key] = True\n        return self.assumptions[key]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef done_evaluating(self, n: Node, s: ShExJ.shapeExpr, result: bool) -> Tuple[bool, bool]:\n        key = (n, s.id)\n\n        # If we didn't have to assume anything or our assumption was correct, we're done\n        if key not in self.assumptions or self.assumptions[key] == result:\n            if key in self.assumptions:\n                del self.assumptions[key]       # good housekeeping, not strictly necessary\n            self.evaluating.remove(key)\n            self.known_results[key] = result\n            return True, True\n        # If we assumed true and got a false, try assuming false\n        elif self.assumptions[key]:\n            self.evaluating.remove(key)         # restart the evaluation from the top\n            self.assumptions[key] = False\n            return False, True\n        else:\n            self.fail_reason = f\"{s.id}: Inconsistent recursive shape reference\"\n            return True, False", "response": "Indicate that we have completed an evaluation of the node n and s."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmoves the type identifiers to the end of the object for print purposes", "response": "def type_last(self, obj: JsonObj) -> JsonObj:\n        \"\"\" Move the type identifiers to the end of the object for print purposes \"\"\"\n        def _tl_list(v: List) -> List:\n            return [self.type_last(e) if isinstance(e, JsonObj)\n                                   else _tl_list(e) if isinstance(e, list) else e for e in v if e is not None]\n\n        rval = JsonObj()\n        for k in as_dict(obj).keys():\n            v = obj[k]\n            if v is not None and k not in ('type', '_context'):\n                rval[k] = _tl_list(v) if isinstance(v, list) else self.type_last(v) if isinstance(v, JsonObj) else v\n\n        if 'type' in obj and obj.type:\n            rval.type = obj.type\n        return rval"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntesting if a given shape expression n satisfies a given shape expression G m.", "response": "def satisfies(cntxt: Context, n: Node, se: ShExJ.shapeExpr) -> bool:\n    \"\"\" `5.3 Shape Expressions <http://shex.io/shex-semantics/#node-constraint-semantics>`_\n\n          satisfies: The expression satisfies(n, se, G, m) indicates that a node n and graph G satisfy a shape\n                      expression se with shapeMap m.\n\n           satisfies(n, se, G, m) is true if and only if:\n\n            * Se is a NodeConstraint and satisfies2(n, se) as described below in Node Constraints.\n                      Note that testing if a node satisfies a node constraint does not require a graph or shapeMap.\n            * Se is a Shape and satisfies(n, se) as defined below in Shapes and Triple Expressions.\n            * Se is a ShapeOr and there is some shape expression se2 in shapeExprs such that\n            satisfies(n, se2, G, m).\n            * Se is a ShapeAnd and for every shape expression se2 in shapeExprs, satisfies(n, se2, G, m).\n            * Se is a ShapeNot and for the shape expression se2 at shapeExpr, notSatisfies(n, se2, G, m).\n            * Se is a ShapeExternal and implementation-specific mechansims not defined in this specification\n            indicate success.\n            * Se is a shapeExprRef and there exists in the schema a shape expression se2 with that id and\n                      satisfies(n, se2, G, m).\n\n          .. note:: Where is the documentation on recursion?  All I can find is\n           `5.9.4 Recursion Example <http://shex.io/shex-semantics/#example-recursion>`_\n          \"\"\"\n    if isinstance(se, ShExJ.NodeConstraint):\n        rval = satisfiesNodeConstraint(cntxt, n, se)\n    elif isinstance(se, ShExJ.Shape):\n        rval = satisfiesShape(cntxt, n, se)\n    elif isinstance(se, ShExJ.ShapeOr):\n        rval = satisifesShapeOr(cntxt, n, se)\n    elif isinstance(se, ShExJ.ShapeAnd):\n        rval = satisfiesShapeAnd(cntxt, n, se)\n    elif isinstance(se, ShExJ.ShapeNot):\n        rval = satisfiesShapeNot(cntxt, n, se)\n    elif isinstance(se, ShExJ.ShapeExternal):\n        rval = satisfiesExternal(cntxt, n, se)\n    elif isinstance_(se, ShExJ.shapeExprLabel):\n        rval = satisfiesShapeExprRef(cntxt, n, se)\n    else:\n        raise NotImplementedError(f\"Unrecognized shapeExpr: {type(se)}\")\n    return rval"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef satisifesShapeOr(cntxt: Context, n: Node, se: ShExJ.ShapeOr, _: DebugContext) -> bool:\n    return any(satisfies(cntxt, n, se2) for se2 in se.shapeExprs)", "response": "Checks if a node n satisfies the given shape expression se."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if n satisfies se.", "response": "def satisfiesShapeAnd(cntxt: Context, n: Node, se: ShExJ.ShapeAnd, _: DebugContext) -> bool:\n    \"\"\" Se is a ShapeAnd and for every shape expression se2 in shapeExprs, satisfies(n, se2, G, m) \"\"\"\n    return all(satisfies(cntxt, n, se2) for se2 in se.shapeExprs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if n satisfies se.", "response": "def satisfiesShapeNot(cntxt: Context, n: Node, se: ShExJ.ShapeNot, _: DebugContext) -> bool:\n    \"\"\" Se is a ShapeNot and for the shape expression se2 at shapeExpr, notSatisfies(n, se2, G, m) \"\"\"\n    return not satisfies(cntxt, n, se.shapeExpr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef satisfiesExternal(cntxt: Context, n: Node, se: ShExJ.ShapeExternal, c: DebugContext) -> bool:\n    if c.debug:\n        print(f\"id: {se.id}\")\n    extern_shape = cntxt.external_shape_for(se.id)\n    if extern_shape:\n        return satisfies(cntxt, n, extern_shape)\n    cntxt.fail_reason = f\"{se.id}: Shape is not in Schema\"\n    return False", "response": "Checks if a node satisfies the external shape."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef satisfiesShapeExprRef(cntxt: Context, n: Node, se: ShExJ.shapeExprLabel, c: DebugContext) -> bool:\n    if c.debug:\n        print(f\"id: {se}\")\n    for shape in cntxt.schema.shapes:\n        if shape.id == se:\n            return satisfies(cntxt, n, shape)\n    cntxt.fail_reason = f\"{se}: Shape is not in Schema\"\n    return False", "response": "Checks if n satisfies se"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cat_proximity():\n    chart = SimpleLineChart(int(settings.width * 1.5), settings.height)\n    chart.set_legend(['INTELLIGENCE', 'INSANITY OF STATEMENTS'])\n\n    # intelligence\n    data_index = chart.add_data([100. / y for y in range(1, 15)])\n\n    # insanity of statements\n    chart.add_data([100. - 100 / y for y in range(1, 15)])\n\n    # line colours\n    chart.set_colours(['208020', '202080'])\n\n    # \"Near\" and \"Far\" labels, they are placed automatically at either ends.\n    near_far_axis_index = chart.set_axis_labels(Axis.BOTTOM, ['FAR', 'NEAR'])\n\n    # \"Human Proximity to cat\" label. Aligned to the center.\n    index = chart.set_axis_labels(Axis.BOTTOM, ['HUMAN PROXIMITY TO CAT'])\n    chart.set_axis_style(index, '202020', font_size=10, alignment=0)\n    chart.set_axis_positions(index, [50])\n\n    chart.download('label-cat-proximity.png')", "response": "Generate a cat proximity graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a URIRef for a str or URIRef", "response": "def normalize_uri(u: URI) -> URIRef:\n    \"\"\" Return a URIRef for a str or URIRef \"\"\"\n    return u if isinstance(u, URIRef) else URIRef(str(u))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an optional list of URIRefs for p", "response": "def normalize_uriparm(p: URIPARM) -> List[URIRef]:\n    \"\"\" Return an optional list of URIRefs for p\"\"\"\n    return normalize_urilist(p) if isinstance(p, List) else \\\n        normalize_urilist([p]) if isinstance(p, (str, URIRef)) else p"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the startspec for p", "response": "def normalize_startparm(p: STARTPARM) -> List[Union[type(START), START_TYPE, URIRef]]:\n    \"\"\" Return the startspec for p \"\"\"\n    if not isinstance(p, list):\n        p = [p]\n    return [normalize_uri(e) if isinstance(e, str) and e is not START else e for e in p]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a command line parser for the sequence of RDF nodes.", "response": "def genargs(prog: Optional[str] = None) -> ArgumentParser:\n    \"\"\"\n    Create a command line parser\n    :return: parser\n    \"\"\"\n    parser = ArgumentParser(prog)\n    parser.add_argument(\"rdf\", help=\"Input RDF file or SPARQL endpoint if slurper or sparql options\")\n    parser.add_argument(\"shex\", help=\"ShEx specification\")\n    parser.add_argument(\"-f\", \"--format\", help=\"Input RDF Format\", default=\"turtle\")\n    parser.add_argument(\"-s\", \"--start\", help=\"Start shape. If absent use ShEx start node.\")\n    parser.add_argument(\"-ut\", \"--usetype\", help=\"Start shape is rdf:type of focus\", action=\"store_true\")\n    parser.add_argument(\"-sp\", \"--startpredicate\", help=\"Start shape is object of this predicate\")\n    parser.add_argument(\"-fn\", \"--focus\", help=\"RDF focus node\")\n    parser.add_argument(\"-A\", \"--allsubjects\", help=\"Evaluate all non-bnode subjects in the graph\", action=\"store_true\")\n    parser.add_argument(\"-d\", \"--debug\", action=\"store_true\", help=\"Add debug output\")\n    parser.add_argument(\"-ss\", \"--slurper\", action=\"store_true\", help=\"Use SPARQL slurper graph\")\n    parser.add_argument(\"-cf\", \"--flattener\", action=\"store_true\", help=\"Use RDF Collections flattener graph\")\n    parser.add_argument(\"-sq\", \"--sparql\", help=\"SPARQL query to generate focus nodes\")\n    parser.add_argument(\"-se\", \"--stoponerror\", help=\"Stop on an error\", action=\"store_true\")\n    parser.add_argument(\"--stopafter\", help=\"Stop after N nodes\", type=int)\n    parser.add_argument(\"-ps\", \"--printsparql\", help=\"Print SPARQL queries as they are executed\", action=\"store_true\")\n    parser.add_argument(\"-pr\", \"--printsparqlresults\", help=\"Print SPARQL query and results\", action=\"store_true\")\n    parser.add_argument(\"-gn\", \"--graphname\", help=\"Specific SPARQL graph to query - use '' for any named graph\")\n    parser.add_argument(\"-pb\", \"--persistbnodes\", help=\"Treat BNodes as persistent in SPARQL endpoint\",\n                        action=\"store_true\")\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the RDF DataSet to be evaulated.", "response": "def rdf(self, rdf: Optional[Union[str, Graph]]) -> None:\n        \"\"\" Set the RDF DataSet to be evaulated.  If ``rdf`` is a string, the presence of a return is the\n        indicator that it is text instead of a location.\n\n        :param rdf: File name, URL, representation of rdflib Graph\n        \"\"\"\n        if isinstance(rdf, Graph):\n            self.g = rdf\n        else:\n            self.g = Graph()\n            if isinstance(rdf, str):\n                if '\\n' in rdf or '\\r' in rdf:\n                    self.g.parse(data=rdf, format=self.rdf_format)\n                elif ':' in rdf:\n                    self.g.parse(location=rdf, format=self.rdf_format)\n                else:\n                    self.g.parse(source=rdf, format=self.rdf_format)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the schema to be used.", "response": "def schema(self, shex: Optional[Union[str, ShExJ.Schema]]) -> None:\n        \"\"\" Set the schema to be used.  Schema can either be a ShExC or ShExJ string or a pre-parsed schema.\n\n        :param shex:  Schema\n        \"\"\"\n        self.pfx = None\n        if shex is not None:\n            if isinstance(shex, ShExJ.Schema):\n                self._schema = shex\n            else:\n                shext = shex.strip()\n                loader = SchemaLoader()\n                if ('\\n' in shex or '\\r' in shex) or shext[0] in '#<_: ':\n                    self._schema = loader.loads(shex)\n                else:\n                    self._schema = loader.load(shex) if isinstance(shex, str) else shex\n                if self._schema is None:\n                    raise ValueError(\"Unable to parse shex file\")\n                self.pfx = PrefixLibrary(loader.schema_text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the focus node in the BNodeSet.", "response": "def focus(self, focus: Optional[URIPARM]) -> None:\n        \"\"\" Set the focus node(s).  If no focus node is specified, the evaluation will occur for all non-BNode\n        graph subjects.  Otherwise it can be a string, a URIRef or a list of string/URIRef combinations\n\n        :param focus: None if focus should be all URIRefs in the graph otherwise a URI or list of URI's\n        \"\"\"\n        self._focus = normalize_uriparm(focus) if focus else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef arcsOut(G: Graph, n: Node) -> RDFGraph:\n    return RDFGraph(G.triples((n, None, None)))", "response": "Returns the set of arcs that are out of the graph G with subject n."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the set of predicates that are out of the given node.", "response": "def predicatesOut(G: Graph, n: Node) -> Set[TriplePredicate]:\n    \"\"\" predicatesOut(G, n) is the set of predicates in arcsOut(G, n). \"\"\"\n    return {p for p, _ in G.predicate_objects(n)}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef arcsIn(G: Graph, n: Node) -> RDFGraph:\n    return RDFGraph(G.triples((None, None, n)))", "response": "Returns the set of arcs in a graph G with object n."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef predicatesIn(G: Graph, n: Node) -> Set[TriplePredicate]:\n    return {p for _, p in G.subject_predicates(n)}", "response": "Returns the set of predicates that are in the given node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef neigh(G: Graph, n: Node) -> RDFGraph:\n    return arcsOut(G, n) | arcsIn(G, n)", "response": "Returns the neighbourhood of the node n in the graph G."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the set of predicates that are set by node n.", "response": "def predicates(G: Graph, n: Node) -> Set[TriplePredicate]:\n    \"\"\" redicates(G, n) is the set of predicates in neigh(G, n).\n\n        predicates(G, n) = predicatesOut(G, n) \u222a predicatesIn(G, n)\n    \"\"\"\n    return predicatesOut(G, n) | predicatesIn(G, n)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert path which can be a URL or a file path into a base URI", "response": "def generate_base(path: str) -> str:\n    \"\"\" Convert path, which can be a URL or a file path into a base URI\n\n    :param path: file location or url\n    :return: file location or url sans actual name\n    \"\"\"\n    if ':' in path:\n        parts = urlparse(path)\n        parts_dict = parts._asdict()\n        parts_dict['path'] = os.path.split(parts.path)[0] if '/' in parts.path else ''\n        return urlunparse(ParseResult(**parts_dict)) + '/'\n    else:\n        return (os.path.split(path)[0] if '/' in path else '') + '/'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split_host_port(cls, server):\n        host, port = splitport(server)\n        if port is None:\n            port = 11211\n        port = int(port)\n        if re.search(':.*$', host):\n            host = re.sub(':.*$', '', host)\n        return host, port", "response": "Split the server host and port into host and port."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_socket(self, size):\n        value = b''\n        while len(value) < size:\n            data = self.connection.recv(size - len(value))\n            if not data:\n                break\n            value += data\n\n        # If we got less data than we requested, the server disconnected.\n        if len(value) < size:\n            raise socket.error()\n\n        return value", "response": "Reads data from socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets memcached response from socket.", "response": "def _get_response(self):\n        \"\"\"\n        Get memcached response from socket.\n\n        :return: A tuple with binary values from memcached.\n        :rtype: tuple\n        \"\"\"\n        try:\n            self._open_connection()\n            if self.connection is None:\n                # The connection wasn't opened, which means we're deferring a reconnection attempt.\n                # Raise a socket.error, so we'll return the same server_disconnected message as we\n                # do below.\n                raise socket.error('Delaying reconnection attempt')\n\n            header = self._read_socket(self.HEADER_SIZE)\n            (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n             cas) = struct.unpack(self.HEADER_STRUCT, header)\n\n            assert magic == self.MAGIC['response']\n\n            extra_content = None\n            if bodylen:\n                extra_content = self._read_socket(bodylen)\n\n            return (magic, opcode, keylen, extlen, datatype, status, bodylen,\n                    opaque, cas, extra_content)\n        except socket.error as e:\n            self._connection_error(e)\n\n            # (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque, cas, extra_content)\n            message = str(e)\n            return (self.MAGIC['response'], -1, 0, 0, 0, self.STATUS['server_disconnected'], 0, 0, 0, message)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authenticate(self, username, password):\n        self._username = username\n        self._password = password\n\n        # Reopen the connection with the new credentials.\n        self.disconnect()\n        self._open_connection()\n        return self.authenticated", "response": "Authenticate user on server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize(self, value, compress_level=-1):\n        flags = 0\n        if isinstance(value, binary_type):\n            flags |= self.FLAGS['binary']\n        elif isinstance(value, text_type):\n            value = value.encode('utf8')\n        elif isinstance(value, int) and isinstance(value, bool) is False:\n            flags |= self.FLAGS['integer']\n            value = str(value)\n        elif isinstance(value, long) and isinstance(value, bool) is False:\n            flags |= self.FLAGS['long']\n            value = str(value)\n        else:\n            flags |= self.FLAGS['object']\n            buf = BytesIO()\n            pickler = self.pickler(buf, self.pickle_protocol)\n            pickler.dump(value)\n            value = buf.getvalue()\n\n        if compress_level != 0 and len(value) > self.COMPRESSION_THRESHOLD:\n            if compress_level is not None and compress_level > 0:\n                # Use the specified compression level.\n                compressed_value = self.compression.compress(value, compress_level)\n            else:\n                # Use the default compression level.\n                compressed_value = self.compression.compress(value)\n            # Use the compressed value only if it is actually smaller.\n            if compressed_value and len(compressed_value) < len(value):\n                value = compressed_value\n                flags |= self.FLAGS['compressed']\n\n        return flags, value", "response": "Serializes a value based on its type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key):\n        logger.debug('Getting key %s', key)\n        data = struct.pack(self.HEADER_STRUCT +\n                           self.COMMANDS['get']['struct'] % (len(key)),\n                           self.MAGIC['request'],\n                           self.COMMANDS['get']['command'],\n                           len(key), 0, 0, 0, len(key), 0, 0, str_to_bytes(key))\n        self._send(data)\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        logger.debug('Value Length: %d. Body length: %d. Data type: %d',\n                     extlen, bodylen, datatype)\n\n        if status != self.STATUS['success']:\n            if status == self.STATUS['key_not_found']:\n                logger.debug('Key not found. Message: %s', extra_content)\n                return None, None\n\n            if status == self.STATUS['server_disconnected']:\n                return None, None\n\n            raise MemcachedException('Code: %d Message: %s' % (status, extra_content), status)\n\n        flags, value = struct.unpack('!L%ds' % (bodylen - 4, ), extra_content)\n\n        return self.deserialize(value, flags), cas", "response": "Get a key and its CAS value from server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef noop(self):\n        logger.debug('Sending NOOP')\n        data = struct.pack(self.HEADER_STRUCT +\n                           self.COMMANDS['noop']['struct'],\n                           self.MAGIC['request'],\n                           self.COMMANDS['noop']['command'],\n                           0, 0, 0, 0, 0, 0, 0)\n        self._send(data)\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        logger.debug('Value Length: %d. Body length: %d. Data type: %d',\n                     extlen, bodylen, datatype)\n\n        if status != self.STATUS['success']:\n            logger.debug('NOOP failed (status is %d). Message: %s' % (status, extra_content))\n\n        return int(status)", "response": "Send a NOOP command to get a specific version of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_multi(self, keys):\n        # pipeline N-1 getkq requests, followed by a regular getk to uncork the\n        # server\n        o_keys = keys\n        keys, last = keys[:-1], str_to_bytes(keys[-1])\n        if six.PY2:\n            msg = ''\n        else:\n            msg = b''\n        msg = msg.join([\n            struct.pack(self.HEADER_STRUCT +\n                        self.COMMANDS['getkq']['struct'] % (len(key)),\n                        self.MAGIC['request'],\n                        self.COMMANDS['getkq']['command'],\n                        len(key), 0, 0, 0, len(key), 0, 0, str_to_bytes(key))\n            for key in keys])\n        msg += struct.pack(self.HEADER_STRUCT +\n                           self.COMMANDS['getk']['struct'] % (len(last)),\n                           self.MAGIC['request'],\n                           self.COMMANDS['getk']['command'],\n                           len(last), 0, 0, 0, len(last), 0, 0, last)\n\n        self._send(msg)\n\n        d = {}\n        opcode = -1\n        while opcode != self.COMMANDS['getk']['command']:\n            (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n             cas, extra_content) = self._get_response()\n\n            if status == self.STATUS['success']:\n                flags, key, value = struct.unpack('!L%ds%ds' %\n                                                  (keylen, bodylen - keylen - 4),\n                                                  extra_content)\n                if six.PY2:\n                    d[key] = self.deserialize(value, flags), cas\n                else:\n                    try:\n                        decoded_key = key.decode()\n                    except UnicodeDecodeError:\n                        d[key] = self.deserialize(value, flags), cas\n                    else:\n                        if decoded_key in o_keys:\n                            d[decoded_key] = self.deserialize(value, flags), cas\n                        else:\n                            d[key] = self.deserialize(value, flags), cas\n\n            elif status == self.STATUS['server_disconnected']:\n                break\n            elif status != self.STATUS['key_not_found']:\n                raise MemcachedException('Code: %d Message: %s' % (status, extra_content), status)\n\n        return d", "response": "This method is used to get multiple keys from server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to set/add/replace commands. :param key: Key's name :type key: six.string_types :param value: A value to be stored on server. :type value: object :param time: Time in seconds that your key will expire. :type time: int :param cas: The CAS value that must be matched for this operation to complete, or 0 for no CAS. :type cas: int :param compress_level: How much to compress. 0 = no compression, 1 = fastest, 9 = slowest but best, -1 = default compression level. :type compress_level: int :return: True in case of success and False in case of failure :rtype: bool", "response": "def _set_add_replace(self, command, key, value, time, cas=0, compress_level=-1):\n        \"\"\"\n        Function to set/add/replace commands.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: A value to be stored on server.\n        :type value: object\n        :param time: Time in seconds that your key will expire.\n        :type time: int\n        :param cas: The CAS value that must be matched for this operation to complete, or 0 for no CAS.\n        :type cas: int\n        :param compress_level: How much to compress.\n            0 = no compression, 1 = fastest, 9 = slowest but best,\n            -1 = default compression level.\n        :type compress_level: int\n        :return: True in case of success and False in case of failure\n        :rtype: bool\n        \"\"\"\n        time = time if time >= 0 else self.MAXIMUM_EXPIRE_TIME\n        logger.debug('Setting/adding/replacing key %s.', key)\n        flags, value = self.serialize(value, compress_level=compress_level)\n        logger.debug('Value bytes %s.', len(value))\n        if isinstance(value, text_type):\n            value = value.encode('utf8')\n\n        self._send(struct.pack(self.HEADER_STRUCT +\n                               self.COMMANDS[command]['struct'] % (len(key), len(value)),\n                               self.MAGIC['request'],\n                               self.COMMANDS[command]['command'],\n                               len(key), 8, 0, 0, len(key) + len(value) + 8, 0, cas, flags,\n                               time, str_to_bytes(key), value))\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        if status != self.STATUS['success']:\n            if status == self.STATUS['key_exists']:\n                return False\n            elif status == self.STATUS['key_not_found']:\n                return False\n            elif status == self.STATUS['server_disconnected']:\n                return False\n            raise MemcachedException('Code: %d Message: %s' % (status, extra_content), status)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, key, value, time, compress_level=-1):\n        return self._set_add_replace('set', key, value, time, compress_level=compress_level)", "response": "Set a value for a key on server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cas(self, key, value, cas, time, compress_level=-1):\n        # The protocol CAS value 0 means \"no cas\".  Calling cas() with that value is\n        # probably unintentional.  Don't allow it, since it would overwrite the value\n        # without performing CAS at all.\n        assert cas != 0, '0 is an invalid CAS value'\n\n        # If we get a cas of None, interpret that as \"compare against nonexistant and set\",\n        # which is simply Add.\n        if cas is None:\n            return self._set_add_replace('add', key, value, time, compress_level=compress_level)\n        else:\n            return self._set_add_replace('set', key, value, time, cas=cas, compress_level=compress_level)", "response": "Adds a key to the server ony if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a key value pair to the server ony if it does not exist.", "response": "def add(self, key, value, time, compress_level=-1):\n        \"\"\"\n        Add a key/value to server ony if it does not exist.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: A value to be stored on server.\n        :type value: object\n        :param time: Time in seconds that your key will expire.\n        :type time: int\n        :param compress_level: How much to compress.\n            0 = no compression, 1 = fastest, 9 = slowest but best,\n            -1 = default compression level.\n        :type compress_level: int\n        :return: True if key is added False if key already exists\n        :rtype: bool\n        \"\"\"\n        return self._set_add_replace('add', key, value, time, compress_level=compress_level)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace(self, key, value, time, compress_level=-1):\n        return self._set_add_replace('replace', key, value, time, compress_level=compress_level)", "response": "Replace a key value in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting multiple keys with its values on server.", "response": "def set_multi(self, mappings, time=100, compress_level=-1):\n        \"\"\"\n        Set multiple keys with its values on server.\n\n        If a key is a (key, cas) tuple, insert as if cas(key, value, cas) had\n        been called.\n\n        :param mappings: A dict with keys/values\n        :type mappings: dict\n        :param time: Time in seconds that your key will expire.\n        :type time: int\n        :param compress_level: How much to compress.\n            0 = no compression, 1 = fastest, 9 = slowest but best,\n            -1 = default compression level.\n        :type compress_level: int\n        :return: True\n        :rtype: bool\n        \"\"\"\n        mappings = mappings.items()\n        msg = []\n\n        for key, value in mappings:\n            if isinstance(key, tuple):\n                key, cas = key\n            else:\n                cas = None\n\n            if cas == 0:\n                # Like cas(), if the cas value is 0, treat it as compare-and-set against not\n                # existing.\n                command = 'addq'\n            else:\n                command = 'setq'\n\n            flags, value = self.serialize(value, compress_level=compress_level)\n            m = struct.pack(self.HEADER_STRUCT +\n                            self.COMMANDS[command]['struct'] % (len(key), len(value)),\n                            self.MAGIC['request'],\n                            self.COMMANDS[command]['command'],\n                            len(key),\n                            8, 0, 0, len(key) + len(value) + 8, 0, cas or 0,\n                            flags, time, str_to_bytes(key), value)\n            msg.append(m)\n\n        m = struct.pack(self.HEADER_STRUCT +\n                        self.COMMANDS['noop']['struct'],\n                        self.MAGIC['request'],\n                        self.COMMANDS['noop']['command'],\n                        0, 0, 0, 0, 0, 0, 0)\n        msg.append(m)\n\n        if six.PY2:\n            msg = ''.join(msg)\n        else:\n            msg = b''.join(msg)\n\n        self._send(msg)\n\n        opcode = -1\n        retval = True\n        while opcode != self.COMMANDS['noop']['command']:\n            (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n             cas, extra_content) = self._get_response()\n            if status != self.STATUS['success']:\n                retval = False\n            if status == self.STATUS['server_disconnected']:\n                break\n\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction which increments and decrements. :param key: Key's name :type key: six.string_types :param value: Number to be (de|in)cremented :type value: int :param default: Default value if key does not exist. :type default: int :param time: Time in seconds to expire key. :type time: int :return: Actual value of the key on server :rtype: int", "response": "def _incr_decr(self, command, key, value, default, time):\n        \"\"\"\n        Function which increments and decrements.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: Number to be (de|in)cremented\n        :type value: int\n        :param default: Default value if key does not exist.\n        :type default: int\n        :param time: Time in seconds to expire key.\n        :type time: int\n        :return: Actual value of the key on server\n        :rtype: int\n        \"\"\"\n        time = time if time >= 0 else self.MAXIMUM_EXPIRE_TIME\n        self._send(struct.pack(self.HEADER_STRUCT +\n                               self.COMMANDS[command]['struct'] % len(key),\n                               self.MAGIC['request'],\n                               self.COMMANDS[command]['command'],\n                               len(key),\n                               20, 0, 0, len(key) + 20, 0, 0, value,\n                               default, time, str_to_bytes(key)))\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        if status not in (self.STATUS['success'], self.STATUS['server_disconnected']):\n            raise MemcachedException('Code: %d Message: %s' % (status, extra_content), status)\n        if status == self.STATUS['server_disconnected']:\n            return 0\n\n        return struct.unpack('!Q', extra_content)[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nincrements a key s name and return its actual value.", "response": "def incr(self, key, value, default=0, time=1000000):\n        \"\"\"\n        Increment a key, if it exists, returns its actual value, if it doesn't, return 0.\n\n        :param key: Key's name\n        :type key: six.string_types\n        :param value: Number to be incremented\n        :type value: int\n        :param default: Default value if key does not exist.\n        :type default: int\n        :param time: Time in seconds to expire key.\n        :type time: int\n        :return: Actual value of the key on server\n        :rtype: int\n        \"\"\"\n        return self._incr_decr('incr', key, value, default, time)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a key from the server.", "response": "def delete(self, key, cas=0):\n        \"\"\"\n        Delete a key/value from server. If key existed and was deleted, return True.\n\n        :param key: Key's name to be deleted\n        :type key: six.string_types\n        :param cas: If set, only delete the key if its CAS value matches.\n        :type cas: int\n        :return: True in case o success and False in case of failure.\n        :rtype: bool\n        \"\"\"\n        logger.debug('Deleting key %s', key)\n        self._send(struct.pack(self.HEADER_STRUCT +\n                               self.COMMANDS['delete']['struct'] % len(key),\n                               self.MAGIC['request'],\n                               self.COMMANDS['delete']['command'],\n                               len(key), 0, 0, 0, len(key), 0, cas, str_to_bytes(key)))\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        if status == self.STATUS['server_disconnected']:\n            return False\n        if status != self.STATUS['success'] and status not in (self.STATUS['key_not_found'], self.STATUS['key_exists']):\n            raise MemcachedException('Code: %d message: %s' % (status, extra_content), status)\n\n        logger.debug('Key deleted %s', key)\n        return status != self.STATUS['key_exists']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_multi(self, keys):\n        logger.debug('Deleting keys %r', keys)\n        if six.PY2:\n            msg = ''\n        else:\n            msg = b''\n        for key in keys:\n            msg += struct.pack(\n                self.HEADER_STRUCT +\n                self.COMMANDS['delete']['struct'] % len(key),\n                self.MAGIC['request'],\n                self.COMMANDS['delete']['command'],\n                len(key), 0, 0, 0, len(key), 0, 0, str_to_bytes(key))\n\n        msg += struct.pack(\n            self.HEADER_STRUCT +\n            self.COMMANDS['noop']['struct'],\n            self.MAGIC['request'],\n            self.COMMANDS['noop']['command'],\n            0, 0, 0, 0, 0, 0, 0)\n\n        self._send(msg)\n\n        opcode = -1\n        retval = True\n        while opcode != self.COMMANDS['noop']['command']:\n            (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n             cas, extra_content) = self._get_response()\n            if status != self.STATUS['success']:\n                retval = False\n            if status == self.STATUS['server_disconnected']:\n                break\n\n        return retval", "response": "Delete multiple keys from server in one command."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a command to server flush | delete all keys.", "response": "def flush_all(self, time):\n        \"\"\"\n        Send a command to server flush|delete all keys.\n\n        :param time: Time to wait until flush in seconds.\n        :type time: int\n        :return: True in case of success, False in case of failure\n        :rtype: bool\n        \"\"\"\n        logger.info('Flushing memcached')\n        self._send(struct.pack(self.HEADER_STRUCT +\n                               self.COMMANDS['flush']['struct'],\n                               self.MAGIC['request'],\n                               self.COMMANDS['flush']['command'],\n                               0, 4, 0, 0, 4, 0, 0, time))\n\n        (magic, opcode, keylen, extlen, datatype, status, bodylen, opaque,\n         cas, extra_content) = self._get_response()\n\n        if status not in (self.STATUS['success'], self.STATUS['server_disconnected']):\n            raise MemcachedException('Code: %d message: %s' % (status, extra_content), status)\n\n        logger.debug('Memcached flushed')\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn server stats. :param key: Optional if you want status from a key. :type key: six.string_types :return: A dict with server stats :rtype: dict", "response": "def stats(self, key=None):\n        \"\"\"\n        Return server stats.\n\n        :param key: Optional if you want status from a key.\n        :type key: six.string_types\n        :return: A dict with server stats\n        :rtype: dict\n        \"\"\"\n        # TODO: Stats with key is not working.\n        if key is not None:\n            if isinstance(key, text_type):\n                key = str_to_bytes(key)\n            keylen = len(key)\n            packed = struct.pack(\n                self.HEADER_STRUCT + '%ds' % keylen,\n                self.MAGIC['request'],\n                self.COMMANDS['stat']['command'],\n                keylen, 0, 0, 0, keylen, 0, 0, key)\n        else:\n            packed = struct.pack(\n                self.HEADER_STRUCT,\n                self.MAGIC['request'],\n                self.COMMANDS['stat']['command'],\n                0, 0, 0, 0, 0, 0, 0)\n\n        self._send(packed)\n\n        value = {}\n\n        while True:\n            response = self._get_response()\n\n            status = response[5]\n            if status == self.STATUS['server_disconnected']:\n                break\n\n            keylen = response[2]\n            bodylen = response[6]\n\n            if keylen == 0 and bodylen == 0:\n                break\n\n            extra_content = response[-1]\n            key = extra_content[:keylen]\n            body = extra_content[keylen:bodylen]\n            value[key.decode() if isinstance(key, bytes) else key] = body\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_shex(self, schema: str) -> \"PrefixLibrary\":\n        if '\\n' in schema or '\\r' in schema or ' ' in schema:\n            shex = schema\n        else:\n            shex = load_shex_file(schema)\n\n        for line in shex.split('\\n'):\n            line = line.strip()\n            m = re.match(r'PREFIX\\s+(\\S+):\\s+<(\\S+)>', line)\n            if not m:\n                m = re.match(r\"@prefix\\s+(\\S+):\\s+<(\\S+)>\\s+\\.\", line)\n            if m:\n                setattr(self, m.group(1).upper(), Namespace(m.group(2)))\n        return self", "response": "Add a ShExC schema to the prefix library object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd bindings in the library to the graph", "response": "def add_bindings(self, g: Graph) -> \"PrefixLibrary\":\n        \"\"\" Add bindings in the library to the graph\n\n        :param g: graph to add prefixes to\n        :return: PrefixLibrary object\n        \"\"\"\n        for prefix, namespace in self:\n            g.bind(prefix.lower(), namespace)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the bindings to the target object.", "response": "def add_to_object(self, target: object, override: bool = False) -> int:\n        \"\"\"\n         Add the bindings to the target object\n        :param target: target to add to\n        :param override: override existing bindings if they are of type Namespace\n        :return: number of items actually added\n        \"\"\"\n        nret = 0\n        for k, v in self:\n            key = k.upper()\n            exists = hasattr(target, key)\n            if not exists or (override and isinstance(getattr(target, k), (Namespace, _RDFNamespace))):\n                setattr(target, k, v)\n                nret += 1\n            else:\n                print(f\"Warning: {key} is already defined in namespace {target}. Not overridden\")\n        return nret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the nsname format of URI or straight URI if no mapping is available", "response": "def nsname(self, uri: Union[str, URIRef]) -> str:\n        \"\"\"\n        Return the 'ns:name' format of URI\n\n        :param uri: URI to transform\n        :return: nsname format of URI or straight URI if no mapping\n        \"\"\"\n        uri = str(uri)\n        nsuri = \"\"\n        prefix = None\n        for pfx, ns in self:\n            nss = str(ns)\n            if uri.startswith(nss) and len(nss) > len(nsuri):\n                nsuri = nss\n                prefix = pfx\n        return (prefix.lower() + ':' + uri[len(nsuri):]) if prefix is not None else uri"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a. pth file with the data in the order they appear.", "response": "def open_spec(f):\n    \"\"\"\n    :param f: file object with spec data\n\n    spec file is a yaml document that specifies which modules\n    can be loaded.\n\n    modules - list of base modules that can be loaded\n    pths    - list of .pth files to load\n    \"\"\"\n    import ruamel.yaml as yaml\n\n    keys = ['modules', 'pths', 'test_import', 'install_hints', 'extra_paths']\n    data = yaml.safe_load(f)\n    parsed = dict()\n    ## pattern = re.compile(\"^\\s+|\\s*,\\s*|\\s+$\")\n    for k in keys:\n        v = data.get(k, [])\n        # Items are always lists\n        if isinstance(v, basestring):\n            parsed[k] = [m for m in re.split(r\",| \", v)]\n            # parsed[k] = re.split(pattern, v)\n        else:\n            parsed[k] = v\n\n    return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a ShEx Schema from schema_location or file - like object.", "response": "def load(self, schema_file: Union[str, TextIO], schema_location: Optional[str]=None) -> ShExJ.Schema:\n        \"\"\" Load a ShEx Schema from schema_location\n\n        :param schema_file:  name or file-like object to deserialize\n        :param schema_location: URL or file name of schema.  Used to create the base_location\n        :return: ShEx Schema represented by schema_location\n        \"\"\"\n        if isinstance(schema_file, str):\n            schema_file = self.location_rewrite(schema_file)\n            self.schema_text = load_shex_file(schema_file)\n        else:\n            self.schema_text = schema_file.read()\n\n        if self.base_location:\n            self.root_location = self.base_location\n        elif schema_location:\n            self.root_location = os.path.dirname(schema_location) + '/'\n        else:\n            self.root_location = None\n        return self.loads(self.schema_text)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loads(self, schema_txt: str) -> ShExJ.Schema:\n        self.schema_text = schema_txt\n        if schema_txt.strip()[0] == '{':\n            # TODO: figure out how to propagate self.base_location into this parse\n            return cast(ShExJ.Schema, loads(schema_txt, ShExJ))\n        else:\n            return generate_shexj.parse(schema_txt, self.base_location)", "response": "Parse and return schema as a ShExJ Schema"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef placeOrder(self, id, contract, order):\n        return _swigibpy.EClient_placeOrder(self, id, contract, order)", "response": "placeOrder - Place an order for an EClient"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reqMktDepth(self, id, contract, numRows, mktDepthOptions):\n        return _swigibpy.EClient_reqMktDepth(self, id, contract, numRows, mktDepthOptions)", "response": "reqMktDepth - Request a set of fields to be used for the given ticker id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exerciseOptions(self, id, contract, exerciseAction, exerciseQuantity, account, override):\n        return _swigibpy.EClient_exerciseOptions(self, id, contract, exerciseAction, exerciseQuantity, account, override)", "response": "exerciseOptions - Exercise options for a ticker."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting a scanner subscription.", "response": "def reqScannerSubscription(self, tickerId, subscription, scannerSubscriptionOptions):\n        \"\"\"reqScannerSubscription(EClient self, int tickerId, ScannerSubscription subscription, TagValueListSPtr const & scannerSubscriptionOptions)\"\"\"\n        return _swigibpy.EClient_reqScannerSubscription(self, tickerId, subscription, scannerSubscriptionOptions)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reqFundamentalData(self, reqId, arg3, reportType):\n        return _swigibpy.EClient_reqFundamentalData(self, reqId, arg3, reportType)", "response": "reqFundamentalData - Request fundamental data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculateImpliedVolatility(self, reqId, contract, optionPrice, underPrice):\n        return _swigibpy.EClient_calculateImpliedVolatility(self, reqId, contract, optionPrice, underPrice)", "response": "calculateImpliedVolatility - Calculates the volatility of the specified contract at the specified option price and under price"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculateOptionPrice(self, reqId, contract, volatility, underPrice):\n        return _swigibpy.EClient_calculateOptionPrice(self, reqId, contract, volatility, underPrice)", "response": "calculateOptionPrice - This is a private method that is called by the EClient class when the contract is used to calculate the option price."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reqAccountSummary(self, reqId, groupName, tags):\n        return _swigibpy.EClient_reqAccountSummary(self, reqId, groupName, tags)", "response": "reqAccountSummary - Request account summary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eConnect(self, host, port, clientId=0, extraAuth=False):\n        return _swigibpy.EClientSocketBase_eConnect(self, host, port, clientId, extraAuth)", "response": "Connect to a remote host and return True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef placeOrder(self, id, contract, order):\n        return _swigibpy.EClientSocketBase_placeOrder(self, id, contract, order)", "response": "placeOrder - Place an order for a given id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reqRealTimeBars(self, id, contract, barSize, whatToShow, useRTH, realTimeBarsOptions):\n        return _swigibpy.EClientSocketBase_reqRealTimeBars(self, id, contract, barSize, whatToShow, useRTH, realTimeBarsOptions)", "response": "This is a private method that is used to request real time bars."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reqScannerSubscription(self, tickerId, subscription, scannerSubscriptionOptions):\n        return _swigibpy.EClientSocketBase_reqScannerSubscription(self, tickerId, subscription, scannerSubscriptionOptions)", "response": "Request a scanner subscription."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reqFundamentalData(self, reqId, arg3, reportType):\n        return _swigibpy.EClientSocketBase_reqFundamentalData(self, reqId, arg3, reportType)", "response": "reqFundamentalData - Request a fundamental data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calculateOptionPrice(self, reqId, contract, volatility, underPrice):\n        return _swigibpy.EClientSocketBase_calculateOptionPrice(self, reqId, contract, volatility, underPrice)", "response": "calculateOptionPrice - This is a private method that is called by the client to calculate the option price."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tickSize(self, tickerId, field, size):\n        return _swigibpy.EWrapper_tickSize(self, tickerId, field, size)", "response": "tickSize - Returns the tick size for the specified field"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tickOptionComputation(self, tickerId, tickType, impliedVol, delta, optPrice, pvDividend, gamma, vega, theta, undPrice):\n        return _swigibpy.EWrapper_tickOptionComputation(self, tickerId, tickType, impliedVol, delta, optPrice, pvDividend, gamma, vega, theta, undPrice)", "response": "tickOptionComputation - This is a wrapper for the EWrapper_tickOptionComputation method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tickString(self, tickerId, tickType, value):\n        return _swigibpy.EWrapper_tickString(self, tickerId, tickType, value)", "response": "tickString - Returns the tick string value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef orderStatus(self, orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld):\n        return _swigibpy.EWrapper_orderStatus(self, orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld)", "response": "OrderStatus - Updates the status of an existing order."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef error(self, id, errorCode, errorString):\n        '''Error during communication with TWS'''\n        if errorCode == 165: # Historical data sevice message\n            sys.stderr.write(\"TWS INFO - %s: %s\\n\" % (errorCode, errorString))\n        elif errorCode >= 501 and errorCode < 600: # Socket read failed\n            sys.stderr.write(\"TWS CLIENT-ERROR - %s: %s\\n\" % (errorCode, errorString))\n        elif errorCode >= 100 and errorCode < 1100:\n            sys.stderr.write(\"TWS ERROR - %s: %s\\n\" % (errorCode, errorString))\n        elif errorCode >= 1100 and errorCode < 2100:\n            sys.stderr.write(\"TWS SYSTEM-ERROR - %s: %s\\n\" % (errorCode, errorString))\n        elif errorCode in (2104, 2106, 2108):\n            sys.stderr.write(\"TWS INFO - %s: %s\\n\" % (errorCode, errorString))\n        elif errorCode >= 2100 and errorCode <= 2110:\n            sys.stderr.write(\"TWS WARNING - %s: %s\\n\" % (errorCode, errorString))\n        else:\n            sys.stderr.write(\"TWS ERROR - %s: %s\\n\" % (errorCode, errorString))", "response": "Error during communication with TWS"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the market depth of a given id", "response": "def updateMktDepth(self, id, position, operation, side, price, size):\n        \"\"\"updateMktDepth(EWrapper self, TickerId id, int position, int operation, int side, double price, int size)\"\"\"\n        return _swigibpy.EWrapper_updateMktDepth(self, id, position, operation, side, price, size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef updateMktDepthL2(self, id, position, marketMaker, operation, side, price, size):\n        return _swigibpy.EWrapper_updateMktDepthL2(self, id, position, marketMaker, operation, side, price, size)", "response": "update market level data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef updateNewsBulletin(self, msgId, msgType, newsMessage, originExch):\n        return _swigibpy.EWrapper_updateNewsBulletin(self, msgId, msgType, newsMessage, originExch)", "response": "updateNewsBulletin - Updates a news bulletin message"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nposition - Get the position of the EWrapper in the specified contract", "response": "def position(self, account, contract, position, avgCost):\n        \"\"\"position(EWrapper self, IBString const & account, Contract contract, int position, double avgCost)\"\"\"\n        return _swigibpy.EWrapper_position(self, account, contract, position, avgCost)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef accountSummary(self, reqId, account, tag, value, curency):\n        return _swigibpy.EWrapper_accountSummary(self, reqId, account, tag, value, curency)", "response": "accountSummary - Returns the summary of the account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pyError(self, type, value, traceback):\n        '''Handles an error thrown during invocation of an EWrapper method.\n\n        Arguments are those provided by sys.exc_info()\n        '''\n        sys.stderr.write(\"Exception thrown during EWrapper method dispatch:\\n\")\n        print_exception(type, value, traceback)", "response": "Handles an error thrown during an EWrapper method dispatch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling after instantiating with a compressed payload", "response": "def init_counts(self, counts_len):\n        '''Called after instantiating with a compressed payload\n        Params:\n            counts_len counts size to use based on decoded settings in the header\n        '''\n        assert self._data and counts_len and self.counts_len == 0\n        self.counts_len = counts_len\n        self._init_counts()\n\n        results = decode(self._data, payload_header_size, addressof(self.counts),\n                         counts_len, self.word_size)\n        # no longer needed\n        self._data = None\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecompress a compressed payload into this payload wrapper.", "response": "def _decompress(self, compressed_payload):\n        '''Decompress a compressed payload into this payload wrapper.\n        Note that the decompressed buffer is saved in self._data and the\n        counts array is not yet allocated.\n\n        Args:\n            compressed_payload (string) a payload in zlib compressed form\n        Exception:\n            HdrCookieException:\n                the compressed payload has an invalid cookie\n            HdrLengthException:\n                the decompressed size is too small for the HdrPayload structure\n                or is not aligned or is too large for the passed payload class\n            HdrHistogramSettingsException:\n                mismatch in the significant figures, lowest and highest\n                         trackable value\n        '''\n        # make sure this instance is pristine\n        if self._data:\n            raise RuntimeError('Cannot decompress to an instance with payload')\n        # Here it is important to keep a reference to the decompressed\n        # string so that it does not get garbage collected\n        self._data = zlib.decompress(compressed_payload)\n        len_data = len(self._data)\n\n        counts_size = len_data - payload_header_size\n        if payload_header_size > counts_size > MAX_COUNTS_SIZE:\n            raise HdrLengthException('Invalid size:' + str(len_data))\n\n        # copy the first bytes for the header\n        self.payload = PayloadHeader.from_buffer_copy(self._data)\n\n        cookie = self.payload.cookie\n        if get_cookie_base(cookie) != V2_ENCODING_COOKIE_BASE:\n            raise HdrCookieException('Invalid cookie: %x' % cookie)\n        word_size = get_word_size_in_bytes_from_cookie(cookie)\n        if word_size != V2_MAX_WORD_SIZE_IN_BYTES:\n            raise HdrCookieException('Invalid V2 cookie: %x' % cookie)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompressing this payload instance into a compressed version of the varint stream.", "response": "def compress(self, counts_limit):\n        '''Compress this payload instance\n        Args:\n            counts_limit how many counters should be encoded\n                           starting from index 0 (can be 0),\n        Return:\n            the compressed payload (python string)\n        '''\n        if self.payload:\n            # worst case varint encoded length is when each counter is at the maximum value\n            # in this case 1 more byte per counter is needed due to the more bits\n            varint_len = counts_limit * (self.word_size + 1)\n            # allocate enough space to fit the header and the varint string\n            encode_buf = (c_byte * (payload_header_size + varint_len))()\n\n            # encode past the payload header\n            varint_len = encode(addressof(self.counts), counts_limit,\n                                self.word_size,\n                                addressof(encode_buf) + payload_header_size,\n                                varint_len)\n\n            # copy the header after updating the varint stream length\n            self.payload.payload_len = varint_len\n            ctypes.memmove(addressof(encode_buf), addressof(self.payload), payload_header_size)\n\n            cdata = zlib.compress(ctypes.string_at(encode_buf, payload_header_size + varint_len))\n            return cdata\n        # can't compress if no payload\n        raise RuntimeError('No payload to compress')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompress the associated encodable payload and prepend the header then encode with base64 if b64_wrap is enabled.", "response": "def encode(self):\n        '''Compress the associated encodable payload,\n        prepend the header then encode with base64 if requested\n\n        Returns:\n            the b64 encoded wire encoding of the histogram (as a string)\n            or the compressed payload (as a string, if b64 wrappinb is disabled)\n        '''\n        # only compress the first non zero buckets\n        # if histogram is empty we do not encode any counter\n        if self.histogram.total_count:\n            relevant_length = \\\n                self.histogram.get_counts_array_index(self.histogram.max_value) + 1\n        else:\n            relevant_length = 0\n        cpayload = self.payload.compress(relevant_length)\n        if self.b64_wrap:\n            self.header.length = len(cpayload)\n            header_str = ctypes.string_at(addressof(self.header), ext_header_size)\n            return base64.b64encode(header_str + cpayload)\n        return cpayload"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode(encoded_histogram, b64_wrap=True):\n        '''Decode a wire histogram encoding into a read-only Hdr Payload instance\n        Args:\n            encoded_histogram a string containing the wire encoding of a histogram\n                              such as one returned from encode()\n        Returns:\n            an hdr_payload instance with all the decoded/uncompressed fields\n\n        Exception:\n            TypeError in case of base64 decode error\n            HdrCookieException:\n                the main header has an invalid cookie\n                the compressed payload header has an invalid cookie\n            HdrLengthException:\n                the decompressed size is too small for the HdrPayload structure\n                or is not aligned or is too large for the passed payload class\n            HdrHistogramSettingsException:\n                mismatch in the significant figures, lowest and highest\n                         trackable value\n            zlib.error:\n                in case of zlib decompression error\n        '''\n        if b64_wrap:\n            b64decode = base64.b64decode(encoded_histogram)\n            # this string has 2 parts in it: the header (raw) and the payload (compressed)\n            b64dec_len = len(b64decode)\n\n            if b64dec_len < ext_header_size:\n                raise HdrLengthException('Base64 decoded message too short')\n\n            header = ExternalHeader.from_buffer_copy(b64decode)\n            if get_cookie_base(header.cookie) != V2_COMPRESSION_COOKIE_BASE:\n                raise HdrCookieException()\n            if header.length != b64dec_len - ext_header_size:\n                raise HdrLengthException('Decoded length=%d buffer length=%d' %\n                                         (header.length, b64dec_len - ext_header_size))\n            # this will result in a copy of the compressed payload part\n            # could not find a way to do otherwise since zlib.decompress()\n            # expects a string (and does not like a buffer or a memoryview object)\n            cpayload = b64decode[ext_header_size:]\n        else:\n            cpayload = encoded_histogram\n        hdr_payload = HdrPayload(8, compressed_payload=cpayload)\n        return hdr_payload", "response": "Decode a wire histogram encoding into a read - only HdrPayload instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrecords a new value into the histogram", "response": "def record_value(self, value, count=1):\n        '''Record a new value into the histogram\n\n        Args:\n            value: the value to record (must be in the valid range)\n            count: incremental count (defaults to 1)\n        '''\n        if value < 0:\n            return False\n        counts_index = self._counts_index_for(value)\n        if (counts_index < 0) or (self.counts_len <= counts_index):\n            return False\n        self.counts[counts_index] += count\n        self.total_count += count\n        self.min_value = min(self.min_value, value)\n        self.max_value = max(self.max_value, value)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef record_corrected_value(self, value, expected_interval, count=1):\n        '''Record a new value into the histogram and correct for\n        coordinated omission if needed\n\n        Args:\n            value: the value to record (must be in the valid range)\n            expected_interval: the expected interval between 2 value samples\n            count: incremental count (defaults to 1)\n        '''\n        while True:\n            if not self.record_value(value, count):\n                return False\n            if value <= expected_interval or expected_interval <= 0:\n                return True\n            value -= expected_interval", "response": "Record a new value into the histogram and correct for the given expected_interval."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_value_at_percentile(self, percentile):\n        '''Get the value for a given percentile\n\n        Args:\n            percentile: a float in [0.0..100.0]\n        Returns:\n            the value for the given percentile\n        '''\n        count_at_percentile = self.get_target_count_at_percentile(percentile)\n        total = 0\n        for index in range(self.counts_len):\n            total += self.get_count_at_index(index)\n            if total >= count_at_percentile:\n                value_at_index = self.get_value_from_index(index)\n                if percentile:\n                    return self.get_highest_equivalent_value(value_at_index)\n                return self.get_lowest_equivalent_value(value_at_index)\n        return 0", "response": "Get the value for a given percentile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_percentile_to_value_dict(self, percentile_list):\n        '''A faster alternative to query values for a list of percentiles.\n\n        Args:\n            percentile_list: a list of percentiles in any order, dups will be ignored\n            each element in the list must be a float value in [0.0 .. 100.0]\n        Returns:\n            a dict of percentile values indexed by the percentile\n        '''\n        result = {}\n        total = 0\n        percentile_list_index = 0\n        count_at_percentile = 0\n        # remove dups and sort\n        percentile_list = list(set(percentile_list))\n        percentile_list.sort()\n\n        for index in range(self.counts_len):\n            total += self.get_count_at_index(index)\n            while True:\n                # recalculate target based on next requested percentile\n                if not count_at_percentile:\n                    if percentile_list_index == len(percentile_list):\n                        return result\n                    percentile = percentile_list[percentile_list_index]\n                    percentile_list_index += 1\n                    if percentile > 100:\n                        return result\n                    count_at_percentile = self.get_target_count_at_percentile(percentile)\n\n                if total >= count_at_percentile:\n                    value_at_index = self.get_value_from_index(index)\n                    if percentile:\n                        result[percentile] = self.get_highest_equivalent_value(value_at_index)\n                    else:\n                        result[percentile] = self.get_lowest_equivalent_value(value_at_index)\n                    count_at_percentile = 0\n                else:\n                    break\n        return result", "response": "A faster alternative to query values for a list of percentiles. This method returns a dictionary of percentile values indexed by the percentile."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef values_are_equivalent(self, val1, val2):\n        '''Check whether 2 values are equivalent (meaning they\n        are in the same bucket/range)\n\n        Returns:\n            true if the 2 values are equivalent\n        '''\n        return self.get_lowest_equivalent_value(val1) == self.get_lowest_equivalent_value(val2)", "response": "Check whether 2 values are equivalent"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset(self):\n        '''Reset the histogram to a pristine state\n        '''\n        for index in range(self.counts_len):\n            self.counts[index] = 0\n        self.total_count = 0\n        self.min_value = sys.maxsize\n        self.max_value = 0\n        self.start_time_stamp_msec = sys.maxsize\n        self.end_time_stamp_msec = 0", "response": "Reset the histogram to a pristine state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef adjust_internal_tacking_values(self,\n                                       min_non_zero_index,\n                                       max_index,\n                                       total_added):\n        '''Called during decoding and add to adjust the new min/max value and\n        total count\n\n        Args:\n            min_non_zero_index min nonzero index of all added counts (-1 if none)\n            max_index max index of all added counts (-1 if none)\n        '''\n        if max_index >= 0:\n            max_value = self.get_highest_equivalent_value(self.get_value_from_index(max_index))\n            self.max_value = max(self.max_value, max_value)\n        if min_non_zero_index >= 0:\n            min_value = self.get_value_from_index(min_non_zero_index)\n            self.min_value = min(self.min_value, min_value)\n        self.total_count += total_added", "response": "Called during decoding and add to adjust the new min max value and total count."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall during decoding and add to adjust the new min max value and total count.", "response": "def set_internal_tacking_values(self,\n                                    min_non_zero_index,\n                                    max_index,\n                                    total_added):\n        '''Called during decoding and add to adjust the new min/max value and\n        total count\n\n        Args:\n            min_non_zero_index min nonzero index of all added counts (-1 if none)\n            max_index max index of all added counts (-1 if none)\n        '''\n        if max_index >= 0:\n            self.max_value = self.get_highest_equivalent_value(self.get_value_from_index(max_index))\n        if min_non_zero_index >= 0:\n            self.min_value = self.get_value_from_index(min_non_zero_index)\n        self.total_count = total_added"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_counts_array_index(self, value):\n        '''Return the index in the counts array for a given value\n        '''\n        if value < 0:\n            raise ValueError(\"Histogram recorded value cannot be negative.\")\n\n        bucket_index = self._get_bucket_index(value)\n        sub_bucket_index = self._get_sub_bucket_index(value, bucket_index)\n        # Calculate the index for the first entry in the bucket:\n        bucket_base_index = (bucket_index + 1) << self.sub_bucket_half_count_magnitude\n        # The following is the equivalent of ((bucket_index + 1) * sub_bucket_half_count)\n        # Calculate the offset in the bucket (can be negative for first bucket):\n        offset_in_bucket = sub_bucket_index - self.sub_bucket_half_count\n        # The following is the equivalent of\n        # ((sub_bucket_index  - sub_bucket_half_count) + bucket_base_index\n        return bucket_base_index + offset_in_bucket", "response": "Return the index in the counts array for a given value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecoding an encoded histogram and add it to this histogram", "response": "def decode_and_add(self, encoded_histogram):\n        '''Decode an encoded histogram and add it to this histogram\n        Args:\n            encoded_histogram (string) an encoded histogram\n                following the V1 format, such as one returned by the encode() method\n        Exception:\n            TypeError in case of base64 decode error\n            HdrCookieException:\n                the main header has an invalid cookie\n                the compressed payload header has an invalid cookie\n            HdrLengthException:\n                the decompressed size is too small for the HdrPayload structure\n                or is not aligned or is too large for the passed payload class\n            zlib.error:\n                in case of zlib decompression error\n        '''\n        other_hist = HdrHistogram.decode(encoded_histogram, self.b64_wrap)\n        self.add(other_hist)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecodes an encoded histogram and return a new histogram instance that represents the decoded content", "response": "def decode(encoded_histogram, b64_wrap=True):\n        '''Decode an encoded histogram and return a new histogram instance that\n        has been initialized with the decoded content\n        Return:\n            a new histogram instance representing the decoded content\n        Exception:\n            TypeError in case of base64 decode error\n            HdrCookieException:\n                the main header has an invalid cookie\n                the compressed payload header has an invalid cookie\n            HdrLengthException:\n                the decompressed size is too small for the HdrPayload structure\n                or is not aligned or is too large for the passed payload class\n            zlib.error:\n                in case of zlib decompression error\n        '''\n        hdr_payload = HdrHistogramEncoder.decode(encoded_histogram, b64_wrap)\n        payload = hdr_payload.payload\n        histogram = HdrHistogram(payload.lowest_trackable_value,\n                                 payload.highest_trackable_value,\n                                 payload.significant_figures,\n                                 hdr_payload=hdr_payload)\n        return histogram"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_json(self, checked_json, schema):\n        try:\n            jsonschema.validate(checked_json, schema)\n        except jsonschema.ValidationError as e:\n            print(\"\"\"Failed validating '{0}'\nin schema {1}:\n{2}\nOn instance {3}:\n{4}\"\"\".format(e.validator,\n              list(e.relative_schema_path)[:-1], pprint.pformat(e.schema),\n              \"[%s]\" % \"][\".join(repr(index) for index in e.absolute_path),\n              pprint.pformat(e.instance).encode('utf-8')))\n            raise JsonValidatorError(\"Failed validating json by schema\")\n        except jsonschema.SchemaError as e:\n            raise JsonValidatorError('Json-schema error')", "response": "Validate the JSON according to the JSON schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_jsonschema_from_file(self, json_string, path_to_schema):\n        schema = open(path_to_schema).read()\n        load_input_json = self.string_to_json(json_string)\n\n        try:\n            load_schema = json.loads(schema)\n        except ValueError as e:\n            raise JsonValidatorError('Error in schema: {}'.format(e))\n\n        self._validate_json(load_input_json, load_schema)", "response": "Validate JSON according to schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate JSON according to schema.", "response": "def validate_jsonschema(self, json_string, input_schema):\n        \"\"\"\n        Validate JSON according to schema.\n\n        *Args:*\\n\n        _json_string_ - JSON string;\\n\n        _input_schema_ - schema in string format;\n\n        *Raises:*\\n\n        JsonValidatorError\n\n        *Example:*\\n\n        | *Settings* | *Value* |\n        | Library    | JsonValidator |\n        | Library    | OperatingSystem |\n        | *Test Cases* | *Action* | *Argument* | *Argument* |\n        | Simple | ${schema}=   | OperatingSystem.Get File |   ${CURDIR}${/}schema_valid.json |\n        |  | Validate jsonschema  |  {\"foo\":bar}  |  ${schema} |\n        \"\"\"\n        load_input_json = self.string_to_json(json_string)\n\n        try:\n            load_schema = json.loads(input_schema)\n        except ValueError as e:\n            raise JsonValidatorError('Error in schema: {}'.format(e))\n\n        self._validate_json(load_input_json, load_schema)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef string_to_json(self, source):\n        try:\n            load_input_json = json.loads(source)\n        except ValueError as e:\n            raise JsonValidatorError(\"Could not parse '%s' as JSON: %s\" % (source, e))\n        return load_input_json", "response": "Deserialize string into JSON structure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize JSON structure into string.", "response": "def json_to_string(self, source):\n        \"\"\"\n        Serialize JSON structure into string.\n\n        *Args:*\\n\n        _source_ - JSON structure\n\n        *Returns:*\\n\n        JSON string\n\n        *Raises:*\\n\n        JsonValidatorError\n\n        *Example:*\\n\n        | *Settings* | *Value* |\n        | Library    | JsonValidator |\n        | Library    | OperatingSystem |\n        | *Test Cases* | *Action* | *Argument* | *Argument* |\n        | Json to string  | ${json_string}=   | OperatingSystem.Get File |   ${CURDIR}${/}json_example.json |\n        |                 | ${json}= | String to json |   ${json_string} |\n        |                 | ${string}=  |  Json to string  |  ${json} |\n        |                 | ${pretty_string}=  |  Pretty print json  |  ${string} |\n        |                 | Log to console  |  ${pretty_string} |\n        \"\"\"\n        try:\n            load_input_json = json.dumps(source)\n        except ValueError as e:\n            raise JsonValidatorError(\"Could serialize '%s' to JSON: %s\" % (source, e))\n        return load_input_json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget list of elements from _json_string_ matching expr.", "response": "def get_elements(self, json_string, expr):\n        \"\"\"\n        Get list of elements from _json_string_, matching [http://goessner.net/articles/JsonPath/|JSONPath] expression.\n\n        *Args:*\\n\n        _json_string_ - JSON string;\\n\n        _expr_ - JSONPath expression;\n\n        *Returns:*\\n\n        List of found elements or ``None`` if no elements were found\n\n        *Example:*\\n\n        | *Settings* | *Value* |\n        | Library    | JsonValidator |\n        | Library    | OperatingSystem |\n        | *Test Cases* | *Action* | *Argument* | *Argument* |\n        | Get json elements | ${json_example}=   | OperatingSystem.Get File |   ${CURDIR}${/}json_example.json |\n        |                   |  ${json_elements}= | Get elements  |  ${json_example}  |  $.store.book[*].author |\n        =>\\n\n        | [u'Nigel Rees', u'Evelyn Waugh', u'Herman Melville', u'J. R. R. Tolkien']\n        \"\"\"\n        load_input_json = self.string_to_json(json_string)\n        # parsing jsonpath\n        jsonpath_expr = parse(expr)\n        # list of returned elements\n        value_list = []\n        for match in jsonpath_expr.find(load_input_json):\n            value_list.append(match.value)\n        if not value_list:\n            return None\n        else:\n            return value_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_elements(self, json_string, expr):\n        load_input_json = self.string_to_json(json_string)\n        # parsing jsonselect\n        match = jsonselect.match(sel=expr, obj=load_input_json)\n        ret = list(match)\n        return ret if ret else None", "response": "Return list of elements from _json_string_ matching expr."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_objects(self, json_string, expr):\n        load_input_json = self.string_to_json(json_string)\n        # parsing objectpath\n        tree = objectpath.Tree(load_input_json)\n        values = tree.execute(expr)\n        return list(values)", "response": "Return list of objects from _json_string_ matching the expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the existence of one or more elements matching the given expression.", "response": "def element_should_exist(self, json_string, expr):\n        \"\"\"\n        Check the existence of one or more elements, matching [ http://jsonselect.org/ | JSONSelect] expression.\n\n        *DEPRECATED* JSON Select query language is outdated and not supported any more.\n        Use other keywords of this library to query JSON.\n\n        *Args:*\\n\n        _json_string_ - JSON string;\\n\n        _expr_ - JSONSelect expression;\\n\n\n        *Raises:*\\n\n        JsonValidatorError\n\n        *Example:*\\n\n        | *Settings* | *Value* |\n        | Library    | JsonValidator |\n        | Library    | OperatingSystem |\n        | *Test Cases* | *Action* | *Argument* | *Argument* |\n        | Check element | ${json_example}=   | OperatingSystem.Get File |   ${CURDIR}${/}json_example.json |\n        | | Element should exist  |  ${json_example}  |  .author:contains(\"Evelyn Waugh\") |\n        | | Element should exist  |  ${json_example}  |  .store .book  .price:expr(x=8.95) |\n        \"\"\"\n        value = self.select_elements(json_string, expr)\n        if value is None:\n            raise JsonValidatorError('Elements %s does not exist' % expr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that one or more elements matching the expression don t exist.", "response": "def element_should_not_exist(self, json_string, expr):\n        \"\"\"\n        Check that one or more elements, matching [ http://jsonselect.org/ | JSONSelect] expression, don't exist.\n\n        *DEPRECATED* JSON Select query language is outdated and not supported any more.\n        Use other keywords of this library to query JSON.\n\n        *Args:*\\n\n        _json_string_ - JSON string;\\n\n        _expr_ - JSONSelect expression;\\n\n\n        *Raises:*\\n\n        JsonValidatorError\n        \"\"\"\n        value = self.select_elements(json_string, expr)\n        if value is not None:\n            raise JsonValidatorError('Elements %s exist but should not' % expr)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _json_path_search(self, json_dict, expr):\n        path = parse(expr)\n        results = path.find(json_dict)\n\n        if len(results) is 0:\n            raise JsonValidatorError(\"Nothing found in the dictionary {0} using the given path {1}\".format(\n                str(json_dict), str(expr)))\n\n        return results", "response": "Searches the given json - dictionary for items within the given path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_json(self, json_string, expr, value, index=0):\n        load_input_json = self.string_to_json(json_string)\n        matches = self._json_path_search(load_input_json, expr)\n\n        datum_object = matches[int(index)]\n\n        if not isinstance(datum_object, DatumInContext):\n            raise JsonValidatorError(\"Nothing found by the given json-path\")\n\n        path = datum_object.path\n\n        # Edit the directory using the received data\n        # If the user specified a list\n        if isinstance(path, Index):\n            datum_object.context.value[datum_object.path.index] = value\n        # If the user specified a value of type (string, bool, integer or complex)\n        elif isinstance(path, Fields):\n            datum_object.context.value[datum_object.path.fields[0]] = value\n\n        return load_input_json", "response": "Update the value in the JSON string with the value in the dictionary format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pretty_print_json(self, json_string):\n        return json.dumps(self.string_to_json(json_string), indent=2, ensure_ascii=False)", "response": "Return formatted JSON string _json_string_."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef output_interval_histogram(self,\n                                  histogram,\n                                  start_time_stamp_sec=0,\n                                  end_time_stamp_sec=0,\n                                  max_value_unit_ratio=1000000.0):\n        '''Output an interval histogram, with the given timestamp and a\n        configurable maxValueUnitRatio.\n        (note that the specified timestamp will be used, and the timestamp in\n        the actual histogram will be ignored).\n        The max value reported with the interval line will be scaled by the\n        given max_value_unit_ratio.\n        The histogram start and end timestamps are assumed to be in msec units.\n        Logging will be in seconds, realtive by a base time\n        The default base time is 0.\n\n        By covention, histogram start/end time are generally stamped with\n        absolute times in msec since the epoch. For logging with absolute time\n        stamps, the base time would remain zero. For\n        logging with relative time stamps (time since a start point),\n        Params:\n            histogram The interval histogram to log.\n            start_time_stamp_sec The start timestamp to log with the\n                interval histogram, in seconds.\n                default: using the start/end timestamp indicated in the histogram\n            end_time_stamp_sec The end timestamp to log with the interval\n                histogram, in seconds.\n                default: using the start/end timestamp indicated in the histogram\n            max_value_unit_ratio The ratio by which to divide the histogram's max\n                value when reporting on it.\n                default: 1,000,000 (which is the msec : nsec ratio\n        '''\n        if not start_time_stamp_sec:\n            start_time_stamp_sec = \\\n                (histogram.get_start_time_stamp() - self.base_time) / 1000.0\n        if not end_time_stamp_sec:\n            end_time_stamp_sec = (histogram.get_end_time_stamp() - self.base_time) / 1000.0\n        cpayload = histogram.encode()\n        self.log.write(\"%f,%f,%f,%s\\n\" %\n                       (start_time_stamp_sec,\n                        end_time_stamp_sec - start_time_stamp_sec,\n                        histogram.get_max_value() // max_value_unit_ratio,\n                        cpayload.decode('utf-8')))", "response": "Output an interval histogram with the given start and end timestamps."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging a start time in the log.", "response": "def output_start_time(self, start_time_msec):\n        '''Log a start time in the log.\n        Params:\n            start_time_msec time (in milliseconds) since the absolute start time (the epoch)\n        '''\n        self.log.write(\"#[StartTime: %f (seconds since epoch), %s]\\n\" %\n                       (float(start_time_msec) / 1000.0,\n                        datetime.fromtimestamp(start_time_msec).iso_format(' ')))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _decode_next_interval_histogram(self,\n                                        dest_histogram,\n                                        range_start_time_sec=0.0,\n                                        range_end_time_sec=sys.maxsize,\n                                        absolute=False):\n        '''Read the next interval histogram from the log, if interval falls\n        within an absolute or relative time range.\n\n        Timestamps are assumed to appear in order in the log file, and as such\n        this method will return a null upon encountering a timestamp larger than\n        range_end_time_sec.\n\n        Relative time range:\n            the range is assumed to be in seconds relative to\n            the actual timestamp value found in each interval line in the log\n        Absolute time range:\n            Absolute timestamps are calculated by adding the timestamp found\n            with the recorded interval to the [latest, optional] start time\n            found in the log. The start time is indicated in the log with\n            a \"#[StartTime: \" followed by the start time in seconds.\n\n        Params:\n            dest_histogram if None, created a new histogram, else adds\n                           the new interval histogram to it\n            range_start_time_sec The absolute or relative start of the expected\n                                 time range, in seconds.\n            range_start_time_sec The absolute or relative end of the expected\n                                  time range, in seconds.\n            absolute Defines if the passed range is absolute or relative\n\n        Return:\n            Returns an histogram object if an interval line was found with an\n            associated start timestamp value that falls between start_time_sec and\n            end_time_sec,\n            or null if no such interval line is found.\n            Upon encountering any unexpected format errors in reading the next\n            interval from the file, this method will return None.\n\n            The histogram returned will have it's timestamp set to the absolute\n            timestamp calculated from adding the interval's indicated timestamp\n            value to the latest [optional] start time found in the log.\n\n        Exceptions:\n            ValueError if there is a syntax error in one of the float fields\n        '''\n        while 1:\n            line = self.input_file.readline()\n            if not line:\n                return None\n            if line[0] == '#':\n                match_res = re_start_time.match(line)\n                if match_res:\n                    self.start_time_sec = float(match_res.group(1))\n                    self.observed_start_time = True\n                    continue\n                match_res = re_base_time.match(line)\n                if match_res:\n                    self.base_time_sec = float(match_res.group(1))\n                    self.observed_base_time = True\n                    continue\n\n            match_res = re_histogram_interval.match(line)\n            if not match_res:\n                # probably a legend line that starts with \"\\\"StartTimestamp\"\n                continue\n            # Decode: startTimestamp, intervalLength, maxTime, histogramPayload\n            # Timestamp is expected to be in seconds\n            log_time_stamp_in_sec = float(match_res.group(1))\n            interval_length_sec = float(match_res.group(2))\n            cpayload = match_res.group(4)\n\n            if not self.observed_start_time:\n                # No explicit start time noted. Use 1st observed time:\n                self.start_time_sec = log_time_stamp_in_sec\n                self.observed_start_time = True\n\n            if not self.observed_base_time:\n                # No explicit base time noted.\n                # Deduce from 1st observed time (compared to start time):\n                if log_time_stamp_in_sec < self.start_time_sec - (365 * 24 * 3600.0):\n                    # Criteria Note: if log timestamp is more than a year in\n                    # the past (compared to StartTime),\n                    # we assume that timestamps in the log are not absolute\n                    self.base_time_sec = self.start_time_sec\n                else:\n                    # Timestamps are absolute\n                    self.base_time_sec = 0.0\n                self.observed_base_time = True\n\n            absolute_start_time_stamp_sec = \\\n                log_time_stamp_in_sec + self.base_time_sec\n            offset_start_time_stamp_sec = \\\n                absolute_start_time_stamp_sec - self.start_time_sec\n\n            # Timestamp length is expect to be in seconds\n            absolute_end_time_stamp_sec = \\\n                absolute_start_time_stamp_sec + interval_length_sec\n\n            if absolute:\n                start_time_stamp_to_check_range_on = absolute_start_time_stamp_sec\n            else:\n                start_time_stamp_to_check_range_on = offset_start_time_stamp_sec\n\n            if start_time_stamp_to_check_range_on < range_start_time_sec:\n                continue\n\n            if start_time_stamp_to_check_range_on > range_end_time_sec:\n                return None\n            if dest_histogram:\n                # add the interval histogram to the destination histogram\n                histogram = dest_histogram\n                histogram.decode_and_add(cpayload)\n            else:\n                histogram = HdrHistogram.decode(cpayload)\n                histogram.set_start_time_stamp(absolute_start_time_stamp_sec * 1000.0)\n                histogram.set_end_time_stamp(absolute_end_time_stamp_sec * 1000.0)\n            return histogram", "response": "This method reads the next interval histogram from the log file and returns the corresponding histogram object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_next_interval_histogram(self,\n                                    range_start_time_sec=0.0,\n                                    range_end_time_sec=sys.maxsize,\n                                    absolute=False):\n        '''Read the next interval histogram from the log, if interval falls\n        within an absolute or relative time range.\n\n        Timestamps are assumed to appear in order in the log file, and as such\n        this method will return a null upon encountering a timestamp larger than\n        range_end_time_sec.\n\n        Relative time range:\n            the range is assumed to be in seconds relative to\n            the actual timestamp value found in each interval line in the log\n        Absolute time range:\n            Absolute timestamps are calculated by adding the timestamp found\n            with the recorded interval to the [latest, optional] start time\n            found in the log. The start time is indicated in the log with\n            a \"#[StartTime: \" followed by the start time in seconds.\n\n        Params:\n\n            range_start_time_sec The absolute or relative start of the expected\n                                 time range, in seconds.\n            range_start_time_sec The absolute or relative end of the expected\n                                  time range, in seconds.\n            absolute Defines if the passed range is absolute or relative\n\n        Return:\n            Returns an histogram object if an interval line was found with an\n            associated start timestamp value that falls between start_time_sec and\n            end_time_sec,\n            or null if no such interval line is found.\n            Upon encountering any unexpected format errors in reading the next\n            interval from the file, this method will return None.\n\n            The histogram returned will have it's timestamp set to the absolute\n            timestamp calculated from adding the interval's indicated timestamp\n            value to the latest [optional] start time found in the log.\n\n        Exceptions:\n            ValueError if there is a syntax error in one of the float fields\n        '''\n        return self._decode_next_interval_histogram(None,\n                                                    range_start_time_sec,\n                                                    range_end_time_sec,\n                                                    absolute)", "response": "This method reads the next interval histogram from the log file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the next interval histogram from the log, if interval falls within an absolute or relative time range, and add it to the destination histogram (or to the reference histogram if dest_histogram is None) Timestamps are assumed to appear in order in the log file, and as such this method will return a null upon encountering a timestamp larger than range_end_time_sec. Relative time range: the range is assumed to be in seconds relative to the actual timestamp value found in each interval line in the log Absolute time range: Absolute timestamps are calculated by adding the timestamp found with the recorded interval to the [latest, optional] start time found in the log. The start time is indicated in the log with a \"#[StartTime: \" followed by the start time in seconds. Params: dest_histogram where to add the next interval histogram, if None the interal histogram will be added to the reference histogram passed in the constructor range_start_time_sec The absolute or relative start of the expected time range, in seconds. range_start_time_sec The absolute or relative end of the expected time range, in seconds. absolute Defines if the passed range is absolute or relative Return: Returns the destination histogram if an interval line was found with an associated start timestamp value that falls between start_time_sec and end_time_sec, or None if no such interval line is found. Upon encountering any unexpected format errors in reading the next interval from the file, this method will return None. The histogram returned will have it's timestamp set to the absolute timestamp calculated from adding the interval's indicated timestamp value to the latest [optional] start time found in the log. Exceptions: ValueError if there is a syntax error in one of the float fields", "response": "def add_next_interval_histogram(self,\n                                    dest_histogram=None,\n                                    range_start_time_sec=0.0,\n                                    range_end_time_sec=sys.maxsize,\n                                    absolute=False):\n        '''Read the next interval histogram from the log, if interval falls\n        within an absolute or relative time range, and add it to the destination\n        histogram (or to the reference histogram if dest_histogram is None)\n\n        Timestamps are assumed to appear in order in the log file, and as such\n        this method will return a null upon encountering a timestamp larger than\n        range_end_time_sec.\n\n        Relative time range:\n            the range is assumed to be in seconds relative to\n            the actual timestamp value found in each interval line in the log\n        Absolute time range:\n            Absolute timestamps are calculated by adding the timestamp found\n            with the recorded interval to the [latest, optional] start time\n            found in the log. The start time is indicated in the log with\n            a \"#[StartTime: \" followed by the start time in seconds.\n\n        Params:\n            dest_histogram where to add the next interval histogram, if None\n                           the interal histogram will be added to the reference\n                           histogram passed in the constructor\n            range_start_time_sec The absolute or relative start of the expected\n                                 time range, in seconds.\n            range_start_time_sec The absolute or relative end of the expected\n                                  time range, in seconds.\n            absolute Defines if the passed range is absolute or relative\n\n        Return:\n            Returns the destination histogram if an interval line was found with an\n            associated start timestamp value that falls between start_time_sec and\n            end_time_sec,\n            or None if no such interval line is found.\n            Upon encountering any unexpected format errors in reading the next\n            interval from the file, this method will return None.\n\n            The histogram returned will have it's timestamp set to the absolute\n            timestamp calculated from adding the interval's indicated timestamp\n            value to the latest [optional] start time found in the log.\n\n        Exceptions:\n            ValueError if there is a syntax error in one of the float fields\n        '''\n        if not dest_histogram:\n            dest_histogram = self.reference_histogram\n        return self._decode_next_interval_histogram(dest_histogram,\n                                                    range_start_time_sec,\n                                                    range_end_time_sec,\n                                                    absolute)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsanitize HTML tags other than provided tags and attributes.", "response": "def sanitize_allow(value, args=''):\n    '''\n    Strip HTML tags other than provided tags and attributes.\n    Example usage:\n\n    {% load sanitizer %}\n    {{ post.body|sanitize_allow:'a, strong, img; href, src'}}\n    '''\n    if isinstance(value, basestring):\n        allowed_tags = []\n        allowed_attributes = []\n        allowed_styles = []\n        \n        args = args.strip().split(';')\n        if len(args) > 0:\n            allowed_tags = [tag.strip() for tag in args[0].split(',')]\n        if len(args) > 1:\n            allowed_attributes = [attr.strip() for attr in args[1].split(',')]\n            \n        value = bleach.clean(value, tags=allowed_tags,\n                             attributes=allowed_attributes, strip=True)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nescape HTML tags attributes and styles.", "response": "def escape_html(value, allowed_tags=[], allowed_attributes=[],\n                allowed_styles=[]):\n    \"\"\"\n    Template tag to sanitize string values. It accepts lists of\n    allowed tags, attributes or styles in comma separated string or list format.\n\n    For example:\n\n    {% load sanitizer %}\n    {% escape_html '<a href=\"\">bar</a> <script>alert('baz')</script>' \"a,img' 'href',src' %}\n\n    Will output:\n\n    <a href=\"\">bar</a> &lt;cript&gt;alert('baz')&lt;/script&gt;\n\n    On django 1.4 you could also use keyword arguments:\n\n    {% escape_html '<a href=\"\">bar</a>' allowed_tags=\"a,img' allowed_attributes='href',src' %} \n\n    \"\"\"\n    if isinstance(value, basestring):\n        value = bleach.clean(value, tags=allowed_tags,\n                             attributes=allowed_attributes, \n                             styles=allowed_styles, strip=False)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntemplates tag to strip html from string values. It accepts lists of allowed tags, attributes or stylesin comma separated string or list format. For example: {% load sanitizer %} {% strip_html '<a href=\"\">bar</a> <script>alert('baz')</script>' \"a,img' 'href',src' %} Will output: <a href=\"\">bar</a> alert('baz'); On django 1.4 you could also use keyword arguments: {% strip_html '<a href=\"\">bar</a>' allowed_tags=\"a,img' allowed_attributes='href',src' %}", "response": "def strip_html(value, allowed_tags=[], allowed_attributes=[],\n               allowed_styles=[]):\n    \"\"\"\n    Template tag to strip html from string values. It accepts lists of\n    allowed tags, attributes or stylesin comma separated string or list format.\n\n    For example:\n\n    {% load sanitizer %}\n    {% strip_html '<a href=\"\">bar</a> <script>alert('baz')</script>' \"a,img' 'href',src' %}\n\n    Will output:\n\n    <a href=\"\">bar</a> alert('baz');\n\n    On django 1.4 you could also use keyword arguments:\n\n    {% strip_html '<a href=\"\">bar</a>' allowed_tags=\"a,img' allowed_attributes='href',src' %}    \n\n    \"\"\"\n    if isinstance(value, basestring):\n        value = bleach.clean(value, tags=allowed_tags,\n                             attributes=allowed_attributes, \n                             styles=allowed_styles, strip=True)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_censor_char():\n    global _censor_pool\n    if not _censor_pool:\n        # censor pool is empty. fill it back up.\n        _censor_pool = list(_censor_chars)\n    return _censor_pool.pop(random.randrange(len(_censor_pool)))", "response": "Plucks a letter out of the censor_pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the input string with profanity replaced with a random string of characters plucked from the censor_characters pool.", "response": "def censor(input_text):\n    \"\"\" Returns the input string with profanity replaced with a random string\n    of characters plucked from the censor_characters pool.\n\n    \"\"\"\n    ret = input_text\n    words = get_words()\n    for word in words:\n        curse_word = re.compile(re.escape(word), re.IGNORECASE)\n        cen = \"\".join(get_censor_char() for i in list(word))\n        ret = curse_word.sub(cen, ret)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading and caches the profanity word list.", "response": "def load_words(wordlist=None):\n    \"\"\" Loads and caches the profanity word list. Input file (if provided)\n    should be a flat text file with one profanity entry per line.\n\n    \"\"\"\n    global words\n    if not wordlist:\n        # no wordlist was provided, load the wordlist from the local store\n        filename = get_data('wordlist.txt')\n        f = open(filename)\n        wordlist = f.readlines()\n        wordlist = [w.strip() for w in wordlist if w]\n    words = wordlist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert(csv, json, **kwargs):\n    '''Convert csv to json.\n\n    csv:  filename or file-like object\n    json: filename  or file-like object\n\n\n    if csv is '-' or None:\n        stdin is used for input\n    if json is '-' or None:\n        stdout is used for output\n    '''\n\n    csv_local, json_local = None, None\n    try:\n        if csv == '-' or csv is None:\n            csv = sys.stdin\n        elif isinstance(csv, str):\n            csv = csv_local = open(csv, 'r')\n\n        if json == '-' or json is None:\n            json = sys.stdout\n        elif isinstance(json, str):\n            json = json_local = open(json, 'w')\n\n        data = load_csv(csv, **kwargs)\n        save_json(data, json, **kwargs)\n    finally:\n        if csv_local is not None:\n            csv_local.close()\n        if json_local is not None:\n            json_local.close()", "response": "Convert csv to json."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds new sentence to generate dictionarys.", "response": "def update_dicts(self, sentence):\n        \"\"\"Add new sentence to generate dictionaries.\n\n        :param sentence: A list of strings representing the sentence.\n        \"\"\"\n        self.dict_generator(sentence=sentence)\n        self.word_dict, self.char_dict = None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_dicts(self, word_dict, char_dict):\n        self.word_dict = word_dict\n        self.char_dict = char_dict", "response": "Set with custom dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting word and character dictionaries.", "response": "def get_dicts(self):\n        \"\"\"Get word and character dictionaries.\n\n        :return word_dict, char_dict:\n        \"\"\"\n        if self.word_dict is None:\n            self.word_dict, self.char_dict, self.max_word_len = self.dict_generator(return_dict=True)\n        return self.word_dict, self.char_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the merged embedding layer.", "response": "def get_embedding_layer(self,\n                            word_embd_dim=300,\n                            char_embd_dim=30,\n                            char_hidden_dim=150,\n                            char_hidden_layer_type='lstm',\n                            word_embd_weights=None,\n                            word_embd_file_path=None,\n                            char_embd_weights=None,\n                            char_embd_file_path=None,\n                            word_embd_trainable=None,\n                            char_embd_trainable=None,\n                            word_mask_zero=True,\n                            char_mask_zero=True,):\n        \"\"\"Get the merged embedding layer.\n\n        :param word_embd_dim: The dimensions of the word embedding.\n        :param char_embd_dim: The dimensions of the character embedding\n        :param char_hidden_dim: The dimensions of the hidden states of RNN in one direction.\n        :param word_embd_weights: A numpy array representing the pre-trained embeddings for words.\n        :param word_embd_file_path: The file that contains the word embeddings.\n        :param char_embd_weights: A numpy array representing the pre-trained embeddings for characters.\n        :param char_embd_file_path: The file that contains the character embeddings.\n        :param word_embd_trainable: Whether the word embedding layer is trainable.\n        :param char_embd_trainable: Whether the character embedding layer is trainable.\n        :param char_hidden_layer_type: The type of the recurrent layer, 'lstm' or 'gru'.\n        :param word_mask_zero: Whether enable the mask for words.\n        :param char_mask_zero: Whether enable the mask for characters.\n\n        :return inputs, embd_layer: The keras layer.\n        \"\"\"\n        if word_embd_file_path is not None:\n            word_embd_weights = get_embedding_weights_from_file(word_dict=self.get_word_dict(),\n                                                                file_path=word_embd_file_path,\n                                                                ignore_case=self.word_ignore_case)\n        if char_embd_file_path is not None:\n            char_embd_weights = get_embedding_weights_from_file(word_dict=self.get_char_dict(),\n                                                                file_path=char_embd_file_path,\n                                                                ignore_case=self.char_ignore_case)\n        return get_embedding_layer(word_dict_len=len(self.get_word_dict()),\n                                   char_dict_len=len(self.get_char_dict()),\n                                   max_word_len=self.max_word_len,\n                                   word_embd_dim=word_embd_dim,\n                                   char_embd_dim=char_embd_dim,\n                                   char_hidden_dim=char_hidden_dim,\n                                   char_hidden_layer_type=char_hidden_layer_type,\n                                   word_embd_weights=word_embd_weights,\n                                   char_embd_weights=char_embd_weights,\n                                   word_embd_trainable=word_embd_trainable,\n                                   char_embd_trainable=char_embd_trainable,\n                                   word_mask_zero=word_mask_zero,\n                                   char_mask_zero=char_mask_zero)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts sentences to desired input tensors.", "response": "def get_batch_input(self, sentences):\n        \"\"\"Convert sentences to desired input tensors.\n\n        :param sentences: A list of lists representing the input sentences.\n\n        :return word_embd_input, char_embd_input: The desired inputs.\n        \"\"\"\n        return get_batch_input(sentences,\n                               max_word_len=self.max_word_len,\n                               word_dict=self.get_word_dict(),\n                               char_dict=self.get_char_dict(),\n                               word_ignore_case=self.word_ignore_case,\n                               char_ignore_case=self.char_ignore_case)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a list of sentences to a list of input tensors.", "response": "def get_batch_input(sentences,\n                    max_word_len,\n                    word_dict,\n                    char_dict,\n                    word_unknown=1,\n                    char_unknown=1,\n                    word_ignore_case=False,\n                    char_ignore_case=False):\n    \"\"\"Convert sentences to desired input tensors.\n\n    :param sentences: A list of lists representing the input sentences.\n    :param max_word_len: The maximum allowed length of word.\n    :param word_dict: Map a word to an integer. (0 and 1 should be preserved)\n    :param char_dict: Map a character to an integer. (0 and 1 should be preserved)\n    :param word_unknown: An integer representing the unknown word.\n    :param char_unknown: An integer representing the unknown character.\n    :param word_ignore_case: Word will be transformed to lower case before mapping.\n    :param char_ignore_case: Character will be transformed to lower case before mapping.\n\n    :return word_embd_input, char_embd_input: The desired inputs.\n    \"\"\"\n    sentence_num = len(sentences)\n\n    max_sentence_len = max(map(len, sentences))\n\n    word_embd_input = [[0] * max_sentence_len for _ in range(sentence_num)]\n    char_embd_input = [[[0] * max_word_len for _ in range(max_sentence_len)] for _ in range(sentence_num)]\n\n    for sentence_index, sentence in enumerate(sentences):\n        for word_index, word in enumerate(sentence):\n            if word_ignore_case:\n                word_key = word.lower()\n            else:\n                word_key = word\n            word_embd_input[sentence_index][word_index] = word_dict.get(word_key, word_unknown)\n            for char_index, char in enumerate(word):\n                if char_index >= max_word_len:\n                    break\n                if char_ignore_case:\n                    char = char.lower()\n                char_embd_input[sentence_index][word_index][char_index] = char_dict.get(char, char_unknown)\n\n    return [numpy.asarray(word_embd_input), numpy.asarray(char_embd_input)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the merged embedding layer.", "response": "def get_embedding_layer(word_dict_len,\n                        char_dict_len,\n                        max_word_len,\n                        word_embd_dim=300,\n                        char_embd_dim=30,\n                        char_hidden_dim=150,\n                        char_hidden_layer_type='lstm',\n                        word_embd_weights=None,\n                        char_embd_weights=None,\n                        word_embd_trainable=None,\n                        char_embd_trainable=None,\n                        word_mask_zero=True,\n                        char_mask_zero=True):\n    \"\"\"Get the merged embedding layer.\n\n    :param word_dict_len: The number of words in the dictionary including the ones mapped to 0 or 1.\n    :param char_dict_len: The number of characters in the dictionary including the ones mapped to 0 or 1.\n    :param max_word_len: The maximum allowed length of word.\n    :param word_embd_dim: The dimensions of the word embedding.\n    :param char_embd_dim: The dimensions of the character embedding\n    :param char_hidden_dim: The dimensions of the hidden states of RNN in one direction.\n    :param word_embd_weights: A numpy array representing the pre-trained embeddings for words.\n    :param char_embd_weights: A numpy array representing the pre-trained embeddings for characters.\n    :param word_embd_trainable: Whether the word embedding layer is trainable.\n    :param char_embd_trainable: Whether the character embedding layer is trainable.\n    :param char_hidden_layer_type: The type of the recurrent layer, 'lstm' or 'gru'.\n    :param word_mask_zero: Whether enable the mask for words.\n    :param char_mask_zero: Whether enable the mask for characters.\n\n    :return inputs, embd_layer: The keras layer.\n    \"\"\"\n    if word_embd_weights is not None:\n        word_embd_weights = [word_embd_weights]\n    if word_embd_trainable is None:\n        word_embd_trainable = word_embd_weights is None\n\n    if char_embd_weights is not None:\n        char_embd_weights = [char_embd_weights]\n    if char_embd_trainable is None:\n        char_embd_trainable = char_embd_weights is None\n\n    word_input_layer = keras.layers.Input(\n        shape=(None,),\n        name='Input_Word',\n    )\n    char_input_layer = keras.layers.Input(\n        shape=(None, max_word_len),\n        name='Input_Char',\n    )\n\n    word_embd_layer = keras.layers.Embedding(\n        input_dim=word_dict_len,\n        output_dim=word_embd_dim,\n        mask_zero=word_mask_zero,\n        weights=word_embd_weights,\n        trainable=word_embd_trainable,\n        name='Embedding_Word',\n    )(word_input_layer)\n    char_embd_layer = keras.layers.Embedding(\n        input_dim=char_dict_len,\n        output_dim=char_embd_dim,\n        mask_zero=char_mask_zero,\n        weights=char_embd_weights,\n        trainable=char_embd_trainable,\n        name='Embedding_Char_Pre',\n    )(char_input_layer)\n    if char_hidden_layer_type == 'lstm':\n        char_hidden_layer = keras.layers.Bidirectional(\n            keras.layers.LSTM(\n                units=char_hidden_dim,\n                input_shape=(max_word_len, char_dict_len),\n                return_sequences=False,\n                return_state=False,\n            ),\n            name='Bi-LSTM_Char',\n        )\n    elif char_hidden_layer_type == 'gru':\n        char_hidden_layer = keras.layers.Bidirectional(\n            keras.layers.GRU(\n                units=char_hidden_dim,\n                input_shape=(max_word_len, char_dict_len),\n                return_sequences=False,\n                return_state=False,\n            ),\n            name='Bi-GRU_Char',\n        )\n    elif char_hidden_layer_type == 'cnn':\n        char_hidden_layer = [\n            MaskedConv1D(\n                filters=max(1, char_hidden_dim // 5),\n                kernel_size=3,\n                activation='relu',\n            ),\n            MaskedFlatten(),\n            keras.layers.Dense(\n                units=char_hidden_dim,\n                name='Dense_Char',\n            ),\n        ]\n    elif isinstance(char_hidden_layer_type, list) or isinstance(char_hidden_layer_type, keras.layers.Layer):\n        char_hidden_layer = char_hidden_layer_type\n    else:\n        raise NotImplementedError('Unknown character hidden layer type: %s' % char_hidden_layer_type)\n    if not isinstance(char_hidden_layer, list):\n        char_hidden_layer = [char_hidden_layer]\n    for i, layer in enumerate(char_hidden_layer):\n        if i == len(char_hidden_layer) - 1:\n            name = 'Embedding_Char'\n        else:\n            name = 'Embedding_Char_Pre_%d' % (i + 1)\n        char_embd_layer = keras.layers.TimeDistributed(layer=layer, name=name)(char_embd_layer)\n    embd_layer = keras.layers.Concatenate(\n        name='Embedding',\n    )([word_embd_layer, char_embd_layer])\n    return [word_input_layer, char_input_layer], embd_layer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a generator that returns the word and character dictionaries for a single word and a single character.", "response": "def get_dicts_generator(word_min_freq=4,\n                        char_min_freq=2,\n                        word_ignore_case=False,\n                        char_ignore_case=False):\n    \"\"\"Get word and character dictionaries from sentences.\n\n    :param word_min_freq: The minimum frequency of a word.\n    :param char_min_freq: The minimum frequency of a character.\n    :param word_ignore_case: Word will be transformed to lower case before saving to dictionary.\n    :param char_ignore_case: Character will be transformed to lower case before saving to dictionary.\n    :return gen: A closure that accepts sentences and returns the dictionaries.\n    \"\"\"\n    word_count, char_count = {}, {}\n\n    def get_dicts(sentence=None,\n                  return_dict=False):\n        \"\"\"Update and return dictionaries for each sentence.\n\n        :param sentence: A list of strings representing the sentence.\n        :param return_dict: Returns the dictionaries if it is True.\n        :return word_dict, char_dict, max_word_len:\n        \"\"\"\n        if sentence is not None:\n            for word in sentence:\n                if not word:\n                    continue\n                if word_ignore_case:\n                    word_key = word.lower()\n                else:\n                    word_key = word\n                word_count[word_key] = word_count.get(word_key, 0) + 1\n                for char in word:\n                    if char_ignore_case:\n                        char_key = char.lower()\n                    else:\n                        char_key = char\n                    char_count[char_key] = char_count.get(char_key, 0) + 1\n        if not return_dict:\n            return None\n        word_dict, char_dict = {'': 0, '<UNK>': 1}, {'': 0, '<UNK>': 1}\n        max_word_len = 0\n        for word, count in word_count.items():\n            if count >= word_min_freq:\n                word_dict[word] = len(word_dict)\n                max_word_len = max(max_word_len, len(word))\n        for char, count in char_count.items():\n            if count >= char_min_freq:\n                char_dict[char] = len(char_dict)\n        return word_dict, char_dict, max_word_len\n\n    return get_dicts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_word_list_eng(text):\n    words, index = [''], 0\n    while index < len(text):\n        while index < len(text) and ('a' <= text[index] <= 'z' or 'A' <= text[index] <= 'Z'):\n            words[-1] += text[index]\n            index += 1\n        if words[-1]:\n            words.append('')\n        while index < len(text) and not ('a' <= text[index] <= 'z' or 'A' <= text[index] <= 'Z'):\n            if text[index] != ' ':\n                words[-1] += text[index]\n            index += 1\n        if words[-1]:\n            words.append('')\n    if not words[-1]:\n        words.pop()\n    return words", "response": "A naive function that extracts English words from raw text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload pre - trained embeddings from a text file.", "response": "def get_embedding_weights_from_file(word_dict, file_path, ignore_case=False):\n    \"\"\"Load pre-trained embeddings from a text file.\n\n    Each line in the file should look like this:\n        word feature_dim_1 feature_dim_2 ... feature_dim_n\n\n    The `feature_dim_i` should be a floating point number.\n\n    :param word_dict: A dict that maps words to indice.\n    :param file_path: The location of the text file containing the pre-trained embeddings.\n    :param ignore_case: Whether ignoring the case of the words.\n\n    :return weights: A numpy array.\n    \"\"\"\n    pre_trained = {}\n    with codecs.open(file_path, 'r', 'utf8') as reader:\n        for line in reader:\n            line = line.strip()\n            if not line:\n                continue\n            parts = line.split()\n            if ignore_case:\n                parts[0] = parts[0].lower()\n            pre_trained[parts[0]] = list(map(float, parts[1:]))\n    embd_dim = len(next(iter(pre_trained.values())))\n    weights = [[0.0] * embd_dim for _ in range(max(word_dict.values()) + 1)]\n    for word, index in word_dict.items():\n        if not word:\n            continue\n        if ignore_case:\n            word = word.lower()\n        if word in pre_trained:\n            weights[index] = pre_trained[word]\n        else:\n            weights[index] = numpy.random.random((embd_dim,)).tolist()\n    return numpy.asarray(weights)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the backend by name raises KeyError if no backend exists with the given name", "response": "def get_backend(name):\n    \"\"\"Returns the backend by name or raises KeyError\"\"\"\n\n    for backend in _BACKENDS:\n        if backend.NAME == name:\n            return backend\n    raise KeyError(\"Backend %r not available\" % name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a prefered ffi backend.", "response": "def set_backend(name=None):\n    \"\"\"Set a prefered ffi backend (cffi, ctypes).\n\n    set_backend() -- default\n    set_backend(\"cffi\") -- cffi first, others as fallback\n    set_backend(\"ctypes\") -- ctypes first, others as fallback\n    \"\"\"\n\n    possible = list(_BACKENDS)\n    if name is None:\n        names = []\n    else:\n        names = name.split(\",\")\n\n    for name in reversed(names):\n        for backend in list(possible):\n            if backend.NAME == name:\n                possible.remove(backend)\n                possible.insert(0, backend)\n                break\n        else:\n            raise LookupError(\"Unkown backend: %r\" % name)\n\n    # only add null as fallback it explicitly specified\n    if \"null\" not in names:\n        possible = [b for b in possible if b.NAME != \"null\"]\n\n    _ACTIVE_BACKENDS[:] = possible"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint debug information for various public objects like methods functions constructors etc.", "response": "def pprint(obj, file_=None):\n    \"\"\"Prints debug information for various public objects like methods,\n    functions, constructors etc.\n    \"\"\"\n\n    if file_ is None:\n        file_ = sys.stdout\n\n    # functions, methods\n    if callable(obj) and hasattr(obj, \"_code\"):\n        obj._code.pprint(file_)\n        return\n\n    # classes\n    if isinstance(obj, type) and hasattr(obj, \"_constructors\"):\n        constructors = obj._constructors\n        for names, func in sorted(constructors.items()):\n            func._code.pprint(file_)\n        return\n\n    raise TypeError(\"unkown type\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_field_type(info):\n\n    type_ = info.get_type()\n\n    cls = get_field_class(type_)\n\n    field = cls(info, type_, None)\n    field.setup()\n    return field.py_type", "response": "A field python type"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new Color object from red green and blue values from 0. 0 to 1. 0.", "response": "def from_floats(red, green, blue):\n        \"\"\"Return a new Color object from red/green/blue values from 0.0 to 1.0.\"\"\"\n\n        return Color(int(red * Color.MAX_VALUE),\n                     int(green * Color.MAX_VALUE),\n                     int(blue * Color.MAX_VALUE))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _construct_target_list(targets):\n    target_entries = []\n    for entry in targets:\n        if not isinstance(entry, Gtk.TargetEntry):\n            entry = Gtk.TargetEntry.new(*entry)\n        target_entries.append(entry)\n    return target_entries", "response": "Construct a list of TargetEntry items from a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef child_get_property(self, child, property_name, value=None):\n\n        if value is None:\n            prop = self.find_child_property(property_name)\n            if prop is None:\n                raise ValueError('Class \"%s\" does not contain child property \"%s\"' %\n                                 (self, property_name))\n            value = GObject.Value(prop.value_type)\n\n        Gtk.Container.child_get_property(self, child, property_name, value)\n        return value.get_value()", "response": "get_property - Gets the value of a child property"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of child property values for the given names.", "response": "def child_get(self, child, *prop_names):\n        \"\"\"Returns a list of child property values for the given names.\"\"\"\n\n        return [self.child_get_property(child, name) for name in prop_names]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef child_set(self, child, **kwargs):\n\n        for name, value in kwargs.items():\n            name = name.replace('_', '-')\n            self.child_set_property(child, name, value)", "response": "Set a child property on the given child to key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert text into the contents of the the widget at the specified position.", "response": "def insert_text(self, text, position):\n        \"\"\"insert_text(self, text, position)\n\n        :param new_text:\n            the text to append\n        :type new_text: :obj:`str`\n\n        :param position:\n            location of the position text will be inserted at\n        :type position: :obj:`int`\n\n        :returns:\n            location of the position text will be inserted at\n        :rtype: :obj:`int`\n\n        Inserts `new_text` into the contents of the\n        widget, at position `position`.\n\n        Note that the position is in characters, not in bytes.\n        \"\"\"\n\n        return super(Editable, self).insert_text(text, -1, position)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_actions(self, entries, user_data=None):\n        try:\n            iter(entries)\n        except (TypeError):\n            raise TypeError('entries must be iterable')\n\n        def _process_action(name, stock_id=None, label=None, accelerator=None, tooltip=None, callback=None):\n            action = Action(name=name, label=label, tooltip=tooltip, stock_id=stock_id)\n            if callback is not None:\n                if user_data is None:\n                    action.connect('activate', callback)\n                else:\n                    action.connect('activate', callback, user_data)\n\n            self.add_action_with_accel(action, accelerator)\n\n        for e in entries:\n            # using inner function above since entries can leave out optional arguments\n            _process_action(*e)", "response": "This method creates a list of gtk. Action objects based on the information in entries and adds them to the action group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_ui_from_string(self, buffer, length=-1):\n\n        return Gtk.UIManager.add_ui_from_string(self, buffer, length)", "response": "Add a UI from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_objects_from_string(self, buffer, object_ids):\n\n        length = -1\n        return Gtk.Builder.add_objects_from_string(self, buffer, length, object_ids)", "response": "add_objects_from_string - Adds objects from a string to the tree"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_tag(self, tag_name=None, **properties):\n\n        tag = Gtk.TextTag(name=tag_name, **properties)\n        self._get_or_create_tag_table().add(tag)\n        return tag", "response": "Creates a new tag and adds it to the tag table of the TextBuffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_text(self, text, length=-1):\n\n        Gtk.TextBuffer.set_text(self, text, length)", "response": "set text to be displayed in the log"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninsert text into the buffer", "response": "def insert(self, iter, text, length=-1):\n        \"\"\"insert(iter, text, length=-1)\n\n        {{ all }}\n        \"\"\"\n\n        Gtk.TextBuffer.insert(self, iter, text, length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_iter(self, path):\n\n        path = self._coerce_path(path)\n        success, aiter = super(TreeModel, self).get_iter(path)\n        if not success:\n            raise ValueError(\"invalid tree path '%s'\" % path)\n        return aiter", "response": "Returns an iterator pointing to the given path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator pointing to the next node following iter.", "response": "def iter_next(self, iter):\n        \"\"\"\n        :param iter: the :obj:`Gtk.TreeIter`-struct\n        :type iter: :obj:`Gtk.TreeIter`\n\n        :returns: a :obj:`Gtk.TreeIter` or :obj:`None`\n        :rtype: :obj:`Gtk.TreeIter` or :obj:`None`\n\n        Returns an iterator pointing to the node following `iter` at the\n        current level.\n\n        If there is no next `iter`, :obj:`None` is returned.\n        \"\"\"\n\n        next_iter = iter.copy()\n        success = super(TreeModel, self).iter_next(next_iter)\n        if success:\n            return next_iter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an iterator pointing to the previous node at the current level.", "response": "def iter_previous(self, iter):\n        \"\"\"\n        :param iter: the :obj:`Gtk.TreeIter`-struct\n        :type iter: :obj:`Gtk.TreeIter`\n\n        :returns: a :obj:`Gtk.TreeIter` or :obj:`None`\n        :rtype: :obj:`Gtk.TreeIter` or :obj:`None`\n\n        Returns an iterator pointing to the previous node at the current level.\n\n        If there is no previous `iter`, :obj:`None` is returned.\n        \"\"\"\n\n        prev_iter = iter.copy()\n        success = super(TreeModel, self).iter_previous(prev_iter)\n        if success:\n            return prev_iter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_row(self, treeiter, row):\n\n        converted_row, columns = self._convert_row(row)\n        for column in columns:\n            value = row[column]\n            if value is None:\n                continue  # None means skip this row\n\n            self.set_value(treeiter, column, value)", "response": "Sets the value of the item in the treestore from a list of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts value to a GObject. Value of the expected type", "response": "def _convert_value(self, column, value):\n        '''Convert value to a GObject.Value of the expected type'''\n\n        if isinstance(value, GObject.Value):\n            return value\n        return GObject.Value(self.get_column_type(column), value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple of all values in the tree store for the given treeiter and the given columns.", "response": "def get(self, treeiter, *columns):\n        \"\"\"\n        :param treeiter: the :obj:`Gtk.TreeIter`\n        :type treeiter: :obj:`Gtk.TreeIter`\n\n        :param \\\\*columns: a list of column indices to fetch\n        :type columns: (:obj:`int`)\n\n        Returns a tuple of all values specified by their indices in `columns`\n        in the order the indices are contained in `columns`\n\n        Also see :obj:`Gtk.TreeStore.get_value`\\\\()\n        \"\"\"\n\n        n_columns = self.get_n_columns()\n\n        values = []\n        for col in columns:\n            if not isinstance(col, int):\n                raise TypeError(\"column numbers must be ints\")\n\n            if col < 0 or col >= n_columns:\n                raise ValueError(\"column number is out of range\")\n\n            values.append(self.get_value(treeiter, col))\n\n        return tuple(values)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nappending - Appends a new entry to the list store", "response": "def append(self, row=None):\n        \"\"\"append(row=None)\n\n        :param row: a list of values to apply to the newly append row or :obj:`None`\n        :type row: [:obj:`object`] or :obj:`None`\n\n        :returns: :obj:`Gtk.TreeIter` of the appended row\n        :rtype: :obj:`Gtk.TreeIter`\n\n        If `row` is :obj:`None` the appended row will be empty and to fill in\n        values you need to call :obj:`Gtk.ListStore.set`\\\\() or\n        :obj:`Gtk.ListStore.set_value`\\\\().\n\n        If `row` isn't :obj:`None` it has to be a list of values which will be\n        used to fill the row .\n        \"\"\"\n\n        if row:\n            return self._do_insert(-1, row)\n        # gtk_list_store_insert() does not know about the \"position == -1\"\n        # case, so use append() here\n        else:\n            return Gtk.ListStore.append(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninsert a new row before a sibling.", "response": "def insert_before(self, sibling, row=None):\n        \"\"\"insert_before(sibling, row=None)\n\n        :param sibling: A valid :obj:`Gtk.TreeIter`, or :obj:`None`\n        :type sibling: :obj:`Gtk.TreeIter` or :obj:`None`\n\n        :param row: a list of values to apply to the newly inserted row or :obj:`None`\n        :type row: [:obj:`object`] or :obj:`None`\n\n        :returns: :obj:`Gtk.TreeIter` pointing to the new row\n        :rtype: :obj:`Gtk.TreeIter`\n\n        Inserts a new row before `sibling`. If `sibling` is :obj:`None`, then\n        the row will be appended to the end of the list.\n\n        The row will be empty if `row` is :obj:`None. To fill in values, you\n        need to call :obj:`Gtk.ListStore.set`\\\\() or\n        :obj:`Gtk.ListStore.set_value`\\\\().\n\n        If `row` isn't :obj:`None` it has to be a list of values which will be\n        used to fill the row.\n        \"\"\"\n\n        treeiter = Gtk.ListStore.insert_before(self, sibling)\n\n        if row is not None:\n            self.set_row(treeiter, row)\n\n        return treeiter"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts a new row after a sibling.", "response": "def insert_after(self, sibling, row=None):\n        \"\"\"insert_after(sibling, row=None)\n\n        :param sibling: A valid :obj:`Gtk.TreeIter`, or :obj:`None`\n        :type sibling: :obj:`Gtk.TreeIter` or :obj:`None`\n\n        :param row: a list of values to apply to the newly inserted row or :obj:`None`\n        :type row: [:obj:`object`] or :obj:`None`\n\n        :returns: :obj:`Gtk.TreeIter` pointing to the new row\n        :rtype: :obj:`Gtk.TreeIter`\n\n        Inserts a new row after `sibling`. If `sibling` is :obj:`None`, then\n        the row will be prepended to the beginning of the list.\n\n        The row will be empty if `row` is :obj:`None. To fill in values, you\n        need to call :obj:`Gtk.ListStore.set`\\\\() or\n        :obj:`Gtk.ListStore.set_value`\\\\().\n\n        If `row` isn't :obj:`None` it has to be a list of values which will be\n        used to fill the row.\n        \"\"\"\n\n        treeiter = Gtk.ListStore.insert_after(self, sibling)\n\n        if row is not None:\n            self.set_row(treeiter, row)\n\n        return treeiter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the value of the a column in the treeiter.", "response": "def set_value(self, treeiter, column, value):\n        \"\"\"\n        {{ all }}\n\n        `value` can also be a Python value and will be converted to a\n        :obj:`GObject.Value` using the corresponding column type (See\n        :obj:`Gtk.ListStore.set_column_types`\\\\()).\n        \"\"\"\n\n        value = self._convert_value(column, value)\n        Gtk.ListStore.set_value(self, treeiter, column, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the next TreeModelRow", "response": "def get_next(self):\n        \"\"\"Returns the next :obj:`Gtk.TreeModelRow` or None\"\"\"\n\n        next_iter = self.model.iter_next(self.iter)\n        if next_iter:\n            return TreeModelRow(self.model, next_iter)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the previous TreeModelRow", "response": "def get_previous(self):\n        \"\"\"Returns the previous :obj:`Gtk.TreeModelRow` or None\"\"\"\n\n        prev_iter = self.model.iter_previous(self.iter)\n        if prev_iter:\n            return TreeModelRow(self.model, prev_iter)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the parent TreeModelRow or None", "response": "def get_parent(self):\n        \"\"\"Returns the parent :obj:`Gtk.TreeModelRow` or htis row or None\"\"\"\n\n        parent_iter = self.model.iter_parent(self.iter)\n        if parent_iter:\n            return TreeModelRow(self.model, parent_iter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iterchildren(self):\n\n        child_iter = self.model.iter_children(self.iter)\n        return TreeModelRowIter(self.model, child_iter)", "response": "Returns a : obj : Gtk. TreeModelRowIter for the row s children"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, parent, position, row=None):\n\n        return self._do_insert(parent, position, row)", "response": "Insert a new entry into the tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insert_before(self, parent, sibling, row=None):\n\n        treeiter = Gtk.TreeStore.insert_before(self, parent, sibling)\n\n        if row is not None:\n            self.set_row(treeiter, row)\n\n        return treeiter", "response": "Insert a new row before a sibling."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_value(self, treeiter, column, value):\n\n        value = self._convert_value(column, value)\n        Gtk.TreeStore.set_value(self, treeiter, column, value)", "response": "Set the value of the key - value pair in the treestore."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert_column_with_attributes(self, position, title, cell, **kwargs):\n\n        column = TreeViewColumn()\n        column.set_title(title)\n        column.pack_start(cell, False)\n        self.insert_column(column, position)\n        column.set_attributes(cell, **kwargs)", "response": "Insert a new column with the given title and cell attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the attributes of the cell layout.", "response": "def set_attributes(self, cell_renderer, **attributes):\n        \"\"\"\n        :param cell_renderer: the :obj:`Gtk.CellRenderer` we're setting the attributes of\n        :type cell_renderer: :obj:`Gtk.CellRenderer`\n\n        {{ docs }}\n        \"\"\"\n\n        Gtk.CellLayout.clear_attributes(self, cell_renderer)\n\n        for (name, value) in attributes.items():\n            Gtk.CellLayout.add_attribute(self, cell_renderer, name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the selected entry in the tree.", "response": "def get_selected(self):\n        \"\"\"\n        :returns:\n            :model: the :obj:`Gtk.TreeModel`\n            :iter: The :obj:`Gtk.TreeIter` or :obj:`None`\n\n        :rtype: (**model**: :obj:`Gtk.TreeModel`, **iter**: :obj:`Gtk.TreeIter` or :obj:`None`)\n\n        {{ docs }}\n        \"\"\"\n\n        success, model, aiter = super(TreeSelection, self).get_selected()\n        if success:\n            return (model, aiter)\n        else:\n            return (model, None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of the child model", "response": "def set_value(self, iter, column, value):\n        \"\"\"Set the value of the child model\"\"\"\n\n        # Delegate to child model\n        iter = self.convert_iter_to_child_iter(iter)\n        self.get_model().set_value(iter, column, value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_foreign_module(namespace):\n\n    if namespace not in _MODULES:\n        try:\n            module = importlib.import_module(\".\" + namespace, __package__)\n        except ImportError:\n            module = None\n        _MODULES[namespace] = module\n\n    module = _MODULES.get(namespace)\n    if module is None:\n        raise ForeignError(\"Foreign %r structs not supported\" % namespace)\n    return module", "response": "Returns the module or raises ForeignError"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_foreign_struct(namespace, name):\n\n    get_foreign_module(namespace)\n\n    try:\n        return ForeignStruct.get(namespace, name)\n    except KeyError:\n        raise ForeignError(\"Foreign %s.%s not supported\" % (namespace, name))", "response": "Returns a ForeignStruct implementation or raises ForeignError"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef require_foreign(namespace, symbol=None):\n\n    \n    try:\n        if symbol is None:\n            get_foreign_module(namespace)\n        else:\n            get_foreign_struct(namespace, symbol)\n    except ForeignError as e:\n        raise ImportError(e)", "response": "Raises ImportError if the specified foreign module isn t supported or the required dependencies aren t installed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef io_add_watch(*args, **kwargs):\n    channel, priority, condition, func, user_data = _io_add_watch_get_args(*args, **kwargs)\n    return GLib.io_add_watch(channel, priority, condition, func, *user_data)", "response": "Wrapper for GLib. io_add_watch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap for GLib. child_watch_add.", "response": "def child_watch_add(*args, **kwargs):\n    \"\"\"child_watch_add(priority, pid, function, *data)\"\"\"\n    priority, pid, function, data = _child_watch_add_get_args(*args, **kwargs)\n    return GLib.child_watch_add(priority, pid, function, *data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a GVariant object from given format and argument list.", "response": "def _create(self, format, args):\n        \"\"\"Create a GVariant object from given format and argument list.\n\n        This method recursively calls itself for complex structures (arrays,\n        dictionaries, boxed).\n\n        Return a tuple (variant, rest_format, rest_args) with the generated\n        GVariant, the remainder of the format string, and the remainder of the\n        arguments.\n\n        If args is None, then this won't actually consume any arguments, and\n        just parse the format string and generate empty GVariant structures.\n        This is required for creating empty dictionaries or arrays.\n        \"\"\"\n        # leaves (simple types)\n        constructor = self._LEAF_CONSTRUCTORS.get(format[0])\n        if constructor:\n            if args is not None:\n                if not args:\n                    raise TypeError('not enough arguments for GVariant format string')\n                v = constructor(args[0])\n                return (v, format[1:], args[1:])\n            else:\n                return (None, format[1:], None)\n\n        if format[0] == '(':\n            return self._create_tuple(format, args)\n\n        if format.startswith('a{'):\n            return self._create_dict(format, args)\n\n        if format[0] == 'a':\n            return self._create_array(format, args)\n\n        raise NotImplementedError('cannot handle GVariant type ' + format)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the case where the outermost type of format is a tuple.", "response": "def _create_tuple(self, format, args):\n        \"\"\"Handle the case where the outermost type of format is a tuple.\"\"\"\n\n        format = format[1:]  # eat the '('\n        if args is None:\n            # empty value: we need to call _create() to parse the subtype\n            rest_format = format\n            while rest_format:\n                if rest_format.startswith(')'):\n                    break\n                rest_format = self._create(rest_format, None)[1]\n            else:\n                raise TypeError('tuple type string not closed with )')\n\n            rest_format = rest_format[1:]  # eat the )\n            return (None, rest_format, None)\n        else:\n            if not args or not isinstance(args[0], tuple):\n                raise TypeError('expected tuple argument')\n\n            builder = GLib.VariantBuilder.new(variant_type_from_string('r'))\n            for i in range(len(args[0])):\n                if format.startswith(')'):\n                    raise TypeError('too many arguments for tuple signature')\n\n                (v, format, _) = self._create(format, args[0][i:])\n                builder.add_value(v)\n            args = args[1:]\n            if not format.startswith(')'):\n                raise TypeError('tuple type string not closed with )')\n\n            rest_format = format[1:]  # eat the )\n            return (builder.end(), rest_format, args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle the case where the outermost type of format is a dict.", "response": "def _create_dict(self, format, args):\n        \"\"\"Handle the case where the outermost type of format is a dict.\"\"\"\n\n        builder = None\n        if args is None or not args[0]:\n            # empty value: we need to call _create() to parse the subtype,\n            # and specify the element type precisely\n            rest_format = self._create(format[2:], None)[1]\n            rest_format = self._create(rest_format, None)[1]\n            if not rest_format.startswith('}'):\n                raise TypeError('dictionary type string not closed with }')\n            rest_format = rest_format[1:]  # eat the }\n            element_type = format[:len(format) - len(rest_format)]\n            builder = GLib.VariantBuilder.new(variant_type_from_string(element_type))\n        else:\n            builder = GLib.VariantBuilder.new(variant_type_from_string('a{?*}'))\n            for k, v in args[0].items():\n                (key_v, rest_format, _) = self._create(format[2:], [k])\n                (val_v, rest_format, _) = self._create(rest_format, [v])\n\n                if not rest_format.startswith('}'):\n                    raise TypeError('dictionary type string not closed with }')\n                rest_format = rest_format[1:]  # eat the }\n\n                entry = GLib.VariantBuilder.new(variant_type_from_string('{?*}'))\n                entry.add_value(key_v)\n                entry.add_value(val_v)\n                builder.add_value(entry.end())\n\n        if args is not None:\n            args = args[1:]\n        return (builder.end(), rest_format, args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_array(self, format, args):\n\n        builder = None\n        if args is None or not args[0]:\n            # empty value: we need to call _create() to parse the subtype,\n            # and specify the element type precisely\n            rest_format = self._create(format[1:], None)[1]\n            element_type = format[:len(format) - len(rest_format)]\n            builder = GLib.VariantBuilder.new(variant_type_from_string(element_type))\n        else:\n            builder = GLib.VariantBuilder.new(variant_type_from_string('a*'))\n            for i in range(len(args[0])):\n                (v, rest_format, _) = self._create(format[1:], args[0][i:])\n                builder.add_value(v)\n        if args is not None:\n            args = args[1:]\n        return (builder.end(), rest_format, args)", "response": "Handle the case where the outermost type of format is an array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecomposing a GVariant into a native Python object.", "response": "def unpack(self):\n        \"\"\"Decompose a GVariant into a native Python object.\"\"\"\n\n        LEAF_ACCESSORS = {\n            'b': self.get_boolean,\n            'y': self.get_byte,\n            'n': self.get_int16,\n            'q': self.get_uint16,\n            'i': self.get_int32,\n            'u': self.get_uint32,\n            'x': self.get_int64,\n            't': self.get_uint64,\n            'h': self.get_handle,\n            'd': self.get_double,\n            's': self.get_string,\n            'o': self.get_string,  # object path\n            'g': self.get_string,  # signature\n        }\n\n        # simple values\n        la = LEAF_ACCESSORS.get(self.get_type_string())\n        if la:\n            return la()\n\n        # tuple\n        if self.get_type_string().startswith('('):\n            res = [self.get_child_value(i).unpack()\n                   for i in range(self.n_children())]\n            return tuple(res)\n\n        # dictionary\n        if self.get_type_string().startswith('a{'):\n            res = {}\n            for i in range(self.n_children()):\n                v = self.get_child_value(i)\n                res[v.get_child_value(0).unpack()] = v.get_child_value(1).unpack()\n            return res\n\n        # array\n        if self.get_type_string().startswith('a'):\n            return [self.get_child_value(i).unpack()\n                    for i in range(self.n_children())]\n\n        # variant (just unbox transparently)\n        if self.get_type_string().startswith('v'):\n            return self.get_variant().unpack()\n\n        # maybe\n        if self.get_type_string().startswith('m'):\n            m = self.get_maybe()\n            return m.unpack() if m else None\n\n        raise NotImplementedError('unsupported GVariant type ' + self.get_type_string())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsplits a signature into a list of elements.", "response": "def split_signature(klass, signature):\n        \"\"\"Return a list of the element signatures of the topmost signature tuple.\n\n        If the signature is not a tuple, it returns one element with the entire\n        signature. If the signature is an empty tuple, the result is [].\n\n        This is useful for e. g. iterating over method parameters which are\n        passed as a single Variant.\n        \"\"\"\n        if signature == '()':\n            return []\n\n        if not signature.startswith('('):\n            return [signature]\n\n        result = []\n        head = ''\n        tail = signature[1:-1]  # eat the surrounding ()\n        while tail:\n            c = tail[0]\n            head += c\n            tail = tail[1:]\n\n            if c in ('m', 'a'):\n                # prefixes, keep collecting\n                continue\n            if c in ('(', '{'):\n                # consume until corresponding )/}\n                level = 1\n                up = c\n                if up == '(':\n                    down = ')'\n                else:\n                    down = '}'\n                while level > 0:\n                    c = tail[0]\n                    head += c\n                    tail = tail[1:]\n                    if c == up:\n                        level += 1\n                    elif c == down:\n                        level -= 1\n\n            # otherwise we have a simple type\n            result.append(head)\n            head = ''\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef typeinfo_to_ctypes(info, return_value=False):\n\n    tag = info.tag.value\n    ptr = info.is_pointer\n\n    mapping = {\n        GITypeTag.BOOLEAN: gboolean,\n        GITypeTag.INT8: gint8,\n        GITypeTag.UINT8: guint8,\n        GITypeTag.INT16: gint16,\n        GITypeTag.UINT16: guint16,\n        GITypeTag.INT32: gint32,\n        GITypeTag.UINT32: guint32,\n        GITypeTag.INT64: gint64,\n        GITypeTag.UINT64: guint64,\n        GITypeTag.FLOAT: gfloat,\n        GITypeTag.DOUBLE: gdouble,\n        GITypeTag.VOID: None,\n        GITypeTag.GTYPE: GType,\n        GITypeTag.UNICHAR: gunichar,\n    }\n\n    if ptr:\n        if tag == GITypeTag.INTERFACE:\n            return gpointer\n        elif tag in (GITypeTag.UTF8, GITypeTag.FILENAME):\n            if return_value:\n                # ctypes does auto conversion to str and gives us no chance\n                # to free the pointer if transfer=everything\n                return gpointer\n            else:\n                return gchar_p\n        elif tag == GITypeTag.ARRAY:\n            return gpointer\n        elif tag == GITypeTag.ERROR:\n            return GErrorPtr\n        elif tag == GITypeTag.GLIST:\n            return GListPtr\n        elif tag == GITypeTag.GSLIST:\n            return GSListPtr\n        else:\n            if tag in mapping:\n                return ctypes.POINTER(mapping[tag])\n    else:\n        if tag == GITypeTag.INTERFACE:\n            iface = info.get_interface()\n            iface_type = iface.type.value\n            if iface_type == GIInfoType.ENUM:\n                return guint32\n            elif iface_type == GIInfoType.OBJECT:\n                return gpointer\n            elif iface_type == GIInfoType.STRUCT:\n                return gpointer\n            elif iface_type == GIInfoType.UNION:\n                return gpointer\n            elif iface_type == GIInfoType.FLAGS:\n                return guint\n            elif iface_type == GIInfoType.CALLBACK:\n                return GCallback\n\n            raise NotImplementedError(\n                \"Could not convert interface: %r to ctypes type\" % iface.type)\n        else:\n            if tag in mapping:\n                return mapping[tag]\n\n    raise NotImplementedError(\"Could not convert %r to ctypes type\" % info.tag)", "response": "Maps a GITypeInfo object to a ctypes type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pack_pointer(self, name):\n\n        return self.parse(\"\"\"\nraise $_.TypeError('Can\\\\'t convert %(type_name)s to pointer: %%r' %% $in_)\n\"\"\" % {\"type_name\": type(self).__name__}, in_=name)[\"in_\"]", "response": "Returns a pointer containing the value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake bytes and returns a GITypelib or raises GIError", "response": "def new_from_memory(cls, data):\n        \"\"\"Takes bytes and returns a GITypelib, or raises GIError\"\"\"\n\n        size = len(data)\n        copy = g_memdup(data, size)\n        ptr = cast(copy, POINTER(guint8))\n        try:\n            with gerror(GIError) as error:\n                return GITypelib._new_from_memory(ptr, size, error)\n        except GIError:\n            free(copy)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_type(cls, ptr):\n\n        # fall back to the base class if unknown\n        return cls.__types.get(lib.g_base_info_get_type(ptr), cls)", "response": "Get the subtype class for a pointer"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_method(info, target_cls, virtual=False, dont_replace=False):\n\n    # escape before prefixing, like pygobject\n    name = escape_identifier(info.name)\n    if virtual:\n        name = \"do_\" + name\n        attr = VirtualMethodAttribute(info, target_cls, name)\n    else:\n        attr = MethodAttribute(info, target_cls, name)\n\n    if dont_replace and hasattr(target_cls, name):\n        return\n\n    setattr(target_cls, name, attr)", "response": "Add a method to the target class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef InterfaceAttribute(iface_info):\n\n    # Create a new class\n    cls = type(iface_info.name, (InterfaceBase,), dict(_Interface.__dict__))\n    cls.__module__ = iface_info.namespace\n\n    # GType\n    cls.__gtype__ = PGType(iface_info.g_type)\n\n    # Properties\n    cls.props = PropertyAttribute(iface_info)\n\n    # Signals\n    cls.signals = SignalsAttribute(iface_info)\n\n    # Add constants\n    for constant in iface_info.get_constants():\n        constant_name = constant.name\n        attr = ConstantAttribute(constant)\n        setattr(cls, constant_name, attr)\n\n    # Add methods\n    for method_info in iface_info.get_methods():\n        add_method(method_info, cls)\n\n    # VFuncs\n    for vfunc_info in iface_info.get_vfuncs():\n        add_method(vfunc_info, cls, virtual=True)\n\n    cls._sigs = {}\n\n    is_info = iface_info.get_iface_struct()\n    if is_info:\n        iface_struct = import_attribute(is_info.namespace, is_info.name)\n    else:\n        iface_struct = None\n\n    def get_iface_struct(cls):\n        if not iface_struct:\n            return None\n\n        ptr = cls.__gtype__._type.default_interface_ref()\n        if not ptr:\n            return None\n        return iface_struct._from_pointer(addressof(ptr.contents))\n\n    setattr(cls, \"_get_iface_struct\", classmethod(get_iface_struct))\n\n    return cls", "response": "Creates a new GInterface class based on the given InterfaceInfo."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new_class_from_gtype(gtype):\n\n    if gtype.is_a(PGType.from_name(\"GObject\")):\n        parent = gtype.parent.pytype\n        if parent is None or parent == PGType.from_name(\"void\"):\n            return\n        interfaces = [i.pytype for i in gtype.interfaces]\n        bases = tuple([parent] + interfaces)\n\n        cls = type(gtype.name, bases, dict())\n        cls.__gtype__ = gtype\n\n        return cls\n    elif gtype.is_a(PGType.from_name(\"GEnum\")):\n        from pgi.enum import GEnumBase\n        return GEnumBase", "response": "Create a new class from a gtype."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new object class.", "response": "def ObjectAttribute(obj_info):\n    \"\"\"Creates a GObject class.\n\n    It inherits from the base class and all interfaces it implements.\n    \"\"\"\n\n    if obj_info.name == \"Object\" and obj_info.namespace == \"GObject\":\n        cls = Object\n    else:\n        # Get the parent class\n        parent_obj = obj_info.get_parent()\n        if parent_obj:\n            attr = import_attribute(parent_obj.namespace, parent_obj.name)\n            bases = (attr,)\n        else:\n            bases = (object,)\n\n        # Get all object interfaces\n        ifaces = []\n        for interface in obj_info.get_interfaces():\n            attr = import_attribute(interface.namespace, interface.name)\n            # only add interfaces if the base classes don't have it\n            for base in bases:\n                if attr in base.__mro__:\n                    break\n            else:\n                ifaces.append(attr)\n\n        # Combine them to a base class list\n        if ifaces:\n            bases = tuple(list(bases) + ifaces)\n\n        # Create a new class\n        cls = type(obj_info.name, bases, dict())\n\n    cls.__module__ = obj_info.namespace\n\n    # Set root to unowned= False and InitiallyUnowned=True\n    if obj_info.namespace == \"GObject\":\n        if obj_info.name == \"InitiallyUnowned\":\n            cls._unowned = True\n        elif obj_info.name == \"Object\":\n            cls._unowned = False\n\n    # GType\n    cls.__gtype__ = PGType(obj_info.g_type)\n\n    if not obj_info.fundamental:\n        # Constructor cache\n        cls._constructors = {}\n\n        # Properties\n        setattr(cls, PROPS_NAME, PropertyAttribute(obj_info))\n\n        # Signals\n        cls.signals = SignalsAttribute(obj_info)\n\n        # Signals\n        cls.__sigs__ = {}\n        for sig_info in obj_info.get_signals():\n            signal_name = sig_info.name\n            cls.__sigs__[signal_name] = sig_info\n\n    # Add constants\n    for constant in obj_info.get_constants():\n        constant_name = constant.name\n        attr = ConstantAttribute(constant)\n        setattr(cls, constant_name, attr)\n\n    # Fields\n    for field in obj_info.get_fields():\n        field_name = escape_identifier(field.name)\n        attr = FieldAttribute(field_name, field)\n        setattr(cls, field_name, attr)\n\n    # Add methods\n    for method_info in obj_info.get_methods():\n        # we implement most of the base object ourself\n        add_method(method_info, cls, dont_replace=cls is Object)\n\n    # VFuncs\n    for vfunc_info in obj_info.get_vfuncs():\n        add_method(vfunc_info, cls, virtual=True)\n\n    cs_info = obj_info.get_class_struct()\n    if cs_info:\n        class_struct = import_attribute(cs_info.namespace, cs_info.name)\n    else:\n        class_struct = None\n\n    # XXX ^ 2\n    def get_class_struct(cls, type_=None):\n        \"\"\"Returns the class struct casted to the passed type\"\"\"\n\n        if type_ is None:\n            type_ = class_struct\n\n        if type_ is None:\n            return None\n\n        ptr = cls.__gtype__._type.class_ref()\n        return type_._from_pointer(ptr)\n\n    setattr(cls, \"_get_class_struct\", classmethod(get_class_struct))\n\n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_constructor(cls, names):\n\n        cache = cls._constructors\n        if names in cache:\n            return cache[names]\n        elif len(cache) > 3:\n            cache.clear()\n\n        func = generate_constructor(cls, names)\n        cache[names] = func\n        return func", "response": "Generate a hopefully cache constructor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_property(self, name, value):\n\n        if not hasattr(self.props, name):\n            raise TypeError(\"Unknown property: %r\" % name)\n        setattr(self.props, name, value)", "response": "Set a property of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_property(self, name):\n\n        if not hasattr(self.props, name):\n            raise TypeError(\"Unknown property: %r\" % name)\n        return getattr(self.props, name)", "response": "Returns a property value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect(self, detailed_signal, handler, *args):\n\n        return self.__connect(0, detailed_signal, handler, *args)", "response": "Connect a signal to a specific class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect_after(self, detailed_signal, handler, *args):\n\n        flags = GConnectFlags.CONNECT_AFTER\n        return self.__connect(flags, detailed_signal, handler, *args)", "response": "Connect to the specified handler after the specified time period."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake the Python instance take ownership of the GIBaseInfo. i. e. the Python instance unref the GIBaseInfo. i. e. the Python instance gets gced.", "response": "def _take_ownership(self):\n        \"\"\"Make the Python instance take ownership of the GIBaseInfo. i.e.\n        unref if the python instance gets gc'ed.\n        \"\"\"\n\n        if self:\n            ptr = cast(self.value, GIBaseInfo)\n            _UnrefFinalizer.track(self, ptr)\n            self.__owns = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncast a GIBaseInfo instance to the right sub type.", "response": "def _cast(cls, base_info, take_ownership=True):\n        \"\"\"Casts a GIBaseInfo instance to the right sub type.\n\n        The original GIBaseInfo can't have ownership.\n        Will take ownership.\n        \"\"\"\n\n        type_value = base_info.type.value\n        try:\n            new_obj = cast(base_info, cls.__types[type_value])\n        except KeyError:\n            new_obj = base_info\n\n        if take_ownership:\n            assert not base_info.__owns\n            new_obj._take_ownership()\n\n        return new_obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_return(codec=\"ascii\"):\n\n    def outer(f):\n        def wrap(*args, **kwargs):\n            res = f(*args, **kwargs)\n            if res is not None:\n                return res.decode(codec)\n            return res\n        return wrap\n    return outer", "response": "Decodes the return value of it isn t None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a library name and calls find_library in case loading fails", "response": "def load_ctypes_library(name):\n    \"\"\"Takes a library name and calls find_library in case loading fails,\n    since some girs don't include the real .so name.\n\n    Raises OSError like LoadLibrary if loading fails.\n\n    e.g. javascriptcoregtk-3.0 should be libjavascriptcoregtk-3.0.so on unix\n    \"\"\"\n\n    try:\n        return cdll.LoadLibrary(name)\n    except OSError:\n        name = find_library(name)\n        if name is None:\n            raise\n        return cdll.LoadLibrary(name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nescape partial C identifiers so they can be used as attributes and arguments", "response": "def escape_identifier(text, reg=KWD_RE):\n    \"\"\"Escape partial C identifiers so they can be used as\n    attributes/arguments\"\"\"\n\n    # see http://docs.python.org/reference/lexical_analysis.html#identifiers\n    if not text:\n        return \"_\"\n    if text[0].isdigit():\n        text = \"_\" + text\n    return reg.sub(r\"\\1_\", text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncache the return value of a function without arguments", "response": "def cache_return(func):\n    \"\"\"Cache the return value of a function without arguments\"\"\"\n\n    _cache = []\n\n    def wrap():\n        if not _cache:\n            _cache.append(func())\n        return _cache[0]\n    return wrap"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a struct or a list of names for a given name.", "response": "def lookup_name_fast(self, name):\n        \"\"\"Might return a struct\"\"\"\n\n        if name in self.__names:\n            return self.__names[name]\n\n        count = self.__get_count_cached()\n        lo = 0\n        hi = count\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.__get_name_cached(mid) < name:\n                lo = mid + 1\n            else:\n                hi = mid\n\n        if lo != count and self.__get_name_cached(lo) == name:\n            return self.__get_info_cached(lo)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup_name_slow(self, name):\n\n        for index in xrange(self.__get_count_cached()):\n            if self.__get_name_cached(index) == name:\n                return self.__get_info_cached(index)", "response": "Returns a struct if one exists"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lookup_name(self, name):\n\n        try:\n            info = self._get_by_name(self._source, name)\n        except NotImplementedError:\n            pass\n        else:\n            if info:\n                return info\n            return\n\n        info = self.lookup_name_fast(name)\n        if info:\n            return info\n        return self.lookup_name_slow(name)", "response": "Returns a struct if one exists with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _new_type(cls, args):\n\n        fformat = [\"%r\" if f is None else \"%s=%%r\" % f for f in args]\n        fformat = \"(%s)\" % \", \".join(fformat)\n\n        class _ResultTuple(cls):\n            __slots__ = ()\n            _fformat = fformat\n            if args:\n                for i, a in enumerate(args):\n                    if a is not None:\n                        vars()[a] = property(itemgetter(i))\n                del i, a\n\n        return _ResultTuple", "response": "Creates a new class similar to namedtuple.\n\n        Pass a list of field names or None for no field name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef signal_list_names(type_):\n\n    ids = signal_list_ids(type_)\n    return tuple(GObjectModule.signal_name(i) for i in ids)", "response": "Returns a list of signal names for the given type\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nblocking the signal handler from being invoked until handler_unblock is called.", "response": "def signal_handler_block(obj, handler_id):\n    \"\"\"Blocks the signal handler from being invoked until\n    handler_unblock() is called.\n\n    :param GObject.Object obj:\n        Object instance to block handlers for.\n    :param int handler_id:\n        Id of signal to block.\n    :returns:\n        A context manager which optionally can be used to\n        automatically unblock the handler:\n\n    .. code-block:: python\n\n        with GObject.signal_handler_block(obj, id):\n            pass\n    \"\"\"\n    GObjectModule.signal_handler_block(obj, handler_id)\n    return _HandlerBlockManager(obj, handler_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef signal_parse_name(detailed_signal, itype, force_detail_quark):\n    res, signal_id, detail = GObjectModule.signal_parse_name(detailed_signal, itype,\n                                                             force_detail_quark)\n    if res:\n        return signal_id, detail\n    else:\n        raise ValueError('%s: unknown signal name: %s' % (itype, detailed_signal))", "response": "Parse a detailed signal name into a tuple of signal_id and detail."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding a library by name.", "response": "def find_library(name, cached=True, internal=True):\n    \"\"\"\n        cached: Return a new instance\n        internal: return a shared instance that's not the ctypes cached one\n    \"\"\"\n\n    # a new one\n    if not cached:\n        return cdll.LoadLibrary(_so_mapping[name])\n\n    # from the shared internal set or a new one\n    if internal:\n        if name not in _internal:\n            _internal[name] = cdll.LoadLibrary(_so_mapping[name])\n        return _internal[name]\n\n    # a shared one\n    return getattr(cdll, _so_mapping[name])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntracking an object which needs destruction when it is garbage collected.", "response": "def track(cls, obj, ptr):\n        \"\"\"\n        Track an object which needs destruction when it is garbage collected.\n        \"\"\"\n        cls._objects.add(cls(obj, ptr))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a D - BUS return variant into an appropriate return value", "response": "def _unpack_result(klass, result):\n        '''Convert a D-BUS return variant into an appropriate return value'''\n\n        result = result.unpack()\n\n        # to be compatible with standard Python behaviour, unbox\n        # single-element tuples and return None for empty result tuples\n        if len(result) == 1:\n            result = result[0]\n        elif len(result) == 0:\n            result = None\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_properties(type):\n\n    if isinstance(type, PGType):\n        type = type.pytype\n\n    from pgi.obj import Object, InterfaceBase\n\n    if not issubclass(type, (Object, InterfaceBase)):\n        raise TypeError(\"Must be a subclass of %s or %s\" %\n                        (Object.__name__, InterfaceBase.__name__))\n\n    gparams = []\n    for key in dir(type.props):\n        if not key.startswith(\"_\"):\n            gparams.append(getattr(type.props, key))\n    return gparams", "response": "Returns a list of GParamSpecs for all properties of a given type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_overrides(introspection_module):\n\n    namespace = introspection_module.__name__.rsplit(\".\", 1)[-1]\n    module_keys = [prefix + \".\" + namespace for prefix in const.PREFIX]\n\n    # We use sys.modules so overrides can import from gi.repository\n    # but restore everything at the end so this doesn't have any side effects\n    for module_key in module_keys:\n        has_old = module_key in sys.modules\n        old_module = sys.modules.get(module_key)\n\n    # Create a new sub type, so we can separate descriptors like\n    # _DeprecatedAttribute for each namespace.\n    proxy_type = type(namespace + \"ProxyModule\", (OverridesProxyModule, ), {})\n\n    proxy = proxy_type(introspection_module)\n    for module_key in module_keys:\n        sys.modules[module_key] = proxy\n\n    try:\n        override_package_name = 'pgi.overrides.' + namespace\n\n        # http://bugs.python.org/issue14710\n        try:\n            override_loader = get_loader(override_package_name)\n\n        except AttributeError:\n            override_loader = None\n\n        # Avoid checking for an ImportError, an override might\n        # depend on a missing module thus causing an ImportError\n        if override_loader is None:\n            return introspection_module\n\n        override_mod = importlib.import_module(override_package_name)\n\n    finally:\n        for module_key in module_keys:\n            del sys.modules[module_key]\n            if has_old:\n                sys.modules[module_key] = old_module\n\n    override_all = []\n    if hasattr(override_mod, \"__all__\"):\n        override_all = override_mod.__all__\n\n    for var in override_all:\n        try:\n            item = getattr(override_mod, var)\n        except (AttributeError, TypeError):\n            # Gedit puts a non-string in __all__, so catch TypeError here\n            continue\n        # make sure new classes have a proper __module__\n        try:\n            if item.__module__.split(\".\")[-1] == namespace:\n                item.__module__ = namespace\n        except AttributeError:\n            pass\n        setattr(proxy, var, item)\n\n    # Replace deprecated module level attributes with a descriptor\n    # which emits a warning when accessed.\n    for attr, replacement in _deprecated_attrs.pop(namespace, []):\n        try:\n            value = getattr(proxy, attr)\n        except AttributeError:\n            raise AssertionError(\n                \"%s was set deprecated but wasn't added to __all__\" % attr)\n        delattr(proxy, attr)\n        deprecated_attr = _DeprecatedAttribute(\n            namespace, attr, value, replacement)\n        setattr(proxy_type, attr, deprecated_attr)\n\n    return proxy", "response": "Loads the overrides for the given introspection module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a override class or function and assigns it dunder arguments form the overidden one.", "response": "def override(klass):\n    \"\"\"Takes a override class or function and assigns it dunder arguments\n    form the overidden one.\n    \"\"\"\n\n    namespace = klass.__module__.rsplit(\".\", 1)[-1]\n    mod_name = const.PREFIX[-1] + \".\" + namespace\n    module = sys.modules[mod_name]\n\n    if isinstance(klass, types.FunctionType):\n        def wrap(wrapped):\n            setattr(module, klass.__name__, wrapped)\n            return wrapped\n        return wrap\n\n    old_klass = klass.__mro__[1]\n    name = old_klass.__name__\n    klass.__name__ = name\n    klass.__module__ = old_klass.__module__\n\n    setattr(module, name, klass)\n\n    return klass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deprecated(function, instead):\n\n    # skip for classes, breaks doc generation\n    if not isinstance(function, types.FunctionType):\n        return function\n\n    @wraps(function)\n    def wrap(*args, **kwargs):\n        warnings.warn(\"Deprecated, use %s instead\" % instead,\n                      PyGIDeprecationWarning)\n        return function(*args, **kwargs)\n\n    return wrap", "response": "Mark a function deprecated so calling it issues a warning"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmarking a module level attribute as deprecated.", "response": "def deprecated_attr(namespace, attr, replacement):\n    \"\"\"Marks a module level attribute as deprecated. Accessing it will emit\n    a PyGIDeprecationWarning warning.\n\n    e.g. for ``deprecated_attr(\"GObject\", \"STATUS_FOO\", \"GLib.Status.FOO\")``\n    accessing GObject.STATUS_FOO will emit:\n\n        \"GObject.STATUS_FOO is deprecated; use GLib.Status.FOO instead\"\n\n    :param str namespace:\n        The namespace of the override this is called in.\n    :param str namespace:\n        The attribute name (which gets added to __all__).\n    :param str replacement:\n        The replacement text which will be included in the warning.\n    \"\"\"\n\n    _deprecated_attrs.setdefault(namespace, []).append((attr, replacement))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deprecated_init(super_init_func, arg_names, ignore=tuple(),\n                    deprecated_aliases={}, deprecated_defaults={},\n                    category=PyGIDeprecationWarning,\n                    stacklevel=2):\n    \"\"\"Wrapper for deprecating GObject based __init__ methods which specify\n    defaults already available or non-standard defaults.\n\n    :param callable super_init_func:\n        Initializer to wrap.\n    :param list arg_names:\n        Ordered argument name list.\n    :param list ignore:\n        List of argument names to ignore when calling the wrapped function.\n        This is useful for function which take a non-standard keyword that is munged elsewhere.\n    :param dict deprecated_aliases:\n        Dictionary mapping a keyword alias to the actual g_object_newv keyword.\n    :param dict deprecated_defaults:\n        Dictionary of non-standard defaults that will be used when the\n        keyword is not explicitly passed.\n    :param Exception category:\n        Exception category of the error.\n    :param int stacklevel:\n        Stack level for the deprecation passed on to warnings.warn\n    :returns: Wrapped version of ``super_init_func`` which gives a deprecation\n        warning when non-keyword args or aliases are used.\n    :rtype: callable\n    \"\"\"\n    # We use a list of argument names to maintain order of the arguments\n    # being deprecated. This allows calls with positional arguments to\n    # continue working but with a deprecation message.\n    def new_init(self, *args, **kwargs):\n        \"\"\"Initializer for a GObject based classes with support for property\n        sets through the use of explicit keyword arguments.\n        \"\"\"\n        # Print warnings for calls with positional arguments.\n        if args:\n            warnings.warn('Using positional arguments with the GObject constructor has been deprecated. '\n                          'Please specify keyword(s) for \"%s\" or use a class specific constructor. '\n                          'See: https://wiki.gnome.org/PyGObject/InitializerDeprecations' %\n                          ', '.join(arg_names[:len(args)]),\n                          category, stacklevel=stacklevel)\n            new_kwargs = dict(zip(arg_names, args))\n        else:\n            new_kwargs = {}\n        new_kwargs.update(kwargs)\n\n        # Print warnings for alias usage and transfer them into the new key.\n        aliases_used = []\n        for key, alias in deprecated_aliases.items():\n            if alias in new_kwargs:\n                new_kwargs[key] = new_kwargs.pop(alias)\n                aliases_used.append(key)\n\n        if aliases_used:\n            warnings.warn('The keyword(s) \"%s\" have been deprecated in favor of \"%s\" respectively. '\n                          'See: https://wiki.gnome.org/PyGObject/InitializerDeprecations' %\n                          (', '.join(deprecated_aliases[k] for k in sorted(aliases_used)),\n                           ', '.join(sorted(aliases_used))),\n                          category, stacklevel=stacklevel)\n\n        # Print warnings for defaults different than what is already provided by the property\n        defaults_used = []\n        for key, value in deprecated_defaults.items():\n            if key not in new_kwargs:\n                new_kwargs[key] = deprecated_defaults[key]\n                defaults_used.append(key)\n\n        if defaults_used:\n            warnings.warn('Initializer is relying on deprecated non-standard '\n                          'defaults. Please update to explicitly use: %s '\n                          'See: https://wiki.gnome.org/PyGObject/InitializerDeprecations' %\n                          ', '.join('%s=%s' % (k, deprecated_defaults[k]) for k in sorted(defaults_used)),\n                          category, stacklevel=stacklevel)\n\n        # Remove keywords that should be ignored.\n        for key in ignore:\n            if key in new_kwargs:\n                new_kwargs.pop(key)\n\n        return super_init_func(self, **new_kwargs)\n\n    return new_init", "response": "Wrapper for deprecating GObject based __init__ methods which specify deprecated defaults already available or non - standard defaults."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_boolean_result(method, exc_type=None, exc_str=None, fail_ret=None):\n    @wraps(method)\n    def wrapped(*args, **kwargs):\n        ret = method(*args, **kwargs)\n        if ret[0]:\n            if len(ret) == 2:\n                return ret[1]\n            else:\n                return ret[1:]\n        else:\n            if exc_type:\n                raise exc_type(exc_str or 'call failed')\n            return fail_ret\n    return wrapped", "response": "Translate method s return value for stripping off success flag."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the module with the given namespace.", "response": "def get_introspection_module(namespace):\n    \"\"\"Raises ImportError\"\"\"\n\n    if namespace in _introspection_modules:\n        return _introspection_modules[namespace]\n\n    from . import get_required_version\n\n    repository = GIRepository()\n    version = get_required_version(namespace)\n\n    try:\n        repository.require(namespace, version, 0)\n    except GIError as e:\n        raise ImportError(e.message)\n\n    # No strictly needed here, but most things will fail during use\n    library = repository.get_shared_library(namespace)\n    if library:\n        library = library.split(\",\")[0]\n        try:\n            util.load_ctypes_library(library)\n        except OSError:\n            raise ImportError(\n                \"Couldn't load shared library %r\" % library)\n\n    # Generate bindings, set up lazy attributes\n    instance = Module(repository, namespace)\n    instance.__path__ = repository.get_typelib_path(namespace)\n    instance.__package__ = const.PREFIX[0]\n    instance.__file__ = \"<%s.%s>\" % (const.PREFIX[0], namespace)\n    instance._version = version or repository.get_version(namespace)\n\n    _introspection_modules[namespace] = instance\n\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_param_type(self, index):\n\n        assert index in (0, 1)\n\n        type_info = self.type.get_param_type(index)\n        type_cls = get_return_class(type_info)\n        instance = type_cls(None, type_info, [], self.backend)\n        instance.setup()\n        return instance", "response": "Returns a ReturnValue instance for the param type index"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a piece of text and substitude by either unique variable names or by kwargs mapping. Use var_factory to escape the variables.", "response": "def parse_code(code, var_factory, **kwargs):\n    \"\"\"Parse a piece of text and substitude $var by either unique\n    variable names or by the given kwargs mapping. Use $$ to escape $.\n\n    Returns a CodeBlock and the resulting variable mapping.\n\n    parse(\"$foo = $foo + $bar\", bar=\"1\")\n    (\"t1 = t1 + 1\", {'foo': 't1', 'bar': '1'})\n    \"\"\"\n\n    block = CodeBlock()\n    defdict = collections.defaultdict(var_factory)\n    defdict.update(kwargs)\n\n    indent = -1\n    code = code.strip()\n    for line in code.splitlines():\n        length = len(line)\n        line = line.lstrip()\n        spaces = length - len(line)\n        if spaces:\n            if indent < 0:\n                indent = spaces\n                level = 1\n            else:\n                level = spaces // indent\n        else:\n            level = 0\n\n        # if there is a single variable and the to be inserted object\n        # is a code block, insert the block with the current indentation level\n        if line.startswith(\"$\") and line.count(\"$\") == 1:\n            name = line[1:]\n            if name in kwargs and isinstance(kwargs[name], CodeBlock):\n                kwargs[name].write_into(block, level)\n                continue\n\n        block.write_line(string.Template(line).substitute(defdict), level)\n    return block, dict(defdict)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_with_objects(code, var, **kwargs):\n\n    deps = {}\n    for key, value in kwargs.items():\n        if isinstance(value, _compat.integer_types):\n            value = str(value)\n\n        if _compat.PY3:\n            if value is None:\n                value = str(value)\n\n        if not isinstance(value, _compat.string_types) and \\\n                not isinstance(value, CodeBlock):\n            new_var = var(value)\n            deps[new_var] = value\n            kwargs[key] = new_var\n\n    block, var = parse_code(code, var, **kwargs)\n    for key, dep in _compat.iteritems(deps):\n        block.add_dependency(key, dep)\n\n    return block, var", "response": "Parse a code block and include non string or codeblock kwargs as well as non - CodeBlock dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_name(self, name):\n\n        while name in self._blacklist:\n            name += \"_\"\n        self._blacklist.add(name)\n        return name", "response": "Request a name from the blacklist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a code dependency so it gets inserted into globals", "response": "def add_dependency(self, name, obj):\n        \"\"\"Add a code dependency so it gets inserted into globals\"\"\"\n\n        if name in self._deps:\n            if self._deps[name] is obj:\n                return\n            raise ValueError(\n                \"There exists a different dep with the same name : %r\" % name)\n        self._deps[name] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_into(self, block, level=0):\n\n        for line, l in self._lines:\n            block.write_line(line, level + l)\n\n        for name, obj in _compat.iteritems(self._deps):\n            block.add_dependency(name, obj)", "response": "Append this block to another one passing all dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending multiple new lines to the log.", "response": "def write_lines(self, lines, level=0):\n        \"\"\"Append multiple new lines\"\"\"\n\n        for line in lines:\n            self.write_line(line, level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile(self, **kwargs):\n\n        code = compile(str(self), \"<string>\", \"exec\")\n        global_dict = dict(self._deps)\n        global_dict.update(kwargs)\n        _compat.exec_(code, global_dict)\n        return global_dict", "response": "Execute the python code and returns the global dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pprint(self, file_=sys.stdout):\n\n        code = []\n        if self._deps:\n            code.append(\"# dependencies:\")\n        for k, v in _compat.iteritems(self._deps):\n            code.append(\"#   %s: %r\" % (k, v))\n        code.append(str(self))\n        code = \"\\n\".join(code)\n\n        if file_.isatty():\n            try:\n                from pygments import highlight\n                from pygments.lexers import PythonLexer\n                from pygments.formatters import TerminalFormatter\n            except ImportError:\n                pass\n            else:\n                formatter = TerminalFormatter(bg=\"dark\")\n                lexer = PythonLexer()\n                file_.write(highlight(code, lexer, formatter))\n                return\n        file_.write(code + \"\\n\")", "response": "Print the code block to stdout. Does syntax highlighting if possible."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclasses decorator. Registers a new class with the given namespace and name.", "response": "def register(cls, namespace, name):\n        \"\"\"Class decorator\"\"\"\n\n        def func(kind):\n            cls._FOREIGN[(namespace, name)] = kind()\n            return kind\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_type_name(type_):\n\n    if type_ is None:\n        return \"\"\n    if isinstance(type_, string_types):\n        return type_\n    elif isinstance(type_, list):\n        assert len(type_) == 1\n        return \"[%s]\" % get_type_name(type_[0])\n    elif isinstance(type_, dict):\n        assert len(type_) == 1\n        key, value = list(type_.items())[0]\n        return \"{%s: %s}\" % (get_type_name(key), get_type_name(value))\n    elif type_.__module__ in (\"__builtin__\", \"builtins\"):\n        return type_.__name__\n    else:\n        return \"%s.%s\" % (type_.__module__, type_.__name__)", "response": "Gives a name for a type that can be suitable for a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a docstring for the given function.", "response": "def build_docstring(func_name, args, ret, throws, signal_owner_type=None):\n    \"\"\"Create a docstring in the form:\n        name(in_name: type) -> (ret_type, out_name: type)\n    \"\"\"\n\n    out_args = []\n    if ret and not ret.ignore:\n        if ret.py_type is None:\n            out_args.append(\"unknown\")\n        else:\n            tname = get_type_name(ret.py_type)\n            if ret.may_return_null:\n                tname += \" or None\"\n            out_args.append(tname)\n\n    in_args = []\n\n    if signal_owner_type is not None:\n        name = get_signal_owner_var_name(signal_owner_type)\n        in_args.append(\"%s: %s\" % (\n            name, get_type_name(signal_owner_type.pytype)))\n\n    for arg in args:\n        if arg.is_aux:\n            continue\n\n        if arg.is_direction_in():\n            if arg.py_type is None:\n                in_args.append(arg.in_var)\n            else:\n                tname = get_type_name(arg.py_type)\n                if arg.may_be_null:\n                    tname += \" or None\"\n                in_args.append(\"%s: %s\" % (arg.in_var, tname))\n\n        if arg.is_direction_out():\n            if arg.py_type is None:\n                out_args.append(arg.name)\n            else:\n                tname = get_type_name(arg.py_type)\n                # if may_be_null means the arg is nullable, it is nullable\n                # and the marshalling returns None for a NULL pointer\n                if may_be_null_is_nullable() and arg.may_be_null and \\\n                        arg.can_unpack_none:\n                    tname += \" or None\"\n                # When can we assume that out args return None?\n                out_args.append(\"%s: %s\" % (arg.name, tname))\n\n    in_def = \", \".join(in_args)\n\n    if not out_args:\n        out_def = \"None\"\n    elif len(out_args) == 1:\n        out_def = out_args[0]\n    else:\n        out_def = \"(%s)\" % \", \".join(out_args)\n\n    error = \"\"\n    if throws:\n        error = \"raises \"\n\n    return \"%s(%s) %s-> %s\" % (func_name, in_def, error, out_def)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a Python callable for a GIFunctionInfo instance", "response": "def generate_function(info, method=False):\n    \"\"\"Creates a Python callable for a GIFunctionInfo instance\"\"\"\n\n    assert isinstance(info, GIFunctionInfo)\n\n    arg_infos = list(info.get_args())\n    arg_types = [a.get_type() for a in arg_infos]\n    return_type = info.get_return_type()\n\n    func = None\n    messages = []\n    for backend in list_backends():\n        instance = backend()\n        try:\n            func = _generate_function(instance, info, arg_infos, arg_types,\n                                      return_type, method)\n        except NotImplementedError:\n            messages.append(\"%s: %s\" % (backend.NAME, traceback.format_exc()))\n        else:\n            break\n\n    if func:\n        return func\n\n    raise NotImplementedError(\"\\n\".join(messages))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_dummy_callable(info, func_name, method=False,\n                            signal_owner_type=None):\n    \"\"\"Takes a GICallableInfo and generates a dummy callback function which\n    just raises but has a correct docstring. They are mainly accessible for\n    documentation, so the API reference can reference a real thing.\n\n    func_name can be different than info.name because vfuncs, for example,\n    get prefixed with 'do_' when exposed in Python.\n    \"\"\"\n\n    assert isinstance(info, GICallableInfo)\n\n    # FIXME: handle out args and trailing user_data ?\n\n    arg_infos = list(info.get_args())\n    arg_types = [a.get_type() for a in arg_infos]\n    return_type = info.get_return_type()\n\n    # the null backend is good enough here\n    backend = get_backend(\"null\")()\n\n    args = []\n    for arg_info, arg_type in zip(arg_infos, arg_types):\n        cls = get_argument_class(arg_type)\n        name = escape_identifier(arg_info.name)\n        name = escape_parameter(name)\n        args.append(cls(name, args, backend, arg_info, arg_type))\n\n    cls = get_return_class(return_type)\n    return_value = cls(info, return_type, args, backend)\n\n    for arg in args:\n        arg.setup()\n\n    return_value.setup()\n\n    in_args = [a for a in args if not a.is_aux and a.in_var]\n\n    # if the last in argument is a closure, make it a var-positional argument\n    if in_args and in_args[-1].closure != -1:\n        name = in_args[-1].in_var\n        in_args[-1].in_var = \"*\" + name\n\n    func_name = escape_identifier(func_name)\n    docstring = build_docstring(func_name, args, return_value,\n                                False, signal_owner_type)\n\n    in_names = [a.in_var for a in in_args]\n\n    var_fac = backend.var\n    var_fac.add_blacklist(in_names)\n    self_name = \"\"\n    if method:\n        self_name = var_fac.request_name(\"self\")\n        in_names.insert(0, self_name)\n\n    main, var = backend.parse(\"\"\"\ndef $func_name($func_args):\n    '''$docstring'''\n\n    raise NotImplementedError(\"This is just a dummy callback function\")\n\"\"\", func_args=\", \".join(in_names), docstring=docstring, func_name=func_name)\n\n    func = main.compile()[func_name]\n    func._code = main\n    func.__doc__ = docstring\n    func.__module__ = info.namespace\n\n    return func", "response": "Takes a GICallableInfo and generates a dummy callback function which just raises but has a correct docstring."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_enum_class(ffi, type_name, prefix, flags=False):\n\n    class _template(int):\n        _map = {}\n\n        @property\n        def value(self):\n            return int(self)\n\n        def __str__(self):\n            return self._map.get(self, \"Unknown\")\n\n        def __repr__(self):\n            return \"%s.%s\" % (type(self).__name__, str(self))\n\n    class _template_flags(int):\n        _map = {}\n\n        @property\n        def value(self):\n            return int(self)\n\n        def __str__(self):\n            names = []\n            val = int(self)\n            for flag, name in self._map.items():\n                if val & flag:\n                    names.append(name)\n                    val &= ~flag\n            if val:\n                names.append(str(val))\n            return \" | \".join(sorted(names or [\"Unknown\"]))\n\n        def __repr__(self):\n            return \"%s(%s)\" % (type(self).__name__, str(self))\n\n    if flags:\n        template = _template_flags\n    else:\n        template = _template\n\n    cls = type(type_name, template.__bases__, dict(template.__dict__))\n    prefix_len = len(prefix)\n    for value, name in ffi.typeof(type_name).elements.items():\n        assert name[:prefix_len] == prefix\n        name = name[prefix_len:]\n        setattr(cls, name, cls(value))\n        cls._map[value] = name\n\n    return cls", "response": "Creates a new shiny class for the given enum type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting some common enum expressions to constants", "response": "def _fixup_cdef_enums(string, reg=re.compile(r\"=\\s*(\\d+)\\s*<<\\s*(\\d+)\")):\n    \"\"\"Converts some common enum expressions to constants\"\"\"\n\n    def repl_shift(match):\n        shift_by = int(match.group(2))\n        value = int(match.group(1))\n        int_value = ctypes.c_int(value << shift_by).value\n        return \"= %s\" % str(int_value)\n    return reg.sub(repl_shift, string)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a glist copies the values casted to type_ in to a list and frees all items and the list.", "response": "def unpack_glist(g, type_, transfer_full=True):\n    \"\"\"Takes a glist, copies the values casted to type_ in to a list\n    and frees all items and the list.\n    \"\"\"\n\n    values = []\n    item = g\n    while item:\n        ptr = item.contents.data\n        value = cast(ptr, type_).value\n        values.append(value)\n        if transfer_full:\n            free(ptr)\n        item = item.next()\n    if transfer_full:\n        g.free()\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack_nullterm_array(array):\n\n    addrs = cast(array, POINTER(ctypes.c_void_p))\n    l = []\n    i = 0\n    value = array[i]\n    while value:\n        l.append(value)\n        free(addrs[i])\n        i += 1\n        value = array[i]\n    free(addrs)\n    return l", "response": "Takes a null terminated array copies the values into a list\n    and frees each value and the list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting a version for the namespace to be loaded.", "response": "def require_version(namespace, version):\n    \"\"\"Set a version for the namespace to be loaded.\n    This needs to be called before importing the namespace or any\n    namespace that depends on it.\n    \"\"\"\n\n    global _versions\n\n    repo = GIRepository()\n    namespaces = repo.get_loaded_namespaces()\n\n    if namespace in namespaces:\n        loaded_version = repo.get_version(namespace)\n        if loaded_version != version:\n            raise ValueError('Namespace %s is already loaded with version %s' %\n                             (namespace, loaded_version))\n\n    if namespace in _versions and _versions[namespace] != version:\n        raise ValueError('Namespace %s already requires version %s' %\n                         (namespace, _versions[namespace]))\n\n    available_versions = repo.enumerate_versions(namespace)\n    if not available_versions:\n        raise ValueError('Namespace %s not available' % namespace)\n\n    if version not in available_versions:\n        raise ValueError('Namespace %s not available for version %s' %\n                         (namespace, version))\n\n    _versions[namespace] = version"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_require_version(namespace, stacklevel):\n\n    repository = GIRepository()\n    was_loaded = repository.is_registered(namespace)\n\n    yield\n\n    if was_loaded:\n        # it was loaded before by another import which depended on this\n        # namespace or by C code like libpeas\n        return\n\n    if namespace in (\"GLib\", \"GObject\", \"Gio\"):\n        # part of glib (we have bigger problems if versions change there)\n        return\n\n    if get_required_version(namespace) is not None:\n        # the version was forced using require_version()\n        return\n\n    version = repository.get_version(namespace)\n    warnings.warn(\n        \"%(namespace)s was imported without specifying a version first. \"\n        \"Use gi.require_version('%(namespace)s', '%(version)s') before \"\n        \"import to ensure that the right version gets loaded.\"\n        % {\"namespace\": namespace, \"version\": version},\n        PyGIWarning, stacklevel=stacklevel)", "response": "A context manager which tries to give helpful warnings\n    about missing gi. require_version which could potentially be used to ensure that the right version gets loaded."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_import_stacklevel(import_hook):\n\n    py_version = sys.version_info[:2]\n    if py_version <= (3, 2):\n        # 2.7 included\n        return 4 if import_hook else 2\n    elif py_version == (3, 3):\n        return 8 if import_hook else 10\n    elif py_version == (3, 4):\n        return 10 if import_hook else 8\n    else:\n        # fixed again in 3.5+, see https://bugs.python.org/issue24305\n        return 4 if import_hook else 2", "response": "Returns the stacklevel value for warnings. warn for when the warning gets emitted by an imported module but the warning should point at the code doing the import."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a glist ptr copies the values casted to type_ in to a list and frees all items and the list.", "response": "def unpack_glist(glist_ptr, cffi_type, transfer_full=True):\n    \"\"\"Takes a glist ptr, copies the values casted to type_ in to a list\n    and frees all items and the list.\n\n    If an item is returned all yielded before are invalid.\n    \"\"\"\n\n    current = glist_ptr\n    while current:\n        yield ffi.cast(cffi_type, current.data)\n        if transfer_full:\n            free(current.data)\n        current = current.next\n    if transfer_full:\n        lib.g_list_free(glist_ptr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a zero terminated array to a list and frees each element and the list itself.", "response": "def unpack_zeroterm_array(ptr):\n    \"\"\"Converts a zero terminated array to a list and frees each element\n    and the list itself.\n\n    If an item is returned all yielded before are invalid.\n    \"\"\"\n\n    assert ptr\n\n    index = 0\n    current = ptr[index]\n    while current:\n        yield current\n        free(ffi.cast(\"gpointer\", current))\n        index += 1\n        current = ptr[index]\n    free(ffi.cast(\"gpointer\", ptr))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new struct class.", "response": "def StructureAttribute(struct_info):\n    \"\"\"Creates a new struct class.\"\"\"\n\n    # Copy the template and add the gtype\n    cls_dict = dict(_Structure.__dict__)\n    cls = type(struct_info.name, _Structure.__bases__, cls_dict)\n    cls.__module__ = struct_info.namespace\n    cls.__gtype__ = PGType(struct_info.g_type)\n    cls._size = struct_info.size\n    cls._is_gtype_struct = struct_info.is_gtype_struct\n\n    # Add methods\n    for method_info in struct_info.get_methods():\n        add_method(method_info, cls)\n\n    # Add fields\n    for field_info in struct_info.get_fields():\n        field_name = escape_identifier(field_info.name)\n        attr = FieldAttribute(field_name, field_info)\n        setattr(cls, field_name, attr)\n\n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a GError exception and takes ownership if own is True", "response": "def _from_gerror(cls, error, own=True):\n        \"\"\"Creates a GError exception and takes ownership if own is True\"\"\"\n\n        if not own:\n            error = error.copy()\n\n        self = cls()\n        self._error = error\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_version(version):\n\n    if isinstance(version, string_types):\n        version = tuple(map(int, version.split(\".\")))\n\n    if version > version_info:\n        str_version = \".\".join(map(str, version))\n        raise ValueError(\"pgi version '%s' requested, '%s' available\" %\n                         (str_version, __version__))", "response": "Checks that the passed version is newer than the current version of pgi."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninstalling the gi module as the current one.", "response": "def install_as_gi():\n    \"\"\"Call before the first gi import to redirect gi imports to pgi\"\"\"\n\n    import sys\n\n    # check if gi has already been replaces\n    if \"gi.repository\" in const.PREFIX:\n        return\n\n    # make sure gi isn't loaded first\n    for mod in iterkeys(sys.modules):\n        if mod == \"gi\" or mod.startswith(\"gi.\"):\n            raise AssertionError(\"pgi has to be imported before gi\")\n\n    # replace and tell the import hook\n    import pgi\n    import pgi.repository\n    sys.modules[\"gi\"] = pgi\n    sys.modules[\"gi.repository\"] = pgi.repository\n    const.PREFIX.append(\"gi.repository\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding specified panel class to model class.", "response": "def add_panel_to_edit_handler(model, panel_cls, heading, index=None):\n    \"\"\"\n    Adds specified panel class to model class.\n\n    :param model: the model class.\n    :param panel_cls: the panel class.\n    :param heading: the panel heading.\n    :param index: the index position to insert at.\n    \"\"\"\n    from wagtail.wagtailadmin.views.pages import get_page_edit_handler\n\n    edit_handler    = get_page_edit_handler(model)\n    panel_instance  = ObjectList(\n        [panel_cls(),],\n        heading = heading\n    ).bind_to_model(model)\n\n    if index:\n        edit_handler.children.insert(index, panel_instance)\n    else:\n        edit_handler.children.append(panel_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_context_data(self, **kwargs):\n        #noinspection PyUnresolvedReferences\n        query_str           = self.request.GET.get('q', None)\n        queryset            = kwargs.pop('object_list', self.object_list)\n        context_object_name = self.get_context_object_name(queryset)\n\n        # Build the context dictionary.\n        context = {\n            'ordering':     self.get_ordering(),\n            'query_string': query_str,\n            'is_searching': bool(query_str),\n        }\n\n        # Add extra variables to context for non-AJAX requests.\n        #noinspection PyUnresolvedReferences\n        if not self.request.is_ajax() or kwargs.get('force_search', False):\n            context.update({\n                'search_form':  self.get_search_form(),\n                'popular_tags': self.model.popular_tags()\n            })\n\n        if context_object_name is not None:\n            context[context_object_name] = queryset\n\n        # Update context with any additional keyword arguments.\n        context.update(kwargs)\n\n        return super(IndexView, self).get_context_data(**context)", "response": "Returns the context dictionary for view."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ordering(self):\n        #noinspection PyUnresolvedReferences\n        ordering = self.request.GET.get('ordering', None)\n\n        if ordering not in ['title', '-created_at']:\n            ordering = '-created_at'\n\n        return ordering", "response": "Returns ordering value for list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn queryset instance. :rtype: django.db.models.query.QuerySet.", "response": "def get_queryset(self):\n        \"\"\"\n        Returns queryset instance.\n\n        :rtype: django.db.models.query.QuerySet.\n        \"\"\"\n        queryset    = super(IndexView, self).get_queryset()\n        search_form = self.get_search_form()\n\n        if search_form.is_valid():\n            query_str   = search_form.cleaned_data.get('q', '').strip()\n            queryset    = self.model.objects.search(query_str)\n\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the search form instance.", "response": "def get_search_form(self):\n        \"\"\"\n        Returns search form instance.\n\n        :rtype: django.forms.ModelForm.\n        \"\"\"\n        #noinspection PyUnresolvedReferences\n        if 'q' in self.request.GET:\n            #noinspection PyUnresolvedReferences\n            return self.search_form_class(self.request.GET)\n        else:\n            return self.search_form_class(placeholder=_(u'Search'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of template names for the view.", "response": "def get_template_names(self):\n        \"\"\"\n        Returns a list of template names for the view.\n\n        :rtype: list.\n        \"\"\"\n        #noinspection PyUnresolvedReferences\n        if self.request.is_ajax():\n            template_name = '/results.html'\n        else:\n            template_name = '/index.html'\n\n        return ['{0}{1}'.format(self.template_dir, template_name)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paginate_queryset(self, queryset, page_size):\n        paginator = self.get_paginator(\n            queryset,\n            page_size,\n            orphans                 = self.get_paginate_orphans(),\n            allow_empty_first_page  = self.get_allow_empty()\n        )\n\n        page_kwarg  = self.page_kwarg\n        #noinspection PyUnresolvedReferences\n        page_num    = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1\n\n        # Default to a valid page.\n        try:\n            page = paginator.page(page_num)\n        except PageNotAnInteger:\n            page = paginator.page(1)\n        except EmptyPage:\n            page = paginator.page(paginator.num_pages)\n\n        #noinspection PyRedundantParentheses\n        return (paginator, page, page.object_list, page.has_other_pages())", "response": "Returns a tuple containing paginator instance page instance object list and whether there are other pages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing an invalid form submittal.", "response": "def form_invalid(self, form):\n        \"\"\"\n        Processes an invalid form submittal.\n\n        :param form: the form instance.\n        :rtype: django.http.HttpResponse.\n        \"\"\"\n        meta = getattr(self.model, '_meta')\n\n        #noinspection PyUnresolvedReferences\n        messages.error(\n            self.request,\n            _(u'The {0} could not be saved due to errors.').format(\n                meta.verbose_name.lower()\n            )\n        )\n\n        return super(BaseEditView, self).form_invalid(form)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef form_valid(self, form):\n        #noinspection PyAttributeOutsideInit\n        self.object = form.save()\n        meta        = getattr(self.object, '_meta')\n\n        # Index the object.\n        for backend in get_search_backends():\n            backend.add(object)\n\n        #noinspection PyUnresolvedReferences\n        messages.success(\n            self.request,\n            _(u'{0} \"{1}\" saved.').format(\n                meta.verbose_name,\n                str(self.object)\n            ),\n            buttons=[messages.button(\n                reverse(\n                    '{0}:edit'.format(self.url_namespace),\n                    args=(self.object.id,)\n                ),\n                _(u'Edit')\n            )]\n        )\n\n        return redirect(self.get_success_url())", "response": "Processes a valid form submittal."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns redirect URL for valid form submittal.", "response": "def get_success_url(self):\n        \"\"\"\n        Returns redirect URL for valid form submittal.\n\n        :rtype: str.\n        \"\"\"\n        if self.success_url:\n            url = force_text(self.success_url)\n        else:\n            url = reverse('{0}:index'.format(self.url_namespace))\n\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the deletion of the specified object.", "response": "def delete(self, request, *args, **kwargs):\n        \"\"\"\n        Processes deletion of the specified instance.\n\n        :param request: the request instance.\n        :rtype: django.http.HttpResponse.\n        \"\"\"\n        #noinspection PyAttributeOutsideInit\n        self.object = self.get_object()\n        success_url = self.get_success_url()\n        meta        = getattr(self.object, '_meta')\n\n        self.object.delete()\n\n        messages.success(\n            request,\n            _(u'{0} \"{1}\" deleted.').format(\n                meta.verbose_name.lower(),\n                str(self.object)\n            )\n        )\n\n        return redirect(success_url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chunked(iterable, n):\n\n    \"\"\"Returns chunks of n length of iterable\n\n    If len(iterable) % n != 0, then the last chunk will have length\n    less than n.\n\n    Example:\n\n    >>> chunked([1, 2, 3, 4, 5], 2)\n    [(1, 2), (3, 4), (5,)]\n\n    \"\"\"\n    iterable = iter(iterable)\n    while 1:\n        t = tuple(islice(iterable, n))\n        if t:\n            yield t\n        else:\n            return", "response": "Returns n chunks of iterable"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format_explanation(explanation, indent='  ', indent_level=0):\n    if not explanation:\n        return ''\n\n    # Note: This is probably a crap implementation, but it's an\n    # interesting starting point for a better formatter.\n    line = ('%s%s %2.4f' % ((indent * indent_level),\n                            explanation['description'],\n                            explanation['value']))\n\n    if 'details' in explanation:\n        details = '\\n'.join(\n            [format_explanation(subtree, indent, indent_level + 1)\n             for subtree in explanation['details']])\n        return line + '\\n' + details\n\n    return line", "response": "Return explanation in an easier to read format a single resource list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an elasticsearch object using settings. py", "response": "def get_es(**overrides):\n    \"\"\"Return a elasticsearch Elasticsearch object using settings\n    from ``settings.py``.\n\n    :arg overrides: Allows you to override defaults to create the\n        ElasticSearch object. You can override any of the arguments\n        isted in :py:func:`elasticutils.get_es`.\n\n    For example, if you wanted to create an ElasticSearch with a\n    longer timeout to a different cluster, you'd do:\n\n    >>> from elasticutils.contrib.django import get_es\n    >>> es = get_es(urls=['http://some_other_cluster:9200'], timeout=30)\n\n    \"\"\"\n    defaults = {\n        'urls': settings.ES_URLS,\n        'timeout': getattr(settings, 'ES_TIMEOUT', 5)\n        }\n\n    defaults.update(overrides)\n    return base_get_es(**defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps a callable and return None if ES_DISABLED is False.", "response": "def es_required(fun):\n    \"\"\"Wrap a callable and return None if ES_DISABLED is False.\n\n    This also adds an additional `es` argument to the callable\n    giving you an ElasticSearch instance to use.\n\n    \"\"\"\n    @wraps(fun)\n    def wrapper(*args, **kw):\n        if getattr(settings, 'ES_DISABLED', False):\n            log.debug('Search disabled for %s.' % fun)\n            return\n\n        return fun(*args, es=get_es(), **kw)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_es(self, default_builder=get_es):\n        return super(S, self).get_es(default_builder=default_builder)", "response": "Returns the elasticsearch object to use."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_indexes(self, default_indexes=None):\n        doctype = self.type.get_mapping_type_name()\n        indexes = (settings.ES_INDEXES.get(doctype) or\n                   settings.ES_INDEXES['default'])\n        if isinstance(indexes, six.string_types):\n            indexes = [indexes]\n        return super(S, self).get_indexes(default_indexes=indexes)", "response": "Returns the list of indexes to act on based on ES_INDEXES setting"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_doctypes(self, default_doctypes=None):\n        doctypes = self.type.get_mapping_type_name()\n        if isinstance(doctypes, six.string_types):\n            doctypes = [doctypes]\n        return super(S, self).get_doctypes(default_doctypes=doctypes)", "response": "Returns the doctypes to use for this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the index for this model.", "response": "def get_index(cls):\n        \"\"\"Gets the index for this model.\n\n        The index for this model is specified in `settings.ES_INDEXES`\n        which is a dict of mapping type -> index name.\n\n        By default, this uses `.get_mapping_type()` to determine the\n        mapping and returns the value in `settings.ES_INDEXES` for that\n        or ``settings.ES_INDEXES['default']``.\n\n        Override this to compute it differently.\n\n        :returns: index name to use\n\n        \"\"\"\n        indexes = settings.ES_INDEXES\n        index = indexes.get(cls.get_mapping_type_name()) or indexes['default']\n        if not (isinstance(index, six.string_types)):\n            # FIXME - not sure what to do here, but we only want one\n            # index and somehow this isn't one index.\n            index = index[0]\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the queryset of all things to be indexed.", "response": "def get_indexable(cls):\n        \"\"\"Returns the queryset of ids of all things to be indexed.\n\n        Defaults to::\n\n            cls.get_model().objects.order_by('id').values_list(\n                'id', flat=True)\n\n        :returns: iterable of ids of objects to be indexed\n\n        \"\"\"\n        model = cls.get_model()\n        return model.objects.order_by('id').values_list('id', flat=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an elasticsearch object and return it.", "response": "def get_es(urls=None, timeout=DEFAULT_TIMEOUT, force_new=False, **settings):\n    \"\"\"Create an elasticsearch `Elasticsearch` object and return it.\n\n    This will aggressively re-use `Elasticsearch` objects with the\n    following rules:\n\n    1. if you pass the same argument values to `get_es()`, then it\n       will return the same `Elasticsearch` object\n    2. if you pass different argument values to `get_es()`, then it\n       will return different `Elasticsearch` object\n    3. it caches each `Elasticsearch` object that gets created\n    4. if you pass in `force_new=True`, then you are guaranteed to get\n       a fresh `Elasticsearch` object AND that object will not be\n       cached\n\n    :arg urls: list of uris; Elasticsearch hosts to connect to,\n        defaults to ``['http://localhost:9200']``\n    :arg timeout: int; the timeout in seconds, defaults to 5\n    :arg force_new: Forces get_es() to generate a new Elasticsearch\n        object rather than pulling it from cache.\n    :arg settings: other settings to pass into Elasticsearch\n        constructor; See\n        `<http://elasticsearch-py.readthedocs.org/>`_ for more details.\n\n    Examples::\n\n        # Returns cached Elasticsearch object\n        es = get_es()\n\n        # Returns a new Elasticsearch object\n        es = get_es(force_new=True)\n\n        es = get_es(urls=['localhost'])\n\n        es = get_es(urls=['localhost:9200'], timeout=10,\n                    max_retries=3)\n\n    \"\"\"\n    # Cheap way of de-None-ifying things\n    urls = urls or DEFAULT_URLS\n\n    # v0.7: Check for 'hosts' instead of 'urls'. Take this out in v1.0.\n    if 'hosts' in settings:\n        raise DeprecationWarning('\"hosts\" is deprecated in favor of \"urls\".')\n\n    if not force_new:\n        key = _build_key(urls, timeout, **settings)\n        if key in _cached_elasticsearch:\n            return _cached_elasticsearch[key]\n\n    es = Elasticsearch(urls, timeout=timeout, **settings)\n\n    if not force_new:\n        # We don't need to rebuild the key here since we built it in\n        # the previous if block, so it's in the namespace. Having said\n        # that, this is a little ew.\n        _cached_elasticsearch[key] = es\n\n    return es"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns facet counts as dict.", "response": "def _facet_counts(items):\n    \"\"\"Returns facet counts as dict.\n\n    Given the `items()` on the raw dictionary from Elasticsearch this processes\n    it and returns the counts keyed on the facet name provided in the original\n    query.\n\n    \"\"\"\n    facets = {}\n    for name, data in items:\n        facets[name] = FacetResult(name, data)\n    return facets"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nboosts a value if we should in _process_queries", "response": "def _boosted_value(name, action, key, value, boost):\n    \"\"\"Boost a value if we should in _process_queries\"\"\"\n    if boost is not None:\n        # Note: Most queries use 'value' for the key name except\n        # Match queries which use 'query'. So we have to do some\n        # switcheroo for that.\n        value_key = 'query' if action in MATCH_ACTIONS else 'value'\n        return {name: {'boost': boost, value_key: value}}\n    return {name: value}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn obj decorated with es_meta object", "response": "def decorate_with_metadata(obj, result):\n    \"\"\"Return obj decorated with es_meta object\"\"\"\n    # Create es_meta object with Elasticsearch metadata about this\n    # search result\n    obj.es_meta = Metadata(\n        # Elasticsearch id\n        id=result.get('_id', 0),\n        # Source data\n        source=result.get('_source', {}),\n        # The search result score\n        score=result.get('_score', None),\n        # The document type\n        type=result.get('_type', None),\n        # Explanation of score\n        explanation=result.get('_explanation', {}),\n        # Highlight bits\n        highlight=result.get('highlight', {})\n    )\n    # Put the id on the object for convenience\n    obj._id = result.get('_id', 0)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_python(self, obj):\n        if isinstance(obj, string_types):\n            if len(obj) == 26:\n                try:\n                    return datetime.strptime(obj, '%Y-%m-%dT%H:%M:%S.%f')\n                except (TypeError, ValueError):\n                    pass\n            elif len(obj) == 19:\n                try:\n                    return datetime.strptime(obj, '%Y-%m-%dT%H:%M:%S')\n                except (TypeError, ValueError):\n                    pass\n            elif len(obj) == 10:\n                try:\n                    return datetime.strptime(obj, '%Y-%m-%d')\n                except (TypeError, ValueError):\n                    pass\n\n        elif isinstance(obj, dict):\n            for key, val in obj.items():\n                obj[key] = self.to_python(val)\n\n        elif isinstance(obj, list):\n            return [self.to_python(item) for item in obj]\n\n        return obj", "response": "Converts strings in a data structure to Python types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying the database for the specified set of entries in the current set of entries.", "response": "def query(self, *queries, **kw):\n        \"\"\"\n        Return a new S instance with query args combined with existing\n        set in a must boolean query.\n\n        :arg queries: instances of Q\n        :arg kw: queries in the form of ``field__action=value``\n\n        There are three special flags you can use:\n\n        * ``must=True``: Specifies that the queries and kw queries\n          **must match** in order for a document to be in the result.\n\n          If you don't specify a special flag, this is the default.\n\n        * ``should=True``: Specifies that the queries and kw queries\n          **should match** in order for a document to be in the result.\n\n        * ``must_not=True``: Specifies the queries and kw queries\n          **must not match** in order for a document to be in the result.\n\n        These flags work by putting those queries in the appropriate\n        clause of an Elasticsearch boolean query.\n\n        Examples:\n\n        >>> s = S().query(foo='bar')\n        >>> s = S().query(Q(foo='bar'))\n        >>> s = S().query(foo='bar', bat__match='baz')\n        >>> s = S().query(foo='bar', should=True)\n        >>> s = S().query(foo='bar', should=True).query(baz='bat', must=True)\n\n        Notes:\n\n        1. Don't specify multiple special flags, but if you did, `should`\n           takes precedence.\n        2. If you don't specify any, it defaults to `must`.\n        3. You can specify special flags in the\n           :py:class:`elasticutils.Q`, too. If you're building your\n           query incrementally, using :py:class:`elasticutils.Q` helps\n           a lot.\n\n        See the documentation on :py:class:`elasticutils.Q` for more\n        details on composing queries with Q.\n\n        See the documentation on :py:class:`elasticutils.S` for more\n        details on adding support for more query types.\n\n        \"\"\"\n        q = Q()\n        for query in queries:\n            q += query\n\n        if 'or_' in kw:\n            # Backwards compatibile with pre-0.7 version.\n            or_query = kw.pop('or_')\n\n            # or_query here is a dict of key/val pairs. or_ indicates\n            # they're in a should clause, so we generate the\n            # equivalent Q and then add it in.\n            or_query['should'] = True\n            q += Q(**or_query)\n\n        q += Q(**kw)\n\n        return self._clone(next_step=('query', q))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter(self, *filters, **kw):\n        items = kw.items()\n        if six.PY3:\n            items = list(items)\n        return self._clone(\n            next_step=('filter', list(filters) + items))", "response": "Return a new S instance with filter args combined with existing set with AND."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef boost(self, **kw):\n        new = self._clone()\n        new.field_boosts.update(kw)\n        return new", "response": "Boost the keys of the current object with the given field - time field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef demote(self, amount_, *queries, **kw):\n        q = Q()\n        for query in queries:\n            q += query\n        q += Q(**kw)\n\n        return self._clone(next_step=('demote', (amount_, q)))", "response": "Returns a new S instance with boosting query and demotion."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef facet_raw(self, **kw):\n        items = kw.items()\n        if six.PY3:\n            items = list(items)\n        return self._clone(next_step=('facet_raw', items))", "response": "Return a new S instance with raw facet args combined with\n            existing set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef suggest(self, name, term, **kwargs):\n        return self._clone(next_step=('suggest', (name, term, kwargs)))", "response": "Set the suggestion options for a specific name and term."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new S instance with extra args combined with existing set.", "response": "def extra(self, **kw):\n        \"\"\"\n        Return a new S instance with extra args combined with existing\n        set.\n        \"\"\"\n        new = self._clone()\n        actions = ['values_list', 'values_dict', 'order_by', 'query',\n                   'filter', 'facet']\n        for key, vals in kw.items():\n            assert key in actions\n            if hasattr(vals, 'items'):\n                new.steps.append((key, vals.items()))\n            else:\n                new.steps.append((key, vals))\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_search(self):\n        filters = []\n        filters_raw = None\n        queries = []\n        query_raw = None\n        sort = []\n        dict_fields = set()\n        list_fields = set()\n        facets = {}\n        facets_raw = {}\n        demote = None\n        highlight_fields = set()\n        highlight_options = {}\n        suggestions = {}\n        explain = False\n        as_list = as_dict = False\n        search_type = None\n\n        for action, value in self.steps:\n            if action == 'order_by':\n                sort = []\n                for key in value:\n                    if isinstance(key, string_types) and key.startswith('-'):\n                        sort.append({key[1:]: 'desc'})\n                    else:\n                        sort.append(key)\n            elif action == 'values_list':\n                if not value:\n                    list_fields = set()\n                else:\n                    list_fields |= set(value)\n                as_list, as_dict = True, False\n            elif action == 'values_dict':\n                if not value:\n                    dict_fields = set()\n                else:\n                    dict_fields |= set(value)\n                as_list, as_dict = False, True\n            elif action == 'explain':\n                explain = value\n            elif action == 'query':\n                queries.append(value)\n            elif action == 'query_raw':\n                query_raw = value\n            elif action == 'demote':\n                # value here is a tuple of (negative_boost, query)\n                demote = value\n            elif action == 'filter':\n                filters.extend(self._process_filters(value))\n            elif action == 'filter_raw':\n                filters_raw = value\n            elif action == 'facet':\n                # value here is a (args, kwargs) tuple\n                facets.update(_process_facets(*value))\n            elif action == 'facet_raw':\n                facets_raw.update(dict(value))\n            elif action == 'highlight':\n                if value[0] == (None,):\n                    highlight_fields = set()\n                else:\n                    highlight_fields |= set(value[0])\n                highlight_options.update(value[1])\n            elif action == 'search_type':\n                search_type = value\n            elif action == 'suggest':\n                suggestions[value[0]] = (value[1], value[2])\n            elif action in ('es', 'indexes', 'doctypes', 'boost'):\n                # Ignore these--we use these elsewhere, but want to\n                # make sure lack of handling it here doesn't throw an\n                # error.\n                pass\n            else:\n                raise NotImplementedError(action)\n\n        qs = {}\n\n        # If there's a filters_raw, we use that.\n        if filters_raw:\n            qs['filter'] = filters_raw\n        else:\n            if len(filters) > 1:\n                qs['filter'] = {'and': filters}\n            elif filters:\n                qs['filter'] = filters[0]\n\n        # If there's a query_raw, we use that. Otherwise we use\n        # whatever we got from query and demote.\n        if query_raw:\n            qs['query'] = query_raw\n\n        else:\n            pq = self._process_queries(queries)\n\n            if demote is not None:\n                qs['query'] = {\n                    'boosting': {\n                        'negative': self._process_queries([demote[1]]),\n                        'negative_boost': demote[0]\n                        }\n                    }\n                if pq:\n                    qs['query']['boosting']['positive'] = pq\n\n            elif pq:\n                qs['query'] = pq\n\n        if as_list:\n            fields = qs['fields'] = list(list_fields) if list_fields else ['*']\n        elif as_dict:\n            fields = qs['fields'] = list(dict_fields) if dict_fields else ['*']\n        else:\n            fields = set()\n\n        if facets:\n            qs['facets'] = facets\n            # Hunt for `facet_filter` shells and update those. We use\n            # None as a shell, so if it's explicitly set to None, then\n            # we update it.\n            for facet in facets.values():\n                if facet.get('facet_filter', 1) is None and 'filter' in qs:\n                    facet['facet_filter'] = qs['filter']\n\n        if facets_raw:\n            qs.setdefault('facets', {}).update(facets_raw)\n\n        if sort:\n            qs['sort'] = sort\n        if self.start:\n            qs['from'] = self.start\n        if self.stop is not None:\n            qs['size'] = self.stop - self.start\n\n        if highlight_fields:\n            qs['highlight'] = self._build_highlight(\n                highlight_fields, highlight_options)\n\n        if explain:\n            qs['explain'] = True\n\n        for suggestion, (term, kwargs) in six.iteritems(suggestions):\n            qs.setdefault('suggest', {})[suggestion] = {\n                'text': term,\n                'term': {\n                    'field': kwargs.get('field', '_all'),\n                },\n            }\n\n        self.fields, self.as_list, self.as_dict = fields, as_list, as_dict\n        self.search_type = search_type\n        return qs", "response": "Builds the Elasticsearch search body for the current state of the user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_highlight(self, fields, options):\n        ret = {'fields': dict((f, {}) for f in fields),\n               'order': 'score'}\n        ret.update(options)\n        return ret", "response": "Build the portion of the query that controls highlighting."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a list of filters and returns ES JSON API filters getWorkspaceName", "response": "def _process_filters(self, filters):\n        \"\"\"Takes a list of filters and returns ES JSON API\n\n        :arg filters: list of F, (key, val) tuples, or dicts\n\n        :returns: list of ES JSON API filters\n\n        \"\"\"\n        rv = []\n        for f in filters:\n            if isinstance(f, F):\n                if f.filters:\n                    rv.extend(self._process_filters(f.filters))\n                    continue\n\n            elif isinstance(f, dict):\n                if six.PY3:\n                    key = list(f.keys())[0]\n                else:\n                    key = f.keys()[0]\n                val = f[key]\n                key = key.strip('_')\n\n                if key not in ('or', 'and', 'not', 'filter'):\n                    raise InvalidFieldActionError(\n                        '%s is not a valid connector' % f.keys()[0])\n\n                if 'filter' in val:\n                    filter_filters = self._process_filters(val['filter'])\n                    if len(filter_filters) == 1:\n                        filter_filters = filter_filters[0]\n                    rv.append({key: {'filter': filter_filters}})\n                else:\n                    rv.append({key: self._process_filters(val)})\n\n            else:\n                key, val = f\n                key, field_action = split_field_action(key)\n                handler_name = 'process_filter_{0}'.format(field_action)\n\n                if field_action and hasattr(self, handler_name):\n                    rv.append(getattr(self, handler_name)(\n                            key, val, field_action))\n\n                elif key.strip('_') in ('or', 'and', 'not'):\n                    connector = key.strip('_')\n                    rv.append({connector: self._process_filters(val.items())})\n\n                elif field_action is None:\n                    if val is None:\n                        rv.append({'missing': {\n                                    'field': key, \"null_value\": True}})\n                    else:\n                        rv.append({'term': {key: val}})\n\n                elif field_action in ('startswith', 'prefix'):\n                    rv.append({'prefix': {key: val}})\n\n                elif field_action == 'in':\n                    rv.append({'in': {key: val}})\n\n                elif field_action in RANGE_ACTIONS:\n                    rv.append({'range': {key: {field_action: val}}})\n\n                elif field_action == 'range':\n                    lower, upper = val\n                    rv.append({'range': {key: {'gte': lower, 'lte': upper}}})\n\n                elif field_action == 'distance':\n                    distance, latitude, longitude = val\n\n                    rv.append({\n                        'geo_distance': {\n                            'distance': distance,\n                            key: [longitude, latitude]\n                        }\n                    })\n\n                else:\n                    raise InvalidFieldActionError(\n                        '%s is not a valid field action' % field_action)\n\n        return rv"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a key - val pair and returns the Elasticsearch code for it", "response": "def _process_query(self, query):\n        \"\"\"Takes a key/val pair and returns the Elasticsearch code for it\"\"\"\n        key, val = query\n        field_name, field_action = split_field_action(key)\n\n        # Boost by name__action overrides boost by name.\n        boost = self.field_boosts.get(key)\n        if boost is None:\n            boost = self.field_boosts.get(field_name)\n\n        handler_name = 'process_query_{0}'.format(field_action)\n\n        if field_action and hasattr(self, handler_name):\n            return getattr(self, handler_name)(field_name, val, field_action)\n\n        elif field_action in QUERY_ACTION_MAP:\n            return {\n                QUERY_ACTION_MAP[field_action]: _boosted_value(\n                    field_name, field_action, key, val, boost)\n            }\n\n        elif field_action == 'query_string':\n            # query_string has different syntax, so it's handled\n            # differently.\n            #\n            # Note: query_string queries are not boosted with\n            # .boost()---they're boosted in the query text itself.\n            return {\n                'query_string': {'default_field': field_name, 'query': val}\n            }\n\n        elif field_action in RANGE_ACTIONS:\n            # Ranges are special and have a different syntax, so\n            # we handle them separately.\n            return {\n                'range': {field_name: _boosted_value(\n                        field_action, field_action, key, val, boost)}\n           }\n\n        elif field_action == 'range':\n            lower, upper = val\n            value = {\n                'gte': lower,\n                'lte': upper,\n            }\n            if boost:\n                value['boost'] = boost\n\n            return {'range': {field_name: value}}\n\n        raise InvalidFieldActionError(\n            '%s is not a valid field action' % field_action)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process_queries(self, queries):\n        # First, let's mush everything into a single Q. Then we can\n        # parse that into bits.\n        new_q = Q()\n\n        for query in queries:\n            new_q += query\n\n        # Now we have a single Q that needs to be processed.\n        should_q = [self._process_query(query) for query in new_q.should_q]\n        must_q = [self._process_query(query) for query in new_q.must_q]\n        must_not_q = [self._process_query(query) for query in new_q.must_not_q]\n\n        if len(must_q) > 1 or (len(should_q) + len(must_not_q) > 0):\n            # If there's more than one must_q or there are must_not_q\n            # or should_q, then we need to wrap the whole thing in a\n            # boolean query.\n            bool_query = {}\n            if must_q:\n                bool_query['must'] = must_q\n            if should_q:\n                bool_query['should'] = should_q\n            if must_not_q:\n                bool_query['must_not'] = must_not_q\n            return {'bool': bool_query}\n\n        if must_q:\n            # There's only one must_q query and that's it, so we hoist\n            # that.\n            return must_q[0]\n\n        return {}", "response": "Takes a list of queries and returns a query clause value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _do_search(self):\n        if self._results_cache is None:\n            response = self.raw()\n            ResultsClass = self.get_results_class()\n            results = self.to_python(response.get('hits', {}).get('hits', []))\n            self._results_cache = ResultsClass(\n                self.type, response, results, self.fields)\n        return self._results_cache", "response": "Perform the search and return a SearchResults instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_es(self, default_builder=get_es):\n        # .es() calls are incremental, so we go through them all and\n        # update bits that are specified.\n        args = {}\n        for action, value in self.steps:\n            if action == 'es':\n                args.update(**value)\n\n        # TODO: store the Elasticsearch on the S if we've already\n        # created one since we don't need to do it multiple times.\n        return default_builder(**args)", "response": "Returns the Elasticsearch object to use."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of indexes to act on.", "response": "def get_indexes(self, default_indexes=DEFAULT_INDEXES):\n        \"\"\"Returns the list of indexes to act on.\"\"\"\n        for action, value in reversed(self.steps):\n            if action == 'indexes':\n                return list(value)\n\n        if self.type is not None:\n            indexes = self.type.get_index()\n            if isinstance(indexes, string_types):\n                indexes = [indexes]\n            return indexes\n\n        return default_indexes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_doctypes(self, default_doctypes=DEFAULT_DOCTYPES):\n        for action, value in reversed(self.steps):\n            if action == 'doctypes':\n                return list(value)\n\n        if self.type is not None:\n            return [self.type.get_mapping_type_name()]\n\n        return default_doctypes", "response": "Returns the list of doctypes to use."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds query and passes to Elasticsearch then returns the raw version of the object.", "response": "def raw(self):\n        \"\"\"\n        Build query and passes to Elasticsearch, then returns the raw\n        format returned.\n        \"\"\"\n        qs = self.build_search()\n        es = self.get_es()\n\n        index = self.get_indexes()\n        doc_type = self.get_doctypes()\n\n        if doc_type and not index:\n            raise BadSearch(\n                'You must specify an index if you are specifying doctypes.')\n\n        extra_search_kwargs = {}\n        if self.search_type:\n            extra_search_kwargs['search_type'] = self.search_type\n\n        hits = es.search(body=qs,\n                         index=self.get_indexes(),\n                         doc_type=self.get_doctypes(),\n                         **extra_search_kwargs)\n\n        log.debug('[%s] %s' % (hits['took'], qs))\n        return hits"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_es(self):\n        if self.s:\n            return self.s.get_es()\n\n        return self.es or get_es()", "response": "Returns an Elasticsearch instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef raw(self):\n        es = self.get_es()\n\n        params = dict(self.query_params)\n        mlt_fields = self.mlt_fields or params.pop('mlt_fields', [])\n\n        body = self.s.build_search() if self.s else ''\n\n        hits = es.mlt(\n            index=self.index, doc_type=self.doctype, id=self.id,\n            mlt_fields=mlt_fields, body=body, **params)\n\n        log.debug(hits)\n\n        return hits", "response": "Builds query and passes to Elasticsearch then returns the raw\n            format returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _do_search(self):\n        if self._results_cache is None:\n            response = self.raw()\n            results = self.to_python(response.get('hits', {}).get('hits', []))\n            self._results_cache = DictSearchResults(\n                self.type, response, results, None)\n        return self._results_cache", "response": "Perform the mlt call then convert that raw format into a DictSearchResults instance and return it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds or updates a document to the index.", "response": "def index(cls, document, id_=None, overwrite_existing=True, es=None,\n              index=None):\n        \"\"\"Adds or updates a document to the index\n\n        :arg document: Python dict of key/value pairs representing\n            the document\n\n            .. Note::\n\n               This must be serializable into JSON.\n\n        :arg id_: the id of the document\n\n            .. Note::\n\n               If you don't provide an ``id_``, then Elasticsearch\n               will make up an id for your document and it'll look\n               like a character name from a Lovecraft novel.\n\n        :arg overwrite_existing: if ``True`` overwrites existing documents\n             of the same ID and doctype\n\n        :arg es: The `Elasticsearch` to use. If you don't specify an\n            `Elasticsearch`, it'll use `cls.get_es()`.\n\n        :arg index: The name of the index to use. If you don't specify one\n            it'll use `cls.get_index()`.\n\n        .. Note::\n\n           If you need the documents available for searches\n           immediately, make sure to refresh the index by calling\n           ``refresh_index()``.\n\n        \"\"\"\n        if es is None:\n            es = cls.get_es()\n\n        if index is None:\n            index = cls.get_index()\n\n        kw = {}\n        if not overwrite_existing:\n            kw['op_type'] = 'create'\n        es.index(index=index, doc_type=cls.get_mapping_type_name(),\n                 body=document, id=id_, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd or updates a batch of documents.", "response": "def bulk_index(cls, documents, id_field='id', es=None, index=None):\n        \"\"\"Adds or updates a batch of documents.\n\n        :arg documents: List of Python dicts representing individual\n            documents to be added to the index\n\n            .. Note::\n\n               This must be serializable into JSON.\n\n        :arg id_field: The name of the field to use as the document\n            id. This defaults to 'id'.\n\n        :arg es: The `Elasticsearch` to use. If you don't specify an\n            `Elasticsearch`, it'll use `cls.get_es()`.\n\n        :arg index: The name of the index to use. If you don't specify one\n            it'll use `cls.get_index()`.\n\n        .. Note::\n\n           If you need the documents available for searches\n           immediately, make sure to refresh the index by calling\n           ``refresh_index()``.\n\n        \"\"\"\n        if es is None:\n            es = cls.get_es()\n\n        if index is None:\n            index = cls.get_index()\n\n        documents = (dict(d, _id=d[id_field]) for d in documents)\n\n        bulk_index(\n            es,\n            documents,\n            index=index,\n            doc_type=cls.get_mapping_type_name(),\n            raise_on_error=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unindex(cls, id_, es=None, index=None):\n        if es is None:\n            es = cls.get_es()\n\n        if index is None:\n            index = cls.get_index()\n\n        es.delete(index=index, doc_type=cls.get_mapping_type_name(), id=id_)", "response": "Removes a particular item from the index."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refresh_index(cls, es=None, index=None):\n        if es is None:\n            es = cls.get_es()\n\n        if index is None:\n            index = cls.get_index()\n\n        es.indices.refresh(index=index)", "response": "Refreshes the index.\n\n        Elasticsearch will update the index periodically\n        automatically. If you need to see the documents you just\n        indexed in your search results right now, you should call\n        `refresh_index` as soon as you're done indexing. This is\n        particularly helpful for unit tests.\n\n        :arg es: The `Elasticsearch` to use. If you don't specify an\n            `Elasticsearch`, it'll use `cls.get_es()`.\n\n        :arg index: The name of the index to use. If you don't specify one\n            it'll use `cls.get_index()`."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn view context dictionary.", "response": "def get_context_data(self, **kwargs):\n        \"\"\"\n        Returns view context dictionary.\n\n        :rtype: dict.\n        \"\"\"\n        kwargs.update({\n            'entries': Entry.objects.get_for_tag(\n                self.kwargs.get('slug', 0)\n            )\n        })\n\n        return super(EntriesView, self).get_context_data(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_password(self, service, username):\n        assoc = self._generate_assoc(service, username)\n        service = escape_for_ini(service)\n        username = escape_for_ini(username)\n\n        # load the passwords from the file\n        config = configparser.RawConfigParser()\n        if os.path.exists(self.file_path):\n            config.read(self.file_path)\n\n        # fetch the password\n        try:\n            password_base64 = config.get(service, username).encode()\n            # decode with base64\n            password_encrypted = decodebytes(password_base64)\n            # decrypt the password with associated data\n            try:\n                password = self.decrypt(password_encrypted, assoc).decode(\n                    'utf-8')\n            except ValueError:\n                # decrypt the password without associated data\n                password = self.decrypt(password_encrypted).decode('utf-8')\n        except (configparser.NoOptionError, configparser.NoSectionError):\n            password = None\n        return password", "response": "Read the password from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_password(self, service, username, password):\n        if not username:\n            # https://github.com/jaraco/keyrings.alt/issues/21\n            raise ValueError(\"Username cannot be blank.\")\n        if not isinstance(password, string_types):\n            raise TypeError(\"Password should be a unicode string, not bytes.\")\n        assoc = self._generate_assoc(service, username)\n        # encrypt the password\n        password_encrypted = self.encrypt(password.encode('utf-8'), assoc)\n        # encode with base64 and add line break to untangle config file\n        password_base64 = '\\n' + encodebytes(password_encrypted).decode()\n\n        self._write_config_value(service, username, password_base64)", "response": "Write the password in the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures the storage path exists.", "response": "def _ensure_file_path(self):\n        \"\"\"\n        Ensure the storage path exists.\n        If it doesn't, create it with \"go-rwx\" permissions.\n        \"\"\"\n        storage_root = os.path.dirname(self.file_path)\n        needs_storage_root = storage_root and not os.path.isdir(storage_root)\n        if needs_storage_root:  # pragma: no cover\n            os.makedirs(storage_root)\n        if not os.path.isfile(self.file_path):\n            # create the file without group/world permissions\n            with open(self.file_path, 'w'):\n                pass\n            user_read_write = 0o600\n            os.chmod(self.file_path, user_read_write)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes the password for the username of the service.", "response": "def delete_password(self, service, username):\n        \"\"\"Delete the password for the username of the service.\n        \"\"\"\n        service = escape_for_ini(service)\n        username = escape_for_ini(username)\n        config = configparser.RawConfigParser()\n        if os.path.exists(self.file_path):\n            config.read(self.file_path)\n        try:\n            if not config.remove_option(service, username):\n                raise PasswordDeleteError(\"Password not found\")\n        except configparser.NoSectionError:\n            raise PasswordDeleteError(\"Password not found\")\n        # update the file\n        with open(self.file_path, 'w') as config_file:\n            config.write(config_file)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef applicable_models(self):\r\n        Page        = apps.get_model('wagtailcore', 'Page')\r\n        applicable  = []\r\n\r\n        for model in apps.get_models():\r\n            meta    = getattr(model, '_meta')\r\n            fields  = meta.get_all_field_names()\r\n\r\n            if issubclass(model, Page) and 'tags' in fields:\r\n                applicable.append(model)\r\n\r\n        return applicable", "response": "Returns a list of models that subclass Page\r\n        and include a tags field."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds edit handler that includes related panels to applicable model classes that don t explicitly define their own edit handler.", "response": "def add_relationship_panels(self):\r\n        \"\"\"\r\n        Add edit handler that includes \"related\" panels to applicable\r\n        model classes that don't explicitly define their own edit handler.\r\n        \"\"\"\r\n        from wagtailplus.utils.edit_handlers import add_panel_to_edit_handler\r\n        from wagtailplus.wagtailrelations.edit_handlers import RelatedPanel\r\n\r\n        for model in self.applicable_models:\r\n            add_panel_to_edit_handler(model, RelatedPanel, _(u'Related'))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd relationship methods to applicable model classes.", "response": "def add_relationship_methods(self):\r\n        \"\"\"\r\n        Adds relationship methods to applicable model classes.\r\n        \"\"\"\r\n        Entry = apps.get_model('wagtailrelations', 'Entry')\r\n\r\n        @cached_property\r\n        def related(instance):\r\n            return instance.get_related()\r\n\r\n        @cached_property\r\n        def related_live(instance):\r\n            return instance.get_related_live()\r\n\r\n        @cached_property\r\n        def related_with_scores(instance):\r\n            return instance.get_related_with_scores()\r\n\r\n        def get_related(instance):\r\n             entry = Entry.objects.get_for_model(instance)[0]\r\n             return entry.get_related()\r\n\r\n        def get_related_live(instance):\r\n             entry = Entry.objects.get_for_model(instance)[0]\r\n             return entry.get_related_live()\r\n\r\n        def get_related_with_scores(instance):\r\n            try:\r\n                entry = Entry.objects.get_for_model(instance)[0]\r\n                return entry.get_related_with_scores()\r\n            except IntegrityError:\r\n                return []\r\n\r\n        for model in self.applicable_models:\r\n            model.add_to_class(\r\n                'get_related',\r\n                get_related\r\n            )\r\n            model.add_to_class(\r\n                'get_related_live',\r\n                get_related_live\r\n            )\r\n            model.add_to_class(\r\n                'get_related_with_scores',\r\n                get_related_with_scores\r\n            )\r\n            model.add_to_class(\r\n                'related',\r\n                related\r\n            )\r\n            model.add_to_class(\r\n                'related_live',\r\n                related_live\r\n            )\r\n            model.add_to_class(\r\n                'related_with_scores',\r\n                related_with_scores\r\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ready(self):\r\n        import wagtailplus.wagtailrelations.signals.handlers\r\n\r\n        self.add_relationship_panels()\r\n        self.add_relationship_methods()\r\n        super(WagtailRelationsAppConfig, self).ready()", "response": "Called when the application is ready to be used."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of models that are applicable to the current page.", "response": "def applicable_models(self):\r\n        \"\"\"\r\n        Returns a list of model classes that subclass Page.\r\n\r\n        :rtype: list.\r\n        \"\"\"\r\n        Page        = apps.get_model('wagtailcore', 'Page')\r\n        applicable  = []\r\n\r\n        for model in apps.get_models():\r\n            if issubclass(model, Page):\r\n                applicable.append(model)\r\n\r\n        return applicable"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_rollback_panels(self):\r\n        from wagtailplus.utils.edit_handlers import add_panel_to_edit_handler\r\n        from wagtailplus.wagtailrollbacks.edit_handlers import HistoryPanel\r\n\r\n        for model in self.applicable_models:\r\n            add_panel_to_edit_handler(model, HistoryPanel, _(u'History'))", "response": "Adds rollback panel to applicable model class s edit handlers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd rollback methods to applicable model classes.", "response": "def add_rollback_methods():\r\n        \"\"\"\r\n        Adds rollback methods to applicable model classes.\r\n        \"\"\"\r\n        # Modified Page.save_revision method.\r\n        def page_rollback(instance, revision_id, user=None, submitted_for_moderation=False, approved_go_live_at=None, changed=True):\r\n            old_revision    = instance.revisions.get(pk=revision_id)\r\n            new_revision    = instance.revisions.create(\r\n                content_json                = old_revision.content_json,\r\n                user                        = user,\r\n                submitted_for_moderation    = submitted_for_moderation,\r\n                approved_go_live_at         = approved_go_live_at\r\n            )\r\n\r\n            update_fields = []\r\n\r\n            instance.latest_revision_created_at = new_revision.created_at\r\n            update_fields.append('latest_revision_created_at')\r\n\r\n            if changed:\r\n                instance.has_unpublished_changes = True\r\n                update_fields.append('has_unpublished_changes')\r\n\r\n            if update_fields:\r\n                instance.save(update_fields=update_fields)\r\n\r\n            logger.info(\r\n                \"Page edited: \\\"%s\\\" id=%d revision_id=%d\",\r\n                instance.title,\r\n                instance.id,\r\n                new_revision.id\r\n            )\r\n\r\n            if submitted_for_moderation:\r\n                logger.info(\r\n                    \"Page submitted for moderation: \\\"%s\\\" id=%d revision_id=%d\",\r\n                    instance.title,\r\n                    instance.id,\r\n                    new_revision.id\r\n                )\r\n\r\n            return new_revision\r\n\r\n        Page = apps.get_model('wagtailcore', 'Page')\r\n        Page.add_to_class('rollback', page_rollback)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling by the application to make sure that the rollbacks application is ready.", "response": "def ready(self):\r\n        \"\"\"\r\n        Finalizes application configuration.\r\n        \"\"\"\r\n        self.add_rollback_panels()\r\n        self.add_rollback_methods()\r\n        super(WagtailRollbacksAppConfig, self).ready()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning list of related Entry instances for specified page.", "response": "def get_related(page):\n    \"\"\"\n    Returns list of related Entry instances for specified page.\n\n    :param page: the page instance.\n    :rtype: list.\n    \"\"\"\n    related = []\n    entry   = Entry.get_for_model(page)\n\n    if entry:\n        related = entry.related\n\n    return related"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn admin URL for specified entry instance.", "response": "def get_related_entry_admin_url(entry):\n    \"\"\"\n    Returns admin URL for specified entry instance.\n\n    :param entry: the entry instance.\n    :return: str.\n    \"\"\"\n    namespaces = {\n        Document:   'wagtaildocs:edit',\n        Link:       'wagtaillinks:edit',\n        Page:       'wagtailadmin_pages:edit',\n    }\n\n    for cls, url in namespaces.iteritems():\n        if issubclass(entry.content_type.model_class(), cls):\n            return urlresolvers.reverse(url, args=(entry.object_id,))\n\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of related tuples for the specified page.", "response": "def get_related_with_scores(page):\n    \"\"\"\n    Returns list of related tuples (Entry instance, score) for\n    specified page.\n\n    :param page: the page instance.\n    :rtype: list.\n    \"\"\"\n    related = []\n    entry   = Entry.get_for_model(page)\n\n    if entry:\n        related = entry.related_with_scores\n\n    return related"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the password of the username for the service", "response": "def get_password(self, service, username):\n        \"\"\"Get password of the username for the service\n        \"\"\"\n        init_part = self._keyring.get_password(service, username)\n        if init_part:\n            parts = [init_part]\n            i = 1\n            while True:\n                next_part = self._keyring.get_password(\n                    service,\n                    '%s{{part_%d}}' % (username, i))\n                if next_part:\n                    parts.append(next_part)\n                    i += 1\n                else:\n                    break\n            return ''.join(parts)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_password(self, service, username, password):\n        segments = range(0, len(password), self._max_password_size)\n        password_parts = [\n            password[i:i + self._max_password_size] for i in segments]\n        for i, password_part in enumerate(password_parts):\n            curr_username = username\n            if i > 0:\n                curr_username += '{{part_%d}}' % i\n            self._keyring.set_password(service, curr_username, password_part)", "response": "Set the password for the username of the service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a dictionary of attributes find the corresponding link instance and return its HTML representation.", "response": "def expand_db_attributes(attrs, for_editor):\n        \"\"\"\n        Given a dictionary of attributes, find the corresponding link instance and\n        return its HTML representation.\n\n        :param attrs: dictionary of link attributes.\n        :param for_editor: whether or not HTML is for editor.\n        :rtype: str.\n        \"\"\"\n        try:\n            editor_attrs    = ''\n            link            = Link.objects.get(id=attrs['id'])\n\n            if for_editor:\n                editor_attrs = 'data-linktype=\"link\" data-id=\"{0}\" '.format(\n                    link.id\n                )\n\n            return '<a {0}href=\"{1}\" title=\"{2}\">'.format(\n                editor_attrs,\n                escape(link.get_absolute_url()),\n                link.title\n            )\n        except Link.DoesNotExist:\n            return '<a>'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crypter(self):\n        if not hasattr(self, '_crypter'):\n            # initialise the Keyczar keysets\n            if not self.keyset_location:\n                raise ValueError('No encrypted keyset location!')\n            reader = keyczar.readers.CreateReader(self.keyset_location)\n            if self.encrypting_keyset_location:\n                encrypting_keyczar = keyczar.Crypter.Read(\n                    self.encrypting_keyset_location)\n                reader = keyczar.readers.EncryptedReader(reader,\n                                                         encrypting_keyczar)\n            self._crypter = keyczar.Crypter(reader)\n        return self._crypter", "response": "The actual keyczar crypter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_objects(mapping_type, ids, chunk_size=100, es=None, index=None):\n    if settings.ES_DISABLED:\n        return\n\n    log.debug('Indexing objects {0}-{1}. [{2}]'.format(\n            ids[0], ids[-1], len(ids)))\n\n    # Get the model this mapping type is based on.\n    model = mapping_type.get_model()\n\n    # Retrieve all the objects that we're going to index and do it in\n    # bulk.\n    for id_list in chunked(ids, chunk_size):\n        documents = []\n\n        for obj in model.objects.filter(id__in=id_list):\n            try:\n                documents.append(mapping_type.extract_document(obj.id, obj))\n            except Exception as exc:\n                log.exception('Unable to extract document {0}: {1}'.format(\n                        obj, repr(exc)))\n\n        if documents:\n            mapping_type.bulk_index(documents, id_field='id', es=es, index=index)", "response": "Index objects of a specified mapping type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove documents of a specified mapping_type from the index.", "response": "def unindex_objects(mapping_type, ids, es=None, index=None):\n    \"\"\"Remove documents of a specified mapping_type from the index.\n\n    This allows for asynchronous deleting.\n\n    If a mapping_type extends Indexable, you can add a ``pre_delete``\n    hook for the model that it's based on like this::\n\n        @receiver(dbsignals.pre_delete, sender=MyModel)\n        def remove_from_index(sender, instance, **kw):\n            from elasticutils.contrib.django import tasks\n            tasks.unindex_objects.delay(MyMappingType, [instance.id])\n\n    :arg mapping_type: the mapping type for these ids\n    :arg ids: the list of ids of things to remove\n    :arg es: The `Elasticsearch` to use. If you don't specify an\n        `Elasticsearch`, it'll use `mapping_type.get_es()`.\n    :arg index: The name of the index to use. If you don't specify one\n        it'll use `mapping_type.get_index()`.\n    \"\"\"\n    if settings.ES_DISABLED:\n        return\n\n    for id_ in ids:\n        mapping_type.unindex(id_, es=es, index=index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning specified link instance as JSON.", "response": "def get_json(self, link):\n        \"\"\"\n        Returns specified link instance as JSON.\n\n        :param link: the link instance.\n        :rtype: JSON.\n        \"\"\"\n        return json.dumps({\n            'id':           link.id,\n            'title':        link.title,\n            'url':          link.get_absolute_url(),\n            'edit_link':    reverse(\n                '{0}:edit'.format(self.url_namespace),\n                kwargs = {'pk': link.pk}\n            ),\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the cipher object to encrypt or decrypt a payload.", "response": "def _create_cipher(self, password, salt, IV):\n        \"\"\"\n        Create the cipher object to encrypt or decrypt a payload.\n        \"\"\"\n        from Crypto.Protocol.KDF import PBKDF2\n        from Crypto.Cipher import AES\n        pw = PBKDF2(password, salt, dkLen=self.block_size)\n        return AES.new(pw[:self.block_size], AES.MODE_CFB, IV)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_file(self):\n        self.keyring_key = self._get_new_password()\n        # set a reference password, used to check that the password provided\n        #  matches for subsequent checks.\n        self.set_password('keyring-setting',\n                          'password reference',\n                          'password reference value')\n        self._write_config_value('keyring-setting',\n                                 'scheme',\n                                 self.scheme)\n        self._write_config_value('keyring-setting',\n                                 'version',\n                                 self.version)", "response": "Initialize a new password file and set the reference password."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the file exists and has the expected password reference.", "response": "def _check_file(self):\n        \"\"\"\n        Check if the file exists and has the expected password reference.\n        \"\"\"\n        if not os.path.exists(self.file_path):\n            return False\n        self._migrate()\n        config = configparser.RawConfigParser()\n        config.read(self.file_path)\n        try:\n            config.get(\n                escape_for_ini('keyring-setting'),\n                escape_for_ini('password reference'),\n            )\n        except (configparser.NoSectionError, configparser.NoOptionError):\n            return False\n        try:\n            self._check_scheme(config)\n        except AttributeError:\n            # accept a missing scheme\n            return True\n        return self._check_version(config)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_version(self, config):\n        try:\n            self.file_version = config.get(\n                escape_for_ini('keyring-setting'),\n                escape_for_ini('version'),\n            )\n        except (configparser.NoSectionError, configparser.NoOptionError):\n            return False\n        return True", "response": "check for a valid version of the file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _unlock(self):\n        self.keyring_key = getpass.getpass(\n            'Please enter password for encrypted keyring: ')\n        try:\n            ref_pw = self.get_password('keyring-setting', 'password reference')\n            assert ref_pw == 'password reference value'\n        except AssertionError:\n            self._lock()\n            raise ValueError(\"Incorrect Password\")", "response": "Unlock this keyring by getting the password for the keyring from the user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _escape_char(c):\n    \"Single char escape. Return the char, escaped if not already legal\"\n    if isinstance(c, int):\n        c = _unichr(c)\n    return c if c in LEGAL_CHARS else ESCAPE_FMT % ord(c)", "response": "Single char escape. Return the char escaped if not already legal"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_passwords(self, service, username, deleting=False):\n        passwords = []\n\n        service = self._safe_string(service)\n        username = self._safe_string(username)\n        for attrs_tuple in (('username', 'service'), ('user', 'domain')):\n            attrs = GnomeKeyring.Attribute.list_new()\n            GnomeKeyring.Attribute.list_append_string(\n                attrs, attrs_tuple[0], username)\n            GnomeKeyring.Attribute.list_append_string(\n                attrs, attrs_tuple[1], service)\n            result, items = GnomeKeyring.find_items_sync(\n                GnomeKeyring.ItemType.NETWORK_PASSWORD, attrs)\n            if result == GnomeKeyring.Result.OK:\n                passwords += items\n            elif deleting:\n                if result == GnomeKeyring.Result.CANCELLED:\n                    raise PasswordDeleteError(\"Cancelled by user\")\n                elif result != GnomeKeyring.Result.NO_MATCH:\n                    raise PasswordDeleteError(result.value_name)\n        return passwords", "response": "Find the passwords for the service and username"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_password(self, service, username):\n        items = self._find_passwords(service, username)\n        if not items:\n            return None\n\n        secret = items[0].secret\n        return (\n            secret\n            if isinstance(secret, six.text_type) else\n            secret.decode('utf-8')\n        )", "response": "Get the password of the username for the service"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_password(self, service, username, password):\n        service = self._safe_string(service)\n        username = self._safe_string(username)\n        password = self._safe_string(password)\n        attrs = GnomeKeyring.Attribute.list_new()\n        GnomeKeyring.Attribute.list_append_string(attrs, 'username', username)\n        GnomeKeyring.Attribute.list_append_string(attrs, 'service', service)\n        GnomeKeyring.Attribute.list_append_string(\n            attrs, 'application', 'python-keyring')\n        result = GnomeKeyring.item_create_sync(\n            self.keyring_name, GnomeKeyring.ItemType.NETWORK_PASSWORD,\n            \"Password for '%s' on '%s'\" % (username, service),\n            attrs, password, True)[0]\n        if result == GnomeKeyring.Result.CANCELLED:\n            # The user pressed \"Cancel\" when prompted to unlock their keyring.\n            raise PasswordSetError(\"Cancelled by user\")\n        elif result != GnomeKeyring.Result.OK:\n            raise PasswordSetError(result.value_name)", "response": "Set the password for the username of the service"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_password(self, service, username):\n        items = self._find_passwords(service, username, deleting=True)\n        if not items:\n            raise PasswordDeleteError(\"Password not found\")\n        for current in items:\n            result = GnomeKeyring.item_delete_sync(current.keyring,\n                                                   current.item_id)\n            if result == GnomeKeyring.Result.CANCELLED:\n                raise PasswordDeleteError(\"Cancelled by user\")\n            elif result != GnomeKeyring.Result.OK:\n                raise PasswordDeleteError(result.value_name)", "response": "Delete the password for the username of the service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _safe_string(self, source, encoding='utf-8'):\n        if not isinstance(source, str):\n            return source.encode(encoding)\n        return str(source)", "response": "Convert unicode to string as gnomekeyring barfs on unicode"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_context_data(self, **kwargs):\n        kwargs.update({\n            'view':             self,\n            'email_form':       EmailLinkForm(),\n            'external_form':    ExternalLinkForm(),\n            'type_email':       Link.LINK_TYPE_EMAIL,\n            'type_external':    Link.LINK_TYPE_EXTERNAL,\n        })\n\n        # If a form has been submitted, update context with\n        # the submitted form value.\n        if 'form' in kwargs:\n            submitted_form = kwargs.pop('form')\n            if isinstance(submitted_form, EmailLinkForm):\n                kwargs.update({'email_form': submitted_form})\n            elif isinstance(submitted_form, ExternalLinkForm):\n                kwargs.update({'external_form': submitted_form})\n\n        return kwargs", "response": "Returns the context dictionary for view."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the response for a POST request.", "response": "def post(self, request, *args, **kwargs):\n        \"\"\"\n        Returns POST response.\n\n        :param request: the request instance.\n        :rtype: django.http.HttpResponse.\n        \"\"\"\n        form        = None\n        link_type   = int(request.POST.get('link_type', 0))\n\n        if link_type == Link.LINK_TYPE_EMAIL:\n            form = EmailLinkForm(**self.get_form_kwargs())\n        elif link_type == Link.LINK_TYPE_EXTERNAL:\n            form = ExternalLinkForm(**self.get_form_kwargs())\n\n        if form:\n            if form.is_valid():\n                return self.form_valid(form)\n            else:\n                return self.form_invalid(form)\n        else:\n            raise Http404()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the form class to use in the view.", "response": "def get_form_class(self):\n        \"\"\"\n        Returns form class to use in the view.\n\n        :rtype: django.forms.ModelForm.\n        \"\"\"\n        if self.object.link_type == Link.LINK_TYPE_EMAIL:\n            return EmailLinkForm\n        elif self.object.link_type == Link.LINK_TYPE_EXTERNAL:\n            return ExternalLinkForm\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the password of the username for the service", "response": "def get_password(self, service, username):\n        \"\"\"Get password of the username for the service\n        \"\"\"\n        try:\n            # fetch the password\n            key = self._key_for_service(service)\n            hkey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key)\n            password_saved = winreg.QueryValueEx(hkey, username)[0]\n            password_base64 = password_saved.encode('ascii')\n            # decode with base64\n            password_encrypted = base64.decodestring(password_base64)\n            # decrypted the password\n            password = _win_crypto.decrypt(password_encrypted).decode('utf-8')\n        except EnvironmentError:\n            password = None\n        return password"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_password(self, service, username, password):\n        # encrypt the password\n        password_encrypted = _win_crypto.encrypt(password.encode('utf-8'))\n        # encode with base64\n        password_base64 = base64.encodestring(password_encrypted)\n        # encode again to unicode\n        password_saved = password_base64.decode('ascii')\n\n        # store the password\n        key_name = self._key_for_service(service)\n        hkey = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_name)\n        winreg.SetValueEx(hkey, username, 0, winreg.REG_SZ, password_saved)", "response": "Write the password to the registry\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_password(self, service, username):\n        try:\n            key_name = self._key_for_service(service)\n            hkey = winreg.OpenKey(\n                winreg.HKEY_CURRENT_USER, key_name, 0,\n                winreg.KEY_ALL_ACCESS)\n            winreg.DeleteValue(hkey, username)\n            winreg.CloseKey(hkey)\n        except WindowsError:\n            e = sys.exc_info()[1]\n            raise PasswordDeleteError(e)\n        self._delete_key_if_empty(service)", "response": "Delete the password for the username of the service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _open(self, mode='r'):\n        open_file = None\n        writeable = 'w' in mode or 'a' in mode or '+' in mode\n        try:\n            # NOTE: currently the MemOpener does not split off any filename\n            #       which causes errors on close()\n            #       so we add a dummy name and open it separately\n            if (self.filename.startswith('mem://')\n                    or self.filename.startswith('ram://')):\n                open_file = fs.opener.fsopendir(self.filename).open('kr.cfg',\n                                                                    mode)\n            else:\n                if not hasattr(self, '_pyfs'):\n                    # reuse the pyfilesystem and path\n                    self._pyfs, self._path = fs.opener.opener.parse(\n                        self.filename, writeable=writeable)\n                    # cache if permitted\n                    if self._cache_timeout is not None:\n                        self._pyfs = fs.remote.CacheFS(\n                            self._pyfs, cache_timeout=self._cache_timeout)\n                open_file = self._pyfs.open(self._path, mode)\n        except fs.errors.ResourceNotFoundError:\n            if self._can_create:\n                segments = fs.opener.opener.split_segments(self.filename)\n                if segments:\n                    # this seems broken, but pyfilesystem uses it, so we must\n                    fs_name, credentials, url1, url2, path = segments.groups()\n                    assert fs_name, 'Should be a remote filesystem'\n                    host = ''\n                    # allow for domain:port\n                    if ':' in url2:\n                        split_url2 = url2.split('/', 1)\n                        if len(split_url2) > 1:\n                            url2 = split_url2[1]\n                        else:\n                            url2 = ''\n                        host = split_url2[0]\n                    pyfs = fs.opener.opener.opendir(\n                        '%s://%s' % (fs_name, host))\n                    # cache if permitted\n                    if self._cache_timeout is not None:\n                        pyfs = fs.remote.CacheFS(\n                            pyfs, cache_timeout=self._cache_timeout)\n                    # NOTE: fs.path.split does not function in the same\n                    # way os os.path.split... at least under windows\n                    url2_path, url2_filename = os.path.split(url2)\n                    if url2_path and not pyfs.exists(url2_path):\n                        pyfs.makedir(url2_path, recursive=True)\n                else:\n                    # assume local filesystem\n                    full_url = fs.opener._expand_syspath(self.filename)\n                    # NOTE: fs.path.split does not function in the same\n                    # way os os.path.split... at least under windows\n                    url2_path, url2 = os.path.split(full_url)\n                    pyfs = fs.osfs.OSFS(url2_path)\n\n                try:\n                    # reuse the pyfilesystem and path\n                    self._pyfs = pyfs\n                    self._path = url2\n                    return pyfs.open(url2, mode)\n                except fs.errors.ResourceNotFoundError:\n                    if writeable:\n                        raise\n                    else:\n                        pass\n            # NOTE: ignore read errors as the underlying caller can fail safely\n            if writeable:\n                raise\n            else:\n                pass\n        return open_file", "response": "Open the password file in the specified mode."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef config(self):\n        if not hasattr(self, '_config'):\n            raw_config = configparser.RawConfigParser()\n            f = self._open()\n            if f:\n                raw_config.readfp(f)\n                f.close()\n            self._config = raw_config\n        return self._config", "response": "load the passwords from the config file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_password(self, service, username):\n        service = escape_for_ini(service)\n        username = escape_for_ini(username)\n\n        # fetch the password\n        try:\n            password_base64 = self.config.get(service, username).encode()\n            # decode with base64\n            password_encrypted = base64.decodestring(password_base64)\n            # decrypted the password\n            password = self.decrypt(password_encrypted).decode('utf-8')\n        except (configparser.NoOptionError, configparser.NoSectionError):\n            password = None\n        return password", "response": "Read the password from the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_password(self, service, username, password):\n        service = escape_for_ini(service)\n        username = escape_for_ini(username)\n\n        # encrypt the password\n        password = password or ''\n        password_encrypted = self.encrypt(password.encode('utf-8'))\n\n        # encode with base64\n        password_base64 = base64.encodestring(password_encrypted).decode()\n        # write the modification\n        if not self.config.has_section(service):\n            self.config.add_section(service)\n        self.config.set(service, username, password_base64)\n        config_file = UnicodeWriterAdapter(self._open('w'))\n        self.config.write(config_file)\n        config_file.close()", "response": "Write the password in the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns queryset limited to categories with live Entry instances.", "response": "def get_queryset(self):\n        \"\"\"\n        Returns queryset limited to categories with live Entry instances.\n\n        :rtype: django.db.models.query.QuerySet.\n        \"\"\"\n        queryset = super(LiveEntryCategoryManager, self).get_queryset()\n        return queryset.filter(tag__in=[\n            entry_tag.tag\n            for entry_tag\n            in EntryTag.objects.filter(entry__live=True)\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a tuple of Entry instance created for the specified model instance.", "response": "def get_for_model(self, model):\n        \"\"\"\n        Returns tuple (Entry instance, created) for specified\n        model instance.\n\n        :rtype: wagtailplus.wagtailrelations.models.Entry.\n        \"\"\"\n        return self.get_or_create(\n            content_type    = ContentType.objects.get_for_model(model),\n            object_id       = model.pk\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns queryset of Entry instances assigned to specified tag.", "response": "def get_for_tag(self, tag):\n        \"\"\"\n        Returns queryset of Entry instances assigned to specified\n        tag, which can be a PK value, a slug value, or a Tag instance.\n\n        :param tag: tag PK, slug, or instance.\n        :rtype: django.db.models.query.QuerySet.\n        \"\"\"\n        tag_filter = {'tag': tag}\n\n        if isinstance(tag, six.integer_types):\n            tag_filter = {'tag_id': tag}\n        elif isinstance(tag, str):\n            tag_filter = {'tag__slug': tag}\n\n        return self.filter(id__in=[\n            entry_tag.entry_id\n            for entry_tag\n            in EntryTag.objects.filter(**tag_filter)\n        ])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef for_category(self, category, live_only=False):\n        filters = {'tag': category.tag}\n\n        if live_only:\n            filters.update({'entry__live': True})\n\n        return self.filter(**filters)", "response": "Returns queryset of EntryTag instances for the specified category."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn queryset of Entry instances related to specified Entry instance.", "response": "def related_to(self, entry, live_only=False):\n        \"\"\"\n        Returns queryset of Entry instances related to specified\n        Entry instance.\n\n        :param entry: the Entry instance.\n        :param live_only: flag to include only \"live\" entries.\n        :rtype: django.db.models.query.QuerySet.\n        \"\"\"\n        filters = {'tag__in': entry.tags}\n\n        if live_only:\n            filters.update({'entry__live': True})\n\n        return self.filter(**filters).exclude(entry=entry)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chosen_view_factory(chooser_cls):\n    class ChosenView(chooser_cls):\n        #noinspection PyUnusedLocal\n        def get(self, request, *args, **kwargs):\n            \"\"\"\n            Returns GET response.\n\n            :param request: the request instance.\n            :rtype: django.http.HttpResponse.\n            \"\"\"\n            #noinspection PyAttributeOutsideInit\n            self.object = self.get_object()\n\n            return render_modal_workflow(\n                self.request,\n                None,\n                '{0}/chosen.js'.format(self.template_dir),\n                {'obj': self.get_json(self.object)}\n            )\n\n        def get_object(self, queryset=None):\n            \"\"\"\n            Returns chosen object instance.\n\n            :param queryset: the queryset instance.\n            :rtype: django.db.models.Model.\n            \"\"\"\n            if queryset is None:\n                queryset = self.get_queryset()\n\n            pk = self.kwargs.get('pk', None)\n\n            try:\n                return queryset.get(pk=pk)\n            except self.models.DoesNotExist:\n                raise Http404()\n\n        def post(self, request, *args, **kwargs):\n            \"\"\"\n            Returns POST response.\n\n            :param request: the request instance.\n            :rtype: django.http.HttpResponse.\n            \"\"\"\n            return self.get(request, *args, **kwargs)\n\n    return ChosenView", "response": "Returns a ChosenView class that extends the specified chooser class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess an invalid form submittal.", "response": "def form_invalid(self, form):\n        \"\"\"\n        Processes an invalid form submittal.\n\n        :param form: the form instance.\n        :rtype: django.http.HttpResponse.\n        \"\"\"\n        context = self.get_context_data(form=form)\n\n        #noinspection PyUnresolvedReferences\n        return render_modal_workflow(\n            self.request,\n            '{0}/chooser.html'.format(self.template_dir),\n            '{0}/chooser.js'.format(self.template_dir),\n            context\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing a valid form submittal.", "response": "def form_valid(self, form):\n        \"\"\"\n        Processes a valid form submittal.\n\n        :param form: the form instance.\n        :rtype: django.http.HttpResponse.\n        \"\"\"\n        #noinspection PyAttributeOutsideInit\n        self.object = form.save()\n\n        # Index the link.\n        for backend in get_search_backends():\n            backend.add(self.object)\n\n        #noinspection PyUnresolvedReferences\n        return render_modal_workflow(\n            self.request,\n            None,\n            '{0}/chosen.js'.format(self.template_dir),\n            {'obj': self.get_json(self.object)}\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, request, *args, **kwargs):\n        #noinspection PyAttributeOutsideInit\n        self.object_list    = self.get_queryset()\n        context             = self.get_context_data(force_search=True)\n\n        if self.form_class:\n            context.update({'form': self.get_form()})\n\n        if 'q' in request.GET or 'p' in request.GET:\n            return render(\n                request,\n                '{0}/results.html'.format(self.template_dir),\n                context\n            )\n        else:\n            return render_modal_workflow(\n                request,\n                '{0}/chooser.html'.format(self.template_dir),\n                '{0}/chooser.js'.format(self.template_dir),\n                context\n            )", "response": "Returns GET response.\n\n        :param request: the request instance.\n        :rtype: django.http.HttpResponse."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_form_kwargs(self):\n        kwargs = {\n            'initial':  self.get_initial(),\n            'prefix':   self.get_prefix(),\n        }\n\n        #noinspection PyUnresolvedReferences\n        if self.request.method in ('POST', 'PUT'):\n            #noinspection PyUnresolvedReferences\n            kwargs.update({\n                'data':     self.request.POST,\n                'files':    self.request.FILES,\n            })\n\n        if hasattr(self, 'object'):\n            kwargs.update({'instance': self.object})\n\n        return kwargs", "response": "Returns the keyword arguments for instantiating the form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate EntryTag for Entry corresponding to specified item base instance.", "response": "def create_entry_tag(sender, instance, created, **kwargs):\n    \"\"\"\n    Creates EntryTag for Entry corresponding to specified\n    ItemBase instance.\n\n    :param sender: the sending ItemBase class.\n    :param instance: the ItemBase instance.\n    \"\"\"\n    from ..models import (\n        Entry,\n        EntryTag\n    )\n\n    entry   = Entry.objects.get_for_model(instance.content_object)[0]\n    tag     = instance.tag\n\n    if not EntryTag.objects.filter(tag=tag, entry=entry).exists():\n        EntryTag.objects.create(tag=tag, entry=entry)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes EntryTag for Entry corresponding to specified EntryBase instance.", "response": "def delete_entry_tag(sender, instance, **kwargs):\n    \"\"\"\n    Deletes EntryTag for Entry corresponding to specified\n    TaggedItemBase instance.\n\n    :param sender: the sending TaggedItemBase class.\n    :param instance: the TaggedItemBase instance.\n    \"\"\"\n    from ..models import (\n        Entry,\n        EntryTag\n    )\n\n    entry   = Entry.objects.get_for_model(instance.content_object)[0]\n    tag     = instance.tag\n\n    EntryTag.objects.filter(tag=tag, entry=entry).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_entry(sender, instance, **kwargs):\n    from ..models import Entry\n\n    Entry.objects.get_for_model(instance)[0].delete()", "response": "Delete Entry instance corresponding to specified instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the attributes of Entry instance corresponding to the passed instance.", "response": "def update_entry_attributes(sender, instance, **kwargs):\n    \"\"\"\n    Updates attributes for Entry instance corresponding to\n    specified instance.\n\n    :param sender: the sending class.\n    :param instance: the instance being saved.\n    \"\"\"\n    from ..models import Entry\n\n    entry = Entry.objects.get_for_model(instance)[0]\n\n    default_url = getattr(instance, 'get_absolute_url', '')\n    entry.title = getattr(instance, 'title', str(instance))\n    entry.url   = getattr(instance, 'url', default_url)\n    entry.live  = bool(getattr(instance, 'live', True))\n\n    entry.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_revisions(page, page_num=1):\n    revisions   = page.revisions.order_by('-created_at')\n    current     = page.get_latest_revision()\n\n    if current:\n        revisions.exclude(id=current.id)\n\n    paginator = Paginator(revisions, 5)\n\n    try:\n        revisions = paginator.page(page_num)\n    except PageNotAnInteger:\n        revisions = paginator.page(1)\n    except EmptyPage:\n        revisions = paginator.page(paginator.num_pages)\n\n    return revisions", "response": "Returns paginated queryset of PageRevision instances for the specified Page instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef page_revisions(request, page_id, template_name='wagtailrollbacks/edit_handlers/revisions.html'):\n    page        = get_object_or_404(Page, pk=page_id)\n    page_perms  = page.permissions_for_user(request.user)\n\n    if not page_perms.can_edit():\n        raise PermissionDenied\n\n    page_num    = request.GET.get('p', 1)\n    revisions   = get_revisions(page, page_num)\n\n    return render(\n        request,\n        template_name,\n        {\n            'page':         page,\n            'revisions':    revisions,\n            'p':            page_num,\n        }\n    )", "response": "Returns GET response for specified page revisions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning GET response for specified page preview.", "response": "def preview_page_version(request, revision_id):\n    \"\"\"\n    Returns GET response for specified page preview.\n\n    :param request: the request instance.\n    :param reversion_pk: the page revision ID.\n    :rtype: django.http.HttpResponse.\n    \"\"\"\n    revision = get_object_or_404(PageRevision, pk=revision_id)\n\n    if not revision.page.permissions_for_user(request.user).can_publish():\n        raise PermissionDenied\n\n    page                = revision.as_page_object()\n    request.revision_id = revision_id\n\n    return page.serve_preview(request, page.default_preview_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef confirm_page_reversion(request, revision_id, template_name='wagtailrollbacks/pages/confirm_reversion.html'):\n    revision    = get_object_or_404(PageRevision, pk=revision_id)\n    page        = revision.page\n\n    if page.locked:\n        messages.error(\n            request,\n            _(\"Page '{0}' is locked.\").format(page.title),\n            buttons = []\n        )\n\n        return redirect(reverse('wagtailadmin_pages:edit', args=(page.id,)))\n\n    page_perms = page.permissions_for_user(request.user)\n    if not page_perms.can_edit():\n        raise PermissionDenied\n\n    if request.POST:\n        is_publishing   = bool(request.POST.get('action-publish')) and page_perms.can_publish()\n        is_submitting   = bool(request.POST.get('action-submit'))\n        new_revision    = page.rollback(\n            revision_id                 = revision_id,\n            user                        = request.user,\n            submitted_for_moderation    = is_submitting\n        )\n\n        if is_publishing:\n            new_revision.publish()\n\n            messages.success(\n                request,\n                _(\"Page '{0}' published.\").format(page.title),\n                buttons=[\n                    messages.button(page.url, _('View live')),\n                    messages.button(reverse('wagtailadmin_pages:edit', args=(page.id,)), _('Edit'))\n                ]\n            )\n        elif is_submitting:\n            messages.success(\n                request,\n                _(\"Page '{0}' submitted for moderation.\").format(page.title),\n                buttons=[\n                    messages.button(reverse('wagtailadmin_pages:view_draft', args=(page.id,)), _('View draft')),\n                    messages.button(reverse('wagtailadmin_pages:edit', args=(page.id,)), _('Edit'))\n                ]\n            )\n            send_notification(new_revision.id, 'submitted', request.user.id)\n        else:\n            messages.success(\n                request,\n                _(\"Page '{0}' updated.\").format(page.title),\n                buttons=[]\n            )\n\n        for fn in hooks.get_hooks('after_edit_page'):\n            result = fn(request, page)\n            if hasattr(result, 'status_code'):\n                return result\n\n        return redirect('wagtailadmin_explore', page.get_parent().id)\n\n    return render(\n        request,\n        template_name,\n        {\n            'page':         page,\n            'revision':     revision,\n            'page_perms':   page_perms\n        }\n    )", "response": "Handles the page reversion process."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_password(self, service, username):\n        result = self._get_entry(self._keyring, service, username)\n        if result:\n            result = self._decrypt(result)\n        return result", "response": "Get the password for the username for the service"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_password(self, service, username, password):\n        password = self._encrypt(password or '')\n        keyring_working_copy = copy.deepcopy(self._keyring)\n        service_entries = keyring_working_copy.get(service)\n        if not service_entries:\n            service_entries = {}\n            keyring_working_copy[service] = service_entries\n        service_entries[username] = password\n        save_result = self._save_keyring(keyring_working_copy)\n        if save_result == self.OK:\n            self._keyring_dict = keyring_working_copy\n            return\n        elif save_result == self.CONFLICT:\n            # check if we can avoid updating\n            self.docs_entry, keyring_dict = self._read()\n            existing_pwd = self._get_entry(self._keyring, service, username)\n            conflicting_pwd = self._get_entry(keyring_dict, service, username)\n            if conflicting_pwd == password:\n                # if someone else updated it to the same value then we are done\n                self._keyring_dict = keyring_working_copy\n                return\n            elif conflicting_pwd is None or conflicting_pwd == existing_pwd:\n                # if doesn't already exist or is unchanged then update it\n                new_service_entries = keyring_dict.get(service, {})\n                new_service_entries[username] = password\n                keyring_dict[service] = new_service_entries\n                save_result = self._save_keyring(keyring_dict)\n                if save_result == self.OK:\n                    self._keyring_dict = keyring_dict\n                    return\n                else:\n                    raise errors.PasswordSetError(\n                        'Failed write after conflict detected')\n            else:\n                raise errors.PasswordSetError(\n                    'Conflict detected, service:%s and username:%s was '\n                    'set to a different value by someone else' % (\n                        service,\n                        username,\n                    ),\n                )\n\n        raise errors.PasswordSetError('Could not save keyring')", "response": "Set the password for the username of the service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _save_keyring(self, keyring_dict):\n        import gdata\n        result = self.OK\n        file_contents = base64.urlsafe_b64encode(pickle.dumps(keyring_dict))\n        try:\n            if self.docs_entry:\n                extra_headers = {'Content-Type': 'text/plain',\n                                 'Content-Length': len(file_contents)}\n                self.docs_entry = self.client.Put(\n                    file_contents,\n                    self.docs_entry.GetEditMediaLink().href,\n                    extra_headers=extra_headers\n                )\n            else:\n                from gdata.docs.service import DocumentQuery\n                # check for existence of folder, create if required\n                folder_query = DocumentQuery(categories=['folder'])\n                folder_query['title'] = self.collection\n                folder_query['title-exact'] = 'true'\n                docs = self.client.QueryDocumentListFeed(folder_query.ToUri())\n                if docs.entry:\n                    folder_entry = docs.entry[0]\n                else:\n                    folder_entry = self.client.CreateFolder(self.collection)\n                file_handle = io.BytesIO(file_contents)\n                media_source = gdata.MediaSource(\n                    file_handle=file_handle,\n                    content_type='text/plain',\n                    content_length=len(file_contents),\n                    file_name='temp')\n                self.docs_entry = self.client.Upload(\n                    media_source,\n                    self._get_doc_title(),\n                    folder_or_uri=folder_entry\n                )\n        except gdata.service.RequestError as ex:\n            try:\n                if ex.message['reason'].lower().find('conflict') != -1:\n                    result = self.CONFLICT\n                else:\n                    # Google docs has a bug when updating a shared document\n                    # using PUT from any account other that the owner.\n                    # It returns an error 400 \"Sorry, there was an error saving\n                    # the file. Please try again\"\n                    # *despite* actually updating the document!\n                    # Workaround by re-reading to see if it actually updated\n                    msg = 'Sorry, there was an error saving the file'\n                    if ex.message['body'].find(msg) != -1:\n                        new_docs_entry, new_keyring_dict = self._read()\n                        if new_keyring_dict == keyring_dict:\n                            result = self.OK\n                        else:\n                            result = self.FAIL\n                    else:\n                        result = self.FAIL\n            except Exception:\n                result = self.FAIL\n\n        return result", "response": "Helper method to actually write the keyring to Google"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the request token for a string.", "response": "def calculate_token(self, text, seed=None):\n        \"\"\" Calculate the request token (`tk`) of a string\n        :param text: str The text to calculate a token for\n        :param seed: str The seed to use. By default this is the number of hours since epoch\n        \"\"\"\n\n        if seed is None:\n            seed = self._get_token_key()\n\n        [first_seed, second_seed] = seed.split(\".\")\n\n        try:\n            d = bytearray(text.encode('UTF-8'))\n        except UnicodeDecodeError:\n            # This will probably only occur when d is actually a str containing UTF-8 chars, which means we don't need\n            # to encode.\n            d = bytearray(text)\n\n        a = int(first_seed)\n        for value in d:\n            a += value\n            a = self._work_token(a, self.SALT_1)\n        a = self._work_token(a, self.SALT_2)\n        a ^= int(second_seed)\n        if 0 > a:\n            a = (a & 2147483647) + 2147483648\n        a %= 1E6\n        a = int(a)\n        return str(a) + \".\" + str(a ^ int(first_seed))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _request(method, url, session=None, **kwargs):\n    url = BASE_URL + url\n\n    if session:\n        request_func = getattr(session, method)\n    else:\n        request_func = getattr(requests, method)\n    response = request_func(url, **kwargs)\n    # raise an exception if request is not successful\n    if not response.status_code == requests.codes.ok:\n        raise DweepyError('HTTP {0} response'.format(response.status_code))\n    response_json = response.json()\n    if response_json['this'] == 'failed':\n        raise DweepyError(response_json['because'])\n    return response_json['with']", "response": "Make HTTP request, raising an exception if it fails."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a dweet to dweet. io", "response": "def _send_dweet(payload, url, params=None, session=None):\n    \"\"\"Send a dweet to dweet.io\n    \"\"\"\n    data = json.dumps(payload)\n    headers = {'Content-type': 'application/json'}\n    return _request('post', url, data=data, headers=headers, params=params, session=session)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dweet_for(thing_name, payload, key=None, session=None):\n    if key is not None:\n        params = {'key': key}\n    else:\n        params = None\n    return _send_dweet(payload, '/dweet/for/{0}'.format(thing_name), params=params, session=session)", "response": "Send a dweet to dweet. io for a thing with a known name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dweets_for(thing_name, key=None, session=None):\n    if key is not None:\n        params = {'key': key}\n    else:\n        params = None\n    return _request('get', '/get/dweets/for/{0}'.format(thing_name), params=params, session=None)", "response": "Read all the dweets for a given thing"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_lock(lock, key, session=None):\n    return _request('get', '/remove/lock/{0}'.format(lock), params={'key': key}, session=session)", "response": "Remove a lock (no matter what it's connected to)."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlocks a thing (prevents unauthed dweets for the locked thing)", "response": "def lock(thing_name, lock, key, session=None):\n    \"\"\"Lock a thing (prevents unauthed dweets for the locked thing)\n    \"\"\"\n    return _request('get', '/lock/{0}'.format(thing_name), params={'key': key, 'lock': lock}, session=session)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunlocking a thing in a sequence", "response": "def unlock(thing_name, key, session=None):\n    \"\"\"Unlock a thing\n    \"\"\"\n    return _request('get', '/unlock/{0}'.format(thing_name), params={'key': key}, session=session)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_alert(thing_name, who, condition, key, session=None):\n    return _request('get', '/alert/{0}/when/{1}/{2}'.format(\n        ','.join(who),\n        thing_name,\n        quote(condition),\n    ), params={'key': key}, session=session)", "response": "Set an alert on a thing with the given condition"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_alert(thing_name, key, session=None):\n    return _request('get', '/get/alert/for/{0}'.format(thing_name), params={'key': key}, session=session)", "response": "Get an alert on a thing with the given condition"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_alert(thing_name, key, session=None):\n    return _request('get', '/remove/alert/for/{0}'.format(thing_name), params={'key': key}, session=session)", "response": "Remove an alert for the given thing"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist all product sets for current user", "response": "def get_product_sets(self):\n        \"\"\"\n        list all product sets for current user\n        \"\"\"\n        # ensure we are using api url without a specific product set id\n        api_url = super(ProductSetAPI, self).base_url\n        return self.client.get(api_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nis NOTICED: this will delete all product sets for current user", "response": "def delete_all_product_sets(self):\n        \"\"\"\n        BE NOTICED: this will delete all product sets for current user\n        \"\"\"\n        # ensure we are using api url without a specific product set id\n        api_url = super(ProductSetAPI, self).base_url\n        return self.client.delete(api_url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_products(self, product_ids):\n        if self.product_set_id is None:\n            raise ValueError('product_set_id must be specified')\n        data = {'ids': product_ids}\n        return self.client.get(self.base_url + '/products', json=data)", "response": "Get a list of products from the specified product set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_stream_timeout(started, timeout):\n    if timeout:\n        elapsed = datetime.datetime.utcnow() - started\n        if elapsed.seconds > timeout:\n            raise StopIteration", "response": "Check if the timeout has been reached and raise a StopIteration if so."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _listen_for_dweets_from_response(response):\n    streambuffer = ''\n    for byte in response.iter_content():\n        if byte:\n            streambuffer += byte.decode('ascii')\n            try:\n                dweet = json.loads(streambuffer.splitlines()[1])\n            except (IndexError, ValueError):\n                continue\n            if isstr(dweet):\n                yield json.loads(dweet)\n            streambuffer = ''", "response": "Yields dweets as received from dweet. io s streaming API\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a real - time subscription to dweets", "response": "def listen_for_dweets_from(thing_name, timeout=900, key=None, session=None):\n    \"\"\"Create a real-time subscription to dweets\n    \"\"\"\n    url = BASE_URL + '/listen/for/dweets/from/{0}'.format(thing_name)\n    session = session or requests.Session()\n    if key is not None:\n        params = {'key': key}\n    else:\n        params = None\n\n    start = datetime.datetime.utcnow()\n    while True:\n        request = requests.Request(\"GET\", url, params=params).prepare()\n        resp = session.send(request, stream=True, timeout=timeout)\n        try:\n            for x in _listen_for_dweets_from_response(resp):\n                yield x\n                _check_stream_timeout(start, timeout)\n        except (ChunkedEncodingError, requests.exceptions.ConnectionError, requests.exceptions.ReadTimeout):\n            pass\n        _check_stream_timeout(start, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, service_id, request_id, description=None, details=None):\n        if not service_id:\n            raise ValueError('service_id is required')\n\n        if not request_id:\n            raise ValueError('request_id is required')\n\n        \"\"\"\n        curl -X POST \\\n            -H 'x-ca-version: 1.0' \\\n            -H 'x-ca-accesskeyid: YourAccessId' \\\n            -d \"service_id=p4dkh2sg&request_id=c13ed5aa-d6d2-11e8-ba11-02420a582a05&description=blahlblah\" \\\n            https://api.productai.cn/bad_cases/_0000204\n        \"\"\"\n        data = dict()\n        data['service_id'] = service_id\n        data['request_id'] = request_id\n\n        if description:\n            data['description'] = description\n\n        if details:\n            data['details'] = details\n\n        \"\"\"\n{\n\"created_at\": \"2018-10-24T03:30:51Z\",\n\"description\": \"\\u8fd9\\u662f\\u4e00\\u4e2a\\u6d4b\\u8bd5\",\n\"details\": \"\",\n\"id\": 34,\n\"image_path\": null,\n\"modified_at\": \"2018-10-24T03:30:51Z\",\n\"reporter_id\": 1632,\n\"request_id\": \"34954696-d73d-11e8-9419-0242ac1c2b04\",\n\"service_id\": \"p4dkh2sg\",\n\"status\": \"open\"\n}            \n        \"\"\"\n        return self.client.post(self.base_url, data=data)", "response": "Add a new bad case to a service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build(self, parallel=True, debug=False, force=False,\n              machine_readable=False):\n        \"\"\"Executes a `packer build`\n\n        :param bool parallel: Run builders in parallel\n        :param bool debug: Run in debug mode\n        :param bool force: Force artifact output even if exists\n        :param bool machine_readable: Make output machine-readable\n        \"\"\"\n        self.packer_cmd = self.packer.build\n\n        self._add_opt('-parallel=true' if parallel else None)\n        self._add_opt('-debug' if debug else None)\n        self._add_opt('-force' if force else None)\n        self._add_opt('-machine-readable' if machine_readable else None)\n        self._append_base_arguments()\n        self._add_opt(self.packerfile)\n\n        return self.packer_cmd()", "response": "Executes a packer build"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix(self, to_file=None):\n        self.packer_cmd = self.packer.fix\n\n        self._add_opt(self.packerfile)\n\n        result = self.packer_cmd()\n        if to_file:\n            with open(to_file, 'w') as f:\n                f.write(result.stdout.decode())\n        result.fixed = json.loads(result.stdout.decode())\n        return result", "response": "Implements the packer fix function\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninspect a Packer Templates file and returns the output in a readable form.", "response": "def inspect(self, mrf=True):\n        \"\"\"Inspects a Packer Templates file (`packer inspect -machine-readable`)\n\n        To return the output in a readable form, the `-machine-readable` flag\n        is appended automatically, afterwhich the output is parsed and returned\n        as a dict of the following format:\n          \"variables\": [\n            {\n              \"name\": \"aws_access_key\",\n              \"value\": \"{{env `AWS_ACCESS_KEY_ID`}}\"\n            },\n            {\n              \"name\": \"aws_secret_key\",\n              \"value\": \"{{env `AWS_ACCESS_KEY`}}\"\n            }\n          ],\n          \"provisioners\": [\n            {\n              \"type\": \"shell\"\n            }\n          ],\n          \"builders\": [\n            {\n              \"type\": \"amazon-ebs\",\n              \"name\": \"amazon\"\n            }\n          ]\n\n        :param bool mrf: output in machine-readable form.\n        \"\"\"\n        self.packer_cmd = self.packer.inspect\n\n        self._add_opt('-machine-readable' if mrf else None)\n        self._add_opt(self.packerfile)\n\n        result = self.packer_cmd()\n        if mrf:\n            result.parsed_output = self._parse_inspection_output(\n                                                        result.stdout.decode())\n        else:\n            result.parsed_output = None\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef push(self, create=True, token=False):\n        self.packer_cmd = self.packer.push\n\n        self._add_opt('-create=true' if create else None)\n        self._add_opt('-tokn={0}'.format(token) if token else None)\n        self._add_opt(self.packerfile)\n\n        return self.packer_cmd()", "response": "Implmenets the packer push function\n\n        UNTESTED! Must be used alongside an Atlas account\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, syntax_only=False):\n        self.packer_cmd = self.packer.validate\n\n        self._add_opt('-syntax-only' if syntax_only else None)\n        self._append_base_arguments()\n        self._add_opt(self.packerfile)\n\n        # as sh raises an exception rather than return a value when execution\n        # fails we create an object to return the exception and the validation\n        # state\n        try:\n            validation = self.packer_cmd()\n            validation.succeeded = validation.exit_code == 0\n            validation.error = None\n        except Exception as ex:\n            validation = ValidationObject()\n            validation.succeeded = False\n            validation.failed = True\n            validation.error = ex.message\n        return validation", "response": "Validates a Packer Template file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _append_base_arguments(self):\n        if self.exc and self.only:\n            raise PackerException('Cannot provide both \"except\" and \"only\"')\n        elif self.exc:\n            self._add_opt('-except={0}'.format(self._join_comma(self.exc)))\n        elif self.only:\n            self._add_opt('-only={0}'.format(self._join_comma(self.only)))\n        for var, value in self.vars.items():\n            self._add_opt(\"-var\")\n            self._add_opt(\"{0}={1}\".format(var, value))\n        if self.var_file:\n            self._add_opt('-var-file={0}'.format(self.var_file))", "response": "Appends base arguments to packer commands."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_inspection_output(self, output):\n        parts = {'variables': [], 'builders': [], 'provisioners': []}\n        for line in output.splitlines():\n            line = line.split(',')\n            if line[2].startswith('template'):\n                del line[0:2]\n                component = line[0]\n                if component == 'template-variable':\n                    variable = {\"name\": line[1], \"value\": line[2]}\n                    parts['variables'].append(variable)\n                elif component == 'template-builder':\n                    builder = {\"name\": line[1], \"type\": line[2]}\n                    parts['builders'].append(builder)\n                elif component == 'template-provisioner':\n                    provisioner = {\"type\": line[1]}\n                    parts['provisioners'].append(provisioner)\n        return parts", "response": "Parses the machine - readable output of the packer inspect command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform an HTTP POST request for a given url. Returns the response object.", "response": "def post(self, url, data, headers=None):\n        \"\"\"\n        Perform an HTTP POST request for a given url.\n        Returns the response object.\n        \"\"\"\n        return self._request('POST', url, data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming an HTTP PUT request for a given url. Returns the response object.", "response": "def put(self, url, data, headers=None):\n        \"\"\"\n        Perform an HTTP PUT request for a given url.\n        Returns the response object.\n        \"\"\"\n        return self._request('PUT', url, data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries a fulltext index by key and query", "response": "def query(self, *args):\n        \"\"\"\n        Query a fulltext index by key and query or just a plain Lucene query,\n\n        i1 = gdb.nodes.indexes.get('people',type='fulltext', provider='lucene')\n        i1.query('name','do*')\n        i1.query('name:do*')\n\n        In this example, the last two line are equivalent.\n        \"\"\"\n        if not args or len(args) > 2:\n            raise TypeError('query() takes 2 or 3 arguments (a query or a key '\n                            'and a query) (%d given)' % (len(args) + 1))\n        elif len(args) == 1:\n            query, = args\n            return self.get('text').query(text_type(query))\n        else:\n            key, query = args\n            index_key = self.get(key)\n            if isinstance(query, string_types):\n                return index_key.query(query)\n            else:\n                if query.fielded:\n                    raise ValueError('Queries with an included key should '\n                                     'not include a field.')\n                return index_key.query(text_type(query))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a HTML representation of a particular QuerySequence.", "response": "def _plot_graph(self, graph, title=None, width=None, height=None):\n        \"\"\"\n        Return a HTML representation for a particular QuerySequence.\n        Mainly for IPython Notebook.\n        \"\"\"\n        if not self._elements_row and not self._elements_graph:\n            raise ValueError('Unable to display the graph or the table')\n        title = title or self.q\n        width = width or json.dumps(None)\n        height = height or 300\n        d3_uuid = text_type(uuid.uuid1())\n        d3_graph = self._transform_graph_to_d3(graph)\n        d3_id = \"d3_id_\" + d3_uuid\n        d3_title = title\n        d3_container_id = d3_id + \"_d3c\"\n        style = \"\"\"\n        #{d3_id} path.link {{\n            fill: none;\n            stroke-width: 1.5px;\n        }}\n        #{d3_id} .node {{\n            /*fill: #ccc;*/\n            stroke: #333;\n            stroke-width: 1.5px;\n        }}\n        #{d3_id} text {{\n            font: 10px sans-serif;\n            pointer-events: none;\n        }}\n        #{d3_id} text.shadow {{\n            stroke: #fff;\n            stroke-width: 3px;\n            stroke-opacity: .8;\n        }}\n        #{d3_id} .node.sticky {{\n            /* stroke-width: 2px; */\n        }}\n        \"\"\".format(d3_id=d3_id)\n        js = \"\"\"\n        var links = graph.links;\n        var nodes = graph.nodes;\n\n        // Compute the distinct nodes from the links.\n        links.forEach(function(link) {\n            link.source = (nodes[link.source] ||\n                           (nodes[link.source] = {name: link.source}));\n            link.target = (nodes[link.target] ||\n                           (nodes[link.target] = {name: link.target}));\n        });\n\n        var w = width || $(container).width(), h = height;\n\n        var force = d3.layout.force()\n            .nodes(d3.values(nodes))\n            .links(links)\n            .size([w, h])\n            .linkDistance(60)\n            .charge(-300)\n            .on(\"tick\", tick)\n            .start();\n\n        var svg = d3.select(container).append(\"svg:svg\")\n            .attr(\"width\", w)\n            .attr(\"height\", h);\n\n        // Per-type markers, as they don't inherit styles.\n        svg.append(\"svg:defs\").selectAll(\"marker\")\n            .data([\"arrow\"])\n            .enter().append(\"svg:marker\")\n            .attr(\"id\", String)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 15)\n            .attr(\"refY\", -1.5)\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n            .append(\"svg:path\")\n            .attr(\"d\", \"M0,-5L10,0L0,5\");\n\n        var path = svg.append(\"svg:g\").selectAll(\"path\")\n            .data(force.links())\n            .enter().append(\"svg:path\")\n            .attr(\"class\", function(d) { return \"link \" + d.stroke; })\n            .attr(\"stroke\", function(d) { return d.stroke; })\n            .attr(\"marker-end\", function(d) { return \"url(#arrow)\"; });\n\n        var circle = svg.append(\"svg:g\").selectAll(\"circle\")\n            .data(force.nodes())\n            .enter().append(\"svg:circle\")\n            .attr(\"fill\", function(d) { return d.fill; })\n            .attr(\"r\", 6)\n            .attr(\"class\", \"node\")\n            .call(force.drag)\n            .on(\"mousedown\", function(d) {\n                d.fixed = true;\n                d3.select(this).classed(\"sticky\", true);\n            });\n\n        var text = svg.append(\"svg:g\").selectAll(\"g\")\n            .data(force.nodes())\n            .enter().append(\"svg:g\");\n\n        // A copy of the text with a thick white stroke for legibility.\n        text.append(\"svg:text\")\n            .attr(\"x\", 8)\n            .attr(\"y\", \".31em\")\n            .attr(\"class\", \"shadow\")\n            .text(function(d) { return d.label; });\n\n        text.append(\"svg:text\")\n            .attr(\"x\", 8)\n            .attr(\"y\", \".31em\")\n            .attr(\"class\", \"front\")\n            .text(function(d) { return d.label; });\n\n        // Use elliptical arc path segments to doubly-encode directionality.\n        function tick() {\n            path.attr(\"d\", function(d) {\n                var dx = d.target.x - d.source.x,\n                dy = d.target.y - d.source.y,\n                dr = Math.sqrt(dx * dx + dy * dy);\n                return (\"M\" + d.source.x + \",\" + d.source.y + \"A\"\n                        + dr + \",\" + dr + \" 0 0,1 \" + d.target.x + \",\"\n                        + d.target.y);\n            });\n\n            circle.attr(\"transform\", function(d) {\n                return \"translate(\" + d.x + \",\" + d.y + \")\";\n            });\n\n            text.attr(\"transform\", function(d) {\n                return \"translate(\" + d.x + \",\" + d.y + \")\";\n            });\n        }\n\n        // Display options\n        var display = $(container + \"_display\");\n        graph.properties.forEach(function (property) {\n            var option = $(\"<OPTION/>\");\n            option.text(property);\n            option.attr(\"value\", property);\n            display.append(option);\n        });\n        display.on(\"change\", function () {\n            var selected = $(this).find(\":selected\").val(),\n                displayFunc;\n            if (selected.length !== 0) {\n                displayFunc = function(d) {\n                    return d.properties[selected];\n                }\n            } else {\n                displayFunc = function(d) {\n                    return d.label;\n                }\n            }\n            text.select(\"text.front\").text(displayFunc);\n            text.select(\"text.shadow\").text(displayFunc);\n        });\n        \"\"\"\n        return (\"\"\"\n        <style type=\"text/css\">\n        {style}\n        </style>\n\n        <div class=\"accordion\">\n            <div class=\"accordion-group\">\n                <div class=\"accordion-heading\">\n                    <a class=\"accordion-toggle collapsed\"\n                       data-toggle=\"collapse\" data-parent=\"\"\n                       href=\"#{d3_id}\">\n                        {d3_title}\n                    </a>\n                </div>\n                <div id=\"{d3_id}\" class=\"accordion-body in collapse\">\n                    <div class=\"accordion-inner\">\n                        <div id=\"{d3_container_id}\">\n                            <select id=\"{d3_container_id}_display\">\n                                <option value=\"\">ID</option>\n                            </select>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <script>\n            var neo4jrestclient = window.neo4jrestclient || {{}};\n            neo4jrestclient['{d3_uuid}'] = {{}};\n            neo4jrestclient['{d3_uuid}'].graph = {d3_graph};\n            neo4jrestclient['{d3_uuid}'].container_id = \"{d3_container_id}\";\n            neo4jrestclient['{d3_uuid}'].container = \"#{d3_container_id}\";\n            neo4jrestclient['{d3_uuid}'].render = function () {{\n                (function (graph, container, width, height) {{\n                    {js}\n                }})(\n                    neo4jrestclient['{d3_uuid}'].graph,\n                    neo4jrestclient['{d3_uuid}'].container,\n                    {width},\n                    {height}\n                );\n            }}\n            if (!window.d3) {{\n                $.getScript(\n                    \"//d3js.org/d3.v2.js?2.9.1\",\n                    neo4jrestclient['{d3_uuid}'].render\n                );\n            }} else {{\n                neo4jrestclient['{d3_uuid}'].render();\n            }}\n        </script>\n        \"\"\".format(\n            style=style,\n            js=js,\n            d3_graph=json.dumps(d3_graph),\n            d3_id=d3_id,\n            d3_uuid=d3_uuid,\n            d3_title=d3_title,\n            d3_container_id=d3_container_id,\n            width=width,\n            height=height,\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_call(self, path, method, body=None, headers=None):\n        url = urljoin(self.base_url, path)\n        try:\n            resp = requests.request(method, url, data=body, headers=headers,\n                                    auth=self.auth, timeout=self.timeout)\n        except requests.exceptions.Timeout as out:\n            raise NetworkError(\"Timeout while trying to connect to RabbitMQ\")\n        except requests.exceptions.RequestException as err:\n            # All other requests exceptions inherit from RequestException\n            raise NetworkError(\"Error during request %s %s\" % (type(err), err))\n\n        try:\n            content = resp.json()\n        except ValueError as out:\n            content = None\n\n        # 'success' HTTP status codes are 200-206\n        if resp.status_code < 200 or resp.status_code > 206:\n            raise HTTPError(content, resp.status_code, resp.text, path, body)\n        else:\n            if content:\n                return content\n            else:\n                return None", "response": "Send an HTTP request to the REST API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap around http. do_call that transforms some HTTPError into an exception and raises PermissionError", "response": "def _call(self, path, method, body=None, headers=None):\n        \"\"\"\n        Wrapper around http.do_call that transforms some HTTPError into\n        our own exceptions\n        \"\"\"\n        try:\n            resp = self.http.do_call(path, method, body, headers)\n        except http.HTTPError as err:\n            if err.status == 401:\n                raise PermissionError('Insufficient permissions to query ' +\n                    '%s with user %s :%s' % (path, self.user, err))\n            raise\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_alive(self, vhost='%2F'):\n        uri = Client.urls['live_test'] % vhost\n\n        try:\n            resp = self._call(uri, 'GET')\n        except http.HTTPError as err:\n            if err.status == 404:\n                raise APIError(\"No vhost named '%s'\" % vhost)\n            raise\n\n        if resp['status'] == 'ok':\n            return True\n        else:\n            return False", "response": "Returns True if the server is alive and False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vhost_names(self):\n        vhosts = self.get_all_vhosts()\n        vhost_names = [i['name'] for i in vhosts]\n        return vhost_names", "response": "A convenience function for getting back only the vhost names instead of\n        the larger vhost dicts."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the attributes of a single named vhost in a dict.", "response": "def get_vhost(self, vname):\n        \"\"\"\n        Returns the attributes of a single named vhost in a dict.\n\n        :param string vname: Name of the vhost to get.\n        :returns dict vhost: Attribute dict for the named vhost\n\n        \"\"\"\n\n        vname = quote(vname, '')\n        path = Client.urls['vhosts_by_name'] % vname\n        vhost = self._call(path, 'GET', headers=Client.json_headers)\n        return vhost"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_vhost(self, vname):\n        vname = quote(vname, '')\n        path = Client.urls['vhosts_by_name'] % vname\n        return self._call(path, 'PUT',\n                                 headers=Client.json_headers)", "response": "Creates a vhost on the server to house exchanges."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a vhost from the server.", "response": "def delete_vhost(self, vname):\n        \"\"\"\n        Deletes a vhost from the server. Note that this also deletes any\n        exchanges or queues that belong to this vhost.\n\n        :param string vname: Name of the vhost to delete from the server.\n        \"\"\"\n        vname = quote(vname, '')\n        path = Client.urls['vhosts_by_name'] % vname\n        return self._call(path, 'DELETE')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_permissions(self):\n        path = Client.urls['all_permissions']\n        conns = self._call(path, 'GET')\n        return conns", "response": "Get all permissions for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vhost_permissions(self, vname):\n        vname = quote(vname, '')\n        path = Client.urls['vhost_permissions_get'] % (vname,)\n        conns = self._call(path, 'GET')\n        return conns", "response": "Get permissions for a vhost."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets permissions for a user.", "response": "def get_user_permissions(self, username):\n        \"\"\"\n        :returns: list of dicts, or an empty list if there are no permissions.\n\n        :param string username: User to set permissions for.\n        \"\"\"\n\n        path = Client.urls['user_permissions'] % (username,)\n        conns = self._call(path, 'GET')\n        return conns"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets permissions for a given vhost.", "response": "def set_vhost_permissions(self, vname, username, config, rd, wr):\n        \"\"\"\n        Set permissions for a given username on a given vhost. Both\n        must already exist.\n\n        :param string vname: Name of the vhost to set perms on.\n        :param string username: User to set permissions for.\n        :param string config: Permission pattern for configuration operations\n            for this user in this vhost.\n        :param string rd: Permission pattern for read operations for this user\n            in this vhost\n        :param string wr: Permission pattern for write operations for this user\n            in this vhost.\n\n        Permission patterns are regex strings. If you're unfamiliar with this,\n        you should definitely check out this section of the RabbitMQ docs:\n\n        http://www.rabbitmq.com/admin-guide.html#access-control\n        \"\"\"\n        vname = quote(vname, '')\n        body = json.dumps({\"configure\": config, \"read\": rd, \"write\": wr})\n        path = Client.urls['vhost_permissions'] % (vname, username)\n        return self._call(path, 'PUT', body,\n                                 headers=Client.json_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes permissions for a given username on a given vhost.", "response": "def delete_permission(self, vname, username):\n        \"\"\"\n        Delete permission for a given username on a given vhost. Both\n        must already exist.\n\n        :param string vname: Name of the vhost to set perms on.\n        :param string username: User to set permissions for.\n        \"\"\"\n        vname = quote(vname, '')\n        path = Client.urls['vhost_permissions'] % (vname, username)\n        return self._call(path, 'DELETE')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_exchanges(self, vhost=None):\n        if vhost:\n            vhost = quote(vhost, '')\n            path = Client.urls['exchanges_by_vhost'] % vhost\n        else:\n            path = Client.urls['all_exchanges']\n\n        exchanges = self._call(path, 'GET')\n        return exchanges", "response": "Returns a list of dicts containing the current set of exchanges for a vhost."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_exchange(self, vhost, name):\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['exchange_by_name'] % (vhost, name)\n        exch = self._call(path, 'GET')\n        return exch", "response": "Gets a single exchange which requires a vhost and name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an AMQP exchange in the given vhost with the given name and type.", "response": "def create_exchange(self,\n                        vhost,\n                        name,\n                        xtype,\n                        auto_delete=False,\n                        durable=True,\n                        internal=False,\n                        arguments=None):\n        \"\"\"\n        Creates an exchange in the given vhost with the given name. As per the\n        RabbitMQ API documentation, a JSON body also needs to be included that\n        \"looks something like this\":\n\n        {\"type\":\"direct\",\n        \"auto_delete\":false,\n        \"durable\":true,\n        \"internal\":false,\n        \"arguments\":[]}\n\n        On success, the API returns a 204 with no content, in which case this\n        function returns True. If any other response is received, it's raised.\n\n        :param string vhost: Vhost to create the exchange in.\n        :param string name: Name of the proposed exchange.\n        :param string type: The AMQP exchange type.\n        :param bool auto_delete: Whether or not the exchange should be\n            dropped when the no. of consumers drops to zero.\n        :param bool durable: Whether you want this exchange to persist a\n            broker restart.\n        :param bool internal: Whether or not this is a queue for use by the\n            broker only.\n        :param list arguments: If given, should be a list. If not given, an\n            empty list is sent.\n\n        \"\"\"\n\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['exchange_by_name'] % (vhost, name)\n        base_body = {\"type\": xtype, \"auto_delete\": auto_delete,\n                     \"durable\": durable, \"internal\": internal,\n                     \"arguments\": arguments or list()}\n\n        body = json.dumps(base_body)\n        self._call(path, 'PUT', body,\n                          headers=Client.json_headers)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npublishing a message to an exchange.", "response": "def publish(self, vhost, xname, rt_key, payload, payload_enc='string',\n                properties=None):\n        \"\"\"\n        Publish a message to an exchange.\n\n        :param string vhost: vhost housing the target exchange\n        :param string xname: name of the target exchange\n        :param string rt_key: routing key for message\n        :param string payload: the message body for publishing\n        :param string payload_enc: encoding of the payload. The only choices\n                      here are 'string' and 'base64'.\n        :param dict properties: a dict of message properties\n        :returns: boolean indicating success or failure.\n        \"\"\"\n        vhost = quote(vhost, '')\n        xname = quote(xname, '')\n        path = Client.urls['publish_to_exchange'] % (vhost, xname)\n        body = json.dumps({'routing_key': rt_key, 'payload': payload,\n                           'payload_encoding': payload_enc,\n                           'properties': properties or {}})\n        result = self._call(path, 'POST', body)\n        return result['routed']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_exchange(self, vhost, name):\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['exchange_by_name'] % (vhost, name)\n        self._call(path, 'DELETE')\n        return True", "response": "Delete the named exchange from the named vhost."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all queues or all queues in a vhost.", "response": "def get_queues(self, vhost=None):\n        \"\"\"\n        Get all queues, or all queues in a vhost if vhost is not None.\n        Returns a list.\n\n        :param string vhost: The virtual host to list queues for. If This is\n                    None (the default), all queues for the broker instance\n                    are returned.\n        :returns: A list of dicts, each representing a queue.\n        :rtype: list of dicts\n\n        \"\"\"\n        if vhost:\n            vhost = quote(vhost, '')\n            path = Client.urls['queues_by_vhost'] % vhost\n        else:\n            path = Client.urls['all_queues']\n\n        queues = self._call(path, 'GET')\n        return queues or list()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a single queue which requires both vhost and name.", "response": "def get_queue(self, vhost, name):\n        \"\"\"\n        Get a single queue, which requires both vhost and name.\n\n        :param string vhost: The virtual host for the queue being requested.\n            If the vhost is '/', note that it will be translated to '%2F' to\n            conform to URL encoding requirements.\n        :param string name: The name of the queue being requested.\n        :returns: A dictionary of queue properties.\n        :rtype: dict\n\n        \"\"\"\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['queues_by_name'] % (vhost, name)\n        queue = self._call(path, 'GET')\n        return queue"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_queue_depth(self, vhost, name):\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['queues_by_name'] % (vhost, name)\n        queue = self._call(path, 'GET')\n        depth = queue['messages']\n\n        return depth", "response": "This is a convenience\n         function that returns the number of messages currently in a queue. It is a convenience\n         function that just calls Client. get_queue and returns the messages field from the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the number of messages currently sitting in a vhost or all queues in a vhost.", "response": "def get_queue_depths(self, vhost, names=None):\n        \"\"\"\n        Get the number of messages currently sitting in either the queue\n        names listed in 'names', or all queues in 'vhost' if no 'names' are\n        given.\n\n        :param str vhost: Vhost where queues in 'names' live.\n        :param list names: OPTIONAL - Specific queues to show depths for. If\n                None, show depths for all queues in 'vhost'.\n        \"\"\"\n\n        vhost = quote(vhost, '')\n        if not names:\n            # get all queues in vhost\n            path = Client.urls['queues_by_vhost'] % vhost\n            queues = self._call(path, 'GET')\n            for queue in queues:\n                depth = queue['messages']\n                print(\"\\t%s: %s\" % (queue, depth))\n        else:\n            # get the named queues only.\n            for name in names:\n                depth = self.get_queue_depth(vhost, name)\n                print(\"\\t%s: %s\" % (name, depth))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef purge_queues(self, queues):\n        for name, vhost in queues:\n            vhost = quote(vhost, '')\n            name = quote(name, '')\n            path = Client.urls['purge_queue'] % (vhost, name)\n            self._call(path, 'DELETE')\n        return True", "response": "Purge all messages from one or more queues."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npurges all messages from a single queue.", "response": "def purge_queue(self, vhost, name):\n        \"\"\"\n        Purge all messages from a single queue. This is a convenience method\n        so you aren't forced to supply a list containing a single tuple to\n        the purge_queues method.\n\n        :param string vhost: The vhost of the queue being purged.\n        :param string name: The name of the queue being purged.\n        :rtype: None\n\n        \"\"\"\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['purge_queue'] % (vhost, name)\n        return self._call(path, 'DELETE')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new queue in the specified vhost and name.", "response": "def create_queue(self, vhost, name, **kwargs):\n        \"\"\"\n        Create a queue. The API documentation specifies that all of the body\n        elements are optional, so this method only requires arguments needed\n        to form the URI\n\n        :param string vhost: The vhost to create the queue in.\n        :param string name: The name of the queue\n\n        More on these operations can be found at:\n        http://www.rabbitmq.com/amqp-0-9-1-reference.html\n\n        \"\"\"\n\n        vhost = quote(vhost, '')\n        name = quote(name, '')\n        path = Client.urls['queues_by_name'] % (vhost, name)\n\n        body = json.dumps(kwargs)\n\n        return self._call(path,\n                                 'PUT',\n                                 body,\n                                 headers=Client.json_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_queue(self, vhost, qname):\n        vhost = quote(vhost, '')\n        qname = quote(qname, '')\n        path = Client.urls['queues_by_name'] % (vhost, qname)\n        return self._call(path, 'DELETE', headers=Client.json_headers)", "response": "Deletes the named queue from the named vhost."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_connections(self):\n        path = Client.urls['all_connections']\n        conns = self._call(path, 'GET')\n        return conns", "response": "Returns a list of dicts containing the current connection information for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a connection by name. To get the names use get_connections.", "response": "def get_connection(self, name):\n        \"\"\"\n        Get a connection by name. To get the names, use get_connections.\n\n        :param string name: Name of connection to get\n        :returns dict conn: A connection attribute dictionary.\n\n        \"\"\"\n        name = quote(name, '')\n        path = Client.urls['connections_by_name'] % name\n        conn = self._call(path, 'GET')\n        return conn"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_connection(self, name):\n        name = quote(name, '')\n        path = Client.urls['connections_by_name'] % name\n        self._call(path, 'DELETE')\n        return True", "response": "Close the named connection."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of dicts containing details about broker connections.", "response": "def get_channels(self):\n        \"\"\"\n        Return a list of dicts containing details about broker connections.\n        :returns: list of dicts\n        \"\"\"\n        path = Client.urls['all_channels']\n        chans = self._call(path, 'GET')\n        return chans"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a channel by name. To get the names use get_channels.", "response": "def get_channel(self, name):\n        \"\"\"\n        Get a channel by name. To get the names, use get_channels.\n\n        :param string name: Name of channel to get\n        :returns dict conn: A channel attribute dictionary.\n\n        \"\"\"\n        name = quote(name, '')\n        path = Client.urls['channels_by_name'] % name\n        chan = self._call(path, 'GET')\n        return chan"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bindings(self):\n        path = Client.urls['all_bindings']\n        bindings = self._call(path, 'GET')\n        return bindings", "response": "Returns a list of dicts containing all the bindings for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of dicts one dict per binding per queue.", "response": "def get_queue_bindings(self, vhost, qname):\n        \"\"\"\n        Return a list of dicts, one dict per binding. The dict format coming\n        from RabbitMQ for queue named 'testq' is:\n\n        {\"source\":\"sourceExch\",\"vhost\":\"/\",\"destination\":\"testq\",\n         \"destination_type\":\"queue\",\"routing_key\":\"*.*\",\"arguments\":{},\n         \"properties_key\":\"%2A.%2A\"}\n        \"\"\"\n        vhost = quote(vhost, '')\n        qname = quote(qname, '')\n        path = Client.urls['bindings_on_queue'] % (vhost, qname)\n        bindings = self._call(path, 'GET')\n        return bindings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_binding(self, vhost, exchange, queue, rt_key=None, args=None):\n\n        vhost = quote(vhost, '')\n        exchange = quote(exchange, '')\n        queue = quote(queue, '')\n        body = json.dumps({'routing_key': rt_key, 'arguments': args or []})\n        path = Client.urls['bindings_between_exch_queue'] % (vhost,\n                                                             exchange,\n                                                             queue)\n        binding = self._call(path, 'POST', body=body,\n                                    headers=Client.json_headers)\n        return binding", "response": "Creates a binding between an exchange and a queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a binding between an exchange and a queue on a given vhost.", "response": "def delete_binding(self, vhost, exchange, queue, rt_key):\n        \"\"\"\n        Deletes a binding between an exchange and a queue on a given vhost.\n\n        :param string vhost: vhost housing the exchange/queue to bind\n        :param string exchange: the target exchange of the binding\n        :param string queue: the queue to bind to the exchange\n        :param string rt_key: the routing key to use for the binding\n        \"\"\"\n\n        vhost = quote(vhost, '')\n        exchange = quote(exchange, '')\n        queue = quote(queue, '')\n        body = ''\n        path = Client.urls['rt_bindings_between_exch_queue'] % (vhost,\n                                                                exchange,\n                                                                queue,\n                                                                rt_key)\n        return self._call(path, 'DELETE', headers=Client.json_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a user. :param string username: The name to give to the new user :param string password: Password for the new user :param string tags: Comma-separated list of tags for the user :returns: boolean", "response": "def create_user(self, username, password, tags=\"\"):\n        \"\"\"\n        Creates a user.\n\n        :param string username: The name to give to the new user\n        :param string password: Password for the new user\n        :param string tags: Comma-separated list of tags for the user\n        :returns: boolean\n        \"\"\"\n        path = Client.urls['users_by_name'] % username\n        body = json.dumps({'password': password, 'tags': tags})\n        return self._call(path, 'PUT', body=body,\n                                 headers=Client.json_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a user from the server.", "response": "def delete_user(self, username):\n        \"\"\"\n        Deletes a user from the server.\n\n        :param string username: Name of the user to delete from the server.\n        \"\"\"\n        path = Client.urls['users_by_name'] % username\n        return self._call(path, 'DELETE')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nredirects to the default wiki index name.", "response": "def index(request):\n    \"\"\"\n    Redirects to the default wiki index name.\n    \"\"\"\n    kwargs = {'slug': getattr(settings, 'WAKAWAKA_DEFAULT_INDEX', 'WikiIndex')}\n    redirect_to = reverse('wakawaka_page', kwargs=kwargs)\n    return HttpResponseRedirect(redirect_to)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef page(\n    request,\n    slug,\n    rev_id=None,\n    template_name='wakawaka/page.html',\n    extra_context=None,\n):\n    \"\"\"\n    Displays a wiki page. Redirects to the edit view if the page doesn't exist.\n    \"\"\"\n    try:\n        queryset = WikiPage.objects.all()\n        page = queryset.get(slug=slug)\n        rev = page.current\n\n        # Display an older revision if rev_id is given\n        if rev_id:\n            revision_queryset = Revision.objects.all()\n            rev_specific = revision_queryset.get(pk=rev_id)\n            if rev.pk != rev_specific.pk:\n                rev_specific.is_not_current = True\n            rev = rev_specific\n\n    # The Page does not exist, redirect to the edit form or\n    # deny, if the user has no permission to add pages\n    except WikiPage.DoesNotExist:\n        if request.user.is_authenticated:\n            kwargs = {'slug': slug}\n            redirect_to = reverse('wakawaka_edit', kwargs=kwargs)\n            return HttpResponseRedirect(redirect_to)\n        raise Http404\n    template_context = {'page': page, 'rev': rev}\n    template_context.update(extra_context or {})\n    return render(request, template_name, template_context)", "response": "Displays a wiki page."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying the form for editing and deleting a page.", "response": "def edit(\n    request,\n    slug,\n    rev_id=None,\n    template_name='wakawaka/edit.html',\n    extra_context=None,\n    wiki_page_form=WikiPageForm,\n    wiki_delete_form=DeleteWikiPageForm,\n):\n    \"\"\"\n    Displays the form for editing and deleting a page.\n    \"\"\"\n    # Get the page for slug and get a specific revision, if given\n    try:\n        queryset = WikiPage.objects.all()\n        page = queryset.get(slug=slug)\n        rev = page.current\n        initial = {'content': page.current.content}\n\n        # Do not allow editing wiki pages if the user has no permission\n        if not request.user.has_perms(\n            ('wakawaka.change_wikipage', 'wakawaka.change_revision')\n        ):\n            return HttpResponseForbidden(\n                ugettext('You don\\'t have permission to edit pages.')\n            )\n\n        if rev_id:\n            # There is a specific revision, fetch this\n            rev_specific = Revision.objects.get(pk=rev_id)\n            if rev.pk != rev_specific.pk:\n                rev = rev_specific\n                rev.is_not_current = True\n                initial = {\n                    'content': rev.content,\n                    'message': _('Reverted to \"%s\"' % rev.message),\n                }\n\n    # This page does not exist, create a dummy page\n    # Note that it's not saved here\n    except WikiPage.DoesNotExist:\n\n        # Do not allow adding wiki pages if the user has no permission\n        if not request.user.has_perms(\n            ('wakawaka.add_wikipage', 'wakawaka.add_revision')\n        ):\n            return HttpResponseForbidden(\n                ugettext('You don\\'t have permission to add wiki pages.')\n            )\n\n        page = WikiPage(slug=slug)\n        page.is_initial = True\n        rev = None\n        initial = {\n            'content': _('Describe your new page %s here...' % slug),\n            'message': _('Initial revision'),\n        }\n\n    # Don't display the delete form if the user has nor permission\n    delete_form = None\n    # The user has permission, then do\n    if request.user.has_perm(\n        'wakawaka.delete_wikipage'\n    ) or request.user.has_perm('wakawaka.delete_revision'):\n        delete_form = wiki_delete_form(request)\n        if request.method == 'POST' and request.POST.get('delete'):\n            delete_form = wiki_delete_form(request, request.POST)\n            if delete_form.is_valid():\n                return delete_form.delete_wiki(request, page, rev)\n\n    # Page add/edit form\n    form = wiki_page_form(initial=initial)\n    if request.method == 'POST':\n        form = wiki_page_form(data=request.POST)\n        if form.is_valid():\n            # Check if the content is changed, except there is a rev_id and the\n            # user possibly only reverted the HEAD to it\n            if (\n                not rev_id\n                and initial['content'] == form.cleaned_data['content']\n            ):\n                form.errors['content'] = (_('You have made no changes!'),)\n\n            # Save the form and redirect to the page view\n            else:\n                try:\n                    # Check that the page already exist\n                    queryset = WikiPage.objects.all()\n                    page = queryset.get(slug=slug)\n                except WikiPage.DoesNotExist:\n                    # Must be a new one, create that page\n                    page = WikiPage(slug=slug)\n                    page.save()\n\n                form.save(request, page)\n\n                kwargs = {'slug': page.slug}\n\n                redirect_to = reverse('wakawaka_page', kwargs=kwargs)\n                messages.success(\n                    request,\n                    ugettext('Your changes to %s were saved' % page.slug),\n                )\n                return HttpResponseRedirect(redirect_to)\n\n    template_context = {\n        'form': form,\n        'delete_form': delete_form,\n        'page': page,\n        'rev': rev,\n    }\n    template_context.update(extra_context or {})\n    return render(request, template_name, template_context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisplays the list of all revisions for a specific WikiPage", "response": "def revisions(\n    request, slug, template_name='wakawaka/revisions.html', extra_context=None\n):\n    \"\"\"\n    Displays the list of all revisions for a specific WikiPage\n    \"\"\"\n    queryset = WikiPage.objects.all()\n    page = get_object_or_404(queryset, slug=slug)\n\n    template_context = {'page': page}\n    template_context.update(extra_context or {})\n    return render(request, template_name, template_context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisplays the changes between two revisions.", "response": "def changes(\n    request, slug, template_name='wakawaka/changes.html', extra_context=None\n):\n    \"\"\"\n    Displays the changes between two revisions.\n    \"\"\"\n    rev_a_id = request.GET.get('a', None)\n    rev_b_id = request.GET.get('b', None)\n\n    # Some stinky fingers manipulated the url\n    if not rev_a_id or not rev_b_id:\n        return HttpResponseBadRequest('Bad Request')\n\n    try:\n        revision_queryset = Revision.objects.all()\n        wikipage_queryset = WikiPage.objects.all()\n        rev_a = revision_queryset.get(pk=rev_a_id)\n        rev_b = revision_queryset.get(pk=rev_b_id)\n        page = wikipage_queryset.get(slug=slug)\n    except ObjectDoesNotExist:\n        raise Http404\n\n    if rev_a.content != rev_b.content:\n        d = difflib.unified_diff(\n            rev_b.content.splitlines(),\n            rev_a.content.splitlines(),\n            'Original',\n            'Current',\n            lineterm='',\n        )\n        difftext = '\\n'.join(d)\n    else:\n        difftext = _(u'No changes were made between this two files.')\n\n    template_context = {\n        'page': page,\n        'diff': difftext,\n        'rev_a': rev_a,\n        'rev_b': rev_b,\n    }\n    template_context.update(extra_context or {})\n    return render(request, template_name, template_context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef revision_list(\n    request, template_name='wakawaka/revision_list.html', extra_context=None\n):\n    \"\"\"\n    Displays a list of all recent revisions.\n    \"\"\"\n    revision_list = Revision.objects.all()\n    template_context = {'revision_list': revision_list}\n    template_context.update(extra_context or {})\n    return render(request, template_name, template_context)", "response": "Displays a list of all recent revisions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_wiki(self, request, page, rev):\n\n        # Delete the page\n        if (\n            self.cleaned_data.get('delete') == 'page'\n            and request.user.has_perm('wakawaka.delete_revision')\n            and request.user.has_perm('wakawaka.delete_wikipage')\n        ):\n            self._delete_page(page)\n            messages.success(\n                request, ugettext('The page %s was deleted' % page.slug)\n            )\n            return HttpResponseRedirect(reverse('wakawaka_index'))\n\n        # Revision handling\n        if self.cleaned_data.get('delete') == 'rev':\n\n            revision_length = len(page.revisions.all())\n\n            # Delete the revision if there are more than 1 and the user has permission\n            if revision_length > 1 and request.user.has_perm(\n                'wakawaka.delete_revision'\n            ):\n                self._delete_revision(rev)\n                messages.success(\n                    request,\n                    ugettext('The revision for %s was deleted' % page.slug),\n                )\n                return HttpResponseRedirect(\n                    reverse('wakawaka_page', kwargs={'slug': page.slug})\n                )\n\n            # Do not allow deleting the revision, if it's the only one and the user\n            # has no permisson to delete the page.\n            if revision_length <= 1 and not request.user.has_perm(\n                'wakawaka.delete_wikipage'\n            ):\n                messages.error(\n                    request,\n                    ugettext(\n                        'You can not delete this revison for %s because it\\'s the '\n                        'only one and you have no permission to delete the whole page.'\n                        % page.slug\n                    ),\n                )\n                return HttpResponseRedirect(\n                    reverse('wakawaka_page', kwargs={'slug': page.slug})\n                )\n\n            # Delete the page and the revision if the user has both permissions\n            if (\n                revision_length <= 1\n                and request.user.has_perm('wakawaka.delete_revision')\n                and request.user.has_perm('wakawaka.delete_wikipage')\n            ):\n                self._delete_page(page)\n                messages.success(\n                    request,\n                    ugettext(\n                        'The page for %s was deleted because you deleted the only revision'\n                        % page.slug\n                    ),\n                )\n                return HttpResponseRedirect(reverse('wakawaka_index'))", "response": "Delete the wiki page with all revisions or the revision."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_real_field(model, field_name):\n    '''\n    Get the real field from a model given its name.\n\n    Handle nested models recursively (aka. ``__`` lookups)\n    '''\n    parts = field_name.split('__')\n    field = model._meta.get_field(parts[0])\n    if len(parts) == 1:\n        return model._meta.get_field(field_name)\n    elif isinstance(field, models.ForeignKey):\n        return get_real_field(field.rel.to, '__'.join(parts[1:]))\n    else:\n        raise Exception('Unhandled field: %s' % field_name)", "response": "Get the real field from a model given its name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_regex(self, field):\n        '''Test if a given field supports regex lookups'''\n        from django.conf import settings\n        if settings.DATABASES['default']['ENGINE'].endswith('sqlite3'):\n            return not isinstance(get_real_field(self.model, field), UNSUPPORTED_REGEX_FIELDS)\n        else:\n            return True", "response": "Test if a given field supports regex lookups"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_orders(self):\n        '''Get ordering fields for ``QuerySet.order_by``'''\n        orders = []\n        iSortingCols = self.dt_data['iSortingCols']\n        dt_orders = [(self.dt_data['iSortCol_%s' % i], self.dt_data['sSortDir_%s' % i]) for i in xrange(iSortingCols)]\n        for field_idx, field_dir in dt_orders:\n            direction = '-' if field_dir == DESC else ''\n            if hasattr(self, 'sort_col_%s' % field_idx):\n                method = getattr(self, 'sort_col_%s' % field_idx)\n                result = method(direction)\n                if isinstance(result, (bytes, text_type)):\n                    orders.append(result)\n                else:\n                    orders.extend(result)\n            else:\n                field = self.get_field(field_idx)\n                if RE_FORMATTED.match(field):\n                    tokens = RE_FORMATTED.findall(field)\n                    orders.extend(['%s%s' % (direction, token) for token in tokens])\n                else:\n                    orders.append('%s%s' % (direction, field))\n        return orders", "response": "Get ordering fields for QuerySet. order_by"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters a queryset with global search", "response": "def global_search(self, queryset):\n        '''Filter a queryset with global search'''\n        search = self.dt_data['sSearch']\n        if search:\n            if self.dt_data['bRegex']:\n                criterions = [\n                    Q(**{'%s__iregex' % field: search})\n                    for field in self.get_db_fields()\n                    if self.can_regex(field)\n                ]\n                if len(criterions) > 0:\n                    search = reduce(or_, criterions)\n                    queryset = queryset.filter(search)\n            else:\n                for term in search.split():\n                    criterions = (Q(**{'%s__icontains' % field: term}) for field in self.get_db_fields())\n                    search = reduce(or_, criterions)\n                    queryset = queryset.filter(search)\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef column_search(self, queryset):\n        '''Filter a queryset with column search'''\n        for idx in xrange(self.dt_data['iColumns']):\n            search = self.dt_data['sSearch_%s' % idx]\n            if search:\n                if hasattr(self, 'search_col_%s' % idx):\n                    custom_search = getattr(self, 'search_col_%s' % idx)\n                    queryset = custom_search(search, queryset)\n                else:\n                    field = self.get_field(idx)\n                    fields = RE_FORMATTED.findall(field) if RE_FORMATTED.match(field) else [field]\n                    if self.dt_data['bRegex_%s' % idx]:\n                        criterions = [Q(**{'%s__iregex' % field: search}) for field in fields if self.can_regex(field)]\n                        if len(criterions) > 0:\n                            search = reduce(or_, criterions)\n                            queryset = queryset.filter(search)\n                    else:\n                        for term in search.split():\n                            criterions = (Q(**{'%s__icontains' % field: term}) for field in fields)\n                            search = reduce(or_, criterions)\n                            queryset = queryset.filter(search)\n        return queryset", "response": "Filter a queryset with column search"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying Datatables sort and search criterion to QuerySet", "response": "def get_queryset(self):\n        '''Apply Datatables sort and search criterion to QuerySet'''\n        qs = super(DatatablesView, self).get_queryset()\n        # Perform global search\n        qs = self.global_search(qs)\n        # Perform column search\n        qs = self.column_search(qs)\n        # Return the ordered queryset\n        return qs.order_by(*self.get_orders())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the requested page", "response": "def get_page(self, form):\n        '''Get the requested page'''\n        page_size = form.cleaned_data['iDisplayLength']\n        start_index = form.cleaned_data['iDisplayStart']\n        paginator = Paginator(self.object_list, page_size)\n        num_page = (start_index / page_size) + 1\n        return paginator.page(num_page)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting a single row ( if necessary )", "response": "def get_row(self, row):\n        '''Format a single row (if necessary)'''\n\n        if isinstance(self.fields, dict):\n            return dict([\n                (key, text_type(value).format(**row) if RE_FORMATTED.match(value) else row[value])\n                for key, value in self.fields.items()\n            ])\n        else:\n            return [text_type(field).format(**row) if RE_FORMATTED.match(field)\n                    else row[field]\n                    for field in self.fields]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_to_response(self, form, **kwargs):\n        '''Render Datatables expected JSON format'''\n        page = self.get_page(form)\n        data = {\n            'iTotalRecords': page.paginator.count,\n            'iTotalDisplayRecords': page.paginator.count,\n            'sEcho': form.cleaned_data['sEcho'],\n            'aaData': self.get_rows(page.object_list),\n        }\n        return self.json_response(data)", "response": "Render Datatables expected JSON format"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_grant_type(self, grant_type = 'client_credentials', api_key=None, api_secret=None, scope=None, info=None):\n\n        \"\"\"\n        Grant types:\n         - token:\n            An authorization is requested to the end-user by redirecting it to an authorization page hosted\n            on Dailymotion. Once authorized, a refresh token is requested by the API client to the token\n            server and stored in the end-user's cookie (or other storage technique implemented by subclasses).\n            The refresh token is then used to request time limited access token to the token server.\n\n        - none / client_credentials:\n            This grant type is a 2 legs authentication: it doesn't allow to act on behalf of another user.\n            With this grant type, all API requests will be performed with the user identity of the API key owner.\n\n        - password:\n            This grant type allows to authenticate end-user by directly providing its credentials.\n            This profile is highly discouraged for web-server workflows. If used, the username and password\n            MUST NOT be stored by the client.\n        \"\"\"\n\n        self.access_token = None\n\n        if api_key and api_secret:\n            self._grant_info['key'] = api_key\n            self._grant_info['secret'] = api_secret\n        else:\n            raise DailymotionClientError('Missing API key/secret')\n\n        if isinstance(info, dict):\n            self._grant_info.update(info)\n        else:\n            info = {}\n\n        if self._session_store_enabled and isinstance(info, dict) and info.get('username') is not None:\n            self._session_store.set_user(info.get('username'))\n\n        if grant_type in ('authorization', 'token'):\n            grant_type = 'authorization'\n            if 'redirect_uri' not in info:\n                raise DailymotionClientError('Missing redirect_uri in grant info for token grant type.')\n        elif grant_type in ('client_credentials', 'none'):\n            grant_type = 'client_credentials'\n        elif grant_type == 'password':\n            if 'username' not in info or 'password' not in info:\n                raise DailymotionClientError('Missing username or password in grant info for password grant type.')\n\n        self._grant_type = grant_type\n\n        if scope:\n            if not isinstance(scope, (list, tuple)):\n                raise DailymotionClientError('Invalid scope type: must be a list of valid scopes')\n            self._grant_info['scope'] = scope", "response": "Sets the grant type of the current user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef urljoin(*parts):\n    # first strip extra forward slashes (except http:// and the likes) and\n    # create list\n    part_list = []\n    for part in parts:\n        p = str(part)\n        if p.endswith('//'):\n            p = p[0:-1]\n        else:\n            p = p.strip('/')\n        part_list.append(p)\n    # join everything together\n    url = '/'.join(part_list)\n    return url", "response": "Join terms together with forward slashes except http:// and likes"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nauthenticates a user and password.", "response": "def authenticate(self, username, password):\n        \"\"\"\n        Uses a Smappee username and password to request an access token,\n        refresh token and expiry date.\n\n        Parameters\n        ----------\n        username : str\n        password : str\n\n        Returns\n        -------\n        requests.Response\n            access token is saved in self.access_token\n            refresh token is saved in self.refresh_token\n            expiration time is set in self.token_expiration_time as\n            datetime.datetime\n        \"\"\"\n        url = URLS['token']\n        data = {\n            \"grant_type\": \"password\",\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"username\": username,\n            \"password\": password\n        }\n        r = requests.post(url, data=data)\n        r.raise_for_status()\n        j = r.json()\n        self.access_token = j['access_token']\n        self.refresh_token = j['refresh_token']\n        self._set_token_expiration_time(expires_in=j['expires_in'])\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_token_expiration_time(self, expires_in):\n        self.token_expiration_time = dt.datetime.utcnow() + \\\n            dt.timedelta(0, expires_in)", "response": "Sets the token expiration time in the internal datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting service locations Returns ------- dict", "response": "def get_service_locations(self):\n        \"\"\"\n        Request service locations\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        url = URLS['servicelocation']\n        headers = {\"Authorization\": \"Bearer {}\".format(self.access_token)}\n        r = requests.get(url, headers=headers)\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests service location info", "response": "def get_service_location_info(self, service_location_id):\n        \"\"\"\n        Request service location info\n\n        Parameters\n        ----------\n        service_location_id : int\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        url = urljoin(URLS['servicelocation'], service_location_id, \"info\")\n        headers = {\"Authorization\": \"Bearer {}\".format(self.access_token)}\n        r = requests.get(url, headers=headers)\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting Elektricity consumption and Solar production of a given service location.", "response": "def get_consumption(self, service_location_id, start, end, aggregation, raw=False):\n        \"\"\"\n        Request Elektricity consumption and Solar production\n        for a given service location.\n\n        Parameters\n        ----------\n        service_location_id : int\n        start : int | dt.datetime | pd.Timestamp\n        end : int | dt.datetime | pd.Timestamp\n            start and end support epoch (in milliseconds),\n            datetime and Pandas Timestamp\n        aggregation : int\n            1 = 5 min values (only available for the last 14 days)\n            2 = hourly values\n            3 = daily values\n            4 = monthly values\n            5 = quarterly values\n        raw : bool\n            default False\n            if True: Return the data \"as is\" from the server\n            if False: convert the 'alwaysOn' value to Wh.\n            (the server returns this value as the sum of the power,\n            measured in 5 minute blocks. This means that it is 12 times\n            higher than the consumption in Wh.\n            See https://github.com/EnergieID/smappy/issues/24)\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        url = urljoin(URLS['servicelocation'], service_location_id,\n                      \"consumption\")\n        d = self._get_consumption(url=url, start=start, end=end,\n                                  aggregation=aggregation)\n        if not raw:\n            for block in d['consumptions']:\n                if 'alwaysOn' not in block.keys():\n                    break\n                block.update({'alwaysOn': block['alwaysOn'] / 12})\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_sensor_consumption(self, service_location_id, sensor_id, start,\n                               end, aggregation):\n        \"\"\"\n        Request consumption for a given sensor in a given service location\n\n        Parameters\n        ----------\n        service_location_id : int\n        sensor_id : int\n        start : int | dt.datetime | pd.Timestamp\n        end : int | dt.datetime | pd.Timestamp\n            start and end support epoch (in milliseconds),\n            datetime and Pandas Timestamp\n            timezone-naive datetimes are assumed to be in UTC\n        aggregation : int\n            1 = 5 min values (only available for the last 14 days)\n            2 = hourly values\n            3 = daily values\n            4 = monthly values\n            5 = quarterly values\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        url = urljoin(URLS['servicelocation'], service_location_id, \"sensor\",\n                      sensor_id, \"consumption\")\n        return self._get_consumption(url=url, start=start, end=end,\n                                     aggregation=aggregation)", "response": "Request consumption for a given sensor in a given service location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting for both the get_consumption and get_sensor_consumption methods.", "response": "def _get_consumption(self, url, start, end, aggregation):\n        \"\"\"\n        Request for both the get_consumption and\n        get_sensor_consumption methods.\n\n        Parameters\n        ----------\n        url : str\n        start : dt.datetime\n        end : dt.datetime\n        aggregation : int\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        start = self._to_milliseconds(start)\n        end = self._to_milliseconds(end)\n\n        headers = {\"Authorization\": \"Bearer {}\".format(self.access_token)}\n        params = {\n            \"aggregation\": aggregation,\n            \"from\": start,\n            \"to\": end\n        }\n        r = requests.get(url, headers=headers, params=params)\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests events for a given appliance and return a dictionary of events.", "response": "def get_events(self, service_location_id, appliance_id, start, end,\n                   max_number=None):\n        \"\"\"\n        Request events for a given appliance\n\n        Parameters\n        ----------\n        service_location_id : int\n        appliance_id : int\n        start : int | dt.datetime | pd.Timestamp\n        end : int | dt.datetime | pd.Timestamp\n            start and end support epoch (in milliseconds),\n            datetime and Pandas Timestamp\n            timezone-naive datetimes are assumed to be in UTC\n        max_number : int, optional\n            The maximum number of events that should be returned by this query\n            Default returns all events in the selected period\n\n        Returns\n        -------\n        dict\n        \"\"\"\n        start = self._to_milliseconds(start)\n        end = self._to_milliseconds(end)\n\n        url = urljoin(URLS['servicelocation'], service_location_id, \"events\")\n        headers = {\"Authorization\": \"Bearer {}\".format(self.access_token)}\n        params = {\n            \"from\": start,\n            \"to\": end,\n            \"applianceId\": appliance_id,\n            \"maxNumber\": max_number\n        }\n        r = requests.get(url, headers=headers, params=params)\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef actuator_on(self, service_location_id, actuator_id, duration=None):\n        return self._actuator_on_off(\n            on_off='on', service_location_id=service_location_id,\n            actuator_id=actuator_id, duration=duration)", "response": "Turn actuator on for a specific action."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns actuator off for a specific action.", "response": "def actuator_off(self, service_location_id, actuator_id, duration=None):\n        \"\"\"\n        Turn actuator off\n\n        Parameters\n        ----------\n        service_location_id : int\n        actuator_id : int\n        duration : int, optional\n            300,900,1800 or 3600 , specifying the time in seconds the actuator\n            should be turned on. Any other value results in turning on for an\n            undetermined period of time.\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n        return self._actuator_on_off(\n            on_off='off', service_location_id=service_location_id,\n            actuator_id=actuator_id, duration=duration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _actuator_on_off(self, on_off, service_location_id, actuator_id,\n                         duration=None):\n        \"\"\"\n        Turn actuator on or off\n\n        Parameters\n        ----------\n        on_off : str\n            'on' or 'off'\n        service_location_id : int\n        actuator_id : int\n        duration : int, optional\n            300,900,1800 or 3600 , specifying the time in seconds the actuator\n            should be turned on. Any other value results in turning on for an\n            undetermined period of time.\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n        url = urljoin(URLS['servicelocation'], service_location_id,\n                      \"actuator\", actuator_id, on_off)\n        headers = {\"Authorization\": \"Bearer {}\".format(self.access_token)}\n        if duration is not None:\n            data = {\"duration\": duration}\n        else:\n            data = {}\n        r = requests.post(url, headers=headers, json=data)\n        r.raise_for_status()\n        return r", "response": "Turn actuator on or off."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextend get_consumption() AND get_sensor_consumption(), parses the results in a Pandas DataFrame Parameters ---------- service_location_id : int start : dt.datetime | int end : dt.datetime | int timezone-naive datetimes are assumed to be in UTC epoch timestamps need to be in milliseconds aggregation : int sensor_id : int, optional If a sensor id is passed, api method get_sensor_consumption will be used otherwise (by default), the get_consumption method will be used: this returns Electricity and Solar consumption and production. localize : bool default False default returns timestamps in UTC if True, timezone is fetched from service location info and Data Frame is localized raw : bool default False if True: Return the data \"as is\" from the server if False: convert the 'alwaysOn' value to Wh. (the server returns this value as the sum of the power, measured in 5 minute blocks. This means that it is 12 times higher than the consumption in Wh. See https://github.com/EnergieID/smappy/issues/24) Returns ------- pd.DataFrame", "response": "def get_consumption_dataframe(self, service_location_id, start, end,\n                                  aggregation, sensor_id=None, localize=False,\n                                  raw=False):\n        \"\"\"\n        Extends get_consumption() AND get_sensor_consumption(),\n        parses the results in a Pandas DataFrame\n\n        Parameters\n        ----------\n        service_location_id : int\n        start : dt.datetime | int\n        end : dt.datetime | int\n            timezone-naive datetimes are assumed to be in UTC\n            epoch timestamps need to be in milliseconds\n        aggregation : int\n        sensor_id : int, optional\n            If a sensor id is passed, api method get_sensor_consumption will\n            be used otherwise (by default),\n            the get_consumption method will be used: this returns Electricity\n            and Solar consumption and production.\n        localize : bool\n            default False\n            default returns timestamps in UTC\n            if True, timezone is fetched from service location info and\n            Data Frame is localized\n        raw : bool\n            default False\n            if True: Return the data \"as is\" from the server\n            if False: convert the 'alwaysOn' value to Wh.\n            (the server returns this value as the sum of the power,\n            measured in 5 minute blocks. This means that it is 12 times\n            higher than the consumption in Wh.\n            See https://github.com/EnergieID/smappy/issues/24)\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        import pandas as pd\n\n        if sensor_id is None:\n            data = self.get_consumption(\n                service_location_id=service_location_id, start=start,\n                end=end, aggregation=aggregation, raw=raw)\n            consumptions = data['consumptions']\n        else:\n            data = self.get_sensor_consumption(\n                service_location_id=service_location_id, sensor_id=sensor_id,\n                start=start, end=end, aggregation=aggregation)\n            # yeah please someone explain me why they had to name this\n            # differently...\n            consumptions = data['records']\n\n        df = pd.DataFrame.from_dict(consumptions)\n        if not df.empty:\n            df.set_index('timestamp', inplace=True)\n            df.index = pd.to_datetime(df.index, unit='ms', utc=True)\n            if localize:\n                info = self.get_service_location_info(\n                    service_location_id=service_location_id)\n                timezone = info['timezone']\n                df = df.tz_convert(timezone)\n        return df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a datetime - like object to milliseconds since epoch", "response": "def _to_milliseconds(self, time):\n        \"\"\"\n        Converts a datetime-like object to epoch, in milliseconds\n        Timezone-naive datetime objects are assumed to be in UTC\n\n        Parameters\n        ----------\n        time : dt.datetime | pd.Timestamp | int\n\n        Returns\n        -------\n        int\n            epoch milliseconds\n        \"\"\"\n        if isinstance(time, dt.datetime):\n            if time.tzinfo is None:\n                time = time.replace(tzinfo=pytz.UTC)\n            return int(time.timestamp() * 1e3)\n        elif isinstance(time, numbers.Number):\n            return time\n        else:\n            raise NotImplementedError(\"Time format not supported. Use milliseconds since epoch,\\\n                                        Datetime or Pandas Datetime\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef active_cosfi(self):\n        inst = self.load_instantaneous()\n        values = [float(i['value']) for i in inst if i['key'].endswith('Cosfi')]\n        return sum(values) / len(values)", "response": "Returns the average of all instantaneous cosfi values Returns a float"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a control command to get the current value of the current key.", "response": "def on_command_control(self, val_id):\n        \"\"\"\n        Parameters\n        ----------\n        val_id : str\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n        data = \"control,controlId=1|\" + val_id\n        return self._basic_post(url='commandControlPublic', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a command to set the current control ID to 0", "response": "def off_command_control(self, val_id):\n        \"\"\"\n        Parameters\n        ----------\n        val_id : str\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n        data = \"control,controlId=0|\" + val_id\n        return self._basic_post(url='commandControlPublic', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a specific control from the current node.", "response": "def delete_command_control(self, val_id):\n        \"\"\"\n        Parameters\n        ----------\n        val_id : str\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n\n        data = \"delete,controlId=\" + val_id\n        return self._basic_post(url='commandControlPublic', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes the control timer for the specified control ID.", "response": "def delete_command_control_timers(self, val_id):\n        \"\"\"\n        Parameters\n        ----------\n        val_id : str\n\n        Returns\n        -------\n        requests.Response\n        \"\"\"\n        data = \"deleteTimers,controlId=\" + val_id\n        return self._basic_post(url='commandControlPublic', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_logfile(self, logfile):\n        data = 'logFileSelect,' + logfile\n        r = self._basic_post(url='logBrowser', data=data)\n        return r.json()", "response": "Select a logfile from the logBrowser."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a tree of similar fs hs and ss interfaces for all speeds.", "response": "def getInterfaceInAllSpeeds(interface, endpoint_list, class_descriptor_list=()):\n    \"\"\"\n    Produce similar fs, hs and ss interface and endpoints descriptors.\n    Should be useful for devices desiring to work in all 3 speeds with maximum\n    endpoint wMaxPacketSize. Reduces data duplication from descriptor\n    declarations.\n    Not intended to cover fancy combinations.\n\n    interface (dict):\n      Keyword arguments for\n        getDescriptor(USBInterfaceDescriptor, ...)\n      in all speeds.\n      bNumEndpoints must not be provided.\n    endpoint_list (list of dicts)\n      Each dict represents an endpoint, and may contain the following items:\n      - \"endpoint\": required, contains keyword arguments for\n          getDescriptor(USBEndpointDescriptorNoAudio, ...)\n        or\n          getDescriptor(USBEndpointDescriptor, ...)\n        The with-audio variant is picked when its extra fields are assigned a\n        value.\n        wMaxPacketSize may be missing, in which case it will be set to the\n        maximum size for given speed and endpoint type.\n        bmAttributes must be provided.\n        If bEndpointAddress is zero (excluding direction bit) on the first\n        endpoint, endpoints will be assigned their rank in this list,\n        starting at 1. Their direction bit is preserved.\n        If bInterval is present on a INT or ISO endpoint, it must be in\n        millisecond units (but may not be an integer), and will be converted\n        to the nearest integer millisecond for full-speed descriptor, and\n        nearest possible interval for high- and super-speed descriptors.\n        If bInterval is present on a BULK endpoint, it is set to zero on\n        full-speed descriptor and used as provided on high- and super-speed\n        descriptors.\n      - \"superspeed\": optional, contains keyword arguments for\n          getDescriptor(USBSSEPCompDescriptor, ...)\n      - \"superspeed_iso\": optional, contains keyword arguments for\n          getDescriptor(USBSSPIsocEndpointDescriptor, ...)\n        Must be provided and non-empty only when endpoint is isochronous and\n        \"superspeed\" dict has \"bmAttributes\" bit 7 set.\n    class_descriptor (list of descriptors of any type)\n      Descriptors to insert in all speeds between the interface descriptor and\n      endpoint descriptors.\n\n    Returns a 3-tuple of lists:\n    - fs descriptors\n    - hs descriptors\n    - ss descriptors\n    \"\"\"\n    interface = getDescriptor(\n        USBInterfaceDescriptor,\n        bNumEndpoints=len(endpoint_list),\n        **interface\n    )\n    class_descriptor_list = list(class_descriptor_list)\n    fs_list = [interface] + class_descriptor_list\n    hs_list = [interface] + class_descriptor_list\n    ss_list = [interface] + class_descriptor_list\n    need_address = (\n        endpoint_list[0]['endpoint'].get(\n            'bEndpointAddress',\n            0,\n        ) & ~ch9.USB_DIR_IN == 0\n    )\n    for index, endpoint in enumerate(endpoint_list, 1):\n        endpoint_kw = endpoint['endpoint'].copy()\n        transfer_type = endpoint_kw[\n            'bmAttributes'\n        ] & ch9.USB_ENDPOINT_XFERTYPE_MASK\n        fs_max, hs_max, ss_max = _MAX_PACKET_SIZE_DICT[transfer_type]\n        if need_address:\n            endpoint_kw['bEndpointAddress'] = index | (\n                endpoint_kw.get('bEndpointAddress', 0) & ch9.USB_DIR_IN\n            )\n        klass = (\n            USBEndpointDescriptor\n            if 'bRefresh' in endpoint_kw or 'bSynchAddress' in endpoint_kw else\n            USBEndpointDescriptorNoAudio\n        )\n        interval = endpoint_kw.pop('bInterval', _MARKER)\n        if interval is _MARKER:\n            fs_interval = hs_interval = 0\n        else:\n            if transfer_type == ch9.USB_ENDPOINT_XFER_BULK:\n                fs_interval = 0\n                hs_interval = interval\n            else: # USB_ENDPOINT_XFER_ISOC or USB_ENDPOINT_XFER_INT\n                fs_interval = max(1, min(255, round(interval)))\n                # 8 is the number of microframes in a millisecond\n                hs_interval = max(\n                    1,\n                    min(16, int(round(1 + math.log(interval * 8, 2)))),\n                )\n        packet_size = endpoint_kw.pop('wMaxPacketSize', _MARKER)\n        if packet_size is _MARKER:\n            fs_packet_size = fs_max\n            hs_packet_size = hs_max\n            ss_packet_size = ss_max\n        else:\n            fs_packet_size = min(fs_max, packet_size)\n            hs_packet_size = min(hs_max, packet_size)\n            ss_packet_size = min(ss_max, packet_size)\n        fs_list.append(getDescriptor(\n            klass,\n            wMaxPacketSize=fs_max,\n            bInterval=fs_interval,\n            **endpoint_kw\n        ))\n        hs_list.append(getDescriptor(\n            klass,\n            wMaxPacketSize=hs_max,\n            bInterval=hs_interval,\n            **endpoint_kw\n        ))\n        ss_list.append(getDescriptor(\n            klass,\n            wMaxPacketSize=ss_max,\n            bInterval=hs_interval,\n            **endpoint_kw\n        ))\n        ss_companion_kw = endpoint.get('superspeed', _EMPTY_DICT)\n        ss_list.append(getDescriptor(\n            USBSSEPCompDescriptor,\n            **ss_companion_kw\n        ))\n        ssp_iso_kw = endpoint.get('superspeed_iso', _EMPTY_DICT)\n        if bool(ssp_iso_kw) != (\n            endpoint_kw.get('bmAttributes', 0) &\n            ch9.USB_ENDPOINT_XFERTYPE_MASK ==\n            ch9.USB_ENDPOINT_XFER_ISOC and\n            bool(ch9.USB_SS_SSP_ISOC_COMP(\n                ss_companion_kw.get('bmAttributes', 0),\n            ))\n        ):\n            raise ValueError('Inconsistent isochronous companion')\n        if ssp_iso_kw:\n            ss_list.append(getDescriptor(\n                USBSSPIsocEndpointDescriptor,\n                **ssp_iso_kw\n            ))\n    return (fs_list, hs_list, ss_list)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getDescriptor(klass, **kw):\n    # XXX: ctypes Structure.__init__ ignores arguments which do not exist\n    # as structure fields. So check it.\n    # This is annoying, but not doing it is a huge waste of time for the\n    # developer.\n    empty = klass()\n    assert hasattr(empty, 'bLength')\n    assert hasattr(empty, 'bDescriptorType')\n    unknown = [x for x in kw if not hasattr(empty, x)]\n    if unknown:\n        raise TypeError('Unknown fields %r' % (unknown, ))\n    # XXX: not very pythonic...\n    return klass(\n        bLength=ctypes.sizeof(klass),\n        # pylint: disable=protected-access\n        bDescriptorType=klass._bDescriptorType,\n        # pylint: enable=protected-access\n        **kw\n    )", "response": "Returns a new object of the given class with the given arguments filled with bLength and bDescriptorType."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getOSDesc(interface, ext_list):\n    try:\n        ext_type, = {type(x) for x in ext_list}\n    except ValueError:\n        raise TypeError('Extensions of a single type are required.')\n    if issubclass(ext_type, OSExtCompatDesc):\n        wIndex = 4\n        kw = {\n            'b': OSDescHeaderBCount(\n                bCount=len(ext_list),\n                Reserved=0,\n            ),\n        }\n    elif issubclass(ext_type, OSExtPropDescHead):\n        wIndex = 5\n        kw = {\n            'wCount': len(ext_list),\n        }\n    else:\n        raise TypeError('Extensions of unexpected type')\n    ext_list_type = ext_type * len(ext_list)\n    klass = type(\n        'OSDesc',\n        (OSDescHeader, ),\n        {\n            '_fields_': [\n                ('ext_list', ext_list_type),\n            ],\n        },\n    )\n    return klass(\n        interface=interface,\n        dwLength=ctypes.sizeof(klass),\n        bcdVersion=1,\n        wIndex=wIndex,\n        ext_list=ext_list_type(*ext_list),\n        **kw\n    )", "response": "Return an OSDesc header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getOSExtPropDesc(data_type, name, value):\n    klass = type(\n        'OSExtPropDesc',\n        (OSExtPropDescHead, ),\n        {\n            '_fields_': [\n                ('bPropertyName', ctypes.c_char * len(name)),\n                ('dwPropertyDataLength', le32),\n                ('bProperty', ctypes.c_char * len(value)),\n            ],\n        }\n    )\n    return klass(\n        dwSize=ctypes.sizeof(klass),\n        dwPropertyDataType=data_type,\n        wPropertyNameLength=len(name),\n        bPropertyName=name,\n        dwPropertyDataLength=len(value),\n        bProperty=value,\n    )", "response": "Returns an OS extension property descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getDescsV2(flags, fs_list=(), hs_list=(), ss_list=(), os_list=()):\n    count_field_list = []\n    descr_field_list = []\n    kw = {}\n    for descriptor_list, flag, prefix, allowed_descriptor_klass in (\n        (fs_list, HAS_FS_DESC, 'fs', USBDescriptorHeader),\n        (hs_list, HAS_HS_DESC, 'hs', USBDescriptorHeader),\n        (ss_list, HAS_SS_DESC, 'ss', USBDescriptorHeader),\n        (os_list, HAS_MS_OS_DESC, 'os', OSDescHeader),\n    ):\n        if descriptor_list:\n            for index, descriptor in enumerate(descriptor_list):\n                if not isinstance(descriptor, allowed_descriptor_klass):\n                    raise TypeError(\n                        'Descriptor %r of unexpected type: %r' % (\n                            index,\n                            type(descriptor),\n                        ),\n                    )\n            descriptor_map = [\n                ('desc_%i' % x, y)\n                for x, y in enumerate(descriptor_list)\n            ]\n            flags |= flag\n            count_name = prefix + 'count'\n            descr_name = prefix + 'descr'\n            count_field_list.append((count_name, le32))\n            descr_type = type(\n                't_' + descr_name,\n                (ctypes.LittleEndianStructure, ),\n                {\n                    '_pack_': 1,\n                    '_fields_': [\n                        (x, type(y))\n                        for x, y in descriptor_map\n                    ],\n                }\n            )\n            descr_field_list.append((descr_name, descr_type))\n            kw[count_name] = len(descriptor_map)\n            kw[descr_name] = descr_type(**dict(descriptor_map))\n        elif flags & flag:\n            raise ValueError(\n                'Flag %r set but descriptor list empty, cannot generate type.' % (\n                    FLAGS.get(flag),\n                )\n            )\n    klass = type(\n        'DescsV2_0x%02x' % (\n            flags & (\n                HAS_FS_DESC |\n                HAS_HS_DESC |\n                HAS_SS_DESC |\n                HAS_MS_OS_DESC\n            ),\n            # XXX: include contained descriptors type information ? (and name ?)\n        ),\n        (DescsHeadV2, ),\n        {\n            '_fields_': count_field_list + descr_field_list,\n        },\n    )\n    return klass(\n        magic=DESCRIPTORS_MAGIC_V2,\n        length=ctypes.sizeof(klass),\n        flags=flags,\n        **kw\n    )", "response": "Return a functionFS descriptor suitable for serialisation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a FunctionFS descriptor suitable for serialisation.", "response": "def getStrings(lang_dict):\n    \"\"\"\n    Return a FunctionFS descriptor suitable for serialisation.\n\n    lang_dict (dict)\n        Key: language ID (ex: 0x0409 for en-us)\n        Value: list of unicode objects\n        All values must have the same number of items.\n    \"\"\"\n    field_list = []\n    kw = {}\n    try:\n        str_count = len(next(iter(lang_dict.values())))\n    except StopIteration:\n        str_count = 0\n    else:\n        for lang, string_list in lang_dict.items():\n            if len(string_list) != str_count:\n                raise ValueError('All values must have the same string count.')\n            field_id = 'strings_%04x' % lang\n            strings = b'\\x00'.join(x.encode('utf-8') for x in string_list) + b'\\x00'\n            field_type = type(\n                'String',\n                (StringBase, ),\n                {\n                    '_fields_': [\n                        ('strings', ctypes.c_char * len(strings)),\n                    ],\n                },\n            )\n            field_list.append((field_id, field_type))\n            kw[field_id] = field_type(\n                lang=lang,\n                strings=strings,\n            )\n    klass = type(\n        'Strings',\n        (StringsHead, ),\n        {\n            '_fields_': field_list,\n        },\n    )\n    return klass(\n        magic=STRINGS_MAGIC,\n        length=ctypes.sizeof(klass),\n        str_count=str_count,\n        lang_count=len(lang_dict),\n        **kw\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nserialising a ctypes. structure into a ctypes. c_char array.", "response": "def serialise(structure):\n    \"\"\"\n    structure (ctypes.Structure)\n        The structure to serialise.\n\n    Returns a ctypes.c_char array.\n    Does not copy memory.\n    \"\"\"\n    return ctypes.cast(\n        ctypes.pointer(structure),\n        ctypes.POINTER(ctypes.c_char * ctypes.sizeof(structure)),\n    ).contents"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the host - visible interface number.", "response": "def getRealInterfaceNumber(self, interface):\n        \"\"\"\n        Returns the host-visible interface number, or None if there is no such\n        interface.\n        \"\"\"\n        try:\n            return self._ioctl(INTERFACE_REVMAP, interface)\n        except IOError as exc:\n            if exc.errno == errno.EDOM:\n                return None\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getDescriptor(self):\n        result = USBEndpointDescriptor()\n        self._ioctl(ENDPOINT_DESC, result, True)\n        return result", "response": "Returns the currently active endpoint descriptor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef halt(self):\n        try:\n            self._halt()\n        except IOError as exc:\n            if exc.errno != errno.EBADMSG:\n                raise\n        else:\n            raise ValueError('halt did not return EBADMSG ?')\n        self._halted = True", "response": "Halts the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclosing all endpoint file descriptors.", "response": "def close(self):\n        \"\"\"\n        Close all endpoint file descriptors.\n        \"\"\"\n        ep_list = self._ep_list\n        while ep_list:\n            ep_list.pop().close()\n        self._closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when a setup USB transaction is received.", "response": "def onSetup(self, request_type, request, value, index, length):\n        \"\"\"\n        Called when a setup USB transaction was received.\n\n        Default implementation:\n        - handles USB_REQ_GET_STATUS on interface and endpoints\n        - handles USB_REQ_CLEAR_FEATURE(USB_ENDPOINT_HALT) on endpoints\n        - handles USB_REQ_SET_FEATURE(USB_ENDPOINT_HALT) on endpoints\n        - halts on everything else\n\n        If this method raises anything, endpoint 0 is halted by its caller and\n        exception is let through.\n\n        May be overridden in subclass.\n        \"\"\"\n        if (request_type & ch9.USB_TYPE_MASK) == ch9.USB_TYPE_STANDARD:\n            recipient = request_type & ch9.USB_RECIP_MASK\n            is_in = (request_type & ch9.USB_DIR_IN) == ch9.USB_DIR_IN\n            if request == ch9.USB_REQ_GET_STATUS:\n                if is_in and length == 2:\n                    if recipient == ch9.USB_RECIP_INTERFACE:\n                        if value == 0:\n                            status = 0\n                            if index == 0:\n                                if self.function_remote_wakeup_capable:\n                                    status |= 1 << 0\n                                if self.function_remote_wakeup:\n                                    status |= 1 << 1\n                            self.ep0.write(struct.pack('<H', status)[:length])\n                            return\n                    elif recipient == ch9.USB_RECIP_ENDPOINT:\n                        if value == 0:\n                            try:\n                                endpoint = self.getEndpoint(index)\n                            except IndexError:\n                                pass\n                            else:\n                                status = 0\n                                if endpoint.isHalted():\n                                    status |= 1 << 0\n                                self.ep0.write(\n                                    struct.pack('<H', status)[:length],\n                                )\n                                return\n            elif request == ch9.USB_REQ_CLEAR_FEATURE:\n                if not is_in and length == 0:\n                    if recipient == ch9.USB_RECIP_ENDPOINT:\n                        if value == ch9.USB_ENDPOINT_HALT:\n                            try:\n                                endpoint = self.getEndpoint(index)\n                            except IndexError:\n                                pass\n                            else:\n                                endpoint.clearHalt()\n                                self.ep0.read(0)\n                                return\n                    elif recipient == ch9.USB_RECIP_INTERFACE:\n                        if value == ch9.USB_INTRF_FUNC_SUSPEND:\n                            if self.function_remote_wakeup_capable:\n                                self.disableRemoteWakeup()\n                                self.ep0.read(0)\n                                return\n            elif request == ch9.USB_REQ_SET_FEATURE:\n                if not is_in and length == 0:\n                    if recipient == ch9.USB_RECIP_ENDPOINT:\n                        if value == ch9.USB_ENDPOINT_HALT:\n                            try:\n                                endpoint = self.getEndpoint(index)\n                            except IndexError:\n                                pass\n                            else:\n                                endpoint.halt()\n                                self.ep0.read(0)\n                                return\n                    elif recipient == ch9.USB_RECIP_INTERFACE:\n                        if value == ch9.USB_INTRF_FUNC_SUSPEND:\n                            if self.function_remote_wakeup_capable:\n                                self.enableRemoteWakeup()\n                                self.ep0.read(0)\n                                return\n        self.ep0.halt(request_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():\n    now = datetime.datetime.now\n    try:\n        while True:\n            sys.stdout.write(str(now()) + ' ')\n            time.sleep(1)\n    except KeyboardInterrupt:\n        pass\n    except IOError as exc:\n        if exc.errno != errno.EPIPE:\n            raise", "response": "Main function for the\nellation pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef onEnable(self):\n        trace('onEnable')\n        self._disable()\n        self._aio_context.submit(self._aio_recv_block_list)\n        self._real_onCanSend()\n        self._enabled = True", "response": "Called by the AIO server when the configuration containing this function has been enabled by host."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisables the AIO operation blocks.", "response": "def _disable(self):\n        \"\"\"\n        The configuration containing this function has been disabled by host.\n        Endpoint do not work anymore, so cancel AIO operation blocks.\n        \"\"\"\n        if self._enabled:\n            self._real_onCannotSend()\n            has_cancelled = 0\n            for block in self._aio_recv_block_list + self._aio_send_block_list:\n                try:\n                    self._aio_context.cancel(block)\n                except OSError as exc:\n                    trace(\n                        'cancelling %r raised: %s' % (block, exc),\n                    )\n                else:\n                    has_cancelled += 1\n            if has_cancelled:\n                noIntr(functools.partial(self._aio_context.getEvents, min_nr=None))\n            self._enabled = False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when eventfd notified events are available.", "response": "def onAIOCompletion(self):\n        \"\"\"\n        Call when eventfd notified events are available.\n        \"\"\"\n        event_count = self.eventfd.read()\n        trace('eventfd reports %i events' % event_count)\n        # Even though eventfd signaled activity, even though it may give us\n        # some number of pending events, some events seem to have been already\n        # processed (maybe during io_cancel call ?).\n        # So do not trust eventfd value, and do not even trust that there must\n        # be even one event to process.\n        self._aio_context.getEvents(0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, value):\n        aio_block = libaio.AIOBlock(\n            mode=libaio.AIOBLOCK_MODE_WRITE,\n            target_file=self.getEndpoint(1),\n            buffer_list=[bytearray(value)],\n            offset=0,\n            eventfd=self.eventfd,\n            onCompletion=self._onCanSend,\n        )\n        self._aio_send_block_list.append(aio_block)\n        self._aio_context.submit([aio_block])\n        if len(self._aio_send_block_list) == MAX_PENDING_WRITE_COUNT:\n            self._onCannotSend()", "response": "Queue write in kernel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pretty_error(error, verbose=False):\n    error_loc = ''\n\n    if error.path:\n        while len(error.path) > 0:\n            path_elem = error.path.popleft()\n            if type(path_elem) is not int:\n                if error_loc:\n                    error_loc += '.'\n                error_loc += path_elem\n            # elif len(error.path) > 0:\n            else:\n                error_loc += '[' + text_type(path_elem) + ']'\n        error_loc += ': '\n\n    # Get error message and remove ugly u'' prefixes\n    if verbose:\n        msg = remove_u(text_type(error))\n    else:\n        msg = remove_u(error.message)\n\n    # Don't reword error messages from our validators,\n    # only the default error messages from the jsonschema library\n    if repr(error.schema) == '<unset>':\n        try:\n            return error_loc + msg\n        except UnicodeDecodeError:\n            return error_loc + msg.decode('utf-8')\n\n    # Reword error messages containing regexes\n    if error.validator == 'pattern' and 'title' in error.schema:\n        if error.schema['title'] == 'type':\n            msg = re.sub(r\"match '.+'$\", 'match the \\'type\\' field format '\n                         '(lowercase ASCII a-z, 0-9, and hypens only - and no '\n                         'two hyphens in a row)', msg)\n        elif error.schema['title'] == 'identifier':\n            msg = re.sub(r\"match '.+'$\", 'match the id format '\n                         '([object-type]--[UUIDv4])', msg)\n        elif error.schema['title'] == 'id':\n            msg = re.sub(r\"match '.+'$\", 'start with \\'' +\n                         error.validator_value[1:-2] + '--\\'', msg)\n        elif error.schema['title'] == 'timestamp':\n            msg = re.sub(r\"match '.+'$\", 'match the timestamp format '\n                         'YYYY-MM-DDTHH:mm:ss[.s+]Z', msg)\n        elif error.schema['title'] == 'timestamp_millis':\n            msg = re.sub(r\"match '.+'$\", 'match the timestamp format '\n                         'YYYY-MM-DDTHH:mm:ss.sssZ (must be precise to the '\n                         'millisecond)', msg)\n        elif error.schema['title'] == 'relationship_type':\n            msg = re.sub(r\"does not match '.+'$\", 'contains invalid '\n                         'characters', msg)\n        elif error.schema['title'] == 'url-regex':\n            msg = re.sub(r'match \".+\"$', 'match the format '\n                         'of a URL', msg)\n        elif error.schema['title'] == 'binary':\n            msg = re.sub(r\"does not.+'$\", 'must be a base64-encoded string', msg)\n    elif error.validator == 'pattern' and 'observed_data_refs' in error.schema_path:\n        msg = \"'observed_data_refs' must refer to Observed Data Objects\"\n    elif error.validator == 'pattern' and 'where_sighted_refs' in error.schema_path:\n        msg = \"'where_sighted_refs' must refer to Identity Objects\"\n\n    # Reword empty array errors\n    elif type(error.instance) is list and len(error.instance) == 0:\n        msg = re.sub(r\"\\[\\] is not valid .+$\", 'empty arrays are not allowed',\n                     msg)\n\n    # Reword custom property errors\n    elif 'title' in error.schema and error.schema['title'] == 'core':\n        if error.validator == 'additionalProperties':\n            msg = re.sub(r\"Additional .+$\", 'Custom properties must match the '\n                         'proper format (lowercase ASCII a-z, 0-9, and '\n                         'underscores; 3-250 characters)', msg)\n        elif error.validator == 'not' and 'anyOf' in error.validator_value:\n            reserved_properties = [y for x in error.validator_value['anyOf'] for y in x['required']]\n            msg = re.sub(r\".+\", \"Contains a reserved property ('%s')\"\n                         % \"', '\".join(reserved_properties), msg)\n    elif 'title' in error.schema and error.schema['title'] == 'cyber-observable-core':\n        if error.validator == 'additionalProperties':\n            msg = re.sub(r\"Additional .+$\", 'Custom observable properties must'\n                         ' match the proper format (lowercase ASCII a-z, 0-9, '\n                         'and underscores; 3-250 characters)', msg)\n\n    elif error.validator == 'additionalProperties':\n        if 'extensions' in error.schema_path:\n            msg = re.sub(r\"Additional .+$\", 'Custom extension keys may only '\n                         'contain alphanumeric characters, dashes, and '\n                         'underscores; 3-256 characters', msg)\n\n    # Reword 'is valid under each of' errors\n    elif error.validator == 'oneOf':\n        try:\n            if 'external_references' in error.schema_path:\n                msg = \"If the external reference is a CVE, 'source_name' must be\" \\\n                      \" 'cve' and 'external_id' must be in the CVE format \" \\\n                      \"(CVE-YYYY-NNNN+). If the external reference is a CAPEC, \" \\\n                      \"'source_name' must be 'capec' and 'external_id' must be \" \\\n                      \"in the CAPEC format (CAPEC-N+). If the external reference \"\\\n                      \"is neither, it must contain the 'source_name' property and\"\\\n                      \" at least one of the 'external_id', 'url', or \"\\\n                      \"'description' properties.\"\n            elif 'type' in error.instance and error.instance['type'] == 'email-message':\n                if 'is_multipart' not in error.instance:\n                    msg = \"'is_multipart' is a required property\"\n                elif error.instance['is_multipart'] is True:\n                    msg = \"Since 'is_multipart' is true, 'body_multipart' must \"\\\n                          \"contain valid 'mime-part-type' objects and the 'body' \"\\\n                          \"property must not be present. \"\n                elif error.instance['is_multipart'] is False:\n                    msg = \"Since 'is_multipart' is false, 'body' must be a string\"\\\n                          \" and the 'body_multipart' property must not be present.\"\n            elif 'type' in error.instance and error.instance['type'] == 'artifact':\n                if 'payload_bin' in error.instance and 'url' in error.instance:\n                    msg = \"'artifact' object must contain either 'payload_bin' \"\\\n                          \"or 'url' but not both\"\n                elif 'payload_bin' in error.instance:\n                    msg = \"'payload_bin' must be base64 encoded and 'hashes', if \"\\\n                          \"present, must contain a valid dictionary of hashes\"\n                elif 'url' in error.instance:\n                    msg = \"'url' must be a valid url and 'hashes', which must be \"\\\n                          \"present, must contain a valid hash dictionary\"\n                else:\n                    msg = \"'artifact' object must contain either 'payload_bin' \"\\\n                          \"or 'url'\"\n            elif 'type' in error.instance and error.instance['type'] == 'marking-definition':\n                msg = \"'definition' must contain a valid statement, TLP, or \"\\\n                      \"custom marking definition\"\n            elif 'type' in error.instance and error.instance['type'] == 'file':\n                if (('is_encrypted' not in error.instance or\n                        error.instance['is_encrypted'] is False) and\n                        ('encryption_algorithm' in error.instance or\n                         'decryption_key' in error.instance)):\n                    msg = \"'file' objects may only contain 'encryption_algorithm'\"\\\n                          \" or 'decryption_key' when 'is_encrypted' is true\"\n            elif 'type' in error.instance and error.instance['type'] == 'network-traffic':\n                if ('is_active' in error.instance and\n                        error.instance['is_active'] is True and\n                        'end' in error.instance):\n                    msg = \"If the 'is_active' property is true, then the \"\\\n                          \"'end' property must not be included.\"\n            else:\n                raise TypeError\n        except TypeError:\n            msg = msg + ':\\n' + remove_u(text_type(error.schema))\n\n    # reword forbidden property or value errors\n    elif error.validator == 'not':\n        if 'enum' in error.validator_value:\n            msg = re.sub(r\"\\{.+\\} is not allowed for '(.+)'$\", r\"'\\g<1>' is \"\n                         \"not an allowed value\", msg)\n        elif ('target_ref' in error.schema_path or\n              'source_ref' in error.schema_path):\n                msg = \"Relationships cannot link bundles, marking definitions\"\\\n                      \", sightings, or other relationships. This field must \"\\\n                      \"contain the id of an SDO.\"\n        elif 'sighting_of_ref' in error.schema_path:\n            msg = \"'sighting_of_ref' must refer to a STIX Domain Object or \"\\\n                  \"Custom Object\"\n\n    # Reword 'is not valid under any of the given schemas' errors\n    elif error.validator == 'anyOf':\n        try:\n            if error.instance == {}:\n                msg = \"must contain at least one property from this type.\"\n            elif error.instance is None:\n                msg = \"null properties are not allowed in STIX.\"\n            elif 'type' in error.instance and error.instance['type'] == 'network-traffic':\n                if ('src_ref' not in error.instance and\n                        'dst_ref' not in error.instance):\n                    msg = \"'network-traffic' objects must contain at least \"\\\n                          \"one of 'src_ref' or 'dst_ref'\"\n            elif 'type' in error.instance and error.instance['type'] in ['process', 'x509-certificate']:\n                if error.instance.keys() == ['type']:\n                    msg = \"must contain at least one property (other than `type`) from this object.\"\n            else:\n                raise TypeError\n        except TypeError:\n            msg = msg + ':\\n' + remove_u(text_type(error.schema))\n\n    return error_loc + msg", "response": "Return a pretty error message for the given error."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _iter_errors_custom(instance, checks, options):\n    # Perform validation\n    for v_function in checks:\n        try:\n            result = v_function(instance)\n        except TypeError:\n            result = v_function(instance, options)\n        if isinstance(result, Iterable):\n            for x in result:\n                yield x\n        elif result is not None:\n            yield result\n\n    # Validate any child STIX objects\n    for field in instance:\n        if type(instance[field]) is list:\n            for obj in instance[field]:\n                if _is_stix_obj(obj):\n                    for err in _iter_errors_custom(obj, checks, options):\n                        yield err", "response": "Iterate over the errors that are not possible merely with JSON schemas."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_json_files(directory, recursive=False):\n    json_files = []\n\n    for top, dirs, files in os.walk(directory):\n        dirs.sort()\n        # Get paths to each file in `files`\n        paths = (os.path.join(top, f) for f in sorted(files))\n\n        # Add all the .json files to our return collection\n        json_files.extend(x for x in paths if is_json(x))\n\n        if not recursive:\n            break\n\n    return json_files", "response": "Return a list of file paths for JSON files within a directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_json_files(files, recursive=False):\n    json_files = []\n\n    if not files:\n        return json_files\n\n    for fn in files:\n        if os.path.isdir(fn):\n            children = list_json_files(fn, recursive)\n            json_files.extend(children)\n        elif is_json(fn):\n            json_files.append(fn)\n        else:\n            continue\n\n    if not json_files:\n        raise NoJSONFileFoundError(\"No JSON files found!\")\n    return json_files", "response": "Return a list of files to validate from files."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_validation(options):\n    if options.files == sys.stdin:\n        results = validate(options.files, options)\n        return [FileValidationResults(is_valid=results.is_valid,\n                                      filepath='stdin',\n                                      object_results=results)]\n\n    files = get_json_files(options.files, options.recursive)\n\n    results = [validate_file(fn, options) for fn in files]\n\n    return results", "response": "Validate files based on command line options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating objects from parsed JSON.", "response": "def validate_parsed_json(obj_json, options=None):\n    \"\"\"\n    Validate objects from parsed JSON.  This supports a single object, or a\n    list of objects.  If a single object is given, a single result is\n    returned.  Otherwise, a list of results is returned.\n\n    If an error occurs, a ValidationErrorResults instance or list which\n    includes one of these instances, is returned.\n\n    :param obj_json: The parsed json\n    :param options: Validation options\n    :return: An ObjectValidationResults instance, or a list of such.\n    \"\"\"\n\n    validating_list = isinstance(obj_json, list)\n\n    if not options:\n        options = ValidationOptions()\n\n    if not options.no_cache:\n        init_requests_cache(options.refresh_cache)\n\n    results = None\n    if validating_list:\n        results = []\n        for obj in obj_json:\n            try:\n                results.append(validate_instance(obj, options))\n            except SchemaInvalidError as ex:\n                error_result = ObjectValidationResults(is_valid=False,\n                                                       object_id=obj.get('id', ''),\n                                                       errors=[str(ex)])\n                results.append(error_result)\n    else:\n        try:\n            results = validate_instance(obj_json, options)\n        except SchemaInvalidError as ex:\n            error_result = ObjectValidationResults(is_valid=False,\n                                                   object_id=obj_json.get('id', ''),\n                                                   errors=[str(ex)])\n            results = error_result\n\n    if not options.no_cache and options.clear_cache:\n        clear_requests_cache()\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate objects from JSON data in a textual stream.", "response": "def validate(in_, options=None):\n    \"\"\"\n    Validate objects from JSON data in a textual stream.\n\n    :param in_: A textual stream of JSON data.\n    :param options: Validation options\n    :return: An ObjectValidationResults instance, or a list of such.\n    \"\"\"\n    obj_json = json.load(in_)\n\n    results = validate_parsed_json(obj_json, options)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the input file fn according to the options passed in.", "response": "def validate_file(fn, options=None):\n    \"\"\"Validate the input document `fn` according to the options passed in.\n\n    If any exceptions are raised during validation, no further validation\n    will take place.\n\n    Args:\n        fn: The filename of the JSON file to be validated.\n        options: An instance of ``ValidationOptions``.\n\n    Returns:\n        An instance of FileValidationResults.\n\n    \"\"\"\n    file_results = FileValidationResults(filepath=fn)\n    output.info(\"Performing JSON schema validation on %s\" % fn)\n\n    if not options:\n        options = ValidationOptions(files=fn)\n\n    try:\n        with open(fn) as instance_file:\n            file_results.object_results = validate(instance_file, options)\n\n    except Exception as ex:\n        if 'Expecting value' in str(ex):\n            line_no = str(ex).split()[3]\n            file_results.fatal = ValidationErrorResults(\n                'Invalid JSON input on line %s' % line_no\n            )\n        else:\n            file_results.fatal = ValidationErrorResults(ex)\n\n        msg = (\"Unexpected error occurred with file '{fn}'. No further \"\n               \"validation will be performed: {error}\")\n        output.info(msg.format(fn=fn, error=str(ex)))\n\n    file_results.is_valid = (all(object_result.is_valid\n                                 for object_result in file_results.object_results)\n                             and not file_results.fatal)\n\n    return file_results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_string(string, options=None):\n    output.info(\"Performing JSON schema validation on input string: \" + string)\n    stream = io.StringIO(string)\n    return validate(stream, options)", "response": "Validate the input string according to the options passed in."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a JSON schema validator for the given schema.", "response": "def load_validator(schema_path, schema):\n    \"\"\"Create a JSON schema validator for the given schema.\n\n    Args:\n        schema_path: The filename of the JSON schema.\n        schema: A Python object representation of the same schema.\n\n    Returns:\n        An instance of Draft4Validator.\n\n    \"\"\"\n    # Get correct prefix based on OS\n    if os.name == 'nt':\n        file_prefix = 'file:///'\n    else:\n        file_prefix = 'file:'\n\n    resolver = RefResolver(file_prefix + schema_path.replace(\"\\\\\", \"/\"), schema)\n    validator = Draft4Validator(schema, resolver=resolver)\n\n    return validator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch the schema_dir directory for a schema called obj_type. json.", "response": "def find_schema(schema_dir, obj_type):\n    \"\"\"Search the `schema_dir` directory for a schema called `obj_type`.json.\n    Return the file path of the first match it finds.\n    \"\"\"\n    schema_filename = obj_type + '.json'\n\n    for root, dirnames, filenames in os.walk(schema_dir):\n        if schema_filename in filenames:\n            return os.path.join(root, schema_filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_schema(schema_path):\n    try:\n        with open(schema_path) as schema_file:\n            schema = json.load(schema_file)\n    except ValueError as e:\n        raise SchemaInvalidError('Invalid JSON in schema or included schema: '\n                                 '%s\\n%s' % (schema_file.name, str(e)))\n\n    return schema", "response": "Load the JSON schema at the given path as a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_error_generator(type, obj, schema_dir=None, version=DEFAULT_VER, default='core'):\n    # If no schema directory given, use default for the given STIX version,\n    # which comes bundled with this package\n    if schema_dir is None:\n        schema_dir = os.path.abspath(os.path.dirname(__file__) + '/schemas-'\n                                     + version + '/')\n\n    try:\n        schema_path = find_schema(schema_dir, type)\n        schema = load_schema(schema_path)\n    except (KeyError, TypeError):\n        # Assume a custom object with no schema\n        try:\n            schema_path = find_schema(schema_dir, default)\n            schema = load_schema(schema_path)\n        except (KeyError, TypeError):\n            # Only raise an error when checking against default schemas, not custom\n            if schema_dir is not None:\n                return None\n            raise SchemaInvalidError(\"Cannot locate a schema for the object's \"\n                                     \"type, nor the base schema ({}.json).\".format(default))\n\n    if type == 'observed-data' and schema_dir is None:\n        # Validate against schemas for specific observed data object types later.\n        # If schema_dir is not None the schema is custom and won't need to be modified.\n        schema['allOf'][1]['properties']['objects'] = {\n            \"objects\": {\n                \"type\": \"object\",\n                \"minProperties\": 1\n            }\n        }\n\n    # Don't use custom validator; only check schemas, no additional checks\n    validator = load_validator(schema_path, schema)\n    try:\n        error_gen = validator.iter_errors(obj)\n    except schema_exceptions.RefResolutionError:\n        raise SchemaInvalidError('Invalid JSON schema: a JSON '\n                                 'reference failed to resolve')\n    return error_gen", "response": "Returns a generator for validating the given object against the given schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_musts(options):\n    if options.version == '2.0':\n        return musts20.list_musts(options)\n    else:\n        return musts21.list_musts(options)", "response": "Returns the list of MUST validators for the correct version of STIX."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of SHOULD validators for the correct version of STIX.", "response": "def _get_shoulds(options):\n    \"\"\"Return the list of 'SHOULD' validators for the correct version of STIX.\n\n    Args:\n        options: ValidationOptions instance with validation options for this\n            validation run, including the STIX spec version.\n    \"\"\"\n    if options.version == '2.0':\n        return shoulds20.list_shoulds(options)\n    else:\n        return shoulds21.list_shoulds(options)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate a single STIX object against its type s schema.", "response": "def _schema_validate(sdo, options):\n    \"\"\"Set up validation of a single STIX object against its type's schema.\n    This does no actual validation; it just returns generators which must be\n    iterated to trigger the actual generation.\n\n    This function first creates generators for the built-in schemas, then adds\n    generators for additional schemas from the options, if specified.\n\n    Do not call this function directly; use validate_instance() instead, as it\n    calls this one. This function does not perform any custom checks.\n    \"\"\"\n    error_gens = []\n\n    if 'id' in sdo:\n        try:\n            error_prefix = sdo['id'] + \": \"\n        except TypeError:\n            error_prefix = 'unidentifiable object: '\n    else:\n        error_prefix = ''\n\n    # Get validator for built-in schema\n    base_sdo_errors = _get_error_generator(sdo['type'], sdo, version=options.version)\n    if base_sdo_errors:\n        error_gens.append((base_sdo_errors, error_prefix))\n\n    # Get validator for any user-supplied schema\n    if options.schema_dir:\n        custom_sdo_errors = _get_error_generator(sdo['type'], sdo, options.schema_dir)\n        if custom_sdo_errors:\n            error_gens.append((custom_sdo_errors, error_prefix))\n\n    # Validate each cyber observable object separately\n    if sdo['type'] == 'observed-data' and 'objects' in sdo:\n        # Check if observed data property is in dictionary format\n        if not isinstance(sdo['objects'], dict):\n            error_gens.append(([schema_exceptions.ValidationError(\"Observed Data objects must be in dict format.\", error_prefix)],\n                              error_prefix))\n            return error_gens\n\n        for key, obj in iteritems(sdo['objects']):\n            if 'type' not in obj:\n                error_gens.append(([schema_exceptions.ValidationError(\"Observable object must contain a 'type' property.\", error_prefix)],\n                                   error_prefix + 'object \\'' + key + '\\': '))\n                continue\n            # Get validator for built-in schemas\n            base_obs_errors = _get_error_generator(obj['type'],\n                                                   obj,\n                                                   None,\n                                                   options.version,\n                                                   'cyber-observable-core')\n            if base_obs_errors:\n                error_gens.append((base_obs_errors,\n                                   error_prefix + 'object \\'' + key + '\\': '))\n\n            # Get validator for any user-supplied schema\n            custom_obs_errors = _get_error_generator(obj['type'],\n                                                     obj,\n                                                     options.schema_dir,\n                                                     options.version,\n                                                     'cyber-observable-core')\n            if custom_obs_errors:\n                error_gens.append((custom_obs_errors,\n                                   error_prefix + 'object \\'' + key + '\\': '))\n\n    return error_gens"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming STIX JSON Schema validation against a STIX object.", "response": "def validate_instance(instance, options=None):\n    \"\"\"Perform STIX JSON Schema validation against STIX input.\n\n    Find the correct schema by looking at the 'type' property of the\n    `instance` JSON object.\n\n    Args:\n        instance: A Python dictionary representing a STIX object with a\n            'type' property.\n        options: ValidationOptions instance with validation options for this\n            validation run.\n\n    Returns:\n        A dictionary of validation results\n\n    \"\"\"\n    if 'type' not in instance:\n        raise ValidationError(\"Input must be an object with a 'type' property.\")\n\n    if not options:\n        options = ValidationOptions()\n\n    error_gens = []\n\n    # Schema validation\n    if instance['type'] == 'bundle' and 'objects' in instance:\n        # Validate each object in a bundle separately\n        for sdo in instance['objects']:\n            if 'type' not in sdo:\n                raise ValidationError(\"Each object in bundle must have a 'type' property.\")\n            error_gens += _schema_validate(sdo, options)\n    else:\n        error_gens += _schema_validate(instance, options)\n\n    # Custom validation\n    must_checks = _get_musts(options)\n    should_checks = _get_shoulds(options)\n    output.info(\"Running the following additional checks: %s.\"\n                % \", \".join(x.__name__ for x in chain(must_checks, should_checks)))\n    try:\n        errors = _iter_errors_custom(instance, must_checks, options)\n        warnings = _iter_errors_custom(instance, should_checks, options)\n\n        if options.strict:\n            chained_errors = chain(errors, warnings)\n            warnings = []\n        else:\n            chained_errors = errors\n            warnings = [pretty_error(x, options.verbose) for x in warnings]\n    except schema_exceptions.RefResolutionError:\n        raise SchemaInvalidError('Invalid JSON schema: a JSON reference '\n                                 'failed to resolve')\n\n    # List of error generators and message prefixes (to denote which object the\n    # error comes from)\n    error_gens += [(chained_errors, '')]\n\n    # Prepare the list of errors (this actually triggers the custom validation\n    # functions).\n    error_list = []\n    for gen, prefix in error_gens:\n        for error in gen:\n            msg = prefix + pretty_error(error, options.verbose)\n            error_list.append(SchemaError(msg))\n\n    if error_list:\n        valid = False\n    else:\n        valid = True\n\n    return ObjectValidationResults(is_valid=valid, object_id=instance.get('id', ''),\n                                   errors=error_list, warnings=warnings)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the object result object assuming there is only one result. Raises ValueError if there is more than one result.", "response": "def object_result(self):\n        \"\"\"\n        Get the object result object, assuming there is only one.  Raises\n        an error if there is more than one.\n        :return: The result object\n        :raises ValueError: If there is more than one result\n        \"\"\"\n        num_obj_results = len(self._object_results)\n\n        if num_obj_results < 1:\n            return None\n        elif num_obj_results < 2:\n            return self._object_results[0]\n        else:\n            raise ValueError(\"There is more than one result; use 'object_results'\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef object_results(self, object_results):\n        if _is_iterable_non_string(object_results):\n            self._object_results = list(object_results)\n        elif object_results is None:\n            self._object_results = []\n        else:\n            self._object_results = [object_results]", "response": "Set the results to an iterable of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef custom_prefix_strict(instance):\n    for error in chain(custom_object_prefix_strict(instance),\n                       custom_property_prefix_strict(instance),\n                       custom_observable_object_prefix_strict(instance),\n                       custom_object_extension_prefix_strict(instance),\n                       custom_observable_properties_prefix_strict(instance)):\n        yield error", "response": "Ensure custom content follows strict naming style conventions."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures custom content follows lenient naming style conventions for forward - compatibility.", "response": "def custom_prefix_lax(instance):\n    \"\"\"Ensure custom content follows lenient naming style conventions\n    for forward-compatibility.\n    \"\"\"\n    for error in chain(custom_object_prefix_lax(instance),\n                       custom_property_prefix_lax(instance),\n                       custom_observable_object_prefix_lax(instance),\n                       custom_object_extension_prefix_lax(instance),\n                       custom_observable_properties_prefix_lax(instance)):\n        yield error"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef custom_object_prefix_strict(instance):\n    if (instance['type'] not in enums.TYPES and\n            instance['type'] not in enums.RESERVED_OBJECTS and\n            not CUSTOM_TYPE_PREFIX_RE.match(instance['type'])):\n        yield JSONError(\"Custom object type '%s' should start with 'x-' \"\n                        \"followed by a source unique identifier (like a \"\n                        \"domain name with dots replaced by hyphens), a hyphen \"\n                        \"and then the name.\" % instance['type'],\n                        instance['id'], 'custom-prefix')", "response": "Ensure custom objects follow strict naming style conventions."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures custom objects follow lenient naming style conventions for forward - compatibility.", "response": "def custom_object_prefix_lax(instance):\n    \"\"\"Ensure custom objects follow lenient naming style conventions\n    for forward-compatibility.\n    \"\"\"\n    if (instance['type'] not in enums.TYPES and\n            instance['type'] not in enums.RESERVED_OBJECTS and\n            not CUSTOM_TYPE_LAX_PREFIX_RE.match(instance['type'])):\n        yield JSONError(\"Custom object type '%s' should start with 'x-' in \"\n                        \"order to be compatible with future versions of the \"\n                        \"STIX 2 specification.\" % instance['type'],\n                        instance['id'], 'custom-prefix-lax')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef custom_property_prefix_strict(instance):\n    for prop_name in instance.keys():\n        if (instance['type'] in enums.PROPERTIES and\n                prop_name not in enums.PROPERTIES[instance['type']] and\n                prop_name not in enums.RESERVED_PROPERTIES and\n                not CUSTOM_PROPERTY_PREFIX_RE.match(prop_name)):\n\n            yield JSONError(\"Custom property '%s' should have a type that \"\n                            \"starts with 'x_' followed by a source unique \"\n                            \"identifier (like a domain name with dots \"\n                            \"replaced by hyphen), a hyphen and then the name.\"\n                            % prop_name, instance['id'],\n                            'custom-prefix')", "response": "Ensure custom properties follow strict naming style conventions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring custom properties follow lenient naming style conventions for forward - compatibility.", "response": "def custom_property_prefix_lax(instance):\n    \"\"\"Ensure custom properties follow lenient naming style conventions\n    for forward-compatibility.\n\n    Does not check property names in custom objects.\n    \"\"\"\n    for prop_name in instance.keys():\n        if (instance['type'] in enums.PROPERTIES and\n                prop_name not in enums.PROPERTIES[instance['type']] and\n                prop_name not in enums.RESERVED_PROPERTIES and\n                not CUSTOM_PROPERTY_LAX_PREFIX_RE.match(prop_name)):\n\n            yield JSONError(\"Custom property '%s' should have a type that \"\n                            \"starts with 'x_' in order to be compatible with \"\n                            \"future versions of the STIX 2 specification.\" %\n                            prop_name, instance['id'],\n                            'custom-prefix-lax')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure that the values of all properties which use open vocabularies are all lowercase and use hyphens instead of spaces or underscores as word separators.", "response": "def open_vocab_values(instance):\n    \"\"\"Ensure that the values of all properties which use open vocabularies are\n    in lowercase and use hyphens instead of spaces or underscores as word\n    separators.\n    \"\"\"\n    if instance['type'] not in enums.VOCAB_PROPERTIES:\n        return\n\n    properties = enums.VOCAB_PROPERTIES[instance['type']]\n    for prop in properties:\n        if prop in instance:\n\n            if type(instance[prop]) is list:\n                values = instance[prop]\n            else:\n                values = [instance[prop]]\n\n            for v in values:\n                if not v.islower() or '_' in v or ' ' in v:\n                    yield JSONError(\"Open vocabulary value '%s' should be all\"\n                                    \" lowercase and use hyphens instead of\"\n                                    \" spaces or underscores as word\"\n                                    \" separators.\" % v, instance['id'],\n                                    'open-vocab-format')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nensure the kill_chain_name and phase_name properties of the gunicorn_root element of the order they appear in the order they appear.", "response": "def kill_chain_phase_names(instance):\n    \"\"\"Ensure the `kill_chain_name` and `phase_name` properties of\n    `kill_chain_phase` objects follow naming style conventions.\n    \"\"\"\n    if instance['type'] in enums.KILL_CHAIN_PHASE_USES and 'kill_chain_phases' in instance:\n        for phase in instance['kill_chain_phases']:\n\n            if 'kill_chain_name' not in phase:\n                # Since this field is required, schemas will already catch the error\n                return\n\n            chain_name = phase['kill_chain_name']\n            if not chain_name.islower() or '_' in chain_name or ' ' in chain_name:\n                yield JSONError(\"kill_chain_name '%s' should be all lowercase\"\n                                \" and use hyphens instead of spaces or \"\n                                \"underscores as word separators.\" % chain_name,\n                                instance['id'], 'kill-chain-names')\n\n            phase_name = phase['phase_name']\n            if not phase_name.islower() or '_' in phase_name or ' ' in phase_name:\n                yield JSONError(\"phase_name '%s' should be all lowercase and \"\n                                \"use hyphens instead of spaces or underscores \"\n                                \"as word separators.\" % phase_name,\n                                instance['id'], 'kill-chain-names')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the open vocabulary specified by vocab is used properly.", "response": "def check_vocab(instance, vocab, code):\n    \"\"\"Ensure that the open vocabulary specified by `vocab` is used properly.\n\n    This checks properties of objects specified in the appropriate `_USES`\n    dictionary to determine which properties SHOULD use the given vocabulary,\n    then checks that the values in those properties are from the vocabulary.\n    \"\"\"\n    vocab_uses = getattr(enums, vocab + \"_USES\")\n    for k in vocab_uses.keys():\n        if instance['type'] == k:\n            for prop in vocab_uses[k]:\n                if prop not in instance:\n                    continue\n\n                vocab_ov = getattr(enums, vocab + \"_OV\")\n                if type(instance[prop]) is list:\n                    is_in = set(instance[prop]).issubset(set(vocab_ov))\n                else:\n                    is_in = instance[prop] in vocab_ov\n\n                if not is_in:\n                    vocab_name = vocab.replace('_', '-').lower()\n                    yield JSONError(\"%s contains a value not in the %s-ov \"\n                                    \"vocabulary.\" % (prop, vocab_name),\n                                    instance['id'], code)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vocab_marking_definition(instance):\n    if (instance['type'] == 'marking-definition' and\n            'definition_type' in instance and not\n            instance['definition_type'] in enums.MARKING_DEFINITION_TYPES):\n\n        return JSONError(\"Marking definition `definition_type` should be one \"\n                         \"of: %s.\" % ', '.join(enums.MARKING_DEFINITION_TYPES),\n                         instance['id'], 'marking-definition-type')", "response": "Ensure that the definition_type property of marking - definition objects is one of the values in the STIX 2. 0 specification."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef relationships_strict(instance):\n    # Don't check objects that aren't relationships or that are custom objects\n    if (instance['type'] != 'relationship' or\n            instance['type'] not in enums.TYPES):\n        return\n\n    if ('relationship_type' not in instance or 'source_ref' not in instance or\n            'target_ref' not in instance):\n        # Since these fields are required, schemas will already catch the error\n        return\n\n    r_type = instance['relationship_type']\n    try:\n        r_source = re.search(r\"(.+)\\-\\-\", instance['source_ref']).group(1)\n        r_target = re.search(r\"(.+)\\-\\-\", instance['target_ref']).group(1)\n    except (AttributeError, TypeError):\n        # Schemas already catch errors of these properties not being strings or\n        # not containing the string '--'.\n        return\n\n    if (r_type in enums.COMMON_RELATIONSHIPS or\n            r_source in enums.NON_SDOS or\n            r_target in enums.NON_SDOS):\n        # If all objects can have this relationship type, no more checks needed\n        # Schemas already catch if source/target type cannot have relationship\n        return\n\n    if r_source not in enums.RELATIONSHIPS:\n        return JSONError(\"'%s' is not a suggested relationship source object \"\n                         \"for the '%s' relationship.\" % (r_source, r_type),\n                         instance['id'], 'relationship-types')\n\n    if r_type not in enums.RELATIONSHIPS[r_source]:\n        return JSONError(\"'%s' is not a suggested relationship type for '%s' \"\n                         \"objects.\" % (r_type, r_source), instance['id'],\n                         'relationship-types')\n\n    if r_target not in enums.RELATIONSHIPS[r_source][r_type]:\n        return JSONError(\"'%s' is not a suggested relationship target object \"\n                         \"for '%s' objects with the '%s' relationship.\"\n                         % (r_target, r_source, r_type), instance['id'],\n                         'relationship-types')", "response": "Ensure that only the relationship types defined in the specification are used."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns true if given value is a valid recommended hash name according to the STIX 2 specification.", "response": "def valid_hash_value(hashname):\n    \"\"\"Return true if given value is a valid, recommended hash name according\n    to the STIX 2 specification.\n    \"\"\"\n    custom_hash_prefix_re = re.compile(r\"^x_\")\n    if hashname in enums.HASH_ALGO_OV or custom_hash_prefix_re.match(hashname):\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vocab_hash_algo(instance):\n    for key, obj in instance['objects'].items():\n        if 'type' not in obj:\n            continue\n\n        if obj['type'] == 'file':\n            try:\n                hashes = obj['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if not (valid_hash_value(h)):\n                        yield JSONError(\"Object '%s' has a 'hashes' dictionary\"\n                                        \" with a hash of type '%s', which is not a \"\n                                        \"value in the hash-algo-ov vocabulary nor a \"\n                                        \"custom value prepended with 'x_'.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                ads = obj['extensions']['ntfs-ext']['alternate_data_streams']\n            except KeyError:\n                pass\n            else:\n                for datastream in ads:\n                    if 'hashes' not in datastream:\n                        continue\n                    for h in datastream['hashes']:\n                        if not (valid_hash_value(h)):\n                            yield JSONError(\"Object '%s' has an NTFS extension\"\n                                            \" with an alternate data stream that has a\"\n                                            \" 'hashes' dictionary with a hash of type \"\n                                            \"'%s', which is not a value in the \"\n                                            \"hash-algo-ov vocabulary nor a custom \"\n                                            \"value prepended with 'x_'.\"\n                                            % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                head_hashes = obj['extensions']['windows-pebinary-ext']['file_header_hashes']\n            except KeyError:\n                pass\n            else:\n                for h in head_hashes:\n                    if not (valid_hash_value(h)):\n                        yield JSONError(\"Object '%s' has a Windows PE Binary \"\n                                        \"File extension with a file header hash of \"\n                                        \"'%s', which is not a value in the \"\n                                        \"hash-algo-ov vocabulary nor a custom value \"\n                                        \"prepended with 'x_'.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                hashes = obj['extensions']['windows-pebinary-ext']['optional_header']['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if not (valid_hash_value(h)):\n                        yield JSONError(\"Object '%s' has a Windows PE Binary \"\n                                        \"File extension with an optional header that \"\n                                        \"has a hash of '%s', which is not a value in \"\n                                        \"the hash-algo-ov vocabulary nor a custom \"\n                                        \"value prepended with 'x_'.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                sections = obj['extensions']['windows-pebinary-ext']['sections']\n            except KeyError:\n                pass\n            else:\n                for s in sections:\n                    if 'hashes' not in s:\n                        continue\n                    for h in s['hashes']:\n                        if not (valid_hash_value(h)):\n                            yield JSONError(\"Object '%s' has a Windows PE \"\n                                            \"Binary File extension with a section that\"\n                                            \" has a hash of '%s', which is not a value\"\n                                            \" in the hash-algo-ov vocabulary nor a \"\n                                            \"custom value prepended with 'x_'.\"\n                                            % (key, h), instance['id'], 'hash-algo')\n\n        elif obj['type'] == 'artifact' or obj['type'] == 'x509-certificate':\n            try:\n                hashes = obj['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if not (valid_hash_value(h)):\n                        yield JSONError(\"Object '%s' has a 'hashes' dictionary\"\n                                        \" with a hash of type '%s', which is not a \"\n                                        \"value in the hash-algo-ov vocabulary nor a \"\n                                        \"custom value prepended with 'x_'.\"\n                                        % (key, h), instance['id'], 'hash-algo')", "response": "Ensure objects with hashes properties only use values from the internal hash - algo - ov vocabulary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring file objects with the windows - pebinary - ext extension have a a pe - type property that is from the windows - pebinary - type - ov vocabulary.", "response": "def vocab_windows_pebinary_type(instance):\n    \"\"\"Ensure file objects with the windows-pebinary-ext extension have a\n    'pe-type' property that is from the windows-pebinary-type-ov vocabulary.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if 'type' in obj and obj['type'] == 'file':\n            try:\n                pe_type = obj['extensions']['windows-pebinary-ext']['pe_type']\n            except KeyError:\n                continue\n            if pe_type not in enums.WINDOWS_PEBINARY_TYPE_OV:\n                yield JSONError(\"Object '%s' has a Windows PE Binary File \"\n                                \"extension with a 'pe_type' of '%s', which is not a \"\n                                \"value in the windows-pebinary-type-ov vocabulary.\"\n                                % (key, pe_type), instance['id'],\n                                'windows-pebinary-type')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vocab_account_type(instance):\n    for key, obj in instance['objects'].items():\n        if 'type' in obj and obj['type'] == 'user-account':\n            try:\n                acct_type = obj['account_type']\n            except KeyError:\n                continue\n            if acct_type not in enums.ACCOUNT_TYPE_OV:\n                yield JSONError(\"Object '%s' is a User Account Object \"\n                                \"with an 'account_type' of '%s', which is not a \"\n                                \"value in the account-type-ov vocabulary.\"\n                                % (key, acct_type), instance['id'], 'account-type')", "response": "Ensure a user - account objects account - type property is from the user - account objects account - type - ov vocabulary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef observable_object_keys(instance):\n    digits_re = re.compile(r\"^\\d+$\")\n    for key in instance['objects']:\n        if not digits_re.match(key):\n            yield JSONError(\"'%s' is not a good key value. Observable Objects \"\n                            \"should use non-negative integers for their keys.\"\n                            % key, instance['id'], 'observable-object-keys')", "response": "Ensure observable - objects keys are non - negative integers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef custom_observable_object_prefix_strict(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] not in enums.OBSERVABLE_TYPES and\n                obj['type'] not in enums.OBSERVABLE_RESERVED_OBJECTS and\n                not CUSTOM_TYPE_PREFIX_RE.match(obj['type'])):\n            yield JSONError(\"Custom Observable Object type '%s' should start \"\n                            \"with 'x-' followed by a source unique identifier \"\n                            \"(like a domain name with dots replaced by \"\n                            \"hyphens), a hyphen and then the name.\"\n                            % obj['type'], instance['id'],\n                            'custom-prefix')", "response": "Ensure custom observable objects follow strict naming style conventions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef custom_observable_object_prefix_lax(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] not in enums.OBSERVABLE_TYPES and\n                obj['type'] not in enums.OBSERVABLE_RESERVED_OBJECTS and\n                not CUSTOM_TYPE_LAX_PREFIX_RE.match(obj['type'])):\n            yield JSONError(\"Custom Observable Object type '%s' should start \"\n                            \"with 'x-'.\"\n                            % obj['type'], instance['id'],\n                            'custom-prefix-lax')", "response": "Ensure custom observable objects follow naming style conventions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef custom_object_extension_prefix_strict(instance):\n    for key, obj in instance['objects'].items():\n        if not ('extensions' in obj and 'type' in obj and\n                obj['type'] in enums.OBSERVABLE_EXTENSIONS):\n            continue\n        for ext_key in obj['extensions']:\n            if (ext_key not in enums.OBSERVABLE_EXTENSIONS[obj['type']] and\n                    not CUSTOM_TYPE_PREFIX_RE.match(ext_key)):\n                yield JSONError(\"Custom Cyber Observable Object extension type\"\n                                \" '%s' should start with 'x-' followed by a source \"\n                                \"unique identifier (like a domain name with dots \"\n                                \"replaced by hyphens), a hyphen and then the name.\"\n                                % ext_key, instance['id'],\n                                'custom-prefix')", "response": "Ensure custom observable object extensions follow strict naming style."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nensure custom observable object extensions follow naming style conventions.", "response": "def custom_object_extension_prefix_lax(instance):\n    \"\"\"Ensure custom observable object extensions follow naming style\n    conventions.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if not ('extensions' in obj and 'type' in obj and\n                obj['type'] in enums.OBSERVABLE_EXTENSIONS):\n            continue\n        for ext_key in obj['extensions']:\n            if (ext_key not in enums.OBSERVABLE_EXTENSIONS[obj['type']] and\n                    not CUSTOM_TYPE_LAX_PREFIX_RE.match(ext_key)):\n                yield JSONError(\"Custom Cyber Observable Object extension type\"\n                                \" '%s' should start with 'x-'.\"\n                                % ext_key, instance['id'],\n                                'custom-prefix-lax')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nensuring observable object custom properties follow strict naming style.", "response": "def custom_observable_properties_prefix_strict(instance):\n    \"\"\"Ensure observable object custom properties follow strict naming style\n    conventions.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if 'type' not in obj:\n            continue\n        type_ = obj['type']\n\n        for prop in obj:\n            # Check objects' properties\n            if (type_ in enums.OBSERVABLE_PROPERTIES and\n                prop not in enums.OBSERVABLE_PROPERTIES[type_] and\n                    not CUSTOM_PROPERTY_PREFIX_RE.match(prop)):\n                yield JSONError(\"Cyber Observable Object custom property '%s' \"\n                                \"should start with 'x_' followed by a source \"\n                                \"unique identifier (like a domain name with \"\n                                \"dots replaced by hyphens), a hyphen and then the\"\n                                \" name.\"\n                                % prop, instance['id'],\n                                'custom-prefix')\n            # Check properties of embedded cyber observable types\n            if (type_ in enums.OBSERVABLE_EMBEDDED_PROPERTIES and\n                    prop in enums.OBSERVABLE_EMBEDDED_PROPERTIES[type_]):\n                for embed_prop in obj[prop]:\n                    if isinstance(embed_prop, dict):\n                        for embedded in embed_prop:\n                            if (embedded not in enums.OBSERVABLE_EMBEDDED_PROPERTIES[type_][prop] and\n                                    not CUSTOM_PROPERTY_PREFIX_RE.match(embedded)):\n                                yield JSONError(\"Cyber Observable Object custom \"\n                                                \"property '%s' in the %s property of \"\n                                                \"%s object should start with 'x_' \"\n                                                \"followed by a source unique \"\n                                                \"identifier (like a domain name with \"\n                                                \"dots replaced by hyphens), a hyphen and \"\n                                                \"then the name.\"\n                                                % (embedded, prop, type_), instance['id'],\n                                                'custom-prefix')\n                    elif (embed_prop not in enums.OBSERVABLE_EMBEDDED_PROPERTIES[type_][prop] and\n                            not CUSTOM_PROPERTY_PREFIX_RE.match(embed_prop)):\n                        yield JSONError(\"Cyber Observable Object custom \"\n                                        \"property '%s' in the %s property of \"\n                                        \"%s object should start with 'x_' \"\n                                        \"followed by a source unique \"\n                                        \"identifier (like a domain name with \"\n                                        \"dots replaced by hyphens), a hyphen and \"\n                                        \"then the name.\"\n                                        % (embed_prop, prop, type_), instance['id'],\n                                        'custom-prefix')\n\n        # Check object extensions' properties\n        if (type_ in enums.OBSERVABLE_EXTENSIONS and 'extensions' in obj):\n            for ext_key in obj['extensions']:\n\n                if ext_key in enums.OBSERVABLE_EXTENSIONS[type_]:\n                    for ext_prop in obj['extensions'][ext_key]:\n                        if (ext_prop not in enums.OBSERVABLE_EXTENSION_PROPERTIES[ext_key] and\n                                not CUSTOM_PROPERTY_PREFIX_RE.match(ext_prop)):\n                            yield JSONError(\"Cyber Observable Object custom \"\n                                            \"property '%s' in the %s extension \"\n                                            \"should start with 'x_' followed by a \"\n                                            \"source unique identifier (like a \"\n                                            \"domain name with dots replaced by \"\n                                            \"hyphens), a hyphen and then the name.\"\n                                            % (ext_prop, ext_key), instance['id'],\n                                            'custom-prefix')\n\n                if ext_key in enums.OBSERVABLE_EXTENSIONS[type_]:\n                    for ext_prop in obj['extensions'][ext_key]:\n                        if (ext_key in enums.OBSERVABLE_EXTENSION_EMBEDDED_PROPERTIES and\n                                ext_prop in enums.OBSERVABLE_EXTENSION_EMBEDDED_PROPERTIES[ext_key]):\n                            for embed_prop in obj['extensions'][ext_key][ext_prop]:\n                                if not (isinstance(embed_prop, Iterable) and not isinstance(embed_prop, string_types)):\n                                    embed_prop = [embed_prop]\n                                for p in embed_prop:\n                                    if (p not in enums.OBSERVABLE_EXTENSION_EMBEDDED_PROPERTIES[ext_key][ext_prop] and\n                                            not CUSTOM_PROPERTY_PREFIX_RE.match(p)):\n                                        yield JSONError(\"Cyber Observable Object \"\n                                                        \"custom property '%s' in the %s \"\n                                                        \"property of the %s extension should \"\n                                                        \"start with 'x_' followed by a source \"\n                                                        \"unique identifier (like a domain name\"\n                                                        \" with dots replaced by hyphens), a \"\n                                                        \"hyphen and then the name.\"\n                                                        % (p, ext_prop, ext_key), instance['id'],\n                                                        'custom-prefix')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef network_traffic_ports(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'network-traffic' and\n                ('src_port' not in obj or 'dst_port' not in obj)):\n            yield JSONError(\"The Network Traffic object '%s' should contain \"\n                            \"both the 'src_port' and 'dst_port' properties.\"\n                            % key, instance['id'], 'network-traffic-ports')", "response": "Ensure Network Traffic objects contain both src_port and dst_port properties."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mime_type(instance):\n    mime_pattern = re.compile(r'^(application|audio|font|image|message|model'\n                              '|multipart|text|video)/[a-zA-Z0-9.+_-]+')\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'file' and 'mime_type' in obj):\n            if enums.media_types():\n                if obj['mime_type'] not in enums.media_types():\n                    yield JSONError(\"The 'mime_type' property of object '%s' \"\n                                    \"('%s') should be an IANA registered MIME \"\n                                    \"Type of the form 'type/subtype'.\"\n                                    % (key, obj['mime_type']), instance['id'],\n                                    'mime-type')\n            else:\n                info(\"Can't reach IANA website; using regex for mime types.\")\n                if not mime_pattern.match(obj['mime_type']):\n                    yield JSONError(\"The 'mime_type' property of object '%s' \"\n                                    \"('%s') should be an IANA MIME Type of the\"\n                                    \" form 'type/subtype'.\"\n                                    % (key, obj['mime_type']), instance['id'],\n                                    'mime-type')", "response": "Ensure the mime_type property of file objects comes from the IANA media type registry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef protocols(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'network-traffic' and\n                'protocols' in obj):\n            for prot in obj['protocols']:\n                if enums.protocols():\n                    if prot not in enums.protocols():\n                        yield JSONError(\"The 'protocols' property of object \"\n                                        \"'%s' contains a value ('%s') not in \"\n                                        \"IANA Service Name and Transport \"\n                                        \"Protocol Port Number Registry.\"\n                                        % (key, prot), instance['id'],\n                                        'protocols')\n                else:\n                    info(\"Can't reach IANA website; using regex for protocols.\")\n                    if not PROTOCOL_RE.match(prot):\n                        yield JSONError(\"The 'protocols' property of object \"\n                                        \"'%s' contains a value ('%s') not in \"\n                                        \"IANA Service Name and Transport \"\n                                        \"Protocol Port Number Registry.\"\n                                        % (key, prot), instance['id'],\n                                        'protocols')", "response": "Ensure the protocols property of network - traffic objects contains only\n    values from the IANA Service Name and Transport Protocol Port Number Registry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ipfix(instance):\n    ipf_pattern = re.compile(r'^[a-z][a-zA-Z0-9]+')\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'network-traffic' and\n                'ipfix' in obj):\n            for ipf in obj['ipfix']:\n                if enums.ipfix():\n                    if ipf not in enums.ipfix():\n                        yield JSONError(\"The 'ipfix' property of object \"\n                                        \"'%s' contains a key ('%s') not in \"\n                                        \"IANA IP Flow Information Export \"\n                                        \"(IPFIX) Entities Registry.\"\n                                        % (key, ipf), instance['id'],\n                                        'ipfix')\n                else:\n                    info(\"Can't reach IANA website; using regex for ipfix.\")\n                    if not ipf_pattern.match(ipf):\n                        yield JSONError(\"The 'ipfix' property of object \"\n                                        \"'%s' contains a key ('%s') not in \"\n                                        \"IANA IP Flow Information Export \"\n                                        \"(IPFIX) Entities Registry.\"\n                                        % (key, ipf), instance['id'],\n                                        'ipfix')", "response": "Ensure the ipfix property of network - traffic objects contains only\n    values from the IANA IP Flow Information Export Entities Registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures the keys of the request_headers property of the HTTP extensions of network - traffic objects conform to the format for HTTP request headers.", "response": "def http_request_headers(instance):\n    \"\"\"Ensure the keys of the 'request_headers' property of the http-request-\n    ext extension of network-traffic objects conform to the format for HTTP\n    request headers. Use a regex because there isn't a definitive source.\n    https://www.iana.org/assignments/message-headers/message-headers.xhtml does\n    not differentiate between request and response headers, and leaves out\n    several common non-standard request fields listed elsewhere.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'network-traffic'):\n            try:\n                headers = obj['extensions']['http-request-ext']['request_header']\n            except KeyError:\n                continue\n\n            for hdr in headers:\n                if hdr not in enums.HTTP_REQUEST_HEADERS:\n                    yield JSONError(\"The 'request_header' property of object \"\n                                    \"'%s' contains an invalid HTTP request \"\n                                    \"header ('%s').\"\n                                    % (key, hdr), instance['id'],\n                                    'http-request-headers')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring the keys of the options property of the socket - ext extension of network - traffic objects are only valid socket options.", "response": "def socket_options(instance):\n    \"\"\"Ensure the keys of the 'options' property of the socket-ext extension of\n    network-traffic objects are only valid socket options (SO_*).\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'network-traffic'):\n            try:\n                options = obj['extensions']['socket-ext']['options']\n            except KeyError:\n                continue\n\n            for opt in options:\n                if opt not in enums.SOCKET_OPTIONS:\n                    yield JSONError(\"The 'options' property of object '%s' \"\n                                    \"contains a key ('%s') that is not a valid\"\n                                    \" socket option (SO_*).\"\n                                    % (key, opt), instance['id'], 'socket-options')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures the keys of the document_info_dict property of the pdf - ext extension of file objects are only valid PDF Document Information Dictionary Keys.", "response": "def pdf_doc_info(instance):\n    \"\"\"Ensure the keys of the 'document_info_dict' property of the pdf-ext\n    extension of file objects are only valid PDF Document Information\n    Dictionary Keys.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'file'):\n            try:\n                did = obj['extensions']['pdf-ext']['document_info_dict']\n            except KeyError:\n                continue\n\n            for elem in did:\n                if elem not in enums.PDF_DID:\n                    yield JSONError(\"The 'document_info_dict' property of \"\n                                    \"object '%s' contains a key ('%s') that is\"\n                                    \" not a valid PDF Document Information \"\n                                    \"Dictionary key.\"\n                                    % (key, elem), instance['id'],\n                                    'pdf-doc-info')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nensure that the country property of location objects is a valid ISO 3166 - 1 ALPHA - 2 Code.", "response": "def countries(instance):\n    \"\"\"Ensure that the `country` property of `location` objects is a valid\n    ISO 3166-1 ALPHA-2 Code.\n    \"\"\"\n    if (instance['type'] == 'location' and 'country' in instance and not\n            instance['country'].upper() in enums.COUNTRY_CODES):\n\n        return JSONError(\"Location `country` should be a valid ISO 3166-1 \"\n                         \"ALPHA-2 Code.\",\n                         instance['id'], 'marking-definition-type')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring the priority property of windows - process - ext ends in _CLASS.", "response": "def windows_process_priority_format(instance):\n    \"\"\"Ensure the 'priority' property of windows-process-ext ends in '_CLASS'.\n    \"\"\"\n    class_suffix_re = re.compile(r'.+_CLASS$')\n    for key, obj in instance['objects'].items():\n        if 'type' in obj and obj['type'] == 'process':\n            try:\n                priority = obj['extensions']['windows-process-ext']['priority']\n            except KeyError:\n                continue\n            if not class_suffix_re.match(priority):\n                yield JSONError(\"The 'priority' property of object '%s' should\"\n                                \" end in '_CLASS'.\" % key, instance['id'],\n                                'windows-process-priority-format')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring keys in hashes - type properties are no more than 30 characters long.", "response": "def hash_length(instance):\n    \"\"\"Ensure keys in 'hashes'-type properties are no more than 30 characters long.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        if 'type' not in obj:\n            continue\n\n        if obj['type'] == 'file':\n            try:\n                hashes = obj['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if (len(h) > 30):\n                        yield JSONError(\"Object '%s' has a 'hashes' dictionary\"\n                                        \" with a hash of type '%s', which is \"\n                                        \"longer than 30 characters.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                ads = obj['extensions']['ntfs-ext']['alternate_data_streams']\n            except KeyError:\n                pass\n            else:\n                for datastream in ads:\n                    if 'hashes' not in datastream:\n                        continue\n                    for h in datastream['hashes']:\n                        if (len(h) > 30):\n                            yield JSONError(\"Object '%s' has an NTFS extension\"\n                                            \" with an alternate data stream that has a\"\n                                            \" 'hashes' dictionary with a hash of type \"\n                                            \"'%s', which is longer than 30 \"\n                                            \"characters.\"\n                                            % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                head_hashes = obj['extensions']['windows-pebinary-ext']['file_header_hashes']\n            except KeyError:\n                pass\n            else:\n                for h in head_hashes:\n                    if (len(h) > 30):\n                        yield JSONError(\"Object '%s' has a Windows PE Binary \"\n                                        \"File extension with a file header hash of \"\n                                        \"'%s', which is longer than 30 \"\n                                        \"characters.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                hashes = obj['extensions']['windows-pebinary-ext']['optional_header']['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if (len(h) > 30):\n                        yield JSONError(\"Object '%s' has a Windows PE Binary \"\n                                        \"File extension with an optional header that \"\n                                        \"has a hash of '%s', which is longer \"\n                                        \"than 30 characters.\"\n                                        % (key, h), instance['id'], 'hash-algo')\n\n            try:\n                sections = obj['extensions']['windows-pebinary-ext']['sections']\n            except KeyError:\n                pass\n            else:\n                for s in sections:\n                    if 'hashes' not in s:\n                        continue\n                    for h in s['hashes']:\n                        if (len(h) > 30):\n                            yield JSONError(\"Object '%s' has a Windows PE \"\n                                            \"Binary File extension with a section that\"\n                                            \" has a hash of '%s', which is \"\n                                            \"longer than 30 characters.\"\n                                            % (key, h), instance['id'], 'hash-algo')\n\n        elif obj['type'] == 'artifact' or obj['type'] == 'x509-certificate':\n            try:\n                hashes = obj['hashes']\n            except KeyError:\n                pass\n            else:\n                for h in hashes:\n                    if (len(h) > 30):\n                        yield JSONError(\"Object '%s' has a 'hashes' dictionary\"\n                                        \" with a hash of type '%s', which is \"\n                                        \"longer than 30 characters.\"\n                                        % (key, h), instance['id'], 'hash-algo')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef duplicate_ids(instance):\n    if instance['type'] != 'bundle' or 'objects' not in instance:\n        return\n\n    unique_ids = {}\n    for obj in instance['objects']:\n        if 'id' not in obj or 'modified' not in obj:\n            continue\n        elif obj['id'] not in unique_ids:\n            unique_ids[obj['id']] = obj['modified']\n        elif obj['modified'] == unique_ids[obj['id']]:\n            yield JSONError(\"Duplicate ID '%s' has identical `modified` timestamp.\"\n                            \" If they are different versions of the same object, \"\n                            \"they should have different `modified` properties.\"\n                            % obj['id'], instance['id'], 'duplicate-ids')", "response": "Ensure objects with duplicate IDs have different modified timestamps."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing the list of SHOULD validators to be run by the validator.", "response": "def list_shoulds(options):\n    \"\"\"Construct the list of 'SHOULD' validators to be run by the validator.\n    \"\"\"\n    validator_list = []\n\n    # Default: enable all\n    if not options.disabled and not options.enabled:\n        validator_list.extend(CHECKS['all'])\n        return validator_list\n\n    # --disable\n    # Add SHOULD requirements to the list unless disabled\n    if options.disabled:\n        if 'all' not in options.disabled:\n            if 'format-checks' not in options.disabled:\n                if 'custom-prefix' not in options.disabled:\n                    validator_list.append(CHECKS['custom-prefix'])\n                elif 'custom-prefix-lax' not in options.disabled:\n                    validator_list.append(CHECKS['custom-prefix-lax'])\n                if 'open-vocab-format' not in options.disabled:\n                    validator_list.append(CHECKS['open-vocab-format'])\n                if 'kill-chain-names' not in options.disabled:\n                    validator_list.append(CHECKS['kill-chain-names'])\n                if 'observable-object-keys' not in options.disabled:\n                    validator_list.append(CHECKS['observable-object-keys'])\n                if 'observable-dictionary-keys' not in options.disabled:\n                    validator_list.append(CHECKS['observable-dictionary-keys'])\n                if 'windows-process-priority-format' not in options.disabled:\n                    validator_list.append(CHECKS['windows-process-priority-format'])\n                if 'hash-length' not in options.disabled:\n                    validator_list.append(CHECKS['hash-length'])\n\n            if 'approved-values' not in options.disabled:\n                if 'marking-definition-type' not in options.disabled:\n                    validator_list.append(CHECKS['marking-definition-type'])\n                if 'relationship-types' not in options.disabled:\n                    validator_list.append(CHECKS['relationship-types'])\n                if 'duplicate-ids' not in options.disabled:\n                    validator_list.append(CHECKS['duplicate-ids'])\n                if 'all-vocabs' not in options.disabled:\n                    if 'attack-motivation' not in options.disabled:\n                        validator_list.append(CHECKS['attack-motivation'])\n                    if 'attack-resource-level' not in options.disabled:\n                        validator_list.append(CHECKS['attack-resource-level'])\n                    if 'identity-class' not in options.disabled:\n                        validator_list.append(CHECKS['identity-class'])\n                    if 'indicator-types' not in options.disabled:\n                        validator_list.append(CHECKS['indicator-types'])\n                    if 'industry-sector' not in options.disabled:\n                        validator_list.append(CHECKS['industry-sector'])\n                    if 'malware-types' not in options.disabled:\n                        validator_list.append(CHECKS['malware-types'])\n                    if 'report-types' not in options.disabled:\n                        validator_list.append(CHECKS['report-types'])\n                    if 'threat-actor-types' not in options.disabled:\n                        validator_list.append(CHECKS['threat-actor-types'])\n                    if 'threat-actor-role' not in options.disabled:\n                        validator_list.append(CHECKS['threat-actor-role'])\n                    if 'threat-actor-sophistication' not in options.disabled:\n                        validator_list.append(CHECKS['threat-actor-sophistication'])\n                    if 'tool-types' not in options.disabled:\n                        validator_list.append(CHECKS['tool-types'])\n                    if 'region' not in options.disabled:\n                        validator_list.append(CHECKS['region'])\n                    if 'hash-algo' not in options.disabled:\n                        validator_list.append(CHECKS['hash-algo'])\n                    if 'windows-pebinary-type' not in options.disabled:\n                        validator_list.append(CHECKS['windows-pebinary-type'])\n                    if 'account-type' not in options.disabled:\n                        validator_list.append(CHECKS['account-type'])\n                if 'all-external-sources' not in options.disabled:\n                    if 'mime-type' not in options.disabled:\n                        validator_list.append(CHECKS['mime-type'])\n                    if 'protocols' not in options.disabled:\n                        validator_list.append(CHECKS['protocols'])\n                    if 'ipfix' not in options.disabled:\n                        validator_list.append(CHECKS['ipfix'])\n                    if 'http-request-headers' not in options.disabled:\n                        validator_list.append(CHECKS['http-request-headers'])\n                    if 'socket-options' not in options.disabled:\n                        validator_list.append(CHECKS['socket-options'])\n                    if 'pdf-doc-info' not in options.disabled:\n                        validator_list.append(CHECKS['pdf-doc-info'])\n                    if 'countries' not in options.disabled:\n                        validator_list.append(CHECKS['countries'])\n\n            if 'network-traffic-ports' not in options.disabled:\n                validator_list.append(CHECKS['network-traffic-ports'])\n            if 'extref-hashes' not in options.disabled:\n                validator_list.append(CHECKS['extref-hashes'])\n\n    # --enable\n    if options.enabled:\n        for check in options.enabled:\n            try:\n                if CHECKS[check] in validator_list:\n                    continue\n\n                if type(CHECKS[check]) is list:\n                    validator_list.extend(CHECKS[check])\n                else:\n                    validator_list.append(CHECKS[check])\n            except KeyError:\n                raise JSONError(\"%s is not a valid check!\" % check)\n\n    return validator_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring timestamps contain sane months days hours minutes seconds.", "response": "def timestamp(instance):\n    \"\"\"Ensure timestamps contain sane months, days, hours, minutes, seconds.\n    \"\"\"\n    ts_re = re.compile(r\"^[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?Z$\")\n    timestamp_props = ['created', 'modified']\n    if instance['type'] in enums.TIMESTAMP_PROPERTIES:\n        timestamp_props += enums.TIMESTAMP_PROPERTIES[instance['type']]\n\n    for tprop in timestamp_props:\n        if tprop in instance and ts_re.match(instance[tprop]):\n            # Don't raise an error if schemas will catch it\n            try:\n                parser.parse(instance[tprop])\n            except ValueError as e:\n                yield JSONError(\"'%s': '%s' is not a valid timestamp: %s\"\n                                % (tprop, instance[tprop], str(e)), instance['id'])\n\n    if has_cyber_observable_data(instance):\n        for key, obj in instance['objects'].items():\n            if 'type' not in obj:\n                continue\n            if obj['type'] in enums.TIMESTAMP_OBSERVABLE_PROPERTIES:\n                for tprop in enums.TIMESTAMP_OBSERVABLE_PROPERTIES[obj['type']]:\n                    if tprop in obj and ts_re.match(obj[tprop]):\n                        # Don't raise an error if schemas will catch it\n                        try:\n                            parser.parse(obj[tprop])\n                        except ValueError as e:\n                            yield JSONError(\"'%s': '%s': '%s' is not a valid timestamp: %s\"\n                                            % (obj['type'], tprop, obj[tprop], str(e)), instance['id'])\n            if obj['type'] in enums.TIMESTAMP_EMBEDDED_PROPERTIES:\n                for embed in enums.TIMESTAMP_EMBEDDED_PROPERTIES[obj['type']]:\n                    if embed in obj:\n                        for tprop in enums.TIMESTAMP_EMBEDDED_PROPERTIES[obj['type']][embed]:\n                            if embed == 'extensions':\n                                for ext in obj[embed]:\n                                    if tprop in obj[embed][ext] and ts_re.match(obj[embed][ext][tprop]):\n                                        try:\n                                            parser.parse(obj[embed][ext][tprop])\n                                        except ValueError as e:\n                                            yield JSONError(\"'%s': '%s': '%s': '%s' is not a valid timestamp: %s\"\n                                                            % (obj['type'], ext, tprop, obj[embed][ext][tprop], str(e)), instance['id'])\n                            elif tprop in obj[embed] and ts_re.match(obj[embed][tprop]):\n                                try:\n                                    parser.parse(obj[embed][tprop])\n                                except ValueError as e:\n                                    yield JSONError(\"'%s': '%s': '%s' is not a valid timestamp: %s\"\n                                                    % (obj['type'], tprop, obj[embed][tprop], str(e)), instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate that modified property is later or equal to created property", "response": "def modified_created(instance):\n    \"\"\"`modified` property must be later or equal to `created` property\n    \"\"\"\n    if 'modified' in instance and 'created' in instance and \\\n            instance['modified'] < instance['created']:\n        msg = \"'modified' (%s) must be later or equal to 'created' (%s)\"\n        return JSONError(msg % (instance['modified'], instance['created']),\n                         instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nensure that the object_marking_refs property of a marking definition object is not circular references.", "response": "def object_marking_circular_refs(instance):\n    \"\"\"Ensure that marking definitions do not contain circular references (ie.\n    they do not reference themselves in the `object_marking_refs` property).\n    \"\"\"\n    if instance['type'] != 'marking-definition':\n        return\n\n    if 'object_marking_refs' in instance:\n        for ref in instance['object_marking_refs']:\n            if ref == instance['id']:\n                yield JSONError(\"`object_marking_refs` cannot contain any \"\n                                \"references to this marking definition object\"\n                                \" (no circular references).\", instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the granular_markings property of a marking definition object does not contain circular references.", "response": "def granular_markings_circular_refs(instance):\n    \"\"\"Ensure that marking definitions do not contain circular references (ie.\n    they do not reference themselves in the `granular_markings` property).\n    \"\"\"\n    if instance['type'] != 'marking-definition':\n        return\n\n    if 'granular_markings' in instance:\n        for marking in instance['granular_markings']:\n            if 'marking_ref' in marking and marking['marking_ref'] == instance['id']:\n                yield JSONError(\"`granular_markings` cannot contain any \"\n                                \"references to this marking definition object\"\n                                \" (no circular references).\", instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures selectors in granular markings refer to items which are actually present in the object.", "response": "def marking_selector_syntax(instance):\n    \"\"\"Ensure selectors in granular markings refer to items which are actually\n    present in the object.\n    \"\"\"\n    if 'granular_markings' not in instance:\n        return\n\n    list_index_re = re.compile(r\"\\[(\\d+)\\]\")\n    for marking in instance['granular_markings']:\n        if 'selectors' not in marking:\n            continue\n\n        selectors = marking['selectors']\n        for selector in selectors:\n            segments = selector.split('.')\n\n            obj = instance\n            prev_segmt = None\n            for segmt in segments:\n                index_match = list_index_re.match(segmt)\n                if index_match:\n                    try:\n                        idx = int(index_match.group(1))\n                        obj = obj[idx]\n                    except IndexError:\n                        yield JSONError(\"'%s' is not a valid selector because\"\n                                        \" %s is not a valid index.\"\n                                        % (selector, idx), instance['id'])\n                    except KeyError:\n                        yield JSONError(\"'%s' is not a valid selector because\"\n                                        \" '%s' is not a list.\"\n                                        % (selector, prev_segmt), instance['id'])\n                else:\n                    try:\n                        obj = obj[segmt]\n                    except KeyError as e:\n                        yield JSONError(\"'%s' is not a valid selector because\"\n                                        \" %s is not a property.\"\n                                        % (selector, e), instance['id'])\n                    except TypeError:\n                        yield JSONError(\"'%s' is not a valid selector because\"\n                                        \" '%s' is not a property.\"\n                                        % (selector, segmt), instance['id'])\n                prev_segmt = segmt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef observable_object_references(instance):\n    for key, obj in instance['objects'].items():\n        if 'type' not in obj:\n            continue\n        elif obj['type'] not in enums.OBSERVABLE_PROP_REFS:\n            continue\n\n        obj_type = obj['type']\n        for obj_prop in enums.OBSERVABLE_PROP_REFS[obj_type]:\n            if obj_prop not in obj:\n                continue\n            enum_prop = enums.OBSERVABLE_PROP_REFS[obj_type][obj_prop]\n            if isinstance(enum_prop, list):\n                refs = obj[obj_prop]\n                enum_vals = enum_prop\n                for x in check_observable_refs(refs, obj_prop, enum_prop, '',\n                                               enum_vals, key, instance):\n                    yield x\n\n            elif isinstance(enum_prop, dict):\n                for embedded_prop in enum_prop:\n                    if isinstance(obj[obj_prop], dict):\n                        if embedded_prop not in obj[obj_prop]:\n                            continue\n                        embedded_obj = obj[obj_prop][embedded_prop]\n                        for embed_obj_prop in embedded_obj:\n                            if embed_obj_prop not in enum_prop[embedded_prop]:\n                                continue\n                            refs = embedded_obj[embed_obj_prop]\n                            enum_vals = enum_prop[embedded_prop][embed_obj_prop]\n                            for x in check_observable_refs(refs, obj_prop, enum_prop,\n                                                           embed_obj_prop, enum_vals,\n                                                           key, instance):\n                                yield x\n\n                    elif isinstance(obj[obj_prop], list):\n                        for embedded_list_obj in obj[obj_prop]:\n\n                            if embedded_prop not in embedded_list_obj:\n                                continue\n                            embedded_obj = embedded_list_obj[embedded_prop]\n                            refs = embedded_obj\n                            enum_vals = enum_prop[embedded_prop]\n                            for x in check_observable_refs(refs, obj_prop, enum_prop,\n                                                           embedded_prop, enum_vals,\n                                                           key, instance):\n                                yield x", "response": "Ensure certain observable object properties reference the correct type\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef artifact_mime_type(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'artifact' and 'mime_type' in obj):\n            if enums.media_types():\n                if obj['mime_type'] not in enums.media_types():\n                    yield JSONError(\"The 'mime_type' property of object '%s' \"\n                                    \"('%s') must be an IANA registered MIME \"\n                                    \"Type of the form 'type/subtype'.\"\n                                    % (key, obj['mime_type']), instance['id'])\n\n            else:\n                info(\"Can't reach IANA website; using regex for mime types.\")\n                mime_re = re.compile(r'^(application|audio|font|image|message|model'\n                                     '|multipart|text|video)/[a-zA-Z0-9.+_-]+')\n                if not mime_re.match(obj['mime_type']):\n                    yield JSONError(\"The 'mime_type' property of object '%s' \"\n                                    \"('%s') should be an IANA MIME Type of the\"\n                                    \" form 'type/subtype'.\"\n                                    % (key, obj['mime_type']), instance['id'])", "response": "Ensure the mime_type property of artifact objects comes from the IANA media type registry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure certain properties of cyber observable objects come from the IANA character set list.", "response": "def character_set(instance):\n    \"\"\"Ensure certain properties of cyber observable objects come from the IANA\n    Character Set list.\n    \"\"\"\n    char_re = re.compile(r'^[a-zA-Z0-9_\\(\\)-]+$')\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'directory' and 'path_enc' in obj):\n            if enums.char_sets():\n                if obj['path_enc'] not in enums.char_sets():\n                    yield JSONError(\"The 'path_enc' property of object '%s' \"\n                                    \"('%s') must be an IANA registered \"\n                                    \"character set.\"\n                                    % (key, obj['path_enc']), instance['id'])\n            else:\n                info(\"Can't reach IANA website; using regex for character_set.\")\n                if not char_re.match(obj['path_enc']):\n                    yield JSONError(\"The 'path_enc' property of object '%s' \"\n                                    \"('%s') must be an IANA registered \"\n                                    \"character set.\"\n                                    % (key, obj['path_enc']), instance['id'])\n\n        if ('type' in obj and obj['type'] == 'file' and 'name_enc' in obj):\n            if enums.char_sets():\n                if obj['name_enc'] not in enums.char_sets():\n                    yield JSONError(\"The 'name_enc' property of object '%s' \"\n                                    \"('%s') must be an IANA registered \"\n                                    \"character set.\"\n                                    % (key, obj['name_enc']), instance['id'])\n            else:\n                info(\"Can't reach IANA website; using regex for character_set.\")\n                if not char_re.match(obj['name_enc']):\n                    yield JSONError(\"The 'name_enc' property of object '%s' \"\n                                    \"('%s') must be an IANA registered \"\n                                    \"character set.\"\n                                    % (key, obj['name_enc']), instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef software_language(instance):\n    for key, obj in instance['objects'].items():\n        if ('type' in obj and obj['type'] == 'software' and\n                'languages' in obj):\n            for lang in obj['languages']:\n                if lang not in enums.SOFTWARE_LANG_CODES:\n                    yield JSONError(\"The 'languages' property of object '%s' \"\n                                    \"contains an invalid ISO 639-2 language \"\n                                    \" code ('%s').\"\n                                    % (key, lang), instance['id'])", "response": "Ensure the language property of software objects is a valid ISO 639 - 2 language code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef types_strict(instance):\n    if instance['type'] not in enums.TYPES:\n        yield JSONError(\"Object type '%s' is not one of those defined in the\"\n                        \" specification.\" % instance['type'], instance['id'])\n\n    if has_cyber_observable_data(instance):\n        for key, obj in instance['objects'].items():\n            if 'type' in obj and obj['type'] not in enums.OBSERVABLE_TYPES:\n                yield JSONError(\"Observable object %s is type '%s' which is \"\n                                \"not one of those defined in the \"\n                                \"specification.\"\n                                % (key, obj['type']), instance['id'])", "response": "Ensure that no custom object types are used but only the official ones\n    is used but only the official ones\nInsights from the specification."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef properties_strict(instance):\n    if instance['type'] not in enums.TYPES:\n        return  # only check properties for official objects\n\n    defined_props = enums.PROPERTIES.get(instance['type'], [])\n    for prop in instance.keys():\n        if prop not in defined_props:\n            yield JSONError(\"Property '%s' is not one of those defined in the\"\n                            \" specification.\" % prop, instance['id'])\n\n    if has_cyber_observable_data(instance):\n        for key, obj in instance['objects'].items():\n            type_ = obj.get('type', '')\n            if type_ not in enums.OBSERVABLE_PROPERTIES:\n                continue  # custom observable types handled outside this function\n            observable_props = enums.OBSERVABLE_PROPERTIES.get(type_, [])\n            embedded_props = enums.OBSERVABLE_EMBEDDED_PROPERTIES.get(type_, {})\n            extensions = enums.OBSERVABLE_EXTENSIONS.get(type_, [])\n            for prop in obj.keys():\n                if prop not in observable_props:\n                    yield JSONError(\"Property '%s' is not one of those defined in the\"\n                                    \" specification for %s objects.\"\n                                    % (prop, type_), instance['id'])\n                # Check properties of embedded cyber observable types\n                elif prop in embedded_props:\n                    embedded_prop_keys = embedded_props.get(prop, [])\n                    for embedded_key in obj[prop]:\n                        if isinstance(embedded_key, dict):\n                            for embedded in embedded_key:\n                                if embedded not in embedded_prop_keys:\n                                    yield JSONError(\"Property '%s' is not one of those defined in the\"\n                                                    \" specification for the %s property in %s objects.\"\n                                                    % (embedded, prop, type_), instance['id'])\n                        elif embedded_key not in embedded_prop_keys:\n                            yield JSONError(\"Property '%s' is not one of those defined in the\"\n                                            \" specification for the %s property in %s objects.\"\n                                            % (embedded_key, prop, type_), instance['id'])\n\n            # Check properties of embedded cyber observable types\n            for ext_key in obj.get('extensions', {}):\n                if ext_key not in extensions:\n                    continue  # don't check custom extensions\n                extension_props = enums.OBSERVABLE_EXTENSION_PROPERTIES[ext_key]\n                for ext_prop in obj['extensions'][ext_key]:\n                    if ext_prop not in extension_props:\n                        yield JSONError(\"Property '%s' is not one of those defined in the\"\n                                        \" specification for the %s extension in %s objects.\"\n                                        % (ext_prop, ext_key, type_), instance['id'])\n                    embedded_ext_props = enums.OBSERVABLE_EXTENSION_EMBEDDED_PROPERTIES.get(ext_key, {}).get(ext_prop, [])\n                    if embedded_ext_props:\n                        for embed_ext_prop in obj['extensions'][ext_key].get(ext_prop, []):\n                            if embed_ext_prop not in embedded_ext_props:\n                                yield JSONError(\"Property '%s' in the %s property of the %s extension \"\n                                                \"is not one of those defined in the specification.\"\n                                                % (embed_ext_prop, ext_prop, ext_key), instance['id'])", "response": "Ensure that no custom properties are used but only the official ones\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the syntax of the pattern of an indicator is valid and that the objects and properties referenced by the pattern are valid.", "response": "def patterns(instance, options):\n    \"\"\"Ensure that the syntax of the pattern of an indicator is valid, and that\n    objects and properties referenced by the pattern are valid.\n    \"\"\"\n    if instance['type'] != 'indicator' or 'pattern' not in instance:\n        return\n\n    pattern = instance['pattern']\n    if not isinstance(pattern, string_types):\n        return  # This error already caught by schemas\n    errors = pattern_validator(pattern)\n\n    # Check pattern syntax\n    if errors:\n        for e in errors:\n            yield PatternError(str(e), instance['id'])\n        return\n\n    type_format_re = re.compile(r'^\\-?[a-z0-9]+(-[a-z0-9]+)*\\-?$')\n    property_format_re = re.compile(r'^[a-z0-9_]{3,250}$')\n\n    p = Pattern(pattern)\n    inspection = p.inspect().comparisons\n    for objtype in inspection:\n        # Check observable object types\n        if objtype in enums.OBSERVABLE_TYPES:\n            pass\n        elif options.strict_types:\n            yield PatternError(\"'%s' is not a valid STIX observable type\"\n                               % objtype, instance['id'])\n        elif (not type_format_re.match(objtype) or\n              len(objtype) < 3 or len(objtype) > 250):\n            yield PatternError(\"'%s' is not a valid observable type name\"\n                               % objtype, instance['id'])\n        elif (all(x not in options.disabled for x in ['all', 'format-checks', 'custom-prefix']) and\n              not CUSTOM_TYPE_PREFIX_RE.match(objtype)):\n            yield PatternError(\"Custom Observable Object type '%s' should start \"\n                               \"with 'x-' followed by a source unique identifier \"\n                               \"(like a domain name with dots replaced by \"\n                               \"hyphens), a hyphen and then the name\"\n                               % objtype, instance['id'])\n        elif (all(x not in options.disabled for x in ['all', 'format-checks', 'custom-prefix-lax']) and\n              not CUSTOM_TYPE_LAX_PREFIX_RE.match(objtype)):\n            yield PatternError(\"Custom Observable Object type '%s' should start \"\n                               \"with 'x-'\" % objtype, instance['id'])\n\n        # Check observable object properties\n        expression_list = inspection[objtype]\n        for exp in expression_list:\n            path = exp[0]\n            # Get the property name without list index, dictionary key, or referenced object property\n            prop = path[0]\n            if objtype in enums.OBSERVABLE_PROPERTIES and prop in enums.OBSERVABLE_PROPERTIES[objtype]:\n                continue\n            elif options.strict_properties:\n                yield PatternError(\"'%s' is not a valid property for '%s' objects\"\n                                   % (prop, objtype), instance['id'])\n            elif not property_format_re.match(prop):\n                yield PatternError(\"'%s' is not a valid observable property name\"\n                                   % prop, instance['id'])\n            elif (all(x not in options.disabled for x in ['all', 'format-checks', 'custom-prefix']) and\n                  not CUSTOM_PROPERTY_PREFIX_RE.match(prop)):\n                yield PatternError(\"Cyber Observable Object custom property '%s' \"\n                                   \"should start with 'x_' followed by a source \"\n                                   \"unique identifier (like a domain name with \"\n                                   \"dots replaced by underscores), an \"\n                                   \"underscore and then the name\"\n                                   % prop, instance['id'])\n            elif (all(x not in options.disabled for x in ['all', 'format-checks', 'custom-prefix-lax']) and\n                  not CUSTOM_PROPERTY_LAX_PREFIX_RE.match(prop)):\n                yield PatternError(\"Cyber Observable Object custom property '%s' \"\n                                   \"should start with 'x_'\" % prop, instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconstructing the list of MUST validators to be run by the validator.", "response": "def list_musts(options):\n    \"\"\"Construct the list of 'MUST' validators to be run by the validator.\n    \"\"\"\n    validator_list = [\n        timestamp,\n        modified_created,\n        object_marking_circular_refs,\n        granular_markings_circular_refs,\n        marking_selector_syntax,\n        observable_object_references,\n        artifact_mime_type,\n        character_set,\n        software_language,\n        patterns\n    ]\n\n    # --strict-types\n    if options.strict_types:\n        validator_list.append(types_strict)\n\n    # --strict-properties\n    if options.strict_properties:\n        validator_list.append(properties_strict)\n\n    return validator_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef media_types():\n    if not hasattr(media_types, 'typelist'):\n        tlist = []\n        categories = [\n            'application',\n            'audio',\n            'font',\n            'image',\n            'message',\n            'model',\n            'multipart',\n            'text',\n            'video'\n        ]\n        for cat in categories:\n            try:\n                data = requests.get('http://www.iana.org/assignments/'\n                                    'media-types/%s.csv' % cat)\n            except requests.exceptions.RequestException:\n                return []\n\n            types = []\n            for line in data.iter_lines():\n                if line:\n                    line = line.decode(\"utf-8\")\n                    if line.count(',') > 0:\n                        reg_template = line.split(',')[1]\n                        if reg_template:\n                            types.append(reg_template)\n                        else:\n                            types.append(cat + '/' + line.split(',')[0])\n\n            tlist.extend(types)\n        media_types.typelist = tlist\n    return media_types.typelist", "response": "Return a list of the IANA Media Types in the current language."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef char_sets():\n    if not hasattr(char_sets, 'setlist'):\n        clist = []\n        try:\n            data = requests.get('http://www.iana.org/assignments/character-'\n                                'sets/character-sets-1.csv')\n        except requests.exceptions.RequestException:\n            return []\n\n        for line in data.iter_lines():\n            if line:\n                line = line.decode(\"utf-8\")\n                if line.count(',') > 0:\n                    vals = line.split(',')\n                    if vals[0]:\n                        clist.append(vals[0])\n                    else:\n                        clist.append(vals[1])\n\n        char_sets.setlist = clist\n    return char_sets.setlist", "response": "Return a list of the IANA Character Sets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef protocols():\n    if not hasattr(protocols, 'protlist'):\n        plist = []\n        try:\n            data = requests.get('http://www.iana.org/assignments/service-names'\n                                '-port-numbers/service-names-port-numbers.csv')\n        except requests.exceptions.RequestException:\n            return []\n\n        for line in data.iter_lines():\n            if line:\n                line = line.decode(\"utf-8\")\n                if line.count(',') > 0:\n                    vals = line.split(',')\n                    if vals[0]:\n                        plist.append(vals[0])\n                    if len(vals) > 2 and vals[2] and vals[2] not in plist:\n                        plist.append(vals[2])\n\n        plist.append('ipv4')\n        plist.append('ipv6')\n        plist.append('ssl')\n        plist.append('tls')\n        plist.append('dns')\n        protocols.protlist = plist\n    return protocols.protlist", "response": "Return a list of values from the IANA Service Name and Transport\n    Protocol Port Number Registry."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of values from the list of IANA IP Flow Information Export IANA Entities", "response": "def ipfix():\n    \"\"\"Return a list of values from the list of IANA IP Flow Information Export\n    (IPFIX) Entities, or an empty list if the IANA website is unreachable.\n    Store it as a function attribute so that we only build the list once.\n    \"\"\"\n    if not hasattr(ipfix, 'ipflist'):\n        ilist = []\n        try:\n            data = requests.get('http://www.iana.org/assignments/ipfix/ipfix-'\n                                'information-elements.csv')\n        except requests.exceptions.RequestException:\n            return []\n\n        for line in data.iter_lines():\n            if line:\n                line = line.decode(\"utf-8\")\n                if re.match(r'^\\d+(,[a-zA-Z0-9]+){2},', line):\n                    vals = line.split(',')\n                    if vals[1]:\n                        ilist.append(vals[1])\n\n        ipfix.ipflist = ilist\n    return ipfix.ipflist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_level(log_function, fmt, level, *args):\n    if _SILENT:\n        return\n\n    msg = fmt % args\n    spaces = '    ' * level\n    log_function(\"%s%s\" % (spaces, msg))", "response": "Print a formatted message to stdout prepended by spaces. Useful for printing hierarchical information like bullet lists."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints fatal errors that occurred during validation runs.", "response": "def print_fatal_results(results, level=0):\n    \"\"\"Print fatal errors that occurred during validation runs.\n    \"\"\"\n    print_level(logger.critical, _RED + \"[X] Fatal Error: %s\", level, results.error)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_schema_results(results, level=0):\n    for error in results.errors:\n        print_level(logger.error, _RED + \"[X] %s\", level, error)", "response": "Print JSON Schema validation errors to stdout."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_warning_results(results, level=0):\n    marker = _YELLOW + \"[!] \"\n\n    for warning in results.warnings:\n        print_level(logger.warning, marker + \"Warning: %s\", level, warning)", "response": "Print warning messages found during validation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints a header for the results of a file or object.", "response": "def print_results_header(identifier, is_valid):\n    \"\"\"Print a header for the results of either a file or an object.\n\n    \"\"\"\n    print_horizontal_rule()\n    print_level(logger.info, \"[-] Results for: %s\", 0, identifier)\n\n    if is_valid:\n        marker = _GREEN + \"[+]\"\n        verdict = \"Valid\"\n        log_func = logger.info\n    else:\n        marker = _RED + \"[X]\"\n        verdict = \"Invalid\"\n        log_func = logger.error\n    print_level(log_func, \"%s STIX JSON: %s\", 0, marker, verdict)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting the results of validating an object.", "response": "def print_object_results(obj_result):\n    \"\"\"Print the results of validating an object.\n\n    Args:\n        obj_result: An ObjectValidationResults instance.\n\n    \"\"\"\n    print_results_header(obj_result.object_id, obj_result.is_valid)\n\n    if obj_result.warnings:\n        print_warning_results(obj_result, 1)\n    if obj_result.errors:\n        print_schema_results(obj_result, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_file_results(file_result):\n    print_results_header(file_result.filepath, file_result.is_valid)\n\n    for object_result in file_result.object_results:\n        if object_result.warnings:\n            print_warning_results(object_result, 1)\n        if object_result.errors:\n            print_schema_results(object_result, 1)\n\n    if file_result.fatal:\n        print_fatal_results(file_result.fatal, 1)", "response": "Prints the results of validating a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_results(results):\n    if not isinstance(results, list):\n        results = [results]\n\n    for r in results:\n        try:\n            r.log()\n        except AttributeError:\n            raise ValueError('Argument to print_results() must be a list of '\n                             'FileValidationResults or ObjectValidationResults.')", "response": "Print results to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vocab_encryption_algo(instance):\n    for key, obj in instance['objects'].items():\n        if 'type' in obj and obj['type'] == 'file':\n            try:\n                enc_algo = obj['encryption_algorithm']\n            except KeyError:\n                continue\n            if enc_algo not in enums.ENCRYPTION_ALGO_OV:\n                yield JSONError(\"Object '%s' has an 'encryption_algorithm' of \"\n                                \"'%s', which is not a value in the \"\n                                \"encryption-algo-ov vocabulary.\"\n                                % (key, enc_algo), instance['id'],\n                                'encryption-algo')", "response": "Ensure file objects encryption_algorithm property is from the availabe encryption - algo - ov vocabulary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that all SDOs being referenced by the SRO are contained within the same bundle.", "response": "def enforce_relationship_refs(instance):\n    \"\"\"Ensures that all SDOs being referenced by the SRO are contained\n    within the same bundle\"\"\"\n    if instance['type'] != 'bundle' or 'objects' not in instance:\n        return\n\n    rel_references = set()\n\n    \"\"\"Find and store all ids\"\"\"\n    for obj in instance['objects']:\n        if obj['type'] != 'relationship':\n            rel_references.add(obj['id'])\n\n    \"\"\"Check if id has been encountered\"\"\"\n    for obj in instance['objects']:\n        if obj['type'] == 'relationship':\n            if obj['source_ref'] not in rel_references:\n                yield JSONError(\"Relationship object %s makes reference to %s \"\n                                \"Which is not found in current bundle \"\n                                % (obj['id'], obj['source_ref']), 'enforce-relationship-refs')\n\n            if obj['target_ref'] not in rel_references:\n                yield JSONError(\"Relationship object %s makes reference to %s \"\n                                \"Which is not found in current bundle \"\n                                % (obj['id'], obj['target_ref']), 'enforce-relationship-refs')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure timestamp properties with a comparison requirement are valid.", "response": "def timestamp_compare(instance):\n    \"\"\"Ensure timestamp properties with a comparison requirement are valid.\n\n    E.g. `modified` must be later or equal to `created`.\n    \"\"\"\n    compares = [('modified', 'ge', 'created')]\n    additional_compares = enums.TIMESTAMP_COMPARE.get(instance.get('type', ''), [])\n    compares.extend(additional_compares)\n\n    for first, op, second in compares:\n        comp = getattr(operator, op)\n        comp_str = get_comparison_string(op)\n\n        if first in instance and second in instance and \\\n                not comp(instance[first], instance[second]):\n            msg = \"'%s' (%s) must be %s '%s' (%s)\"\n            yield JSONError(msg % (first, instance[first], comp_str, second, instance[second]),\n                            instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure that the observable timestamp properties with a comparison requirement are valid.", "response": "def observable_timestamp_compare(instance):\n    \"\"\"Ensure cyber observable timestamp properties with a comparison\n    requirement are valid.\n    \"\"\"\n    for key, obj in instance['objects'].items():\n        compares = enums.TIMESTAMP_COMPARE_OBSERVABLE.get(obj.get('type', ''), [])\n        print(compares)\n        for first, op, second in compares:\n            comp = getattr(operator, op)\n            comp_str = get_comparison_string(op)\n\n            if first in obj and second in obj and \\\n                    not comp(obj[first], obj[second]):\n                msg = \"In object '%s', '%s' (%s) must be %s '%s' (%s)\"\n                yield JSONError(msg % (key, first, obj[first], comp_str, second, obj[second]),\n                                instance['id'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef language_contents(instance):\n    if instance['type'] != 'language-content' or 'contents' not in instance:\n        return\n\n    for key, value in instance['contents'].items():\n        if key not in enums.LANG_CODES:\n            yield JSONError(\"Invalid key '%s' in 'contents' property must be\"\n                            \" an RFC 5646 code\" % key, instance['id'])\n        for subkey, subvalue in value.items():\n            if not PROPERTY_FORMAT_RE.match(subkey):\n                yield JSONError(\"'%s' in '%s' of the 'contents' property is \"\n                                \"invalid and must match a valid property name\"\n                                % (subkey, key), instance['id'], 'observable-dictionary-keys')", "response": "Ensure keys in Language Content s contents dictionary are valid language codes and that the keys in the sub - dictionaries match the rules\n    language codes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_musts(options):\n    validator_list = [\n        timestamp,\n        timestamp_compare,\n        observable_timestamp_compare,\n        object_marking_circular_refs,\n        granular_markings_circular_refs,\n        marking_selector_syntax,\n        observable_object_references,\n        artifact_mime_type,\n        character_set,\n        language,\n        software_language,\n        patterns,\n        language_contents,\n    ]\n\n    # --strict-types\n    if options.strict_types:\n        validator_list.append(types_strict)\n\n    # --strict-properties\n    if options.strict_properties:\n        validator_list.append(properties_strict)\n\n    return validator_list", "response": "Construct the list of MUST validators to be run by the validator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_code(results):\n    status = EXIT_SUCCESS\n\n    for file_result in results:\n        error = any(object_result.errors for object_result in file_result.object_results)\n\n        fatal = file_result.fatal\n\n        if error:\n            status |= EXIT_SCHEMA_INVALID\n        if fatal:\n            status |= EXIT_VALIDATION_ERROR\n\n    return status", "response": "Determines the exit status code to be returned from a script by inspecting the results returned from validating files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_args(cmd_args, is_script=False):\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=NewlinesHelpFormatter,\n        epilog=CODES_TABLE\n    )\n\n    # Input options\n    if is_script:\n        parser.add_argument(\n            \"files\",\n            metavar=\"FILES\",\n            nargs=\"*\",\n            default=sys.stdin,\n            help=\"A whitespace separated list of STIX files or directories of \"\n                 \"STIX files to validate. If none given, stdin will be used.\"\n        )\n    parser.add_argument(\n        \"-r\",\n        \"--recursive\",\n        dest=\"recursive\",\n        action=\"store_true\",\n        default=True,\n        help=\"Recursively descend into input directories.\"\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--schemas\",\n        dest=\"schema_dir\",\n        help=\"Custom schema directory. If provided, input will be validated \"\n             \"against these schemas in addition to the STIX schemas bundled \"\n             \"with this script.\"\n    )\n    parser.add_argument(\n        \"--version\",\n        dest=\"version\",\n        default=DEFAULT_VER,\n        help=\"The version of the STIX specification to validate against (e.g. \"\n             \"\\\"2.0\\\").\"\n    )\n\n    # Output options\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        dest=\"verbose\",\n        action=\"store_true\",\n        default=False,\n        help=\"Print informational notes and more verbose error messages.\"\n    )\n\n    parser.add_argument(\n        \"-q\",\n        \"--silent\",\n        dest=\"silent\",\n        action=\"store_true\",\n        default=False,\n        help=\"Silence all output to stdout.\"\n    )\n\n    parser.add_argument(\n        \"-d\",\n        \"--disable\",\n        \"--ignore\",\n        dest=\"disabled\",\n        default=\"\",\n        help=\"A comma-separated list of recommended best practice checks to \"\n             \"skip. By default, no checks are disabled. \\n\\n\"\n             \"Example: --disable 202,210\"\n    )\n\n    parser.add_argument(\n        \"-e\",\n        \"--enable\",\n        \"--select\",\n        dest=\"enabled\",\n        default=\"\",\n        help=\"A comma-separated list of recommended best practice checks to \"\n             \"enable. If the --disable option is not used, no other checks \"\n             \"will be run. By default, all checks are enabled.\\n\\n\"\n             \"Example: --enable 218\"\n    )\n\n    parser.add_argument(\n        \"--strict\",\n        dest=\"strict\",\n        action=\"store_true\",\n        default=False,\n        help=\"Treat warnings as errors and fail validation if any are found.\"\n    )\n\n    parser.add_argument(\n        \"--strict-types\",\n        dest=\"strict_types\",\n        action=\"store_true\",\n        default=False,\n        help=\"Ensure that no custom object types are used, only those defined\"\n             \" in the STIX specification.\"\n    )\n\n    parser.add_argument(\n        \"--strict-properties\",\n        dest=\"strict_properties\",\n        action=\"store_true\",\n        default=False,\n        help=\"Ensure that no custom properties are used, only those defined\"\n             \" in the STIX specification.\"\n    )\n\n    parser.add_argument(\n        \"--no-cache\",\n        dest=\"no_cache\",\n        action=\"store_true\",\n        default=False,\n        help=\"Disable the caching of external source values.\"\n    )\n\n    parser.add_argument(\n        \"--refresh-cache\",\n        dest=\"refresh_cache\",\n        action=\"store_true\",\n        default=False,\n        help=\"Clears the cache of external source values, then \"\n             \"during validation downloads them again.\"\n    )\n\n    parser.add_argument(\n        \"--clear-cache\",\n        dest=\"clear_cache\",\n        action=\"store_true\",\n        default=False,\n        help=\"Clear the cache of external source values after validation.\"\n    )\n\n    parser.add_argument(\n        \"--enforce-refs\",\n        dest=\"enforce_refs\",\n        action=\"store_true\",\n        default=False,\n        help=\"Ensures that all SDOs being referenced by SROs are contained \"\n             \"within the same bundle.\"\n    )\n\n    args = parser.parse_args(cmd_args)\n\n    if not is_script:\n        args.files = \"\"\n    if not args.version:\n        args.version = DEFAULT_VER\n\n    return ValidationOptions(args)", "response": "Parses a list of command line arguments into a ValidationOptions object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_requests_cache(refresh_cache=False):\n    # Cache data from external sources; used in some checks\n    dirs = AppDirs(\"stix2-validator\", \"OASIS\")\n    # Create cache dir if doesn't exist\n    try:\n        os.makedirs(dirs.user_cache_dir)\n    except OSError as e:\n        if e.errno != errno.EEXIST:\n            raise\n    requests_cache.install_cache(\n        cache_name=os.path.join(dirs.user_cache_dir, 'py{}cache'.format(\n            sys.version_info[0])),\n        expire_after=datetime.timedelta(weeks=1))\n\n    if refresh_cache:\n        clear_requests_cache()", "response": "Initializes a requests cache for the given node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_tag(self, context, kwargs, nodelist):\n        '''render content with \"active\" urls logic'''\n        # load configuration from passed options\n        self.load_configuration(**kwargs)\n\n        # get request from context\n        request = context['request']\n\n        # get full path from request\n        self.full_path = request.get_full_path()\n\n        # render content of template tag\n        context.push()\n        content = nodelist.render(context)\n        context.pop()\n\n        # check content for \"active\" urls\n        content = render_content(\n            content,\n            full_path=self.full_path,\n            parent_tag=self.parent_tag,\n            css_class=self.css_class,\n            menu=self.menu,\n            ignore_params=self.ignore_params,\n        )\n\n        return content", "response": "render content with active urls logic"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse content of extension", "response": "def parse(self, parser):\n        '''parse content of extension'''\n        # line number of token that started the tag\n        lineno = next(parser.stream).lineno\n\n        # template context\n        context = nodes.ContextReference()\n\n        # parse keyword arguments\n        kwargs = []\n\n        while parser.stream.look().type == lexer.TOKEN_ASSIGN:\n            key = parser.stream.expect(lexer.TOKEN_NAME)\n            next(parser.stream)\n            kwargs.append(\n                nodes.Keyword(key.value, parser.parse_expression()),\n            )\n            parser.stream.skip_if('comma')\n        # parse content of the activeurl block up to endactiveurl\n        body = parser.parse_statements(['name:endactiveurl'], drop_needle=True)\n\n        args = [context]\n\n        call_method = self.call_method(\n            'render_tag',\n            args=args,\n            kwargs=kwargs,\n        )\n\n        return nodes.CallBlock(call_method, [], [], body).set_lineno(lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders content with active urls logic", "response": "def render_tag(self, context, caller, **kwargs):\n        '''render content with \"active\" urls logic'''\n        # load configuration from passed options\n        self.load_configuration(**kwargs)\n\n        # get request from context\n        request = context['request']\n\n        # get full path from request\n        self.full_path = request.get_full_path()\n\n        # render content of extension\n        content = caller()\n\n        # check content for \"active\" urls\n        content = render_content(\n            content,\n            full_path=self.full_path,\n            parent_tag=self.parent_tag,\n            css_class=self.css_class,\n            menu=self.menu,\n            ignore_params=self.ignore_params,\n        )\n\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef yesno_to_bool(value, varname):\n    if isinstance(value, bool):\n        if value:\n            value = 'yes'\n        else:\n            value = 'no'\n    elif value is None:\n        value = 'no'\n\n    # check value configuration, set boolean value\n    if value.lower() in ('yes', 'true'):\n        value = True\n    elif value.lower() in ('no', 'false'):\n        value = False\n    else:\n        raise ImproperlyConfigured(\n            'activeurl: malformed param value for %s' % varname\n        )\n    return value", "response": "Return True or False from yes or no."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_active(url, element, **kwargs):\n    '''check \"active\" url, apply css_class'''\n    menu = yesno_to_bool(kwargs['menu'], 'menu')\n    ignore_params = yesno_to_bool(kwargs['ignore_params'], 'ignore_params')\n\n    # check missing href parameter\n    if not url.attrib.get('href', None) is None:\n        # get href attribute\n        href = url.attrib['href'].strip()\n\n        # href=\"#\" is often used when links shouldn't be handled by browsers.\n        # For example, Bootstrap uses this for expandable menus on\n        # small screens, see\n        # https://getbootstrap.com/docs/4.0/components/navs/#using-dropdowns\n        if href == '#':\n            return False\n\n        # split into urlparse object\n        href = urlparse.urlsplit(href)\n\n        # cut off hashtag (anchor)\n        href = href._replace(fragment='')\n\n        # cut off get params (?key=var&etc=var2)\n        if ignore_params:\n            href = href._replace(query='')\n            kwargs['full_path'] = urlparse.urlunsplit(\n                urlparse.urlsplit(\n                    kwargs['full_path']\n                )._replace(query='')\n            )\n\n        # build urlparse object back into string\n        href = urlparse.urlunsplit(href)\n\n        # check empty href\n        if href == '':\n            # replace href with current location\n            href = kwargs['full_path']\n        # compare full_path with href according to menu configuration\n\n        if menu:\n            # try mark \"root\" (/) url as \"active\", in equals way\n            if href == '/' == kwargs['full_path']:\n                logic = True\n            # skip \"root\" (/) url, otherwise it will be always \"active\"\n            elif href != '/':\n                # start with logic\n                logic = (\n                    kwargs['full_path'].startswith(href)\n                    or\n                    # maybe an urlquoted href was supplied\n                    urlquote(kwargs['full_path']).startswith(href)\n                    or\n                    kwargs['full_path'].startswith(urlquote(href))\n                )\n            else:\n                logic = False\n        else:\n            # equals logic\n            logic = (\n                kwargs['full_path'] == href\n                or\n                # maybe an urlquoted href was supplied\n                urlquote(kwargs['full_path']) == href\n                or\n                kwargs['full_path'] == urlquote(href)\n            )\n        # \"active\" url found\n        if logic:\n            # check parent tag has \"class\" attribute or it is empty\n            if element.attrib.get('class'):\n                # prevent multiple \"class\" attribute adding\n                if kwargs['css_class'] not in element.attrib['class']:\n                    # append \"active\" class\n                    element.attrib['class'] += ' {css_class}'.format(\n                        css_class=kwargs['css_class'],\n                    )\n            else:\n                # create or set (if empty) \"class\" attribute\n                element.attrib['class'] = kwargs['css_class']\n            return True\n    # no \"active\" urls found\n    return False", "response": "check if url is active"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_content(content, **kwargs):\n    '''check content for \"active\" urls'''\n    # valid html root tag\n    try:\n        # render elements tree from content\n        tree = fragment_fromstring(content)\n        # flag for prevent content rerendering, when no \"active\" urls found\n        processed = False\n        # django > 1.5 template boolean\\None variables feature\n        if isinstance(kwargs['parent_tag'], bool):\n            if not kwargs['parent_tag']:\n                kwargs['parent_tag'] = 'self'\n            else:\n                raise ImproperlyConfigured('''\n                    parent_tag=True is not allowed\n                ''')\n        elif kwargs['parent_tag'] is None:\n            kwargs['parent_tag'] = 'self'\n        # if parent_tag is False\\None\\''\\a\\self\n        # \"active\" status will be applied directly to \"<a>\"\n        if kwargs['parent_tag'].lower() in ('a', 'self', ''):\n            # xpath query to get all \"<a>\"\n            urls = tree.xpath('.//a')\n            # check \"active\" status for all urls\n            for url in urls:\n                if check_active(url, url, **kwargs):\n                    # mark flag for rerendering content\n                    processed = True\n        # otherwise css_class must be applied to parent_tag\n        else:\n            # xpath query to get all parent tags\n            elements = tree.xpath('.//{parent_tag}'.format(\n                parent_tag=kwargs['parent_tag'],\n            ))\n            # check all elements for \"active\" \"<a>\"\n            for element in elements:\n                # xpath query to get all \"<a>\"\n                urls = element.xpath('.//a')\n                # check \"active\" status for all urls\n                for url in urls:\n                    if check_active(url, element, **kwargs):\n                        # flag for rerendering content tree\n                        processed = True\n                        # stop checking other \"<a>\"\n                        break\n        # do not rerender content if no \"active\" urls found\n        if processed:\n            # render content from tree\n            return tostring(tree, encoding='unicode')\n    # not valid html root tag\n    except ParserError:\n        # raise an exception with configuration example\n        raise ImproperlyConfigured('''\n            content of {% activeurl %} must have valid html root tag\n            for example\n                {% activeurl %}\n                    <ul>\n                        <li>\n                            <a href=\"/page/\">page</a>\n                        </li>\n                        <li>\n                            <a href=\"/other_page/\">other_page</a>\n                        </li>\n                    </ul>\n                {% endactiveurl %}\n            in this case <ul> is valid content root tag\n        ''')\n    return content", "response": "check content for active urls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render_content(content, **kwargs):\n    '''check content for \"active\" urls, store results to django cache'''\n    # try to take pre rendered content from django cache, if caching is enabled\n    if settings.ACTIVE_URL_CACHE:\n        cache_key = get_cache_key(content, **kwargs)\n\n        # get cached content from django cache backend\n        from_cache = cache.get(cache_key)\n\n        # return pre rendered content if it exist in cache\n        if from_cache is not None:\n            return from_cache\n\n    # render content with \"active\" logic\n    content = check_content(content, **kwargs)\n\n    # write rendered content to django cache backend, if caching is enabled\n    if settings.ACTIVE_URL_CACHE:\n        cache.set(cache_key, content, settings.ACTIVE_URL_CACHE_TIMEOUT)\n\n    return content", "response": "check content for active urls store results to django cache"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading configuration merge with default settings", "response": "def load_configuration(self, **kwargs):\n        '''load configuration, merge with default settings'''\n        # update passed arguments with default values\n        for key in settings.ACTIVE_URL_KWARGS:\n            kwargs.setdefault(key, settings.ACTIVE_URL_KWARGS[key])\n\n        # \"active\" html tag css class\n        self.css_class = kwargs['css_class']\n        # \"active\" html tag\n        self.parent_tag = kwargs['parent_tag']\n        # flipper for menu support\n        self.menu = kwargs['menu']\n        # whether to ignore / chomp get_params\n        self.ignore_params = kwargs['ignore_params']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_response(response, clazz, is_list=False, resource_name=None):\n        target = response.json()[\n            resource_name] if resource_name else response.json()\n        if is_list:\n            return [clazz.from_json(resource) for resource in target]\n        else:\n            return clazz.from_json(target)", "response": "Parse a Marathon response into an object or list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a request to the Marathon server.", "response": "def _do_request(self, method, path, params=None, data=None):\n        \"\"\"Query Marathon server.\"\"\"\n        headers = {\n            'Content-Type': 'application/json', 'Accept': 'application/json'}\n\n        if self.auth_token:\n            headers['Authorization'] = \"token={}\".format(self.auth_token)\n\n        response = None\n        servers = list(self.servers)\n        while servers and response is None:\n            server = servers.pop(0)\n            url = ''.join([server.rstrip('/'), path])\n            try:\n                response = self.session.request(\n                    method, url, params=params, data=data, headers=headers,\n                    auth=self.auth, timeout=self.timeout, verify=self.verify)\n                marathon.log.info('Got response from %s', server)\n            except requests.exceptions.RequestException as e:\n                marathon.log.error(\n                    'Error while calling %s: %s', url, str(e))\n\n        if response is None:\n            raise NoResponseError('No remaining Marathon servers to try')\n\n        if response.status_code >= 500:\n            marathon.log.error('Got HTTP {code}: {body}'.format(\n                code=response.status_code, body=response.text.encode('utf-8')))\n            raise InternalServerError(response)\n        elif response.status_code >= 400:\n            marathon.log.error('Got HTTP {code}: {body}'.format(\n                code=response.status_code, body=response.text.encode('utf-8')))\n            if response.status_code == 404:\n                raise NotFoundError(response)\n            elif response.status_code == 409:\n                raise ConflictError(response)\n            else:\n                raise MarathonHttpError(response)\n        elif response.status_code >= 300:\n            marathon.log.warn('Got HTTP {code}: {body}'.format(\n                code=response.status_code, body=response.text.encode('utf-8')))\n        else:\n            marathon.log.debug('Got HTTP {code}: {body}'.format(\n                code=response.status_code, body=response.text.encode('utf-8')))\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _do_sse_request(self, path, params=None):\n        urls = [''.join([server.rstrip('/'), path]) for server in self.servers]\n        while urls:\n            url = urls.pop()\n            try:\n                # Requests does not set the original Authorization header on cross origin\n                # redirects. If set allow_redirects=True we may get a 401 response.\n                response = self.sse_session.get(\n                    url,\n                    params=params,\n                    stream=True,\n                    headers={'Accept': 'text/event-stream'},\n                    auth=self.auth,\n                    verify=self.verify,\n                    allow_redirects=False\n                )\n            except Exception as e:\n                marathon.log.error(\n                    'Error while calling %s: %s', url, e.message)\n            else:\n                if response.is_redirect and response.next:\n                    urls.append(response.next.url)\n                    marathon.log.debug(\"Got redirect to {}\".format(response.next.url))\n                elif response.ok:\n                    return response.iter_lines()\n\n        raise MarathonError('No remaining Marathon servers to try')", "response": "Query Marathon server for events."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_app(self, app_id, app, minimal=True):\n        app.id = app_id\n        data = app.to_json(minimal=minimal)\n        response = self._do_request('POST', '/v2/apps', data=data)\n        if response.status_code == 201:\n            return self._parse_response(response, MarathonApp)\n        else:\n            return False", "response": "Create and start an app."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_apps(self, cmd=None, embed_tasks=False, embed_counts=False,\n                  embed_deployments=False, embed_readiness=False,\n                  embed_last_task_failure=False, embed_failures=False,\n                  embed_task_stats=False, app_id=None, label=None, **kwargs):\n        \"\"\"List all apps.\n\n        :param str cmd: if passed, only show apps with a matching `cmd`\n        :param bool embed_tasks: embed tasks in result\n        :param bool embed_counts: embed all task counts\n        :param bool embed_deployments: embed all deployment identifier\n        :param bool embed_readiness: embed all readiness check results\n        :param bool embed_last_task_failure: embeds the last task failure\n        :param bool embed_failures: shorthand for embed_last_task_failure\n        :param bool embed_task_stats: embed task stats in result\n        :param str app_id: if passed, only show apps with an 'id' that matches or contains this value\n        :param str label: if passed, only show apps with the selected labels\n        :param kwargs: arbitrary search filters\n\n        :returns: list of applications\n        :rtype: list[:class:`marathon.models.app.MarathonApp`]\n        \"\"\"\n        params = {}\n        if cmd:\n            params['cmd'] = cmd\n        if app_id:\n            params['id'] = app_id\n        if label:\n            params['label'] = label\n\n        embed_params = {\n            'app.tasks': embed_tasks,\n            'app.counts': embed_counts,\n            'app.deployments': embed_deployments,\n            'app.readiness': embed_readiness,\n            'app.lastTaskFailure': embed_last_task_failure,\n            'app.failures': embed_failures,\n            'app.taskStats': embed_task_stats\n        }\n        filtered_embed_params = [k for (k, v) in embed_params.items() if v]\n        if filtered_embed_params:\n            params['embed'] = filtered_embed_params\n\n        response = self._do_request('GET', '/v2/apps', params=params)\n        apps = self._parse_response(\n            response, MarathonApp, is_list=True, resource_name='apps')\n        for k, v in kwargs.items():\n            apps = [o for o in apps if getattr(o, k) == v]\n        return apps", "response": "List all apps in the Marathon system."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a single application.", "response": "def get_app(self, app_id, embed_tasks=False, embed_counts=False,\n                embed_deployments=False, embed_readiness=False,\n                embed_last_task_failure=False, embed_failures=False,\n                embed_task_stats=False):\n        \"\"\"Get a single app.\n\n        :param str app_id: application ID\n        :param bool embed_tasks: embed tasks in result\n        :param bool embed_counts: embed all task counts\n        :param bool embed_deployments: embed all deployment identifier\n        :param bool embed_readiness: embed all readiness check results\n        :param bool embed_last_task_failure: embeds the last task failure\n        :param bool embed_failures: shorthand for embed_last_task_failure\n        :param bool embed_task_stats: embed task stats in result\n\n        :returns: application\n        :rtype: :class:`marathon.models.app.MarathonApp`\n        \"\"\"\n        params = {}\n        embed_params = {\n            'app.tasks': embed_tasks,\n            'app.counts': embed_counts,\n            'app.deployments': embed_deployments,\n            'app.readiness': embed_readiness,\n            'app.lastTaskFailure': embed_last_task_failure,\n            'app.failures': embed_failures,\n            'app.taskStats': embed_task_stats\n        }\n        filtered_embed_params = [k for (k, v) in embed_params.items() if v]\n        if filtered_embed_params:\n            params['embed'] = filtered_embed_params\n\n        response = self._do_request(\n            'GET', '/v2/apps/{app_id}'.format(app_id=app_id), params=params)\n        return self._parse_response(response, MarathonApp, resource_name='app')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate an app. Applies writable settings in `app` to `app_id` Note: this method can not be used to rename apps. :param str app_id: target application ID :param app: application settings :type app: :class:`marathon.models.app.MarathonApp` :param bool force: apply even if a deployment is in progress :param bool minimal: ignore nulls and empty collections :returns: a dict containing the deployment id and version :rtype: dict", "response": "def update_app(self, app_id, app, force=False, minimal=True):\n        \"\"\"Update an app.\n\n        Applies writable settings in `app` to `app_id`\n        Note: this method can not be used to rename apps.\n\n        :param str app_id: target application ID\n        :param app: application settings\n        :type app: :class:`marathon.models.app.MarathonApp`\n        :param bool force: apply even if a deployment is in progress\n        :param bool minimal: ignore nulls and empty collections\n\n        :returns: a dict containing the deployment id and version\n        :rtype: dict\n        \"\"\"\n        # Changes won't take if version is set - blank it for convenience\n        app.version = None\n\n        params = {'force': force}\n        data = app.to_json(minimal=minimal)\n\n        response = self._do_request(\n            'PUT', '/v2/apps/{app_id}'.format(app_id=app_id), params=params, data=data)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates multiple apps. Applies writable settings in elements of apps either by upgrading existing ones or creating new ones :param apps: sequence of application settings :param bool force: apply even if a deployment is in progress :param bool minimal: ignore nulls and empty collections :returns: a dict containing the deployment id and version :rtype: dict", "response": "def update_apps(self, apps, force=False, minimal=True):\n        \"\"\"Update multiple apps.\n\n        Applies writable settings in elements of apps either by upgrading existing ones or creating new ones\n\n        :param apps: sequence of application settings\n        :param bool force: apply even if a deployment is in progress\n        :param bool minimal: ignore nulls and empty collections\n\n        :returns: a dict containing the deployment id and version\n        :rtype: dict\n        \"\"\"\n        json_repr_apps = []\n        for app in apps:\n            # Changes won't take if version is set - blank it for convenience\n            app.version = None\n            json_repr_apps.append(app.json_repr(minimal=minimal))\n\n        params = {'force': force}\n        encoder = MarathonMinimalJsonEncoder if minimal else MarathonJsonEncoder\n        data = json.dumps(json_repr_apps, cls=encoder, sort_keys=True)\n\n        response = self._do_request(\n            'PUT', '/v2/apps', params=params, data=data)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rollback_app(self, app_id, version, force=False):\n        params = {'force': force}\n        data = json.dumps({'version': version})\n        response = self._do_request(\n            'PUT', '/v2/apps/{app_id}'.format(app_id=app_id), params=params, data=data)\n        return response.json()", "response": "Roll an app back to a previous version."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_app(self, app_id, force=False):\n        params = {'force': force}\n        response = self._do_request(\n            'DELETE', '/v2/apps/{app_id}'.format(app_id=app_id), params=params)\n        return response.json()", "response": "Stop and destroy an application."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scale_app(self, app_id, instances=None, delta=None, force=False):\n        if instances is None and delta is None:\n            marathon.log.error('instances or delta must be passed')\n            return\n\n        try:\n            app = self.get_app(app_id)\n        except NotFoundError:\n            marathon.log.error('App \"{app}\" not found'.format(app=app_id))\n            return\n\n        desired = instances if instances is not None else (\n            app.instances + delta)\n        return self.update_app(app.id, MarathonApp(instances=desired), force=force)", "response": "Scale an app to a target number of instances or by some delta."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating and start a group.", "response": "def create_group(self, group):\n        \"\"\"Create and start a group.\n\n        :param :class:`marathon.models.group.MarathonGroup` group: the group to create\n\n        :returns: success\n        :rtype: dict containing the version ID\n        \"\"\"\n        data = group.to_json()\n        response = self._do_request('POST', '/v2/groups', data=data)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all groups. :param kwargs: arbitrary search filters :returns: list of groups :rtype: list[:class:`marathon.models.group.MarathonGroup`]", "response": "def list_groups(self, **kwargs):\n        \"\"\"List all groups.\n\n        :param kwargs: arbitrary search filters\n\n        :returns: list of groups\n        :rtype: list[:class:`marathon.models.group.MarathonGroup`]\n        \"\"\"\n        response = self._do_request('GET', '/v2/groups')\n        groups = self._parse_response(\n            response, MarathonGroup, is_list=True, resource_name='groups')\n        for k, v in kwargs.items():\n            groups = [o for o in groups if getattr(o, k) == v]\n        return groups"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a single group.", "response": "def get_group(self, group_id):\n        \"\"\"Get a single group.\n\n        :param str group_id: group ID\n\n        :returns: group\n        :rtype: :class:`marathon.models.group.MarathonGroup`\n        \"\"\"\n        response = self._do_request(\n            'GET', '/v2/groups/{group_id}'.format(group_id=group_id))\n        return self._parse_response(response, MarathonGroup)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a group s internal cache entries.", "response": "def update_group(self, group_id, group, force=False, minimal=True):\n        \"\"\"Update a group.\n\n        Applies writable settings in `group` to `group_id`\n        Note: this method can not be used to rename groups.\n\n        :param str group_id: target group ID\n        :param group: group settings\n        :type group: :class:`marathon.models.group.MarathonGroup`\n        :param bool force: apply even if a deployment is in progress\n        :param bool minimal: ignore nulls and empty collections\n\n        :returns: a dict containing the deployment id and version\n        :rtype: dict\n        \"\"\"\n        # Changes won't take if version is set - blank it for convenience\n        group.version = None\n\n        params = {'force': force}\n        data = group.to_json(minimal=minimal)\n\n        response = self._do_request(\n            'PUT', '/v2/groups/{group_id}'.format(group_id=group_id), data=data, params=params)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrolls a group back to a previous version.", "response": "def rollback_group(self, group_id, version, force=False):\n        \"\"\"Roll a group back to a previous version.\n\n        :param str group_id: group ID\n        :param str version: group version\n        :param bool force: apply even if a deployment is in progress\n\n        :returns: a dict containing the deployment id and version\n        :rtype: dict\n        \"\"\"\n        params = {'force': force}\n        response = self._do_request(\n            'PUT',\n            '/v2/groups/{group_id}/versions/{version}'.format(\n                group_id=group_id, version=version),\n            params=params)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstops and destroy a group.", "response": "def delete_group(self, group_id, force=False):\n        \"\"\"Stop and destroy a group.\n\n        :param str group_id: group ID\n        :param bool force: apply even if a deployment is in progress\n\n        :returns: a dict containing the deleted version\n        :rtype: dict\n        \"\"\"\n        params = {'force': force}\n        response = self._do_request(\n            'DELETE', '/v2/groups/{group_id}'.format(group_id=group_id), params=params)\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scale_group(self, group_id, scale_by):\n        data = {'scaleBy': scale_by}\n        response = self._do_request(\n            'PUT', '/v2/groups/{group_id}'.format(group_id=group_id), data=json.dumps(data))\n        return response.json()", "response": "Scale a group by a factor."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_tasks(self, app_id=None, **kwargs):\n        response = self._do_request(\n            'GET', '/v2/apps/%s/tasks' % app_id if app_id else '/v2/tasks')\n        tasks = self._parse_response(\n            response, MarathonTask, is_list=True, resource_name='tasks')\n        [setattr(t, 'app_id', app_id)\n         for t in tasks if app_id and t.app_id is None]\n        for k, v in kwargs.items():\n            tasks = [o for o in tasks if getattr(o, k) == v]\n\n        return tasks", "response": "List running tasks optionally filtered by app_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kill_given_tasks(self, task_ids, scale=False, force=None):\n        params = {'scale': scale}\n        if force is not None:\n            params['force'] = force\n        data = json.dumps({\"ids\": task_ids})\n        response = self._do_request(\n            'POST', '/v2/tasks/delete', params=params, data=data)\n        return response == 200", "response": "Kill a list of given tasks."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kill_tasks(self, app_id, scale=False, wipe=False,\n                   host=None, batch_size=0, batch_delay=0):\n        \"\"\"Kill all tasks belonging to app.\n\n        :param str app_id: application ID\n        :param bool scale: if true, scale down the app by the number of tasks killed\n        :param str host: if provided, only terminate tasks on this Mesos slave\n        :param int batch_size: if non-zero, terminate tasks in groups of this size\n        :param int batch_delay: time (in seconds) to wait in between batched kills. If zero, automatically determine\n\n        :returns: list of killed tasks\n        :rtype: list[:class:`marathon.models.task.MarathonTask`]\n        \"\"\"\n        def batch(iterable, size):\n            sourceiter = iter(iterable)\n            while True:\n                batchiter = itertools.islice(sourceiter, size)\n                yield itertools.chain([next(batchiter)], batchiter)\n\n        if batch_size == 0:\n            # Terminate all at once\n            params = {'scale': scale, 'wipe': wipe}\n            if host:\n                params['host'] = host\n            response = self._do_request(\n                'DELETE', '/v2/apps/{app_id}/tasks'.format(app_id=app_id), params)\n            # Marathon is inconsistent about what type of object it returns on the multi\n            # task deletion endpoint, depending on the version of Marathon. See:\n            # https://github.com/mesosphere/marathon/blob/06a6f763a75fb6d652b4f1660685ae234bd15387/src/main/scala/mesosphere/marathon/api/v2/AppTasksResource.scala#L88-L95\n            if \"tasks\" in response.json():\n                return self._parse_response(response, MarathonTask, is_list=True, resource_name='tasks')\n            else:\n                return response.json()\n        else:\n            # Terminate in batches\n            tasks = self.list_tasks(\n                app_id, host=host) if host else self.list_tasks(app_id)\n            for tbatch in batch(tasks, batch_size):\n                killed_tasks = [self.kill_task(app_id, t.id, scale=scale, wipe=wipe)\n                                for t in tbatch]\n\n                # Pause until the tasks have been killed to avoid race\n                # conditions\n                killed_task_ids = set(t.id for t in killed_tasks)\n                running_task_ids = killed_task_ids\n                while killed_task_ids.intersection(running_task_ids):\n                    time.sleep(1)\n                    running_task_ids = set(\n                        t.id for t in self.get_app(app_id).tasks)\n\n                if batch_delay == 0:\n                    # Pause until the replacement tasks are healthy\n                    desired_instances = self.get_app(app_id).instances\n                    running_instances = 0\n                    while running_instances < desired_instances:\n                        time.sleep(1)\n                        running_instances = sum(\n                            t.started_at is None for t in self.get_app(app_id).tasks)\n                else:\n                    time.sleep(batch_delay)\n\n            return tasks", "response": "Kill all tasks belonging to an app."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kill_task(self, app_id, task_id, scale=False, wipe=False):\n        params = {'scale': scale, 'wipe': wipe}\n        response = self._do_request('DELETE', '/v2/apps/{app_id}/tasks/{task_id}'\n                                    .format(app_id=app_id, task_id=task_id), params)\n        # Marathon is inconsistent about what type of object it returns on the multi\n        # task deletion endpoint, depending on the version of Marathon. See:\n        # https://github.com/mesosphere/marathon/blob/06a6f763a75fb6d652b4f1660685ae234bd15387/src/main/scala/mesosphere/marathon/api/v2/AppTasksResource.scala#L88-L95\n        if \"task\" in response.json():\n            return self._parse_response(response, MarathonTask, is_list=False, resource_name='task')\n        else:\n            return response.json()", "response": "Kill a task.\n\n        :param str app_id: application ID\n        :param str task_id: the task to kill\n        :param bool scale: if true, scale down the app by one if the task exists\n\n        :returns: the killed task\n        :rtype: :class:`marathon.models.task.MarathonTask`"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_versions(self, app_id):\n        response = self._do_request(\n            'GET', '/v2/apps/{app_id}/versions'.format(app_id=app_id))\n        return [version for version in response.json()['versions']]", "response": "List the versions of an app."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_version(self, app_id, version):\n        response = self._do_request('GET', '/v2/apps/{app_id}/versions/{version}'\n                                    .format(app_id=app_id, version=version))\n        return MarathonApp.from_json(response.json())", "response": "Get the configuration of an app at a specific version."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_event_subscription(self, url):\n        params = {'callbackUrl': url}\n        response = self._do_request('POST', '/v2/eventSubscriptions', params)\n        return response.json()", "response": "Register a callback URL as an event subscriber."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all running deployments.", "response": "def list_deployments(self):\n        \"\"\"List all running deployments.\n\n        :returns: list of deployments\n        :rtype: list[:class:`marathon.models.deployment.MarathonDeployment`]\n        \"\"\"\n        response = self._do_request('GET', '/v2/deployments')\n        return self._parse_response(response, MarathonDeployment, is_list=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_queue(self, embed_last_unused_offers=False):\n        if embed_last_unused_offers:\n            params = {'embed': 'lastUnusedOffers'}\n        else:\n            params = {}\n        response = self._do_request('GET', '/v2/queue', params=params)\n        return self._parse_response(response, MarathonQueueItem, is_list=True, resource_name='queue')", "response": "List all the tasks queued up or waiting to be scheduled."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncancel a deployment. :param str deployment_id: deployment id :param bool force: if true, don't create a rollback deployment to restore the previous configuration :returns: a dict containing the deployment id and version (empty dict if force=True) :rtype: dict", "response": "def delete_deployment(self, deployment_id, force=False):\n        \"\"\"Cancel a deployment.\n\n        :param str deployment_id: deployment id\n        :param bool force: if true, don't create a rollback deployment to restore the previous configuration\n\n        :returns: a dict containing the deployment id and version (empty dict if force=True)\n        :rtype: dict\n        \"\"\"\n        if force:\n            params = {'force': True}\n            self._do_request('DELETE', '/v2/deployments/{deployment}'.format(\n                deployment=deployment_id), params=params)\n            # Successful DELETE with ?force=true returns empty text (and status\n            # code 202). Client code should poll until deployment is removed.\n            return {}\n        else:\n            response = self._do_request(\n                'DELETE', '/v2/deployments/{deployment}'.format(deployment=deployment_id))\n            return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef event_stream(self, raw=False, event_types=None):\n\n        ef = EventFactory()\n\n        params = {\n            'event_type': [\n                EventFactory.class_to_event[et] if isinstance(\n                    et, type) and issubclass(et, MarathonEvent) else et\n                for et in event_types or []\n            ]\n        }\n\n        for raw_message in self._do_sse_request('/v2/events', params=params):\n            try:\n                _data = raw_message.decode('utf8').split(':', 1)\n\n                if _data[0] == 'data':\n                    if raw:\n                        yield _data[1]\n                    else:\n                        event_data = json.loads(_data[1].strip())\n                        if 'eventType' not in event_data:\n                            raise MarathonError('Invalid event data received.')\n                        yield ef.process(event_data)\n            except ValueError:\n                raise MarathonError('Invalid event data received.')", "response": "Polls event bus using / v2 / events"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a path is a correct format that Marathon expects. Raises ValueError if not valid.", "response": "def assert_valid_path(path):\n    \"\"\"Checks if a path is a correct format that Marathon expects. Raises ValueError if not valid.\n\n    :param str path: The app id.\n\n    :rtype: str\n    \"\"\"\n    if path is None:\n        return\n    # As seen in:\n    # https://github.com/mesosphere/marathon/blob/0c11661ca2f259f8a903d114ef79023649a6f04b/src/main/scala/mesosphere/marathon/state/PathId.scala#L71\n    for id in filter(None, path.strip('/').split('/')):\n        if not ID_PATTERN.match(id):\n            raise ValueError(\n                'invalid path (allowed: lowercase letters, digits, hyphen, \"/\", \".\", \"..\"): %r' % path)\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assert_valid_id(id):\n    if id is None:\n        return\n    if not ID_PATTERN.match(id.strip('/')):\n        raise ValueError(\n            'invalid id (allowed: lowercase letters, digits, hyphen, \".\", \"..\"): %r' % id)\n    return id", "response": "Checks if an id is the correct format that Marathon expects. Raises ValueError if not valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a JSON - friendly representation of the object.", "response": "def json_repr(self, minimal=False):\n        \"\"\"Construct a JSON-friendly representation of the object.\n\n        :param bool minimal: Construct a minimal representation of the object (ignore nulls and empty collections)\n\n        :rtype: dict\n        \"\"\"\n        if minimal:\n            return {to_camel_case(k): v for k, v in vars(self).items() if (v or v is False or v == 0)}\n        else:\n            return {to_camel_case(k): v for k, v in vars(self).items()}"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs an object from a parsed response.", "response": "def from_json(cls, attributes):\n        \"\"\"Construct an object from a parsed response.\n\n        :param dict attributes: object attributes from parsed response\n        \"\"\"\n        return cls(**{to_snake_case(k): v for k, v in attributes.items()})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding an object as a JSON string.", "response": "def to_json(self, minimal=True):\n        \"\"\"Encode an object as a JSON string.\n\n        :param bool minimal: Construct a minimal representation of the object (ignore nulls and empty collections)\n\n        :rtype: str\n        \"\"\"\n        if minimal:\n            return json.dumps(self.json_repr(minimal=True), cls=MarathonMinimalJsonEncoder, sort_keys=True)\n        else:\n            return json.dumps(self.json_repr(), cls=MarathonJsonEncoder, sort_keys=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef json_repr(self, minimal=False):\n        if self.value:\n            return [self.field, self.operator, self.value]\n        else:\n            return [self.field, self.operator]", "response": "Construct a JSON - friendly representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a MarathonConstraint from a parsed response.", "response": "def from_json(cls, obj):\n        \"\"\"Construct a MarathonConstraint from a parsed response.\n\n        :param dict attributes: object attributes from parsed response\n\n        :rtype: :class:`MarathonConstraint`\n        \"\"\"\n        if len(obj) == 2:\n            (field, operator) = obj\n            return cls(field, operator)\n        if len(obj) > 2:\n            (field, operator, value) = obj\n            return cls(field, operator, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_string(cls, constraint):\n        obj = constraint.split(':')\n        marathon_constraint = cls.from_json(obj)\n\n        if marathon_constraint:\n            return marathon_constraint\n\n        raise ValueError(\"Invalid string format. \"\n                         \"Expected `field:operator:value`\")", "response": "Returns a MarathonResource object from a string representation of a MarathonConstraint."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_tasks(cls, tasks):\n\n        endpoints = [\n            [\n                MarathonEndpoint(task.app_id, task.service_ports[\n                                 port_index], task.host, task.id, port)\n                for port_index, port in enumerate(task.ports)\n            ]\n            for task in tasks\n        ]\n        # Flatten result\n        return [item for sublist in endpoints for item in sublist]", "response": "Construct a list of MarathonEndpoints from a list of tasks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_newlines(prefix, formatted_node, options):\n    replacement = u''.join([\n        options.NEWLINE,\n        u'\\n',\n        prefix])\n    return formatted_node.replace(u'\\n', replacement)", "response": "Convert newlines into U + 23EC characters followed by an actual newline and a tree prefix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a band with the specified tag.", "response": "def get_band(self, tag):\n        \"\"\"Gets a band.\n\n        Gets a band with specified tag. If no tag is specified, the request will fail.\n        If the tag is invalid, a brawlstars.InvalidTag will be raised.\n        If the data is missing, a ValueError will be raised.\n        If the connection times out, a brawlstars.Timeout will be raised.\n        If the data was unable to be received, a brawlstars.HTTPError will be raised along with the\n        HTTP status code.\n        On success, will return a Band.\n        \"\"\"\n\n        tag = tag.strip(\"#\")\n        tag = tag.upper()\n\n        try:\n            resp = requests.get(self._base_url + 'bands/' + tag, headers=self.headers, timeout=self.timeout)\n            if resp.status_code == 200:\n                data = resp.json()\n            elif 500 > resp.status_code > 400:\n                raise HTTPError(resp.status_code)\n            else:\n                raise Error()\n        except ValueError:\n            raise MissingData('data')\n        except Exception:\n            raise Timeout()\n\n        data = Box(data)\n        band = Band(data)\n        return band"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def get_player(self, tag):\n\n        tag = tag.strip(\"#\")\n        tag = tag.upper()\n\n        try:\n            async with self.session.get(self._base_url + 'players/' + tag, timeout=self.timeout,\n                                        headers=self.headers) as resp:\n                if resp.status == 200:\n                    data = await resp.json()\n                elif 500 > resp.status > 400:\n                    raise HTTPError(resp.status)\n                else:\n                    raise Error()\n        except asyncio.TimeoutError:\n            raise Timeout()\n        except ValueError:\n            raise MissingData('data')\n        except Exception:\n            raise InvalidArg('tag')\n\n        data = Box(data)\n        player = Player(data)\n        return player", "response": "Gets a player with specified tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_band(self, tag):\n\n        tag = tag.strip(\"#\")\n        tag = tag.upper()\n\n        try:\n            async with self.session.get(self._base_url + 'bands/' + tag, timeout=self.timeout,\n                                        headers=self.headers) as resp:\n                if resp.status == 200:\n                    data = await resp.json()\n                elif 500 > resp.status > 400:\n                    raise HTTPError(resp.status)\n                else:\n                    raise Error()\n        except asyncio.TimeoutError:\n            raise Timeout()\n        except ValueError:\n            raise MissingData('data')\n        except Exception:\n            raise InvalidArg('tag')\n\n        data = Box(data)\n        band = Band(data)\n        return band", "response": "Gets a band with the specified tag."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lazy_module(modname, error_strings=None, lazy_mod_class=LazyModule,\n                  level='leaf'):\n    \"\"\"Function allowing lazy importing of a module into the namespace.\n\n    A lazy module object is created, registered in `sys.modules`, and\n    returned. This is a hollow module; actual loading, and `ImportErrors` if\n    not found, are delayed until an attempt is made to access attributes of the\n    lazy module.\n\n    A handy application is to use :func:`lazy_module` early in your own code\n    (say, in `__init__.py`) to register all modulenames you want to be lazy.\n    Because of registration in `sys.modules` later invocations of\n    `import modulename` will also return the lazy object. This means that after\n    initial registration the rest of your code can use regular pyhon import\n    statements and retain the lazyness of the modules.\n\n    Parameters\n    ----------\n    modname : str\n         The module to import.\n    error_strings : dict, optional\n         A dictionary of strings to use when module-loading fails. Key 'msg'\n         sets the message to use (defaults to :attr:`lazy_import._MSG`). The\n         message is formatted using the remaining dictionary keys. The default\n         message informs the user of which module is missing (key 'module'),\n         what code loaded the module as lazy (key 'caller'), and which package\n         should be installed to solve the dependency (key 'install_name').\n         None of the keys is mandatory and all are given smart names by default.\n    lazy_mod_class: type, optional\n         Which class to use when instantiating the lazy module, to allow\n         deep customization. The default is :class:`LazyModule` and custom\n         alternatives **must** be a subclass thereof.\n    level : str, optional\n         Which submodule reference to return. Either a reference to the 'leaf'\n         module (the default) or to the 'base' module. This is useful if you'll\n         be using the module functionality in the same place you're calling\n         :func:`lazy_module` from, since then you don't need to run `import`\n         again. Setting *level* does not affect which names/modules get\n         registered in `sys.modules`.\n         For *level* set to 'base' and *modulename* 'aaa.bbb.ccc'::\n\n            aaa = lazy_import.lazy_module(\"aaa.bbb.ccc\", level='base')\n            # 'aaa' becomes defined in the current namespace, with\n            #  (sub)attributes 'aaa.bbb' and 'aaa.bbb.ccc'.\n            # It's the lazy equivalent to:\n            import aaa.bbb.ccc\n\n        For *level* set to 'leaf'::\n\n            ccc = lazy_import.lazy_module(\"aaa.bbb.ccc\", level='leaf')\n            # Only 'ccc' becomes set in the current namespace.\n            # Lazy equivalent to:\n            from aaa.bbb import ccc\n\n    Returns\n    -------\n    module\n        The module specified by *modname*, or its base, depending on *level*.\n        The module isn't immediately imported. Instead, an instance of\n        *lazy_mod_class* is returned. Upon access to any of its attributes, the\n        module is finally loaded.\n\n    Examples\n    --------\n    >>> import lazy_import, sys\n    >>> np = lazy_import.lazy_module(\"numpy\")\n    >>> np\n    Lazily-loaded module numpy\n    >>> np is sys.modules['numpy']\n    True\n    >>> np.pi # This causes the full loading of the module ...\n    3.141592653589793\n    >>> np # ... and the module is changed in place. \n    <module 'numpy' from '/usr/local/lib/python/site-packages/numpy/__init__.py'>\n\n    >>> import lazy_import, sys\n    >>> # The following succeeds even when asking for a module that's not available\n    >>> missing = lazy_import.lazy_module(\"missing_module\")\n    >>> missing\n    Lazily-loaded module missing_module\n    >>> missing is sys.modules['missing_module']\n    True\n    >>> missing.some_attr # This causes the full loading of the module, which now fails.\n    ImportError: __main__ attempted to use a functionality that requires module missing_module, but it couldn't be loaded. Please install missing_module and retry.\n\n    See Also\n    --------\n    :func:`lazy_callable`\n    :class:`LazyModule`\n\n    \"\"\"\n    if error_strings is None:\n        error_strings = {}\n    _set_default_errornames(modname, error_strings)\n\n    mod = _lazy_module(modname, error_strings, lazy_mod_class)\n    if level == 'base':\n        return sys.modules[module_basename(modname)]\n    elif level == 'leaf':\n        return mod\n    else:\n        raise ValueError(\"Parameter 'level' must be one of ('base', 'leaf')\")", "response": "Function allowing lazy importing of a module into the namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms lazy importing of one or more callables. :func:`lazy_callable` creates functions that are thin wrappers that pass any and all arguments straight to the target module's callables. These can be functions or classes. The full loading of that module is only actually triggered when the returned lazy function itself is called. This lazy import of the target module uses the same mechanism as :func:`lazy_module`. If, however, the target module has already been fully imported prior to invocation of :func:`lazy_callable`, then the target callables themselves are returned and no lazy imports are made. :func:`lazy_function` and :func:`lazy_function` are aliases of :func:`lazy_callable`. Parameters ---------- modname : str The base module from where to import the callable(s) in *names*, or a full 'module_name.callable_name' string. names : str (optional) The callable name(s) to import from the module specified by *modname*. If left empty, *modname* is assumed to also include the callable name to import. error_strings : dict, optional A dictionary of strings to use when reporting loading errors (either a missing module, or a missing callable name in the loaded module). *error_string* follows the same usage as described under :func:`lazy_module`, with the exceptions that 1) a further key, 'msg_callable', can be supplied to be used as the error when a module is successfully loaded but the target callable can't be found therein (defaulting to :attr:`lazy_import._MSG_CALLABLE`); 2) a key 'callable' is always added with the callable name being loaded. lazy_mod_class : type, optional See definition under :func:`lazy_module`. lazy_call_class : type, optional Analogously to *lazy_mod_class*, allows setting a custom class to handle lazy callables, other than the default :class:`LazyCallable`. Returns ------- wrapper function or tuple of wrapper functions If *names* is passed, returns a tuple of wrapper functions, one for each element in *names*. If only *modname* is passed it is assumed to be a full 'module_name.callable_name' string, in which case the wrapper for the imported callable is returned directly, and not in a tuple. Notes ----- Unlike :func:`lazy_module`, which returns a lazy module that eventually mutates into the fully-functional version, :func:`lazy_callable` only returns thin wrappers that never change. This means that the returned wrapper object never truly becomes the one under the module's namespace, even after successful loading of the module in *modname*. This is fine for most practical use cases, but may break code that relies on the usage of the returned objects oter than calling them. One such example is the lazy import of a class: it's fine to use the returned wrapper to instantiate an object, but it can't be used, for instance, to subclass from. Examples -------- >>> import lazy_import, sys >>> fn = lazy_import.lazy_callable(\"numpy.arange\") >>> sys.modules['numpy'] Lazily-loaded module numpy >>> fn(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> sys.modules['numpy'] <module 'numpy' from '/usr/local/lib/python3.5/site-packages/numpy/__init__.py'> >>> import lazy_import, sys >>> cl = lazy_import.lazy_callable(\"numpy.ndarray\") # a class >>> obj = cl([1, 2]) # This works OK (and also triggers the loading of numpy) >>> class MySubclass(cl): # This fails because cls is just a wrapper, >>> pass # not an actual class. See Also -------- :func:`lazy_module` :class:`LazyCallable` :class:`LazyModule`", "response": "def lazy_callable(modname, *names, **kwargs):\n    \"\"\"Performs lazy importing of one or more callables.\n\n    :func:`lazy_callable` creates functions that are thin wrappers that pass\n    any and all arguments straight to the target module's callables. These can\n    be functions or classes. The full loading of that module is only actually\n    triggered when the returned lazy function itself is called. This lazy\n    import of the target module uses the same mechanism as\n    :func:`lazy_module`.\n    \n    If, however, the target module has already been fully imported prior\n    to invocation of :func:`lazy_callable`, then the target callables\n    themselves are returned and no lazy imports are made.\n\n    :func:`lazy_function` and :func:`lazy_function` are aliases of\n    :func:`lazy_callable`.\n\n    Parameters\n    ----------\n    modname : str\n         The base module from where to import the callable(s) in *names*,\n         or a full 'module_name.callable_name' string.\n    names : str (optional)\n         The callable name(s) to import from the module specified by *modname*.\n         If left empty, *modname* is assumed to also include the callable name\n         to import.\n    error_strings : dict, optional\n         A dictionary of strings to use when reporting loading errors (either a\n         missing module, or a missing callable name in the loaded module).\n         *error_string* follows the same usage as described under\n         :func:`lazy_module`, with the exceptions that 1) a further key,\n         'msg_callable', can be supplied to be used as the error when a module\n         is successfully loaded but the target callable can't be found therein\n         (defaulting to :attr:`lazy_import._MSG_CALLABLE`); 2) a key 'callable'\n         is always added with the callable name being loaded.\n    lazy_mod_class : type, optional\n         See definition under :func:`lazy_module`.\n    lazy_call_class : type, optional\n         Analogously to *lazy_mod_class*, allows setting a custom class to\n         handle lazy callables, other than the default :class:`LazyCallable`.\n\n    Returns\n    -------\n    wrapper function or tuple of wrapper functions\n        If *names* is passed, returns a tuple of wrapper functions, one for\n        each element in *names*.\n        If only *modname* is passed it is assumed to be a full\n        'module_name.callable_name' string, in which case the wrapper for the\n        imported callable is returned directly, and not in a tuple.\n        \n    Notes\n    -----\n    Unlike :func:`lazy_module`, which returns a lazy module that eventually\n    mutates into the fully-functional version, :func:`lazy_callable` only\n    returns thin wrappers that never change. This means that the returned\n    wrapper object never truly becomes the one under the module's namespace,\n    even after successful loading of the module in *modname*. This is fine for\n    most practical use cases, but may break code that relies on the usage of\n    the returned objects oter than calling them. One such example is the lazy\n    import of a class: it's fine to use the returned wrapper to instantiate an\n    object, but it can't be used, for instance, to subclass from.\n\n    Examples\n    --------\n    >>> import lazy_import, sys\n    >>> fn = lazy_import.lazy_callable(\"numpy.arange\")\n    >>> sys.modules['numpy']\n    Lazily-loaded module numpy\n    >>> fn(10)\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> sys.modules['numpy']\n    <module 'numpy' from '/usr/local/lib/python3.5/site-packages/numpy/__init__.py'>\n\n    >>> import lazy_import, sys\n    >>> cl = lazy_import.lazy_callable(\"numpy.ndarray\") # a class\n    >>> obj = cl([1, 2]) # This works OK (and also triggers the loading of numpy)\n    >>> class MySubclass(cl): # This fails because cls is just a wrapper,\n    >>>     pass              #  not an actual class.\n\n    See Also\n    --------\n    :func:`lazy_module`\n    :class:`LazyCallable`\n    :class:`LazyModule`\n\n    \"\"\"\n    if not names:\n        modname, _, name = modname.rpartition(\".\")\n    lazy_mod_class = _setdef(kwargs, 'lazy_mod_class', LazyModule)\n    lazy_call_class = _setdef(kwargs, 'lazy_call_class', LazyCallable)\n    error_strings = _setdef(kwargs, 'error_strings', {})\n    _set_default_errornames(modname, error_strings, call=True)\n\n    if not names:\n        # We allow passing a single string as 'modname.callable_name',\n        # in which case the wrapper is returned directly and not as a list.\n        return _lazy_callable(modname, name, error_strings.copy(),\n                                lazy_mod_class, lazy_call_class)\n    return tuple(_lazy_callable(modname, cname, error_strings.copy(),\n                        lazy_mod_class, lazy_call_class) for cname in names)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_module(module):\n    modclass = type(module)\n    # We only take care of our own LazyModule instances\n    if not issubclass(modclass, LazyModule):\n        raise TypeError(\"Passed module is not a LazyModule instance.\")\n    with _ImportLockContext():\n        parent, _, modname = module.__name__.rpartition('.')\n        logger.debug(\"loading module {}\".format(modname))\n        # We first identify whether this is a loadable LazyModule, then we\n        # strip as much of lazy_import behavior as possible (keeping it cached,\n        # in case loading fails and we need to reset the lazy state).\n        if not hasattr(modclass, '_lazy_import_error_msgs'):\n            # Alreay loaded (no _lazy_import_error_msgs attr). Not reloading.\n            return\n        # First, ensure the parent is loaded (using recursion; *very* unlikely\n        # we'll ever hit a stack limit in this case).\n        modclass._LOADING = True\n        try:\n            if parent:\n                logger.debug(\"first loading parent module {}\".format(parent))\n                setattr(sys.modules[parent], modname, module)\n            if not hasattr(modclass, '_LOADING'):\n                logger.debug(\"Module {} already loaded by the parent\"\n                             .format(modname))\n                # We've been loaded by the parent. Let's bail.\n                return\n            cached_data = _clean_lazymodule(module)\n            try:\n                # Get Python to do the real import!\n                reload_module(module)           \n            except:\n                # Loading failed. We reset our lazy state.\n                logger.debug(\"Failed to load module {}. Resetting...\"\n                             .format(modname))\n                _reset_lazymodule(module, cached_data)\n                raise\n            else:\n                # Successful load\n                logger.debug(\"Successfully loaded module {}\".format(modname))\n                delattr(modclass, '_LOADING')\n                _reset_lazy_submod_refs(module)\n\n        except (AttributeError, ImportError) as err:\n            logger.debug(\"Failed to load {}.\\n{}: {}\"\n                         .format(modname, err.__class__.__name__, err))\n            logger.lazy_trace()\n            # Under Python 3 reloading our dummy LazyModule instances causes an\n            # AttributeError if the module can't be found. Would be preferrable\n            # if we could always rely on an ImportError. As it is we vet the\n            # AttributeError as thoroughly as possible.\n            if ((six.PY3 and isinstance(err, AttributeError)) and not\n                err.args[0] == \"'NoneType' object has no attribute 'name'\"):\n                # Not the AttributeError we were looking for.\n                raise\n            msg = modclass._lazy_import_error_msgs['msg']\n            raise_from(ImportError(\n                msg.format(**modclass._lazy_import_error_strings)), None)", "response": "Load a module and its parents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _setdef(argdict, name, defaultvalue):\n    if not name in argdict or argdict[name] is None:\n        argdict[name] = defaultvalue\n    return argdict[name]", "response": "Like dict. setdefault but sets the default value also"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _clean_lazymodule(module):\n    modclass = type(module)\n    _clean_lazy_submod_refs(module)\n\n    modclass.__getattribute__ = ModuleType.__getattribute__\n    modclass.__setattr__ = ModuleType.__setattr__\n    cls_attrs = {}\n    for cls_attr in _CLS_ATTRS:\n        try:\n            cls_attrs[cls_attr] = getattr(modclass, cls_attr)\n            delattr(modclass, cls_attr)\n        except AttributeError:\n            pass\n    return cls_attrs", "response": "Removes all lazy behavior from a module s class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _reset_lazymodule(module, cls_attrs):\n    modclass = type(module)\n    del modclass.__getattribute__\n    del modclass.__setattr__\n    try:\n        del modclass._LOADING\n    except AttributeError:\n        pass\n    for cls_attr in _CLS_ATTRS:\n        try:\n            setattr(modclass, cls_attr, cls_attrs[cls_attr])\n        except KeyError:\n            pass\n    _reset_lazy_submod_refs(module)", "response": "Resets a module s lazy state from cached data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timestamp_from_datetime(dt):\n    try:\n        utc_dt = dt.astimezone(pytz.utc)\n    except ValueError:\n        utc_dt = dt.replace(tzinfo=pytz.utc)\n    return timegm(utc_dt.timetuple())", "response": "Compute timestamp from a datetime object that could be timezone aware\n    or unaware."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a string or memoryview to bytes.", "response": "def force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):\n    \"\"\"\n    Similar to smart_bytes, except that lazy instances are resolved to\n    strings, rather than kept as lazy objects.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"\n    if isinstance(s, memoryview):\n        s = bytes(s)\n    if isinstance(s, bytes):\n        if encoding == 'utf-8':\n            return s\n        else:\n            return s.decode('utf-8', errors).encode(encoding, errors)\n    if strings_only and (s is None or isinstance(s, int)):\n        return s\n    if not isinstance(s, six.string_types):\n        try:\n            if six.PY3:\n                return six.text_type(s).encode(encoding)\n            else:\n                return bytes(s)\n        except UnicodeEncodeError:\n            if isinstance(s, Exception):\n                # An Exception subclass containing non-ASCII data that doesn't\n                # know how to print itself properly. We shouldn't raise a\n                # further exception.\n                return b' '.join([force_bytes(arg, encoding, strings_only,\n                                              errors) for arg in s])\n            return six.text_type(s).encode(encoding, errors)\n    else:\n        return s.encode(encoding, errors)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef memoize(func, cache, num_args):\n\n    @wraps(func)\n    def wrapper(*args):\n        mem_args = args[:num_args]\n        if mem_args in cache:\n            return cache[mem_args]\n        result = func(*args)\n        cache[mem_args] = result\n        return result\n\n    return wrapper", "response": "A decorator that caches the result of a function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reraise_as(new_exception_or_type):\n    __traceback_hide__ = True  # NOQA\n\n    e_type, e_value, e_traceback = sys.exc_info()\n\n    if inspect.isclass(new_exception_or_type):\n        new_type = new_exception_or_type\n        new_exception = new_exception_or_type()\n    else:\n        new_type = type(new_exception_or_type)\n        new_exception = new_exception_or_type\n\n    new_exception.__cause__ = e_value\n\n    try:\n        six.reraise(new_type, new_exception, e_traceback)\n    finally:\n        del e_traceback", "response": "Re - raises an exception or type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hide_auth(msg):\n    for pattern, repl in RE_HIDE_AUTH:\n        msg = pattern.sub(repl, msg)\n\n    return msg", "response": "Remove sensitive information from msg."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(self):\n        self.debug('Initializing %r', self)\n        proto = self.server.split('://')[0]\n\n        if proto == 'https':\n            if hasattr(ssl, 'create_default_context'):\n                context = ssl.create_default_context()\n\n                if self.ssl_verify:\n                    context.check_hostname = True\n                    context.verify_mode = ssl.CERT_REQUIRED\n                else:\n                    context.check_hostname = False\n                    context.verify_mode = ssl.CERT_NONE\n\n                self._http_handler = urllib2.HTTPSHandler(debuglevel=0, context=context)\n            else:\n                self._http_handler = urllib2.HTTPSHandler(debuglevel=0)\n        elif proto == 'http':\n            self._http_handler = urllib2.HTTPHandler(debuglevel=0)\n        else:\n            raise ValueError('Invalid protocol %s' % proto)\n\n        self._api_url = self.server + '/api_jsonrpc.php'\n        self._http_headers = {\n            'Content-Type': 'application/json-rpc',\n            'User-Agent': 'python/zabbix_api',\n        }\n\n        if self.httpuser:\n            self.debug('HTTP authentication enabled')\n            auth = self.httpuser + ':' + self.httppasswd\n            self._http_headers['Authorization'] = 'Basic ' + b64encode(auth.encode('utf-8')).decode('ascii')", "response": "Prepare the HTTP handler URL and HTTP headers for all subsequent requests"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timestamp_to_datetime(cls, dt, dt_format=DATETIME_FORMAT):\n        return cls.convert_datetime(cls.get_datetime(dt), dt_format=dt_format)", "response": "Convert unix timestamp to human readable date / time string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_age(dt):\n        delta = datetime.now() - dt\n        days = delta.days\n        hours, rem = divmod(delta.seconds, 3600)\n        minutes, seconds = divmod(rem, 60)\n\n        if days:\n            return '%dd %dh %dm' % (days, hours, minutes)\n        else:\n            return '%dh %dm %ds' % (hours, minutes, seconds)", "response": "Calculate delta between current time and datetime and return a human readable form of the delta object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning JSON object expected by the Zabbix API", "response": "def json_obj(self, method, params=None, auth=True):\n        \"\"\"Return JSON object expected by the Zabbix API\"\"\"\n        if params is None:\n            params = {}\n\n        obj = {\n            'jsonrpc': '2.0',\n            'method': method,\n            'params': params,\n            'auth': self.__auth if auth else None,\n            'id': self.id,\n        }\n\n        return json.dumps(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms one HTTP request to Zabbix API and return the result.", "response": "def do_request(self, json_obj):\n        \"\"\"Perform one HTTP request to Zabbix API\"\"\"\n        self.debug('Request: url=\"%s\" headers=%s', self._api_url, self._http_headers)\n        self.debug('Request: body=%s', json_obj)\n        self.r_query.append(json_obj)\n\n        request = urllib2.Request(url=self._api_url, data=json_obj.encode('utf-8'), headers=self._http_headers)\n        opener = urllib2.build_opener(self._http_handler)\n        urllib2.install_opener(opener)\n\n        try:\n            response = opener.open(request, timeout=self.timeout)\n        except Exception as e:\n            raise ZabbixAPIException('HTTP connection problem: %s' % e)\n\n        self.debug('Response: code=%s', response.code)\n\n        # NOTE: Getting a 412 response code means the headers are not in the list of allowed headers.\n        if response.code != 200:\n            raise ZabbixAPIException('HTTP error %s: %s' % (response.status, response.reason))\n\n        reads = response.read()\n\n        if len(reads) == 0:\n            raise ZabbixAPIException('Received zero answer')\n\n        try:\n            jobj = json.loads(reads.decode('utf-8'))\n        except ValueError as e:\n            self.log(ERROR, 'Unable to decode. returned string: %s', reads)\n            raise ZabbixAPIException('Unable to decode response: %s' % e)\n\n        self.debug('Response: body=%s', jobj)\n        self.id += 1\n\n        if 'error' in jobj:  # zabbix API error\n            error = jobj['error']\n\n            if isinstance(error, dict):\n                raise ZabbixAPIError(**error)\n\n        try:\n            return jobj['result']\n        except KeyError:\n            raise ZabbixAPIException('Missing result in API response')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming a user. login API request", "response": "def login(self, user=None, password=None, save=True):\n        \"\"\"Perform a user.login API request\"\"\"\n        if user and password:\n            if save:\n                self.__username = user\n                self.__password = password\n        elif self.__username and self.__password:\n            user = self.__username\n            password = self.__password\n        else:\n            raise ZabbixAPIException('No authentication information available.')\n\n        self.last_login = time()\n        # Don't print the raw password\n        hashed_pw_string = 'md5(%s)' % md5(password.encode('utf-8')).hexdigest()\n        self.debug('Trying to login with %r:%r', user, hashed_pw_string)\n        obj = self.json_obj('user.login', params={'user': user, 'password': password}, auth=False)\n        self.__auth = self.do_request(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform a re - login", "response": "def relogin(self):\n        \"\"\"Perform a re-login\"\"\"\n        try:\n            self.__auth = None  # reset auth before relogin\n            self.login()\n        except ZabbixAPIException as e:\n            self.log(ERROR, 'Zabbix API relogin error (%s)', e)\n            self.__auth = None  # logged_in() will always return False\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms a re - login if not signed in or raise an exception", "response": "def check_auth(self):\n        \"\"\"Perform a re-login if not signed in or raise an exception\"\"\"\n        if not self.logged_in:\n            if self.relogin_interval and self.last_login and (time() - self.last_login) > self.relogin_interval:\n                self.log(WARNING, 'Zabbix API not logged in. Performing Zabbix API relogin after %d seconds',\n                         self.relogin_interval)\n                self.relogin()  # Will raise exception in case of login error\n            else:\n                raise ZabbixAPIException('Not logged in.')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms a Zabbix API request and return the result.", "response": "def call(self, method, params=None):\n        \"\"\"Check authentication and perform actual API request and relogin if needed\"\"\"\n        start_time = time()\n        self.check_auth()\n        self.log(INFO, '[%s-%05d] Calling Zabbix API method \"%s\"', start_time, self.id, method)\n        self.log(DEBUG, '\\twith parameters: %s', params)\n\n        try:\n            return self.do_request(self.json_obj(method, params=params))\n        except ZabbixAPIError as ex:\n            if self.relogin_interval and any(i in ex.error['data'] for i in self.LOGIN_ERRORS):\n                self.log(WARNING, 'Zabbix API not logged in (%s). Performing Zabbix API relogin', ex)\n                self.relogin()  # Will raise exception in case of login error\n                return self.do_request(self.json_obj(method, params=params))\n            raise  # Re-raise the exception\n        finally:\n            self.log(INFO, '[%s-%05d] Zabbix API method \"%s\" finished in %g seconds',\n                     start_time, self.id, method, (time() - start_time))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload a file from a remote server", "response": "def download_parallel(url, directory, idx, min_file_size = 0, max_file_size = -1,  \n\t\t\t no_redirects = False, pos = 0, mode = 's'):\n\t\"\"\"\n\tdownload function to download parallely\n\t\"\"\"\n\tglobal main_it\n\tglobal exit_flag\n\tglobal total_chunks\n\tglobal file_name\n\tglobal i_max\n\n\tfile_name[idx]= url.split('/')[-1] \n\tfile_address = directory + '/' + file_name[idx]\n\tis_redirects = not no_redirects\n\n\tresp = s.get(url, stream = True, allow_redirects = is_redirects)\n\tif not resp.status_code == 200:\n\t\t# ignore this file since server returns invalid response\n\t\texit_flag += 1\n\t\treturn\n\ttry:\n\t\ttotal_size = int(resp.headers['content-length'])\n\texcept KeyError:\n\t\ttotal_size = len(resp.content)\n\n\ttotal_chunks[idx] = total_size / chunk_size\n\tif total_chunks[idx] < min_file_size: \n\t\t# ignore this file since file size is lesser than min_file_size\n\t\texit_flag += 1\n\t\treturn\n\telif max_file_size != -1 and total_chunks[idx] > max_file_size:\n\t\t# ignore this file since file size is greater than max_file_size\n\t\texit_flag += 1\n\t\treturn\n\n\tfile_iterable = resp.iter_content(chunk_size = chunk_size)\n\twith open(file_address, 'wb') as f:\n\t\tfor sno, data in enumerate(file_iterable):\n\t\t\ti_max[idx] = sno + 1\n\t\t\tf.write(data)\n\t\n\texit_flag += 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download_parallel_gui(root, urls, directory, min_file_size, max_file_size, no_redirects):\n\tglobal parallel\n\n\t# create directory to save files\n\tif not os.path.exists(directory):\n\t\tos.makedirs(directory)\n\tparallel = True\n\tapp = progress_class(root, urls, directory, min_file_size, max_file_size, no_redirects)", "response": "downloads urls in parallel mode and creates a GUI file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_series_gui(frame, urls, directory, min_file_size, max_file_size, no_redirects):\n\n\t# create directory to save files\n\tif not os.path.exists(directory):\n\t\tos.makedirs(directory)\n\tapp = progress_class(frame, urls, directory, min_file_size, max_file_size, no_redirects)", "response": "downloads series from wxPython and creates GUI"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstart downloading the file", "response": "def start(self):\n\t\t\"\"\"\n\t\tfunction to initialize thread for downloading\n\t\t\"\"\"\n\t\tglobal parallel\n\t\tfor self.i in range(0, self.length):\n\t\t\tif parallel:\n\t\t\t\tself.thread.append(myThread(self.url[ self.i ], self.directory, self.i, \n\t\t\t\t\t\t\t\t   self.min_file_size, self.max_file_size, self.no_redirects))\n\t\t\telse:\n\t\t\t\t# if not parallel whole url list is passed\n\t\t\t\tself.thread.append(myThread(self.url, self.directory, self.i , self.min_file_size, \n\t\t\t\t\t\t\t\t   self.max_file_size,  self.no_redirects))\n\t\t\tself.progress[self.i][\"value\"] = 0\n\t\t\tself.bytes[self.i] = 0\n\t\t\tself.thread[self.i].start()\n\n\t\tself.read_bytes()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_bytes(self):\n\t\tglobal exit_flag\n\n\t\tfor self.i in range(0, self.length) :\n\t\t\tself.bytes[self.i] = i_max[self.i]\n\t\t\tself.maxbytes[self.i] = total_chunks[self.i]\n\t\t\tself.progress[self.i][\"maximum\"] = total_chunks[self.i]\n\t\t\tself.progress[self.i][\"value\"] = self.bytes[self.i]\n\t\t\tself.str[self.i].set(file_name[self.i]+ \"       \" + str(self.bytes[self.i]) \n\t\t\t\t\t\t\t\t  + \"KB / \" + str(int(self.maxbytes[self.i] + 1)) + \" KB\")\n\n\t\tif exit_flag == self.length:\n\t\t\texit_flag = 0\n\t\t\tself.frame.destroy()\n\t\telse:\n\t\t\tself.frame.after(10, self.read_bytes)", "response": "read bytes update progress bar after 1 ms\n\texit_flag"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds this type to our collection if needed.", "response": "def declare_type(self, declared_type):  # type: (TypeDef) -> TypeDef\n        \"\"\"Add this type to our collection, if needed.\"\"\"\n        if declared_type not in self.collected_types:\n            self.collected_types[declared_type.name] = declared_type\n        return declared_type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_namespaces(metadata, namespaces):\n    # type: (Mapping[Text, Any], MutableMapping[Text, Text]) -> None\n    \"\"\"Collect the provided namespaces, checking for conflicts.\"\"\"\n    for key, value in metadata.items():\n        if key not in namespaces:\n            namespaces[key] = value\n        elif namespaces[key] != value:\n            raise validate.ValidationException(\n                \"Namespace prefix '{}' has conflicting definitions '{}'\"\n                \" and '{}'.\".format(key, namespaces[key], value))", "response": "Add the provided namespaces to the provided metadata."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collect_namespaces(metadata):\n    # type: (Mapping[Text, Any]) -> Dict[Text, Text]\n    \"\"\"Walk through the metadata object, collecting namespace declarations.\"\"\"\n    namespaces = {}  # type: Dict[Text, Text]\n    if \"$import_metadata\" in metadata:\n        for value in metadata[\"$import_metadata\"].values():\n            add_namespaces(collect_namespaces(value), namespaces)\n    if \"$namespaces\" in metadata:\n        add_namespaces(metadata[\"$namespaces\"], namespaces)\n    return namespaces", "response": "Walk through the metadata object and collect namespace declarations."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_schema(schema_ref,  # type: Union[CommentedMap, CommentedSeq, Text]\n                cache=None   # type: Dict\n                ):\n    # type: (...) -> Tuple[Loader, Union[Names, SchemaParseException], Dict[Text, Any], Loader]\n    \"\"\"\n    Load a schema that can be used to validate documents using load_and_validate.\n\n    return: document_loader, avsc_names, schema_metadata, metaschema_loader\n    \"\"\"\n\n    metaschema_names, _metaschema_doc, metaschema_loader = get_metaschema()\n    if cache is not None:\n        metaschema_loader.cache.update(cache)\n    schema_doc, schema_metadata = metaschema_loader.resolve_ref(schema_ref, \"\")\n\n    if not isinstance(schema_doc, MutableSequence):\n        raise ValueError(\"Schema reference must resolve to a list.\")\n\n    validate_doc(metaschema_names, schema_doc, metaschema_loader, True)\n    metactx = schema_metadata.get(\"@context\", {})\n    metactx.update(collect_namespaces(schema_metadata))\n    schema_ctx = jsonld_context.salad_to_jsonld_context(schema_doc, metactx)[0]\n\n    # Create the loader that will be used to load the target document.\n    document_loader = Loader(schema_ctx, cache=cache)\n\n    # Make the Avro validation that will be used to validate the target\n    # document\n    avsc_names = make_avro_schema(schema_doc, document_loader)\n\n    return document_loader, avsc_names, schema_metadata, metaschema_loader", "response": "Load a schema that can be used to validate documents using load_and_validate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a document and validate it with the provided schema.", "response": "def load_and_validate(document_loader,                 # type: Loader\n                      avsc_names,                      # type: Names\n                      document,                        # type: Union[CommentedMap, Text]\n                      strict,                          # type: bool\n                      strict_foreign_properties=False  # type: bool\n                      ):\n    # type: (...) -> Tuple[Any, Dict[Text, Any]]\n    \"\"\"Load a document and validate it with the provided schema.\n\n    return data, metadata\n    \"\"\"\n    try:\n        if isinstance(document, CommentedMap):\n            data, metadata = document_loader.resolve_all(\n                document, document[\"id\"], checklinks=True,\n                strict_foreign_properties=strict_foreign_properties)\n        else:\n            data, metadata = document_loader.resolve_ref(\n                document, checklinks=True,\n                strict_foreign_properties=strict_foreign_properties)\n\n        validate_doc(avsc_names, data, document_loader, strict,\n                     strict_foreign_properties=strict_foreign_properties)\n\n        return data, metadata\n    except validate.ValidationException as exc:\n        raise validate.ValidationException(strip_dup_lineno(str(exc)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_doc(schema_names,  # type: Names\n                 doc,           # type: Union[Dict[Text, Any], List[Dict[Text, Any]], Text, None]\n                 loader,        # type: Loader\n                 strict,        # type: bool\n                 strict_foreign_properties=False  # type: bool\n                 ):\n    # type: (...) -> None\n    \"\"\"Validate a document using the provided schema.\"\"\"\n    has_root = False\n    for root in schema_names.names.values():\n        if ((hasattr(root, 'get_prop') and root.get_prop(u\"documentRoot\")) or (\n                u\"documentRoot\" in root.props)):\n            has_root = True\n            break\n\n    if not has_root:\n        raise validate.ValidationException(\n            \"No document roots defined in the schema\")\n\n    if isinstance(doc, MutableSequence):\n        vdoc = doc\n    elif isinstance(doc, CommentedMap):\n        vdoc = CommentedSeq([doc])\n        vdoc.lc.add_kv_line_col(0, [doc.lc.line, doc.lc.col])\n        vdoc.lc.filename = doc.lc.filename\n    else:\n        raise validate.ValidationException(\"Document must be dict or list\")\n\n    roots = []\n    for root in schema_names.names.values():\n        if ((hasattr(root, \"get_prop\") and root.get_prop(u\"documentRoot\")) or (\n                root.props.get(u\"documentRoot\"))):\n            roots.append(root)\n\n    anyerrors = []\n    for pos, item in enumerate(vdoc):\n        sourceline = SourceLine(vdoc, pos, Text)\n        success = False\n        for root in roots:\n            success = validate.validate_ex(\n                root, item, loader.identifiers, strict,\n                foreign_properties=loader.foreign_properties,\n                raise_ex=False, skip_foreign_properties=loader.skip_schemas,\n                strict_foreign_properties=strict_foreign_properties)\n            if success:\n                break\n\n        if not success:\n            errors = []  # type: List[Text]\n            for root in roots:\n                if hasattr(root, \"get_prop\"):\n                    name = root.get_prop(u\"name\")\n                elif hasattr(root, \"name\"):\n                    name = root.name\n\n                try:\n                    validate.validate_ex(\n                        root, item, loader.identifiers, strict,\n                        foreign_properties=loader.foreign_properties,\n                        raise_ex=True, skip_foreign_properties=loader.skip_schemas,\n                        strict_foreign_properties=strict_foreign_properties)\n                except validate.ClassValidationException as exc:\n                    errors = [sourceline.makeError(u\"tried `%s` but\\n%s\" % (\n                        name, validate.indent(str(exc), nolead=False)))]\n                    break\n                except validate.ValidationException as exc:\n                    errors.append(sourceline.makeError(u\"tried `%s` but\\n%s\" % (\n                        name, validate.indent(str(exc), nolead=False))))\n\n            objerr = sourceline.makeError(u\"Invalid\")\n            for ident in loader.identifiers:\n                if ident in item:\n                    objerr = sourceline.makeError(\n                        u\"Object `%s` is not valid because\"\n                        % (relname(item[ident])))\n                    break\n            anyerrors.append(u\"%s\\n%s\" %\n                             (objerr, validate.indent(bullets(errors, \"- \"))))\n    if anyerrors:\n        raise validate.ValidationException(\n            strip_dup_lineno(bullets(anyerrors, \"* \")))", "response": "Validate a document using the provided schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_anon_name(rec):\n    # type: (MutableMapping[Text, Any]) -> Text\n    \"\"\"Calculate a reproducible name for anonymous types.\"\"\"\n    if \"name\" in rec:\n        return rec[\"name\"]\n    anon_name = \"\"\n    if rec['type'] in ('enum', 'https://w3id.org/cwl/salad#enum'):\n        for sym in rec[\"symbols\"]:\n            anon_name += sym\n        return \"enum_\"+hashlib.sha1(anon_name.encode(\"UTF-8\")).hexdigest()\n    if rec['type'] in ('record', 'https://w3id.org/cwl/salad#record'):\n        for field in rec[\"fields\"]:\n            anon_name += field[\"name\"]\n        return \"record_\"+hashlib.sha1(anon_name.encode(\"UTF-8\")).hexdigest()\n    if rec['type'] in ('array', 'https://w3id.org/cwl/salad#array'):\n        return \"\"\n    raise validate.ValidationException(\"Expected enum or record, was %s\" % rec['type'])", "response": "Calculate a reproducible name for anonymous types."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngoes through and replace types in the spec mapping.", "response": "def replace_type(items, spec, loader, found, find_embeds=True, deepen=True):\n    # type: (Any, Dict[Text, Any], Loader, Set[Text], bool, bool) -> Any\n    \"\"\" Go through and replace types in the 'spec' mapping\"\"\"\n\n    if isinstance(items, MutableMapping):\n        # recursively check these fields for types to replace\n        if items.get(\"type\") in (\"record\", \"enum\") and items.get(\"name\"):\n            if items[\"name\"] in found:\n                return items[\"name\"]\n            found.add(items[\"name\"])\n\n        if not deepen:\n            return items\n\n        items = copy.copy(items)\n        if not items.get(\"name\"):\n            items[\"name\"] = get_anon_name(items)\n        for name in (\"type\", \"items\", \"fields\"):\n            if name in items:\n                items[name] = replace_type(\n                    items[name], spec, loader, found, find_embeds=find_embeds,\n                    deepen=find_embeds)\n                if isinstance(items[name], MutableSequence):\n                    items[name] = flatten(items[name])\n\n        return items\n    if isinstance(items, MutableSequence):\n        # recursively transform list\n        return [replace_type(i, spec, loader, found, find_embeds=find_embeds,\n                             deepen=deepen) for i in items]\n    if isinstance(items, string_types):\n        # found a string which is a symbol corresponding to a type.\n        replace_with = None\n        if items in loader.vocab:\n            # If it's a vocabulary term, first expand it to its fully qualified\n            # URI\n            items = loader.vocab[items]\n\n        if items in spec:\n            # Look up in specialization map\n            replace_with = spec[items]\n\n        if replace_with:\n            return replace_type(replace_with, spec, loader, found, find_embeds=find_embeds)\n        found.add(items)\n    return items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nturning a URL into an Avro - safe name.", "response": "def avro_name(url):  # type: (AnyStr) -> AnyStr\n    \"\"\"\n    Turn a URL into an Avro-safe name.\n\n    If the URL has no fragment, return this plain URL.\n\n    Extract either the last part of the URL fragment past the slash, otherwise\n    the whole fragment.\n    \"\"\"\n    frg = urllib.parse.urldefrag(url)[1]\n    if frg != '':\n        if '/' in frg:\n            return frg[frg.rindex('/') + 1:]\n        return frg\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_valid_avro(items,          # type: Avro\n                    alltypes,       # type: Dict[Text, Dict[Text, Any]]\n                    found,          # type: Set[Text]\n                    union=False     # type: bool\n                    ):\n    # type: (...) -> Union[Avro, Dict, Text]\n    \"\"\"Convert our schema to be more avro like.\"\"\"\n    # Possibly could be integrated into our fork of avro/schema.py?\n    if isinstance(items, MutableMapping):\n        items = copy.copy(items)\n        if items.get(\"name\") and items.get(\"inVocab\", True):\n            items[\"name\"] = avro_name(items[\"name\"])\n\n        if \"type\" in items and items[\"type\"] in (\n                \"https://w3id.org/cwl/salad#record\",\n                \"https://w3id.org/cwl/salad#enum\", \"record\", \"enum\"):\n            if (hasattr(items, \"get\") and items.get(\"abstract\")) or (\"abstract\"\n                                                                     in items):\n                return items\n            if items[\"name\"] in found:\n                return cast(Text, items[\"name\"])\n            found.add(items[\"name\"])\n        for field in (\"type\", \"items\", \"values\", \"fields\"):\n            if field in items:\n                items[field] = make_valid_avro(\n                    items[field], alltypes, found, union=True)\n        if \"symbols\" in items:\n            items[\"symbols\"] = [avro_name(sym) for sym in items[\"symbols\"]]\n        return items\n    if isinstance(items, MutableSequence):\n        ret = []\n        for i in items:\n            ret.append(make_valid_avro(i, alltypes, found, union=union))  # type: ignore\n        return ret\n    if union and isinstance(items, string_types):\n        if items in alltypes and avro_name(items) not in found:\n            return cast(Dict, make_valid_avro(alltypes[items], alltypes, found,\n                                              union=union))\n        items = avro_name(items)\n    return items", "response": "Convert our schema to more avro like."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deepcopy_strip(item):  # type: (Any) -> Any\n\n    if isinstance(item, MutableMapping):\n        return {k: deepcopy_strip(v) for k, v in iteritems(item)}\n    if isinstance(item, MutableSequence):\n        return [deepcopy_strip(k) for k in item]\n    return item", "response": "Make a deep copy of list and dict objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extend_and_specialize(items, loader):\n    # type: (List[Dict[Text, Any]], Loader) -> List[Dict[Text, Any]]\n    \"\"\"\n    Apply 'extend' and 'specialize' to fully materialize derived record types.\n    \"\"\"\n\n    items = deepcopy_strip(items)\n    types = {i[\"name\"]: i for i in items}  # type: Dict[Text, Any]\n    results = []\n\n    for stype in items:\n        if \"extends\" in stype:\n            specs = {}  # type: Dict[Text, Text]\n            if \"specialize\" in stype:\n                for spec in aslist(stype[\"specialize\"]):\n                    specs[spec[\"specializeFrom\"]] = spec[\"specializeTo\"]\n\n            exfields = []  # type: List[Text]\n            exsym = []  # type: List[Text]\n            for ex in aslist(stype[\"extends\"]):\n                if ex not in types:\n                    raise Exception(\n                        \"Extends {} in {} refers to invalid base type.\".format(\n                            stype[\"extends\"], stype[\"name\"]))\n\n                basetype = copy.copy(types[ex])\n\n                if stype[\"type\"] == \"record\":\n                    if specs:\n                        basetype[\"fields\"] = replace_type(\n                            basetype.get(\"fields\", []), specs, loader, set())\n\n                    for field in basetype.get(\"fields\", []):\n                        if \"inherited_from\" not in field:\n                            field[\"inherited_from\"] = ex\n\n                    exfields.extend(basetype.get(\"fields\", []))\n                elif stype[\"type\"] == \"enum\":\n                    exsym.extend(basetype.get(\"symbols\", []))\n\n            if stype[\"type\"] == \"record\":\n                stype = copy.copy(stype)\n                exfields.extend(stype.get(\"fields\", []))\n                stype[\"fields\"] = exfields\n\n                fieldnames = set()  # type: Set[Text]\n                for field in stype[\"fields\"]:\n                    if field[\"name\"] in fieldnames:\n                        raise validate.ValidationException(\n                            \"Field name {} appears twice in {}\".format(\n                                field[\"name\"], stype[\"name\"]))\n                    else:\n                        fieldnames.add(field[\"name\"])\n            elif stype[\"type\"] == \"enum\":\n                stype = copy.copy(stype)\n                exsym.extend(stype.get(\"symbols\", []))\n                stype[\"symbol\"] = exsym\n\n            types[stype[\"name\"]] = stype\n\n        results.append(stype)\n\n    ex_types = {}\n    for result in results:\n        ex_types[result[\"name\"]] = result\n\n    extended_by = {}  # type: Dict[Text, Text]\n    for result in results:\n        if \"extends\" in result:\n            for ex in aslist(result[\"extends\"]):\n                if ex_types[ex].get(\"abstract\"):\n                    add_dictlist(extended_by, ex, ex_types[result[\"name\"]])\n                    add_dictlist(extended_by, avro_name(ex), ex_types[ex])\n\n    for result in results:\n        if result.get(\"abstract\") and result[\"name\"] not in extended_by:\n            raise validate.ValidationException(\n                \"{} is abstract but missing a concrete subtype\".format(\n                    result[\"name\"]))\n\n    for result in results:\n        if \"fields\" in result:\n            result[\"fields\"] = replace_type(\n                result[\"fields\"], extended_by, loader, set())\n\n    return results", "response": "Extend derived record types and specialize."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_avro_schema(i,         # type: List[Any]\n                     loader     # type: Loader\n                     ):  # type: (...) -> Names\n    \"\"\"\n    All in one convenience function.\n\n    Call make_avro() and make_avro_schema_from_avro() separately if you need\n    the intermediate result for diagnostic output.\n    \"\"\"\n    names = Names()\n    avro = make_avro(i, loader)\n    make_avsc_object(convert_to_dict(avro), names)\n    return names", "response": "Make an avro schema from a list of IKIF objects."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the last segment of the provided fragment or path.", "response": "def shortname(inputid):  # type: (Text) -> Text\n    \"\"\"Returns the last segment of the provided fragment or path.\"\"\"\n    parsed_id = urllib.parse.urlparse(inputid)\n    if parsed_id.fragment:\n        return parsed_id.fragment.split(u\"/\")[-1]\n    return parsed_id.path.split(u\"/\")[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a Grapviz inheritance graph for the supplied document.", "response": "def print_inheritance(doc, stream):\n    # type: (List[Dict[Text, Any]], IO) -> None\n    \"\"\"Write a Grapviz inheritance graph for the supplied document.\"\"\"\n    stream.write(\"digraph {\\n\")\n    for entry in doc:\n        if entry[\"type\"] == \"record\":\n            label = name = shortname(entry[\"name\"])\n            fields = entry.get(\"fields\", [])\n            if fields:\n                label += \"\\\\n* %s\\\\l\" % (\n                    \"\\\\l* \".join(shortname(field[\"name\"])\n                                 for field in fields))\n            shape = \"ellipse\" if entry.get(\"abstract\") else \"box\"\n            stream.write(\"\\\"%s\\\" [shape=%s label=\\\"%s\\\"];\\n\"\n                         % (name, shape, label))\n            if \"extends\" in entry:\n                for target in aslist(entry[\"extends\"]):\n                    stream.write(\"\\\"%s\\\" -> \\\"%s\\\";\\n\"\n                                 % (shortname(target), name))\n    stream.write(\"}\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a GraphViz graph of the relationships between the fields.", "response": "def print_fieldrefs(doc, loader, stream):\n    # type: (List[Dict[Text, Any]], Loader, IO) -> None\n    \"\"\"Write a GraphViz graph of the relationships between the fields.\"\"\"\n    obj = extend_and_specialize(doc, loader)\n\n    primitives = set((\"http://www.w3.org/2001/XMLSchema#string\",\n                      \"http://www.w3.org/2001/XMLSchema#boolean\",\n                      \"http://www.w3.org/2001/XMLSchema#int\",\n                      \"http://www.w3.org/2001/XMLSchema#long\",\n                      \"https://w3id.org/cwl/salad#null\",\n                      \"https://w3id.org/cwl/salad#enum\",\n                      \"https://w3id.org/cwl/salad#array\",\n                      \"https://w3id.org/cwl/salad#record\",\n                      \"https://w3id.org/cwl/salad#Any\"))\n\n    stream.write(\"digraph {\\n\")\n    for entry in obj:\n        if entry.get(\"abstract\"):\n            continue\n        if entry[\"type\"] == \"record\":\n            label = shortname(entry[\"name\"])\n            for field in entry.get(\"fields\", []):\n                found = set()  # type: Set[Text]\n                field_name = shortname(field[\"name\"])\n                replace_type(field[\"type\"], {}, loader, found, find_embeds=False)\n                for each_type in found:\n                    if each_type not in primitives:\n                        stream.write(\n                            \"\\\"%s\\\" -> \\\"%s\\\" [label=\\\"%s\\\"];\\n\"\n                            % (label, shortname(each_type), field_name))\n    stream.write(\"}\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_other_props(all_props, reserved_props):\n    # type: (Dict, Tuple) -> Optional[Dict]\n    \"\"\"\n    Retrieve the non-reserved properties from a dictionary of properties\n    @args reserved_props: The set of reserved properties to exclude\n    \"\"\"\n    if hasattr(all_props, 'items') and callable(all_props.items):\n        return dict([(k,v) for (k,v) in list(all_props.items()) if k not in\n                     reserved_props])\n    return None", "response": "Retrieve the non - reserved properties from a dictionary of properties\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an Avro Schema from data parsed out of JSON string.", "response": "def make_avsc_object(json_data, names=None):\n    # type: (Union[Dict[Text, Text], List[Any], Text], Optional[Names]) -> Schema\n    \"\"\"\n    Build Avro Schema from data parsed out of JSON string.\n\n    @arg names: A Name object (tracks seen names and default space)\n    \"\"\"\n    if names is None:\n        names = Names()\n    assert isinstance(names, Names)\n\n    # JSON object (non-union)\n    if hasattr(json_data, 'get') and callable(json_data.get):  # type: ignore\n        assert isinstance(json_data, Dict)\n        atype = cast(Text, json_data.get('type'))\n        other_props = get_other_props(json_data, SCHEMA_RESERVED_PROPS)\n        if atype in PRIMITIVE_TYPES:\n            return PrimitiveSchema(atype, other_props)\n        if atype in NAMED_TYPES:\n            name = cast(Text, json_data.get('name'))\n            namespace = cast(Text, json_data.get('namespace',\n                                                 names.default_namespace))\n            if atype == 'enum':\n                symbols = cast(List[Text], json_data.get('symbols'))\n                doc = json_data.get('doc')\n                return EnumSchema(name, namespace, symbols, names, doc, other_props)\n            if atype in ['record', 'error']:\n                fields = cast(List, json_data.get('fields'))\n                doc = json_data.get('doc')\n                return RecordSchema(name, namespace, fields, names, atype, doc, other_props)\n            raise SchemaParseException('Unknown Named Type: %s' % atype)\n        if atype in VALID_TYPES:\n            if atype == 'array':\n                items = cast(List, json_data.get('items'))\n                return ArraySchema(items, names, other_props)\n        if atype is None:\n            raise SchemaParseException('No \"type\" property: %s' % json_data)\n        raise SchemaParseException('Undefined type: %s' % atype)\n    # JSON array (union)\n    if isinstance(json_data, list):\n        return UnionSchema(json_data, names)\n    # JSON string (primitive)\n    if json_data in PRIMITIVE_TYPES:\n        return PrimitiveSchema(cast(Text, json_data))\n    # not for us!\n    fail_msg = \"Could not make an Avro Schema object from %s.\" % json_data\n    raise SchemaParseException(fail_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbacks out a namespace from full name.", "response": "def get_space(self):\n        # type: () -> Optional[Text]\n        \"\"\"Back out a namespace from full name.\"\"\"\n        if self._full is None:\n            return None\n\n        if self._full.find('.') > 0:\n            return self._full.rsplit(\".\", 1)[0]\n        else:\n            return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_name(self, name_attr, space_attr, new_schema):\n        # type: (Text, Optional[Text], NamedSchema) -> Name\n        \"\"\"\n        Add a new schema object to the name set.\n\n          @arg name_attr: name value read in schema\n          @arg space_attr: namespace value read in schema.\n\n          @return: the Name that was just added.\n        \"\"\"\n        to_add = Name(name_attr, space_attr, self.default_namespace)\n\n        if to_add.fullname in VALID_TYPES:\n            fail_msg = '%s is a reserved type name.' % to_add.fullname\n            raise SchemaParseException(fail_msg)\n        elif to_add.fullname in self.names:\n            fail_msg = 'The name \"%s\" is already in use.' % to_add.fullname\n            raise SchemaParseException(fail_msg)\n\n        self.names[to_add.fullname] = new_schema\n        return to_add", "response": "Add a new name to the name set."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking the list of field objects that are needed to create the message parameters.", "response": "def make_field_objects(field_data, names):\n        # type: (List[Dict[Text, Text]], Names) -> List[Field]\n        \"\"\"We're going to need to make message parameters too.\"\"\"\n        field_objects = []\n        field_names = []  # type: List[Text]\n        for field in field_data:\n            if hasattr(field, 'get') and callable(field.get):\n                atype = cast(Text, field.get('type'))\n                name = cast(Text, field.get('name'))\n\n                # null values can have a default value of None\n                has_default = False\n                default = None\n                if 'default' in field:\n                    has_default = True\n                    default = field.get('default')\n\n                order = field.get('order')\n                doc = field.get('doc')\n                other_props = get_other_props(field, FIELD_RESERVED_PROPS)\n                new_field = Field(atype, name, has_default, default, order, names, doc,\n                                 other_props)\n                # make sure field name has not been used yet\n                if new_field.name in field_names:\n                    fail_msg = 'Field name %s already in use.' % new_field.name\n                    raise SchemaParseException(fail_msg)\n                field_names.append(new_field.name)\n            else:\n                raise SchemaParseException('Not a valid field: %s' % field)\n            field_objects.append(new_field)\n        return field_objects"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching function to get links global", "response": "def search_function(root1, q, s, f, l, o='g'):\n\t\"\"\"\n\tfunction to get links\n\t\"\"\"\n\tglobal links\n\tlinks = search(q, o, s, f, l)\n\troot1.destroy()\n\troot1.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef task(ft):\n\tft.pack(expand = True,  fill = BOTH,  side = TOP)\n\tpb_hD = ttk.Progressbar(ft, orient = 'horizontal', mode = 'indeterminate')\n\tpb_hD.pack(expand = True, fill = BOTH, side = TOP)\n\tpb_hD.start(50)\n\tft.mainloop()", "response": "create loading progress bar\n\t to create loading progress bar\n\tpb to create loading progress bar\n\tpb"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_content_gui(**args):\n\tglobal row\n\n\tif not args ['directory']:\n\t\targs ['directory'] = args ['query'].replace(' ', '-')\n\n\troot1 = Frame(root)\n\tt1 = threading.Thread(target = search_function,  args = (root1,\n\t\t\t\t\t\t  args['query'], args['website'], args['file_type'], args['limit'],args['option']))\n\tt1.start()\n\ttask(root1)\n\tt1.join()\n\n\t#new frame for progress bar \n\trow = Frame(root)\n\trow.pack()\n\tif args['parallel']:\n\t\tdownload_parallel_gui(row, links,  args['directory'], args['min_file_size'], \n\t\t\t\t\t\t\t\t args['max_file_size'], args['no_redirects'])\n\telse:\n\t\tdownload_series_gui(row, links, args['directory'], args['min_file_size'],\n\t\t\t\t\t\t\t\t args['max_file_size'], args['no_redirects'])", "response": "downloads content from the main window"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef click_download(self, event):\n\t\targs ['parallel'] = self.p.get()\n\t\targs ['file_type'] = self.optionmenu.get()\n\t\targs ['no_redirects'] = self.t.get()\n\t\targs ['query'] = self.entry_query.get()\n\t\targs ['min_file_size'] = int( self.entry_min.get())\n\t\targs ['max_file_size'] = int( self.entry_max.get())\n\t\targs ['limit'] = int( self.entry_limit.get())\n\t\targs ['website']= self.entry_website.get()\n\t\targs ['option']= self.engine.get()\n\t\tprint(args)\n\t\tself.check_threat()\n\t\tdownload_content_gui( **args )", "response": "event for download button"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions that gets called when the entry is clicked", "response": "def on_entry_click(self, event):\n\t\t\"\"\"\n\t\tfunction that gets called whenever entry is clicked\n\t\t\"\"\"\n\t\tif event.widget.config('fg') [4] == 'grey':\n\t\t   event.widget.delete(0, \"end\" ) # delete all the text in the entry\n\t\t   event.widget.insert(0, '') #Insert blank for user input\n\t\t   event.widget.config(fg = 'black')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning that gets called whenever the user clicks the entry.", "response": "def on_focusout(self, event, a):\n\t\t\"\"\"\n\t\tfunction that gets called whenever anywhere except entry is clicked\n\t\t\"\"\"\n\t\tif event.widget.get() == '':\n\t\t\tevent.widget.insert(0, default_text[a])\n\t\t\tevent.widget.config(fg = 'grey')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if threat extension is high", "response": "def check_threat(self):\n\t\t\"\"\"\n\t\tfunction to check input filetype against threat extensions list \n\t\t\"\"\"\n\t\tis_high_threat = False\n\t\tfor val in THREAT_EXTENSIONS.values():\n\t\t\tif type(val) == list:\n\t\t\t\tfor el in val:\n\t\t\t\t\tif self.optionmenu.get() == el:\n\t\t\t\t\t\tis_high_threat = True\n\t\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif self.optionmenu.get() == val:\n\t\t\t\t\tis_high_threat = True\n\t\t\t\t\tbreak\n\n\t\tif is_high_threat == True:\n\t\t\tis_high_threat = not askokcancel('FILE TYPE', 'WARNING: Downloading this \\\n\t\t\t\t\t\t\t\t\t\t\tfile type may expose you to a heightened security risk.\\nPress\\\n\t\t\t\t\t\t\t\t\t\t\t\"OK\" to proceed or \"CANCEL\" to exit')\n\t\treturn not is_high_threat"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ask_dir(self):\n\t\targs ['directory'] = askdirectory(**self.dir_opt) \n\t\tself.dir_text.set(args ['directory'])", "response": "asks user for a directory"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_google_links(limit, params, headers):\n\tlinks = []\n\tfor start_index in range(0, limit, 10):\n\t\tparams['start'] = start_index\n\t\tresp = s.get(\"https://www.google.com/search\", params = params, headers = headers)\n\t\tpage_links = scrape_links(resp.content, engine = 'g')\n\t\tlinks.extend(page_links)\n\treturn links[:limit]", "response": "function to fetch links equal to limit\n\n\tevery Google search result page has a start index.\n\tevery page contains 10 search results."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction to fetch links equal to limit duckduckgo pagination is not static, so there is a limit on maximum number of links that can be scraped", "response": "def get_duckduckgo_links(limit, params, headers):\n\t\"\"\"\n\tfunction to fetch links equal to limit\n\n\tduckduckgo pagination is not static, so there is a limit on\n\tmaximum number of links that can be scraped\n\t\"\"\"\n\tresp = s.get('https://duckduckgo.com/html', params = params, headers = headers)\n\tlinks = scrape_links(resp.content, engine = 'd')\n\treturn links[:limit]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nscrape file links from html response function to scrape file links from html response", "response": "def scrape_links(html, engine):\n\t\"\"\"\n\tfunction to scrape file links from html response\n\t\"\"\"\n\tsoup = BeautifulSoup(html, 'lxml')\n\tlinks = []\n\n\tif engine == 'd':\n\t\tresults = soup.findAll('a', {'class': 'result__a'})\n\t\tfor result in results:\n\t\t\tlink = result.get('href')[15:]\n\t\t\tlink = link.replace('/blob/', '/raw/')\n\t\t\tlinks.append(link)\n\n\telif engine == 'g':\n\t\tresults = soup.findAll('h3', {'class': 'r'})   \t\n\t\tfor result in results:\n\t\t\tlink = result.a['href'][7:].split('&')[0]\n\t\t\tlink = link.replace('/blob/', '/raw/')\n\t\t\tlinks.append(link)\n\n\treturn links"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction to get return code of a url", "response": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating urls based on http prefixes and return code 200", "response": "def validate_links(links):\n\t\"\"\"\n\tfunction to validate urls based on http(s) prefix and return code\n\t\"\"\"\n\tvalid_links = []\n\tfor link in links:\n\t\tif link[:7] in \"http://\" or link[:8] in \"https://\":\n\t\t\tvalid_links.append(link)\n\t\n\tif not valid_links:\n\t\tprint(\"No files found.\")\n\t\tsys.exit(0)\n\n\t# checking valid urls for return code\n\turls = {}\n\tfor link in valid_links:\n\t\tif 'github.com' and '/blob/' in link:\n\t\t\tlink = link.replace('/blob/', '/raw/')\n\t\turls[link] = {'code': get_url_nofollow(link)}\n\t\t\n\t\n\t# printing valid urls with return code 200\n\tavailable_urls = []\n\tfor url in urls:\n\t\tprint(\"code: %d\\turl: %s\" % (urls[url]['code'], url))\n\t\tif urls[url]['code'] != 0:\n\t\t\tavailable_urls.append(url)\n\n\treturn available_urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches function to search for links and return valid ones", "response": "def search(query, engine='g', site=\"\", file_type = 'pdf', limit = 10):\n\t\"\"\"\n\tmain function to search for links and return valid ones\n\t\"\"\"\n\tif site == \"\":\n\t\tsearch_query = \"filetype:{0} {1}\".format(file_type, query)\n\telse:\n\t\tsearch_query = \"site:{0} filetype:{1} {2}\".format(site,file_type, query)\n\n\theaders = {\n\t\t'User Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) \\\n\t\tGecko/20100101 Firefox/53.0'\n\t}\n\tif engine == \"g\":\n\t\tparams = {\n\t\t\t'q': search_query,\n\t\t\t'start': 0,\n\t\t}\n\t\tlinks = get_google_links(limit, params, headers)\n\n\telif engine == \"d\":\n\t\tparams = {\n\t\t\t'q': search_query,\n\t\t}\n\t\tlinks = get_duckduckgo_links(limit,params,headers)\n\telse:\n\t\tprint(\"Wrong search engine selected!\")\n\t\tsys.exit()\n\t\n\tvalid_links = validate_links(links)\n\treturn valid_links"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_threats(**args):\n\tis_high_threat = False\n\tfor val in THREAT_EXTENSIONS.values():\n\t\tif type(val) == list:\n\t\t\tfor el in val:\n\t\t\t\tif args['file_type'] == el:\n\t\t\t\t\tis_high_threat = True\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tif args['file_type'] == val:\n\t\t\t\tis_high_threat = True\n\t\t\t\tbreak\n\treturn is_high_threat", "response": "check if threat extensions are high"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_args(**args):\n\tif not args['query']:\n\t\tprint(\"\\nMissing required query argument.\")\n\t\tsys.exit()\n\n\tfor key in DEFAULTS:\n\t\tif key not in args:\n\t\t\targs[key] = DEFAULTS[key]\n\n\treturn args", "response": "check if input query is not None \n\tand set missing arguments to default value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_filetypes(extensions):\n\tfor item in extensions.items():\n\t\tval = item[1]\n\t\tif type(item[1]) == list:\n\t\t\tval = \", \".join(str(x) for x in item[1])\n\t\tprint(\"{0:4}: {1}\".format(val, item[0]))", "response": "shows valid file extensions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_ex(expected_schema,                  # type: Schema\n                datum,                            # type: Any\n                identifiers=None,                 # type: List[Text]\n                strict=False,                     # type: bool\n                foreign_properties=None,          # type: Set[Text]\n                raise_ex=True,                    # type: bool\n                strict_foreign_properties=False,  # type: bool\n                logger=_logger,                   # type: logging.Logger\n                skip_foreign_properties=False     # type: bool\n                ):\n    # type: (...) -> bool\n    \"\"\"Determine if a python datum is an instance of a schema.\"\"\"\n\n    if not identifiers:\n        identifiers = []\n\n    if not foreign_properties:\n        foreign_properties = set()\n\n    schema_type = expected_schema.type\n\n    if schema_type == 'null':\n        if datum is None:\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"the value is not null\")\n            else:\n                return False\n    elif schema_type == 'boolean':\n        if isinstance(datum, bool):\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"the value is not boolean\")\n            else:\n                return False\n    elif schema_type == 'string':\n        if isinstance(datum, six.string_types):\n            return True\n        elif isinstance(datum, bytes):\n            datum = datum.decode(u\"utf-8\")\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"the value is not string\")\n            else:\n                return False\n    elif schema_type == 'int':\n        if (isinstance(datum, six.integer_types)\n                and INT_MIN_VALUE <= datum <= INT_MAX_VALUE):\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"`%s` is not int\" % vpformat(datum))\n            else:\n                return False\n    elif schema_type == 'long':\n        if ((isinstance(datum, six.integer_types))\n                and LONG_MIN_VALUE <= datum <= LONG_MAX_VALUE):\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(\n                    u\"the value `%s` is not long\" % vpformat(datum))\n            else:\n                return False\n    elif schema_type in ['float', 'double']:\n        if (isinstance(datum, six.integer_types)\n                or isinstance(datum, float)):\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(\n                    u\"the value `%s` is not float or double\" % vpformat(datum))\n            else:\n                return False\n    elif isinstance(expected_schema, avro.schema.EnumSchema):\n        if expected_schema.name == \"Any\":\n            if datum is not None:\n                return True\n            else:\n                if raise_ex:\n                    raise ValidationException(u\"'Any' type must be non-null\")\n                else:\n                    return False\n        if not isinstance(datum, six.string_types):\n            if raise_ex:\n                raise ValidationException(\n                    u\"value is a %s but expected a string\" % (type(datum).__name__))\n            else:\n                return False\n        if expected_schema.name == \"Expression\":\n            if \"$(\" in datum or \"${\" in datum:\n                return True\n            if raise_ex:\n                raise ValidationException(u\"value `%s` does not contain an expression in the form $() or ${}\" % datum)\n            else:\n                return False\n        if datum in expected_schema.symbols:\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"the value %s is not a valid %s, expected %s%s\" % (vpformat(datum), expected_schema.name,\n                                                                                              \"one of \" if len(\n                                                                                                  expected_schema.symbols) > 1 else \"\",\n                                                                                              \"'\" + \"', '\".join(expected_schema.symbols) + \"'\"))\n            else:\n                return False\n    elif isinstance(expected_schema, avro.schema.ArraySchema):\n        if isinstance(datum, MutableSequence):\n            for i, d in enumerate(datum):\n                try:\n                    sl = SourceLine(datum, i, ValidationException)\n                    if not validate_ex(expected_schema.items, d, identifiers,\n                                       strict=strict,\n                                       foreign_properties=foreign_properties,\n                                       raise_ex=raise_ex,\n                                       strict_foreign_properties=strict_foreign_properties,\n                                       logger=logger,\n                                       skip_foreign_properties=skip_foreign_properties):\n                        return False\n                except ValidationException as v:\n                    if raise_ex:\n                        raise sl.makeError(\n                            six.text_type(\"item is invalid because\\n%s\" % (indent(str(v)))))\n                    else:\n                        return False\n            return True\n        else:\n            if raise_ex:\n                raise ValidationException(u\"the value %s is not a list, expected list of %s\" % (\n                    vpformat(datum), friendly(expected_schema.items)))\n            else:\n                return False\n    elif isinstance(expected_schema, avro.schema.UnionSchema):\n        for s in expected_schema.schemas:\n            if validate_ex(s, datum, identifiers, strict=strict, raise_ex=False,\n                           strict_foreign_properties=strict_foreign_properties,\n                           logger=logger, skip_foreign_properties=skip_foreign_properties):\n                return True\n\n        if not raise_ex:\n            return False\n\n        errors = []  # type: List[Text]\n        checked = []\n        for s in expected_schema.schemas:\n            if isinstance(datum, MutableSequence) and not isinstance(s, avro.schema.ArraySchema):\n                continue\n            elif isinstance(datum, MutableMapping) and not isinstance(s, avro.schema.RecordSchema):\n                continue\n            elif (isinstance(  # type: ignore\n                    datum, (bool, six.integer_types, float, six.string_types))\n                    and isinstance(s, (avro.schema.ArraySchema,\n                                       avro.schema.RecordSchema))):\n                continue\n            elif datum is not None and s.type == \"null\":\n                continue\n\n            checked.append(s)\n            try:\n                validate_ex(s, datum, identifiers, strict=strict,\n                            foreign_properties=foreign_properties,\n                            raise_ex=True,\n                            strict_foreign_properties=strict_foreign_properties,\n                            logger=logger, skip_foreign_properties=skip_foreign_properties)\n            except ClassValidationException as e:\n                raise\n            except ValidationException as e:\n                errors.append(six.text_type(e))\n        if bool(errors):\n            raise ValidationException(bullets([\"tried %s but\\n%s\" % (friendly(\n                checked[i]), indent(errors[i])) for i in range(0, len(errors))], \"- \"))\n        else:\n            raise ValidationException(\"value is a %s, expected %s\" % (\n                type(datum).__name__, friendly(expected_schema)))\n\n    elif isinstance(expected_schema, avro.schema.RecordSchema):\n        if not isinstance(datum, MutableMapping):\n            if raise_ex:\n                raise ValidationException(u\"is not a dict\")\n            else:\n                return False\n\n        classmatch = None\n        for f in expected_schema.fields:\n            if f.name in (\"class\",):\n                d = datum.get(f.name)\n                if not d:\n                    if raise_ex:\n                        raise ValidationException(\n                            u\"Missing '%s' field\" % (f.name))\n                    else:\n                        return False\n                if expected_schema.name != d:\n                    if raise_ex:\n                        raise ValidationException(\n                            u\"Expected class '%s' but this is '%s'\" % (expected_schema.name, d))\n                    else:\n                        return False\n                classmatch = d\n                break\n\n        errors = []\n        for f in expected_schema.fields:\n            if f.name in (\"class\",):\n                continue\n\n            if f.name in datum:\n                fieldval = datum[f.name]\n            else:\n                try:\n                    fieldval = f.default\n                except KeyError:\n                    fieldval = None\n\n            try:\n                sl = SourceLine(datum, f.name, six.text_type)\n                if not validate_ex(f.type, fieldval, identifiers, strict=strict,\n                                   foreign_properties=foreign_properties,\n                                   raise_ex=raise_ex,\n                                   strict_foreign_properties=strict_foreign_properties,\n                                   logger=logger, skip_foreign_properties=skip_foreign_properties):\n                    return False\n            except ValidationException as v:\n                if f.name not in datum:\n                    errors.append(u\"missing required field `%s`\" % f.name)\n                else:\n                    errors.append(sl.makeError(u\"the `%s` field is not valid because\\n%s\" % (\n                        f.name, indent(str(v)))))\n\n        for d in datum:\n            found = False\n            for f in expected_schema.fields:\n                if d == f.name:\n                    found = True\n            if not found:\n                sl = SourceLine(datum, d, six.text_type)\n                if d not in identifiers and d not in foreign_properties and d[0] not in (\"@\", \"$\"):\n                    if (d not in identifiers and strict) and (\n                            d not in foreign_properties and strict_foreign_properties and not skip_foreign_properties) and not raise_ex:\n                        return False\n                    split = urllib.parse.urlsplit(d)\n                    if split.scheme:\n                        if not skip_foreign_properties:\n                            err = sl.makeError(u\"unrecognized extension field `%s`%s.%s\"\n                                               % (d,\n                                                  \" and strict_foreign_properties checking is enabled\"\n                                                  if strict_foreign_properties else \"\",\n                                                  \"\\nForeign properties from $schemas:\\n  %s\" % \"\\n  \".join(sorted(foreign_properties))\n                                                  if len(foreign_properties) > 0 else \"\"))\n                            if strict_foreign_properties:\n                                errors.append(err)\n                            elif len(foreign_properties) > 0:\n                                logger.warning(strip_dup_lineno(err))\n                    else:\n                        err = sl.makeError(u\"invalid field `%s`, expected one of: %s\" % (\n                            d, \", \".join(\"'%s'\" % fn.name for fn in expected_schema.fields)))\n                        if strict:\n                            errors.append(err)\n                        else:\n                            logger.warning(err)\n\n        if bool(errors):\n            if raise_ex:\n                if classmatch:\n                    raise ClassValidationException(bullets(errors, \"* \"))\n                else:\n                    raise ValidationException(bullets(errors, \"* \"))\n            else:\n                return False\n        else:\n            return True\n    if raise_ex:\n        raise ValidationException(u\"Unrecognized schema_type %s\" % schema_type)\n    else:\n        return False", "response": "Validate a python datum against a schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json_dump(obj,       # type: Any\n              fp,        # type: IO[str]\n              **kwargs   # type: Any\n             ):  # type: (...) -> None\n    \"\"\" Force use of unicode. \"\"\"\n    if six.PY2:\n        kwargs['encoding'] = 'utf-8'\n    json.dump(convert_to_dict(obj), fp, **kwargs)", "response": "Dump a dictionary to a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserialize a dictionary into JSON.", "response": "def json_dumps(obj,       # type: Any\n               **kwargs   # type: Any\n              ):  # type: (...) -> str\n    \"\"\" Force use of unicode. \"\"\"\n    if six.PY2:\n        kwargs['encoding'] = 'utf-8'\n    return json.dumps(convert_to_dict(obj), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate classes with loaders for the given schema salad description.", "response": "def codegen(lang,             # type: str\n            i,                # type: List[Dict[Text, Any]]\n            schema_metadata,  # type: Dict[Text, Any]\n            loader            # type: Loader\n           ):  # type: (...) -> None\n    \"\"\"Generate classes with loaders for the given Schema Salad description.\"\"\"\n\n    j = schema.extend_and_specialize(i, loader)\n\n    gen = None  # type: Optional[CodeGenBase]\n    if lang == \"python\":\n        gen = PythonCodeGen(sys.stdout)\n    elif lang == \"java\":\n        gen = JavaCodeGen(schema_metadata.get(\"$base\", schema_metadata.get(\"id\")))\n    else:\n        raise Exception(\"Unsupported code generation language '%s'\" % lang)\n    assert gen is not None\n\n    gen.prologue()\n\n    document_roots = []\n\n    for rec in j:\n        if rec[\"type\"] in (\"enum\", \"record\"):\n            gen.type_loader(rec)\n            gen.add_vocab(shortname(rec[\"name\"]), rec[\"name\"])\n\n    for rec in j:\n        if rec[\"type\"] == \"enum\":\n            for symbol in rec[\"symbols\"]:\n                gen.add_vocab(shortname(symbol), symbol)\n\n        if rec[\"type\"] == \"record\":\n            if rec.get(\"documentRoot\"):\n                document_roots.append(rec[\"name\"])\n\n            field_names = []\n            for field in rec.get(\"fields\", []):\n                field_names.append(shortname(field[\"name\"]))\n\n            idfield = \"\"\n            for field in rec.get(\"fields\", []):\n                if field.get(\"jsonldPredicate\") == \"@id\":\n                    idfield = field.get(\"name\")\n\n            gen.begin_class(rec[\"name\"], aslist(rec.get(\"extends\", [])), rec.get(\"doc\", \"\"),\n                            rec.get(\"abstract\", False), field_names, idfield)\n            gen.add_vocab(shortname(rec[\"name\"]), rec[\"name\"])\n\n            for field in rec.get(\"fields\", []):\n                if field.get(\"jsonldPredicate\") == \"@id\":\n                    fieldpred = field[\"name\"]\n                    optional = bool(\"https://w3id.org/cwl/salad#null\" in field[\"type\"])\n                    uri_loader = gen.uri_loader(gen.type_loader(field[\"type\"]), True, False, None)\n                    gen.declare_id_field(fieldpred, uri_loader, field.get(\"doc\"), optional)\n                    break\n\n            for field in rec.get(\"fields\", []):\n                optional = bool(\"https://w3id.org/cwl/salad#null\" in field[\"type\"])\n                type_loader = gen.type_loader(field[\"type\"])\n                jld = field.get(\"jsonldPredicate\")\n                fieldpred = field[\"name\"]\n                if isinstance(jld, MutableMapping):\n                    ref_scope = jld.get(\"refScope\")\n\n                    if jld.get(\"typeDSL\"):\n                        type_loader = gen.typedsl_loader(type_loader, ref_scope)\n                    elif jld.get(\"_type\") == \"@id\":\n                        type_loader = gen.uri_loader(type_loader, jld.get(\"identity\", False),\n                                                     False, ref_scope)\n                    elif jld.get(\"_type\") == \"@vocab\":\n                        type_loader = gen.uri_loader(type_loader, False, True, ref_scope)\n\n                    map_subject = jld.get(\"mapSubject\")\n                    if map_subject:\n                        type_loader = gen.idmap_loader(\n                            field[\"name\"], type_loader, map_subject, jld.get(\"mapPredicate\"))\n\n                    if \"_id\" in jld and jld[\"_id\"][0] != \"@\":\n                        fieldpred = jld[\"_id\"]\n\n                if jld == \"@id\":\n                    continue\n\n                gen.declare_field(fieldpred, type_loader, field.get(\"doc\"), optional)\n\n            gen.end_class(rec[\"name\"], field_names)\n\n    root_type = list(document_roots)\n    root_type.append({\n        \"type\": \"array\",\n        \"items\": document_roots\n    })\n\n    gen.epilogue(gen.type_loader(root_type))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of VM that match the pattern name", "response": "def find(self, name):\n        \"\"\"\n        Return a list of subset of VM that match the pattern name\n        @param name (str): the vm name of the virtual machine\n        @param name (Obj): the vm object that represent the virtual\n                           machine (can be Pro or Smart)\n        @return (list): the subset containing the serach result.\n        \"\"\"\n        if name.__class__ is 'base.Server.Pro' or name.__class__ is 'base.Server.Smart':\n            # print('DEBUG: matched VM object %s' % name.__class__)\n            pattern = name.vm_name\n        else:\n            # print('DEBUG: matched Str Object %s' % name.__class__)\n            pattern = name\n        # 14/06/2013: since this method is called within a thread and I wont to pass the return objects with queue or\n        # call back, I will allocate a list inside the Interface class object itself, which contain all of the vm found\n        # 02/11/2015: this must be changed ASAP! it's a mess this way... what was I thinking??\n        self.last_search_result = [vm for vm in self if pattern in vm.vm_name]\n        return self.last_search_result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login(self, username, password, load=True):\n        self.auth = Auth(username, password)\n        if load is True:\n            self.get_ip()\n            self.get_servers()", "response": "Login to the cloud and retrieve the ip list and the vm list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef poweroff_server(self, server=None, server_id=None):\n        sid = server_id if server_id is not None else server.sid\n        if sid is None:\n            raise Exception('No Server Specified.')\n        json_scheme = self.gen_def_json_scheme('SetEnqueueServerPowerOff', dict(ServerId=sid))\n        json_obj = self.call_method_post('SetEnqueueServerPowerOff', json_scheme=json_scheme)\n        return True if json_obj['Success'] is 'True' else False", "response": "Poweroff a VM. If possible to pass the VM object or simply the ID\n        of the VM that we want to turn on.\n        Args:\n            server: VM Object that represent the VM to power off,\n            server_id: Int or Str representing the ID of the VM to power off.\n        Returns:\n            return True if json_obj['Success'] is 'True' else False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_hypervisors(self):\n        json_scheme = self.gen_def_json_scheme('GetHypervisors')\n        json_obj = self.call_method_post(method='GetHypervisors', json_scheme=json_scheme)\n        self.json_templates = json_obj\n        d = dict(json_obj)\n        for elem in d['Value']:\n            hv = self.hypervisors[elem['HypervisorType']]\n            for inner_elem in elem['Templates']:\n                o = Template(hv)\n                o.template_id = inner_elem['Id']\n                o.descr = inner_elem['Description']\n                o.id_code = inner_elem['IdentificationCode']\n                o.name = inner_elem['Name']\n                o.enabled = inner_elem['Enabled']\n                if hv != 'SMART':\n                    for rb in inner_elem['ResourceBounds']:\n                        resource_type = rb['ResourceType']\n                        if resource_type == 1:\n                            o.resource_bounds.max_cpu = rb['Max']\n                        if resource_type == 2:\n                            o.resource_bounds.max_memory = rb['Max']\n                        if resource_type == 3:\n                            o.resource_bounds.hdd0 = rb['Max']\n                        if resource_type == 7:\n                            o.resource_bounds.hdd1 = rb['Max']\n                        if resource_type == 8:\n                            o.resource_bounds.hdd2 = rb['Max']\n                        if resource_type == 9:\n                            o.resource_bounds.hdd3 = rb['Max']\n                self.templates.append(o)\n        return True if json_obj['Success'] is 'True' else False", "response": "Initialize the internal list containing each template available for each hypervisor."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the list of servers inside the Datacenter objects.", "response": "def get_servers(self):\n        \"\"\"\n        Create the list of Server object inside the Datacenter objects.\n        Build an internal list of VM Objects (pro or smart) as iterator.\n        :return: bool\n        \"\"\"\n        json_scheme = self.gen_def_json_scheme('GetServers')\n        json_obj = self.call_method_post(method='GetServers', json_scheme=json_scheme)\n        self.json_servers = json_obj\n        # if this method is called I assume that i must re-read the data\n        # so i reinitialize the vmlist\n        self.vmlist = VMList()\n        # getting all instanced IP in case the list is empty\n        if len(self.iplist) <= 0:\n            self.get_ip()\n        for elem in dict(json_obj)[\"Value\"]:\n            if elem['HypervisorType'] is 4:\n                s = Smart(interface=self, sid=elem['ServerId'])\n            else:\n                s = Pro(interface=self, sid=elem['ServerId'])\n            s.vm_name = elem['Name']\n            s.cpu_qty = elem['CPUQuantity']\n            s.ram_qty = elem['RAMQuantity']\n            s.status = elem['ServerStatus']\n            s.datacenter_id = elem['DatacenterId']\n            s.wcf_baseurl = self.wcf_baseurl\n            s.auth = self.auth\n            s.hd_qty = elem['HDQuantity']\n            s.hd_total_size = elem['HDTotalSize']\n            if elem['HypervisorType'] is 4:\n                ssd = self.get_server_detail(elem['ServerId'])\n                try:\n                    s.ip_addr = str(ssd['EasyCloudIPAddress']['Value'])\n                except TypeError:\n                    s.ip_addr = 'Not retrieved.'\n            else:\n                s.ip_addr = []\n                for ip in self.iplist:\n                    if ip.serverid == s.sid:\n                        s.ip_addr.append(ip)\n            self.vmlist.append(s)\n        return True if json_obj['Success'] is True else False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of templates that could have one or more elements.", "response": "def find_template(self, name=None, hv=None):\n        \"\"\"\n        Return a list of templates that could have one or more elements.\n        Args:\n            name: name of the template to find.\n            hv: the ID of the hypervisor to search the template in\n        Returns:\n            A list of templates object. If hv is None will return all the\n            templates matching the name if every hypervisor type. Otherwise\n            if name is None will return all templates of an hypervisor.\n        Raises:\n            ValidationError: if name and hv are None\n        \"\"\"\n        if len(self.templates) <= 0:\n            self.get_hypervisors()\n        if name is not None and hv is not None:\n            template_list = filter(\n                lambda x: name in x.descr and x.hypervisor == self.hypervisors[hv], self.templates\n            )\n        elif name is not None and hv is None:\n            template_list = filter(\n                lambda x: name in x.descr, self.templates\n            )\n        elif name is None and hv is not None:\n            template_list = filter(\n                lambda x: x.hypervisor == self.hypervisors[hv], self.templates\n            )\n        else:\n            raise Exception('Error, no pattern defined')\n        if  sys.version_info.major < (3):\n            return template_list\n        else:\n            return(list(template_list))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an ip object representing a new bought IP", "response": "def purchase_ip(self, debug=False):\n        \"\"\"\n        Return an ip object representing a new bought IP\n        @param debug [Boolean] if true, request and response will be printed\n        @return (Ip): Ip object\n        \"\"\"\n        json_scheme = self.gen_def_json_scheme('SetPurchaseIpAddress')\n        json_obj = self.call_method_post(method='SetPurchaseIpAddress', json_scheme=json_scheme, debug=debug)\n        try:\n            ip = Ip()\n            ip.ip_addr = json_obj['Value']['Value']\n            ip.resid = json_obj['Value']['ResourceId']\n            return ip\n        except:\n            raise Exception('Unknown error retrieving IP.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npurchases a new VLAN. :param debug: Log the json response if True :param vlan_name: String representing the name of the vlan (virtual switch) :return: a Vlan Object representing the vlan created", "response": "def purchase_vlan(self, vlan_name, debug=False):\n        \"\"\"\n        Purchase a new VLAN.\n        :param debug: Log the json response if True\n        :param vlan_name: String representing the name of the vlan (virtual switch)\n        :return: a Vlan Object representing the vlan created\n        \"\"\"\n        vlan_name = {'VLanName': vlan_name}\n        json_scheme = self.gen_def_json_scheme('SetPurchaseVLan', vlan_name)\n        json_obj = self.call_method_post(method=\"SetPurchaseVLan\", json_scheme=json_scheme)\n        if debug is True:\n            self.logger.debug(json_obj)\n        if json_obj['Success'] is False:\n            raise Exception(\"Cannot purchase new vlan.\")\n        vlan = Vlan()\n        vlan.name = json_obj['Value']['Name']\n        vlan.resource_id = json_obj['Value']['ResourceId']\n        vlan.vlan_code = json_obj['Value']['VlanCode']\n        return vlan"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_vlan(self, vlan_resource_id):\n        vlan_id = {'VLanResourceId': vlan_resource_id}\n        json_scheme = self.gen_def_json_scheme('SetRemoveVLan', vlan_id)\n        json_obj = self.call_method_post(method='SetRemoveVLan', json_scheme=json_scheme)\n        return True if json_obj['Success'] is True else False", "response": "Remove a VLAN from a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_ip(self, ip_id):\n        ip_id = '    \"IpAddressResourceId\": %s' % ip_id\n        json_scheme = self.gen_def_json_scheme('SetRemoveIpAddress', ip_id)\n        json_obj = self.call_method_post(method='SetRemoveIpAddress', json_scheme=json_scheme)\n        pprint(json_obj)\n        return True if json_obj['Success'] is True else False", "response": "Delete an Ip from the boughs ip list\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve the smart package id given is English name", "response": "def get_package_id(self, name):\n        \"\"\"\n        Retrieve the smart package id given is English name\n        @param (str) name: the Aruba Smart package size name, ie: \"small\", \"medium\", \"large\", \"extra large\".\n        @return: The package id that depends on the Data center and the size choosen.\n        \"\"\"\n        json_scheme = self.gen_def_json_scheme('GetPreConfiguredPackages', dict(HypervisorType=4))\n        json_obj = self.call_method_post(method='GetPreConfiguredPackages ', json_scheme=json_scheme)\n        for package in json_obj['Value']:\n            packageId  = package['PackageID']\n            for description in package['Descriptions']:\n                languageID = description['LanguageID']\n                packageName = description['Text']\n                if languageID == 2 and packageName.lower() == name.lower():\n                    return packageId"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a complete list of bought ip address related only to PRO Servers.", "response": "def get_ip(self):\n        \"\"\"\n        Retrieve a complete list of bought ip address related only to PRO Servers.\n        It create an internal object (Iplist) representing all of the ips object\n        iterated form the WS.\n        @param: None\n        @return: None\n        \"\"\"\n        json_scheme = self.gen_def_json_scheme('GetPurchasedIpAddresses')\n        json_obj = self.call_method_post(method='GetPurchasedIpAddresses ', json_scheme=json_scheme)\n        self.iplist = IpList()\n        for ip in json_obj['Value']:\n            r = Ip()\n            r.ip_addr = ip['Value']\n            r.resid = ip['ResourceId']\n            r.serverid = ip['ServerId'] if 'None' not in str(ip['ServerId']) else None\n            self.iplist.append(r)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the json scheme for the request.", "response": "def gen_def_json_scheme(self, req, method_fields=None):\n        \"\"\"\n        Generate the scheme for the json request.\n        :param req: String representing the name of the method to call\n        :param method_fields: A dictionary containing the method-specified fields\n        :rtype : json object representing the method call\n        \"\"\"\n        json_dict = dict(\n            ApplicationId=req,\n            RequestId=req,\n            SessionId=req,\n            Password=self.auth.password,\n            Username=self.auth.username\n        )\n        if method_fields is not None:\n            json_dict.update(method_fields)\n        self.logger.debug(json.dumps(json_dict))\n        return json.dumps(json_dict)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _commit(self):\n        assert self.uri is not None, Exception(\"BadArgument: uri property cannot be None\")\n        url = '{}/{}'.format(self.uri, self.__class__.__name__)\n        serialized_json = jsonpickle.encode(self, unpicklable=False, )\n        headers = {'Content-Type': 'application/json', 'Content-Length': str(len(serialized_json))}\n        response = Http.post(url=url, data=serialized_json, headers=headers)\n        if response.status_code != 200:\n            from ArubaCloud.base.Errors import MalformedJsonRequest\n            raise MalformedJsonRequest(\"Request: {}, Status Code: {}\".format(serialized_json, response.status_code))\n        content = jsonpickle.decode(response.content.decode(\"utf-8\"))\n        if content['ResultCode'] == 17:\n            from ArubaCloud.base.Errors import OperationAlreadyEnqueued\n            raise OperationAlreadyEnqueued(\"{} already enqueued\".format(self.__class__.__name__))\n        if content['Success'] is False:\n            from ArubaCloud.base.Errors import RequestFailed\n            raise RequestFailed(\"Request: {}, Response: {}\".format(serialized_json, response.content))\n        return content", "response": "Commits the object to Aruba Cloud."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the current configured SharedStorages entries", "response": "def get(self):\n        \"\"\"\n        Retrieve the current configured SharedStorages entries\n        :return: [list] List containing the current SharedStorages entries\n        \"\"\"\n        request = self._call(GetSharedStorages)\n        response = request.commit()\n        return response['Value']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npurchase an ISCSI resource from the specified set of IQNs.", "response": "def purchase_iscsi(self, quantity, iqn, name, protocol=SharedStorageProtocolType.ISCSI):\n        \"\"\"\n        :type quantity: int\n        :type iqn: list[str]\n        :type name: str\n        :type protocol: SharedStorageProtocols\n        :param quantity: Amount of GB\n        :param iqn: List of IQN represented in string format\n        :param name: Name of the resource\n        :param protocol: Protocol to use\n        :return:\n        \"\"\"\n        iqns = []\n        for _iqn in iqn:\n            iqns.append(SharedStorageIQN(Value=_iqn))\n        request = self._call(SetEnqueuePurchaseSharedStorage, Quantity=quantity, SharedStorageName=name,\n                             SharedStorageIQNs=iqns, SharedStorageProtocolType=protocol)\n        response = request.commit()\n        return response['Value']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get(self, *args, **kwargs):\n\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = self.timeout\n\n        req = self.session.get(*args, **kwargs)\n        return req", "response": "Wrapper around Requests for GET requests\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps around Requests for GET XML requests A Requests object", "response": "def _get_xml(self, *args, **kwargs):\n        \"\"\"Wrapper around Requests for GET XML requests\n\n        Returns:\n            Response:\n                A Requests Response object\n        \"\"\"\n        req = self.session_xml.get(*args, **kwargs)\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping around Requests for POST requests = > n.", "response": "def _post(self, *args, **kwargs):\n        \"\"\"Wrapper around Requests for POST requests\n\n        Returns:\n            Response:\n                A Requests Response object\n        \"\"\"\n\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = self.timeout\n\n        req = self.session.post(*args, **kwargs)\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _post_xml(self, *args, **kwargs):\n\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = self.timeout\n\n        req = self.session_xml.post(*args, **kwargs)\n        return req", "response": "Wrapper around Requests for POST requests\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _put(self, *args, **kwargs):\n\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = self.timeout\n\n        req = self.session.put(*args, **kwargs)\n        return req", "response": "Wrapper around Requests for PUT requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps around Requests for DELETE requests", "response": "def _delete(self, *args, **kwargs):\n        \"\"\"Wrapper around Requests for DELETE requests\n\n        Returns:\n            Response:\n                A Requests Response object\n        \"\"\"\n\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = self.timeout\n\n        req = self.session.delete(*args, **kwargs)\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auth_ping(self):\n\n        url = self.rest_url + \"/non-existent/location\"\n        response = self._get(url)\n\n        if response.status_code == 401:\n            return False\n        elif response.status_code == 404:\n            return True\n        else:\n            # An error encountered - problem with the Crowd server?\n            return False", "response": "Test that the application can authenticate to Crowd."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nauthenticating a user against the Crowd server.", "response": "def auth_user(self, username, password):\n        \"\"\"Authenticate a user account against the Crowd server.\n\n        Attempts to authenticate the user against the Crowd server.\n\n        Args:\n            username: The account username.\n\n            password: The account password.\n\n        Returns:\n            dict:\n                A dict mapping of user attributes if the application\n                authentication was successful. See the Crowd documentation\n                for the authoritative list of attributes.\n\n            None: If authentication failed.\n        \"\"\"\n\n        response = self._post(self.rest_url + \"/authentication\",\n                              data=json.dumps({\"value\": password}),\n                              params={\"username\": username})\n\n        # If authentication failed for any reason return None\n        if not response.ok:\n            return None\n\n        # ...otherwise return a dictionary of user attributes\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_session(self, username, password, remote=\"127.0.0.1\", proxy=None):\n\n        params = {\n            \"username\": username,\n            \"password\": password,\n            \"validation-factors\": {\n                \"validationFactors\": [\n                    {\"name\": \"remote_address\", \"value\": remote, },\n                ]\n            }\n        }\n\n        if proxy:\n            params[\"validation-factors\"][\"validationFactors\"].append({\"name\": \"X-Forwarded-For\", \"value\": proxy, })\n\n        response = self._post(self.rest_url + \"/session\",\n                              data=json.dumps(params),\n                              params={\"expand\": \"user\"})\n\n        # If authentication failed for any reason return None\n        if not response.ok:\n            return None\n\n        # Otherwise return the user object\n        return response.json()", "response": "Creates a user session on the Crowd server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_session(self, token, remote=\"127.0.0.1\", proxy=None):\n\n        params = {\n            \"validationFactors\": [\n                {\"name\": \"remote_address\", \"value\": remote, },\n            ]\n        }\n\n        if proxy:\n            params[\"validation-factors\"][\"validationFactors\"].append({\"name\": \"X-Forwarded-For\", \"value\": proxy, })\n\n        url = self.rest_url + \"/session/%s\" % token\n        response = self._post(url, data=json.dumps(params), params={\"expand\": \"user\"})\n\n        # For consistency between methods use None rather than False\n        # If token validation failed for any reason return None\n        if not response.ok:\n            return None\n\n        # Otherwise return the user object\n        return response.json()", "response": "Validate a previously acquired session token against the Crowd server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nterminate the user with the specified token.", "response": "def terminate_session(self, token):\n        \"\"\"Terminates the session token, effectively logging out the user\n        from all crowd-enabled services.\n\n        Args:\n            token: The session token.\n\n        Returns:\n            True: If session terminated\n\n            None: If session termination failed\n        \"\"\"\n\n        url = self.rest_url + \"/session/%s\" % token\n        response = self._delete(url)\n\n        # For consistency between methods use None rather than False\n        # If token validation failed for any reason return None\n        if not response.ok:\n            return None\n\n        # Otherwise return True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a user to the directory.", "response": "def add_user(self, username, raise_on_error=False, **kwargs):\n        \"\"\"Add a user to the directory\n\n        Args:\n            username: The account username\n            raise_on_error: optional (default: False)\n            **kwargs: key-value pairs:\n                          password: mandatory\n                          email: mandatory\n                          first_name: optional\n                          last_name: optional\n                          display_name: optional\n                          active: optional (default True)\n\n        Returns:\n            True: Succeeded\n            False: If unsuccessful\n        \"\"\"\n        # Check that mandatory elements have been provided\n        if 'password' not in kwargs:\n            raise ValueError(\"missing password\")\n        if 'email' not in kwargs:\n            raise ValueError(\"missing email\")\n\n        # Populate data with default and mandatory values.\n        # A KeyError means a mandatory value was not provided,\n        # so raise a ValueError indicating bad args.\n        try:\n            data = {\n                    \"name\": username,\n                    \"first-name\": username,\n                    \"last-name\": username,\n                    \"display-name\": username,\n                    \"email\": kwargs[\"email\"],\n                    \"password\": {\"value\": kwargs[\"password\"]},\n                    \"active\": True\n                   }\n        except KeyError:\n            return ValueError\n\n        # Remove special case 'password'\n        del(kwargs[\"password\"])\n\n        # Put values from kwargs into data\n        for k, v in kwargs.items():\n            new_k = k.replace(\"_\", \"-\")\n            if new_k not in data:\n                raise ValueError(\"invalid argument %s\" % k)\n            data[new_k] = v\n\n        response = self._post(self.rest_url + \"/user\",\n                              data=json.dumps(data))\n\n        if response.status_code == 201:\n            return True\n\n        if raise_on_error:\n            raise RuntimeError(response.json()['message'])\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user(self, username):\n\n        response = self._get(self.rest_url + \"/user\",\n                             params={\"username\": username,\n                                     \"expand\": \"attributes\"})\n\n        if not response.ok:\n            return None\n\n        return response.json()", "response": "Retrieve information about a user"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the active state of a user", "response": "def set_active(self, username, active_state):\n        \"\"\"Set the active state of a user\n\n        Args:\n            username: The account username\n            active_state: True or False\n\n        Returns:\n            True: If successful\n            None: If no user or failure occurred\n        \"\"\"\n\n        if active_state not in (True, False):\n            raise ValueError(\"active_state must be True or False\")\n\n        user = self.get_user(username)\n        if user is None:\n            return None\n\n        if user['active'] is active_state:\n            # Already in desired state\n            return True\n\n        user['active'] = active_state\n        response = self._put(self.rest_url + \"/user\",\n                             params={\"username\": username},\n                             data=json.dumps(user))\n\n        if response.status_code == 204:\n            return True\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_user_attribute(self, username, attribute, value, raise_on_error=False):\n        data = {\n            'attributes': [\n                {\n                    'name': attribute,\n                    'values': [\n                        value\n                    ]\n                },\n            ]\n        }\n        response = self._post(self.rest_url + \"/user/attribute\",\n                              params={\"username\": username,},\n                              data=json.dumps(data))\n\n        if response.status_code == 204:\n            return True\n\n        if raise_on_error:\n            raise RuntimeError(response.json()['message'])\n\n        return False", "response": "Set an attribute on a user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_user_to_group(self, username, groupname, raise_on_error=False):\n        data = {\n                'name': groupname,\n        }\n        response = self._post(self.rest_url + \"/user/group/direct\",\n                              params={\"username\": username,},\n                              data=json.dumps(data))\n\n        if response.status_code == 201:\n            return True\n\n        if raise_on_error:\n            raise RuntimeError(response.json()['message'])\n\n        return False", "response": "Add a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_user_from_group(self, username, groupname, raise_on_error=False):\n\n        response = self._delete(self.rest_url + \"/group/user/direct\",params={\"username\": username, \"groupname\": groupname})\n\n        if response.status_code == 204:\n            return True\n\n        if raise_on_error:\n            raise RuntimeError(response.json()['message'])\n\n        return False", "response": "Remove a user from a group."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nchange the password for a user.", "response": "def change_password(self, username, newpassword, raise_on_error=False):\n        \"\"\"Change new password for a user\n\n        Args:\n            username: The account username.\n\n            newpassword: The account new password.\n\n            raise_on_error: optional (default: False)\n\n        Returns:\n            True: Succeeded\n            False: If unsuccessful\n        \"\"\"\n\n        response = self._put(self.rest_url + \"/user/password\",\n                             data=json.dumps({\"value\": newpassword}),\n                             params={\"username\": username})\n\n        if response.ok:\n            return True\n\n        if raise_on_error:\n            raise RuntimeError(response.json()['message'])\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend the user a password reset link", "response": "def send_password_reset_link(self, username):\n        \"\"\"Sends the user a password reset link (by email)\n\n        Args:\n            username: The account username.\n\n        Returns:\n            True: Succeeded\n            False: If unsuccessful\n        \"\"\"\n\n        response = self._post(self.rest_url + \"/user/mail/password\",\n                              params={\"username\": username})\n\n        if response.ok:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nested_groups(self, username):\n\n        response = self._get(self.rest_url + \"/user/group/nested\",\n                             params={\"username\": username})\n\n        if not response.ok:\n            return None\n\n        return [g['name'] for g in response.json()['groups']]", "response": "Retrieve a list of all group names that have a direct or indirect member."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nested_group_users(self, groupname):\n\n        response = self._get(self.rest_url + \"/group/user/nested\",\n                             params={\"groupname\": groupname,\n                                     \"start-index\": 0,\n                                     \"max-results\": 99999})\n\n        if not response.ok:\n            return None\n\n        return [u['name'] for u in response.json()['users']]", "response": "Retrieves a list of all users that directly or indirectly belong to the given groupname."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_exists(self, username):\n\n        response = self._get(self.rest_url + \"/user\",\n                             params={\"username\": username})\n\n        if not response.ok:\n            return None\n\n        return True", "response": "Determines if the user exists in the Crowd application."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_memberships(self):\n\n        response = self._get_xml(self.rest_url + \"/group/membership\")\n\n        if not response.ok:\n            return None\n\n        xmltree = etree.fromstring(response.content)\n        memberships = {}\n        for mg in xmltree.findall('membership'):\n            # coerce values to unicode in a python 2 and 3 compatible way\n            group = u'{}'.format(mg.get('group'))\n            users = [u'{}'.format(u.get('name')) for u in mg.find('users').findall('user')]\n            groups = [u'{}'.format(g.get('name')) for g in mg.find('groups').findall('group')]\n            memberships[group] = {u'users': users, u'groups': groups}\n        return memberships", "response": "Fetches all group memberships.\n        returns None if the request failed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming a user search using the Crowd search API.", "response": "def search(self, entity_type, property_name, search_string, start_index=0, max_results=99999):\n        \"\"\"Performs a user search using the Crowd search API.\n\n        https://developer.atlassian.com/display/CROWDDEV/Crowd+REST+Resources#CrowdRESTResources-SearchResource\n\n        Args:\n            entity_type: 'user' or 'group'\n            property_name: eg. 'email', 'name'\n            search_string: the string to search for.\n            start_index: starting index of the results (default: 0)\n            max_results: maximum number of results returned (default: 99999)\n\n        Returns:\n            json results:\n                Returns search results.\n        \"\"\"\n\n        params = {\n            \"entity-type\": entity_type,\n            \"expand\": entity_type,\n            \"property-search-restriction\": {\n                \"property\": {\"name\": property_name, \"type\": \"STRING\"},\n                \"match-mode\": \"CONTAINS\",\n                \"value\": search_string,\n            }\n        }\n\n        params = {\n            'entity-type': entity_type,\n            'expand': entity_type,\n            'start-index': start_index,\n            'max-results': max_results\n        }\n        # Construct XML payload of the form:\n        # <property-search-restriction>\n        #   <property>\n        #     <name>email</name>\n        #     <type>STRING</type>\n        #   </property>\n        #   <match-mode>EXACTLY_MATCHES</match-mode>\n        #   <value>bob@example.net</value>\n        # </property-search-restriction>\n\n        root = etree.Element('property-search-restriction')\n\n        property_ = etree.Element('property')\n        prop_name = etree.Element('name')\n        prop_name.text = property_name\n        property_.append(prop_name)\n        prop_type = etree.Element('type')\n        prop_type.text = 'STRING'\n        property_.append(prop_type)\n        root.append(property_)\n\n        match_mode = etree.Element('match-mode')\n        match_mode.text = 'CONTAINS'\n        root.append(match_mode)\n\n        value = etree.Element('value')\n        value.text = search_string\n        root.append(value)\n\n        # Construct the XML payload expected by search API\n        payload = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + etree.tostring(root).decode('utf-8')\n\n        # We're sending XML but would like a JSON response\n        session = self._build_session(content_type='xml')\n        session.headers.update({'Accept': 'application/json'})\n        response = session.post(self.rest_url + \"/search\", params=params, data=payload, timeout=self.timeout)\n\n        if not response.ok:\n            return None\n\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of all versions associated with this repository.", "response": "def versions(self) -> List(BlenderVersion):\n        \"\"\"\n        The versions associated with Blender\n        \"\"\"\n\n        return [BlenderVersion(tag) for tag in self.git_repo.tags] + [BlenderVersion(BLENDER_VERSION_MASTER)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncopy libraries from the bin directory and place them as appropriate", "response": "def run(self):\n        \"\"\"\n        Copy libraries from the bin directory and place them as appropriate\n        \"\"\"\n\n        self.announce(\"Moving library files\", level=3)\n\n        # We have already built the libraries in the previous build_ext step\n\n        self.skip_build = True\n\n        bin_dir = self.distribution.bin_dir\n\n        libs = [os.path.join(bin_dir, _lib) for _lib in \n                os.listdir(bin_dir) if \n                os.path.isfile(os.path.join(bin_dir, _lib)) and \n                os.path.splitext(_lib)[1] in [\".dll\", \".so\"]\n                and not (_lib.startswith(\"python\") or _lib.startswith(\"bpy\"))]\n\n        for lib in libs:\n\n            shutil.move(lib, os.path.join(self.build_dir,\n                                          os.path.basename(lib)))\n\n        # Mark the libs for installation, adding them to \n        # distribution.data_files seems to ensure that setuptools' record \n        # writer appends them to installed-files.txt in the package's egg-info\n        #\n        # Also tried adding the libraries to the distribution.libraries list, \n        # but that never seemed to add them to the installed-files.txt in the \n        # egg-info, and the online recommendation seems to be adding libraries \n        # into eager_resources in the call to setup(), which I think puts them \n        # in data_files anyways. \n        # \n        # What is the best way?\n\n        self.distribution.data_files = [os.path.join(self.install_dir, \n                                                     os.path.basename(lib))\n                                        for lib in libs]\n\n        # Must be forced to run after adding the libs to data_files\n\n        self.distribution.run_command(\"install_data\")\n\n        super().run()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n\n        self.announce(\"Moving scripts files\", level=3)\n\n        self.skip_build = True\n\n        bin_dir = self.distribution.bin_dir\n\n        scripts_dirs = [os.path.join(bin_dir, _dir) for _dir in\n                        os.listdir(bin_dir) if\n                        os.path.isdir(os.path.join(bin_dir, _dir))]\n\n        for scripts_dir in scripts_dirs:\n\n            dst_dir = os.path.join(self.build_dir,\n                                   os.path.basename(scripts_dir))\n\n            # Mostly in case of weird things happening during build\n            if os.path.exists(dst_dir):\n                \n                if os.path.isdir(dst_dir): \n\n                    shutil.rmtree(dst_dir)\n\n                elif os.path.isfile(dst_dir):\n\n                    os.remove(dst_dir)\n\n            shutil.move(scripts_dir,\n                        os.path.join(self.build_dir,\n                                     os.path.basename(scripts_dir)))\n\n        # Mark the scripts for installation, adding them to \n        # distribution.scripts seems to ensure that the setuptools' record \n        # writer appends them to installed-files.txt in the package's egg-info\n\n        self.distribution.scripts = scripts_dirs\n\n        super().run()", "response": "Copy the required directory to the build directory and build the setuptools record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming build_cmake before doing the normal stuff", "response": "def run(self):\n        \"\"\"\n        Perform build_cmake before doing the 'normal' stuff\n        \"\"\"\n\n        for extension in self.extensions:\n\n            if extension.name == \"bpy\":\n\n                self.build_cmake(extension)\n\n        super().run()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_cmake(self, extension: Extension):\n\n        # We import the setup_requires modules here because if we import them\n        # at the top this script will always fail as they won't be present\n\n        from git import Repo as GitRepo\n        from svn.remote import RemoteClient as SvnRepo\n\n        self.announce(\"Preparing the build environment\", level=3)\n\n        blender_dir = os.path.join(BLENDERPY_DIR, \"blender\")\n\n        build_dir = pathlib.Path(self.build_temp)\n\n        extension_path = pathlib.Path(self.get_ext_fullpath(extension.name))\n\n        os.makedirs(blender_dir, exist_ok=True)\n        os.makedirs(str(build_dir), exist_ok=True)\n        os.makedirs(str(extension_path.parent.absolute()), exist_ok=True)\n\n        # Now that the necessary directories are created, ensure that OS \n        # specific steps are performed; a good example is checking on linux \n        # that the required build libraries are in place.\n\n        os_build_args = []\n\n        # Have to find the correct release tag to checkout here, as potentially\n        # master may not be the correct one for this Python version. We use svn\n        # to find whether or not master, or a specific tag supports the \n        # current python version\n\n        if sys.platform == \"win32\": # Windows only steps\n\n            import winreg\n\n            vs_versions = []\n\n            for version in [12, 14, 15]:\n\n                try:\n\n                    winreg.OpenKey(winreg.HKEY_CLASSES_ROOT,\n                                   f\"VisualStudio.DTE.{version}.0\")\n\n                except:\n\n                    pass\n                    \n                else:\n\n                    vs_versions.append(version)\n\n            if not vs_versions:\n\n                raise Exception(\"Windows users must have Visual Studio 2013 \"\n                                \"or later installed\")\n\n            if max(vs_versions) == 15:\n\n                os_build_args += [\"-G\", f\"Visual Studio 15 2017\"\n                                        f\"{' Win64' if BITS == 64 else ''}\"]\n\n            elif max(vs_versions) == 14:\n\n                os_build_args += [\"-G\", f\"Visual Studio 14 2015\"\n                                        f\"{' Win64' if BITS == 64 else ''}\"]\n\n            elif max(vs_versions) == 12:\n\n                os_build_args += [\"-G\", f\"Visual Studio 12 2013\"\n                                        f\"{' Win64' if BITS == 64 else ''}\"]\n\n            # TODO: Clean up here\n\n            svn_lib_options += [f\"win{64 if BITS == 64 else 'dows'}_vc{version}\" \n                                for version in vs_versions]\n\n            blender_svn_repo = SvnRepo(svn_url)\n\n            os.makedirs(svn_dir, exist_ok=True)\n\n            self.announce(f\"Checking out svn libs from {svn_url}\", level=3)\n\n            try:\n                \n                blender_svn_repo.checkout(svn_dir)\n\n            except Exception as e:\n\n                self.warn(\"Windows users must have the svn executable \"\n                          \"available from the command line\")\n                self.warn(\"Please install Tortoise SVN with \\\"command line \"\n                          \"client tools\\\" as described here\")\n                self.warn(\"https://stackoverflow.com/questions/1625406/using-\"\n                          \"tortoisesvn-via-the-command-line\")\n                raise e\n\n        elif sys.platform == \"linux\": # Linux only steps\n\n            # TODO: Test linux environment, issue #1\n\n            pass\n\n        elif sys.platform == \"darwin\": # MacOS only steps\n\n            # TODO: Test MacOS environment, issue #2\n\n            pass\n\n        # Perform relatively common build steps\n\n        # TODO: if blender desired version, then see if we can install that\n        # Otherwise fail, if no desired version, find the latest version that\n        # supports our python and install that\n\n        git_repo = GitRepo(GIT_BASE_URL)\n        svn_repo = SvnRepo(SVN_BASE_URL)\n\n        if BLENDER_DESIRED_VERSION:\n\n            match = BLENDER_VERSION_REGEX.match(BLENDER_DESIRED_VERSION)\n\n            if match:\n\n                # We have a blender version that conforms to the naming scheme\n                # now to see if it actually exists in git and svn\n\n                if match.group(0) in git_repo.tags:\n\n                    # The version was tagged in the git repository\n                    # now, format the version to match the svn versioning \n                    # scheme...\n\n                    svn_version_tag = (f\"blender-{match.group(1)}\"\n                                       f\"{match.group(2) if not match.group(2).startswith(\"-rc\")}-release\")\n\n                    svn_tag_repo = SvnRepo(os.path.join(SVN_BASE_URL, SVN_TAGS))\n\n                    if svn_version_tag in svn_tag_repo.list():\n\n                        # The version was released in svn and we found it\n                        # Now, is it compatible with our OS and python version?\n\n                    else:\n\n                        raise Exception(f\"{BLENDER_DESIRED_VERSION} was found \"\n                                        f\"in the git repository but not the \"\n                                        f\"svn repository.\")\n\n                else:\n\n                    raise Exception(f\"The provided version \"\n                                    f\"{BLENDER_DESIRED_VERSION} does not \"\n                                    f\"exist; please check \"\n                                    f\"https://git.blender.org/gitweb/\"\n                                    f\"gitweb.cgi/blender.git/tags for a list \"\n                                    f\"of valid Blender releases\")\n\n            else:\n\n                # The blender version did not conform to the naming scheme\n                # fail and notify the user how to list the version\n\n                raise Exception(f\"The provided version \"\n                                f\"{BLENDER_DESIRED_VERSION} did not match \"\n                                f\"Blender's naming scheme. Please list your \"\n                                f\"desired version as 'v' followed by a digit, \"\n                                f\"followed by a period, followed by two \"\n                                f\"digits and either 'a', 'b', 'c' or '-rc' \"\n                                f\"(versions using '-rc' can optionally add \"\n                                f\"a number which specifies which release \"\n                                f\"candidate they want to install) such that \"\n                                f\"the version looks like the following: \"\n                                f\"v2.74-rc2\")\n\n        else:\n\n            if sys.version_info >= (3, 6):\n\n                # we can get from svn and git master branch\n\n            else:\n\n                # we must find a compatible version\n\n        self.announce(f\"Cloning Blender source from {BLENDER_GIT_REPO_URL}\",\n                      level=3)\n\n        try:\n\n            blender_git_repo = GitRepo(blender_dir)\n\n        except:\n\n            GitRepo.clone_from(BLENDER_GIT_REPO_URL, blender_dir)\n            blender_git_repo = GitRepo(blender_dir)\n\n        finally:\n                \n            blender_git_repo.heads.master.checkout()\n            blender_git_repo.remotes.origin.pull()\n\n        self.announce(f\"Updating Blender git submodules\", level=3)\n\n        blender_git_repo.git.submodule('update', '--init', '--recursive')\n\n        for submodule in blender_git_repo.submodules:\n                \n            submodule_repo = submodule.module()\n            submodule_repo.heads.master.checkout()\n            submodule_repo.remotes.origin.pull()\n\n        self.announce(\"Configuring cmake project\", level=3)\n\n        self.spawn(['cmake', '-H'+blender_dir, '-B'+self.build_temp,\n                    '-DWITH_PLAYER=OFF', '-DWITH_PYTHON_INSTALL=OFF',\n                    '-DWITH_PYTHON_MODULE=ON', \n                    f\"-DPYTHON_VERSION=\"\n                    f\"{sys.version_info[0]}.{sys.version_info[1]}\"]\n                    + os_build_args)\n        \n        self.announce(\"Building binaries\", level=3)\n\n        self.spawn([\"cmake\", \"--build\", self.build_temp, \"--target\", \"INSTALL\",\n                    \"--config\", \"Release\"])\n\n        # Build finished, now copy the files into the copy directory\n        # The copy directory is the parent directory of the extension (.pyd)\n\n        self.announce(\"Moving Blender python module\", level=3)\n\n        bin_dir = os.path.join(str(build_dir), 'bin', 'Release')\n        self.distribution.bin_dir = bin_dir\n\n        bpy_path = [os.path.join(bin_dir, _bpy) for _bpy in\n                    os.listdir(bin_dir) if\n                    os.path.isfile(os.path.join(bin_dir, _bpy)) and\n                    os.path.splitext(_bpy)[0].startswith('bpy') and\n                    os.path.splitext(_bpy)[1] in [\".pyd\", \".so\"]][0]\n\n        shutil.move(str(bpy_path), str(extension_path))", "response": "Build the build environment for the given extension."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the current ReverseDns entries for the given list of addresses", "response": "def get(self, addresses):\n        \"\"\"\n        :type addresses: list[str]\n        :param addresses: (list[str]) List of addresses to retrieve their reverse dns\n        Retrieve the current configured ReverseDns entries\n        :return: (list) List containing the current ReverseDns Addresses\n        \"\"\"\n        request = self._call(GetReverseDns.GetReverseDns, IPs=addresses)\n        response = request.commit()\n        return response['Value']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, address, host_name):\n        request = self._call(SetEnqueueSetReverseDns.SetEnqueueSetReverseDns, IP=address, Hosts=host_name)\n        response = request.commit()\n        return response['Success']", "response": "Assign one or more PTR records to a single IP"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset(self, addresses):\n        request = self._call(SetEnqueueResetReverseDns.SetEnqueueResetReverseDns, IPs=addresses)\n        response = request.commit()\n        return response['Success']", "response": "Reset all PTR records from the given list of IP addresses."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new Load Balancer.", "response": "def create(self, healthCheckNotification, instance, ipAddressResourceId, name, notificationContacts, rules,\n               loadBalancerClassOfServiceID=1, *args, **kwargs):\n        \"\"\"\n        :type healthCheckNotification: bool\n        :type instance: list[Instance]\n        :type ipAddressResourceId: list[int]\n        :type loadBalancerClassOfServiceID: int\n        :type name: str\n        :type notificationContacts: NotificationContacts or list[NotificationContact]\n        :type rules: Rules\n        :param healthCheckNotification: Enable or disable notifications\n        :param instance: List of balanced IP Addresses (VM or server)\n        :param ipAddressResourceId: ID of the IP Address resource of the Load Balancer\n        :param loadBalancerClassOfServiceID: default 1\n        :param name: Name of the Load Balancer\n        :param notificationContacts: Nullable if notificationContacts is false\n        :param rules: List of NewLoadBalancerRule object containing the list of rules to be configured with the service\n        \"\"\"\n        response = self._call(method=SetEnqueueLoadBalancerCreation,\n                              healthCheckNotification=healthCheckNotification,\n                              instance=instance,\n                              ipAddressResourceId=ipAddressResourceId,\n                              name=name,\n                              notificationContacts=notificationContacts,\n                              rules=rules,\n                              loadBalancerClassOfServiceID=loadBalancerClassOfServiceID,\n                              *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the load balancer notifications for a specific rule within a specific window time frame", "response": "def get_notifications(self, startDate, endDate, loadBalancerID, loadBalancerRuleID):\n        \"\"\"\n        Get the load balancer notifications for a specific rule within a specifying window time frame\n        :type startDate: datetime\n        :type endDate: datetime\n        :type loadBalancerID: int\n        :type loadBalancerRuleID: int\n        :param startDate: From Date\n        :param endDate: To Date\n        :param loadBalancerID: ID of the Laod Balancer\n        :param loadBalancerRuleID: ID of the Load Balancer Rule\n        \"\"\"\n        return self._call(GetLoadBalancerNotifications, startDate=startDate, endDate=endDate,\n                          loadBalancerID=loadBalancerID, loadBalancerRuleID=loadBalancerRuleID)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_oauth_authcfg(authcfg_id=AUTHCFG_ID):\n    # Handle empty strings\n    if not authcfg_id:\n        authcfg_id = AUTHCFG_ID\n    configs = auth_manager().availableAuthMethodConfigs()\n    if authcfg_id in configs \\\n            and configs[authcfg_id].isValid() \\\n            and configs[authcfg_id].method() == 'OAuth2':\n        return configs[authcfg_id]\n    return None", "response": "Check if the given authcfg_id exists and if it s valid\n    OAuth2 return the configuration or None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute_search(\n    search,\n    search_terms=\"\",\n    user=None,\n    reference=\"\",\n    save=True,\n    query_type=SearchQuery.QUERY_TYPE_SEARCH,\n):\n    \"\"\"\n    Create a new SearchQuery instance and execute a search against ES.\n\n    Args:\n        search: elasticsearch.search.Search object, that internally contains\n            the connection and query; this is the query that is executed. All\n            we are doing is logging the input and parsing the output.\n        search_terms: raw end user search terms input - what they typed into the search\n            box.\n        user: Django User object, the person making the query - used for logging\n            purposes. Can be null.\n        reference: string, can be anything you like, used for identification,\n            grouping purposes.\n        save: bool, if True then save the new object immediately, can be\n            overridden to False to prevent logging absolutely everything.\n            Defaults to True\n        query_type: string, used to determine whether to run a search query or\n            a count query (returns hit count, but no results).\n\n    \"\"\"\n    start = time.time()\n    if query_type == SearchQuery.QUERY_TYPE_SEARCH:\n        response = search.execute()\n        hits = [h.meta.to_dict() for h in response.hits]\n        total_hits = response.hits.total\n    elif query_type == SearchQuery.QUERY_TYPE_COUNT:\n        response = total_hits = search.count()\n        hits = []\n    else:\n        raise ValueError(f\"Invalid SearchQuery.query_type value: '{query_type}'\")\n    duration = time.time() - start\n    search_query = SearchQuery(\n        user=user,\n        search_terms=search_terms,\n        index=\", \".join(search._index or [\"_all\"])[:100],  # field length restriction\n        query=search.to_dict(),\n        query_type=query_type,\n        hits=hits,\n        total_hits=total_hits,\n        reference=reference or \"\",\n        executed_at=tz_now(),\n        duration=duration,\n    )\n    search_query.response = response\n    return search_query.save() if save else search_query", "response": "Execute a search against ES and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef in_search_queryset(self, instance_id, index=\"_all\"):\n        return self.get_search_queryset(index=index).filter(pk=instance_id).exists()", "response": "Return True if an object is part of the search index queryset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning queryset of objects from SearchQuery.results, **in order**. EXPERIMENTAL: this will only work with results from a single index, with a single doc_type - as we are returning a single QuerySet. This method takes the hits JSON and converts that into a queryset of all the relevant objects. The key part of this is the ordering - the order in which search results are returned is based on relevance, something that only ES can calculate, and that cannot be replicated in the database. It does this by adding custom SQL which annotates each record with the score from the search 'hit'. This is brittle, caveat emptor. The RawSQL clause is in the form: SELECT CASE {{model}}.id WHEN {{id}} THEN {{score}} END The \"WHEN x THEN y\" is repeated for every hit. The resulting SQL, in full is like this: SELECT \"freelancer_freelancerprofile\".\"id\", (SELECT CASE freelancer_freelancerprofile.id WHEN 25 THEN 1.0 WHEN 26 THEN 1.0 [...] ELSE 0 END) AS \"search_score\" FROM \"freelancer_freelancerprofile\" WHERE \"freelancer_freelancerprofile\".\"id\" IN (25, 26, [...]) ORDER BY \"search_score\" DESC It should be very fast, as there is no table lookup, but there is an assumption at the heart of this, which is that the search query doesn't contain the entire database - i.e. that it has been paged. (ES itself caps the results at 10,000.)", "response": "def from_search_query(self, search_query):\n        \"\"\"\n        Return queryset of objects from SearchQuery.results, **in order**.\n\n        EXPERIMENTAL: this will only work with results from a single index,\n        with a single doc_type - as we are returning a single QuerySet.\n\n        This method takes the hits JSON and converts that into a queryset\n        of all the relevant objects. The key part of this is the ordering -\n        the order in which search results are returned is based on relevance,\n        something that only ES can calculate, and that cannot be replicated\n        in the database.\n\n        It does this by adding custom SQL which annotates each record with\n        the score from the search 'hit'. This is brittle, caveat emptor.\n\n        The RawSQL clause is in the form:\n\n            SELECT CASE {{model}}.id WHEN {{id}} THEN {{score}} END\n\n        The \"WHEN x THEN y\" is repeated for every hit. The resulting SQL, in\n        full is like this:\n\n            SELECT \"freelancer_freelancerprofile\".\"id\",\n                (SELECT CASE freelancer_freelancerprofile.id\n                    WHEN 25 THEN 1.0\n                    WHEN 26 THEN 1.0\n                    [...]\n                    ELSE 0\n                END) AS \"search_score\"\n            FROM \"freelancer_freelancerprofile\"\n            WHERE \"freelancer_freelancerprofile\".\"id\" IN (25, 26, [...])\n            ORDER BY \"search_score\" DESC\n\n        It should be very fast, as there is no table lookup, but there is an\n        assumption at the heart of this, which is that the search query doesn't\n        contain the entire database - i.e. that it has been paged. (ES itself\n        caps the results at 10,000.)\n\n        \"\"\"\n        hits = search_query.hits\n        score_sql = self._raw_sql([(h[\"id\"], h[\"score\"] or 0) for h in hits])\n        rank_sql = self._raw_sql([(hits[i][\"id\"], i) for i in range(len(hits))])\n        return (\n            self.get_queryset()\n            .filter(pk__in=[h[\"id\"] for h in hits])\n            # add the query relevance score\n            .annotate(search_score=RawSQL(score_sql, ()))\n            # add the ordering number (0-based)\n            .annotate(search_rank=RawSQL(rank_sql, ()))\n            .order_by(\"search_rank\")\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npreparing SQL statement consisting of a sequence of WHEN.. THEN statements.", "response": "def _raw_sql(self, values):\n        \"\"\"Prepare SQL statement consisting of a sequence of WHEN .. THEN statements.\"\"\"\n        if isinstance(self.model._meta.pk, CharField):\n            when_clauses = \" \".join(\n                [self._when(\"'{}'\".format(x), y) for (x, y) in values]\n            )\n        else:\n            when_clauses = \" \".join([self._when(x, y) for (x, y) in values])\n        table_name = self.model._meta.db_table\n        primary_key = self.model._meta.pk.column\n        return 'SELECT CASE {}.\"{}\" {} ELSE 0 END'.format(\n            table_name, primary_key, when_clauses\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nkey used for storing search docs in local cache.", "response": "def search_document_cache_key(self):\n        \"\"\"Key used for storing search docs in local cache.\"\"\"\n        return \"elasticsearch_django:{}.{}.{}\".format(\n            self._meta.app_label, self._meta.model_name, self.pk\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_field_serializable(self, field_name):\n        return (\n            self._meta.get_field(field_name).get_internal_type()\n            in self.SIMPLE_UPDATE_FIELD_TYPES\n        )", "response": "Return True if the field can be serialized into a JSON doc."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncleans the list of update_fields based on the index being updated.", "response": "def clean_update_fields(self, index, update_fields):\n        \"\"\"\n        Clean the list of update_fields based on the index being updated.\\\n\n        If any field in the update_fields list is not in the set of properties\n        defined by the index mapping for this model, then we ignore it. If\n        a field _is_ in the mapping, but the underlying model field is a\n        related object, and thereby not directly serializable, then this\n        method will raise a ValueError.\n\n        \"\"\"\n        search_fields = get_model_index_properties(self, index)\n        clean_fields = [f for f in update_fields if f in search_fields]\n        ignore = [f for f in update_fields if f not in search_fields]\n        if ignore:\n            logger.debug(\n                \"Ignoring fields from partial update: %s\",\n                [f for f in update_fields if f not in search_fields],\n            )\n        for f in clean_fields:\n            if not self._is_field_serializable(f):\n                raise ValueError(\n                    \"'%s' cannot be automatically serialized into a search document property. Please override as_search_document_update.\",\n                    f,\n                )\n        return clean_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_search_document_update(self, *, index, update_fields):\n        if UPDATE_STRATEGY == UPDATE_STRATEGY_FULL:\n            return self.as_search_document(index=index)\n\n        if UPDATE_STRATEGY == UPDATE_STRATEGY_PARTIAL:\n            # in partial mode we update the intersection of update_fields and\n            # properties found in the mapping file.\n            return {\n                k: getattr(self, k)\n                for k in self.clean_update_fields(\n                    index=index, update_fields=update_fields\n                )\n            }", "response": "Returns a partial update document based on which fields have been updated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an object as represented in a bulk api operation.", "response": "def as_search_action(self, *, index, action):\n        \"\"\"\n        Return an object as represented in a bulk api operation.\n\n        Bulk API operations have a very specific format. This function will\n        call the standard `as_search_document` method on the object and then\n        wrap that up in the correct format for the action specified.\n\n        https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html\n\n        Args:\n            index: string, the name of the index in which the action is to\n                be taken. Bulk operations are only every carried out on a single\n                index at a time.\n            action: string ['index' | 'update' | 'delete'] - this decides\n                how the final document is formatted.\n\n        Returns a dictionary.\n\n        \"\"\"\n        if action not in (\"index\", \"update\", \"delete\"):\n            raise ValueError(\"Action must be 'index', 'update' or 'delete'.\")\n\n        document = {\n            \"_index\": index,\n            \"_type\": self.search_doc_type,\n            \"_op_type\": action,\n            \"_id\": self.pk,\n        }\n\n        if action == \"index\":\n            document[\"_source\"] = self.as_search_document(index=index)\n        elif action == \"update\":\n            document[\"doc\"] = self.as_search_document(index=index)\n        return document"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch_search_document(self, *, index):\n        assert self.pk, \"Object must have a primary key before being indexed.\"\n        client = get_client()\n        return client.get(index=index, doc_type=self.search_doc_type, id=self.pk)", "response": "Fetch the object s document from a search index by id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index_search_document(self, *, index):\n        cache_key = self.search_document_cache_key\n        new_doc = self.as_search_document(index=index)\n        cached_doc = cache.get(cache_key)\n        if new_doc == cached_doc:\n            logger.debug(\"Search document for %r is unchanged, ignoring update.\", self)\n            return []\n        cache.set(cache_key, new_doc, timeout=get_setting(\"cache_expiry\", 60))\n        get_client().index(\n            index=index, doc_type=self.search_doc_type, body=new_doc, id=self.pk\n        )", "response": "Create or replace search document in named index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the index with the new values.", "response": "def update_search_document(self, *, index, update_fields):\n        \"\"\"\n        Partial update of a document in named index.\n\n        Partial updates are invoked via a call to save the document\n        with 'update_fields'. These fields are passed to the\n        as_search_document method so that it can build a partial\n        document. NB we don't just call as_search_document and then\n        strip the fields _not_ in update_fields as we are trying\n        to avoid possibly expensive operations in building the\n        source document. The canonical example for this method\n        is updating a single timestamp on a model - we don't want\n        to have to walk the model relations and build a document\n        in this case - we just want to push the timestamp.\n\n        When POSTing a partial update the `as_search_document` doc\n        must be passed to the `client.update` wrapped in a \"doc\" node,\n        see: https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html\n\n        \"\"\"\n        doc = self.as_search_document_update(index=index, update_fields=update_fields)\n        if not doc:\n            logger.debug(\"Ignoring object update as document is empty.\")\n            return\n\n        get_client().update(\n            index=index, doc_type=self.search_doc_type, body={\"doc\": doc}, id=self.pk\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_search_document(self, *, index):\n        cache.delete(self.search_document_cache_key)\n        get_client().delete(index=index, doc_type=self.search_doc_type, id=self.pk)", "response": "Delete document from named index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(cls, search, search_terms=\"\", user=None, reference=None, save=True):\n        warnings.warn(\n            \"Pending deprecation - please use `execute_search` function instead.\",\n            PendingDeprecationWarning,\n        )\n        return execute_search(\n            search, search_terms=search_terms, user=user, reference=reference, save=save\n        )", "response": "Create a new SearchQuery instance and execute a search against ES."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves and return the object.", "response": "def save(self, **kwargs):\n        \"\"\"Save and return the object (for chaining).\"\"\"\n        if self.search_terms is None:\n            self.search_terms = \"\"\n        super().save(**kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef page_slice(self):\n        return (\n            None\n            if self.query is None\n            else (self.query.get(\"from\", 0), self.query.get(\"size\", 10))\n        )", "response": "Return the query from : size tuple ( 0 - based."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setPluginSetting(name, value, namespace = None):\n    '''\n    Sets the value of a plugin setting.\n\n    :param name: the name of the setting. It is not the full path, but just the last name of it\n    :param value: the value to set for the plugin setting\n    :param namespace: The namespace. If not passed or None, the namespace will be inferred from\n    the caller method. Normally, this should not be passed, since it suffices to let this function\n    find out the plugin from where it is being called, and it will automatically use the\n    corresponding plugin namespace\n    '''\n    namespace = namespace or _callerName().split(\".\")[0]\n    settings.setValue(namespace + \"/\" + name, value)", "response": "Sets the value of a plugin setting."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pluginSetting(name, namespace=None, typ=None):\n    '''\n    Returns the value of a plugin setting.\n\n    :param name: the name of the setting. It is not the full path, but just the last name of it\n    :param namespace: The namespace. If not passed or None, the namespace will be inferred from\n    the caller method. Normally, this should not be passed, since it suffices to let this function\n    find out the plugin from where it is being called, and it will automatically use the\n    corresponding plugin namespace\n    '''\n    def _find_in_cache(name, key):\n        for setting in _settings[namespace]:\n            if setting[\"name\"] == name:\n                return setting[key]\n        return None\n\n    def _type_map(t):\n        \"\"\"Return setting python type\"\"\"\n        if t == BOOL:\n            return bool\n        elif t == NUMBER:\n            return float\n        else:\n            return unicode\n\n    namespace = namespace or _callerName().split(\".\")[0]\n    full_name = namespace + \"/\" + name\n    if settings.contains(full_name):\n        if typ is None:\n            typ = _type_map(_find_in_cache(name, 'type'))\n        v = settings.value(full_name, None, type=typ)\n        try:\n            if isinstance(v, QPyNullVariant):\n                v = None\n        except:\n            pass\n        return v\n    else:\n        return _find_in_cache(name, 'default')", "response": "Returns the value of a plugin setting."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the settings corresponding to the plugin class.", "response": "def readSettings(settings_path=None):\n    global _settings\n    '''\n    Reads the settings corresponding to the plugin from where the method is called.\n    This function has to be called in the __init__ method of the plugin class.\n    Settings are stored in a settings.json file in the plugin folder.\n    Here is an eample of such a file:\n\n    [\n    {\"name\":\"mysetting\",\n     \"label\": \"My setting\",\n     \"description\": \"A setting to customize my plugin\",\n     \"type\": \"string\",\n     \"default\": \"dummy string\",\n     \"group\": \"Group 1\"\n     \"onEdit\": \"def f():\\\\n\\\\tprint \"Value edited in settings dialog\"\n     \"onChange\": \"def f():\\\\n\\\\tprint \"New settings value has been saved\"\n    },\n    {\"name\":\"anothersetting\",\n      \"label\": \"Another setting\",\n     \"description\": \"Another setting to customize my plugin\",\n     \"type\": \"number\",\n     \"default\": 0,\n     \"group\": \"Group 2\"\n    },\n    {\"name\":\"achoicesetting\",\n     \"label\": \"A choice setting\",\n     \"description\": \"A setting to select from a set of possible options\",\n     \"type\": \"choice\",\n     \"default\": \"option 1\",\n     \"options\":[\"option 1\", \"option 2\", \"option 3\"],\n     \"group\": \"Group 2\"\n    }\n    ]\n\n    Available types for settings are: string, bool, number, choice, crs and text (a multiline string)\n\n    The onEdit property contains a function that will be executed when the user edits the value\n    in the settings dialog. It shouldl return false if, after it has been executed, the setting\n    should not be modified and should recover its original value.\n\n    The onEdit property contains a function that will be executed when the setting is changed after\n    closing the settings dialog, or programatically by callin the setPluginSetting method\n\n    Both onEdit and onChange are optional properties\n\n    '''\n\n    namespace = _callerName().split(\".\")[0]\n    settings_path = settings_path or os.path.join(os.path.dirname(_callerPath()), \"settings.json\")\n    with open(settings_path) as f:\n        _settings[namespace] = json.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an index and apply mapping if appropriate.", "response": "def create_index(index):\n    \"\"\"Create an index and apply mapping if appropriate.\"\"\"\n    logger.info(\"Creating search index: '%s'\", index)\n    client = get_client()\n    return client.indices.create(index=index, body=get_index_mapping(index))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_index(index):\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "response": "Re - index every document in a named index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_index(index):\n    logger.info(\"Deleting search index: '%s'\", index)\n    client = get_client()\n    return client.indices.delete(index=index)", "response": "Delete index entirely (removes all documents and mapping)."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all orphaned documents from an index.", "response": "def prune_index(index):\n    \"\"\"Remove all orphaned documents from an index.\n\n    This function works by scanning the remote index, and in each returned\n    batch of documents looking up whether they appear in the default index\n    queryset. If they don't (they've been deleted, or no longer fit the qs\n    filters) then they are deleted from the index. The deletion is done in\n    one hit after the entire remote index has been scanned.\n\n    The elasticsearch.helpers.scan function returns each document one at a\n    time, so this function can swamp the database with SELECT requests.\n\n    Please use sparingly.\n\n    Returns a list of ids of all the objects deleted.\n\n    \"\"\"\n    logger.info(\"Pruning missing objects from index '%s'\", index)\n    prunes = []\n    responses = []\n    client = get_client()\n    for model in get_index_models(index):\n        for hit in scan_index(index, model):\n            obj = _prune_hit(hit, model)\n            if obj:\n                prunes.append(obj)\n        logger.info(\n            \"Found %s objects of type '%s' for deletion from '%s'.\",\n            len(prunes),\n            model,\n            index,\n        )\n        if len(prunes) > 0:\n            actions = bulk_actions(prunes, index, \"delete\")\n            response = helpers.bulk(\n                client, actions, chunk_size=get_setting(\"chunk_size\")\n            )\n            responses.append(response)\n    return responses"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking whether a document should be pruned. This method uses the SearchDocumentManagerMixin.in_search_queryset method to determine whether a 'hit' (search document) should be pruned from an index, and if so it returns the hit as a Django object(id=hit_id). Args: hit: dict object the represents a document as returned from the scan_index function. (Contains object id and index.) model: the Django model (not object) from which the document was derived. Used to get the correct model manager and bulk action. Returns: an object of type model, with id=hit_id. NB this is not the object itself, which by definition may not exist in the underlying database, but a temporary object with the document id - which is enough to create a 'delete' action.", "response": "def _prune_hit(hit, model):\n    \"\"\"\n    Check whether a document should be pruned.\n\n    This method uses the SearchDocumentManagerMixin.in_search_queryset method\n    to determine whether a 'hit' (search document) should be pruned from an index,\n    and if so it returns the hit as a Django object(id=hit_id).\n\n    Args:\n        hit: dict object the represents a document as returned from the scan_index\n            function. (Contains object id and index.)\n        model: the Django model (not object) from which the document was derived.\n            Used to get the correct model manager and bulk action.\n\n    Returns:\n        an object of type model, with id=hit_id. NB this is not the object\n        itself, which by definition may not exist in the underlying database,\n        but a temporary object with the document id - which is enough to create\n        a 'delete' action.\n\n    \"\"\"\n    hit_id = hit[\"_id\"]\n    hit_index = hit[\"_index\"]\n    if model.objects.in_search_queryset(hit_id, index=hit_index):\n        logger.debug(\n            \"%s with id=%s exists in the '%s' index queryset.\", model, hit_id, hit_index\n        )\n        return None\n    else:\n        logger.debug(\n            \"%s with id=%s does not exist in the '%s' index queryset and will be pruned.\",\n            model,\n            hit_id,\n            hit_index,\n        )\n        # we don't need the full obj for a delete action, just the id.\n        # (the object itself may not even exist.)\n        return model(pk=hit_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scan_index(index, model):\n    # see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-type-query.html\n    query = {\"query\": {\"type\": {\"value\": model._meta.model_name}}}\n    client = get_client()\n    for hit in helpers.scan(client, index=index, query=query):\n        yield hit", "response": "Yields all documents of type model in an index."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bulk_actions(objects, index, action):\n    assert (\n        index != \"_all\"\n    ), \"index arg must be a valid index name. '_all' is a reserved term.\"\n    logger.info(\"Creating bulk '%s' actions for '%s'\", action, index)\n    for obj in objects:\n        try:\n            logger.debug(\"Appending '%s' action for '%r'\", action, obj)\n            yield obj.as_search_action(index=index, action=action)\n        except Exception:\n            logger.exception(\"Unable to create search action for %s\", obj)", "response": "Yield bulk api actions from a collection of objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_mapping(index, strict=False):\n    try:\n        settings.get_index_mapping(index)\n    except IOError:\n        if strict:\n            raise ImproperlyConfigured(\"Index '%s' has no mapping file.\" % index)\n        else:\n            logger.warning(\"Index '%s' has no mapping, relying on ES instead.\", index)", "response": "Check that an index mapping JSON file exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_model(model):\n    if not hasattr(model, \"as_search_document\"):\n        raise ImproperlyConfigured(\"'%s' must implement `as_search_document`.\" % model)\n    if not hasattr(model.objects, \"get_search_queryset\"):\n        raise ImproperlyConfigured(\n            \"'%s.objects must implement `get_search_queryset`.\" % model\n        )", "response": "Check that a model configured for an index subclasses the required classes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect up post save post delete signals for models.", "response": "def _connect_signals():\n    \"\"\"Connect up post_save, post_delete signals for models.\"\"\"\n    for index in settings.get_index_names():\n        for model in settings.get_index_models(index):\n            _connect_model_signals(model)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting signals for a single model.", "response": "def _connect_model_signals(model):\n    \"\"\"Connect signals for a single model.\"\"\"\n    dispatch_uid = \"%s.post_save\" % model._meta.model_name\n    logger.debug(\"Connecting search index model post_save signal: %s\", dispatch_uid)\n    signals.post_save.connect(_on_model_save, sender=model, dispatch_uid=dispatch_uid)\n    dispatch_uid = \"%s.post_delete\" % model._meta.model_name\n    logger.debug(\"Connecting search index model post_delete signal: %s\", dispatch_uid)\n    signals.post_delete.connect(\n        _on_model_delete, sender=model, dispatch_uid=dispatch_uid\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate document in search index post_save.", "response": "def _on_model_save(sender, **kwargs):\n    \"\"\"Update document in search index post_save.\"\"\"\n    instance = kwargs.pop(\"instance\")\n    update_fields = kwargs.pop(\"update_fields\")\n    for index in instance.search_indexes:\n        try:\n            _update_search_index(\n                instance=instance, index=index, update_fields=update_fields\n            )\n        except Exception:\n            logger.exception(\"Error handling 'on_save' signal for %s\", instance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves documents from search indexes post_delete.", "response": "def _on_model_delete(sender, **kwargs):\n    \"\"\"Remove documents from search indexes post_delete.\"\"\"\n    instance = kwargs.pop(\"instance\")\n    for index in instance.search_indexes:\n        try:\n            _delete_from_search_index(instance=instance, index=index)\n        except Exception:\n            logger.exception(\"Error handling 'on_delete' signal for %s\", instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _in_search_queryset(*, instance, index) -> bool:\n    try:\n        return instance.__class__.objects.in_search_queryset(instance.id, index=index)\n    except Exception:\n        logger.exception(\"Error checking object in_search_queryset.\")\n        return False", "response": "Wrapper around the instance manager method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update_search_index(*, instance, index, update_fields):\n    if not _in_search_queryset(instance=instance, index=index):\n        logger.debug(\n            \"Object (%r) is not in search queryset, ignoring update.\", instance\n        )\n        return\n\n    try:\n        if update_fields:\n            pre_update.send(\n                sender=instance.__class__,\n                instance=instance,\n                index=index,\n                update_fields=update_fields,\n            )\n            if settings.auto_sync(instance):\n                instance.update_search_document(\n                    index=index, update_fields=update_fields\n                )\n        else:\n            pre_index.send(sender=instance.__class__, instance=instance, index=index)\n            if settings.auto_sync(instance):\n                instance.index_search_document(index=index)\n    except Exception:\n        logger.exception(\"Error handling 'post_save' signal for %s\", instance)", "response": "Process index update actions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a document from a search index.", "response": "def _delete_from_search_index(*, instance, index):\n    \"\"\"Remove a document from a search index.\"\"\"\n    pre_delete.send(sender=instance.__class__, instance=instance, index=index)\n    if settings.auto_sync(instance):\n        instance.delete_search_document(index=index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates config and connect signals.", "response": "def ready(self):\n        \"\"\"Validate config and connect signals.\"\"\"\n        super(ElasticAppConfig, self).ready()\n        _validate_config(settings.get_setting(\"strict_validation\"))\n        _connect_signals()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn specific search setting from Django conf.", "response": "def get_setting(key, *default):\n    \"\"\"Return specific search setting from Django conf.\"\"\"\n    if default:\n        return get_settings().get(key, default[0])\n    else:\n        return get_settings()[key]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the JSON mapping file for an index.", "response": "def get_index_mapping(index):\n    \"\"\"Return the JSON mapping file for an index.\n\n    Mappings are stored as JSON files in the mappings subdirectory of this\n    app. They must be saved as {{index}}.json.\n\n    Args:\n        index: string, the name of the index to look for.\n\n    \"\"\"\n    # app_path = apps.get_app_config('elasticsearch_django').path\n    mappings_dir = get_setting(\"mappings_dir\")\n    filename = \"%s.json\" % index\n    path = os.path.join(mappings_dir, filename)\n    with open(path, \"r\") as f:\n        return json.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the list of properties specified for a model in an index.", "response": "def get_model_index_properties(instance, index):\n    \"\"\"Return the list of properties specified for a model in an index.\"\"\"\n    mapping = get_index_mapping(index)\n    doc_type = instance._meta.model_name.lower()\n    return list(mapping[\"mappings\"][doc_type][\"properties\"].keys())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_index_models(index):\n    models = []\n    for app_model in get_index_config(index).get(\"models\"):\n        app, model = app_model.split(\".\")\n        models.append(apps.get_model(app, model))\n    return models", "response": "Return list of models configured for a named index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list of all indexes in which a Django model is configured.", "response": "def get_model_indexes(model):\n    \"\"\"Return list of all indexes in which a model is configured.\n\n    A model may be configured to appear in multiple indexes. This function\n    will return the names of the indexes as a list of strings. This is\n    useful if you want to know which indexes need updating when a model\n    is saved.\n\n    Args:\n        model: a Django model class.\n\n    \"\"\"\n    indexes = []\n    for index in get_index_names():\n        for app_model in get_index_models(index):\n            if app_model == model:\n                indexes.append(index)\n    return indexes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn dict of index. doc_type model.", "response": "def get_document_models():\n    \"\"\"Return dict of index.doc_type: model.\"\"\"\n    mappings = {}\n    for i in get_index_names():\n        for m in get_index_models(i):\n            key = \"%s.%s\" % (i, m._meta.model_name)\n            mappings[key] = m\n    return mappings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef auto_sync(instance):\n    # this allows us to turn off sync temporarily - e.g. when doing bulk updates\n    if not get_setting(\"auto_sync\"):\n        return False\n    model_name = \"{}.{}\".format(instance._meta.app_label, instance._meta.model_name)\n    if model_name in get_setting(\"never_auto_sync\", []):\n        return False\n    return True", "response": "Returns bool if auto_sync is on for the model"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pprint(data):\n    pretty = json.dumps(data, sort_keys=True, indent=4, separators=(\",\", \": \"))\n    html = pretty.replace(\" \", \"&nbsp;\").replace(\"\\n\", \"<br>\")\n    return mark_safe(\"<code>%s</code>\" % html)", "response": "Pretty - print the JSON data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addHelpMenu(menuName, parentMenuFunction=None):\n    '''\n    Adds a help menu to the plugin menu.\n    This method should be called from the initGui() method of the plugin\n\n    :param menuName: The name of the plugin menu in which the about menu is to be added.\n    '''\n\n    parentMenuFunction = parentMenuFunction or iface.addPluginToMenu\n    namespace = _callerName().split(\".\")[0]\n    path = \"file://{}\".format(os.path.join(os.path.dirname(_callerPath()), \"docs\",  \"html\", \"index.html\"))    \n    helpAction = QtWidgets.QAction(QgsApplication.getThemeIcon('/mActionHelpContents.svg'), \n                                    \"Plugin help...\", iface.mainWindow())\n    helpAction.setObjectName(namespace + \"help\")\n    helpAction.triggered.connect(lambda: openHelp(path))\n    parentMenuFunction(menuName, helpAction)\n    global _helpActions\n    _helpActions[menuName] = helpAction", "response": "Adds a help menu to the plugin menu."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addAboutMenu(menuName, parentMenuFunction=None):\n    '''\n    Adds an 'about...' menu to the plugin menu.\n    This method should be called from the initGui() method of the plugin\n\n    :param menuName: The name of the plugin menu in which the about menu is to be added\n    '''\n\n    parentMenuFunction = parentMenuFunction or iface.addPluginToMenu\n    namespace = _callerName().split(\".\")[0]\n    icon = QtGui.QIcon(os.path.join(os.path.dirname(os.path.dirname(__file__)), \"icons\", \"help.png\"))\n    aboutAction = QtWidgets.QAction(icon, \"About...\", iface.mainWindow())\n    aboutAction.setObjectName(namespace + \"about\")\n    aboutAction.triggered.connect(lambda: openAboutDialog(namespace))\n    parentMenuFunction(menuName, aboutAction)\n    global _aboutActions\n    _aboutActions[menuName] = aboutAction", "response": "Adds an about menu to the plugin menu."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef showMessageDialog(title, text):\n    '''\n    Show a dialog containing a given text, with a given title.\n\n    The text accepts HTML syntax\n    '''\n    dlg = QgsMessageOutput.createMessageOutput()\n    dlg.setTitle(title)\n    dlg.setMessage(text, QgsMessageOutput.MessageHtml)\n    dlg.showMessage()", "response": "Show a dialog containing a given text with a given title."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef askForFiles(parent, msg = None, isSave = False, allowMultiple = False, exts = \"*\"):\n    '''\n    Asks for a file or files, opening the corresponding dialog with the last path that was selected\n    when this same function was invoked from the calling method.\n\n    :param parent: The parent window\n    :param msg: The message to use for the dialog title\n    :param isSave: true if we are asking for file to save\n    :param allowMultiple: True if should allow multiple files to be selected. Ignored if isSave == True\n    :param exts: Extensions to allow in the file dialog. Can be a single string or a list of them.\n    Use \"*\" to add an option that allows all files to be selected\n\n    :returns: A string with the selected filepath or an array of them, depending on whether allowMultiple is True of False\n    '''\n    msg = msg or 'Select file'\n    caller = _callerName().split(\".\")\n    name = \"/\".join([LAST_PATH, caller[-1]])\n    namespace = caller[0]\n    path = pluginSetting(name, namespace)\n    f = None\n    if not isinstance(exts, list):\n        exts = [exts]\n    extString = \";; \".join([\" %s files (*.%s)\" % (e.upper(), e) if e != \"*\" else \"All files (*.*)\" for e in exts])\n    if allowMultiple:\n        ret = QtWidgets.QFileDialog.getOpenFileNames(parent, msg, path, '*.' + extString)\n        if ret:\n            f = ret[0]\n        else:\n            f = ret = None\n    else:\n        if isSave:\n            ret = QtWidgets.QFileDialog.getSaveFileName(parent, msg, path, '*.' + extString) or None\n            if ret is not None and not ret.endswith(exts[0]):\n                ret += \".\" + exts[0]\n        else:\n            ret = QtWidgets.QFileDialog.getOpenFileName(parent, msg , path, '*.' + extString) or None\n        f = ret\n\n    if f is not None:\n        setPluginSetting(name, os.path.dirname(f), namespace)\n\n    return ret", "response": "Asks for a file or files in the current directory of the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nasking for a folder opening the corresponding dialog with the last path that was selected by the calling function.", "response": "def askForFolder(parent, msg = None):\n    '''\n    Asks for a folder, opening the corresponding dialog with the last path that was selected\n    when this same function was invoked from the calling method\n\n    :param parent: The parent window\n    :param msg: The message to use for the dialog title\n    '''\n    msg = msg or 'Select folder'\n    caller = _callerName().split(\".\")\n    name = \"/\".join([LAST_PATH, caller[-1]])\n    namespace = caller[0]\n    path = pluginSetting(name, namespace)\n    folder =  QtWidgets.QFileDialog.getExistingDirectory(parent, msg, path)\n    if folder:\n        setPluginSetting(name, folder, namespace)\n    return folder"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(func, message = None):\n    '''\n    Executes a lengthy tasks in a separate thread and displays a waiting dialog if needed.\n    Sets the cursor to wait cursor while the task is running.\n\n    This function does not provide any support for progress indication\n\n    :param func: The function to execute.\n\n    :param message: The message to display in the wait dialog. If not passed, the dialog won't be shown\n    '''\n    global _dialog\n    cursor = QtWidgets.QApplication.overrideCursor()\n    waitCursor = (cursor is not None and cursor.shape() == QtCore.Qt.WaitCursor)\n    dialogCreated = False\n    try:\n        QtCore.QCoreApplication.processEvents()\n        if not waitCursor:\n            QtWidgets.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))\n        if message is not None:\n            t = ExecutorThread(func)\n            loop = QtCore.QEventLoop()\n            t.finished.connect(loop.exit, QtCore.Qt.QueuedConnection)\n            if _dialog is None:\n                dialogCreated = True\n                _dialog = QtGui.QProgressDialog(message, \"Running\", 0, 0, iface.mainWindow())\n                _dialog.setWindowTitle(\"Running\")\n                _dialog.setWindowModality(QtCore.Qt.WindowModal);\n                _dialog.setMinimumDuration(1000)\n                _dialog.setMaximum(100)\n                _dialog.setValue(0)\n                _dialog.setMaximum(0)\n                _dialog.setCancelButton(None)\n            else:\n                oldText = _dialog.labelText()\n                _dialog.setLabelText(message)\n            QtWidgets.QApplication.processEvents()\n            t.start()\n            loop.exec_(flags = QtCore.QEventLoop.ExcludeUserInputEvents)\n            if t.exception is not None:\n                raise t.exception\n            return t.returnValue\n        else:\n            return func()\n    finally:\n        if message is not None:\n            if dialogCreated:\n                _dialog.reset()\n                _dialog = None\n            else:\n                _dialog.setLabelText(oldText)\n        if not waitCursor:\n            QtWidgets.QApplication.restoreOverrideCursor()\n        QtCore.QCoreApplication.processEvents()", "response": "Executes a function in a separate thread and displays a waiting dialog if needed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a HTTP request to the server.", "response": "def request(self, url, method=\"GET\", body=None, headers=None, redirections=DEFAULT_MAX_REDIRECTS, connection_type=None, blocking=True):\n        \"\"\"\n        Make a network request by calling QgsNetworkAccessManager.\n        redirections argument is ignored and is here only for httplib2 compatibility.\n        \"\"\"\n        self.msg_log(u'http_call request: {0}'.format(url))\n\n        self.blocking_mode = blocking\n        req = QNetworkRequest()\n        # Avoid double quoting form QUrl\n        url = urllib.parse.unquote(url)\n        req.setUrl(QUrl(url))\n        if headers is not None:\n            # This fixes a wierd error with compressed content not being correctly\n            # inflated.\n            # If you set the header on the QNetworkRequest you are basically telling\n            # QNetworkAccessManager \"I know what I'm doing, please don't do any content\n            # encoding processing\".\n            # See: https://bugs.webkit.org/show_bug.cgi?id=63696#c1\n            try:\n                del headers['Accept-Encoding']\n            except KeyError:\n                pass\n            for k, v in list(headers.items()):\n                self.msg_log(\"Setting header %s to %s\" % (k, v))\n                req.setRawHeader(k.encode(), v.encode())\n        if self.authid:\n            self.msg_log(\"Update request w/ authid: {0}\".format(self.authid))\n            self.auth_manager().updateNetworkRequest(req, self.authid)\n        if self.reply is not None and self.reply.isRunning():\n            self.reply.close()\n        if method.lower() == 'delete':\n            func = getattr(QgsNetworkAccessManager.instance(), 'deleteResource')\n        else:\n            func = getattr(QgsNetworkAccessManager.instance(), method.lower())\n        # Calling the server ...\n        # Let's log the whole call for debugging purposes:\n        self.msg_log(\"Sending %s request to %s\" % (method.upper(), req.url().toString()))\n        self.on_abort = False\n        headers = {str(h): str(req.rawHeader(h)) for h in req.rawHeaderList()}\n        for k, v in list(headers.items()):\n            self.msg_log(\"%s: %s\" % (k, v))\n        if method.lower() in ['post', 'put']:\n            if isinstance(body, io.IOBase):\n                body = body.read()\n            if isinstance(body, str):\n                body = body.encode()\n            self.reply = func(req, body)\n        else:\n            self.reply = func(req)\n        if self.authid:\n            self.msg_log(\"Update reply w/ authid: {0}\".format(self.authid))\n            self.auth_manager().updateNetworkReply(self.reply, self.authid)\n\n        # necessary to trap local timout manage by QgsNetworkAccessManager\n        # calling QgsNetworkAccessManager::abortRequest\n        QgsNetworkAccessManager.instance().requestTimedOut.connect(self.requestTimedOut)\n\n        self.reply.sslErrors.connect(self.sslErrors)\n        self.reply.finished.connect(self.replyFinished)\n        self.reply.downloadProgress.connect(self.downloadProgress)\n\n        # block if blocking mode otherwise return immediatly\n        # it's up to the caller to manage listeners in case of no blocking mode\n        if not self.blocking_mode:\n            return (None, None)\n\n        # Call and block\n        self.el = QEventLoop()\n        self.reply.finished.connect(self.el.quit)\n\n        # Catch all exceptions (and clean up requests)\n        try:\n            self.el.exec_(QEventLoop.ExcludeUserInputEvents)\n        except Exception as e:\n            raise e\n\n        if self.reply:\n            self.reply.finished.disconnect(self.el.quit)\n\n        # emit exception in case of error\n        if not self.http_call_result.ok:\n            if self.http_call_result.exception and not self.exception_class:\n                raise self.http_call_result.exception\n            else:\n                raise self.exception_class(self.http_call_result.reason)\n\n        return (self.http_call_result, self.http_call_result.content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sslErrors(self, ssl_errors):\n        if ssl_errors:\n            for v in ssl_errors:\n                self.msg_log(\"SSL Error: %s\" % v.errorString())\n        if self.disable_ssl_certificate_validation:\n            self.reply.ignoreSslErrors()", "response": "Handle SSL errors logging them if debug is on and ignoring them if disable_ssl_certificate_validation is set to True."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nabort the HTTP call.", "response": "def abort(self):\n        \"\"\"\n        Handle request to cancel HTTP call\n        \"\"\"\n        if (self.reply and self.reply.isRunning()):\n            self.on_abort = True\n            self.reply.abort()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all layers in a single key - value basis.", "response": "def mapLayers(name=None, types=None):\n    \"\"\"\n    Return all the loaded layers.  Filters by name (optional) first and then type (optional)\n    :param name: (optional) name of layer to return..\n    :param type: (optional) The QgsMapLayer type of layer to return. Accepts a single value or a list of them\n    :return: List of loaded layers. If name given will return all layers with matching name.\n    \"\"\"\n    if types is not None and not isinstance(types, list):\n        types = [types]\n    layers = _layerreg.mapLayers().values()\n    _layers = []\n    if name or types:\n        if name:\n            _layers = [layer for layer in layers if re.match(name, layer.name())]\n        if types:\n            _layers += [layer for layer in layers if layer.type() in types]\n        return _layers\n    else:\n        return layers"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a layer to the QGIS layer registry and session.", "response": "def addLayer(layer, loadInLegend=True):\n    \"\"\"\n    Add one or several layers to the QGIS session and layer registry.\n    :param layer: The layer object or list with layers  to add the QGIS layer registry and session.\n    :param loadInLegend: True if this layer should be added to the legend.\n    :return: The added layer\n    \"\"\"\n    if not hasattr(layer, \"__iter__\"):\n        layer = [layer]\n    _layerreg.addMapLayers(layer, loadInLegend)\n    return layer"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a layer from layer object but does not ask for CRS", "response": "def addLayerNoCrsDialog(layer, loadInLegend=True):\n    '''\n    Tries to add a layer from layer object\n    Same as the addLayer method, but it does not ask for CRS, regardless of current\n    configuration in QGIS settings\n    '''\n    settings = QSettings()\n    prjSetting = settings.value('/Projections/defaultBehaviour')\n    settings.setValue('/Projections/defaultBehaviour', '')\n    # QGIS3\n    prjSetting3 = settings.value('/Projections/defaultBehavior')\n    settings.setValue('/Projections/defaultBehavior', '')\n    layer = addLayer(layer, loadInLegend)\n    settings.setValue('/Projections/defaultBehaviour', prjSetting)\n    settings.setValue('/Projections/defaultBehavior', prjSetting3)\n    return layer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef newVectorLayer(filename, fields, geometryType, crs, encoding=\"utf-8\"):\n    '''\n    Creates a new vector layer\n\n    :param filename: The filename to store the file. The extensions determines the type of file.\n    If extension is not among the supported ones, a shapefile will be created and the file will\n    get an added '.shp' to its path.\n    If the filename is None, a memory layer will be created\n\n    :param fields: the fields to add to the layer. Accepts a QgsFields object or a list of tuples (field_name, field_type)\n    Accepted field types are basic Python types str, float, int and bool\n\n    :param geometryType: The type of geometry of the layer to create.\n\n    :param crs: The crs of the layer to create. Accepts a QgsCoordinateSystem object or a string with the CRS authId.\n\n    :param encoding: The layer encoding\n    '''\n    if isinstance(crs, basestring):\n        crs = QgsCoordinateReferenceSystem(crs)\n    if filename is None:\n        uri = GEOM_TYPE_MAP[geometryType]\n        if crs.isValid():\n            uri += '?crs=' + crs.authid() + '&'\n        fieldsdesc = ['field=' + f for f in fields]\n\n        fieldsstring = '&'.join(fieldsdesc)\n        uri += fieldsstring\n        layer = QgsVectorLayer(uri, \"mem_layer\", 'memory')\n    else:\n        formats = QgsVectorFileWriter.supportedFiltersAndFormats()\n        OGRCodes = {}\n        for (key, value) in formats.items():\n            extension = unicode(key)\n            extension = extension[extension.find('*.') + 2:]\n            extension = extension[:extension.find(' ')]\n            OGRCodes[extension] = value\n\n        extension = os.path.splitext(filename)[1][1:]\n        if extension not in OGRCodes:\n            extension = 'shp'\n            filename = filename + '.shp'\n\n        if isinstance(fields, QgsFields):\n            qgsfields = fields\n        else:\n            qgsfields = QgsFields()\n            for field in fields:\n                qgsfields.append(_toQgsField(field))\n\n        QgsVectorFileWriter(filename, encoding, qgsfields,\n                            geometryType, crs, OGRCodes[extension])\n\n        layer = QgsVectorLayer(filename, os.path.basename(filename), 'ogr')\n\n    return layer", "response": "Create a new vector layer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the layer from the current project with the passed source Raises WrongLayerSourceException", "response": "def layerFromSource(source):\n    '''\n    Returns the layer from the current project with the passed source\n    Raises WrongLayerSourceException if no layer with that source is found\n    '''\n    layers =_layerreg.mapLayers().values()\n    for layer in layers:\n        if layer.source() == source:\n            return layer\n    raise WrongLayerSourceException()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to load a layer from the given file and returns the layer object.", "response": "def loadLayer(filename, name = None, provider=None):\n    '''\n    Tries to load a layer from the given file\n\n    :param filename: the path to the file to load.\n\n    :param name: the name to use for adding the layer to the current project.\n    If not passed or None, it will use the filename basename\n    '''\n    name = name or os.path.splitext(os.path.basename(filename))[0]\n    if provider != 'gdal': # QGIS3 crashes if opening a raster as vector ... this needs further investigations\n        qgslayer = QgsVectorLayer(filename, name, provider or \"ogr\")\n    if provider == 'gdal' or not qgslayer.isValid():\n        qgslayer = QgsRasterLayer(filename, name, provider or \"gdal\")\n        if not qgslayer.isValid():\n            raise RuntimeError('Could not load layer: ' + unicode(filename))\n\n    return qgslayer"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to load a layer from the given file and does not ask for CRS", "response": "def loadLayerNoCrsDialog(filename, name=None, provider=None):\n    '''\n    Tries to load a layer from the given file\n    Same as the loadLayer method, but it does not ask for CRS, regardless of current\n    configuration in QGIS settings\n    '''\n    settings = QSettings()\n    prjSetting = settings.value('/Projections/defaultBehaviour')\n    settings.setValue('/Projections/defaultBehaviour', '')\n    # QGIS3:\n    prjSetting3 = settings.value('/Projections/defaultBehavior')\n    settings.setValue('/Projections/defaultBehavior', '')\n    layer = loadLayer(filename, name, provider)\n    settings.setValue('/Projections/defaultBehaviour', prjSetting)\n    settings.setValue('/Projections/defaultBehavior', prjSetting3)\n    return layer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a open settings menu to the plugin menu.", "response": "def addSettingsMenu(menuName, parentMenuFunction=None):\n    '''\n    Adds a 'open settings...' menu to the plugin menu.\n    This method should be called from the initGui() method of the plugin\n\n    :param menuName: The name of the plugin menu in which the settings menu is to be added\n    :param parentMenuFunction: a function from QgisInterface to indicate where to put the container plugin menu.\n    If not passed, it uses addPluginToMenu\n    '''\n\n    parentMenuFunction = parentMenuFunction or iface.addPluginToMenu\n    namespace = _callerName().split(\".\")[0]\n    settingsAction = QAction(\n        QgsApplication.getThemeIcon('/mActionOptions.svg'),\n        \"Plugin Settings...\",\n        iface.mainWindow())\n    settingsAction.setObjectName(namespace + \"settings\")\n    settingsAction.triggered.connect(lambda: openSettingsDialog(namespace))\n    parentMenuFunction(menuName, settingsAction)\n    global _settingActions\n    _settingActions[menuName] = settingsAction"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef openParametersDialog(params, title=None):\n    '''\n    Opens a dialog to enter parameters.\n    Parameters are passed as a list of Parameter objects\n    Returns a dict with param names as keys and param values as values\n    Returns None if the dialog was cancelled\n    '''\n    QApplication.setOverrideCursor(QCursor(Qt.ArrowCursor))\n    dlg = ParametersDialog(params, title)\n    dlg.exec_()\n    QApplication.restoreOverrideCursor()\n    return dlg.values", "response": "Opens a dialog to enter parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns do_index_command on each specified index and log the output.", "response": "def handle(self, *args, **options):\n        \"\"\"Run do_index_command on each specified index and log the output.\"\"\"\n        for index in options.pop(\"indexes\"):\n            data = {}\n            try:\n                data = self.do_index_command(index, **options)\n            except TransportError as ex:\n                logger.warning(\"ElasticSearch threw an error: %s\", ex)\n                data = {\"index\": index, \"status\": ex.status_code, \"reason\": ex.error}\n            finally:\n                logger.info(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new template.", "response": "def create(self, Name, Subject, HtmlBody=None, TextBody=None, Alias=None):\n        \"\"\"\n        Creates a template.\n\n        :param Name: Name of template\n        :param Subject: The content to use for the Subject when this template is used to send email.\n        :param HtmlBody: The content to use for the HtmlBody when this template is used to send email.\n        :param TextBody: The content to use for the HtmlBody when this template is used to send email.\n        :return:\n        \"\"\"\n        assert TextBody or HtmlBody, \"Provide either email TextBody or HtmlBody or both\"\n        data = {\"Name\": Name, \"Subject\": Subject, \"HtmlBody\": HtmlBody, \"TextBody\": TextBody, \"Alias\": Alias}\n        return self._init_instance(self.call(\"POST\", \"/templates\", data=data))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a logger with the given name and verbosity and stream.", "response": "def get_logger(name, verbosity, stream):\n    \"\"\"\n    Returns simple console logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    logger.setLevel(\n        {0: DEFAULT_LOGGING_LEVEL, 1: logging.INFO, 2: logging.DEBUG}.get(min(2, verbosity), DEFAULT_LOGGING_LEVEL)\n    )\n    logger.handlers = []\n    handler = logging.StreamHandler(stream)\n    handler.setLevel(logging.DEBUG)\n    handler.setFormatter(logging.Formatter(LOG_FORMAT))\n    logger.addHandler(handler)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_config(cls, config, prefix=\"postmark_\", is_uppercase=False):\n        kwargs = {}\n        for arg in get_args(cls):\n            key = prefix + arg\n            if is_uppercase:\n                key = key.upper()\n            else:\n                key = key.lower()\n            if key in config:\n                kwargs[arg] = config[key]\n        return cls(**kwargs)", "response": "Instantiates a new instance of the class from a dictionary - like object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chunks(container, n):\n    for i in range(0, len(container), n):\n        yield container[i : i + n]", "response": "Split a container into n - sized chunks."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sizes(count, offset=0, max_chunk=500):\n    if count is None:\n        chunk = max_chunk\n        while True:\n            yield chunk, offset\n            offset += chunk\n    else:\n        while count:\n            chunk = min(count, max_chunk)\n            count = max(0, count - max_chunk)\n            yield chunk, offset\n            offset += chunk", "response": "Yields count and offset items from the remote data via count & offset pagination."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef raise_for_response(self, responses):\n        exception_messages = [self.client.format_exception_message(response) for response in responses]\n        if len(exception_messages) == 1:\n            message = exception_messages[0]\n        else:\n            message = \"[%s]\" % \", \".join(exception_messages)\n        raise PostmarkerException(message)", "response": "Constructs appropriate exception from list of responses and raises it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert list to string with comma separated values. For list is no - op.", "response": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_attachments(attachment):\n    if isinstance(attachment, tuple):\n        result = {\"Name\": attachment[0], \"Content\": attachment[1], \"ContentType\": attachment[2]}\n        if len(attachment) == 4:\n            result[\"ContentID\"] = attachment[3]\n    elif isinstance(attachment, MIMEBase):\n        payload = attachment.get_payload()\n        content_type = attachment.get_content_type()\n        # Special case for message/rfc822\n        # Even if RFC implies such attachments being not base64-encoded,\n        # Postmark requires all attachments to be encoded in this way\n        if content_type == \"message/rfc822\" and not isinstance(payload, str):\n            payload = b64encode(payload[0].get_payload(decode=True)).decode()\n        result = {\n            \"Name\": attachment.get_filename() or \"attachment.txt\",\n            \"Content\": payload,\n            \"ContentType\": content_type,\n        }\n        content_id = attachment.get(\"Content-ID\")\n        if content_id:\n            if content_id.startswith(\"<\") and content_id.endswith(\">\"):\n                content_id = content_id[1:-1]\n            if (attachment.get(\"Content-Disposition\") or \"\").startswith(\"inline\"):\n                content_id = \"cid:%s\" % content_id\n            result[\"ContentID\"] = content_id\n    elif isinstance(attachment, str):\n        content_type = guess_content_type(attachment)\n        filename = os.path.basename(attachment)\n        with open(attachment, \"rb\") as fd:\n            data = fd.read()\n        result = {\"Name\": filename, \"Content\": b64encode(data).decode(\"utf-8\"), \"ContentType\": content_type}\n    else:\n        result = attachment\n    return result", "response": "Converts incoming attachment into dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_dict(self):\n        data = super(BaseEmail, self).as_dict()\n        data[\"Headers\"] = [{\"Name\": name, \"Value\": value} for name, value in data[\"Headers\"].items()]\n        for field in (\"To\", \"Cc\", \"Bcc\"):\n            if field in data:\n                data[field] = list_to_csv(data[field])\n        data[\"Attachments\"] = [prepare_attachments(attachment) for attachment in data[\"Attachments\"]]\n        return data", "response": "Returns a dict representation of the email."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attach_binary(self, content, filename):\n        content_type = guess_content_type(filename)\n        payload = {\"Name\": filename, \"Content\": b64encode(content).decode(\"utf-8\"), \"ContentType\": content_type}\n        self.attach(payload)", "response": "Attaches given binary data to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing an instance of this class from a MIMEText instance.", "response": "def from_mime(cls, message, manager):\n        \"\"\"\n        Instantiates ``Email`` instance from ``MIMEText`` instance.\n\n        :param message: ``email.mime.text.MIMEText`` instance.\n        :param manager: :py:class:`EmailManager` instance.\n        :return: :py:class:`Email`\n        \"\"\"\n        text, html, attachments = deconstruct_multipart(message)\n        subject = prepare_header(message[\"Subject\"])\n        sender = prepare_header(message[\"From\"])\n        to = prepare_header(message[\"To\"])\n        cc = prepare_header(message[\"Cc\"])\n        bcc = prepare_header(message[\"Bcc\"])\n        reply_to = prepare_header(message[\"Reply-To\"])\n        tag = getattr(message, \"tag\", None)\n        return cls(\n            manager=manager,\n            From=sender,\n            To=to,\n            TextBody=text,\n            HtmlBody=html,\n            Subject=subject,\n            Cc=cc,\n            Bcc=bcc,\n            ReplyTo=reply_to,\n            Attachments=attachments,\n            Tag=tag,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert all available emails to dictionaries.", "response": "def as_dict(self, **extra):\n        \"\"\"\n        Converts all available emails to dictionaries.\n\n        :return: List of dictionaries.\n        \"\"\"\n        return [self._construct_email(email, **extra) for email in self.emails]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _construct_email(self, email, **extra):\n        if isinstance(email, dict):\n            email = Email(manager=self._manager, **email)\n        elif isinstance(email, (MIMEText, MIMEMultipart)):\n            email = Email.from_mime(email, self._manager)\n        elif not isinstance(email, Email):\n            raise ValueError\n        email._update(extra)\n        return email.as_dict()", "response": "Constructs a dictionary of data from incoming data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, **extra):\n        emails = self.as_dict(**extra)\n        responses = [self._manager._send_batch(*batch) for batch in chunks(emails, self.MAX_SIZE)]\n        return sum(responses, [])", "response": "Sends a batch of emails."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends an email message to the specified recipients.", "response": "def send(\n        self,\n        message=None,\n        From=None,\n        To=None,\n        Cc=None,\n        Bcc=None,\n        Subject=None,\n        Tag=None,\n        HtmlBody=None,\n        TextBody=None,\n        Metadata=None,\n        ReplyTo=None,\n        Headers=None,\n        TrackOpens=None,\n        TrackLinks=\"None\",\n        Attachments=None,\n    ):\n        \"\"\"\n        Sends a single email.\n\n        :param message: :py:class:`Email` or ``email.mime.text.MIMEText`` instance.\n        :param str From: The sender email address.\n        :param To: Recipient's email address.\n                   Multiple recipients could be specified as a list or string with comma separated values.\n        :type To: str or list\n        :param Cc: Cc recipient's email address.\n                   Multiple Cc recipients could be specified as a list or string with comma separated values.\n        :type Cc: str or list\n        :param Bcc: Bcc recipient's email address.\n                    Multiple Bcc recipients could be specified as a list or string with comma separated values.\n        :type Bcc: str or list\n        :param str Subject: Email subject.\n        :param str Tag: Email tag.\n        :param str HtmlBody: HTML email message.\n        :param str TextBody: Plain text email message.\n        :param str ReplyTo: Reply To override email address.\n        :param dict Headers: Dictionary of custom headers to include.\n        :param bool TrackOpens: Activate open tracking for this email.\n        :param str TrackLinks: Activate link tracking for links in the HTML or Text bodies of this email.\n        :param list Attachments: List of attachments.\n        :return: Information about sent email.\n        :rtype: `dict`\n        \"\"\"\n        assert not (message and (From or To)), \"You should specify either message or From and To parameters\"\n        assert TrackLinks in (\"None\", \"HtmlAndText\", \"HtmlOnly\", \"TextOnly\")\n        if message is None:\n            message = self.Email(\n                From=From,\n                To=To,\n                Cc=Cc,\n                Bcc=Bcc,\n                Subject=Subject,\n                Tag=Tag,\n                HtmlBody=HtmlBody,\n                TextBody=TextBody,\n                Metadata=Metadata,\n                ReplyTo=ReplyTo,\n                Headers=Headers,\n                TrackOpens=TrackOpens,\n                TrackLinks=TrackLinks,\n                Attachments=Attachments,\n            )\n        elif isinstance(message, (MIMEText, MIMEMultipart)):\n            message = Email.from_mime(message, self)\n        elif not isinstance(message, Email):\n            raise TypeError(\"message should be either Email or MIMEText or MIMEMultipart instance\")\n        return message.send()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs an email instance for the given related objects.", "response": "def Email(\n        self,\n        From,\n        To,\n        Cc=None,\n        Bcc=None,\n        Subject=None,\n        Tag=None,\n        HtmlBody=None,\n        TextBody=None,\n        Metadata=None,\n        ReplyTo=None,\n        Headers=None,\n        TrackOpens=None,\n        TrackLinks=\"None\",\n        Attachments=None,\n    ):\n        \"\"\"\n        Constructs :py:class:`Email` instance.\n\n        :return: :py:class:`Email`\n        \"\"\"\n        return Email(\n            manager=self,\n            From=From,\n            To=To,\n            Cc=Cc,\n            Bcc=Bcc,\n            Subject=Subject,\n            Tag=Tag,\n            HtmlBody=HtmlBody,\n            TextBody=TextBody,\n            Metadata=Metadata,\n            ReplyTo=ReplyTo,\n            Headers=Headers,\n            TrackOpens=TrackOpens,\n            TrackLinks=TrackLinks,\n            Attachments=Attachments,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing an email template instance.", "response": "def EmailTemplate(\n        self,\n        TemplateId,\n        TemplateModel,\n        From,\n        To,\n        TemplateAlias=None,\n        Cc=None,\n        Bcc=None,\n        Subject=None,\n        Tag=None,\n        ReplyTo=None,\n        Headers=None,\n        TrackOpens=None,\n        TrackLinks=\"None\",\n        Attachments=None,\n        InlineCss=True,\n    ):\n        \"\"\"\n        Constructs :py:class:`EmailTemplate` instance.\n\n        :return: :py:class:`EmailTemplate`\n        \"\"\"\n        return EmailTemplate(\n            manager=self,\n            TemplateId=TemplateId,\n            TemplateAlias=TemplateAlias,\n            TemplateModel=TemplateModel,\n            From=From,\n            To=To,\n            Cc=Cc,\n            Bcc=Bcc,\n            Subject=Subject,\n            Tag=Tag,\n            ReplyTo=ReplyTo,\n            Headers=Headers,\n            TrackOpens=TrackOpens,\n            TrackLinks=TrackLinks,\n            Attachments=Attachments,\n            InlineCss=InlineCss,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nactivate the bounce instance and updates the latest data.", "response": "def activate(self):\n        \"\"\"\n        Activates the bounce instance and updates it with the latest data.\n\n        :return: Activation status.\n        :rtype: `str`\n        \"\"\"\n        response = self._manager.activate(self.ID)\n        self._update(response[\"Bounce\"])\n        return response[\"Message\"]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all bounces for a given set of attributes.", "response": "def all(\n        self,\n        count=500,\n        offset=0,\n        type=None,\n        inactive=None,\n        emailFilter=None,\n        tag=None,\n        messageID=None,\n        fromdate=None,\n        todate=None,\n    ):\n        \"\"\"\n        Returns many bounces.\n\n        :param int count: Number of bounces to return per request.\n        :param int offset: Number of bounces to skip.\n        :param str type: Filter by type of bounce.\n        :param bool inactive: Filter by emails that were deactivated by Postmark due to the bounce.\n        :param str emailFilter: Filter by email address.\n        :param str tag: Filter by tag.\n        :param str messageID: Filter by messageID.\n        :param date fromdate: Filter messages starting from the date specified (inclusive).\n        :param date todate: Filter messages up to the date specified (inclusive).\n        :return: A list of :py:class:`Bounce` instances.\n        :rtype: `list`\n        \"\"\"\n        responses = self.call_many(\n            \"GET\",\n            \"/bounces/\",\n            count=count,\n            offset=offset,\n            type=type,\n            inactive=inactive,\n            emailFilter=emailFilter,\n            tag=tag,\n            messageID=messageID,\n            fromdate=fromdate,\n            todate=todate,\n        )\n        return self.expand_responses(responses, \"Bounces\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_kwargs(self, kwargs, count, offset):\n        kwargs.update({self.count_key: count, self.offset_key: offset})\n        return kwargs", "response": "Helper to support handy dictionaries merging on all Python versions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overview(self, tag=None, fromdate=None, todate=None):\n        return self.call(\"GET\", \"/stats/outbound\", tag=tag, fromdate=fromdate, todate=todate)", "response": "Gets a brief overview of all of your outbound email."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a total count of emails you ve sent out.", "response": "def sends(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets a total count of emails you\u2019ve sent out.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/sends\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bounces(self, tag=None, fromdate=None, todate=None):\n        return self.call(\"GET\", \"/stats/outbound/bounces\", tag=tag, fromdate=fromdate, todate=todate)", "response": "Gets the total number of emails that have been sent out that have been bounced."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the total number of recipients who have marked your email as spam.", "response": "def spam(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets a total count of recipients who have marked your email as spam.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/spam\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tracked(self, tag=None, fromdate=None, todate=None):\n        return self.call(\"GET\", \"/stats/outbound/tracked\", tag=tag, fromdate=fromdate, todate=todate)", "response": "Gets a total count of emails you have sent with open tracking or link tracking enabled."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the total number of recipients who opened your emails.", "response": "def opens(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets total counts of recipients who opened your emails.\n        This is only recorded when open tracking is enabled for that email.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/opens\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an overview of the platforms used to open your emails.", "response": "def opens_platforms(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets an overview of the platforms used to open your emails.\n        This is only recorded when open tracking is enabled for that email.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/opens/platforms\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emailclients(self, tag=None, fromdate=None, todate=None):\n        return self.call(\"GET\", \"/stats/outbound/opens/emailclients\", tag=tag, fromdate=fromdate, todate=todate)", "response": "Gets an overview of the email clients used to open your emails."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the total number of times that a given email was read.", "response": "def readtimes(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets the length of time that recipients read emails along with counts for each time.\n        This is only recorded when open tracking is enabled for that email.\n        Read time tracking stops at 20 seconds, so any read times above that will appear in the 20s+ field.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/opens/readtimes\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the total number of unique links that were clicked.", "response": "def clicks(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets total counts of unique links that were clicked.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/clicks\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting an overview of the browser families used to open links in your emails.", "response": "def browserfamilies(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets an overview of the browsers used to open links in your emails.\n        This is only recorded when Link Tracking is enabled for that email.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/clicks/browserfamilies\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an overview of the browser platforms used to open your emails.", "response": "def clicks_platforms(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets an overview of the browser platforms used to open your emails.\n        This is only recorded when Link Tracking is enabled for that email.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/clicks/platforms\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an overview of which part of the email links were clicked from.", "response": "def location(self, tag=None, fromdate=None, todate=None):\n        \"\"\"\n        Gets an overview of which part of the email links were clicked from (HTML or Text).\n        This is only recorded when Link Tracking is enabled for that email.\n        \"\"\"\n        return self.call(\"GET\", \"/stats/outbound/clicks/location\", tag=tag, fromdate=fromdate, todate=todate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef line_rate(self, filename=None):\n        if filename is None:\n            el = self.xml\n        else:\n            el = self._get_class_element_by_filename(filename)\n\n        return float(el.attrib['line-rate'])", "response": "Returns the global line rate of the coverage report."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the global branch rate of the coverage report.", "response": "def branch_rate(self, filename=None):\n        \"\"\"\n        Return the global branch rate of the coverage report. If the\n        `filename` file is given, return the branch rate of the file.\n        \"\"\"\n        if filename is None:\n            el = self.xml\n        else:\n            el = self._get_class_element_by_filename(filename)\n\n        return float(el.attrib['branch-rate'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of uncovered line numbers for each of the missed statements for the file filename.", "response": "def missed_statements(self, filename):\n        \"\"\"\n        Return a list of uncovered line numbers for each of the missed\n        statements found for the file `filename`.\n        \"\"\"\n        el = self._get_class_element_by_filename(filename)\n        lines = el.xpath('./lines/line[@hits=0]')\n        return [int(l.attrib['number']) for l in lines]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef line_statuses(self, filename):\n        line_elements = self._get_lines_by_filename(filename)\n\n        lines_w_status = []\n        for line in line_elements:\n            lineno = int(line.attrib['number'])\n            status = line.attrib['hits'] != '0'\n            lines_w_status.append((lineno, status))\n\n        return lines_w_status", "response": "Return a list of tuples that each element is a line number and a status of the line which can be coverageed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of extrapolated uncovered line numbers for the given file filename.", "response": "def missed_lines(self, filename):\n        \"\"\"\n        Return a list of extrapolated uncovered line numbers for the\n        file `filename` according to `Cobertura.line_statuses`.\n        \"\"\"\n        statuses = self.line_statuses(filename)\n        statuses = extrapolate_coverage(statuses)\n        return [lno for lno, status in statuses if status is False]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef file_source(self, filename):\n        lines = []\n        try:\n            with self.filesystem.open(filename) as f:\n                line_statuses = dict(self.line_statuses(filename))\n                for lineno, source in enumerate(f, start=1):\n                    line_status = line_statuses.get(lineno)\n                    line = Line(lineno, source, line_status, None)\n                    lines.append(line)\n\n        except self.filesystem.FileNotFound as file_not_found:\n            lines.append(\n                Line(0, '%s not found' % file_not_found.path, None, None)\n            )\n\n        return lines", "response": "Return a list of namedtuple Line for each line of code found in the\n            source file with the given filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef total_misses(self, filename=None):\n        if filename is not None:\n            return len(self.missed_statements(filename))\n\n        total = 0\n        for filename in self.files():\n            total += len(self.missed_statements(filename))\n\n        return total", "response": "Return the total number of uncovered statements for the file\n        filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef total_hits(self, filename=None):\n        if filename is not None:\n            return len(self.hit_statements(filename))\n\n        total = 0\n        for filename in self.files():\n            total += len(self.hit_statements(filename))\n\n        return total", "response": "Return the total number of covered statements for the file\n        filename."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef total_statements(self, filename=None):\n        if filename is not None:\n            statements = self._get_lines_by_filename(filename)\n            return len(statements)\n\n        total = 0\n        for filename in self.files():\n            statements = self._get_lines_by_filename(filename)\n            total += len(statements)\n\n        return total", "response": "Return the total number of statements for the file\n        filename."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef files(self):\n        # maybe replace with a trie at some point? see has_file FIXME\n        already_seen = set()\n        filenames = []\n\n        for el in self.xml.xpath(\"//class\"):\n            filename = el.attrib['filename']\n            if filename in already_seen:\n                continue\n            already_seen.add(filename)\n            filenames.append(filename)\n\n        return filenames", "response": "Return the list of available files in the coverage report."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of source lines of file filename.", "response": "def source_lines(self, filename):\n        \"\"\"\n        Return a list for source lines of file `filename`.\n        \"\"\"\n        with self.filesystem.open(filename) as f:\n            return f.readlines()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_better_coverage(self):\n        for filename in self.files():\n            if self.diff_total_misses(filename) > 0:\n                return False\n        return True", "response": "Return True if coverage of has improved False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if all changes have been covered False otherwise.", "response": "def has_all_changes_covered(self):\n        \"\"\"\n        Return `True` if all changes have been covered, `False` otherwise.\n        \"\"\"\n        for filename in self.files():\n            for hunk in self.file_source_hunks(filename):\n                for line in hunk:\n                    if line.reason is None:\n                        continue  # line untouched\n                    if line.status is False:\n                        return False  # line not covered\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _diff_attr(self, attr_name, filename):\n        if filename is not None:\n            files = [filename]\n        else:\n            files = self.files()\n\n        total_count = 0.0\n        for filename in files:\n            if self.cobertura1.has_file(filename):\n                method = getattr(self.cobertura1, attr_name)\n                count1 = method(filename)\n            else:\n                count1 = 0.0\n            method = getattr(self.cobertura2, attr_name)\n            count2 = method(filename)\n            total_count += count2 - count1\n\n        return total_count", "response": "Return the difference between the attributes of the related object and the file filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of 2 - element tuples where the lineno is a missed line number and is_new is True if the missed line was introduced or removed.", "response": "def diff_missed_lines(self, filename):\n        \"\"\"\n        Return a list of 2-element tuples `(lineno, is_new)` for the given\n        file `filename` where `lineno` is a missed line number and `is_new`\n        indicates whether the missed line was introduced (True) or removed\n        (False).\n        \"\"\"\n        line_changed = []\n        for line in self.file_source(filename):\n            if line.status is not None:\n                is_new = not line.status\n                line_changed.append((line.number, is_new))\n        return line_changed"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of namedtuple Line for each line of code found in the file filename.", "response": "def file_source(self, filename):\n        \"\"\"\n        Return a list of namedtuple `Line` for each line of code found in the\n        given file `filename`.\n\n        \"\"\"\n        if self.cobertura1.has_file(filename) and \\\n                self.cobertura1.filesystem.has_file(filename):\n            lines1 = self.cobertura1.source_lines(filename)\n            line_statuses1 = dict(self.cobertura1.line_statuses(\n                filename))\n        else:\n            lines1 = []\n            line_statuses1 = {}\n\n        lines2 = self.cobertura2.source_lines(filename)\n        line_statuses2 = dict(self.cobertura2.line_statuses(filename))\n\n        # Build a dict of lineno2 -> lineno1\n        lineno_map = reconcile_lines(lines2, lines1)\n\n        lines = []\n        for lineno, source in enumerate(lines2, start=1):\n            status = None\n            reason = None\n            if lineno not in lineno_map:\n                # line was added or removed, just use whatever coverage status\n                # is available as there is nothing to compare against.\n                status = line_statuses2.get(lineno)\n                reason = 'line-edit'\n            else:\n                other_lineno = lineno_map[lineno]\n                line_status1 = line_statuses1.get(other_lineno)\n                line_status2 = line_statuses2.get(lineno)\n                if line_status1 is line_status2:\n                    status = None  # unchanged\n                    reason = None\n                elif line_status1 is True and line_status2 is False:\n                    status = False  # decreased\n                    reason = 'cov-down'\n                elif line_status1 is False and line_status2 is True:\n                    status = True  # increased\n                    reason = 'cov-up'\n\n            line = Line(lineno, source, status, reason)\n            lines.append(line)\n\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_source_hunks(self, filename):\n        lines = self.file_source(filename)\n        hunks = hunkify_lines(lines)\n        return hunks", "response": "Like file_source but returns a list of line hunks that have changed for the given file filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nflushes the queue periodically.", "response": "def monitor(self):\n        \"\"\"Flushes the queue periodically.\"\"\"\n        while self.monitor_running.is_set():\n            if time.time() - self.last_flush > self.batch_time:\n                if not self.queue.empty():\n                    logger.info(\"Queue Flush: time without flush exceeded\")\n                    self.flush_queue()\n            time.sleep(self.batch_time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put_records(self, records, partition_key=None):\n        for record in records:\n            self.put_record(record, partition_key)", "response": "Adds a list of data records to the record queue in the proper format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding data to the record queue in the proper format.", "response": "def put_record(self, data, partition_key=None):\n        \"\"\"Add data to the record queue in the proper format.\n\n        Parameters\n        ----------\n        data : str\n            Data to send.\n        partition_key: str\n            Hash that determines which shard a given data record belongs to.\n\n        \"\"\"\n        # Byte encode the data\n        data = encode_data(data)\n\n        # Create a random partition key if not provided\n        if not partition_key:\n            partition_key = uuid.uuid4().hex\n\n        # Build the record\n        record = {\n            'Data': data,\n            'PartitionKey': partition_key\n        }\n\n        # Flush the queue if it reaches the batch size\n        if self.queue.qsize() >= self.batch_size:\n            logger.info(\"Queue Flush: batch size reached\")\n            self.pool.submit(self.flush_queue)\n\n        # Append the record\n        logger.debug('Putting record \"{}\"'.format(record['Data'][:100]))\n        self.queue.put(record)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nflushes the queue and waits for the executor to finish.", "response": "def close(self):\n        \"\"\"Flushes the queue and waits for the executor to finish.\"\"\"\n        logger.info('Closing producer')\n        self.flush_queue()\n        self.monitor_running.clear()\n        self.pool.shutdown()\n        logger.info('Producer closed')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flush_queue(self):\n        records = []\n\n        while not self.queue.empty() and len(records) < self.batch_size:\n            records.append(self.queue.get())\n\n        if records:\n            self.send_records(records)\n            self.last_flush = time.time()", "response": "Grab all the current records in the queue and send them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_records(self, records, attempt=0):\n\n        # If we already tried more times than we wanted, save to a file\n        if attempt > self.max_retries:\n            logger.warning('Writing {} records to file'.format(len(records)))\n            with open('failed_records.dlq', 'ab') as f:\n                for r in records:\n                    f.write(r.get('Data'))\n            return\n\n        # Sleep before retrying\n        if attempt:\n            time.sleep(2 ** attempt * .1)\n\n        response = self.kinesis_client.put_records(StreamName=self.stream_name,\n                                                   Records=records)\n        failed_record_count = response['FailedRecordCount']\n\n        # Grab failed records\n        if failed_record_count:\n            logger.warning('Retrying failed records')\n            failed_records = []\n            for i, record in enumerate(response['Records']):\n                if record.get('ErrorCode'):\n                    failed_records.append(records[i])\n\n            # Recursive call\n            attempt += 1\n            self.send_records(failed_records, attempt=attempt)", "response": "Send records to the Kinesis stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nassuming the list is sorted.", "response": "def rangify(number_list):\n    \"\"\"Assumes the list is sorted.\"\"\"\n    if not number_list:\n        return number_list\n\n    ranges = []\n\n    range_start = prev_num = number_list[0]\n    for num in number_list[1:]:\n        if num != (prev_num + 1):\n            ranges.append((range_start, prev_num))\n            range_start = num\n        prev_num = num\n\n    ranges.append((range_start, prev_num))\n    return ranges"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving the following input return the expanded lines with their extrapolated line status.", "response": "def extrapolate_coverage(lines_w_status):\n    \"\"\"\n    Given the following input:\n\n    >>> lines_w_status = [\n        (1, True),\n        (4, True),\n        (7, False),\n        (9, False),\n    ]\n\n    Return expanded lines with their extrapolated line status.\n\n    >>> extrapolate_coverage(lines_w_status) == [\n        (1, True),\n        (2, True),\n        (3, True),\n        (4, True),\n        (5, None),\n        (6, None),\n        (7, False),\n        (8, False),\n        (9, False),\n    ]\n\n    \"\"\"\n    lines = []\n\n    prev_lineno = 0\n    prev_status = True\n    for lineno, status in lines_w_status:\n        while (lineno - prev_lineno) > 1:\n            prev_lineno += 1\n            if prev_status is status:\n                lines.append((prev_lineno, status))\n            else:\n                lines.append((prev_lineno, None))\n        lines.append((lineno, status))\n        prev_lineno = lineno\n        prev_status = status\n\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dict that maps line numbers lineno1 to line numbers lineno2.", "response": "def reconcile_lines(lines1, lines2):\n    \"\"\"\n    Return a dict `{lineno1: lineno2}` which reconciles line numbers `lineno1`\n    of list `lines1` to line numbers `lineno2` of list `lines2`. Only lines\n    that are common in both sets are present in the dict, lines unique to one\n    of the sets are omitted.\n    \"\"\"\n    differ = difflib.Differ()\n    diff = differ.compare(lines1, lines2)\n\n    SAME = '  '\n    ADDED = '+ '\n    REMOVED = '- '\n    INFO = '? '\n\n    lineno_map = {}  # {lineno1: lineno2, ...}\n    lineno1_offset = 0\n    lineno2 = 1\n\n    for diffline in diff:\n        if diffline.startswith(INFO):\n            continue\n\n        if diffline.startswith(SAME):\n            lineno1 = lineno2 + lineno1_offset\n            lineno_map[lineno1] = lineno2\n\n        elif diffline.startswith(ADDED):\n            lineno1_offset -= 1\n\n        elif diffline.startswith(REMOVED):\n            lineno1_offset += 1\n            continue\n\n        lineno2 += 1\n\n    return lineno_map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hunkify_lines(lines, context=3):\n    # Find contiguous line changes\n    ranges = []\n    range_start = None\n    for i, line in enumerate(lines):\n        if line.status is not None:\n            if range_start is None:\n                range_start = i\n                continue\n        elif range_start is not None:\n            range_stop = i\n            ranges.append((range_start, range_stop))\n            range_start = None\n    else:\n        # Append the last range\n        if range_start is not None:\n            range_stop = i\n            ranges.append((range_start, range_stop))\n\n    # add context\n    ranges_w_context = []\n    for range_start, range_stop in ranges:\n        range_start = range_start - context\n        range_start = range_start if range_start >= 0 else 0\n        range_stop = range_stop + context\n        ranges_w_context.append((range_start, range_stop))\n\n    # merge overlapping hunks\n    merged_ranges = ranges_w_context[:1]\n    for range_start, range_stop in ranges_w_context[1:]:\n        prev_start, prev_stop = merged_ranges[-1]\n        if range_start <= prev_stop:\n            range_start = prev_start\n            merged_ranges[-1] = (range_start, range_stop)\n        else:\n            merged_ranges.append((range_start, range_stop))\n\n    # build final hunks\n    hunks = []\n    for range_start, range_stop in merged_ranges:\n        hunk = lines[range_start:range_stop]\n        hunks.append(hunk)\n\n    return hunks", "response": "Return a list of line hunks given a list of lines."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show(cobertura_file, format, output, source, source_prefix):\n    cobertura = Cobertura(cobertura_file, source=source)\n    Reporter = reporters[format]\n    reporter = Reporter(cobertura)\n    report = reporter.generate()\n\n    if not isinstance(report, bytes):\n        report = report.encode('utf-8')\n\n    isatty = True if output is None else output.isatty()\n    click.echo(report, file=output, nl=isatty)", "response": "show coverage summary of a Cobertura report"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares coverage of two Cobertura reports", "response": "def diff(\n        cobertura_file1, cobertura_file2,\n        color, format, output, source1, source2,\n        source_prefix1, source_prefix2, source):\n    \"\"\"compare coverage of two Cobertura reports\"\"\"\n    cobertura1 = Cobertura(\n        cobertura_file1,\n        source=source1,\n        source_prefix=source_prefix1\n    )\n    cobertura2 = Cobertura(\n        cobertura_file2,\n        source=source2,\n        source_prefix=source_prefix2\n    )\n\n    Reporter = delta_reporters[format]\n    reporter_args = [cobertura1, cobertura2]\n    reporter_kwargs = {'show_source': source}\n\n    isatty = True if output is None else output.isatty()\n\n    if format == 'text':\n        color = isatty if color is None else color is True\n        reporter_kwargs['color'] = color\n\n    reporter = Reporter(*reporter_args, **reporter_kwargs)\n    report = reporter.generate()\n\n    if not isinstance(report, bytes):\n        report = report.encode('utf-8')\n\n    click.echo(report, file=output, nl=isatty, color=color)\n\n    exit_code = get_exit_code(reporter.differ, source)\n    raise SystemExit(exit_code)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open(self, filename):\n        filename = self.real_filename(filename)\n\n        if not os.path.exists(filename):\n            raise self.FileNotFound(filename)\n\n        with codecs.open(filename, encoding='utf-8') as f:\n            yield f", "response": "Yield a file - like object for filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninject a message into a topic.", "response": "def topic_inject(self, topic_name, _msg_content=None, **kwargs):\n        \"\"\"\n        Injecting message into topic. if _msg_content, we inject it directly. if not, we use all extra kwargs\n        :param topic_name: name of the topic\n        :param _msg_content: optional message content\n        :param kwargs: each extra kwarg will be put int he message is structure matches\n        :return:\n        \"\"\"\n        #changing unicode to string ( testing stability of multiprocess debugging )\n        if isinstance(topic_name, unicode):\n            topic_name = unicodedata.normalize('NFKD', topic_name).encode('ascii', 'ignore')\n\n        if _msg_content is not None:\n            # logging.warn(\"injecting {msg} into {topic}\".format(msg=_msg_content, topic=topic_name))\n            res = self.topic_svc.call(args=(topic_name, _msg_content,))\n        else:  # default kwargs is {}\n            # logging.warn(\"injecting {msg} into {topic}\".format(msg=kwargs, topic=topic_name))\n            res = self.topic_svc.call(args=(topic_name, kwargs,))\n\n        return res is None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the value of a parameter in a topic.", "response": "def param_set(self, param_name, _value=None, **kwargs):\n        \"\"\"\n        Setting parameter. if _value, we inject it directly. if not, we use all extra kwargs\n        :param topic_name: name of the topic\n        :param _value: optional value\n        :param kwargs: each extra kwarg will be put in the value if structure matches\n        :return:\n        \"\"\"\n        #changing unicode to string ( testing stability of multiprocess debugging )\n        if isinstance(param_name, unicode):\n            param_name = unicodedata.normalize('NFKD', param_name).encode('ascii', 'ignore')\n\n        _value = _value or {}\n\n        if kwargs:\n            res = self.param_svc.call(args=(param_name, kwargs,))\n        elif _value is not None:\n            res = self.param_svc.call(args=(param_name, _value,))\n        else:   # if _msg_content is None the request is invalid.\n                # just return something to mean False.\n            res = 'WRONG SET'\n\n        return res is None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(interface, config, logfile, ros_args):\n    logging.info(\n        'pyros started with : interface {interface} config {config} logfile {logfile} ros_args {ros_args}'.format(\n            interface=interface, config=config, logfile=logfile, ros_args=ros_args))\n\n    if interface == 'ros':\n        node_proc = pyros_rosinterface_launch(node_name='pyros_rosinterface', pyros_config=config, ros_argv=ros_args)\n    else:\n        node_proc = None  # NOT IMPLEMENTED\n\n    # node_proc.daemon = True  # we do NOT want a daemon(would stop when this main process exits...)\n    client_conn = node_proc.start()", "response": "Start a pyros node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring nick user host in kwargs", "response": "def nickmask(prefix: str, kwargs: Dict[str, Any]) -> None:\n    \"\"\" store nick, user, host in kwargs if prefix is correct format \"\"\"\n    if \"!\" in prefix and \"@\" in prefix:\n        # From a user\n        kwargs[\"nick\"], remainder = prefix.split(\"!\", 1)\n        kwargs[\"user\"], kwargs[\"host\"] = remainder.split(\"@\", 1)\n    else:\n        # From a server, probably the host\n        kwargs[\"host\"] = prefix"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef split_line(msg: str) -> Tuple[str, str, List[str]]:\n    match = RE_IRCLINE.match(msg)\n    if not match:\n        raise ValueError(\"Invalid line\")\n\n    prefix = match.group(\"prefix\") or \"\"\n    command = match.group(\"command\")\n    params = (match.group(\"params\") or \"\").split()\n    message = match.group(\"message\") or \"\"\n\n    if message:\n        params.append(message)\n\n    return prefix, command, params", "response": "Parse a line of text according to RFC 2812 for routing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef b(field: str, kwargs: Dict[str, Any],\n      present: Optional[Any] = None, missing: Any = '') -> str:\n    \"\"\"\n    Return `present` value (default to `field`) if `field` in `kwargs` and\n    Truthy, otherwise return `missing` value\n    \"\"\"\n    if kwargs.get(field):\n        return field if present is None else str(present)\n    return str(missing)", "response": "Return the value of a field in the order they appear in the order they appear in."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naliases for more readable command construction", "response": "def f(field: str, kwargs: Dict[str, Any],\n      default: Optional[Any] = None) -> str:\n    \"\"\" Alias for more readable command construction \"\"\"\n    if default is not None:\n        return str(kwargs.get(field, default))\n    return str(kwargs[field])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pack(field: str, kwargs: Dict[str, Any],\n         default: Optional[Any] = None, sep: str=',') -> str:\n    \"\"\" Util for joining multiple fields with commas \"\"\"\n    if default is not None:\n        value = kwargs.get(field, default)\n    else:\n        value = kwargs[field]\n    if isinstance(value, str):\n        return value\n    elif isinstance(value, collections.abc.Iterable):\n        return sep.join(str(f) for f in value)\n    else:\n        return str(value)", "response": "Util for joining multiple fields with commas"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npack a command to send to an IRC server", "response": "def pack_command(command: str, **kwargs: Any) -> str:\n    \"\"\" Pack a command to send to an IRC server \"\"\"\n    if not command:\n        raise ValueError(\"Must provide a command\")\n    if not isinstance(command, str):\n        raise ValueError(\"Command must be a string\")\n    command = command.upper()\n\n    # ========================================================================\n    # For each command, provide:\n    #  1. a link to the definition in rfc2812\n    #  2. the normalized grammar, which may not equate to the rfc grammar\n    #     the normalized grammar will use the keys expected in kwargs,\n    #     which usually do NOT line up with rfc2812.  They may also make\n    #     optional fields which are required in rfc2812, by providing\n    #     the most common or reasonable defaults.\n    #  3. exhaustive examples, preferring normalized form of\n    #     the rfc2812 examples\n    # ========================================================================\n\n    # ========================================================================\n    # Normalized grammar:\n    # : should not be provided; it denotes the beginning of the last\n    #   field, which may contain spaces\n    # [] indicates an optional field\n    # <> denote the key that the field will be filled with\n    # because fields are filled from a dict, required fields may follow\n    #   optional fields - see USER command, where mode is optional\n    #   (and defaults to 0)\n    # \"\" indicates a literal value that is inserted if present\n    # ========================================================================\n\n    # PASS\n    # https://tools.ietf.org/html/rfc2812#section-3.1.1\n    # PASS <password>\n    # ----------\n    # PASS secretpasswordhere\n    if command == \"PASS\":\n        return \"PASS \" + f(\"password\", kwargs)\n\n    # NICK\n    # https://tools.ietf.org/html/rfc2812#section-3.1.2\n    # NICK <nick>\n    # ----------\n    # NICK Wiz\n    elif command == \"NICK\":\n        return \"NICK \" + f(\"nick\", kwargs)\n\n    # USER\n    # https://tools.ietf.org/html/rfc2812#section-3.1.3\n    # USER <user> [<mode>] :<realname>\n    # ----------\n    # USER guest 8 :Ronnie Reagan\n    # USER guest :Ronnie Reagan\n    elif command == \"USER\":\n        return \"USER {} {} * :{}\".format(\n            f(\"user\", kwargs),\n            f(\"mode\", kwargs, 0),\n            f(\"realname\", kwargs))\n\n    # OPER\n    # https://tools.ietf.org/html/rfc2812#section-3.1.4\n    # OPER <user> <password>\n    # ----------\n    # OPER AzureDiamond hunter2\n    elif command == \"OPER\":\n        return \"OPER {} {}\".format(f(\"user\", kwargs), f(\"password\", kwargs))\n\n    # USERMODE (renamed from MODE)\n    # https://tools.ietf.org/html/rfc2812#section-3.1.5\n    # MODE <nick> [<modes>]\n    # ----------\n    # MODE WiZ -w\n    # MODE Angel +i\n    # MODE\n    elif command == \"USERMODE\":\n        return \"MODE {} {}\".format(f(\"nick\", kwargs), f(\"modes\", kwargs, ''))\n\n    # SERVICE\n    # https://tools.ietf.org/html/rfc2812#section-3.1.6\n    # SERVICE <nick> <distribution> <type> :<info>\n    # ----------\n    # SERVICE dict *.fr 0 :French\n    elif command == \"SERVICE\":\n        return \"SERVICE {} * {} {} 0 :{}\".format(\n            f(\"nick\", kwargs),\n            f(\"distribution\", kwargs),\n            f(\"type\", kwargs),\n            f(\"info\", kwargs))\n\n    # QUIT\n    # https://tools.ietf.org/html/rfc2812#section-3.1.7\n    # QUIT :[<message>]\n    # ----------\n    # QUIT :Gone to lunch\n    # QUIT\n    elif command == \"QUIT\":\n        if \"message\" in kwargs:\n            return \"QUIT :\" + f(\"message\", kwargs)\n        return \"QUIT\"\n\n    # SQUIT\n    # https://tools.ietf.org/html/rfc2812#section-3.1.8\n    # SQUIT <server> [<message>]\n    # ----------\n    # SQUIT tolsun.oulu.fi :Bad Link\n    # SQUIT tolsun.oulu.fi\n    elif command == \"SQUIT\":\n        base = \"SQUIT \" + f(\"server\", kwargs)\n        if \"message\" in kwargs:\n            return base + \" :\" + f(\"message\", kwargs)\n        return base\n\n    # JOIN\n    # https://tools.ietf.org/html/rfc2812#section-3.2.1\n    # JOIN <channel> [<key>]\n    # ----------\n    # JOIN #foo fookey\n    # JOIN #foo\n    # JOIN 0\n    elif command == \"JOIN\":\n        return \"JOIN {} {}\".format(pack(\"channel\", kwargs),\n                                   pack(\"key\", kwargs, ''))\n\n    # PART\n    # https://tools.ietf.org/html/rfc2812#section-3.2.2\n    # PART <channel> :[<message>]\n    # ----------\n    # PART #foo :I lost\n    # PART #foo\n    elif command == \"PART\":\n        base = \"PART \" + pack(\"channel\", kwargs)\n        if \"message\" in kwargs:\n            return base + \" :\" + f(\"message\", kwargs)\n        return base\n\n    # CHANNELMODE (renamed from MODE)\n    # https://tools.ietf.org/html/rfc2812#section-3.2.3\n    # MODE <channel> <modes> [<params>]\n    # ----------\n    # MODE #Finnish +imI *!*@*.fi\n    # MODE #en-ops +v WiZ\n    # MODE #Fins -s\n    elif command == \"CHANNELMODE\":\n        return \"MODE {} {} {}\".format(f(\"channel\", kwargs),\n                                      f(\"modes\", kwargs),\n                                      f(\"params\", kwargs, ''))\n\n    # TOPIC\n    # https://tools.ietf.org/html/rfc2812#section-3.2.4\n    # TOPIC <channel> :[<message>]\n    # ----------\n    # TOPIC #test :New topic\n    # TOPIC #test :\n    # TOPIC #test\n    elif command == \"TOPIC\":\n        base = \"TOPIC \" + f(\"channel\", kwargs)\n        if \"message\" in kwargs:\n            return base + \" :\" + f(\"message\", kwargs)\n        return base\n\n    # NAMES\n    # https://tools.ietf.org/html/rfc2812#section-3.2.5\n    # NAMES [<channel>] [<target>]\n    # ----------\n    # NAMES #twilight_zone remote.*.edu\n    # NAMES #twilight_zone\n    # NAMES\n    elif command == \"NAMES\":\n        if \"channel\" in kwargs:\n            return \"NAMES {} {}\".format(pack(\"channel\", kwargs),\n                                        f(\"target\", kwargs, ''))\n        return \"NAMES\"\n\n    # LIST\n    # https://tools.ietf.org/html/rfc2812#section-3.2.6\n    # LIST [<channel>] [<target>]\n    # ----------\n    # LIST #twilight_zone remote.*.edu\n    # LIST #twilight_zone\n    # LIST\n    elif command == \"LIST\":\n        if \"channel\" in kwargs:\n            return \"LIST {} {}\".format(pack(\"channel\", kwargs),\n                                       f(\"target\", kwargs, ''))\n        return \"LIST\"\n\n    # INVITE\n    # https://tools.ietf.org/html/rfc2812#section-3.2.7\n    # INVITE <nick> <channel>\n    # ----------\n    # INVITE Wiz #Twilight_Zone\n    elif command == \"INVITE\":\n        return \"INVITE {} {}\".format(f(\"nick\", kwargs),\n                                     f(\"channel\", kwargs))\n\n    # KICK\n    # https://tools.ietf.org/html/rfc2812#section-3.2.8\n    # KICK <channel> <nick> :[<message>]\n    # ----------\n    # KICK #Finnish WiZ :Speaking English\n    # KICK #Finnish WiZ,Wiz-Bot :Both speaking English\n    # KICK #Finnish,#English WiZ,ZiW :Speaking wrong language\n    elif command == \"KICK\":\n        base = \"KICK {} {}\".format(pack(\"channel\", kwargs),\n                                   pack(\"nick\", kwargs))\n        if \"message\" in kwargs:\n            return base + \" :\" + pack(\"message\", kwargs)\n        return base\n\n    # PRIVMSG\n    # https://tools.ietf.org/html/rfc2812#section-3.3.1\n    # PRIVMSG <target> :<message>\n    # ----------\n    # PRIVMSG Angel :yes I'm receiving it !\n    # PRIVMSG $*.fi :Server tolsun.oulu.fi rebooting.\n    # PRIVMSG #Finnish :This message is in english\n    elif command == \"PRIVMSG\":\n        return \"PRIVMSG {} :{}\".format(f(\"target\", kwargs),\n                                       f(\"message\", kwargs))\n\n    # NOTICE\n    # https://tools.ietf.org/html/rfc2812#section-3.3.2\n    # NOTICE <target> :<message>\n    # ----------\n    # NOTICE Angel :yes I'm receiving it !\n    # NOTICE $*.fi :Server tolsun.oulu.fi rebooting.\n    # NOTICE #Finnish :This message is in english\n    elif command == \"NOTICE\":\n        return \"NOTICE {} :{}\".format(f(\"target\", kwargs),\n                                      f(\"message\", kwargs))\n\n    # MOTD\n    # https://tools.ietf.org/html/rfc2812#section-3.4.1\n    # MOTD [<target>]\n    # ----------\n    # MOTD remote.*.edu\n    # MOTD\n    elif command == \"MOTD\":\n        return \"MOTD \" + f(\"target\", kwargs, '')\n\n    # LUSERS\n    # https://tools.ietf.org/html/rfc2812#section-3.4.2\n    # LUSERS [<mask>] [<target>]\n    # ----------\n    # LUSERS *.edu remote.*.edu\n    # LUSERS *.edu\n    # LUSERS\n    elif command == \"LUSERS\":\n        if \"mask\" in kwargs:\n            return \"LUSERS {} {}\".format(f(\"mask\", kwargs),\n                                         f(\"target\", kwargs, ''))\n        return \"LUSERS\"\n\n    # VERSION\n    # https://tools.ietf.org/html/rfc2812#section-3.4.3\n    # VERSION [<target>]\n    # ----------\n    # VERSION remote.*.edu\n    # VERSION\n    elif command == \"VERSION\":\n        return \"VERSION \" + f(\"target\", kwargs, '')\n\n    # STATS\n    # https://tools.ietf.org/html/rfc2812#section-3.4.4\n    # STATS [<query>] [<target>]\n    # ----------\n    # STATS m remote.*.edu\n    # STATS m\n    # STATS\n    elif command == \"STATS\":\n        if \"query\" in kwargs:\n            return \"STATS {} {}\".format(f(\"query\", kwargs),\n                                        f(\"target\", kwargs, ''))\n        return \"STATS\"\n\n    # LINKS\n    # https://tools.ietf.org/html/rfc2812#section-3.4.5\n    # LINKS [<remote>] [<mask>]\n    # ----------\n    # LINKS *.edu *.bu.edu\n    # LINKS *.au\n    # LINKS\n    elif command == \"LINKS\":\n        if \"remote\" in kwargs:\n            return \"LINKS {} {}\".format(f(\"remote\", kwargs), f(\"mask\", kwargs))\n        elif \"mask\" in kwargs:\n            return \"LINKS \" + f(\"mask\", kwargs)\n        return \"LINKS\"\n\n    # TIME\n    # https://tools.ietf.org/html/rfc2812#section-3.4.6\n    # TIME [<target>]\n    # ----------\n    # TIME remote.*.edu\n    # TIME\n    elif command == \"TIME\":\n        return \"TIME \" + f(\"target\", kwargs, '')\n\n    # CONNECT\n    # https://tools.ietf.org/html/rfc2812#section-3.4.7\n    # CONNECT <target> <port> [<remote>]\n    # ----------\n    # CONNECT tolsun.oulu.fi 6667 *.edu\n    # CONNECT tolsun.oulu.fi 6667\n    elif command == \"CONNECT\":\n        return \"CONNECT {} {} {}\".format(f(\"target\", kwargs),\n                                         f(\"port\", kwargs),\n                                         f(\"remote\", kwargs, ''))\n\n    # TRACE\n    # https://tools.ietf.org/html/rfc2812#section-3.4.8\n    # TRACE [<target>]\n    # ----------\n    # TRACE\n    elif command == \"TRACE\":\n        return \"TRACE \" + f(\"target\", kwargs, '')\n\n    # ADMIN\n    # https://tools.ietf.org/html/rfc2812#section-3.4.9\n    # ADMIN [<target>]\n    # ----------\n    # ADMIN\n    elif command == \"ADMIN\":\n        return \"ADMIN \" + f(\"target\", kwargs, '')\n\n    # INFO\n    # https://tools.ietf.org/html/rfc2812#section-3.4.10\n    # INFO [<target>]\n    # ----------\n    # INFO\n    elif command == \"INFO\":\n        return \"INFO \" + f(\"target\", kwargs, '')\n\n    # SERVLIST\n    # https://tools.ietf.org/html/rfc2812#section-3.5.1\n    # SERVLIST [<mask>] [<type>]\n    # ----------\n    # SERVLIST *SERV 3\n    # SERVLIST *SERV\n    # SERVLIST\n    elif command == \"SERVLIST\":\n        return \"SERVLIST {} {}\".format(f(\"mask\", kwargs, ''),\n                                       f(\"type\", kwargs, ''))\n\n    # SQUERY\n    # https://tools.ietf.org/html/rfc2812#section-3.5.2\n    # SQUERY <target> :<message>\n    # ----------\n    # SQUERY irchelp :HELP privmsg\n    elif command == \"SQUERY\":\n        return \"SQUERY {} :{}\".format(f(\"target\", kwargs),\n                                      f(\"message\", kwargs))\n\n    # WHO\n    # https://tools.ietf.org/html/rfc2812#section-3.6.1\n    # WHO [<mask>] [\"o\"]\n    # ----------\n    # WHO jto* o\n    # WHO *.fi\n    # WHO\n    elif command == \"WHO\":\n        return \"WHO {} {}\".format(f(\"mask\", kwargs, ''), b(\"o\", kwargs))\n\n    # WHOIS\n    # https://tools.ietf.org/html/rfc2812#section-3.6.2\n    # WHOIS <mask> [<target>]\n    # ----------\n    # WHOIS jto* o remote.*.edu\n    # WHOIS jto* o\n    # WHOIS *.fi\n    elif command == \"WHOIS\":\n        return \"WHOIS {} {}\".format(pack(\"mask\", kwargs),\n                                    f(\"target\", kwargs, ''))\n\n    # WHOWAS\n    # https://tools.ietf.org/html/rfc2812#section-3.6.3\n    # WHOWAS <nick> [<count>] [<target>]\n    # ----------\n    # WHOWAS Wiz 9 remote.*.edu\n    # WHOWAS Wiz 9\n    # WHOWAS Mermaid\n    elif command == \"WHOWAS\":\n        if \"count\" in kwargs:\n            return \"WHOWAS {} {} {}\".format(pack(\"nick\", kwargs),\n                                            f(\"count\", kwargs),\n                                            f(\"target\", kwargs, ''))\n        return \"WHOWAS \" + pack(\"nick\", kwargs)\n\n    # KILL\n    # https://tools.ietf.org/html/rfc2812#section-3.7.1\n    # KILL <nick> :<message>\n    # ----------\n    # KILL WiZ :Spamming joins\n    elif command == \"KILL\":\n        return \"KILL {} :{}\".format(f(\"nick\", kwargs), f(\"message\", kwargs))\n\n    # PING\n    # https://tools.ietf.org/html/rfc2812#section-3.7.2\n    # PING :[<message>]\n    # ----------\n    # PING :I'm still here\n    # PING\n    elif command == \"PING\":\n        if \"message\" in kwargs:\n            return \"PING :{}\".format(f(\"message\", kwargs))\n        else:\n            return \"PING\"\n\n    # PONG\n    # https://tools.ietf.org/html/rfc2812#section-3.7.3\n    # PONG :[<message>]\n    # ----------\n    # PONG :I'm still here\n    # PONG\n    elif command == \"PONG\":\n        if \"message\" in kwargs:\n            return \"PONG :{}\".format(f(\"message\", kwargs))\n        else:\n            return \"PONG\"\n\n    # AWAY\n    # https://tools.ietf.org/html/rfc2812#section-4.1\n    # AWAY :[<message>]\n    # ----------\n    # AWAY :Gone to lunch.\n    # AWAY\n    elif command == \"AWAY\":\n        if \"message\" in kwargs:\n            return \"AWAY :\" + f(\"message\", kwargs)\n        return \"AWAY\"\n\n    # REHASH\n    # https://tools.ietf.org/html/rfc2812#section-4.2\n    # REHASH\n    # ----------\n    # REHASH\n    elif command == \"REHASH\":\n        return \"REHASH\"\n\n    # DIE\n    # https://tools.ietf.org/html/rfc2812#section-4.3\n    # DIE\n    # ----------\n    # DIE\n    elif command == \"DIE\":\n        return \"DIE\"\n\n    # RESTART\n    # https://tools.ietf.org/html/rfc2812#section-4.4\n    # RESTART\n    # ----------\n    # RESTART\n    elif command == \"RESTART\":\n        return \"RESTART\"\n\n    # SUMMON\n    # https://tools.ietf.org/html/rfc2812#section-4.5\n    # SUMMON <nick> [<target>] [<channel>]\n    # ----------\n    # SUMMON Wiz remote.*.edu #Finnish\n    # SUMMON Wiz remote.*.edu\n    # SUMMON Wiz\n    elif command == \"SUMMON\":\n        if \"target\" in kwargs:\n            return \"SUMMON {} {} {}\".format(f(\"nick\", kwargs),\n                                            f(\"target\", kwargs),\n                                            f(\"channel\", kwargs, ''))\n        return \"SUMMON \" + f(\"nick\", kwargs)\n\n    # USERS\n    # https://tools.ietf.org/html/rfc2812#section-4.6\n    # USERS [<target>]\n    # ----------\n    # USERS remote.*.edu\n    # USERS\n    elif command == \"USERS\":\n        return \"USERS \" + f(\"target\", kwargs, '')\n\n    # WALLOPS\n    # https://tools.ietf.org/html/rfc2812#section-4.7\n    # WALLOPS :<message>\n    # ----------\n    # WALLOPS :Maintenance in 5 minutes\n    elif command == \"WALLOPS\":\n        return \"WALLOPS :\" + f(\"message\", kwargs)\n\n    # USERHOST\n    # https://tools.ietf.org/html/rfc2812#section-4.8\n    # USERHOST <nick>\n    # ----------\n    # USERHOST Wiz Michael syrk\n    # USERHOST syrk\n    elif command == \"USERHOST\":\n        return \"USERHOST \" + pack(\"nick\", kwargs, sep=\" \")\n\n    # ISON\n    # https://tools.ietf.org/html/rfc2812#section-4.9\n    # ISON <nick>\n    # ----------\n    # ISON Wiz Michael syrk\n    # ISON syrk\n    elif command == \"ISON\":\n        return \"ISON \" + pack(\"nick\", kwargs, sep=\" \")\n\n    else:\n        raise ValueError(\"Unknown command '{}'\".format(command))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def connect(self) -> None:\n        def protocol_factory() -> Protocol:\n            return Protocol(client=self)\n\n        _, protocol = await self.loop.create_connection(\n            protocol_factory,\n            host=self.host,\n            port=self.port,\n            ssl=self.ssl\n        )  # type: Tuple[Any, Any]\n        if self.protocol:\n            self.protocol.close()\n        self.protocol = protocol\n        # TODO: Delete the following code line. It is currently kept in order\n        # to not break the current existing codebase. Removing it requires a\n        # heavy change in the test codebase.\n        protocol.client = self\n        self.trigger(\"client_connect\")", "response": "Open a connection to the defined server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntriggers all handlers for an event to execute", "response": "def trigger(self, event: str, **kwargs: Any) -> None:\n        \"\"\"Trigger all handlers for an event to (asynchronously) execute\"\"\"\n        event = event.upper()\n        for func in self._event_handlers[event]:\n            self.loop.create_task(func(**kwargs))\n        # This will unblock anyone that is awaiting on the next loop update,\n        # while still ensuring the next `await client.wait(event)` doesn't\n        # immediately fire.\n        async_event = self._events[event]\n        async_event.set()\n        async_event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecorates a function to be invoked when the given event occurs. The function may be a coroutine. Your function should accept **kwargs in case an event is triggered with unexpected kwargs. Example ------- import asyncio import bottom client = bottom.Client(...) @client.on(\"test\") async def func(one, two, **kwargs): print(one) print(two) print(kwargs) events.trigger(\"test\", **{\"one\": 1, \"two\": 2, \"extra\": \"foo\"}) loop = asyncio.get_event_loop() # Run all queued events loop.stop() loop.run_forever()", "response": "def on(self, event: str, func: Optional[Callable] = None) -> Callable:\n        \"\"\"\n        Decorate a function to be invoked when the given event occurs.\n\n        The function may be a coroutine.  Your function should accept **kwargs\n        in case an event is triggered with unexpected kwargs.\n\n        Example\n        -------\n        import asyncio\n        import bottom\n\n        client = bottom.Client(...)\n        @client.on(\"test\")\n        async def func(one, two, **kwargs):\n            print(one)\n            print(two)\n            print(kwargs)\n\n        events.trigger(\"test\", **{\"one\": 1, \"two\": 2, \"extra\": \"foo\"})\n        loop = asyncio.get_event_loop()\n        # Run all queued events\n        loop.stop()\n        loop.run_forever()\n        \"\"\"\n        if func is None:\n            return functools.partial(self.on, event)  # type: ignore\n        wrapped = func\n        if not asyncio.iscoroutinefunction(wrapped):\n            wrapped = asyncio.coroutine(wrapped)\n        self._event_handlers[event.upper()].append(wrapped)\n        # Always return original\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, command: str, **kwargs: Any) -> None:\n        packed_command = pack_command(command, **kwargs).strip()\n        self.send_raw(packed_command)", "response": "Send a message to the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle(self, nick, target, message, **kwargs):\n        for regex, (func, pattern) in self.routes.items():\n            match = regex.match(message)\n            if match:\n                self.client.loop.create_task(\n                    func(nick, target, message, match, **kwargs))", "response": "handle a message from the client"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n\n    fcodes = collections.OrderedDict((\n        ('f.i', protocol.FLG_FORMAT_FDI),\n        ('fi', protocol.FLG_FORMAT_FI),\n        ('f.i.c', protocol.FLG_FORMAT_FDIDC),\n        ('f.ic', protocol.FLG_FORMAT_FDIC),\n        ('fi.c', protocol.FLG_FORMAT_FIDC),\n        ('fic', protocol.FLG_FORMAT_FIC), ))\n\n    def make_parser():\n        # command line parsing\n\n        parser = argparse.ArgumentParser()\n\n        # positional args\n        parser.add_argument('uri', metavar='URI', nargs='?', default='/',\n                            help='[owserver:]//hostname:port/path')\n\n        # optional args for temperature scale\n        parser.set_defaults(t_flags=protocol.FLG_TEMP_C)\n        tempg = parser.add_mutually_exclusive_group()\n        tempg.add_argument('-C', '--Celsius', const=protocol.FLG_TEMP_C,\n                           help='Celsius(default) temperature scale',\n                           dest='t_flags', action='store_const', )\n        tempg.add_argument('-F', '--Fahrenheit', const=protocol.FLG_TEMP_F,\n                           help='Fahrenheit temperature scale',\n                           dest='t_flags', action='store_const', )\n        tempg.add_argument('-K', '--Kelvin', const=protocol.FLG_TEMP_K,\n                           help='Kelvin temperature scale',\n                           dest='t_flags', action='store_const', )\n        tempg.add_argument('-R', '--Rankine', const=protocol.FLG_TEMP_R,\n                           help='Rankine temperature scale',\n                           dest='t_flags', action='store_const', )\n\n        # optional arg for address format\n        parser.set_defaults(format='f.i')\n        parser.add_argument('-f', '--format', choices=fcodes,\n                            help='format for 1-wire unique serial IDs display')\n\n        # optional arg for output format\n        tempg = parser.add_mutually_exclusive_group()\n        tempg.add_argument('--hex', action='store_true',\n                           help='write data in hex format')\n        tempg.add_argument('-b', '--binary', action='store_true',\n                           help='output binary data')\n\n        # debug output\n        parser.add_argument('-d', '--debug', action='store_true',\n                            help='debug output')\n\n        return parser\n\n    def print_data(data):\n        # format and print data\n\n        if args.binary:\n            if sys.version_info < (3, ):\n                sys.stdout.write(data)\n            else:\n                sys.stdout.buffer.write(data)\n        else:\n            if args.hex:\n                data = hexlify(data)\n            else:\n                try:\n                    data = data.decode('ascii')\n                except UnicodeDecodeError:\n                    data = repr(data)\n            print(data)\n\n    #\n    # main program starts here\n    #\n\n    #\n    # parse command line arguments\n    #\n    parser = make_parser()\n    args = parser.parse_args()\n\n    #\n    # parse args.uri and substitute defaults\n    #\n    urlc = urlsplit(args.uri, scheme='owserver', allow_fragments=False)\n    assert urlc.fragment == ''\n    if urlc.scheme != 'owserver':\n        parser.error(\"Invalid URI scheme '{0}:'\".format(urlc.scheme))\n    if urlc.query:\n        parser.error(\"Invalid URI, query component '?{0}' not allowed\"\n                     .format(urlc.query))\n    try:\n        host = urlc.hostname or 'localhost'\n        port = urlc.port or 4304\n    except ValueError as error:\n        parser.error(\"Invalid URI: invalid net location '//{0}/'\"\n                     .format(urlc.netloc))\n\n    #\n    # create owserver proxy object\n    #\n    try:\n        owproxy = protocol.proxy(\n            host, port, flags=args.t_flags | fcodes[args.format],\n            verbose=args.debug, )\n    except protocol.ConnError as error:\n        print(\"Unable to open connection to '{0}:{1}'\\nSystem error: {2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)\n    except protocol.ProtocolError as error:\n        print(\"'{0}:{1}' not an owserver?\\nProtocol error: {2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)\n\n    #\n    # query owserver and print results\n    #\n    try:\n        if urlc.path.endswith('/'):\n            for path in owproxy.dir(urlc.path, bus=True):\n                print(path)\n        else:\n            data = owproxy.read(urlc.path)\n            print_data(data)\n    except protocol.OwnetError as error:\n        print(\"Remote server error: {2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)\n    except protocol.ProtocolError as error:\n        print(\"'{0}:{1}' buggy?\\nProtocol error: {2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)", "response": "parse commandline arguments and print result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse commandline arguments and print result", "response": "def main():\n    \"\"\"parse commandline arguments and print result\"\"\"\n\n    #\n    # setup command line parsing a la argpase\n    #\n    parser = argparse.ArgumentParser()\n\n    # positional args\n    parser.add_argument('uri', metavar='URI', nargs='?', default='/',\n                        help='[owserver:]//hostname:port/path')\n\n    #\n    # parse command line args\n    #\n    args = parser.parse_args()\n\n    #\n    # parse args.uri and substitute defaults\n    #\n    urlc = urlsplit(args.uri, scheme='owserver', allow_fragments=False)\n    assert urlc.fragment == ''\n    if urlc.scheme != 'owserver':\n        parser.error(\"Invalid URI scheme '{0}:'\".format(urlc.scheme))\n    if urlc.query:\n        parser.error(\"Invalid URI, query component '?{0}' not allowed\"\n                     .format(urlc.query))\n    try:\n        host = urlc.hostname or 'localhost'\n        port = urlc.port or 4304\n    except ValueError as error:\n        parser.error(\"Invalid URI: invalid net location '//{0}/'\"\n                     .format(urlc.netloc))\n\n    #\n    # create owserver proxy object\n    #\n    try:\n        owproxy = protocol.proxy(host, port, persistent=True)\n    except protocol.ConnError as error:\n        print(\"Unable to open connection to '{0}:{1}'\\n{2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)\n    except protocol.ProtocolError as error:\n        print(\"Protocol error, '{0}:{1}' not an owserver?\\n{2}\"\n              .format(host, port, error), file=sys.stderr)\n        sys.exit(1)\n\n    stress(owproxy, urlc.path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the url for a cheddar API resource.", "response": "def build_url(self, path, params=None):\n        '''\n        Constructs the url for a cheddar API resource\n        '''\n        url = u'%s/%s/productCode/%s' % (\n            self.endpoint,\n            path,\n            self.product_code,\n        )\n        if params:\n            for key, value in params.items():\n                url = u'%s/%s/%s' % (url, key, value)\n\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a request to the cheddar api.", "response": "def make_request(self, path, params=None, data=None, method=None):\n        '''\n        Makes a request to the cheddar api using the authentication and\n        configuration settings available.\n        '''\n        # Setup values\n        url = self.build_url(path, params)\n        client_log.debug('Requesting:  %s' % url)\n        method = method or 'GET'\n        body = None\n        headers = {}\n\n        if data:\n            method = 'POST'\n            body = urlencode(data)\n            headers = {\n                'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',\n            }\n\n        client_log.debug('Request Method:  %s' % method)\n        client_log.debug('Request Body(Data):  %s' % data)\n        client_log.debug('Request Body(Raw):  %s' % body)\n\n        # Setup http client\n        h = httplib2.Http(cache=self.cache, timeout=self.timeout)\n        #h.add_credentials(self.username, self.password)\n        # Skip the normal http client behavior and send auth headers immediately\n        # to save an http request.\n        headers['Authorization'] = \"Basic %s\" % base64.standard_b64encode(self.username + ':' + self.password).strip()\n\n        # Make request\n        response, content = h.request(url, method, body=body, headers=headers)\n        status = response.status\n        client_log.debug('Response Status:  %d' % status)\n        client_log.debug('Response Content:  %s' % content)\n        if status != 200 and status != 302:\n            exception_class = CheddarError\n            if status == 401:\n                exception_class = AccessDenied\n            elif status == 400:\n                exception_class = BadRequest\n            elif status == 404:\n                exception_class = NotFound\n            elif status == 412:\n                exception_class = PreconditionFailed\n            elif status == 500:\n                exception_class = CheddarFailure\n            elif status == 502:\n                exception_class = NaughtyGateway\n            elif status == 422:\n                exception_class = UnprocessableEntity\n\n            raise exception_class(response, content)\n\n        response.content = content\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n\n    #\n    # setup command line parsing a la argpase\n    #\n    parser = argparse.ArgumentParser()\n\n    # positional args\n    parser.add_argument('uri', metavar='URI', nargs='?', default='/',\n                        help='[owserver:]//server:port/entity')\n\n    # optional args for temperature scale\n    parser.set_defaults(t_flags=protocol.FLG_TEMP_C)\n    tempg = parser.add_mutually_exclusive_group()\n    tempg.add_argument('-C', '--Celsius', const=protocol.FLG_TEMP_C,\n                       help='Celsius(default) temperature scale',\n                       dest='t_flags', action='store_const', )\n    tempg.add_argument('-F', '--Fahrenheit', const=protocol.FLG_TEMP_F,\n                       help='Fahrenheit temperature scale',\n                       dest='t_flags', action='store_const', )\n    tempg.add_argument('-K', '--Kelvin', const=protocol.FLG_TEMP_K,\n                       help='Kelvin temperature scale',\n                       dest='t_flags', action='store_const', )\n    tempg.add_argument('-R', '--Rankine', const=protocol.FLG_TEMP_R,\n                       help='Rankine temperature scale',\n                       dest='t_flags', action='store_const', )\n\n    # optional arg for address format\n    fcodes = collections.OrderedDict((\n        ('f.i', protocol.FLG_FORMAT_FDI),\n        ('fi', protocol.FLG_FORMAT_FI),\n        ('f.i.c', protocol.FLG_FORMAT_FDIDC),\n        ('f.ic', protocol.FLG_FORMAT_FDIC),\n        ('fi.c', protocol.FLG_FORMAT_FIDC),\n        ('fic', protocol.FLG_FORMAT_FIC), ))\n    parser.set_defaults(format='f.i')\n    parser.add_argument('-f', '--format', choices=fcodes,\n                        help='format for 1-wire unique serial IDs display')\n\n    parser.add_argument('--nosys', '--only-sensors',\n                        action='store_false', dest='bus',\n                        help='do not descend system directories')\n    #\n    # parse command line args\n    #\n    args = parser.parse_args()\n\n    #\n    # parse args.uri and substitute defaults\n    #\n    urlc = urlsplit(args.uri, scheme='owserver', allow_fragments=False)\n    if urlc.scheme != 'owserver':\n        parser.error(\"Invalid URI scheme '{}:'\".format(urlc.scheme))\n    assert not urlc.fragment\n    if urlc.query:\n        parser.error(\n            \"Invalid URI '{}', no query component allowed\".format(args.uri))\n    host = urlc.hostname or 'localhost'\n    port = urlc.port or 4304\n\n    #\n    # create owserver proxy object\n    #\n    try:\n        proxy = protocol.proxy(\n            host, port, flags=args.t_flags | fcodes[args.format],\n            persistent=True)\n    except (protocol.ConnError, protocol.ProtocolError) as error:\n        parser.exit(status=1, message=str(error) + '\\n')\n\n    def walk(path):\n        try:\n            if not path.endswith('/'):\n                val = proxy.read(path)\n                print(\"{:40} {!r}\".format(path, val))\n            else:\n                for entity in proxy.dir(path, bus=args.bus):\n                    walk(entity)\n        except protocol.OwnetError as error:\n            print('Unable to walk {}: server says {}'.format(path, error),\n                  file=sys.stderr)\n        except protocol.ConnError as error:\n            print('Unable to walk {}: {}'.format(path, error), file=sys.stderr)\n\n    with proxy:\n        walk(urlc.path)", "response": "parse commandline arguments and print result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef proxy(host='localhost', port=4304, flags=0, persistent=False,\n          verbose=False, ):\n    \"\"\"factory function that returns a proxy object for an owserver at\n    host, port.\n    \"\"\"\n\n    # resolve host name/port\n    try:\n        gai = socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM,\n                                 socket.IPPROTO_TCP)\n    except socket.gaierror as err:\n        raise ConnError(*err.args)\n\n    # gai is a (non empty) list of tuples, search for the first working one\n    assert gai\n    for (family, _type, _proto, _, sockaddr) in gai:\n        assert _type is socket.SOCK_STREAM and _proto is socket.IPPROTO_TCP\n        owp = _Proxy(family, sockaddr, flags, verbose)\n        try:\n            # check if there is an owserver listening\n            owp.ping()\n        except ConnError as err:\n            # no connection, go over to next sockaddr\n            lasterr = err.args\n            continue\n        else:\n            # ok, live owserver found, stop searching\n            break\n    else:\n        # no server listening on (family, sockaddr) found:\n        raise ConnError(*lasterr)\n\n    # init errno to errmessage mapping\n    # FIXME: should this be only optional?\n    owp._init_errcodes()\n\n    if persistent:\n        owp = clone(owp, persistent=True)\n\n    # here we should have all connections closed\n    assert not isinstance(owp, _PersistentProxy) or owp.conn is None\n\n    return owp", "response": "factory function that returns an owserver at\n    host port."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone(proxy, persistent=True):\n\n    if not isinstance(proxy, _Proxy):\n        raise TypeError('argument is not a Proxy object')\n\n    if persistent:\n        pclass = _PersistentProxy\n    else:\n        pclass = _Proxy\n\n    return pclass(proxy._family, proxy._sockaddr,\n                  proxy.flags & ~FLG_PERSISTENCE, proxy.verbose, proxy.errmess)", "response": "factory function for cloning a proxy object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef shutdown(self):\n\n        if self.verbose:\n            print(self.socket.getsockname(), 'xx', self.peername)\n\n        try:\n            self.socket.shutdown(socket.SHUT_RDWR)\n        except IOError as err:\n            assert err.errno is _ENOTCONN, \"unexpected IOError: %s\" % err\n            # remote peer has already closed the connection,\n            # just ignore the exceeption\n            pass", "response": "shutdown connection to the remote peer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a message to the server and return a response", "response": "def req(self, msgtype, payload, flags, size=0, offset=0, timeout=0):\n        \"\"\"send message to server and return response\"\"\"\n\n        if timeout < 0:\n            raise ValueError(\"timeout cannot be negative!\")\n\n        tohead = _ToServerHeader(payload=len(payload), type=msgtype,\n                                 flags=flags, size=size, offset=offset)\n\n        tstartcom = monotonic()  # set timer when communication begins\n        self._send_msg(tohead, payload)\n\n        while True:\n            fromhead, data = self._read_msg()\n\n            if fromhead.payload >= 0:\n                # we received a valid answer and return the result\n                return fromhead.ret, fromhead.flags, data\n\n            assert msgtype != MSG_NOP\n\n            # we did not exit the loop because payload is negative\n            # Server said PING to keep connection alive during lenghty op\n\n            # check if timeout has expired\n            if timeout:\n                tcom = monotonic() - tstartcom\n                if tcom > timeout:\n                    raise OwnetTimeout(tcom, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to the server", "response": "def _send_msg(self, header, payload):\n        \"\"\"send message to server\"\"\"\n\n        if self.verbose:\n            print('->', repr(header))\n            print('..', repr(payload))\n        assert header.payload == len(payload)\n        try:\n            sent = self.socket.send(header + payload)\n        except IOError as err:\n            raise ConnError(*err.args)\n\n        # FIXME FIXME FIXME:\n        # investigate under which situations socket.send should be retried\n        # instead of aborted.\n        # FIXME FIXME FIXME\n        if sent < len(header + payload):\n            raise ShortWrite(sent, len(header + payload))\n        assert sent == len(header + payload), sent"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a message from the server and return it as a tuple.", "response": "def _read_msg(self):\n        \"\"\"read message from server\"\"\"\n\n        #\n        # NOTE:\n        # '_recv_socket(nbytes)' was implemented as\n        # 'socket.recv(nbytes, socket.MSG_WAITALL)'\n        # but socket.MSG_WAITALL proved not reliable\n        #\n\n        def _recv_socket(nbytes):\n            \"\"\"read nbytes bytes from self.socket\"\"\"\n\n            #\n            # code below is written under the assumption that\n            # 'nbytes' is smallish so that the 'while len(buf) < nbytes' loop\n            # is entered rarerly\n            #\n            try:\n                buf = self.socket.recv(nbytes)\n            except IOError as err:\n                raise ConnError(*err.args)\n\n            if not buf:\n                raise ShortRead(0, nbytes)\n\n            while len(buf) < nbytes:\n                try:\n                    tmp = self.socket.recv(nbytes - len(buf))\n                except IOError as err:\n                    raise ConnError(*err.args)\n\n                if not tmp:\n                    if self.verbose:\n                        print('ee', repr(buf))\n                    raise ShortRead(len(buf), nbytes)\n\n                buf += tmp\n\n            assert len(buf) == nbytes, (buf, len(buf), nbytes)\n            return buf\n\n        data = _recv_socket(_FromServerHeader.header_size)\n        header = _FromServerHeader(data)\n        if self.verbose:\n            print('<-', repr(header))\n\n        # error conditions\n        if header.version != 0:\n            raise MalformedHeader('bad version', header)\n        if header.payload > MAX_PAYLOAD:\n            raise MalformedHeader('huge payload, unwilling to read', header)\n\n        if header.payload > 0:\n            payload = _recv_socket(header.payload)\n            if self.verbose:\n                print('..', repr(payload))\n            assert header.size <= header.payload\n            payload = payload[:header.size]\n        else:\n            payload = bytes()\n        return header, payload"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sendmess(self, msgtype, payload, flags=0, size=0, offset=0, timeout=0):\n\n        flags |= self.flags\n        assert not (flags & FLG_PERSISTENCE)\n\n        with self._new_connection() as conn:\n            ret, _, data = conn.req(\n                msgtype, payload, flags, size, offset, timeout)\n\n        return ret, data", "response": "send a generic message and return the retcode and data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ping(self):\n\n        ret, data = self.sendmess(MSG_NOP, bytes())\n        if data or ret > 0:\n            raise ProtocolError('invalid reply to ping message')\n        if ret < 0:\n            raise OwnetError(-ret, self.errmess[-ret])", "response": "sends a NOP packet and waits response ; returns None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if there is an entity at path", "response": "def present(self, path, timeout=0):\n        \"\"\"returns True if there is an entity at path\"\"\"\n\n        ret, data = self.sendmess(MSG_PRESENCE, str2bytez(path),\n                                  timeout=timeout)\n        assert ret <= 0 and not data, (ret, data)\n        if ret < 0:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dir(self, path='/', slash=True, bus=False, timeout=0):\n\n        if slash:\n            msg = MSG_DIRALLSLASH\n        else:\n            msg = MSG_DIRALL\n        if bus:\n            flags = self.flags | FLG_BUS_RET\n        else:\n            flags = self.flags & ~FLG_BUS_RET\n\n        ret, data = self.sendmess(msg, str2bytez(path), flags, timeout=timeout)\n        if ret < 0:\n            raise OwnetError(-ret, self.errmess[-ret], path)\n        if data:\n            return bytes2str(data).split(',')\n        else:\n            return []", "response": "list entities at path"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads data at path", "response": "def read(self, path, size=MAX_PAYLOAD, offset=0, timeout=0):\n        \"\"\"read data at path\"\"\"\n\n        if size > MAX_PAYLOAD:\n            raise ValueError(\"size cannot exceed %d\" % MAX_PAYLOAD)\n\n        ret, data = self.sendmess(MSG_READ, str2bytez(path),\n                                  size=size, offset=offset, timeout=timeout)\n        if ret < 0:\n            raise OwnetError(-ret, self.errmess[-ret], path)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, path, data, offset=0, timeout=0):\n\n        # fixme: check of path type delayed to str2bytez\n        if not isinstance(data, (bytes, bytearray, )):\n            raise TypeError(\"'data' argument must be binary\")\n\n        ret, rdata = self.sendmess(MSG_WRITE, str2bytez(path) + data,\n                                   size=len(data), offset=offset,\n                                   timeout=timeout)\n        assert not rdata, (ret, rdata)\n        if ret < 0:\n            raise OwnetError(-ret, self.errmess[-ret], path)", "response": "write data at path at offset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending generic message and return retcode and data", "response": "def sendmess(self, msgtype, payload, flags=0, size=0, offset=0, timeout=0):\n        \"\"\"\n        retcode, data = sendmess(msgtype, payload)\n        send generic message and returns retcode, data\n        \"\"\"\n\n        # reuse last valid connection or create new\n        conn = self.conn or self._new_connection()\n        # invalidate last connection\n        self.conn = None\n\n        flags |= self.flags\n        assert (flags & FLG_PERSISTENCE)\n        ret, rflags, data = conn.req(\n            msgtype, payload, flags, size, offset, timeout)\n        if rflags & FLG_PERSISTENCE:\n            # persistence granted, save connection object for reuse\n            self.conn = conn\n        else:\n            # discard connection object\n            conn.shutdown()\n\n        return ret, data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all customers in this product.", "response": "def get_customers(self, filter_data=None):\n        '''\n        Returns all customers. Sometimes they are too much and cause internal \n        server errors on CG. API call permits post parameters for filtering \n        which tends to fix this\n        https://cheddargetter.com/developers#all-customers\n\n        filter_data\n            Will be processed by urlencode and can be used for filtering\n            Example value: [\n                (\"subscriptionStatus\": \"activeOnly\"),\n                (\"planCode[]\": \"100GB\"), (\"planCode[]\": \"200GB\")\n            ]\n        '''\n        customers = []\n        \n        try:\n            response = self.client.make_request(path='customers/get', data=filter_data)\n        except NotFound:\n            response = None\n        \n        if response:\n            customer_parser = CustomersParser()\n            customers_data = customer_parser.parse_xml(response.content)\n            for customer_data in customers_data:\n                customers.append(Customer(product=self, **customer_data))\n            \n        return customers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initial_bill_date(self):\n        '''\n        An estimated initial bill date for an account created today,\n        based on available plan info.\n        '''\n        time_to_start = None\n        \n        if self.initial_bill_count_unit == 'months':\n            time_to_start = relativedelta(months=self.initial_bill_count)\n        else:\n            time_to_start = relativedelta(days=self.initial_bill_count)\n        \n        initial_bill_date = datetime.utcnow().date() + time_to_start\n        \n        return initial_bill_date", "response": "An estimated initial bill date for an account created today based on available plan info."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an arbitrary charge or credit to a customer s account.", "response": "def charge(self, code, each_amount, quantity=1, description=None):\n        '''\n        Add an arbitrary charge or credit to a customer's account.  A positive\n        number will create a charge.  A negative number will create a credit.\n        \n        each_amount is normalized to a Decimal with a precision of 2 as that\n        is the level of precision which the cheddar API supports.\n        '''\n        each_amount = Decimal(each_amount)\n        each_amount = each_amount.quantize(Decimal('.01'))\n        data = {\n            'chargeCode': code,\n            'eachAmount': '%.2f' % each_amount,\n            'quantity': quantity,\n        }\n        if description:\n            data['description'] = description\n        \n        response = self.product.client.make_request(\n            path='customers/add-charge',\n            params={'code': self.code},\n            data=data,\n        )\n        return self.load_data_from_xml(response.content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a one - time invoice for the user.", "response": "def create_one_time_invoice(self, charges):\n        '''\n        Charges should be a list of charges to execute immediately.  Each\n        value in the charges diectionary should be a dictionary with the \n        following keys:\n\n        code\n            Your code for this charge.  This code will be displayed in the \n            user's invoice and is limited to 36 characters.\n        quantity\n            A positive integer quantity.  If not provided this value will \n            default to 1.\n        each_amount\n            Positive or negative integer or decimal with two digit precision.\n            A positive number will create a charge (debit). A negative number\n            will create a credit.\n        description\n            An optional description for this charge which will be displayed on\n            the user's invoice.\n        '''\n        data = {}\n        for n, charge in enumerate(charges):\n            each_amount = Decimal(charge['each_amount'])\n            each_amount = each_amount.quantize(Decimal('.01'))\n            data['charges[%d][chargeCode]' % n ] = charge['code']\n            data['charges[%d][quantity]' % n] = charge.get('quantity', 1)\n            data['charges[%d][eachAmount]' % n] = '%.2f' % each_amount\n            if 'description' in charge.keys():\n                data['charges[%d][description]' % n] = charge['description']\n\n        response = self.product.client.make_request(\n            path='invoices/new',\n            params={'code': self.code},\n            data=data,\n        )\n        return self.load_data_from_xml(response.content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, quantity):\n        '''\n        Set the item's quantity to the passed in amount.  If nothing is\n        passed in, a quantity of 1 is assumed.  If a decimal value is passsed\n        in, it is rounded to the 4th decimal place as that is the level of \n        precision which the Cheddar API accepts.\n        '''\n        data = {}\n        data['quantity'] = self._normalize_quantity(quantity)\n         \n        response = self.subscription.customer.product.client.make_request(\n            path = 'customers/set-item-quantity',\n            params = {\n                'code': self.subscription.customer.code,\n                'itemCode': self.code,\n            },\n            data = data,\n            method = 'POST',\n        )\n        \n        return self.subscription.customer.load_data_from_xml(response.content)", "response": "Set the item s quantity to the passed in amount."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompares each field of the name one at a time to see if they match.", "response": "def deep_compare(self, other, settings):\n        \"\"\"\n        Compares each field of the name one at a time to see if they match.\n        Each name field has context-specific comparison logic.\n\n        :param Name other: other Name for comparison\n        :return bool: whether the two names are compatible\n        \"\"\"\n\n        if not self._is_compatible_with(other):\n            return False\n\n        first, middle, last = self._compare_components(other, settings)\n\n        return first and middle and last"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ratio_deep_compare(self, other, settings):\n\n        if not self._is_compatible_with(other):\n            return 0\n\n        first, middle, last = self._compare_components(other, settings, True)\n        f_weight, m_weight, l_weight = self._determine_weights(other, settings)\n        total_weight = f_weight + m_weight + l_weight\n\n        result = (\n            first * f_weight +\n            middle * m_weight +\n            last * l_weight\n        ) / total_weight\n\n        return result", "response": "Compares each field of the name one at a time to see if they match."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if names are not incompatible.", "response": "def _is_compatible_with(self, other):\n        \"\"\"\n        Return True if names are not incompatible.\n\n        This checks that the gender of titles and compatibility of suffixes\n        \"\"\"\n\n        title = self._compare_title(other)\n        suffix = self._compare_suffix(other)\n\n        return title and suffix"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if titles have different gender associations", "response": "def _compare_title(self, other):\n        \"\"\"Return False if titles have different gender associations\"\"\"\n\n        # If title is omitted, assume a match\n        if not self.title or not other.title:\n            return True\n\n        titles = set(self.title_list + other.title_list)\n\n        return not (titles & MALE_TITLES and titles & FEMALE_TITLES)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _compare_suffix(self, other):\n\n        # If suffix is omitted, assume a match\n        if not self.suffix or not other.suffix:\n            return True\n\n        # Check if more than one unique suffix\n        suffix_set = set(self.suffix_list + other.suffix_list)\n        unique_suffixes = suffix_set & UNIQUE_SUFFIXES\n        for key in EQUIVALENT_SUFFIXES:\n            if key in unique_suffixes:\n                unique_suffixes.remove(key)\n                unique_suffixes.add(EQUIVALENT_SUFFIXES[key])\n\n        return len(unique_suffixes) < 2", "response": "Return true if the suffix of the two entry sets are mutually exclusive."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn comparison of first middle and last components", "response": "def _compare_components(self, other, settings, ratio=False):\n        \"\"\"Return comparison of first, middle, and last components\"\"\"\n\n        first = compare_name_component(\n            self.first_list,\n            other.first_list,\n            settings['first'],\n            ratio,\n        )\n\n        if settings['check_nickname']:\n            if first is False:\n                first = compare_name_component(\n                    self.nickname_list,\n                    other.first_list,\n                    settings['first'],\n                    ratio\n                ) or compare_name_component(\n                    self.first_list,\n                    other.nickname_list,\n                    settings['first'],\n                    ratio\n                )\n            elif ratio and first is not 100:\n                first = max(\n                    compare_name_component(\n                        self.nickname_list,\n                        other.first_list,\n                        settings['first'],\n                        ratio\n                    ),\n                    compare_name_component(\n                        self.first_list,\n                        other.nickname_list,\n                        settings['first'],\n                        ratio\n                    ),\n                    first,\n                )\n\n        middle = compare_name_component(\n            self.middle_list,\n            other.middle_list,\n            settings['middle'],\n            ratio,\n        )\n\n        last = compare_name_component(\n            self.last_list,\n            other.last_list,\n            settings['last'],\n            ratio,\n        )\n\n        return first, middle, last"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines weights of name components based on whether or not they were omitted", "response": "def _determine_weights(self, other, settings):\n        \"\"\"\n        Return weights of name components based on whether or not they were\n        omitted\n        \"\"\"\n\n        # TODO: Reduce weight for matches by prefix or initials\n\n        first_is_used = settings['first']['required'] or \\\n            self.first and other.first\n        first_weight = settings['first']['weight'] if first_is_used else 0\n\n        middle_is_used = settings['middle']['required'] or \\\n            self.middle and other.middle\n        middle_weight = settings['middle']['weight'] if middle_is_used else 0\n\n        last_is_used = settings['last']['required'] or \\\n            self.last and other.last\n        last_weight = settings['last']['weight'] if last_is_used else 0\n\n        return first_weight, middle_weight, last_weight"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the rate limiting configuration for the application.", "response": "def init_app(self, app):\n        \"\"\"\n        :param app: :class:`sanic.Sanic` instance to rate limit.\n        \"\"\"\n        self.enabled = app.config.setdefault(C.ENABLED, True)\n        self._swallow_errors = app.config.setdefault(\n            C.SWALLOW_ERRORS, self._swallow_errors\n        )\n        self._storage_options.update(\n            app.config.get(C.STORAGE_OPTIONS, {})\n        )\n        self._storage = storage_from_string(\n            self._storage_uri\n            or app.config.setdefault(C.STORAGE_URL, 'memory://'),\n            **self._storage_options\n        )\n        strategy = (\n            self._strategy\n            or app.config.setdefault(C.STRATEGY, 'fixed-window')\n        )\n        if strategy not in STRATEGIES:\n            raise ConfigurationError(\"Invalid rate limiting strategy %s\" % strategy)\n        self._limiter = STRATEGIES[strategy](self._storage)\n\n        conf_limits = app.config.get(C.GLOBAL_LIMITS, None)\n        if not self._global_limits and conf_limits:\n            self._global_limits = [\n                ExtLimit(\n                    limit, self._key_func, None, False, None, None, None\n                ) for limit in parse_many(conf_limits)\n                ]\n        app.request_middleware.append(self.__check_request_limit)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef limit(self, limit_value, key_func=None, per_method=False,\n              methods=None, error_message=None, exempt_when=None):\n        \"\"\"\n        decorator to be used for rate limiting individual routes.\n\n        :param limit_value: rate limit string or a callable that returns a string.\n         :ref:`ratelimit-string` for more details.\n        :param function key_func: function/lambda to extract the unique identifier for\n         the rate limit. defaults to remote address of the request.\n        :param bool per_method: whether the limit is sub categorized into the http\n         method of the request.\n        :param list methods: if specified, only the methods in this list will be rate\n         limited (default: None).\n        :param error_message: string (or callable that returns one) to override the\n         error message used in the response.\n        :return:\n        \"\"\"\n        return self.__limit_decorator(limit_value, key_func, per_method=per_method,\n                                      methods=methods, error_message=error_message,\n                                      exempt_when=exempt_when)", "response": "Decorator to be used for rate limiting individual routes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shared_limit(self, limit_value, scope, key_func=None,\n                     error_message=None, exempt_when=None):\n        \"\"\"\n        decorator to be applied to multiple routes sharing the same rate limit.\n\n        :param limit_value: rate limit string or a callable that returns a string.\n         :ref:`ratelimit-string` for more details.\n        :param scope: a string or callable that returns a string\n         for defining the rate limiting scope.\n        :param function key_func: function/lambda to extract the unique identifier for\n         the rate limit. defaults to remote address of the request.\n        :param error_message: string (or callable that returns one) to override the\n         error message used in the response.\n        \"\"\"\n        return self.__limit_decorator(\n            limit_value, key_func, True, scope, error_message=error_message,\n            exempt_when=exempt_when\n        )", "response": "decorator to be applied to multiple routes sharing the same rate limit."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reset(self):\n        try:\n            self._storage.reset()\n            self.logger.info(\"Storage has been reset and all limits cleared\")\n        except NotImplementedError:\n            self.logger.warning(\"This storage type does not support being reset\")", "response": "Resets the storage if it supports being reset\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_soup(page=''):\n    content = requests.get('%s/%s' % (BASE_URL, page)).text\n    return BeautifulSoup(content)", "response": "Returns a bs4 object of the requested page"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(fullname1, fullname2, strictness='default', options=None):\n\n    if options is not None:\n        settings = deepcopy(SETTINGS[strictness])\n        deep_update_dict(settings, options)\n    else:\n        settings = SETTINGS[strictness]\n\n    name1 = Name(fullname1)\n    name2 = Name(fullname2)\n\n    return name1.deep_compare(name2, settings)", "response": "Takes two names and returns true if they describe the same person."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ratio(fullname1, fullname2, strictness='default', options=None):\n\n    if options is not None:\n        settings = deepcopy(SETTINGS[strictness])\n        deep_update_dict(settings, options)\n    else:\n        settings = SETTINGS[strictness]\n\n    name1 = Name(fullname1)\n    name2 = Name(fullname2)\n\n    return name1.ratio_deep_compare(name2, settings)", "response": "Returns true if two names describe the same person."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_zipped_rows(self, soup):\r\n        # the table with all submissions\r\n        table = soup.findChildren('table')[2]\r\n        # get all rows but last 2\r\n        rows = table.findChildren(['tr'])[:-2]\r\n        # remove the spacing rows\r\n        # indices of spacing tr's\r\n        spacing = range(2, len(rows), 3)\r\n        rows = [row for (i, row) in enumerate(rows) if (i not in spacing)]\r\n        # rank, title, domain\r\n        info = [row for (i, row) in enumerate(rows) if (i % 2 == 0)]\r\n        # points, submitter, comments\r\n        detail = [row for (i, row) in enumerate(rows) if (i % 2 != 0)]\r\n\r\n        # build a list of tuple for all post\r\n        return zip(info, detail)", "response": "Returns all tr tags as a list of tuples. Each tuple is for\r\n        a single story."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _build_story(self, all_rows):\r\n        # list to hold all stories\r\n        all_stories = []\r\n\r\n        for (info, detail) in all_rows:\r\n\r\n            #-- Get the into about a story --#\r\n            # split in 3 cells\r\n            info_cells = info.findAll('td')\r\n\r\n            rank = int(info_cells[0].string[:-1])\r\n            title = '%s' % info_cells[2].find('a').string\r\n            link = info_cells[2].find('a').get('href')\r\n\r\n            # by default all stories are linking posts\r\n            is_self = False\r\n\r\n            # the link doesn't contains \"http\" meaning an internal link\r\n            if link.find('item?id=') is -1:\r\n                # slice \" (abc.com) \"\r\n                domain = info_cells[2].findAll('span')[1].string[2:-1]\r\n            else:\r\n                link = '%s/%s' % (BASE_URL, link)\r\n                domain = BASE_URL\r\n                is_self = True\r\n            #-- Get the into about a story --#\r\n\r\n            #-- Get the detail about a story --#\r\n            # split in 2 cells, we need only second\r\n            detail_cell = detail.findAll('td')[1]\r\n            # list of details we need, 5 count\r\n            detail_concern = detail_cell.contents\r\n\r\n            num_comments = -1\r\n\r\n            if re.match(r'^(\\d+)\\spoint.*', detail_concern[0].string) is not \\\r\n                    None:\r\n                # can be a link or self post\r\n                points = int(re.match(r'^(\\d+)\\spoint.*', detail_concern[\r\n                    0].string).groups()[0])\r\n                submitter = '%s' % detail_concern[2].string\r\n                submitter_profile = '%s/%s' % (BASE_URL, detail_concern[\r\n                    2].get('href'))\r\n                published_time = ' '.join(detail_concern[3].strip().split()[\r\n                                          :3])\r\n                comment_tag = detail_concern[4]\r\n                story_id = int(re.match(r'.*=(\\d+)', comment_tag.get(\r\n                    'href')).groups()[0])\r\n                comments_link = '%s/item?id=%d' % (BASE_URL, story_id)\r\n                comment_count = re.match(r'(\\d+)\\s.*', comment_tag.string)\r\n                try:\r\n                    # regex matched, cast to int\r\n                    num_comments = int(comment_count.groups()[0])\r\n                except AttributeError:\r\n                    # did not match, assign 0\r\n                    num_comments = 0\r\n            else:\r\n                # this is a job post\r\n                points = 0\r\n                submitter = ''\r\n                submitter_profile = ''\r\n                published_time = '%s' % detail_concern[0]\r\n                comment_tag = ''\r\n                try:\r\n                    story_id = int(re.match(r'.*=(\\d+)', link).groups()[0])\r\n                except AttributeError:\r\n                    # job listing that points to external link\r\n                    story_id = -1\r\n                comments_link = ''\r\n                comment_count = -1\r\n            #-- Get the detail about a story --#\r\n\r\n            story = Story(rank, story_id, title, link, domain, points,\r\n                          submitter, published_time, submitter_profile,\r\n                          num_comments, comments_link, is_self)\r\n\r\n            all_stories.append(story)\r\n\r\n        return all_stories", "response": "Builds a list of stories from the passed source."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_stories(self, story_type='', limit=30):\r\n        if limit is None or limit < 1 or limit > 30:\r\n            # we need at least 30 items\r\n            limit = 30\r\n\r\n        stories_found = 0\r\n        # self.more = story_type\r\n        # while we still have more stories to find\r\n        while stories_found < limit:\r\n            # get current page soup\r\n            soup = get_soup(page=story_type)\r\n            all_rows = self._get_zipped_rows(soup)\r\n            # get a list of stories on current page\r\n            stories = self._build_story(all_rows)\r\n            # move to next page\r\n            # self.more = self._get_next_page(soup)\r\n\r\n            for story in stories:\r\n                yield story\r\n                stories_found += 1\r\n\r\n                # if enough stories found, return\r\n                if stories_found == limit:\r\n                    return", "response": "Yields a list of stories from the passed page\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_leaders(self, limit=10):\r\n        if limit is None:\r\n            limit = 10\r\n        soup = get_soup('leaders')\r\n        table = soup.find('table')\r\n        leaders_table = table.find_all('table')[1]\r\n        listleaders = leaders_table.find_all('tr')[2:]\r\n        listleaders.pop(10)  # Removing because empty in the Leaders page\r\n        for i, leader in enumerate(listleaders):\r\n            if i == limit:\r\n                return\r\n            if not leader.text == '':\r\n                item = leader.find_all('td')\r\n                yield User(item[1].text, '', item[2].text, item[3].text)", "response": "Returns the leaders of Hacker News"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_next_page(self, soup, current_page):\r\n\r\n        # Get the table with all the comments:\r\n        if current_page == 1:\r\n            table = soup.findChildren('table')[3]\r\n        elif current_page > 1:\r\n            table = soup.findChildren('table')[2]\r\n\r\n        # the last row of the table contains the relative url of the next page\r\n        anchor = table.findChildren(['tr'])[-1].find('a')\r\n        if anchor and anchor.text == u'More':\r\n            return anchor.get('href').lstrip(BASE_URL)\r\n        else:\r\n            return None", "response": "Get the next page of the news."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a list of Comment objects for the story.", "response": "def _build_comments(self, soup):\r\n        \"\"\"\r\n        For the story, builds and returns a list of Comment objects.\r\n        \"\"\"\r\n\r\n        comments = []\r\n        current_page = 1\r\n\r\n        while True:\r\n            # Get the table holding all comments:\r\n            if current_page == 1:\r\n                table = soup.findChildren('table')[3]\r\n            elif current_page > 1:\r\n                table = soup.findChildren('table')[2]\r\n            # get all rows (each comment is duplicated twice)\r\n            rows = table.findChildren(['tr'])\r\n            # last row is more, second last is spacing\r\n            rows = rows[:len(rows) - 2]\r\n            # now we have unique comments only\r\n            rows = [row for i, row in enumerate(rows) if (i % 2 == 0)]\r\n\r\n            if len(rows) > 1:\r\n                for row in rows:\r\n\r\n                    # skip an empty td\r\n                    if not row.findChildren('td'):\r\n                        continue\r\n\r\n                    # Builds a flat list of comments\r\n\r\n                    # level of comment, starting with 0\r\n                    level = int(row.findChildren('td')[1].find('img').get(\r\n                        'width')) // 40\r\n\r\n                    spans = row.findChildren('td')[3].findAll('span')\r\n                    # span[0] = submitter details\r\n                    # [<a href=\"user?id=jonknee\">jonknee</a>, u' 1 hour ago  | ', <a href=\"item?id=6910978\">link</a>]\r\n                    # span[1] = actual comment\r\n\r\n                    if str(spans[0]) != '<span class=\"comhead\"></span>':\r\n                        # user who submitted the comment\r\n                        user = spans[0].contents[0].string\r\n                        # relative time of comment\r\n                        time_ago = spans[0].contents[1].string.strip(\r\n                        ).rstrip(' |')\r\n                        try:\r\n                            comment_id = int(re.match(r'item\\?id=(.*)',\r\n                                                      spans[0].contents[\r\n                                                          2].get(\r\n                                                          'href')).groups()[0])\r\n                        except AttributeError:\r\n                            comment_id = int(re.match(r'%s/item\\?id=(.*)' %\r\n                                                      BASE_URL,\r\n                                                      spans[0].contents[\r\n                                                          2].get(\r\n                                                          'href')).groups()[0])\r\n\r\n                        # text representation of comment (unformatted)\r\n                        body = spans[1].text\r\n\r\n                        if body[-2:] == '--':\r\n                            body = body[:-5]\r\n\r\n                        # html of comment, may not be valid\r\n                        try:\r\n                            pat = re.compile(\r\n                                r'<span class=\"comment\"><font color=\".*\">(.*)</font></span>')\r\n                            body_html = re.match(pat, str(spans[1]).replace(\r\n                                '\\n', '')).groups()[0]\r\n                        except AttributeError:\r\n                            pat = re.compile(\r\n                                r'<span class=\"comment\"><font color=\".*\">(.*)</font></p><p><font size=\"1\">')\r\n                            body_html = re.match(pat, str(spans[1]).replace(\r\n                                '\\n', '')).groups()[0]\r\n\r\n                    else:\r\n                        # comment deleted\r\n                        user = ''\r\n                        time_ago = ''\r\n                        comment_id = -1\r\n                        body = '[deleted]'\r\n                        body_html = '[deleted]'\r\n\r\n                    comment = Comment(comment_id, level, user, time_ago,\r\n                                      body, body_html)\r\n                    comments.append(comment)\r\n\r\n            # Move on to the next page of comments, or exit the loop if there\r\n            # is no next page.\r\n            next_page_url = self._get_next_page(soup, current_page)\r\n            if not next_page_url:\r\n                break\r\n\r\n            soup = get_soup(page=next_page_url)\r\n            current_page += 1\r\n\r\n        previous_comment = None\r\n        # for comment in comments:\r\n        # if comment.level == 0:\r\n        #         previous_comment = comment\r\n        #     else:\r\n        #         level_difference = comment.level - previous_comment.level\r\n        #         previous_comment.body_html += '\\n' + '\\t' * level_difference \\\r\n        #                                       + comment.body_html\r\n        #         previous_comment.body += '\\n' + '\\t' * level_difference + \\\r\n        #                                  comment.body\r\n        return comments"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an instance of the class instance from the ID of the item.", "response": "def fromid(self, item_id):\r\n        \"\"\"\r\n        Initializes an instance of Story for given item_id.\r\n        It is assumed that the story referenced by item_id is valid\r\n        and does not raise any HTTP errors.\r\n        item_id is an int.\r\n        \"\"\"\r\n        if not item_id:\r\n            raise Exception('Need an item_id for a story')\r\n        # get details about a particular story\r\n        soup = get_item_soup(item_id)\r\n\r\n        # this post has not been scraped, so we explititly get all info\r\n        story_id = item_id\r\n        rank = -1\r\n\r\n        # to extract meta information about the post\r\n        info_table = soup.findChildren('table')[2]\r\n        # [0] = title, domain, [1] = points, user, time, comments\r\n        info_rows = info_table.findChildren('tr')\r\n\r\n        # title, domain\r\n        title_row = info_rows[0].findChildren('td')[1]\r\n        title = title_row.find('a').text\r\n        try:\r\n            domain = title_row.find('span').string[2:-2]\r\n            # domain found\r\n            is_self = False\r\n            link = title_row.find('a').get('href')\r\n        except AttributeError:\r\n            # self post\r\n            domain = BASE_URL\r\n            is_self = True\r\n            link = '%s/item?id=%s' % (BASE_URL, item_id)\r\n\r\n        # points, user, time, comments\r\n        meta_row = info_rows[1].findChildren('td')[1].contents\r\n        # [<span id=\"score_7024626\">789 points</span>, u' by ', <a href=\"user?id=endianswap\">endianswap</a>,\r\n        # u' 8 hours ago  | ', <a href=\"item?id=7024626\">238 comments</a>]\r\n\r\n        points = int(re.match(r'^(\\d+)\\spoint.*', meta_row[0].text).groups()[0])\r\n        submitter = meta_row[2].text\r\n        submitter_profile = '%s/%s' % (BASE_URL, meta_row[2].get('href'))\r\n        published_time = ' '.join(meta_row[3].strip().split()[:3])\r\n        comments_link = '%s/item?id=%s' % (BASE_URL, item_id)\r\n        try:\r\n            num_comments = int(re.match(r'(\\d+)\\s.*', meta_row[\r\n                4].text).groups()[0])\r\n        except AttributeError:\r\n            num_comments = 0\r\n        story = Story(rank, story_id, title, link, domain, points, submitter,\r\n                      published_time, submitter_profile, num_comments,\r\n                      comments_link, is_self)\r\n        return story"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompares a list of names from a name component based on settings", "response": "def compare_name_component(list1, list2, settings, use_ratio=False):\n    \"\"\"\n    Compare a list of names from a name component based on settings\n    \"\"\"\n    if not list1[0] or not list2[0]:\n        not_required = not settings['required']\n        return not_required * 100 if use_ratio else not_required\n\n    if len(list1) != len(list2):\n        return False\n\n    compare_func = _ratio_compare if use_ratio else _normal_compare\n    return compare_func(list1, list2, settings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef equate_initial(name1, name2):\n    if len(name1) == 0 or len(name2) == 0:\n        return False\n\n    if len(name1) == 1 or len(name2) == 1:\n        return name1[0] == name2[0]\n\n    return name1 == name2", "response": "Evaluates whether two names are the initial of the other."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef equate_prefix(name1, name2):\n\n    if len(name1) == 0 or len(name2) == 0:\n        return False\n\n    return name1.startswith(name2) or name2.startswith(name1)", "response": "Evaluate whether two names are the same prefix."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef equate_nickname(name1, name2):\n    # Convert '-ie' and '-y' to the root name\n    nickname_regex = r'(.)\\1(y|ie)$'\n    root_regex = r'\\1'\n\n    name1 = re.sub(nickname_regex, root_regex, name1)\n    name2 = re.sub(nickname_regex, root_regex, name2)\n\n    if equate_prefix(name1, name2):\n        return True\n\n    return False", "response": "Evaluates whether two names are the same based on common nickname patterns."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts unicode - specific characters to their equivalent ascii", "response": "def make_ascii(word):\n    \"\"\"\n    Converts unicode-specific characters to their equivalent ascii\n    \"\"\"\n    if sys.version_info < (3, 0, 0):\n        word = unicode(word)\n    else:\n        word = str(word)\n\n    normalized = unicodedata.normalize('NFKD', word)\n\n    return normalized.encode('ascii', 'ignore').decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef seq_ratio(word1, word2):\n    raw_ratio = SequenceMatcher(None, word1, word2).ratio()\n    return int(round(100 * raw_ratio))", "response": "Returns the ratio of a sequence match for two words\n    Returns 0 if no match is found"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deep_update_dict(default, options):\n    for key in options.keys():\n        default_setting = default.get(key)\n        new_setting = options.get(key)\n        if isinstance(default_setting, dict):\n            deep_update_dict(default_setting, new_setting)\n        else:\n            default[key] = new_setting", "response": "Updates the values in a nested dict while unspecified values will remain unchanged"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget base output path for a list of songs for download.", "response": "def template_to_base_path(template, google_songs):\n\t\"\"\"Get base output path for a list of songs for download.\"\"\"\n\n\tif template == os.getcwd() or template == '%suggested%':\n\t\tbase_path = os.getcwd()\n\telse:\n\t\ttemplate = os.path.abspath(template)\n\t\tsong_paths = [template_to_filepath(template, song) for song in google_songs]\n\t\tbase_path = os.path.dirname(os.path.commonprefix(song_paths))\n\n\treturn base_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a randomly generated bit string of the given length with the probability of bit_prob equal to bit_prob.", "response": "def random(cls, length, bit_prob=.5):\n        \"\"\"Create a bit string of the given length, with the probability of\n        each bit being set equal to bit_prob, which defaults to .5.\n\n        Usage:\n            # Create a random BitString of length 10 with mostly zeros.\n            bits = BitString.random(10, bit_prob=.1)\n\n        Arguments:\n            length: An int, indicating the desired length of the result.\n            bit_prob: A float in the range [0, 1]. This is the probability\n                of any given bit in the result having a value of 1; default\n                is .5, giving 0 and 1 equal probabilities of appearance for\n                each bit's value.\n        Return:\n            A randomly generated BitString instance of the requested\n            length.\n        \"\"\"\n\n        assert isinstance(length, int) and length >= 0\n        assert isinstance(bit_prob, (int, float)) and 0 <= bit_prob <= 1\n\n        bits = 0\n        for _ in range(length):\n            bits <<= 1\n            bits += (random.random() < bit_prob)\n\n        return cls(bits, length)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new bitstring containing the given number of points and a new length.", "response": "def crossover_template(cls, length, points=2):\n        \"\"\"Create a crossover template with the given number of points. The\n        crossover template can be used as a mask to crossover two\n        bitstrings of the same length.\n\n        Usage:\n            assert len(parent1) == len(parent2)\n            template = BitString.crossover_template(len(parent1))\n            inv_template = ~template\n            child1 = (parent1 & template) | (parent2 & inv_template)\n            child2 = (parent1 & inv_template) | (parent2 & template)\n\n        Arguments:\n            length: An int, indicating the desired length of the result.\n            points: An int, the number of crossover points.\n        Return:\n            A BitString instance of the requested length which can be used\n            as a crossover template.\n        \"\"\"\n\n        assert isinstance(length, int) and length >= 0\n        assert isinstance(points, int) and points >= 0\n\n        # Select the crossover points.\n        points = random.sample(range(length + 1), points)\n\n        # Prep the points for the loop.\n        points.sort()\n        points.append(length)\n\n        # Fill the bits in with alternating ranges of 0 and 1 according to\n        # the selected crossover points.\n        previous = 0\n        include_range = bool(random.randrange(2))\n        bits = 0\n        for point in points:\n            if point > previous:\n                bits <<= point - previous\n                if include_range:\n                    bits += (1 << (point - previous)) - 1\n            include_range = not include_range\n            previous = point\n\n        return cls(bits, length)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count(self):\n        result = 0\n        bits = self._bits\n        while bits:\n            result += bits % 2\n            bits >>= 1\n        return result", "response": "Returns the number of bits set to True in the bit string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwait for an event on any channel.", "response": "def drain_events(self, allowed_methods=None, timeout=None):\n        \"\"\"Wait for an event on any channel.\"\"\"\n        return self.wait_multi(self.channels.values(), timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for an event on a channel.", "response": "def wait_multi(self, channels, allowed_methods=None, timeout=None):\n        \"\"\"Wait for an event on a channel.\"\"\"\n        chanmap = dict((chan.channel_id, chan) for chan in channels)\n        chanid, method_sig, args, content = self._wait_multiple(\n                chanmap.keys(), allowed_methods, timeout=timeout)\n\n        channel = chanmap[chanid]\n\n        if content \\\n        and channel.auto_decode \\\n        and hasattr(content, 'content_encoding'):\n            try:\n                content.body = content.body.decode(content.content_encoding)\n            except Exception:\n                pass\n\n        amqp_method = channel._METHOD_MAP.get(method_sig, None)\n\n        if amqp_method is None:\n            raise Exception('Unknown AMQP method (%d, %d)' % method_sig)\n\n        if content is None:\n            return amqp_method(channel, args)\n        else:\n            return amqp_method(channel, args, content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestablishing connection to the AMQP broker.", "response": "def establish_connection(self):\n        \"\"\"Establish connection to the AMQP broker.\"\"\"\n        conninfo = self.connection\n        if not conninfo.hostname:\n            raise KeyError(\"Missing hostname for AMQP connection.\")\n        if conninfo.userid is None:\n            raise KeyError(\"Missing user id for AMQP connection.\")\n        if conninfo.password is None:\n            raise KeyError(\"Missing password for AMQP connection.\")\n        if not conninfo.port:\n            conninfo.port = self.default_port\n        return Connection(host=conninfo.host,\n                          userid=conninfo.userid,\n                          password=conninfo.password,\n                          virtual_host=conninfo.virtual_host,\n                          insist=conninfo.insist,\n                          ssl=conninfo.ssl,\n                          connect_timeout=conninfo.connect_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef queue_exists(self, queue):\n        try:\n            self.channel.queue_declare(queue=queue, passive=True)\n        except AMQPChannelException, e:\n            if e.amqp_reply_code == 404:\n                return False\n            raise e\n        else:\n            return True", "response": "Check if a queue exists."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a queue by name.", "response": "def queue_delete(self, queue, if_unused=False, if_empty=False):\n        \"\"\"Delete queue by name.\"\"\"\n        return self.channel.queue_delete(queue, if_unused, if_empty)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeclaring a named queue.", "response": "def queue_declare(self, queue, durable, exclusive, auto_delete,\n            warn_if_exists=False, arguments=None):\n        \"\"\"Declare a named queue.\"\"\"\n        if warn_if_exists and self.queue_exists(queue):\n            warnings.warn(QueueAlreadyExistsWarning(\n                QueueAlreadyExistsWarning.__doc__))\n\n        return self.channel.queue_declare(queue=queue,\n                                          durable=durable,\n                                          exclusive=exclusive,\n                                          auto_delete=auto_delete,\n                                          arguments=arguments)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeclare an named exchange.", "response": "def exchange_declare(self, exchange, type, durable, auto_delete):\n        \"\"\"Declare an named exchange.\"\"\"\n        return self.channel.exchange_declare(exchange=exchange,\n                                             type=type,\n                                             durable=durable,\n                                             auto_delete=auto_delete)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef queue_bind(self, queue, exchange, routing_key, arguments=None):\n        return self.channel.queue_bind(queue=queue,\n                                       exchange=exchange,\n                                       routing_key=routing_key,\n                                       arguments=arguments)", "response": "Bind a queue to an exchange using a routing key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, queue, no_ack=False):\n        raw_message = self.channel.basic_get(queue, no_ack=no_ack)\n        if not raw_message:\n            return None\n        return self.message_to_python(raw_message)", "response": "Receive a message from a declared queue by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef consume(self, limit=None):\n        for total_message_count in count():\n            if limit and total_message_count >= limit:\n                raise StopIteration\n\n            if not self.channel.is_open:\n                raise StopIteration\n\n            self.channel.wait()\n            yield True", "response": "Returns an iterator that waits for one message at a time."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cancel(self, consumer_tag):\n        if not self.channel.connection:\n            return\n        self.channel.basic_cancel(consumer_tag)", "response": "Cancel a channel by consumer tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the channel if open.", "response": "def close(self):\n        \"\"\"Close the channel if open.\"\"\"\n        if self._channel and self._channel.is_open:\n            self._channel.close()\n        self._channel_ref = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrequests specific Quality of Service.", "response": "def qos(self, prefetch_size, prefetch_count, apply_global=False):\n        \"\"\"Request specific Quality of Service.\"\"\"\n        self.channel.basic_qos(prefetch_size, prefetch_count,\n                                apply_global)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef channel(self):\n        if not self._channel:\n            self._channel_ref = weakref.ref(self.connection.get_channel())\n        return self._channel", "response": "Returns the channel object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nestablishes connection to the AMQP broker.", "response": "def establish_connection(self):\n        \"\"\"Establish connection to the AMQP broker.\"\"\"\n        conninfo = self.connection\n        if not conninfo.hostname:\n            raise KeyError(\"Missing hostname for AMQP connection.\")\n        if conninfo.userid is None:\n            raise KeyError(\"Missing user id for AMQP connection.\")\n        if conninfo.password is None:\n            raise KeyError(\"Missing password for AMQP connection.\")\n        if not conninfo.port:\n            conninfo.port = self.default_port\n        conn = amqp.Connection(host=conninfo.hostname,\n                               port=conninfo.port,\n                               userid=conninfo.userid,\n                               password=conninfo.password,\n                               virtual_host=conninfo.virtual_host)\n        return conn"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an iterator that waits for one message at a time.", "response": "def consume(self, limit=None):\n        \"\"\"Returns an iterator that waits for one message at a time.\"\"\"\n        for total_message_count in count():\n            if limit and total_message_count >= limit:\n                raise StopIteration\n\n            if not self.channel.is_open:\n                raise StopIteration\n\n            self.channel.conn.drain_events()\n            yield True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncancels a channel by consumer tag.", "response": "def cancel(self, consumer_tag):\n        \"\"\"Cancel a channel by consumer tag.\"\"\"\n        if not self.channel.conn:\n            return\n        self.channel.basic_cancel(consumer_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prepare_message(self, message_data, delivery_mode, priority=None,\n                content_type=None, content_encoding=None):\n        \"\"\"Encapsulate data into a AMQP message.\"\"\"\n        return amqp.Message(message_data, properties={\n                \"delivery_mode\": delivery_mode,\n                \"priority\": priority,\n                \"content_type\": content_type,\n                \"content_encoding\": content_encoding})", "response": "Encapsulate data into a AMQP message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_json():\n    from anyjson import serialize as json_serialize\n    from anyjson import deserialize as json_deserialize\n\n    registry.register('json', json_serialize, json_deserialize,\n                      content_type='application/json',\n                      content_encoding='utf-8')", "response": "Register a encoder or decoder for JSON serialization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a encoder and decoder for YAML serialization.", "response": "def register_yaml():\n    \"\"\"Register a encoder/decoder for YAML serialization.\n\n    It is slower than JSON, but allows for more data types\n    to be serialized. Useful if you need to send data such as dates\"\"\"\n    try:\n        import yaml\n        registry.register('yaml', yaml.safe_dump, yaml.safe_load,\n                          content_type='application/x-yaml',\n                          content_encoding='utf-8')\n    except ImportError:\n\n        def not_available(*args, **kwargs):\n            \"\"\"In case a client receives a yaml message, but yaml\n            isn't installed.\"\"\"\n            raise SerializerNotInstalled(\n                \"No decoder installed for YAML. Install the PyYAML library\")\n        registry.register('yaml', None, not_available, 'application/x-yaml')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering msgpack with the msgpack library.", "response": "def register_msgpack():\n    \"\"\"See http://msgpack.sourceforge.net/\"\"\"\n    try:\n        import msgpack\n        registry.register('msgpack', msgpack.packs, msgpack.unpacks,\n                content_type='application/x-msgpack',\n                content_encoding='binary')\n    except ImportError:\n\n        def not_available(*args, **kwargs):\n            \"\"\"In case a client receives a msgpack message, but yaml\n            isn't installed.\"\"\"\n            raise SerializerNotInstalled(\n                    \"No decoder installed for msgpack. \"\n                    \"Install the msgpack library\")\n        registry.register('msgpack', None, not_available,\n                          'application/x-msgpack')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, name, encoder, decoder, content_type,\n                 content_encoding='utf-8'):\n        \"\"\"Register a new encoder/decoder.\n\n        :param name: A convenience name for the serialization method.\n\n        :param encoder: A method that will be passed a python data structure\n            and should return a string representing the serialized data.\n            If ``None``, then only a decoder will be registered. Encoding\n            will not be possible.\n\n        :param decoder: A method that will be passed a string representing\n            serialized data and should return a python data structure.\n            If ``None``, then only an encoder will be registered.\n            Decoding will not be possible.\n\n        :param content_type: The mime-type describing the serialized\n            structure.\n\n        :param content_encoding: The content encoding (character set) that\n            the :param:`decoder` method will be returning. Will usually be\n            ``utf-8``, ``us-ascii``, or ``binary``.\n\n        \"\"\"\n        if encoder:\n            self._encoders[name] = (content_type, content_encoding, encoder)\n        if decoder:\n            self._decoders[content_type] = decoder", "response": "Register a new encoder and decoder for a new version of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_default_serializer(self, name):\n        try:\n            (self._default_content_type, self._default_content_encoding,\n             self._default_encode) = self._encoders[name]\n        except KeyError:\n            raise SerializerNotInstalled(\n                \"No encoder installed for %s\" % name)", "response": "Sets the default serialization method used by this library."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode(self, data, serializer=None):\n        if serializer == \"raw\":\n            return raw_encode(data)\n        if serializer and not self._encoders.get(serializer):\n            raise SerializerNotInstalled(\n                        \"No encoder installed for %s\" % serializer)\n\n        # If a raw string was sent, assume binary encoding\n        # (it's likely either ASCII or a raw binary file, but 'binary'\n        # charset will encompass both, even if not ideal.\n        if not serializer and isinstance(data, str):\n            # In Python 3+, this would be \"bytes\"; allow binary data to be\n            # sent as a message without getting encoder errors\n            return \"application/data\", \"binary\", data\n\n        # For unicode objects, force it into a string\n        if not serializer and isinstance(data, unicode):\n            payload = data.encode(\"utf-8\")\n            return \"text/plain\", \"utf-8\", payload\n\n        if serializer:\n            content_type, content_encoding, encoder = \\\n                    self._encoders[serializer]\n        else:\n            encoder = self._default_encode\n            content_type = self._default_content_type\n            content_encoding = self._default_content_encoding\n\n        payload = encoder(data)\n        return content_type, content_encoding, payload", "response": "Encodes a data structure into a string suitable for sending to the broker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode(self, data, content_type, content_encoding):\n        content_type = content_type or 'application/data'\n        content_encoding = (content_encoding or 'utf-8').lower()\n\n        # Don't decode 8-bit strings or unicode objects\n        if content_encoding not in ('binary', 'ascii-8bit') and \\\n                not isinstance(data, unicode):\n            data = codecs.decode(data, content_encoding)\n\n        try:\n            decoder = self._decoders[content_type]\n        except KeyError:\n            return data\n\n        return decoder(data)", "response": "Deserialize a data stream as serialized using encode based on content_type and content_encoding."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nacknowledging this message as being processed., This will remove the message from the queue. :raises MessageStateError: If the message has already been acknowledged/requeued/rejected.", "response": "def ack(self):\n        \"\"\"Acknowledge this message as being processed.,\n        This will remove the message from the queue.\n\n        :raises MessageStateError: If the message has already been\n            acknowledged/requeued/rejected.\n\n        \"\"\"\n        if self.acknowledged:\n            raise self.MessageStateError(\n                \"Message already acknowledged with state: %s\" % self._state)\n        self.backend.ack(self._frame)\n        self._state = \"ACK\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator that waits for one message at a time.", "response": "def consume(self, limit=None):\n        \"\"\"Returns an iterator that waits for one message at a time.\"\"\"\n        for total_message_count in count():\n            if limit and total_message_count >= limit:\n                raise StopIteration\n            self.drain_events()\n            yield True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a randomly generated bit string of the given length with the probability of bit_prob equal to bit_prob.", "response": "def random(cls, length, bit_prob=.5):\n        \"\"\"Create a bit string of the given length, with the probability of\n        each bit being set equal to bit_prob, which defaults to .5.\n\n        Usage:\n            # Create a random BitString of length 10 with mostly zeros.\n            bits = BitString.random(10, bit_prob=.1)\n\n        Arguments:\n            length: An int, indicating the desired length of the result.\n            bit_prob: A float in the range [0, 1]. This is the probability\n                of any given bit in the result having a value of 1; default\n                is .5, giving 0 and 1 equal probabilities of appearance for\n                each bit's value.\n        Return:\n            A randomly generated BitString instance of the requested\n            length.\n        \"\"\"\n\n        assert isinstance(length, int) and length >= 0\n        assert isinstance(bit_prob, (int, float)) and 0 <= bit_prob <= 1\n\n        bits = numpy.random.choice(\n            [False, True],\n            size=(length,),\n            p=[1-bit_prob, bit_prob]\n        )\n        bits.flags.writeable = False\n\n        return cls(bits)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crossover_template(cls, length, points=2):\n\n        assert isinstance(length, int) and length >= 0\n        assert isinstance(points, int) and points >= 0\n\n        # Select the crossover points.\n        points = random.sample(range(length + 1), points)\n\n        # Prep the points for the loop.\n        points.sort()\n        points.append(length)\n\n        # Fill the bits in with alternating ranges of 0 and 1 according to\n        # the selected crossover points.\n        previous = 0\n        include_range = bool(random.randrange(2))\n        pieces = []\n        for point in points:\n            if point > previous:\n                fill = (numpy.ones if include_range else numpy.zeros)\n                pieces.append(fill(point - previous, dtype=bool))\n            include_range = not include_range\n            previous = point\n        bits = numpy.concatenate(pieces)\n        bits.flags.writeable = False\n\n        return cls(bits)", "response": "Create a crossover template with the given number of points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cover(cls, bits, wildcard_probability):\n\n        if not isinstance(bits, BitString):\n            bits = BitString(bits)\n\n        mask = BitString([\n            random.random() > wildcard_probability\n            for _ in range(len(bits))\n        ])\n\n        return cls(bits, mask)", "response": "Create a new bit condition that matches the provided bit string with the indicated per - index wildcard probability."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming 2 - point crossover on this bit condition and another bit condition.", "response": "def crossover_with(self, other, points=2):\n        \"\"\"Perform 2-point crossover on this bit condition and another of\n        the same length, returning the two resulting children.\n\n        Usage:\n            offspring1, offspring2 = condition1.crossover_with(condition2)\n\n        Arguments:\n            other: A second BitCondition of the same length as this one.\n            points: An int, the number of crossover points of the\n                crossover operation.\n        Return:\n            A tuple (condition1, condition2) of BitConditions, where the\n            value at each position of this BitCondition and the other is\n            preserved in one or the other of the two resulting conditions.\n        \"\"\"\n\n        assert isinstance(other, BitCondition)\n        assert len(self) == len(other)\n\n        template = BitString.crossover_template(len(self), points)\n        inv_template = ~template\n\n        bits1 = (self._bits & template) | (other._bits & inv_template)\n        mask1 = (self._mask & template) | (other._mask & inv_template)\n\n        bits2 = (self._bits & inv_template) | (other._bits & template)\n        mask2 = (self._mask & inv_template) | (other._mask & template)\n\n        # Convert the modified sequences back into BitConditions\n        return type(self)(bits1, mask1), type(self)(bits2, mask2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_backend_cls(self):\n        backend_cls = self.backend_cls\n        if not backend_cls or isinstance(backend_cls, basestring):\n            backend_cls = get_backend_cls(backend_cls)\n        return backend_cls", "response": "Get the currently used backend class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ensure_connection(self, errback=None, max_retries=None,\n            interval_start=2, interval_step=2, interval_max=30):\n        \"\"\"Ensure we have a connection to the server.\n\n        If not retry establishing the connection with the settings\n        specified.\n\n        :keyword errback: Optional callback called each time the connection\n          can't be established. Arguments provided are the exception\n          raised and the interval that will be slept ``(exc, interval)``.\n\n        :keyword max_retries: Maximum number of times to retry.\n          If this limit is exceeded the connection error will be re-raised.\n\n        :keyword interval_start: The number of seconds we start sleeping for.\n        :keyword interval_step: How many seconds added to the interval\n          for each retry.\n        :keyword interval_max: Maximum number of seconds to sleep between\n          each retry.\n\n        \"\"\"\n        retry_over_time(self.connect, self.connection_errors, (), {},\n                        errback, max_retries,\n                        interval_start, interval_step, interval_max)\n        return self", "response": "Ensure we have a connection to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close(self):\n        try:\n            if self._connection:\n                backend = self.create_backend()\n                backend.close_connection(self._connection)\n        except socket.error:\n            pass\n        self._closed = True", "response": "Close the currently open connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode(self):\n        return serialization.decode(self.body, self.content_type,\n                                    self.content_encoding)", "response": "Deserialize the message body returning the original\n        python structure sent by the publisher."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ack(self):\n        if self.acknowledged:\n            raise self.MessageStateError(\n                \"Message already acknowledged with state: %s\" % self._state)\n        self.backend.ack(self.delivery_tag)\n        self._state = \"ACK\"", "response": "Acknowledge this message as being processed.,\n        This will remove the message from the queue.\n\n        :raises MessageStateError: If the message has already been\n            acknowledged/requeued/rejected."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reject(self):\n        if self.acknowledged:\n            raise self.MessageStateError(\n                \"Message already acknowledged with state: %s\" % self._state)\n        self.backend.reject(self.delivery_tag)\n        self._state = \"REJECTED\"", "response": "Reject this message.\n\n        The message will be discarded by the server.\n\n        :raises MessageStateError: If the message has already been\n            acknowledged/requeued/rejected."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef requeue(self):\n        if self.acknowledged:\n            raise self.MessageStateError(\n                \"Message already acknowledged with state: %s\" % self._state)\n        self.backend.requeue(self.delivery_tag)\n        self._state = \"REQUEUED\"", "response": "Reject this message and put it back on the queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a unique id for a node.", "response": "def gen_unique_id():\n    \"\"\"Generate a unique id, having - hopefully - a very small chance of\n    collission.\n\n    For now this is provided by :func:`uuid.uuid4`.\n    \"\"\"\n    # Workaround for http://bugs.python.org/issue4607\n    if ctypes and _uuid_generate_random:\n        buffer = ctypes.create_string_buffer(16)\n        _uuid_generate_random(buffer)\n        return str(UUID(bytes=buffer.raw))\n    return str(uuid4())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef retry_over_time(fun, catch, args=[], kwargs={}, errback=None,\n        max_retries=None, interval_start=2, interval_step=2, interval_max=30):\n    \"\"\"Retry the function over and over until max retries is exceeded.\n\n    For each retry we sleep a for a while before we try again, this interval\n    is increased for every retry until the max seconds is reached.\n\n    :param fun: The function to try\n    :param catch: Exceptions to catch, can be either tuple or a single\n        exception class.\n    :keyword args: Positional arguments passed on to the function.\n    :keyword kwargs: Keyword arguments passed on to the function.\n    :keyword errback: Callback for when an exception in ``catch`` is raised.\n        The callback must take two arguments: ``exc`` and ``interval``, where\n        ``exc`` is the exception instance, and ``interval`` is the time in\n        seconds to sleep next..\n    :keyword max_retries: Maximum number of retries before we give up.\n        If this is not set, we will retry forever.\n    :keyword interval_start: How long (in seconds) we start sleeping between\n        retries.\n    :keyword interval_step: By how much the interval is increased for each\n        retry.\n    :keyword interval_max: Maximum number of seconds to sleep between retries.\n\n    \"\"\"\n    retries = 0\n    interval_range = xrange(interval_start,\n                            interval_max + interval_start,\n                            interval_step)\n\n    for retries, interval in enumerate(repeatlast(interval_range)):\n        try:\n            retval = fun(*args, **kwargs)\n        except catch, exc:\n            if max_retries and retries > max_retries:\n                raise\n            if errback:\n                errback(exc, interval)\n            sleep(interval)\n        else:\n            return retval", "response": "Retry the function over and over time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the next waiting message from the queue.", "response": "def get(self, *args, **kwargs):\n        \"\"\"Get the next waiting message from the queue.\n\n        :returns: A :class:`Message` instance, or ``None`` if there is\n            no messages waiting.\n\n        \"\"\"\n        if not mqueue.qsize():\n            return None\n        message_data, content_type, content_encoding = mqueue.get()\n        return self.Message(backend=self, body=message_data,\n                       content_type=content_type,\n                       content_encoding=content_encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndiscarding all messages in the queue.", "response": "def queue_purge(self, queue, **kwargs):\n        \"\"\"Discard all messages in the queue.\"\"\"\n        qsize = mqueue.qsize()\n        mqueue.queue.clear()\n        return qsize"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prepare_message(self, message_data, delivery_mode,\n                        content_type, content_encoding, **kwargs):\n        \"\"\"Prepare message for sending.\"\"\"\n        return (message_data, content_type, content_encoding)", "response": "Prepare message for sending."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the expected near - future payoff for the currently selected action given only the current match set.", "response": "def get_future_expectation(self, match_set):\n        \"\"\"Return a numerical value representing the expected future payoff\n        of the previously selected action, given only the current match\n        set. The match_set argument is a MatchSet instance representing the\n        current match set.\n\n        Usage:\n            match_set = model.match(situation)\n            expectation = model.algorithm.get_future_expectation(match_set)\n            payoff = previous_reward + discount_factor * expectation\n            previous_match_set.payoff = payoff\n\n        Arguments:\n            match_set: A MatchSet instance.\n        Return:\n            A float, the estimate of the expected near-future payoff for\n            the situation for which match_set was generated, based on the\n            contents of match_set.\n        \"\"\"\n        assert isinstance(match_set, MatchSet)\n        assert match_set.algorithm is self\n\n        return self.discount_factor * (\n            self.idealization_factor * match_set.best_prediction +\n            (1 - self.idealization_factor) * match_set.prediction\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a Boolean indicating whether covering is required for the current match set.", "response": "def covering_is_required(self, match_set):\n        \"\"\"Return a Boolean indicating whether covering is required for the\n        current match set. The match_set argument is a MatchSet instance\n        representing the current match set before covering is applied.\n\n        Usage:\n            match_set = model.match(situation)\n            if model.algorithm.covering_is_required(match_set):\n                new_rule = model.algorithm.cover(match_set)\n                assert new_rule.condition(situation)\n                model.add(new_rule)\n                match_set = model.match(situation)\n\n        Arguments:\n            match_set: A MatchSet instance.\n        Return:\n            A bool indicating whether match_set contains too few matching\n            classifier rules and therefore needs to be augmented with a\n            new one.\n        \"\"\"\n        assert isinstance(match_set, MatchSet)\n        assert match_set.algorithm is self\n\n        if self.minimum_actions is None:\n            return len(match_set) < len(match_set.model.possible_actions)\n        else:\n            return len(match_set) < self.minimum_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a new classifier rule that can be added to the match set with a condition that matches the situation of the match set and an action that is not already suggested by the actions already contained therein.", "response": "def cover(self, match_set):\n        \"\"\"Return a new classifier rule that can be added to the match set,\n        with a condition that matches the situation of the match set and an\n        action selected to avoid duplication of the actions already\n        contained therein. The match_set argument is a MatchSet instance\n        representing the match set to which the returned rule may be added.\n\n        Usage:\n            match_set = model.match(situation)\n            if model.algorithm.covering_is_required(match_set):\n                new_rule = model.algorithm.cover(match_set)\n                assert new_rule.condition(situation)\n                model.add(new_rule)\n                match_set = model.match(situation)\n\n        Arguments:\n            match_set: A MatchSet instance.\n        Return:\n            A new ClassifierRule instance, appropriate for the addition to\n            match_set and to the classifier set from which match_set was\n            drawn.\n        \"\"\"\n\n        assert isinstance(match_set, MatchSet)\n        assert match_set.model.algorithm is self\n\n        # Create a new condition that matches the situation.\n        condition = bitstrings.BitCondition.cover(\n            match_set.situation,\n            self.wildcard_probability\n        )\n\n        # Pick a random action that (preferably) isn't already suggested by\n        # some other rule for this situation.\n        action_candidates = (\n            frozenset(match_set.model.possible_actions) -\n            frozenset(match_set)\n        )\n        if not action_candidates:\n            action_candidates = match_set.model.possible_actions\n        action = random.choice(list(action_candidates))\n\n        # Create the new rule.\n        return XCSClassifierRule(\n            condition,\n            action,\n            self,\n            match_set.time_stamp\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndistributes the payoff received in response to the selected action of the given match set.", "response": "def distribute_payoff(self, match_set):\n        \"\"\"Distribute the payoff received in response to the selected\n        action of the given match set among the rules in the action set\n        which deserve credit for recommending the action. The match_set\n        argument is the MatchSet instance which suggested the selected\n        action and earned the payoff.\n\n        Usage:\n            match_set = model.match(situation)\n            match_set.select_action()\n            match_set.payoff = reward\n            model.algorithm.distribute_payoff(match_set)\n\n        Arguments:\n            match_set: A MatchSet instance for which the accumulated payoff\n                needs to be distributed among its classifier rules.\n        Return: None\n        \"\"\"\n\n        assert isinstance(match_set, MatchSet)\n        assert match_set.algorithm is self\n        assert match_set.selected_action is not None\n\n        payoff = float(match_set.payoff)\n\n        action_set = match_set[match_set.selected_action]\n        action_set_size = sum(rule.numerosity for rule in action_set)\n\n        # Update the average reward, error, and action set size of each\n        # rule participating in the action set.\n        for rule in action_set:\n            rule.experience += 1\n\n            update_rate = max(self.learning_rate, 1 / rule.experience)\n\n            rule.average_reward += (\n                (payoff - rule.average_reward) *\n                update_rate\n            )\n\n            rule.error += (\n                (abs(payoff - rule.average_reward) - rule.error) *\n                update_rate\n\n            )\n\n            rule.action_set_size += (\n                (action_set_size - rule.action_set_size) *\n                update_rate\n            )\n\n        # Update the fitness of the rules.\n        self._update_fitness(action_set)\n\n        # If the parameters so indicate, perform action set subsumption.\n        if self.do_action_set_subsumption:\n            self._action_set_subsumption(action_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, match_set):\n\n        assert isinstance(match_set, MatchSet)\n        assert match_set.model.algorithm is self\n        assert match_set.selected_action is not None\n\n        # Increment the iteration counter.\n        match_set.model.update_time_stamp()\n\n        action_set = match_set[match_set.selected_action]\n\n        # If the average number of iterations since the last update for\n        # each rule in the action set is too small, return early instead of\n        # applying the GA.\n        average_time_passed = (\n            match_set.model.time_stamp -\n            self._get_average_time_stamp(action_set)\n        )\n        if average_time_passed <= self.ga_threshold:\n            return\n\n        # Update the time step for each rule to indicate that they were\n        # updated by the GA.\n        self._set_timestamps(action_set)\n\n        # Select two parents from the action set, with probability\n        # proportionate to their fitness.\n        parent1 = self._select_parent(action_set)\n        parent2 = self._select_parent(action_set)\n\n        # With the probability specified in the parameters, apply the\n        # crossover operator to the parents. Otherwise, just take the\n        # parents unchanged.\n        if random.random() < self.crossover_probability:\n            condition1, condition2 = parent1.condition.crossover_with(\n                parent2.condition\n            )\n        else:\n            condition1, condition2 = parent1.condition, parent2.condition\n\n        # Apply the mutation operator to each child, randomly flipping\n        # their mask bits with a small probability.\n        condition1 = self._mutate(condition1, action_set.situation)\n        condition2 = self._mutate(condition2, action_set.situation)\n\n        # If the newly generated children are already present in the\n        # population (or if they should be subsumed due to GA subsumption)\n        # then simply increment the numerosities of the existing rules in\n        # the population.\n        new_children = []\n        for condition in condition1, condition2:\n            # If the parameters specify that GA subsumption should be\n            # performed, look for an accurate parent that can subsume the\n            # new child.\n            if self.do_ga_subsumption:\n                subsumed = False\n                for parent in parent1, parent2:\n                    should_subsume = (\n                        (parent.experience >\n                         self.subsumption_threshold) and\n                        parent.error < self.error_threshold and\n                        parent.condition(condition)\n                    )\n                    if should_subsume:\n                        if parent in action_set.model:\n                            parent.numerosity += 1\n                            self.prune(action_set.model)\n                        else:\n                            # Sometimes the parent is removed from a\n                            # previous subsumption\n                            parent.numerosity = 1\n                            action_set.model.add(parent)\n                        subsumed = True\n                        break\n                if subsumed:\n                    continue\n\n            # Provided the child has not already been subsumed and it is\n            # present in the population, just increment its numerosity.\n            # Otherwise, if the child has neither been subsumed nor does it\n            # already exist, remember it so we can add it to the classifier\n            # set in just a moment.\n            child = XCSClassifierRule(\n                condition,\n                action_set.action,\n                self,\n                action_set.model.time_stamp\n            )\n            if child in action_set.model:\n                action_set.model.add(child)\n            else:\n                new_children.append(child)\n\n        # If there were any children which weren't subsumed and weren't\n        # already present in the classifier set, add them.\n        if new_children:\n            average_reward = .5 * (\n                parent1.average_reward +\n                parent2.average_reward\n            )\n\n            error = .5 * (parent1.error + parent2.error)\n\n            # .1 * (average fitness of parents)\n            fitness = .05 * (\n                parent1.fitness +\n                parent2.fitness\n            )\n\n            for child in new_children:\n                child.average_reward = average_reward\n                child.error = error\n                child.fitness = fitness\n                action_set.model.add(child)", "response": "Update the classifier set from which the match set was drawn."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prune(self, model):\n\n        assert isinstance(model, ClassifierSet)\n        assert model.algorithm is self\n\n        # Determine the (virtual) population size.\n        total_numerosity = sum(rule.numerosity for rule in model)\n\n        # If the population size is already small enough, just return early\n        if total_numerosity <= self.max_population_size:\n            return []  # No rule's numerosity dropped to zero.\n\n        # Determine the average fitness of the rules in the population.\n        total_fitness = sum(rule.fitness for rule in model)\n        average_fitness = total_fitness / total_numerosity\n\n        # Determine the probability of deletion, as a function of both\n        # accuracy and niche sparsity.\n        total_votes = 0\n        deletion_votes = {}\n        for rule in model:\n            vote = rule.action_set_size * rule.numerosity\n\n            sufficient_experience = (\n                rule.experience > self.deletion_threshold\n            )\n            low_fitness = (\n                rule.fitness / rule.numerosity <\n                self.fitness_threshold * average_fitness\n            )\n            if sufficient_experience and low_fitness:\n                vote *= average_fitness / (rule.fitness /\n                                           rule.numerosity)\n\n            deletion_votes[rule] = vote\n            total_votes += vote\n\n        # Choose a rule to delete based on the probabilities just computed.\n        selector = random.uniform(0, total_votes)\n        for rule, vote in deletion_votes.items():\n            selector -= vote\n            if selector <= 0:\n                assert rule in model\n                if model.discard(rule):\n                    return [rule]\n                else:\n                    return []\n\n        assert False", "response": "Reduce the classifier set s population size by removing lower - quality rules. Return a list containing any rules that were removed entirely from the classifier set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the fitness values of the rules belonging to this action_set.", "response": "def _update_fitness(self, action_set):\n        \"\"\"Update the fitness values of the rules belonging to this action\n        set.\"\"\"\n        # Compute the accuracy of each rule. Accuracy is inversely\n        # proportional to error. Below a certain error threshold, accuracy\n        # becomes constant. Accuracy values range over (0, 1].\n        total_accuracy = 0\n        accuracies = {}\n        for rule in action_set:\n            if rule.error < self.error_threshold:\n                accuracy = 1\n            else:\n                accuracy = (\n                    self.accuracy_coefficient *\n                    (rule.error / self.error_threshold) **\n                    -self.accuracy_power\n                )\n            accuracies[rule] = accuracy\n            total_accuracy += accuracy * rule.numerosity\n\n        # On rare occasions we have zero total accuracy. This avoids a div\n        # by zero\n        total_accuracy = total_accuracy or 1\n\n        # Use the relative accuracies of the rules to update their fitness\n        for rule in action_set:\n            accuracy = accuracies[rule]\n            rule.fitness += (\n                self.learning_rate *\n                (accuracy * rule.numerosity / total_accuracy -\n                 rule.fitness)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _action_set_subsumption(self, action_set):\n        # Select a condition with maximum bit count among those having\n        # sufficient experience and sufficiently low error.\n        selected_rule = None\n        selected_bit_count = None\n        for rule in action_set:\n            if not (rule.experience > self.subsumption_threshold and\n                    rule.error < self.error_threshold):\n                continue\n            bit_count = rule.condition.count()\n            if (selected_rule is None or\n                    bit_count > selected_bit_count or\n                    (bit_count == selected_bit_count and\n                     random.randrange(2))):\n                selected_rule = rule\n                selected_bit_count = bit_count\n\n        # If no rule was found satisfying the requirements, return\n        # early.\n        if selected_rule is None:\n            return\n\n        # Subsume each rule which the selected rule generalizes. When a\n        # rule is subsumed, all instances of the subsumed rule are replaced\n        # with instances of the more general one in the population.\n        to_remove = []\n        for rule in action_set:\n            if (selected_rule is not rule and\n                    selected_rule.condition(rule.condition)):\n                selected_rule.numerosity += rule.numerosity\n                action_set.model.discard(rule, rule.numerosity)\n                to_remove.append(rule)\n        for rule in to_remove:\n            action_set.remove(rule)", "response": "Perform action set subsumption."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_average_time_stamp(action_set):\n        # This is the average value of the iteration counter upon the most\n        # recent update of each rule in this action set.\n        total_time_stamps = sum(rule.time_stamp * rule.numerosity\n                                for rule in action_set)\n        total_numerosity = sum(rule.numerosity for rule in action_set)\n        return total_time_stamps / (total_numerosity or 1)", "response": "Return the average time stamp for the rules in this action set."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects a rule from this action set with probability proportionate to its fitness to act as a parent for a new rule in the classifier set. Return the selected rule.", "response": "def _select_parent(action_set):\n        \"\"\"Select a rule from this action set, with probability\n        proportionate to its fitness, to act as a parent for a new rule in\n        the classifier set. Return the selected rule.\"\"\"\n        total_fitness = sum(rule.fitness for rule in action_set)\n        selector = random.uniform(0, total_fitness)\n        for rule in action_set:\n            selector -= rule.fitness\n            if selector <= 0:\n                return rule\n        # If for some reason a case slips through the above loop, perhaps\n        # due to floating point error, we fall back on uniform selection.\n        return random.choice(list(action_set))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _mutate(self, condition, situation):\n\n        # Go through each position in the condition, randomly flipping\n        # whether the position is a value (0 or 1) or a wildcard (#). We do\n        # this in a new list because the original condition's mask is\n        # immutable.\n        mutation_points = bitstrings.BitString.random(\n            len(condition.mask),\n            self.mutation_probability\n        )\n        mask = condition.mask ^ mutation_points\n\n        # The bits that aren't wildcards always have the same value as the\n        # situation, which ensures that the mutated condition still matches\n        # the situation.\n        if isinstance(situation, bitstrings.BitCondition):\n            mask &= situation.mask\n            return bitstrings.BitCondition(situation.bits, mask)\n        return bitstrings.BitCondition(situation, mask)", "response": "Create a new condition from the given one by probabilistically applying point - wise mutations. Bits that were originally wildcarded\n        in the parent condition acquire their values from the provided situation apply their values from the provided condition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nestablish connection to the AMQP broker.", "response": "def establish_connection(self):\n        \"\"\"Establish connection to the AMQP broker.\"\"\"\n        conninfo = self.connection\n        if not conninfo.port:\n            conninfo.port = self.default_port\n        credentials = pika.PlainCredentials(conninfo.userid,\n                                            conninfo.password)\n        return self._connection_cls(pika.ConnectionParameters(\n                                           conninfo.hostname,\n                                           port=conninfo.port,\n                                           virtual_host=conninfo.virtual_host,\n                                           credentials=credentials))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndiscarding all messages in the queue.", "response": "def queue_purge(self, queue, **kwargs):\n        \"\"\"Discard all messages in the queue. This will delete the messages\n        and results in an empty queue.\"\"\"\n        return self.channel.queue_purge(queue=queue).message_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeclares a named queue.", "response": "def queue_declare(self, queue, durable, exclusive, auto_delete,\n            warn_if_exists=False, arguments=None):\n        \"\"\"Declare a named queue.\"\"\"\n\n        return self.channel.queue_declare(queue=queue,\n                                          durable=durable,\n                                          exclusive=exclusive,\n                                          auto_delete=auto_delete,\n                                          arguments=arguments)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclose the channel if open.", "response": "def close(self):\n        \"\"\"Close the channel if open.\"\"\"\n        if self._channel and not self._channel.handler.channel_close:\n            self._channel.close()\n        self._channel_ref = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nencapsulate data into a AMQP message.", "response": "def prepare_message(self, message_data, delivery_mode, priority=None,\n            content_type=None, content_encoding=None):\n        \"\"\"Encapsulate data into a AMQP message.\"\"\"\n        properties = pika.BasicProperties(priority=priority,\n                                          content_type=content_type,\n                                          content_encoding=content_encoding,\n                                          delivery_mode=delivery_mode)\n        return message_data, properties"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npublish a message to a named exchange.", "response": "def publish(self, message, exchange, routing_key, mandatory=None,\n            immediate=None, headers=None):\n        \"\"\"Publish a message to a named exchange.\"\"\"\n        body, properties = message\n\n        if headers:\n            properties.headers = headers\n\n        ret = self.channel.basic_publish(body=body,\n                                         properties=properties,\n                                         exchange=exchange,\n                                         routing_key=routing_key,\n                                         mandatory=mandatory,\n                                         immediate=immediate)\n        if mandatory or immediate:\n            self.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a unique consumer tag.", "response": "def _generate_consumer_tag(self):\n        \"\"\"Generate a unique consumer tag.\n\n        :rtype string:\n\n        \"\"\"\n        return \"%s.%s%s\" % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                self._next_consumer_tag())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndeclare the queue the exchange and binds the queue to the exchange.", "response": "def declare(self):\n        \"\"\"Declares the queue, the exchange and binds the queue to\n        the exchange.\"\"\"\n        arguments = None\n        routing_key = self.routing_key\n        if self.exchange_type == \"headers\":\n            arguments, routing_key = routing_key, \"\"\n\n        if self.queue:\n            self.backend.queue_declare(queue=self.queue, durable=self.durable,\n                                       exclusive=self.exclusive,\n                                       auto_delete=self.auto_delete,\n                                       arguments=self.queue_arguments,\n                                       warn_if_exists=self.warn_if_exists)\n        if self.exchange:\n            self.backend.exchange_declare(exchange=self.exchange,\n                                          type=self.exchange_type,\n                                          durable=self.durable,\n                                          auto_delete=self.auto_delete)\n        if self.queue:\n            self.backend.queue_bind(queue=self.queue,\n                                    exchange=self.exchange,\n                                    routing_key=routing_key,\n                                    arguments=arguments)\n        self._closed = False\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch(self, no_ack=None, auto_ack=None, enable_callbacks=False):\n        no_ack = no_ack or self.no_ack\n        auto_ack = auto_ack or self.auto_ack\n        message = self.backend.get(self.queue, no_ack=no_ack)\n        if message:\n            if auto_ack and not message.acknowledged:\n                message.ack()\n            if enable_callbacks:\n                self.receive(message.payload, message)\n        return message", "response": "Fetch the next message waiting on the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndiscard all waiting messages.", "response": "def discard_all(self, filterfunc=None):\n        \"\"\"Discard all waiting messages.\n\n        :param filterfunc: A filter function to only discard the messages this\n            filter returns.\n\n        :returns: the number of messages discarded.\n\n        *WARNING*: All incoming messages will be ignored and not processed.\n\n        Example using filter:\n\n            >>> def waiting_feeds_only(message):\n            ...     try:\n            ...         message_data = message.decode()\n            ...     except: # Should probably be more specific.\n            ...         pass\n            ...\n            ...     if message_data.get(\"type\") == \"feed\":\n            ...         return True\n            ...     else:\n            ...         return False\n        \"\"\"\n        if not filterfunc:\n            return self.backend.queue_purge(self.queue)\n\n        if self.no_ack or self.auto_ack:\n            raise Exception(\"discard_all: Can't use filter with auto/no-ack.\")\n\n        discarded_count = 0\n        while True:\n            message = self.fetch()\n            if message is None:\n                return discarded_count\n\n            if filterfunc(message):\n                message.ack()\n                discarded_count += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngoes into consume mode.", "response": "def wait(self, limit=None):\n        \"\"\"Go into consume mode.\n\n        Mostly for testing purposes and simple programs, you probably\n        want :meth:`iterconsume` or :meth:`iterqueue` instead.\n\n        This runs an infinite loop, processing all incoming messages\n        using :meth:`receive` to apply the message to all registered\n        callbacks.\n\n        \"\"\"\n        it = self.iterconsume(limit)\n        while True:\n            it.next()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iterqueue(self, limit=None, infinite=False):\n        for items_since_start in count():\n            item = self.fetch()\n            if (not infinite and item is None) or \\\n                    (limit and items_since_start >= limit):\n                raise StopIteration\n            yield item", "response": "Infinite iterator yielding pending messages from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncancel a running : meth : iterconsume session.", "response": "def cancel(self):\n        \"\"\"Cancel a running :meth:`iterconsume` session.\"\"\"\n        if self.channel_open:\n            try:\n                self.backend.cancel(self.consumer_tag)\n            except KeyError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the channel to the queue.", "response": "def close(self):\n        \"\"\"Close the channel to the queue.\"\"\"\n        self.cancel()\n        self.backend.close()\n        self._closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef qos(self, prefetch_size=0, prefetch_count=0, apply_global=False):\n        return self.backend.qos(prefetch_size, prefetch_count, apply_global)", "response": "Request specific Quality of Service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef declare(self):\n        self.backend.exchange_declare(exchange=self.exchange,\n                                      type=self.exchange_type,\n                                      durable=self.durable,\n                                      auto_delete=self.auto_delete)", "response": "Declare the exchange on the broker."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_message(self, message_data, delivery_mode=None, priority=None,\n                       content_type=None, content_encoding=None,\n                       serializer=None):\n        \"\"\"With any data, serialize it and encapsulate it in a AMQP\n        message with the proper headers set.\"\"\"\n\n        delivery_mode = delivery_mode or self.delivery_mode\n\n        # No content_type? Then we're serializing the data internally.\n        if not content_type:\n            serializer = serializer or self.serializer\n            (content_type, content_encoding,\n             message_data) = serialization.encode(message_data,\n                                                  serializer=serializer)\n        else:\n            # If the programmer doesn't want us to serialize,\n            # make sure content_encoding is set.\n            if isinstance(message_data, unicode):\n                if not content_encoding:\n                    content_encoding = 'utf-8'\n                message_data = message_data.encode(content_encoding)\n\n            # If they passed in a string, we can't know anything\n            # about it.  So assume it's binary data.\n            elif not content_encoding:\n                content_encoding = 'binary'\n\n        return self.backend.prepare_message(message_data, delivery_mode,\n                                            priority=priority,\n                                            content_type=content_type,\n                                            content_encoding=content_encoding)", "response": "Create a new AMQP message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, message_data, routing_key=None, delivery_mode=None,\n            mandatory=False, immediate=False, priority=0, content_type=None,\n            content_encoding=None, serializer=None, exchange=None):\n        \"\"\"Send a message.\n\n        :param message_data: The message data to send. Can be a list,\n            dictionary or a string.\n\n        :keyword routing_key: A custom routing key for the message.\n            If not set, the default routing key set in the :attr:`routing_key`\n            attribute is used.\n\n        :keyword mandatory: If set, the message has mandatory routing.\n            By default the message is silently dropped by the server if it\n            can't be routed to a queue. However - If the message is mandatory,\n            an exception will be raised instead.\n\n        :keyword immediate: Request immediate delivery.\n            If the message cannot be routed to a queue consumer immediately,\n            an exception will be raised. This is instead of the default\n            behaviour, where the server will accept and queue the message,\n            but with no guarantee that the message will ever be consumed.\n\n        :keyword delivery_mode: Override the default :attr:`delivery_mode`.\n\n        :keyword priority: The message priority, ``0`` to ``9``.\n\n        :keyword content_type: The messages content_type. If content_type\n            is set, no serialization occurs as it is assumed this is either\n            a binary object, or you've done your own serialization.\n            Leave blank if using built-in serialization as our library\n            properly sets content_type.\n\n        :keyword content_encoding: The character set in which this object\n            is encoded. Use \"binary\" if sending in raw binary objects.\n            Leave blank if using built-in serialization as our library\n            properly sets content_encoding.\n\n        :keyword serializer: Override the default :attr:`serializer`.\n\n        :keyword exchange: Override the exchange to publish to.\n            Note that this exchange must have been declared.\n\n        \"\"\"\n        headers = None\n        routing_key = routing_key or self.routing_key\n\n        if self.exchange_type == \"headers\":\n            headers, routing_key = routing_key, \"\"\n\n        exchange = exchange or self.exchange\n\n        message = self.create_message(message_data, priority=priority,\n                                      delivery_mode=delivery_mode,\n                                      content_type=content_type,\n                                      content_encoding=content_encoding,\n                                      serializer=serializer)\n        self.backend.publish(message,\n                             exchange=exchange, routing_key=routing_key,\n                             mandatory=mandatory, immediate=immediate,\n                             headers=headers)", "response": "Sends a message to the specified exchange."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a message to the topic.", "response": "def send(self, message_data, delivery_mode=None):\n        \"\"\"See :meth:`Publisher.send`\"\"\"\n        self.publisher.send(message_data, delivery_mode=delivery_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close(self):\n        self.consumer.close()\n        self.publisher.close()\n        self._closed = True", "response": "Close any open channels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _receive_callback(self, raw_message):\n        message = self.backend.message_to_python(raw_message)\n        if self.auto_ack and not message.acknowledged:\n            message.ack()\n        try:\n            decoded = message.decode()\n        except Exception, exc:\n            if not self.on_decode_error:\n                raise\n            self.on_decode_error(message, exc)\n        else:\n            self.receive(decoded, message)", "response": "Internal method used when a message is received in consume mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds another consumer from dictionary configuration.", "response": "def add_consumer_from_dict(self, queue, **options):\n        \"\"\"Add another consumer from dictionary configuration.\"\"\"\n        options.setdefault(\"routing_key\", options.pop(\"binding_key\", None))\n        consumer = Consumer(self.connection, queue=queue,\n                            backend=self.backend, **options)\n        self.consumers.append(consumer)\n        return consumer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_consumer(self, consumer):\n        consumer.backend = self.backend\n        self.consumers.append(consumer)", "response": "Add another consumer from a : class : Consumer instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeclares consumer so messages can be received from it using .", "response": "def _declare_consumer(self, consumer, nowait=False):\n        \"\"\"Declare consumer so messages can be received from it using\n        :meth:`iterconsume`.\"\"\"\n        if consumer.queue not in self._open_consumers:\n            # Use the ConsumerSet's consumer by default, but if the\n            # child consumer has a callback, honor it.\n            callback = consumer.callbacks and \\\n                consumer._receive_callback or self._receive_callback\n            self.backend.declare_consumer(queue=consumer.queue,\n                                          no_ack=consumer.no_ack,\n                                          nowait=nowait,\n                                          callback=callback,\n                                          consumer_tag=consumer.consumer_tag)\n            self._open_consumers[consumer.queue] = consumer.consumer_tag"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iterconsume(self, limit=None):\n        self.consume()\n        return self.backend.consume(limit=limit)", "response": "Iterate over all consumers in consume mode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cancel(self):\n        for consumer_tag in self._open_consumers.values():\n            try:\n                self.backend.cancel(consumer_tag)\n            except KeyError:\n                pass\n        self._open_consumers.clear()", "response": "Cancel a running : meth : iterconsume session."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_md_to_rst(source, destination=None, backup_dir=None):\n\n    # Doing this in the function instead of the module level ensures the\n    # error occurs when the function is called, rather than when the module\n    # is evaluated.\n    try:\n        import pypandoc\n    except ImportError:\n        # Don't give up right away; first try to install the python module.\n        os.system(\"pip install pypandoc\")\n        import pypandoc\n\n    # Set our destination path to a default, if necessary\n    destination = destination or (os.path.splitext(source)[0] + '.rst')\n\n    # Likewise for the backup directory\n    backup_dir = backup_dir or os.path.join(os.path.dirname(destination),\n                                            'bak')\n\n    bak_name = (os.path.basename(destination) +\n                time.strftime('.%Y%m%d%H%M%S.bak'))\n    bak_path = os.path.join(backup_dir, bak_name)\n\n    # If there's already a file at the destination path, move it out of the\n    # way, but don't delete it.\n    if os.path.isfile(destination):\n        if not os.path.isdir(os.path.dirname(bak_path)):\n            os.mkdir(os.path.dirname(bak_path))\n        os.rename(destination, bak_path)\n\n    try:\n        # Try to convert the file.\n        pypandoc.convert(\n            source,\n            'rst',\n            format='md',\n            outputfile=destination\n        )\n    except:\n        # If for any reason the conversion fails, try to put things back\n        # like we found them.\n        if os.path.isfile(destination):\n            os.remove(destination)\n        if os.path.isfile(bak_path):\n            os.rename(bak_path, destination)\n        raise", "response": "Try to convert the source file to an. rst file at the destination."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls the conversion routine on README. md to generate README. rst.", "response": "def build_readme(base_path=None):\n    \"\"\"Call the conversion routine on README.md to generate README.rst.\n    Why do all this? Because pypi requires reStructuredText, but markdown\n    is friendlier to work with and is nicer for GitHub.\"\"\"\n    if base_path:\n        path = os.path.join(base_path, 'README.md')\n    else:\n        path = 'README.md'\n    convert_md_to_rst(path)\n    print(\"Successfully converted README.md to README.rst\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sense(self):\n        self.current_situation = bitstrings.BitString([\n            random.randrange(2)\n            for _ in range(self.address_size + (1 << self.address_size))\n        ])\n        return self.current_situation", "response": "Return a situation encoded as a bit string which represents\n            the observable state of the environment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, action):\n\n        assert action in self.possible_actions\n\n        self.remaining_cycles -= 1\n        index = int(bitstrings.BitString(\n            self.current_situation[:self.address_size]\n        ))\n        bit = self.current_situation[self.address_size + index]\n        return action == bit", "response": "Execute the indicated action within the environment and return the resulting immediate reward dictated by the program."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the scenario starting it over for a new run.", "response": "def reset(self):\n        \"\"\"Reset the scenario, starting it over for a new run.\n\n        Usage:\n            if not scenario.more():\n                scenario.reset()\n\n        Arguments: None\n        Return: None\n        \"\"\"\n        self.remaining_cycles = self.initial_training_cycles\n        self.needle_index = random.randrange(self.input_size)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sense(self):\n        haystack = bitstrings.BitString.random(self.input_size)\n        self.needle_value = haystack[self.needle_index]\n        return haystack", "response": "Return a situation encoded as a bit string which represents\n            the observable state of the environment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the indicated action within the environment and return the resulting immediate reward dictated by the rewardPython program.", "response": "def execute(self, action):\n        \"\"\"Execute the indicated action within the environment and\n        return the resulting immediate reward dictated by the reward\n        program.\n\n        Usage:\n            immediate_reward = scenario.execute(selected_action)\n\n        Arguments:\n            action: The action to be executed within the current situation.\n        Return:\n            A float, the reward received for the action that was executed,\n            or None if no reward is offered.\n        \"\"\"\n\n        assert action in self.possible_actions\n\n        self.remaining_cycles -= 1\n        return action == self.needle_value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a sequence containing the possible actions that can be executed within the environment.", "response": "def get_possible_actions(self):\n        \"\"\"Return a sequence containing the possible actions that can be\n        executed within the environment.\n\n        Usage:\n            possible_actions = scenario.get_possible_actions()\n\n        Arguments: None\n        Return:\n            A sequence containing the possible actions which can be\n            executed within this scenario.\n        \"\"\"\n        possible_actions = self.wrapped.get_possible_actions()\n\n        if len(possible_actions) <= 20:\n            # Try to ensure that the possible actions are unique. Also, put\n            # them into a list so we can iterate over them safely before\n            # returning them; this avoids accidentally exhausting an\n            # iterator, if the wrapped class happens to return one.\n            try:\n                possible_actions = list(set(possible_actions))\n            except TypeError:\n                possible_actions = list(possible_actions)\n\n            try:\n                possible_actions.sort()\n            except TypeError:\n                pass\n\n            self.logger.info('Possible actions:')\n            for action in possible_actions:\n                self.logger.info('    %s', action)\n        else:\n            self.logger.info(\"%d possible actions.\", len(possible_actions))\n\n        return possible_actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sense(self):\n        situation = self.wrapped.sense()\n\n        self.logger.debug('Situation: %s', situation)\n\n        return situation", "response": "Return a situation encoded as a bit string which represents\n            the observable state of the environment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting the indicated action within the environment and return the resulting immediate reward.", "response": "def execute(self, action):\n        \"\"\"Execute the indicated action within the environment and\n        return the resulting immediate reward dictated by the reward\n        program.\n\n        Usage:\n            immediate_reward = scenario.execute(selected_action)\n\n        Arguments:\n            action: The action to be executed within the current situation.\n        Return:\n            A float, the reward received for the action that was executed,\n            or None if no reward is offered.\n        \"\"\"\n\n        self.logger.debug('Executing action: %s', action)\n\n        reward = self.wrapped.execute(action)\n        if reward:\n            self.total_reward += reward\n        self.steps += 1\n\n        self.logger.debug('Reward received on this step: %.5f',\n                          reward or 0)\n        self.logger.debug('Average reward per step: %.5f',\n                          self.total_reward / self.steps)\n\n        return reward"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef more(self):\n        more = self.wrapped.more()\n\n        if not self.steps % 100:\n            self.logger.info('Steps completed: %d', self.steps)\n            self.logger.info('Average reward per step: %.5f',\n                             self.total_reward / (self.steps or 1))\n        if not more:\n            self.logger.info('Run completed.')\n            self.logger.info('Total steps: %d', self.steps)\n            self.logger.info('Total reward received: %.5f',\n                             self.total_reward)\n            self.logger.info('Average reward per step: %.5f',\n                             self.total_reward / (self.steps or 1))\n\n        return more", "response": "Return a Boolean indicating whether additional situations may be executed in the current run."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, action):\n        reward = self.reward_function(\n            action,\n            self.classifications[self.steps]\n        )\n        self.total_reward += reward\n        self.steps += 1\n        return reward", "response": "Execute the indicated action within the environment and return the resulting immediate reward dictated by the reward_function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_classifications(self):\n        if bitstrings.using_numpy():\n            return numpy.array(self.classifications)\n        else:\n            return self.classifications", "response": "Returns the classifications made by the algorithm for this\n            scenario."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_model(self, scenario):\n        assert isinstance(scenario, scenarios.Scenario)\n        return ClassifierSet(self, scenario.get_possible_actions())", "response": "Create and return a new untrained classifier set initialized for handling\n        the given scenario."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, scenario):\n        assert isinstance(scenario, scenarios.Scenario)\n        model = self.new_model(scenario)\n        model.run(scenario, learn=True)\n        return model", "response": "Run the algorithm and return a classifier set that was trained on the given scenario."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the combined prediction and prediction weight for thisCOOKIE.", "response": "def _compute_prediction(self):\n        \"\"\"Compute the combined prediction and prediction weight for this\n        action set. The combined prediction is the weighted average of the\n        individual predictions of the classifiers. The combined prediction\n        weight is the sum of the individual prediction weights of the\n        classifiers.\n\n        Usage:\n            Do not call this method directly. Use the prediction and/or\n            prediction_weight properties instead.\n\n        Arguments: None\n        Return: None\n        \"\"\"\n        total_weight = 0\n        total_prediction = 0\n        for rule in self._rules.values():\n            total_weight += rule.prediction_weight\n            total_prediction += (rule.prediction *\n                                 rule.prediction_weight)\n        self._prediction = total_prediction / (total_weight or 1)\n        self._prediction_weight = total_weight"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef best_prediction(self):\n        if self._best_prediction is None and self._action_sets:\n            self._best_prediction = max(\n                action_set.prediction\n                for action_set in self._action_sets.values()\n            )\n        return self._best_prediction", "response": "The highest value from among the predictions made by the action\n            sets in this match set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef best_actions(self):\n        if self._best_actions is None:\n            best_prediction = self.best_prediction\n            self._best_actions = tuple(\n                action\n                for action, action_set in self._action_sets.items()\n                if action_set.prediction == best_prediction\n            )\n        return self._best_actions", "response": "A tuple containing the actions whose action sets have the best\n            prediction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_action(self):\n        if self._selected_action is not None:\n            raise ValueError(\"The action has already been selected.\")\n        strategy = self._algorithm.action_selection_strategy\n        self._selected_action = strategy(self)\n        return self._selected_action", "response": "Select an action according to the action selection strategy of the associated algorithm."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _set_selected_action(self, action):\n        assert action in self._action_sets\n\n        if self._selected_action is not None:\n            raise ValueError(\"The action has already been selected.\")\n        self._selected_action = action", "response": "Setter method for the selected_action property."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_payoff(self, payoff):\n        if self._selected_action is None:\n            raise ValueError(\"The action has not been selected yet.\")\n        if self._closed:\n            raise ValueError(\"The payoff for this match set has already\"\n                             \"been applied.\")\n        self._payoff = float(payoff)", "response": "Setter method for the payoff property."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pay(self, predecessor):\n        assert predecessor is None or isinstance(predecessor, MatchSet)\n\n        if predecessor is not None:\n            expectation = self._algorithm.get_future_expectation(self)\n            predecessor.payoff += expectation", "response": "This method pays the amount of time until the predecessor has been fulfilled."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying the payoff that has been accumulated from immediate reward and or payments from successor match sets.", "response": "def apply_payoff(self):\n        \"\"\"Apply the payoff that has been accumulated from immediate\n        reward and/or payments from successor match sets. Attempting to\n        call this method before an action has been selected or after it\n        has already been called for the same match set will result in a\n        ValueError.\n\n        Usage:\n            match_set.select_action()\n            match_set.payoff = reward\n            match_set.apply_payoff()\n\n        Arguments: None\n        Return: None\n        \"\"\"\n        if self._selected_action is None:\n            raise ValueError(\"The action has not been selected yet.\")\n        if self._closed:\n            raise ValueError(\"The payoff for this match set has already\"\n                             \"been applied.\")\n        self._algorithm.distribute_payoff(self)\n        self._payoff = 0\n        self._algorithm.update(self)\n        self._closed = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccept a situation and return a MatchSet containing the classifier rules whose conditions match the situation.", "response": "def match(self, situation):\n        \"\"\"Accept a situation (input) and return a MatchSet containing the\n        classifier rules whose conditions match the situation. If\n        appropriate per the algorithm managing this classifier set, create\n        new rules to ensure sufficient coverage of the possible actions.\n\n        Usage:\n            match_set = model.match(situation)\n\n        Arguments:\n            situation: The situation for which a match set is desired.\n        Return:\n            A MatchSet instance for the given situation, drawn from the\n            classifier rules in this classifier set.\n        \"\"\"\n\n        # Find the conditions that match against the current situation, and\n        # group them according to which action(s) they recommend.\n        by_action = {}\n        for condition, actions in self._population.items():\n            if not condition(situation):\n                continue\n\n            for action, rule in actions.items():\n                if action in by_action:\n                    by_action[action][condition] = rule\n                else:\n                    by_action[action] = {condition: rule}\n\n        # Construct the match set.\n        match_set = MatchSet(self, situation, by_action)\n\n        # If an insufficient number of actions are recommended, create some\n        # new rules (condition/action pairs) until there are enough actions\n        # being recommended.\n        if self._algorithm.covering_is_required(match_set):\n            # Ask the algorithm to provide a new classifier rule to add to\n            # the population.\n            rule = self._algorithm.cover(match_set)\n\n            # Ensure that the condition provided by the algorithm does\n            # indeed match the situation. If not, there is a bug in the\n            # algorithm.\n            assert rule.condition(situation)\n\n            # Add the new classifier, getting back a list of the rule(s)\n            # which had to be removed to make room for it.\n            replaced = self.add(rule)\n\n            # Remove the rules that were removed the population from the\n            # action set, as well. Note that they may not appear in the\n            # action set, in which case nothing is done.\n            for replaced_rule in replaced:\n                action = replaced_rule.action\n                condition = replaced_rule.condition\n                if action in by_action and condition in by_action[action]:\n                    del by_action[action][condition]\n                    if not by_action[action]:\n                        del by_action[action]\n\n            # Add the new classifier to the action set. This is done after\n            # the replaced rules are removed, just in case the algorithm\n            # provided us with a rule that was already present and was\n            # displaced.\n            if rule.action not in by_action:\n                by_action[rule.action] = {}\n            by_action[rule.action][rule.condition] = rule\n\n            # Reconstruct the match set with the modifications we just\n            # made.\n            match_set = MatchSet(self, situation, by_action)\n\n        # Return the newly created match set.\n        return match_set"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new rule to the classifier set.", "response": "def add(self, rule):\n        \"\"\"Add a new classifier rule to the classifier set. Return a list\n        containing zero or more rules that were deleted from the classifier\n        by the algorithm in order to make room for the new rule. The rule\n        argument should be a ClassifierRule instance. The behavior of this\n        method depends on whether the rule already exists in the\n        classifier set. When a rule is already present, the rule's\n        numerosity is added to that of the version of the rule already\n        present in the population. Otherwise, the new rule is captured.\n        Note that this means that for rules already present in the\n        classifier set, the metadata of the existing rule is not\n        overwritten by that of the one passed in as an argument.\n\n        Usage:\n            displaced_rules = model.add(rule)\n\n        Arguments:\n            rule: A ClassifierRule instance which is to be added to this\n                classifier set.\n        Return:\n            A possibly empty list of ClassifierRule instances which were\n            removed altogether from the classifier set (as opposed to\n            simply having their numerosities decremented) in order to make\n            room for the newly added rule.\n        \"\"\"\n\n        assert isinstance(rule, ClassifierRule)\n\n        condition = rule.condition\n        action = rule.action\n\n        # If the rule already exists in the population, then we virtually\n        # add the rule by incrementing the existing rule's numerosity. This\n        # prevents redundancy in the rule set. Otherwise we capture the\n        # new rule.\n        if condition not in self._population:\n            self._population[condition] = {}\n\n        if action in self._population[condition]:\n            existing_rule = self._population[condition][action]\n            existing_rule.numerosity += rule.numerosity\n        else:\n            self._population[condition][action] = rule\n\n        # Any time we add a rule, we need to call this to keep the\n        # population size under control.\n        return self._algorithm.prune(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef discard(self, rule, count=1):\n        assert isinstance(rule, ClassifierRule)\n        assert isinstance(count, int) and count >= 0\n\n        rule = self.get(rule)\n        if rule is None:\n            return False\n\n        # Only actually remove the rule if its numerosity drops below 1.\n        rule.numerosity -= count\n        if rule.numerosity <= 0:\n            # Ensure that if there is still a reference to this rule\n            # elsewhere, its numerosity is still well-defined.\n            rule.numerosity = 0\n\n            del self._population[rule.condition][rule.action]\n            if not self._population[rule.condition]:\n                del self._population[rule.condition]\n            return True\n\n        return False", "response": "Removes one or more instances of a rule from the classifier set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the existing version of the given rule.", "response": "def get(self, rule, default=None):\n        \"\"\"Return the existing version of the given rule. If the rule is\n        not present in the classifier set, return the default. If no\n        default was given, use None. This is useful for eliminating\n        duplicate copies of rules.\n\n        Usage:\n            unique_rule = model.get(possible_duplicate, possible_duplicate)\n\n        Arguments:\n            rule: The ClassifierRule instance which may be a duplicate of\n                another already contained in the classifier set.\n            default: The value returned if the rule is not a duplicate of\n                another already contained in the classifier set.\n        Return:\n            If the rule is a duplicate of another already contained in the\n            classifier set, the existing one is returned. Otherwise, the\n            value of default is returned.\n        \"\"\"\n        assert isinstance(rule, ClassifierRule)\n\n        if (rule.condition not in self._population or\n                rule.action not in self._population[rule.condition]):\n            return default\n        return self._population[rule.condition][rule.action]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the algorithm utilizing the classifier set to choose the most appropriate action for each situation produced by the classifier set and then execute the selected action.", "response": "def run(self, scenario, learn=True):\n        \"\"\"Run the algorithm, utilizing the classifier set to choose the\n        most appropriate action for each situation produced by the\n        scenario. If learn is True, improve the situation/action mapping to\n        maximize reward. Otherwise, ignore any reward received.\n\n        Usage:\n            model.run(scenario, learn=True)\n\n        Arguments:\n            scenario: A Scenario instance which this classifier set is to\n                interact with.\n            learn: A bool indicating whether the classifier set should\n                attempt to optimize its performance based on reward\n                received for each action, as opposed to simply using what\n                it has already learned from previous runs and ignoring\n                reward received; default is True.\n        Return: None\n        \"\"\"\n\n        assert isinstance(scenario, scenarios.Scenario)\n\n        previous_match_set = None\n\n        # Repeat until the scenario has run its course.\n        while scenario.more():\n            # Gather information about the current state of the\n            # environment.\n            situation = scenario.sense()\n\n            # Determine which rules match the current situation.\n            match_set = self.match(situation)\n\n            # Select the best action for the current situation (or a random\n            # one, if we are on an exploration step).\n            match_set.select_action()\n\n            # Perform the selected action\n            # and find out what the received reward was.\n            reward = scenario.execute(match_set.selected_action)\n\n            # If the scenario is dynamic, don't immediately apply the\n            # reward; instead, wait until the next iteration and factor in\n            # not only the reward that was received on the previous step,\n            # but the (discounted) reward that is expected going forward\n            # given the resulting situation observed after the action was\n            # taken. This is a classic feature of temporal difference (TD)\n            # algorithms, which acts to stitch together a general picture\n            # of the future expected reward without actually waiting the\n            # full duration to find out what it will be.\n            if learn:\n                # Ensure we are not trying to learn in a non-learning\n                # scenario.\n                assert reward is not None\n\n                if scenario.is_dynamic:\n                    if previous_match_set is not None:\n                        match_set.pay(previous_match_set)\n                        previous_match_set.apply_payoff()\n                    match_set.payoff = reward\n\n                    # Remember the current reward and match set for the\n                    # next iteration.\n                    previous_match_set = match_set\n                else:\n                    match_set.payoff = reward\n                    match_set.apply_payoff()\n\n        # This serves to tie off the final stitch. The last action taken\n        # gets only the immediate reward; there is no future reward\n        # expected.\n        if learn and previous_match_set is not None:\n            previous_match_set.apply_payoff()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist configuration files detected and examined paths.", "response": "def ls(system, user, local, include_missing):\n    \"\"\"List configuration files detected (and/or examined paths).\"\"\"\n\n    # default action is to list *all* auto-detected files\n    if not (system or user or local):\n        system = user = local = True\n\n    for path in get_configfile_paths(system=system, user=user, local=local,\n                                     only_existing=not include_missing):\n        click.echo(path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninspecting existing configuration file and profile.", "response": "def inspect(config_file, profile):\n    \"\"\"Inspect existing configuration/profile.\"\"\"\n\n    try:\n        section = load_profile_from_files(\n            [config_file] if config_file else None, profile)\n\n        click.echo(\"Configuration file: {}\".format(config_file if config_file else \"auto-detected\"))\n        click.echo(\"Profile: {}\".format(profile if profile else \"auto-detected\"))\n        click.echo(\"---\")\n        for key, val in section.items():\n            click.echo(\"{} = {}\".format(key, val))\n\n    except (ValueError, ConfigFileReadError, ConfigFileParseError) as e:\n        click.echo(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(config_file, profile):\n\n    # determine the config file path\n    if config_file:\n        click.echo(\"Using configuration file: {}\".format(config_file))\n    else:\n        # path not given, try to detect; or use default, but allow user to override\n        config_file = get_configfile_path()\n        if config_file:\n            click.echo(\"Found existing configuration file: {}\".format(config_file))\n        else:\n            config_file = get_default_configfile_path()\n            click.echo(\"Configuration file not found; the default location is: {}\".format(config_file))\n        config_file = default_text_input(\"Configuration file path\", config_file)\n        config_file = os.path.expanduser(config_file)\n\n    # create config_file path\n    config_base = os.path.dirname(config_file)\n    if config_base and not os.path.exists(config_base):\n        if click.confirm(\"Configuration file path does not exist. Create it?\", abort=True):\n            try:\n                os.makedirs(config_base)\n            except Exception as e:\n                click.echo(\"Error creating configuration path: {}\".format(e))\n                return 1\n\n    # try loading existing config, or use defaults\n    try:\n        config = load_config_from_files([config_file])\n    except:\n        config = get_default_config()\n\n    # determine profile\n    if profile:\n        click.echo(\"Using profile: {}\".format(profile))\n    else:\n        existing = config.sections()\n        if existing:\n            profiles = 'create new or choose from: {}'.format(', '.join(existing))\n            default_profile = ''\n        else:\n            profiles = 'create new'\n            default_profile = 'prod'\n        profile = default_text_input(\"Profile (%s)\" % profiles, default_profile, optional=False)\n\n    if not config.has_section(profile):\n        config.add_section(profile)\n\n    # fill out the profile variables\n    variables = 'endpoint token client solver proxy'.split()\n    prompts = ['API endpoint URL',\n               'Authentication token',\n               'Default client class (qpu or sw)',\n               'Default solver']\n    for var, prompt in zip(variables, prompts):\n        default_val = config.get(profile, var, fallback=None)\n        val = default_text_input(prompt, default_val)\n        if val:\n            val = os.path.expandvars(val)\n        if val != default_val:\n            config.set(profile, var, val)\n\n    try:\n        with open(config_file, 'w') as fp:\n            config.write(fp)\n    except Exception as e:\n        click.echo(\"Error writing to configuration file: {}\".format(e))\n        return 2\n\n    click.echo(\"Configuration saved.\")\n    return 0", "response": "Create and or update cloud client configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _ping(config_file, profile, solver_def, request_timeout, polling_timeout, output):\n\n    config = dict(config_file=config_file, profile=profile, solver=solver_def)\n    if request_timeout is not None:\n        config.update(request_timeout=request_timeout)\n    if polling_timeout is not None:\n        config.update(polling_timeout=polling_timeout)\n    try:\n        client = Client.from_config(**config)\n    except Exception as e:\n        raise CLIError(\"Invalid configuration: {}\".format(e), code=1)\n    if config_file:\n        output(\"Using configuration file: {config_file}\", config_file=config_file)\n    if profile:\n        output(\"Using profile: {profile}\", profile=profile)\n    output(\"Using endpoint: {endpoint}\", endpoint=client.endpoint)\n\n    t0 = timer()\n    try:\n        solver = client.get_solver()\n    except SolverAuthenticationError:\n        raise CLIError(\"Authentication error. Check credentials in your configuration file.\", 2)\n    except SolverNotFoundError:\n        raise CLIError(\"Solver not available.\", 6)\n    except (InvalidAPIResponseError, UnsupportedSolverError):\n        raise CLIError(\"Invalid or unexpected API response.\", 3)\n    except RequestTimeout:\n        raise CLIError(\"API connection timed out.\", 4)\n    except requests.exceptions.SSLError as e:\n        # we need to handle `ssl.SSLError` wrapped in several exceptions,\n        # with differences between py2/3; greping the message is the easiest way\n        if 'CERTIFICATE_VERIFY_FAILED' in str(e):\n            raise CLIError(\n                \"Certificate verification failed. Please check that your API endpoint \"\n                \"is correct. If you are connecting to a private or third-party D-Wave \"\n                \"system that uses self-signed certificate(s), please see \"\n                \"https://support.dwavesys.com/hc/en-us/community/posts/360018930954.\", 5)\n        raise CLIError(\"Unexpected SSL error while fetching solver: {!r}\".format(e), 5)\n    except Exception as e:\n        raise CLIError(\"Unexpected error while fetching solver: {!r}\".format(e), 5)\n\n    t1 = timer()\n    output(\"Using solver: {solver_id}\", solver_id=solver.id)\n\n    try:\n        future = solver.sample_ising({0: 1}, {})\n        timing = future.timing\n    except RequestTimeout:\n        raise CLIError(\"API connection timed out.\", 8)\n    except PollingTimeout:\n        raise CLIError(\"Polling timeout exceeded.\", 9)\n    except Exception as e:\n        raise CLIError(\"Sampling error: {!r}\".format(e), 10)\n    finally:\n        output(\"Submitted problem ID: {problem_id}\", problem_id=future.id)\n\n    t2 = timer()\n\n    output(\"\\nWall clock time:\")\n    output(\" * Solver definition fetch: {wallclock_solver_definition:.3f} ms\", wallclock_solver_definition=(t1-t0)*1000.0)\n    output(\" * Problem submit and results fetch: {wallclock_sampling:.3f} ms\", wallclock_sampling=(t2-t1)*1000.0)\n    output(\" * Total: {wallclock_total:.3f} ms\", wallclock_total=(t2-t0)*1000.0)\n    if timing.items():\n        output(\"\\nQPU timing:\")\n        for component, duration in timing.items():\n            output(\" * %(name)s = {%(name)s} us\" % {\"name\": component}, **{component: duration})\n    else:\n        output(\"\\nQPU timing data not available.\")", "response": "Ping the D - Wave API."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npings the QPU by submitting a single - qubit problem.", "response": "def ping(config_file, profile, solver_def, json_output, request_timeout, polling_timeout):\n    \"\"\"Ping the QPU by submitting a single-qubit problem.\"\"\"\n\n    now = utcnow()\n    info = dict(datetime=now.isoformat(), timestamp=datetime_to_timestamp(now), code=0)\n\n    def output(fmt, **kwargs):\n        info.update(kwargs)\n        if not json_output:\n            click.echo(fmt.format(**kwargs))\n\n    def flush():\n        if json_output:\n            click.echo(json.dumps(info))\n\n    try:\n        _ping(config_file, profile, solver_def, request_timeout, polling_timeout, output)\n    except CLIError as error:\n        output(\"Error: {error} (code: {code})\", error=str(error), code=error.code)\n        sys.exit(error.code)\n    except Exception as error:\n        output(\"Unhandled error: {error}\", error=str(error))\n        sys.exit(127)\n    finally:\n        flush()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting solver details. Unless solver name/id specified, fetch and display details for all online solvers available on the configured endpoint.", "response": "def solvers(config_file, profile, solver_def, list_solvers):\n    \"\"\"Get solver details.\n\n    Unless solver name/id specified, fetch and display details for\n    all online solvers available on the configured endpoint.\n    \"\"\"\n\n    with Client.from_config(\n            config_file=config_file, profile=profile, solver=solver_def) as client:\n\n        try:\n            solvers = client.get_solvers(**client.default_solver)\n        except SolverNotFoundError:\n            click.echo(\"Solver(s) {} not found.\".format(solver_def))\n            return 1\n\n        if list_solvers:\n            for solver in solvers:\n                click.echo(solver.id)\n            return\n\n        # ~YAML output\n        for solver in solvers:\n            click.echo(\"Solver: {}\".format(solver.id))\n            click.echo(\"  Parameters:\")\n            for name, val in sorted(solver.parameters.items()):\n                click.echo(\"    {}: {}\".format(name, strtrunc(val) if val else '?'))\n            solver.properties.pop('parameters', None)\n            click.echo(\"  Properties:\")\n            for name, val in sorted(solver.properties.items()):\n                click.echo(\"    {}: {}\".format(name, strtrunc(val)))\n            click.echo(\"  Derived properties:\")\n            for name in sorted(solver.derived_properties):\n                click.echo(\"    {}: {}\".format(name, strtrunc(getattr(solver, name))))\n            click.echo()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsubmits Ising - formulated problem and return samples.", "response": "def sample(config_file, profile, solver_def, biases, couplings, random_problem,\n           num_reads, verbose):\n    \"\"\"Submit Ising-formulated problem and return samples.\"\"\"\n\n    # TODO: de-dup wrt ping\n\n    def echo(s, maxlen=100):\n        click.echo(s if verbose else strtrunc(s, maxlen))\n\n    try:\n        client = Client.from_config(\n            config_file=config_file, profile=profile, solver=solver_def)\n    except Exception as e:\n        click.echo(\"Invalid configuration: {}\".format(e))\n        return 1\n    if config_file:\n        echo(\"Using configuration file: {}\".format(config_file))\n    if profile:\n        echo(\"Using profile: {}\".format(profile))\n    echo(\"Using endpoint: {}\".format(client.endpoint))\n\n    try:\n        solver = client.get_solver()\n    except SolverAuthenticationError:\n        click.echo(\"Authentication error. Check credentials in your configuration file.\")\n        return 1\n    except (InvalidAPIResponseError, UnsupportedSolverError):\n        click.echo(\"Invalid or unexpected API response.\")\n        return 2\n    except SolverNotFoundError:\n        click.echo(\"Solver with the specified features does not exist.\")\n        return 3\n\n    echo(\"Using solver: {}\".format(solver.id))\n\n    if random_problem:\n        linear, quadratic = generate_random_ising_problem(solver)\n    else:\n        try:\n            linear = ast.literal_eval(biases) if biases else []\n        except Exception as e:\n            click.echo(\"Invalid biases: {}\".format(e))\n        try:\n            quadratic = ast.literal_eval(couplings) if couplings else {}\n        except Exception as e:\n            click.echo(\"Invalid couplings: {}\".format(e))\n\n    echo(\"Using qubit biases: {!r}\".format(linear))\n    echo(\"Using qubit couplings: {!r}\".format(quadratic))\n    echo(\"Number of samples: {}\".format(num_reads))\n\n    try:\n        result = solver.sample_ising(linear, quadratic, num_reads=num_reads).result()\n    except Exception as e:\n        click.echo(e)\n        return 4\n\n    if verbose:\n        click.echo(\"Result: {!r}\".format(result))\n\n    echo(\"Samples: {!r}\".format(result['samples']))\n    echo(\"Occurrences: {!r}\".format(result['occurrences']))\n    echo(\"Energies: {!r}\".format(result['energies']))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_input_callback(samplerate, params, num_samples=256):\n    amplitude = params['mod_amplitude']\n    frequency = params['mod_frequency']\n\n    def producer():\n        \"\"\"Generate samples.\n\n        Yields\n        ------\n        samples : ndarray\n            A number of samples (`num_samples`) of the sine.\n        \"\"\"\n        start_time = 0\n        while True:\n            time = start_time + np.arange(num_samples) / samplerate\n            start_time += num_samples / samplerate\n            output = amplitude * np.cos(2 * np.pi * frequency * time)\n            yield output\n\n    return lambda p=producer(): next(p)", "response": "Returns a function that produces samples of a sine."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a callback that can be used to play the next frame of the next frame of the next frame.", "response": "def get_playback_callback(resampler, samplerate, params):\n    \"\"\"Return a sound playback callback.\n\n    Parameters\n    ----------\n    resampler\n        The resampler from which samples are read.\n    samplerate : float\n        The sample rate.\n    params : dict\n        Parameters for FM generation.\n    \"\"\"\n\n    def callback(outdata, frames, time, _):\n        \"\"\"Playback callback.\n\n        Read samples from the resampler and modulate them onto a carrier\n        frequency.\n        \"\"\"\n        last_fmphase = getattr(callback, 'last_fmphase', 0)\n        df = params['fm_gain'] * resampler.read(frames)\n        df = np.pad(df, (0, frames - len(df)), mode='constant')\n        t = time.outputBufferDacTime + np.arange(frames) / samplerate\n        phase = 2 * np.pi * params['carrier_frequency'] * t\n        fmphase = last_fmphase + 2 * np.pi * np.cumsum(df) / samplerate\n        outdata[:, 0] = params['output_volume'] * np.cos(phase + fmphase)\n        callback.last_fmphase = fmphase[-1]\n\n    return callback"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(source_samplerate, target_samplerate, params, converter_type):\n    from time import sleep\n\n    ratio = target_samplerate / source_samplerate\n\n    with sr.CallbackResampler(get_input_callback(source_samplerate, params),\n                              ratio, converter_type) as resampler, \\\n            sd.OutputStream(channels=1, samplerate=target_samplerate,\n                            callback=get_playback_callback(\n                                resampler, target_samplerate, params)):\n        print(\"Playing back...  Ctrl+C to stop.\")\n        try:\n            while True:\n                sleep(1)\n        except KeyboardInterrupt:\n            print(\"Aborting.\")", "response": "Setup the resampling and audio output callbacks and start playback."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the maximum number of reads for the given solver parameters.", "response": "def max_num_reads(self, **params):\n        \"\"\"Returns the maximum number of reads for the given solver parameters.\n\n        Args:\n            **params:\n                Parameters for the sampling method. Relevant to num_reads:\n\n                - annealing_time\n                - readout_thermalization\n                - num_reads\n                - programming_thermalization\n\n        Returns:\n            int: The maximum number of reads.\n\n        \"\"\"\n        # dev note: in the future it would be good to have a way of doing this\n        # server-side, as we are duplicating logic here.\n\n        properties = self.properties\n\n        if self.software or not params:\n            # software solvers don't use any of the above parameters\n            return properties['num_reads_range'][1]\n\n        # qpu\n\n        _, duration = properties['problem_run_duration_range']\n\n        annealing_time = params.get('annealing_time',\n                                    properties['default_annealing_time'])\n\n        readout_thermalization = params.get('readout_thermalization',\n                                            properties['default_readout_thermalization'])\n\n        programming_thermalization = params.get('programming_thermalization',\n                                                properties['default_programming_thermalization'])\n\n        return min(properties['num_reads_range'][1],\n                   int((duration - programming_thermalization)\n                       / (annealing_time + readout_thermalization)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sample_ising(self, linear, quadratic, **params):\n        # Our linear and quadratic objective terms are already separated in an\n        # ising model so we can just directly call `_sample`.\n        return self._sample('ising', linear, quadratic, params)", "response": "Sample from the specified Ising model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sample_qubo(self, qubo, **params):\n        # In a QUBO the linear and quadratic terms in the objective are mixed into\n        # a matrix. For the sake of encoding, we will separate them before calling `_sample`\n        linear = {i1: v for (i1, i2), v in uniform_iterator(qubo) if i1 == i2}\n        quadratic = {(i1, i2): v for (i1, i2), v in uniform_iterator(qubo) if i1 != i2}\n        return self._sample('qubo', linear, quadratic, params)", "response": "Sample from the specified binary contains an unconstrained binary entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _sample(self, type_, linear, quadratic, params):\n        # Check the problem\n        if not self.check_problem(linear, quadratic):\n            raise ValueError(\"Problem graph incompatible with solver.\")\n\n        # Mix the new parameters with the default parameters\n        combined_params = dict(self._params)\n        combined_params.update(params)\n\n        # Check the parameters before submitting\n        for key in combined_params:\n            if key not in self.parameters and not key.startswith('x_'):\n                raise KeyError(\"{} is not a parameter of this solver.\".format(key))\n\n        # transform some of the parameters in-place\n        self._format_params(type_, combined_params)\n\n        body = json.dumps({\n            'solver': self.id,\n            'data': encode_bqm_as_qp(self, linear, quadratic),\n            'type': type_,\n            'params': combined_params\n        })\n        _LOGGER.trace(\"Encoded sample request: %s\", body)\n\n        future = Future(solver=self, id_=None, return_matrix=self.return_matrix,\n                        submission_data=(type_, linear, quadratic, params))\n\n        _LOGGER.debug(\"Submitting new problem to: %s\", self.id)\n        self.client._submit(body, future)\n        return future", "response": "Internal method for both sample_ising and sample_qubo."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_params(self, type_, params):\n        if 'initial_state' in params:\n            # NB: at this moment the error raised when initial_state does not match lin/quad (in\n            # active qubits) is not very informative, but there is also no clean way to check here\n            # that they match because lin can be either a list or a dict. In the future it would be\n            # good to check.\n            initial_state = params['initial_state']\n            if isinstance(initial_state, Mapping):\n\n                initial_state_list = [3]*self.properties['num_qubits']\n\n                low = -1 if type_ == 'ising' else 0\n\n                for v, val in initial_state.items():\n                    if val == 3:\n                        continue\n                    if val <= 0:\n                        initial_state_list[v] = low\n                    else:\n                        initial_state_list[v] = 1\n\n                params['initial_state'] = initial_state_list", "response": "Reformat some of the parameters for sapi."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_problem(self, linear, quadratic):\n        for key, value in uniform_iterator(linear):\n            if value != 0 and key not in self.nodes:\n                return False\n        for key, value in uniform_iterator(quadratic):\n            if value != 0 and tuple(key) not in self.edges:\n                return False\n        return True", "response": "Test if an Ising model matches the graph provided by the solver."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _retrieve_problem(self, id_):\n        future = Future(self, id_, self.return_matrix, None)\n        self.client._poll(future)\n        return future", "response": "Resume polling for a problem previously submitted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the converter type for identifier.", "response": "def _get_converter_type(identifier):\n    \"\"\"Return the converter type for `identifier`.\"\"\"\n    if isinstance(identifier, str):\n        return ConverterType[identifier]\n    if isinstance(identifier, ConverterType):\n        return identifier\n    return ConverterType(identifier)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resample(input_data, ratio, converter_type='sinc_best', verbose=False):\n    from samplerate.lowlevel import src_simple\n    from samplerate.exceptions import ResamplingError\n\n    input_data = np.require(input_data, requirements='C', dtype=np.float32)\n    if input_data.ndim == 2:\n        num_frames, channels = input_data.shape\n        output_shape = (int(num_frames * ratio), channels)\n    elif input_data.ndim == 1:\n        num_frames, channels = input_data.size, 1\n        output_shape = (int(num_frames * ratio), )\n    else:\n        raise ValueError('rank > 2 not supported')\n\n    output_data = np.empty(output_shape, dtype=np.float32)\n    converter_type = _get_converter_type(converter_type)\n\n    (error, input_frames_used, output_frames_gen) \\\n        = src_simple(input_data, output_data, ratio,\n                     converter_type.value, channels)\n\n    if error != 0:\n        raise ResamplingError(error)\n\n    if verbose:\n        info = ('samplerate info:\\n'\n                '{} input frames used\\n'\n                '{} output frames generated\\n'\n                .format(input_frames_used, output_frames_gen))\n        print(info)\n\n    return (output_data[:output_frames_gen, :]\n            if channels > 1 else output_data[:output_frames_gen])", "response": "Resample the signal in input_data at once."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_ratio(self, new_ratio):\n        from samplerate.lowlevel import src_set_ratio\n        return src_set_ratio(self._state, new_ratio)", "response": "Set a new conversion ratio immediately."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create(self):\n        from samplerate.lowlevel import ffi, src_callback_new, src_delete\n        from samplerate.exceptions import ResamplingError\n\n        state, handle, error = src_callback_new(\n            self._callback, self._converter_type.value, self._channels)\n        if error != 0:\n            raise ResamplingError(error)\n        self._state = ffi.gc(state, src_delete)\n        self._handle = handle", "response": "Create new callback resampler."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_starting_ratio(self, ratio):\n        from samplerate.lowlevel import src_set_ratio\n        if self._state is None:\n            self._create()\n        src_set_ratio(self._state, ratio)\n        self.ratio = ratio", "response": "Set the starting conversion ratio for the next read call."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the state of the object.", "response": "def reset(self):\n        \"\"\"Reset state.\"\"\"\n        from samplerate.lowlevel import src_reset\n        if self._state is None:\n            self._create()\n        src_reset(self._state)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a number of frames from the resampler.", "response": "def read(self, num_frames):\n        \"\"\"Read a number of frames from the resampler.\n\n        Parameters\n        ----------\n        num_frames : int\n            Number of frames to read.\n\n        Returns\n        -------\n        output_data : ndarray\n            Resampled frames as a (`num_output_frames`, `num_channels`) or\n            (`num_output_frames`,) array. Note that this may return fewer frames\n            than requested, for example when no more input is available.\n        \"\"\"\n        from samplerate.lowlevel import src_callback_read, src_error\n        from samplerate.exceptions import ResamplingError\n\n        if self._state is None:\n            self._create()\n        if self._channels > 1:\n            output_shape = (num_frames, self._channels)\n        elif self._channels == 1:\n            output_shape = (num_frames, )\n        output_data = np.empty(output_shape, dtype=np.float32)\n\n        ret = src_callback_read(self._state, self._ratio, num_frames,\n                                output_data)\n        if ret == 0:\n            error = src_error(self._state)\n            if error:\n                raise ResamplingError(error)\n\n        return (output_data[:ret, :]\n                if self._channels > 1 else output_data[:ret])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_variance(seq):\n    m = get_mean(seq)\n    return sum((v-m)**2 for v in seq)/float(len(seq))", "response": "Calculate the batch variance of a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mean_absolute_error(seq, correct):\n    assert len(seq) == len(correct)\n    diffs = [abs(a-b) for a, b in zip(seq, correct)]\n    return sum(diffs)/float(len(diffs))", "response": "Calculate the mean absolute error of a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize(seq):\n    s = float(sum(seq))\n    return [v/s for v in seq]", "response": "Normalizes each number in the sequence so that the sum of all numbers equals 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the probability that a real - valued random variable X is found at a value less than or equal to mu and sigma.", "response": "def normcdf(x, mu, sigma):\n    \"\"\"\n    Describes the probability that a real-valued random variable X with a given\n    probability distribution will be found at a value less than or equal to X\n    in a normal distribution.\n    \n    http://en.wikipedia.org/wiki/Cumulative_distribution_function\n    \"\"\"\n    t = x-mu\n    y = 0.5*erfcc(-t/(sigma*math.sqrt(2.0)))\n    if y > 1.0:\n        y = 1.0\n    return y"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normpdf(x, mu, sigma):\n    u = (x-mu)/abs(sigma)\n    y = (1/(math.sqrt(2*pi)*abs(sigma)))*math.exp(-u*u/2)\n    return y", "response": "Returns the relative likelihood that a real - valued random variable X will\n    take on a given value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the entropy of the attribute attr in given data set.", "response": "def entropy(data, class_attr=None, method=DEFAULT_DISCRETE_METRIC):\n    \"\"\"\n    Calculates the entropy of the attribute attr in given data set data.\n    \n    Parameters:\n    data<dict|list> :=\n        if dict, treated as value counts of the given attribute name\n        if list, treated as a raw list from which the value counts will be generated\n    attr<string> := the name of the class attribute\n    \"\"\"\n    assert (class_attr is None and isinstance(data, dict)) \\\n        or (class_attr is not None and isinstance(data, list))\n    if isinstance(data, dict):\n        counts = data\n    else:\n        counts = defaultdict(float) # {attr:count}\n        for record in data:\n            # Note: A missing attribute is treated like an attribute with a value\n            # of None, representing the attribute is \"irrelevant\".\n            counts[record.get(class_attr)] += 1.0\n    len_data = float(sum(cnt for _, cnt in iteritems(counts)))\n    n = max(2, len(counts))\n    total = float(sum(counts.values()))\n    assert total, \"There must be at least one non-zero count.\"\n    try:\n        #return -sum((count/total)*math.log(count/total,n) for count in counts)\n        if method == ENTROPY1:\n            return -sum((count/len_data)*math.log(count/len_data, n)\n                for count in itervalues(counts) if count)\n        elif method == ENTROPY2:\n            return -sum((count/len_data)*math.log(count/len_data, n)\n                for count in itervalues(counts) if count) - ((len(counts)-1)/float(total))\n        elif method == ENTROPY3:\n            return -sum((count/len_data)*math.log(count/len_data, n)\n                for count in itervalues(counts) if count) - 100*((len(counts)-1)/float(total))\n        else:\n            raise Exception(\"Unknown entropy method %s.\" % method)\n    except Exception:\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the variance of a continuous class attribute.", "response": "def entropy_variance(data, class_attr=None,\n    method=DEFAULT_CONTINUOUS_METRIC):\n    \"\"\"\n    Calculates the variance fo a continuous class attribute, to be used as an\n    entropy metric.\n    \"\"\"\n    assert method in CONTINUOUS_METRICS, \"Unknown entropy variance metric: %s\" % (method,)\n    assert (class_attr is None and isinstance(data, dict)) \\\n        or (class_attr is not None and isinstance(data, list))\n    if isinstance(data, dict):\n        lst = data\n    else:\n        lst = [record.get(class_attr) for record in data]\n    return get_variance(lst)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_gain(data, attr, class_attr,\n    method=DEFAULT_DISCRETE_METRIC,\n    only_sub=0, prefer_fewer_values=False, entropy_func=None):\n    \"\"\"\n    Calculates the information gain (reduction in entropy) that would\n    result by splitting the data on the chosen attribute (attr).\n    \n    Parameters:\n    \n    prefer_fewer_values := Weights the gain by the count of the attribute's\n        unique values. If multiple attributes have the same gain, but one has\n        slightly fewer attributes, this will cause the one with fewer\n        attributes to be preferred.\n    \"\"\"\n    entropy_func = entropy_func or entropy\n    val_freq = defaultdict(float)\n    subset_entropy = 0.0\n\n    # Calculate the frequency of each of the values in the target attribute\n    for record in data:\n        val_freq[record.get(attr)] += 1.0\n\n    # Calculate the sum of the entropy for each subset of records weighted\n    # by their probability of occuring in the training set.\n    for val in val_freq.keys():\n        val_prob = val_freq[val] / sum(val_freq.values())\n        data_subset = [record for record in data if record.get(attr) == val]\n        e = entropy_func(data_subset, class_attr, method=method)\n        subset_entropy += val_prob * e\n        \n    if only_sub:\n        return subset_entropy\n\n    # Subtract the entropy of the chosen attribute from the entropy of the\n    # whole data set with respect to the target attribute (and return it)\n    main_entropy = entropy_func(data, class_attr, method=method)\n    \n    # Prefer gains on attributes with fewer values.\n    if prefer_fewer_values:\n#        n = len(val_freq)\n#        w = (n+1)/float(n)/2\n        #return (main_entropy - subset_entropy)*w\n        return ((main_entropy - subset_entropy), 1./len(val_freq))\n    else:\n        return (main_entropy - subset_entropy)", "response": "Calculates the information gain that would be reduced on the data set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef majority_value(data, class_attr):\n    if is_continuous(data[0][class_attr]):\n        return CDist(seq=[record[class_attr] for record in data])\n    else:\n        return most_frequent([record[class_attr] for record in data])", "response": "Returns the value that appears in the target attribute for each record in the data list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef most_frequent(lst):\n    lst = lst[:]\n    highest_freq = 0\n    most_freq = None\n\n    for val in unique(lst):\n        if lst.count(val) > highest_freq:\n            most_freq = val\n            highest_freq = lst.count(val)\n            \n    return most_freq", "response": "Returns the item that appears most frequently in the given list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list made up of the unique values found in lst.", "response": "def unique(lst):\n    \"\"\"\n    Returns a list made up of the unique values found in lst.  i.e., it\n    removes the redundant values in lst.\n    \"\"\"\n    lst = lst[:]\n    unique_lst = []\n\n    # Cycle through the list and add each value to the unique list only once.\n    for item in lst:\n        if unique_lst.count(item) <= 0:\n            unique_lst.append(item)\n            \n    # Return the list with all redundant values removed.\n    return unique_lst"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef choose_attribute(data, attributes, class_attr, fitness, method):\n    best = (-1e999999, None)\n    for attr in attributes:\n        if attr == class_attr:\n            continue\n        gain = fitness(data, attr, class_attr, method=method)\n        best = max(best, (gain, attr))\n    return best[1]", "response": "Given a list of attributes and a fitness method choose the attribute that is available in the order of the attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new decision tree based on the examples given.", "response": "def create_decision_tree(data, attributes, class_attr, fitness_func, wrapper, **kwargs):\n    \"\"\"\n    Returns a new decision tree based on the examples given.\n    \"\"\"\n    \n    split_attr = kwargs.get('split_attr', None)\n    split_val = kwargs.get('split_val', None)\n    \n    assert class_attr not in attributes\n    node = None\n    data = list(data) if isinstance(data, Data) else data\n    if wrapper.is_continuous_class:\n        stop_value = CDist(seq=[r[class_attr] for r in data])\n        # For a continuous class case, stop if all the remaining records have\n        # a variance below the given threshold.\n        stop = wrapper.leaf_threshold is not None \\\n            and stop_value.variance <= wrapper.leaf_threshold\n    else:\n        stop_value = DDist(seq=[r[class_attr] for r in data])\n        # For a discrete class, stop if all remaining records have the same\n        # classification.\n        stop = len(stop_value.counts) <= 1\n\n    if not data or len(attributes) <= 0:\n        # If the dataset is empty or the attributes list is empty, return the\n        # default value. The target attribute is not in the attributes list, so\n        # we need not subtract 1 to account for the target attribute.\n        if wrapper:\n            wrapper.leaf_count += 1\n        return stop_value\n    elif stop:\n        # If all the records in the dataset have the same classification,\n        # return that classification.\n        if wrapper:\n            wrapper.leaf_count += 1\n        return stop_value\n    else:\n        # Choose the next best attribute to best classify our data\n        best = choose_attribute(\n            data,\n            attributes,\n            class_attr,\n            fitness_func,\n            method=wrapper.metric)\n\n        # Create a new decision tree/node with the best attribute and an empty\n        # dictionary object--we'll fill that up next.\n#        tree = {best:{}}\n        node = Node(tree=wrapper, attr_name=best)\n        node.n += len(data)\n\n        # Create a new decision tree/sub-node for each of the values in the\n        # best attribute field\n        for val in get_values(data, best):\n            # Create a subtree for the current value under the \"best\" field\n            subtree = create_decision_tree(\n                [r for r in data if r[best] == val],\n                [attr for attr in attributes if attr != best],\n                class_attr,\n                fitness_func,\n                split_attr=best,\n                split_val=val,\n                wrapper=wrapper)\n\n            # Add the new subtree to the empty dictionary object in our new\n            # tree/node we just created.\n            if isinstance(subtree, Node):\n                node._branches[val] = subtree\n            elif isinstance(subtree, (CDist, DDist)):\n                node.set_leaf_dist(attr_value=val, dist=subtree)\n            else:\n                raise Exception(\"Unknown subtree type: %s\" % (type(subtree),))\n\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the count for the given element.", "response": "def add(self, k, count=1):\n        \"\"\"\n        Increments the count for the given element.\n        \"\"\"\n        self.counts[k] += count\n        self.total += count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the element with the highest probability.", "response": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of probabilities for all elements in the form", "response": "def probs(self):\n        \"\"\"\n        Returns a list of probabilities for all elements in the form\n        [(value1,prob1),(value2,prob2),...].\n        \"\"\"\n        return [\n            (k, self.counts[k]/float(self.total))\n            for k in iterkeys(self.counts)\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the counts of the current distribution with the given distribution s counts.", "response": "def update(self, dist):\n        \"\"\"\n        Adds the given distribution's counts to the current distribution.\n        \"\"\"\n        assert isinstance(dist, DDist)\n        for k, c in iteritems(dist.counts):\n            self.counts[k] += c\n        self.total += dist.total"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef probability_lt(self, x):\n        if self.mean is None:\n            return\n        return normdist(x=x, mu=self.mean, sigma=self.standard_deviation)", "response": "Returns the probability of a random variable being less than the given value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef probability_in(self, a, b):\n        if self.mean is None:\n            return\n        p1 = normdist(x=a, mu=self.mean, sigma=self.standard_deviation)\n        p2 = normdist(x=b, mu=self.mean, sigma=self.standard_deviation)\n        return abs(p1 - p2)", "response": "Returns the probability of a random variable falling between the given values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef probability_gt(self, x):\n        if self.mean is None:\n            return\n        p = normdist(x=x, mu=self.mean, sigma=self.standard_deviation)\n        return 1-p", "response": "Returns the probability of a random variable being greater than the given value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_no_data(self):\n        return type(self)(\n            [],\n            order=list(self.header_modes),\n            types=self.header_types.copy(),\n            modes=self.header_modes.copy())", "response": "Returns a copy of the object without any data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns true if the given value matches the type for the given name.", "response": "def is_valid(self, name, value):\n        \"\"\"\n        Returns true if the given value matches the type for the given name\n        according to the schema.\n        Returns false otherwise.\n        \"\"\"\n        if name not in self.header_types:\n            return False\n        t = self.header_types[name]\n        if t == ATTR_TYPE_DISCRETE:\n            return isinstance(value, int)\n        elif t == ATTR_TYPE_CONTINUOUS:\n            return isinstance(value, (float, Decimal))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_header(self):\n        if not self.filename or self.header_types:\n            return\n        rows = csv.reader(open(self.filename))\n        #header = rows.next()\n        header = next(rows)\n        self.header_types = {} # {attr_name:type}\n        self._class_attr_name = None\n        self.header_order = [] # [attr_name,...]\n        for el in header:\n            matches = ATTR_HEADER_PATTERN.findall(el)\n            assert matches, \"Invalid header element: %s\" % (el,)\n            el_name, el_type, el_mode = matches[0]\n            el_name = el_name.strip()\n            self.header_order.append(el_name)\n            self.header_types[el_name] = el_type\n            if el_mode == ATTR_MODE_CLASS:\n                assert self._class_attr_name is None, \\\n                    \"Multiple class attributes are not supported.\"\n                self._class_attr_name = el_name\n            else:\n                assert self.header_types[el_name] != ATTR_TYPE_CONTINUOUS, \\\n                    \"Non-class continuous attributes are not supported.\"\n        assert self._class_attr_name, \"A class attribute must be specified.\"", "response": "Reads the CSV file and populates the internal internal"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_row(self, row):\n        clean_row = {}\n        if isinstance(row, (tuple, list)):\n            assert self.header_order, \"No attribute order specified.\"\n            assert len(row) == len(self.header_order), \\\n                \"Row length does not match header length.\"\n            itr = zip(self.header_order, row)\n        else:\n            assert isinstance(row, dict)\n            itr = iteritems(row)\n        for el_name, el_value in itr:\n            if self.header_types[el_name] == ATTR_TYPE_DISCRETE:\n                clean_row[el_name] = int(el_value)\n            elif self.header_types[el_name] == ATTR_TYPE_CONTINUOUS:\n                clean_row[el_name] = float(el_value)\n            else:\n                clean_row[el_name] = el_value\n        return clean_row", "response": "Ensure each element in the row matches the schema."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef split(self, ratio=0.5, leave_one_out=False):\n        a_labels = set()\n        a = self.copy_no_data()\n        b = self.copy_no_data()\n        for row in self:\n            if leave_one_out and not self.is_continuous_class:\n                label = row[self.class_attribute_name]\n                if label not in a_labels:\n                    a_labels.add(label)\n                    a.data.append(row)\n                else:\n                    b.data.append(row)\n            elif not a:\n                a.data.append(row)\n            elif not b:\n                b.data.append(row)\n            elif random.random() <= ratio:\n                a.data.append(row)\n            else:\n                b.data.append(row)\n        return a, b", "response": "Returns two Data instances containing the data randomly split between the two."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_attribute_value_for_node(self, record):\n        \n        # Abort if this node has not get split on an attribute. \n        if self.attr_name is None:\n            return\n        \n        # Otherwise, lookup the attribute value for this node in the\n        # given record.\n        attr = self.attr_name\n        attr_value = record[attr]\n        attr_values = self.get_values(attr)\n        if attr_value in attr_values:\n            return attr_value\n        else:\n            # The value of the attribute in the given record does not directly\n            # map to any previously known values, so apply a missing value\n            # policy.\n            policy = self.tree.missing_value_policy.get(attr)\n            assert policy, \\\n                (\"No missing value policy specified for attribute %s.\") \\\n                % (attr,)\n            if policy == USE_NEAREST:\n                # Use the value that the tree has seen that's also has the\n                # smallest Euclidean distance to the actual value.\n                assert self.tree.data.header_types[attr] \\\n                    in (ATTR_TYPE_DISCRETE, ATTR_TYPE_CONTINUOUS), \\\n                    \"The use-nearest policy is invalid for nominal types.\"\n                nearest = (1e999999, None)\n                for _value in attr_values:\n                    nearest = min(\n                        nearest,\n                        (abs(_value - attr_value), _value))\n                _, nearest_value = nearest\n                return nearest_value\n            else:\n                raise Exception(\"Unknown missing value policy: %s\" % (policy,))", "response": "Get the closest value for the current node s attribute matching the current node s record."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the unique set of values seen for the given attribute.", "response": "def get_values(self, attr_name):\n        \"\"\"\n        Retrieves the unique set of values seen for the given attribute\n        at this node.\n        \"\"\"\n        ret = list(self._attr_value_cdist[attr_name].keys()) \\\n            + list(self._attr_value_counts[attr_name].keys()) \\\n            + list(self._branches.keys())\n        ret = set(ret)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_best_splitting_attr(self):\n        best = (-1e999999, None)\n        for attr in self.attributes:\n            best = max(best, (self.get_gain(attr), attr))\n        best_gain, best_attr = best\n        return best_attr", "response": "Returns the name of the attribute with the highest gain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_entropy(self, attr_name=None, attr_value=None):\n        is_con = self.tree.data.is_continuous_class\n        if is_con:\n            if attr_name is None:\n                # Calculate variance of class attribute.\n                var = self._class_cdist.variance\n            else:\n                # Calculate variance of the given attribute.\n                var = self._attr_value_cdist[attr_name][attr_value].variance\n            if self.tree.metric == VARIANCE1 or attr_name is None:\n                return var\n            elif self.tree.metric == VARIANCE2:\n                unique_value_count = len(self._attr_value_counts[attr_name])\n                attr_total = float(self._attr_value_count_totals[attr_name])\n                return var*(unique_value_count/attr_total)\n        else:\n            if attr_name is None:\n                # The total number of times this attr/value pair has been seen.\n                total = float(self._class_ddist.total)\n                # The total number of times each class value has been seen for\n                # this attr/value pair.\n                counts = self._class_ddist.counts\n                # The total number of unique values seen for this attribute.\n                unique_value_count = len(self._class_ddist.counts)\n                # The total number of times this attribute has been seen.\n                attr_total = total\n            else:\n                total = float(self._attr_value_counts[attr_name][attr_value])\n                counts = self._attr_class_value_counts[attr_name][attr_value]\n                unique_value_count = len(self._attr_value_counts[attr_name])\n                attr_total = float(self._attr_value_count_totals[attr_name])\n            assert total, \"There must be at least one non-zero count.\"\n            \n            n = max(2, len(counts))\n            if self._tree.metric == ENTROPY1:\n                # Traditional entropy.\n                return -sum(\n                    (count/total)*math.log(count/total, n)\n                    for count in itervalues(counts)\n                )\n            elif self._tree.metric == ENTROPY2:\n                # Modified entropy that down-weights universally unique values.\n                # e.g. If the number of unique attribute values equals the total\n                # count of the attribute, then it has the maximum amount of unique\n                # values.\n                return -sum(\n                    (count/total)*math.log(count/total, n)\n                    for count in itervalues(counts)\n                #) - ((len(counts)-1)/float(total))\n                ) + (unique_value_count/attr_total)\n            elif self._tree.metric == ENTROPY3:\n                # Modified entropy that down-weights universally unique values\n                # as well as features with large numbers of values.\n                return -sum(\n                    (count/total)*math.log(count/total, n)\n                    for count in itervalues(counts)\n                #) - 100*((len(counts)-1)/float(total))\n                ) + 100*(unique_value_count/attr_total)", "response": "Calculates the entropy of a specific attribute value combination."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gain(self, attr_name):\n        subset_entropy = 0.0\n        for value in iterkeys(self._attr_value_counts[attr_name]):\n            value_prob = self.get_value_prob(attr_name, value)\n            e = self.get_entropy(attr_name, value)\n            subset_entropy += value_prob * e\n        return (self.main_entropy - subset_entropy)", "response": "Calculates the information gain from splitting on the given attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the class value probability distribution of the given attribute name and attribute value.", "response": "def get_value_ddist(self, attr_name, attr_value):\n        \"\"\"\n        Returns the class value probability distribution of the given\n        attribute value.\n        \"\"\"\n        assert not self.tree.data.is_continuous_class, \\\n            \"Discrete distributions are only maintained for \" + \\\n            \"discrete class types.\"\n        ddist = DDist()\n        cls_counts = self._attr_class_value_counts[attr_name][attr_value]\n        for cls_value, cls_count in iteritems(cls_counts):\n            ddist.add(cls_value, count=cls_count)\n        return ddist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the value probability of the given attribute at this node.", "response": "def get_value_prob(self, attr_name, value):\n        \"\"\"\n        Returns the value probability of the given attribute at this node.\n        \"\"\"\n        if attr_name not in self._attr_value_count_totals:\n            return\n        n = self._attr_value_counts[attr_name][value]\n        d = self._attr_value_count_totals[attr_name]\n        return n/float(d)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef predict(self, record, depth=0):\n        \n        # Check if we're ready to predict.\n        if not self.ready_to_predict:\n            raise NodeNotReadyToPredict\n        \n        # Lookup attribute value.\n        attr_value = self._get_attribute_value_for_node(record)\n        \n        # Propagate decision to leaf node.\n        if self.attr_name:\n            if attr_value in self._branches:\n                try:\n                    return self._branches[attr_value].predict(record, depth=depth+1)\n                except NodeNotReadyToPredict:\n                    #TODO:allow re-raise if user doesn't want an intermediate prediction?\n                    pass\n                \n        # Otherwise make decision at current node.\n        if self.attr_name:\n            if self._tree.data.is_continuous_class:\n                return self._attr_value_cdist[self.attr_name][attr_value].copy()\n            else:\n#                return self._class_ddist.copy()\n                return self.get_value_ddist(self.attr_name, attr_value)\n        elif self._tree.data.is_continuous_class:\n            # Make decision at current node, which may be a true leaf node\n            # or an incomplete branch in a tree currently being built.\n            assert self._class_cdist is not None\n            return self._class_cdist.copy()\n        else:\n            return self._class_ddist.copy()", "response": "Predict the value of the class attribute for the given record."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ready_to_split(self):\n        # Never split if we're a leaf that predicts adequately.\n        threshold = self._tree.leaf_threshold\n        if self._tree.data.is_continuous_class:\n            var = self._class_cdist.variance\n            if var is not None and threshold is not None \\\n            and var <= threshold:\n                return False\n        else:\n            best_prob = self._class_ddist.best_prob\n            if best_prob is not None and threshold is not None \\\n            and best_prob >= threshold:\n                return False\n            \n        return self._tree.auto_grow \\\n            and not self.attr_name \\\n            and self.n >= self._tree.splitting_n", "response": "Returns true if this node is ready to branch off additional nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_leaf_dist(self, attr_value, dist):\n        assert self.attr_name\n        assert self.tree.data.is_valid(self.attr_name, attr_value), \\\n            \"Value %s is invalid for attribute %s.\" \\\n                % (attr_value, self.attr_name)\n        if self.is_continuous_class:\n            assert isinstance(dist, CDist)\n            assert self.attr_name\n            self._attr_value_cdist[self.attr_name][attr_value] = dist.copy()\n#            self.n += dist.count\n        else:\n            assert isinstance(dist, DDist)\n            # {attr_name:{attr_value:count}}\n            self._attr_value_counts[self.attr_name][attr_value] += 1\n            # {attr_name:total}\n            self._attr_value_count_totals[self.attr_name] += 1\n            # {attr_name:{attr_value:{class_value:count}}}\n            for cls_value, cls_count in iteritems(dist.counts):\n                self._attr_class_value_counts[self.attr_name][attr_value] \\\n                    [cls_value] += cls_count", "response": "Sets the probability distribution at a leaf node."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntrains the tree at this node.", "response": "def train(self, record):\n        \"\"\"\n        Incrementally update the statistics at this node.\n        \"\"\"\n        self.n += 1\n        class_attr = self.tree.data.class_attribute_name\n        class_value = record[class_attr]\n        \n        # Update class statistics.\n        is_con = self.tree.data.is_continuous_class\n        if is_con:\n            # For a continuous class.\n            self._class_cdist += class_value\n        else:\n            # For a discrete class.\n            self._class_ddist.add(class_value)\n        \n        # Update attribute statistics.\n        for an, av in iteritems(record):\n            if an == class_attr:\n                continue\n            self._attr_value_counts[an][av] += 1\n            self._attr_value_count_totals[an] += 1\n            if is_con:\n                self._attr_value_cdist[an][av] += class_value\n            else:\n                self._attr_class_value_counts[an][av][class_value] += 1\n        \n        # Decide if branch should split on an attribute.\n        if self.ready_to_split:\n            self.attr_name = self.get_best_splitting_attr()\n            self.tree.leaf_count -= 1\n            for av in self._attr_value_counts[self.attr_name]:\n                self._branches[av] = Node(tree=self.tree)\n                self.tree.leaf_count += 1\n            \n        # If we've split, then propagate the update to appropriate sub-branch.\n        if self.attr_name:\n            key = record[self.attr_name]\n            del record[self.attr_name]\n            self._branches[key].train(record)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a classification or regression tree in a single batch by using the given data.", "response": "def build(cls, data, *args, **kwargs):\n        \"\"\"\n        Constructs a classification or regression tree in a single batch by\n        analyzing the given data.\n        \"\"\"\n        assert isinstance(data, Data)\n        if data.is_continuous_class:\n            fitness_func = gain_variance\n        else:\n            fitness_func = get_gain\n        \n        t = cls(data=data, *args, **kwargs)\n        t._data = data\n        t.sample_count = len(data)\n        t._tree = create_decision_tree(\n            data=data,\n            attributes=data.attribute_names,\n            class_attr=data.class_attribute_name,\n            fitness_func=fitness_func,\n            wrapper=t,\n        )\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef out_of_bag_mae(self):\n        if not self._out_of_bag_mae_clean:\n            try:\n                self._out_of_bag_mae = self.test(self.out_of_bag_samples)\n                self._out_of_bag_mae_clean = True\n            except NodeNotReadyToPredict:\n                return\n        return self._out_of_bag_mae.copy()", "response": "Returns the mean absolute error for predictions on the out - of - bag xsd elements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the out - of - bag samples list.", "response": "def out_of_bag_samples(self):\n        \"\"\"\n        Returns the out-of-bag samples list, inside a wrapper to keep track\n        of modifications.\n        \"\"\"\n        #TODO:replace with more a generic pass-through wrapper?\n        class O(object):\n            def __init__(self, tree):\n                self.tree = tree\n            def __len__(self):\n                return len(self.tree._out_of_bag_samples)\n            def append(self, v):\n                self.tree._out_of_bag_mae_clean = False\n                return self.tree._out_of_bag_samples.append(v)\n            def pop(self, v):\n                self.tree._out_of_bag_mae_clean = False\n                return self.tree._out_of_bag_samples.pop(v)\n            def __iter__(self):\n                for _ in self.tree._out_of_bag_samples:\n                    yield _\n        return O(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_missing_value_policy(self, policy, target_attr_name=None):\n        assert policy in MISSING_VALUE_POLICIES, \\\n            \"Unknown policy: %s\" % (policy,)\n        for attr_name in self.data.attribute_names:\n            if target_attr_name is not None and target_attr_name != attr_name:\n                continue\n            self.missing_value_policy[attr_name] = policy", "response": "Sets the behavior for one or all attributes to use when traversing the tree using a query vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _fell_trees(self):\n        if callable(self.fell_method):\n            for tree in self.fell_method(list(self.trees)):\n                self.trees.remove(tree)", "response": "Removes trees from the forest according to the fell method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the prediction from the tree with the lowest mean absolute error.", "response": "def _get_best_prediction(self, record, train=True):\n        \"\"\"\n        Gets the prediction from the tree with the lowest mean absolute error.\n        \"\"\"\n        if not self.trees:\n            return\n        best = (+1e999999, None)\n        for tree in self.trees:\n            best = min(best, (tree.mae.mean, tree))\n        _, best_tree = best\n        prediction, tree_mae = best_tree.predict(record, train=train)\n        return prediction.mean"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn weights so that the tree with smallest out - of - bag mean absolute error is the smallest tree with smallest out - of - bag mean absolute error.", "response": "def best_oob_mae_weight(trees):\n        \"\"\"\n        Returns weights so that the tree with smallest out-of-bag mean absolute error\n        \"\"\"\n        best = (+1e999999, None)\n        for tree in trees:\n            oob_mae = tree.out_of_bag_mae\n            if oob_mae is None or oob_mae.mean is None:\n                continue\n            best = min(best, (oob_mae.mean, tree))\n        best_mae, best_tree = best\n        if best_tree is None:\n            return\n        return [(1.0, best_tree)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mean_oob_mae_weight(trees):\n        weights = []\n        active_trees = []\n        for tree in trees:\n            oob_mae = tree.out_of_bag_mae\n            if oob_mae is None or oob_mae.mean is None:\n                continue\n            weights.append(oob_mae.mean)\n            active_trees.append(tree)\n        if not active_trees:\n            return\n        weights = normalize(weights)\n        return zip(weights, active_trees)", "response": "Returns weights proportional to the out - of - bag mean absolute error for each tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _grow_trees(self):\n        if self.grow_method == GROW_AUTO_INCREMENTAL:\n            self.tree_kwargs['auto_grow'] = True\n        \n        while len(self.trees) < self.size:\n            self.trees.append(Tree(data=self.data, **self.tree_kwargs))", "response": "Adds new trees to the forest according to the growth method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npredict the value of the class attribute for the given record.", "response": "def predict(self, record):\n        \"\"\"\n        Attempts to predict the value of the class attribute by aggregating\n        the predictions of each tree.\n        \n        Parameters:\n            weighting_formula := a callable that takes a list of trees and\n                returns a list of weights.\n        \"\"\"\n        \n        # Get raw predictions.\n        # {tree:raw prediction}\n        predictions = {}\n        for tree in self.trees:\n            _p = tree.predict(record)\n            if _p is None:\n                continue\n            if isinstance(_p, CDist):\n                if _p.mean is None:\n                    continue\n            elif isinstance(_p, DDist):\n                if not _p.count:\n                    continue\n            predictions[tree] = _p\n        if not predictions:\n            return\n\n        # Normalize weights and aggregate final prediction.\n        weights = self.weighting_method(predictions.keys())\n        if not weights:\n            return\n#        assert sum(weights) == 1.0, \"Sum of weights must equal 1.\"\n        if self.data.is_continuous_class:\n            # Merge continuous class predictions.\n            total = sum(w*predictions[tree].mean for w, tree in weights)\n        else:\n            # Merge discrete class predictions.\n            total = DDist()\n            for weight, tree in weights:\n                prediction = predictions[tree]\n                for cls_value, cls_prob in prediction.probs:\n                    total.add(cls_value, cls_prob*weight)\n        \n        return total"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntraining the trees with the given training record.", "response": "def train(self, record):\n        \"\"\"\n        Updates the trees with the given training record.\n        \"\"\"\n        self._fell_trees()\n        self._grow_trees()\n        for tree in self.trees:\n            if random.random() < self.sample_ratio:\n                tree.train(record)\n            else:\n                tree.out_of_bag_samples.append(record)\n                while len(tree.out_of_bag_samples) > self.max_out_of_bag_samples:\n                    tree.out_of_bag_samples.pop(0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of local configuration file paths.", "response": "def get_configfile_paths(system=True, user=True, local=True, only_existing=True):\n    \"\"\"Return a list of local configuration file paths.\n\n    Search paths for configuration files on the local system\n    are based on homebase_ and depend on operating system; for example, for Linux systems\n    these might include ``dwave.conf`` in the current working directory (CWD),\n    user-local ``.config/dwave/``, and system-wide ``/etc/dwave/``.\n\n    .. _homebase: https://github.com/dwavesystems/homebase\n\n    Args:\n        system (boolean, default=True):\n            Search for system-wide configuration files.\n\n        user (boolean, default=True):\n            Search for user-local configuration files.\n\n        local (boolean, default=True):\n            Search for local configuration files (in CWD).\n\n        only_existing (boolean, default=True):\n            Return only paths for files that exist on the local system.\n\n    Returns:\n        list[str]:\n            List of configuration file paths.\n\n    Examples:\n        This example displays all paths to configuration files on a Windows system\n        running Python 2.7 and then finds the single existing configuration file.\n\n        >>> import dwave.cloud as dc\n        >>> # Display paths\n        >>> dc.config.get_configfile_paths(only_existing=False)   # doctest: +SKIP\n        [u'C:\\\\ProgramData\\\\dwavesystem\\\\dwave\\\\dwave.conf',\n         u'C:\\\\Users\\\\jane\\\\AppData\\\\Local\\\\dwavesystem\\\\dwave\\\\dwave.conf',\n         '.\\\\dwave.conf']\n        >>> # Find existing files\n        >>> dc.config.get_configfile_paths()   # doctest: +SKIP\n        [u'C:\\\\Users\\\\jane\\\\AppData\\\\Local\\\\dwavesystem\\\\dwave\\\\dwave.conf']\n\n    \"\"\"\n\n    candidates = []\n\n    # system-wide has the lowest priority, `/etc/dwave/dwave.conf`\n    if system:\n        candidates.extend(homebase.site_config_dir_list(\n            app_author=CONF_AUTHOR, app_name=CONF_APP,\n            use_virtualenv=False, create=False))\n\n    # user-local will override it, `~/.config/dwave/dwave.conf`\n    if user:\n        candidates.append(homebase.user_config_dir(\n            app_author=CONF_AUTHOR, app_name=CONF_APP, roaming=False,\n            use_virtualenv=False, create=False))\n\n    # highest priority (overrides all): `./dwave.conf`\n    if local:\n        candidates.append(\".\")\n\n    paths = [os.path.join(base, CONF_FILENAME) for base in candidates]\n    if only_existing:\n        paths = list(filter(os.path.exists, paths))\n\n    return paths"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the default configuration - file path.", "response": "def get_default_configfile_path():\n    \"\"\"Return the default configuration-file path.\n\n    Typically returns a user-local configuration file; e.g:\n    ``~/.config/dwave/dwave.conf``.\n\n    Returns:\n        str:\n            Configuration file path.\n\n    Examples:\n        This example displays the default configuration file on an Ubuntu Unix system\n        running IPython 2.7.\n\n        >>> import dwave.cloud as dc\n        >>> # Display paths\n        >>> dc.config.get_configfile_paths(only_existing=False)   # doctest: +SKIP\n        ['/etc/xdg/xdg-ubuntu/dwave/dwave.conf',\n         '/usr/share/upstart/xdg/dwave/dwave.conf',\n         '/etc/xdg/dwave/dwave.conf',\n         '/home/mary/.config/dwave/dwave.conf',\n         './dwave.conf']\n        >>> # Find default configuration path\n        >>> dc.config.get_default_configfile_path()   # doctest: +SKIP\n        '/home/mary/.config/dwave/dwave.conf'\n\n    \"\"\"\n    base = homebase.user_config_dir(\n        app_author=CONF_AUTHOR, app_name=CONF_APP, roaming=False,\n        use_virtualenv=False, create=False)\n    path = os.path.join(base, CONF_FILENAME)\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload D - Wave Cloud Client configuration from a list of files.", "response": "def load_config_from_files(filenames=None):\n    \"\"\"Load D-Wave Cloud Client configuration from a list of files.\n\n    .. note:: This method is not standardly used to set up D-Wave Cloud Client configuration.\n        It is recommended you use :meth:`.Client.from_config` or\n        :meth:`.config.load_config` instead.\n\n    Configuration files comply with standard Windows INI-like format,\n    parsable with Python's :mod:`configparser`. A section called\n    ``defaults`` contains default values inherited by other sections.\n\n    Each filename in the list (each configuration file loaded) progressively upgrades\n    the final configuration, on a key by key basis, per each section.\n\n    Args:\n        filenames (list[str], default=None):\n            D-Wave Cloud Client configuration files (paths and names).\n\n            If ``None``, searches for a configuration file named ``dwave.conf``\n            in all system-wide configuration directories, in the user-local\n            configuration directory, and in the current working directory,\n            following the user/system configuration paths of :func:`get_configfile_paths`.\n\n    Returns:\n        :obj:`~configparser.ConfigParser`:\n            :class:`dict`-like mapping of configuration sections (profiles) to\n            mapping of per-profile keys holding values.\n\n    Raises:\n        :exc:`~dwave.cloud.exceptions.ConfigFileReadError`:\n            Config file specified or detected could not be opened or read.\n\n        :exc:`~dwave.cloud.exceptions.ConfigFileParseError`:\n            Config file parse failed.\n\n    Examples:\n        This example loads configurations from two files. One contains a default\n        section with key/values that are overwritten by any profile section that\n        contains that key/value; for example, profile dw2000b in file dwave_b.conf\n        overwrites the default URL and client type, which profile dw2000a inherits\n        from the defaults section, while profile dw2000a overwrites the API token that\n        profile dw2000b inherits.\n\n        The files, which are located in the current working directory, are\n        (1) dwave_a.conf::\n\n            [defaults]\n            endpoint = https://url.of.some.dwavesystem.com/sapi\n            client = qpu\n            token = ABC-123456789123456789123456789\n\n            [dw2000a]\n            solver = EXAMPLE_2000Q_SYSTEM\n            token = DEF-987654321987654321987654321\n\n        and (2) dwave_b.conf::\n\n            [dw2000b]\n            endpoint = https://url.of.some.other.dwavesystem.com/sapi\n            client = sw\n            solver = EXAMPLE_2000Q_SYSTEM\n\n        The following example code loads configuration from both these files, with\n        the defined overrides and inheritance.\n\n        .. code:: python\n\n            >>> import dwave.cloud as dc\n            >>> import sys\n            >>> configuration = dc.config.load_config_from_files([\"./dwave_a.conf\", \"./dwave_b.conf\"])   # doctest: +SKIP\n            >>> configuration.write(sys.stdout)    # doctest: +SKIP\n            [defaults]\n            endpoint = https://url.of.some.dwavesystem.com/sapi\n            client = qpu\n            token = ABC-123456789123456789123456789\n\n            [dw2000a]\n            solver = EXAMPLE_2000Q_SYSTEM\n            token = DEF-987654321987654321987654321\n\n            [dw2000b]\n            endpoint = https://url.of.some.other.dwavesystem.com/sapi\n            client = sw\n            solver = EXAMPLE_2000Q_SYSTEM\n\n    \"\"\"\n    if filenames is None:\n        filenames = get_configfile_paths()\n\n    config = configparser.ConfigParser(default_section=\"defaults\")\n    for filename in filenames:\n        try:\n            with open(filename, 'r') as f:\n                config.read_file(f, filename)\n        except (IOError, OSError):\n            raise ConfigFileReadError(\"Failed to read {!r}\".format(filename))\n        except configparser.Error:\n            raise ConfigFileParseError(\"Failed to parse {!r}\".format(filename))\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a profile from a list of configuration files.", "response": "def load_profile_from_files(filenames=None, profile=None):\n    \"\"\"Load a profile from a list of D-Wave Cloud Client configuration files.\n\n    .. note:: This method is not standardly used to set up D-Wave Cloud Client configuration.\n        It is recommended you use :meth:`.Client.from_config` or\n        :meth:`.config.load_config` instead.\n\n    Configuration files comply with standard Windows INI-like format,\n    parsable with Python's :mod:`configparser`.\n\n    Each file in the list is progressively searched until the first profile is found.\n    This function does not input profile information from environment variables.\n\n    Args:\n        filenames (list[str], default=None):\n            D-Wave cloud client configuration files (path and name). If ``None``,\n            searches for existing configuration files in the standard directories\n            of :func:`get_configfile_paths`.\n\n        profile (str, default=None):\n            Name of profile to return from reading the configuration from the specified\n            configuration file(s). If ``None``, progressively falls back in the\n            following order:\n\n            (1) ``profile`` key following ``[defaults]`` section.\n            (2) First non-``[defaults]`` section.\n            (3) ``[defaults]`` section.\n\n    Returns:\n        dict:\n            Mapping of configuration keys to values. If no valid config/profile\n            is found, returns an empty dict.\n\n    Raises:\n        :exc:`~dwave.cloud.exceptions.ConfigFileReadError`:\n            Config file specified or detected could not be opened or read.\n\n        :exc:`~dwave.cloud.exceptions.ConfigFileParseError`:\n            Config file parse failed.\n\n        :exc:`ValueError`:\n            Profile name not found.\n\n    Examples:\n        This example loads a profile based on configurations from two files. It\n        finds the first profile, dw2000a, in the first file, dwave_a.conf, and adds to\n        the values of the defaults section, overwriting the existing client value,\n        while ignoring the profile in the second file, dwave_b.conf.\n\n        The files, which are located in the current working directory, are\n        (1) dwave_a.conf::\n\n            [defaults]\n            endpoint = https://url.of.some.dwavesystem.com/sapi\n            client = qpu\n            token = ABC-123456789123456789123456789\n\n            [dw2000a]\n            client = sw\n            solver = EXAMPLE_2000Q_SYSTEM_A\n            token = DEF-987654321987654321987654321\n\n        and (2) dwave_b.conf::\n\n            [dw2000b]\n            endpoint = https://url.of.some.other.dwavesystem.com/sapi\n            client = qpu\n            solver = EXAMPLE_2000Q_SYSTEM_B\n\n        The following example code loads profile values from parsing both these files,\n        by default loading the first profile encountered or an explicitly specified profile.\n\n        >>> import dwave.cloud as dc\n        >>> dc.config.load_profile_from_files([\"./dwave_a.conf\", \"./dwave_b.conf\"])   # doctest: +SKIP\n        {'client': u'sw',\n         'endpoint': u'https://url.of.some.dwavesystem.com/sapi',\n         'solver': u'EXAMPLE_2000Q_SYSTEM_A',\n         'token': u'DEF-987654321987654321987654321'}\n        >>> dc.config.load_profile_from_files([\"./dwave_a.conf\", \"./dwave_b.conf\"],\n        ...                                   profile='dw2000b')   # doctest: +SKIP\n        {'client': u'qpu',\n        'endpoint': u'https://url.of.some.other.dwavesystem.com/sapi',\n        'solver': u'EXAMPLE_2000Q_SYSTEM_B',\n        'token': u'ABC-123456789123456789123456789'}\n\n    \"\"\"\n\n    # progressively build config from a file, or a list of auto-detected files\n    # raises ConfigFileReadError/ConfigFileParseError on error\n    config = load_config_from_files(filenames)\n\n    # determine profile name fallback:\n    #  (1) profile key under [defaults],\n    #  (2) first non-[defaults] section\n    #  (3) [defaults] section\n    first_section = next(iter(config.sections() + [None]))\n    config_defaults = config.defaults()\n    if not profile:\n        profile = config_defaults.get('profile', first_section)\n\n    if profile:\n        try:\n            section = dict(config[profile])\n        except KeyError:\n            raise ValueError(\"Config profile {!r} not found\".format(profile))\n    else:\n        # as the very last resort (unspecified profile name and\n        # no profiles defined in config), try to use [defaults]\n        if config_defaults:\n            section = config_defaults\n        else:\n            section = {}\n\n    return section"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_config(config_file=None, profile=None, client=None,\n                endpoint=None, token=None, solver=None, proxy=None):\n    \"\"\"Load D-Wave Cloud Client configuration based on a configuration file.\n\n    Configuration values can be specified in multiple ways, ranked in the following\n    order (with 1 the highest ranked):\n\n    1. Values specified as keyword arguments in :func:`load_config()`. These values replace\n       values read from a configuration file, and therefore must be **strings**, including float\n       values for timeouts, boolean flags (tested for \"truthiness\"), and solver feature\n       constraints (a dictionary encoded as JSON).\n    2. Values specified as environment variables.\n    3. Values specified in the configuration file.\n\n    Configuration-file format is described in :mod:`dwave.cloud.config`.\n\n    If the location of the configuration file is not specified, auto-detection\n    searches for existing configuration files in the standard directories\n    of :func:`get_configfile_paths`.\n\n    If a configuration file explicitly specified, via an argument or\n    environment variable, does not exist or is unreadable, loading fails with\n    :exc:`~dwave.cloud.exceptions.ConfigFileReadError`. Loading fails\n    with :exc:`~dwave.cloud.exceptions.ConfigFileParseError` if the file is\n    readable but invalid as a configuration file.\n\n    Similarly, if a profile explicitly specified, via an argument or\n    environment variable, is not present in the loaded configuration, loading fails\n    with :exc:`ValueError`. Explicit profile selection also fails if the configuration\n    file is not explicitly specified, detected on the system, or defined via\n    an environment variable.\n\n    Environment variables: ``DWAVE_CONFIG_FILE``, ``DWAVE_PROFILE``, ``DWAVE_API_CLIENT``,\n    ``DWAVE_API_ENDPOINT``, ``DWAVE_API_TOKEN``, ``DWAVE_API_SOLVER``, ``DWAVE_API_PROXY``.\n\n    Environment variables are described in :mod:`dwave.cloud.config`.\n\n    Args:\n\n        config_file (str/[str]/None/False/True, default=None):\n            Path to configuration file(s).\n\n            If `None`, the value is taken from `DWAVE_CONFIG_FILE` environment\n            variable if defined. If the environment variable is undefined or empty,\n            auto-detection searches for existing configuration files in the standard\n            directories of :func:`get_configfile_paths`.\n\n            If `False`, loading from file(s) is skipped; if `True`, forces auto-detection\n            (regardless of the `DWAVE_CONFIG_FILE` environment variable).\n\n        profile (str, default=None):\n            Profile name (name of the profile section in the configuration file).\n\n            If undefined, inferred from `DWAVE_PROFILE` environment variable if\n            defined. If the environment variable is undefined or empty, a profile is\n            selected in the following order:\n\n            1. From the default section if it includes a profile key.\n            2. The first section (after the default section).\n            3. If no other section is defined besides `[defaults]`, the defaults\n               section is promoted and selected.\n\n        client (str, default=None):\n            Client type used for accessing the API. Supported values are `qpu`\n            for :class:`dwave.cloud.qpu.Client` and `sw` for\n            :class:`dwave.cloud.sw.Client`.\n\n        endpoint (str, default=None):\n            API endpoint URL.\n\n        token (str, default=None):\n            API authorization token.\n\n        solver (str, default=None):\n            :term:`solver` features, as a JSON-encoded dictionary of feature constraints,\n            the client should use. See :meth:`~dwave.cloud.client.Client.get_solvers` for\n            semantics of supported feature constraints.\n\n            If undefined, the client uses a solver definition from environment variables,\n            a configuration file, or falls back to the first available online solver.\n\n            For backward compatibility, solver name in string format is accepted and\n            converted to ``{\"name\": <solver name>}``.\n\n        proxy (str, default=None):\n            URL for proxy to use in connections to D-Wave API. Can include\n            username/password, port, scheme, etc. If undefined, client\n            uses the system-level proxy, if defined, or connects directly to the API.\n\n    Returns:\n        dict:\n            Mapping of configuration keys to values for the profile\n            (section), as read from the configuration file and optionally overridden by\n            environment values and specified keyword arguments.\n            Always contains the `client`, `endpoint`, `token`, `solver`, and `proxy`\n            keys.\n\n    Raises:\n        :exc:`ValueError`:\n            Invalid (non-existing) profile name.\n\n        :exc:`~dwave.cloud.exceptions.ConfigFileReadError`:\n            Config file specified or detected could not be opened or read.\n\n        :exc:`~dwave.cloud.exceptions.ConfigFileParseError`:\n            Config file parse failed.\n\n    Examples\n        This example loads the configuration from an auto-detected configuration file\n        in the home directory of a Windows system user.\n\n        >>> import dwave.cloud as dc\n        >>> dc.config.load_config()\n        {'client': u'qpu',\n         'endpoint': u'https://url.of.some.dwavesystem.com/sapi',\n         'proxy': None,\n         'solver': u'EXAMPLE_2000Q_SYSTEM_A',\n         'token': u'DEF-987654321987654321987654321'}\n        >>> See which configuration file was loaded\n        >>> dc.config.get_configfile_paths()\n        [u'C:\\\\Users\\\\jane\\\\AppData\\\\Local\\\\dwavesystem\\\\dwave\\\\dwave.conf']\n\n        Additional examples are given in :mod:`dwave.cloud.config`.\n\n    \"\"\"\n\n    if profile is None:\n        profile = os.getenv(\"DWAVE_PROFILE\")\n\n    if config_file == False:\n        # skip loading from file altogether\n        section = {}\n    elif config_file == True:\n        # force auto-detection, disregarding DWAVE_CONFIG_FILE\n        section = load_profile_from_files(None, profile)\n    else:\n        # auto-detect if not specified with arg or env\n        if config_file is None:\n            # note: both empty and undefined DWAVE_CONFIG_FILE treated as None\n            config_file = os.getenv(\"DWAVE_CONFIG_FILE\")\n\n        # handle ''/None/str/[str] for `config_file` (after env)\n        filenames = None\n        if config_file:\n            if isinstance(config_file, six.string_types):\n                filenames = [config_file]\n            else:\n                filenames = config_file\n\n        section = load_profile_from_files(filenames, profile)\n\n    # override a selected subset of values via env or kwargs,\n    # pass-through the rest unmodified\n    section['client'] = client or os.getenv(\"DWAVE_API_CLIENT\", section.get('client'))\n    section['endpoint'] = endpoint or os.getenv(\"DWAVE_API_ENDPOINT\", section.get('endpoint'))\n    section['token'] = token or os.getenv(\"DWAVE_API_TOKEN\", section.get('token'))\n    section['solver'] = solver or os.getenv(\"DWAVE_API_SOLVER\", section.get('solver'))\n    section['proxy'] = proxy or os.getenv(\"DWAVE_API_PROXY\", section.get('proxy'))\n\n    return section", "response": "Loads D - Wave Cloud Client configuration based on a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef legacy_load_config(profile=None, endpoint=None, token=None, solver=None,\n                       proxy=None, **kwargs):\n    \"\"\"Load configured URLs and token for the SAPI server.\n\n    .. warning:: Included only for backward compatibility. Please use\n        :func:`load_config` or the client factory\n        :meth:`~dwave.cloud.client.Client.from_config` instead.\n\n    This method tries to load a legacy configuration file from ``~/.dwrc``, select a\n    specified `profile` (or, if not specified, the first profile), and override\n    individual keys with values read from environment variables or\n    specified explicitly as key values in the function.\n\n    Configuration values can be specified in multiple ways, ranked in the following\n    order (with 1 the highest ranked):\n\n    1. Values specified as keyword arguments in :func:`legacy_load_config()`\n    2. Values specified as environment variables\n    3. Values specified in the legacy ``~/.dwrc`` configuration file\n\n    Environment variables searched for are:\n\n     - ``DW_INTERNAL__HTTPLINK``\n     - ``DW_INTERNAL__TOKEN``\n     - ``DW_INTERNAL__HTTPPROXY``\n     - ``DW_INTERNAL__SOLVER``\n\n    Legacy configuration file format is a modified CSV where the first comma is\n    replaced with a bar character (``|``). Each line encodes a single profile. Its\n    columns are::\n\n        profile_name|endpoint_url,authentication_token,proxy_url,default_solver_name\n\n    All its fields after ``authentication_token`` are optional.\n\n    When there are multiple connections in a file, the first one is\n    the default. Any commas in the URLs must be percent-encoded.\n\n    Args:\n        profile (str):\n            Profile name in the legacy configuration file.\n\n        endpoint (str, default=None):\n            API endpoint URL.\n\n        token (str, default=None):\n            API authorization token.\n\n        solver (str, default=None):\n            Default solver to use in :meth:`~dwave.cloud.client.Client.get_solver`.\n            If undefined, all calls to :meth:`~dwave.cloud.client.Client.get_solver`\n            must explicitly specify the solver name/id.\n\n        proxy (str, default=None):\n            URL for proxy to use in connections to D-Wave API. Can include\n            username/password, port, scheme, etc. If undefined, client uses a\n            system-level proxy, if defined, or connects directly to the API.\n\n    Returns:\n        Dictionary with keys: endpoint, token, solver, and proxy.\n\n    Examples:\n        This example creates a client using the :meth:`~dwave.cloud.client.Client.from_config`\n        method, which falls back on the legacy file by default when it fails to\n        find a D-Wave Cloud Client configuration file (setting its `legacy_config_fallback`\n        parameter to False precludes this fall-back operation). For this example,\n        no D-Wave Cloud Client configuration file is present on the local system;\n        instead the following ``.dwrc`` legacy configuration file is present in the\n        user's home directory::\n\n            profile-a|https://one.com,token-one\n            profile-b|https://two.com,token-two\n\n        The following example code creates a client without explicitly specifying\n        key values, therefore auto-detection searches for existing (non-legacy) configuration\n        files in the standard directories of :func:`get_configfile_paths` and, failing to\n        find one, falls back on the existing legacy configuration file above.\n\n        >>> import dwave.cloud as dc\n        >>> client = dwave.cloud.Client.from_config()    # doctest: +SKIP\n        >>> client.endpoint   # doctest: +SKIP\n        'https://one.com'\n        >>> client.token    # doctest: +SKIP\n        'token-one'\n\n        The following examples specify a profile and/or token.\n\n        >>> # Explicitly specify a profile\n        >>> client = dwave.cloud.Client.from_config(profile='profile-b')\n        >>> # Will try to connect with the url `https://two.com` and the token `token-two`.\n        >>> client = dwave.cloud.Client.from_config(profile='profile-b', token='new-token')\n        >>> # Will try to connect with the url `https://two.com` and the token `new-token`.\n\n    \"\"\"\n\n    def _parse_config(fp, filename):\n        fields = ('endpoint', 'token', 'proxy', 'solver')\n        config = OrderedDict()\n        for line in fp:\n            # strip whitespace, skip blank and comment lines\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            # parse each record, store in dict with label as key\n            try:\n                label, data = line.split('|', 1)\n                values = [v.strip() or None for v in data.split(',')]\n                config[label] = dict(zip(fields, values))\n            except:\n                raise ConfigFileParseError(\n                    \"Failed to parse {!r}, line {!r}\".format(filename, line))\n        return config\n\n    def _read_config(filename):\n        try:\n            with open(filename, 'r') as f:\n                return _parse_config(f, filename)\n        except (IOError, OSError):\n            raise ConfigFileReadError(\"Failed to read {!r}\".format(filename))\n\n    config = {}\n    filename = os.path.expanduser('~/.dwrc')\n    if os.path.exists(filename):\n        config = _read_config(filename)\n\n    # load profile if specified, or first one in file\n    if profile:\n        try:\n            section = config[profile]\n        except KeyError:\n            raise ValueError(\"Config profile {!r} not found\".format(profile))\n    else:\n        try:\n            _, section = next(iter(config.items()))\n        except StopIteration:\n            section = {}\n\n    # override config variables (if any) with environment and then with arguments\n    section['endpoint'] = endpoint or os.getenv(\"DW_INTERNAL__HTTPLINK\", section.get('endpoint'))\n    section['token'] = token or os.getenv(\"DW_INTERNAL__TOKEN\", section.get('token'))\n    section['proxy'] = proxy or os.getenv(\"DW_INTERNAL__HTTPPROXY\", section.get('proxy'))\n    section['solver'] = solver or os.getenv(\"DW_INTERNAL__SOLVER\", section.get('solver'))\n    section.update(kwargs)\n\n    return section", "response": "Load the configuration file for the SAPI server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_data(data):\n    if not (data.dtype == _np.float32 and data.flags.c_contiguous):\n        raise ValueError('supplied data must be float32 and C contiguous')\n    if data.ndim == 2:\n        num_frames, channels = data.shape\n    elif data.ndim == 1:\n        num_frames, channels = data.size, 1\n    else:\n        raise ValueError('rank > 2 not supported')\n    return num_frames, channels", "response": "Check whether data is a valid input or output for libsamplerate."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef src_simple(input_data, output_data, ratio, converter_type, channels):\n    input_frames, _ = _check_data(input_data)\n    output_frames, _ = _check_data(output_data)\n    data = ffi.new('SRC_DATA*')\n    data.input_frames = input_frames\n    data.output_frames = output_frames\n    data.src_ratio = ratio\n    data.data_in = ffi.cast('float*', ffi.from_buffer(input_data))\n    data.data_out = ffi.cast('float*', ffi.from_buffer(output_data))\n    error = _lib.src_simple(data, converter_type, channels)\n    return error, data.input_frames_used, data.output_frames_gen", "response": "Simple interface for performing a single conversion from an input buffer to an output buffer at a fixed conversion ratio."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitialises a new sample rate converter.", "response": "def src_new(converter_type, channels):\n    \"\"\"Initialise a new sample rate converter.\n\n    Parameters\n    ----------\n    converter_type : int\n        Converter to be used.\n    channels : int\n        Number of channels.\n\n    Returns\n    -------\n    state\n        An anonymous pointer to the internal state of the converter.\n    error : int\n        Error code.\n    \"\"\"\n    error = ffi.new('int*')\n    state = _lib.src_new(converter_type, channels, error)\n    return state, error[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _src_input_callback(cb_data, data):\n    cb_data = ffi.from_handle(cb_data)\n    ret = cb_data['callback']()\n    if ret is None:\n        cb_data['last_input'] = None\n        return 0  # No frames supplied\n    input_data = _np.require(ret, requirements='C', dtype=_np.float32)\n    input_frames, channels = _check_data(input_data)\n\n    # Check whether the correct number of channels is supplied by user.\n    if cb_data['channels'] != channels:\n        raise ValueError('Invalid number of channels in callback.')\n\n    # Store a reference of the input data to ensure it is still alive when\n    # accessed by libsamplerate.\n    cb_data['last_input'] = input_data\n\n    data[0] = ffi.cast('float*', ffi.from_buffer(input_data))\n    return input_frames", "response": "Internal function to be used with the callback API."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads up to frames worth of data using the callback API.", "response": "def src_callback_read(state, ratio, frames, data):\n    \"\"\"Read up to `frames` worth of data using the callback API.\n\n    Returns\n    -------\n    frames : int\n        Number of frames read or -1 on error.\n    \"\"\"\n    data_ptr = ffi.cast('float*f', ffi.from_buffer(data))\n    return _lib.src_callback_read(state, ratio, frames, data_ptr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_config(cls, config_file=None, profile=None, client=None,\n                    endpoint=None, token=None, solver=None, proxy=None,\n                    legacy_config_fallback=False, **kwargs):\n        \"\"\"Client factory method to instantiate a client instance from configuration.\n\n        Configuration values can be specified in multiple ways, ranked in the following\n        order (with 1 the highest ranked):\n\n        1. Values specified as keyword arguments in :func:`from_config()`\n        2. Values specified as environment variables\n        3. Values specified in the configuration file\n\n        Configuration-file format is described in :mod:`dwave.cloud.config`.\n\n        If the location of the configuration file is not specified, auto-detection\n        searches for existing configuration files in the standard directories\n        of :func:`get_configfile_paths`.\n\n        If a configuration file explicitly specified, via an argument or\n        environment variable, does not exist or is unreadable, loading fails with\n        :exc:`~dwave.cloud.exceptions.ConfigFileReadError`. Loading fails\n        with :exc:`~dwave.cloud.exceptions.ConfigFileParseError` if the file is\n        readable but invalid as a configuration file.\n\n        Similarly, if a profile explicitly specified, via an argument or\n        environment variable, is not present in the loaded configuration, loading fails\n        with :exc:`ValueError`. Explicit profile selection also fails if the configuration\n        file is not explicitly specified, detected on the system, or defined via\n        an environment variable.\n\n        Environment variables: ``DWAVE_CONFIG_FILE``, ``DWAVE_PROFILE``, ``DWAVE_API_CLIENT``,\n        ``DWAVE_API_ENDPOINT``, ``DWAVE_API_TOKEN``, ``DWAVE_API_SOLVER``, ``DWAVE_API_PROXY``.\n\n        Environment variables are described in :mod:`dwave.cloud.config`.\n\n        Args:\n            config_file (str/[str]/None/False/True, default=None):\n                Path to configuration file.\n\n                If ``None``, the value is taken from ``DWAVE_CONFIG_FILE`` environment\n                variable if defined. If the environment variable is undefined or empty,\n                auto-detection searches for existing configuration files in the standard\n                directories of :func:`get_configfile_paths`.\n\n                If ``False``, loading from file is skipped; if ``True``, forces auto-detection\n                (regardless of the ``DWAVE_CONFIG_FILE`` environment variable).\n\n            profile (str, default=None):\n                Profile name (name of the profile section in the configuration file).\n\n                If undefined, inferred from ``DWAVE_PROFILE`` environment variable if\n                defined. If the environment variable is undefined or empty, a profile is\n                selected in the following order:\n\n                1. From the default section if it includes a profile key.\n                2. The first section (after the default section).\n                3. If no other section is defined besides ``[defaults]``, the defaults\n                   section is promoted and selected.\n\n            client (str, default=None):\n                Client type used for accessing the API. Supported values are ``qpu``\n                for :class:`dwave.cloud.qpu.Client` and ``sw`` for\n                :class:`dwave.cloud.sw.Client`.\n\n            endpoint (str, default=None):\n                API endpoint URL.\n\n            token (str, default=None):\n                API authorization token.\n\n            solver (dict/str, default=None):\n                Default :term:`solver` features to use in :meth:`~dwave.cloud.client.Client.get_solver`.\n\n                Defined via dictionary of solver feature constraints\n                (see :meth:`~dwave.cloud.client.Client.get_solvers`).\n                For backward compatibility, a solver name, as a string,\n                is also accepted and converted to ``{\"name\": <solver name>}``.\n\n                If undefined, :meth:`~dwave.cloud.client.Client.get_solver` uses a\n                solver definition from environment variables, a configuration file, or\n                falls back to the first available online solver.\n\n            proxy (str, default=None):\n                URL for proxy to use in connections to D-Wave API. Can include\n                username/password, port, scheme, etc. If undefined, client\n                uses the system-level proxy, if defined, or connects directly to the API.\n\n            legacy_config_fallback (bool, default=False):\n                If True and loading from a standard D-Wave Cloud Client configuration\n                file (``dwave.conf``) fails, tries loading a legacy configuration file (``~/.dwrc``).\n\n        Other Parameters:\n            Unrecognized keys (str):\n                All unrecognized keys are passed through to the appropriate client class constructor\n                as string keyword arguments.\n\n                An explicit key value overrides an identical user-defined key value loaded from a\n                configuration file.\n\n        Returns:\n            :class:`~dwave.cloud.client.Client` (:class:`dwave.cloud.qpu.Client` or :class:`dwave.cloud.sw.Client`, default=:class:`dwave.cloud.qpu.Client`):\n                Appropriate instance of a QPU or software client.\n\n        Raises:\n            :exc:`~dwave.cloud.exceptions.ConfigFileReadError`:\n                Config file specified or detected could not be opened or read.\n\n            :exc:`~dwave.cloud.exceptions.ConfigFileParseError`:\n                Config file parse failed.\n\n        Examples:\n\n            A variety of examples are given in :mod:`dwave.cloud.config`.\n\n            This example initializes :class:`~dwave.cloud.client.Client` from an\n            explicitly specified configuration file, \"~/jane/my_path_to_config/my_cloud_conf.conf\"::\n\n            >>> from dwave.cloud import Client\n            >>> client = Client.from_config(config_file='~/jane/my_path_to_config/my_cloud_conf.conf')  # doctest: +SKIP\n            >>> # code that uses client\n            >>> client.close()\n\n        \"\"\"\n\n        # try loading configuration from a preferred new config subsystem\n        # (`./dwave.conf`, `~/.config/dwave/dwave.conf`, etc)\n        config = load_config(\n            config_file=config_file, profile=profile, client=client,\n            endpoint=endpoint, token=token, solver=solver, proxy=proxy)\n        _LOGGER.debug(\"Config loaded: %r\", config)\n\n        # fallback to legacy `.dwrc` if key variables missing\n        if legacy_config_fallback:\n            warnings.warn(\"'legacy_config_fallback' is deprecated, please convert \"\n                          \"your legacy .dwrc file to the new config format.\", DeprecationWarning)\n\n            if not config.get('token'):\n                config = legacy_load_config(\n                    profile=profile, client=client,\n                    endpoint=endpoint, token=token, solver=solver, proxy=proxy)\n                _LOGGER.debug(\"Legacy config loaded: %r\", config)\n\n        # manual override of other (client-custom) arguments\n        config.update(kwargs)\n\n        from dwave.cloud import qpu, sw\n        _clients = {'qpu': qpu.Client, 'sw': sw.Client, 'base': cls}\n        _client = config.pop('client', None) or 'base'\n\n        _LOGGER.debug(\"Final config used for %s.Client(): %r\", _client, config)\n        return _clients[_client](**config)", "response": "Creates a new instance of the class instance from a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef close(self):\n        # Finish all the work that requires the connection\n        _LOGGER.debug(\"Joining submission queue\")\n        self._submission_queue.join()\n        _LOGGER.debug(\"Joining cancel queue\")\n        self._cancel_queue.join()\n        _LOGGER.debug(\"Joining poll queue\")\n        self._poll_queue.join()\n        _LOGGER.debug(\"Joining load queue\")\n        self._load_queue.join()\n\n        # Send kill-task to all worker threads\n        # Note: threads can't be 'killed' in Python, they have to die by\n        # natural causes\n        for _ in self._submission_workers:\n            self._submission_queue.put(None)\n        for _ in self._cancel_workers:\n            self._cancel_queue.put(None)\n        for _ in self._poll_workers:\n            self._poll_queue.put((-1, None))\n        for _ in self._load_workers:\n            self._load_queue.put(None)\n\n        # Wait for threads to die\n        for worker in chain(self._submission_workers, self._cancel_workers,\n                            self._poll_workers, self._load_workers):\n            worker.join()\n\n        # Close the requests session\n        self.session.close()", "response": "Perform a clean shutdown of the context manager."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_solvers(self, refresh=False, order_by='avg_load', **filters):\n\n        def covers_op(prop, val):\n            \"\"\"Does LHS `prop` (range) fully cover RHS `val` (range or item)?\"\"\"\n\n            # `prop` must be a 2-element list/tuple range.\n            if not isinstance(prop, (list, tuple)) or not len(prop) == 2:\n                raise ValueError(\"2-element list/tuple range required for LHS value\")\n            llo, lhi = min(prop), max(prop)\n\n            # `val` can be a single value, or a range (2-list/2-tuple).\n            if isinstance(val, (list, tuple)) and len(val) == 2:\n                # val range within prop range?\n                rlo, rhi = min(val), max(val)\n                return llo <= rlo and lhi >= rhi\n            else:\n                # val item within prop range?\n                return llo <= val <= lhi\n\n        def within_op(prop, val):\n            \"\"\"Is LHS `prop` (range or item) fully covered by RHS `val` (range)?\"\"\"\n            try:\n                return covers_op(val, prop)\n            except ValueError:\n                raise ValueError(\"2-element list/tuple range required for RHS value\")\n\n        def _set(iterable):\n            \"\"\"Like set(iterable), but works for lists as items in iterable.\n            Before constructing a set, lists are converted to tuples.\n            \"\"\"\n            first = next(iter(iterable))\n            if isinstance(first, list):\n                return set(tuple(x) for x in iterable)\n            return set(iterable)\n\n        def with_valid_lhs(op):\n            @wraps(op)\n            def _wrapper(prop, val):\n                if prop is None:\n                    return False\n                return op(prop, val)\n            return _wrapper\n\n        # available filtering operators\n        ops = {\n            'lt': with_valid_lhs(operator.lt),\n            'lte': with_valid_lhs(operator.le),\n            'gt': with_valid_lhs(operator.gt),\n            'gte': with_valid_lhs(operator.ge),\n            'eq': operator.eq,\n            'available': lambda prop, val: prop is not None if val else prop is None,\n            'regex': with_valid_lhs(lambda prop, val: re.match(\"^{}$\".format(val), prop)),\n            # range operations\n            'covers': with_valid_lhs(covers_op),\n            'within': with_valid_lhs(within_op),\n            # membership tests\n            'in': lambda prop, val: prop in val,\n            'contains': with_valid_lhs(lambda prop, val: val in prop),\n            # set tests\n            'issubset': with_valid_lhs(lambda prop, val: _set(prop).issubset(_set(val))),\n            'issuperset': with_valid_lhs(lambda prop, val: _set(prop).issuperset(_set(val))),\n        }\n\n        def predicate(solver, query, val):\n            # needs to handle kwargs like these:\n            #  key=val\n            #  key__op=val\n            #  key__key=val\n            #  key__key__op=val\n            # LHS is split on __ in `query`\n            assert len(query) >= 1\n\n            potential_path, potential_op_name = query[:-1], query[-1]\n\n            if potential_op_name in ops:\n                # op is explicit, and potential path is correct\n                op_name = potential_op_name\n            else:\n                # op is implied and depends on property type, path is the whole query\n                op_name = None\n                potential_path = query\n\n            path = '.'.join(potential_path)\n\n            if path in solver.derived_properties:\n                op = ops[op_name or 'eq']\n                return op(getattr(solver, path), val)\n            elif pluck(solver.parameters, path, None) is not None:\n                op = ops[op_name or 'available']\n                return op(pluck(solver.parameters, path), val)\n            elif pluck(solver.properties, path, None) is not None:\n                op = ops[op_name or 'eq']\n                return op(pluck(solver.properties, path), val)\n            else:\n                op = ops[op_name or 'eq']\n                return op(None, val)\n\n        # param validation\n        sort_reverse = False\n        if not order_by:\n            sort_key = None\n        elif isinstance(order_by, six.string_types):\n            if order_by[0] == '-':\n                sort_reverse = True\n                order_by = order_by[1:]\n            if not order_by:\n                sort_key = None\n            else:\n                sort_key = lambda solver: pluck(solver, order_by, None)\n        elif callable(order_by):\n            sort_key = order_by\n        else:\n            raise TypeError(\"expected string or callable for 'order_by'\")\n\n        # default filters:\n        filters.setdefault('online', True)\n\n        predicates = []\n        for lhs, val in filters.items():\n            query = lhs.split('__')\n            predicates.append(partial(predicate, query=query, val=val))\n\n        _LOGGER.debug(\"Filtering solvers with predicates=%r\", predicates)\n\n        # optimization for case when exact solver name/id is known:\n        # we can fetch only that solver\n        # NOTE: in future, complete feature-based filtering will be on server-side\n        query = dict(refresh_=refresh)\n        if 'name' in filters:\n            query['name'] = filters['name']\n        if 'name__eq' in filters:\n            query['name'] = filters['name__eq']\n\n        # filter\n        solvers = self._fetch_solvers(**query)\n        solvers = [s for s in solvers if all(p(s) for p in predicates)]\n\n        # sort: undefined (None) key values go last\n        if sort_key is not None:\n            solvers_with_keys = [(sort_key(solver), solver) for solver in solvers]\n            solvers_with_invalid_keys = [(key, solver) for key, solver in solvers_with_keys if key is None]\n            solvers_with_valid_keys = [(key, solver) for key, solver in solvers_with_keys if key is not None]\n            solvers_with_valid_keys.sort(key=operator.itemgetter(0))\n            solvers = [solver for key, solver in chain(solvers_with_valid_keys, solvers_with_invalid_keys)]\n\n        # reverse if necessary (as a separate step from sorting, so it works for invalid keys\n        # and plain list reverse without sorting)\n        if sort_reverse:\n            solvers.reverse()\n\n        return solvers", "response": "Return a filtered list of solvers handled by this client."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeprecate in favor of get_solvers.", "response": "def solvers(self, refresh=False, **filters):\n        \"\"\"Deprecated in favor of :meth:`.get_solvers`.\"\"\"\n        warnings.warn(\"'solvers' is deprecated in favor of 'get_solvers'.\", DeprecationWarning)\n        return self.get_solvers(refresh=refresh, **filters)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_solver(self, name=None, refresh=False, **filters):\n        _LOGGER.debug(\"Requested a solver that best matches feature filters=%r\", filters)\n\n        # backward compatibility: name as the first feature\n        if name is not None:\n            filters.setdefault('name', name)\n\n        # in absence of other filters, config/env solver filters/name are used\n        if not filters and self.default_solver:\n            filters = self.default_solver\n\n        # get the first solver that satisfies all filters\n        try:\n            _LOGGER.debug(\"Fetching solvers according to filters=%r\", filters)\n            return self.get_solvers(refresh=refresh, **filters)[0]\n        except IndexError:\n            raise SolverNotFoundError(\"Solver with the requested features not available\")", "response": "Load the configuration for a single solver."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsubmitting the problems from the submission queue and pass them on to the future.", "response": "def _do_submit_problems(self):\n        \"\"\"Pull problems from the submission queue and submit them.\n\n        Note:\n            This method is always run inside of a daemon thread.\n        \"\"\"\n        try:\n            while True:\n                # Pull as many problems as we can, block on the first one,\n                # but once we have one problem, switch to non-blocking then\n                # submit without blocking again.\n\n                # `None` task is used to signal thread termination\n                item = self._submission_queue.get()\n                if item is None:\n                    break\n\n                ready_problems = [item]\n                while len(ready_problems) < self._SUBMIT_BATCH_SIZE:\n                    try:\n                        ready_problems.append(self._submission_queue.get_nowait())\n                    except queue.Empty:\n                        break\n\n                # Submit the problems\n                _LOGGER.debug(\"Submitting %d problems\", len(ready_problems))\n                body = '[' + ','.join(mess.body for mess in ready_problems) + ']'\n                try:\n                    try:\n                        response = self.session.post(posixpath.join(self.endpoint, 'problems/'), body)\n                        localtime_of_response = epochnow()\n                    except requests.exceptions.Timeout:\n                        raise RequestTimeout\n\n                    if response.status_code == 401:\n                        raise SolverAuthenticationError()\n                    response.raise_for_status()\n\n                    message = response.json()\n                    _LOGGER.debug(\"Finished submitting %d problems\", len(ready_problems))\n                except BaseException as exception:\n                    _LOGGER.debug(\"Submit failed for %d problems\", len(ready_problems))\n                    if not isinstance(exception, SolverAuthenticationError):\n                        exception = IOError(exception)\n\n                    for mess in ready_problems:\n                        mess.future._set_error(exception, sys.exc_info())\n                        self._submission_queue.task_done()\n                    continue\n\n                # Pass on the information\n                for submission, res in zip(ready_problems, message):\n                    submission.future._set_clock_diff(response, localtime_of_response)\n                    self._handle_problem_status(res, submission.future)\n                    self._submission_queue.task_done()\n\n                # this is equivalent to a yield to scheduler in other threading libraries\n                time.sleep(0)\n\n        except BaseException as err:\n            _LOGGER.exception(err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_problem_status(self, message, future):\n        try:\n            _LOGGER.trace(\"Handling response: %r\", message)\n            _LOGGER.debug(\"Handling response for %s with status %s\", message.get('id'), message.get('status'))\n\n            # Handle errors in batch mode\n            if 'error_code' in message and 'error_msg' in message:\n                raise SolverFailureError(message['error_msg'])\n\n            if 'status' not in message:\n                raise InvalidAPIResponseError(\"'status' missing in problem description response\")\n            if 'id' not in message:\n                raise InvalidAPIResponseError(\"'id' missing in problem description response\")\n\n            future.id = message['id']\n            future.remote_status = status = message['status']\n\n            # The future may not have the ID set yet\n            with future._single_cancel_lock:\n                # This handles the case where cancel has been called on a future\n                # before that future received the problem id\n                if future._cancel_requested:\n                    if not future._cancel_sent and status == self.STATUS_PENDING:\n                        # The problem has been canceled but the status says its still in queue\n                        # try to cancel it\n                        self._cancel(message['id'], future)\n                    # If a cancel request could meaningfully be sent it has been now\n                    future._cancel_sent = True\n\n            if not future.time_received and message.get('submitted_on'):\n                future.time_received = parse_datetime(message['submitted_on'])\n\n            if not future.time_solved and message.get('solved_on'):\n                future.time_solved = parse_datetime(message['solved_on'])\n\n            if not future.eta_min and message.get('earliest_estimated_completion'):\n                future.eta_min = parse_datetime(message['earliest_estimated_completion'])\n\n            if not future.eta_max and message.get('latest_estimated_completion'):\n                future.eta_max = parse_datetime(message['latest_estimated_completion'])\n\n            if status == self.STATUS_COMPLETE:\n                # TODO: find a better way to differentiate between\n                # `completed-on-submit` and `completed-on-poll`.\n                # Loading should happen only once, not every time when response\n                # doesn't contain 'answer'.\n\n                # If the message is complete, forward it to the future object\n                if 'answer' in message:\n                    future._set_message(message)\n                # If the problem is complete, but we don't have the result data\n                # put the problem in the queue for loading results.\n                else:\n                    self._load(future)\n            elif status in self.ANY_STATUS_ONGOING:\n                # If the response is pending add it to the queue.\n                self._poll(future)\n            elif status == self.STATUS_CANCELLED:\n                # If canceled return error\n                raise CanceledFutureError()\n            else:\n                # Return an error to the future object\n                errmsg = message.get('error_message', 'An unknown error has occurred.')\n                if 'solver is offline' in errmsg.lower():\n                    raise SolverOfflineError(errmsg)\n                else:\n                    raise SolverFailureError(errmsg)\n\n        except Exception as error:\n            # If there were any unhandled errors we need to release the\n            # lock in the future, otherwise deadlock occurs.\n            future._set_error(error, sys.exc_info())", "response": "Handle the results of a problem submission or results request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _do_cancel_problems(self):\n        try:\n            while True:\n                # Pull as many problems as we can, block when none are available.\n\n                # `None` task is used to signal thread termination\n                item = self._cancel_queue.get()\n                if item is None:\n                    break\n\n                item_list = [item]\n                while True:\n                    try:\n                        item_list.append(self._cancel_queue.get_nowait())\n                    except queue.Empty:\n                        break\n\n                # Submit the problems, attach the ids as a json list in the\n                # body of the delete query.\n                try:\n                    body = [item[0] for item in item_list]\n\n                    try:\n                        self.session.delete(posixpath.join(self.endpoint, 'problems/'), json=body)\n                    except requests.exceptions.Timeout:\n                        raise RequestTimeout\n\n                except Exception as err:\n                    for _, future in item_list:\n                        if future is not None:\n                            future._set_error(err, sys.exc_info())\n\n                # Mark all the ids as processed regardless of success or failure.\n                [self._cancel_queue.task_done() for _ in item_list]\n\n                # this is equivalent to a yield to scheduler in other threading libraries\n                time.sleep(0)\n\n        except Exception as err:\n            _LOGGER.exception(err)", "response": "Pulls ids from the cancel queue and submit them."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _poll(self, future):\n\n        if future._poll_backoff is None:\n            # on first poll, start with minimal back-off\n            future._poll_backoff = self._POLL_BACKOFF_MIN\n\n            # if we have ETA of results, schedule the first poll for then\n            if future.eta_min and self._is_clock_diff_acceptable(future):\n                at = datetime_to_timestamp(future.eta_min)\n                _LOGGER.debug(\"Response ETA indicated and local clock reliable. \"\n                              \"Scheduling first polling at +%.2f sec\", at - epochnow())\n            else:\n                at = time.time() + future._poll_backoff\n                _LOGGER.debug(\"Response ETA not indicated, or local clock unreliable. \"\n                              \"Scheduling first polling at +%.2f sec\", at - epochnow())\n\n        else:\n            # update exponential poll back-off, clipped to a range\n            future._poll_backoff = \\\n                max(self._POLL_BACKOFF_MIN,\n                    min(future._poll_backoff * 2, self._POLL_BACKOFF_MAX))\n\n            # for poll priority we use timestamp of next scheduled poll\n            at = time.time() + future._poll_backoff\n\n        now = utcnow()\n        future_age = (now - future.time_created).total_seconds()\n        _LOGGER.debug(\"Polling scheduled at %.2f with %.2f sec new back-off for: %s (future's age: %.2f sec)\",\n                      at, future._poll_backoff, future.id, future_age)\n\n        # don't enqueue for next poll if polling_timeout is exceeded by then\n        future_age_on_next_poll = future_age + (at - datetime_to_timestamp(now))\n        if self.polling_timeout is not None and future_age_on_next_poll > self.polling_timeout:\n            _LOGGER.debug(\"Polling timeout exceeded before next poll: %.2f sec > %.2f sec, aborting polling!\",\n                          future_age_on_next_poll, self.polling_timeout)\n            raise PollingTimeout\n\n        self._poll_queue.put((at, future))", "response": "Enqueue a problem to poll the server for status."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npolls the server for the status of a set of problems.", "response": "def _do_poll_problems(self):\n        \"\"\"Poll the server for the status of a set of problems.\n\n        Note:\n            This method is always run inside of a daemon thread.\n        \"\"\"\n        try:\n            # grouped futures (all scheduled within _POLL_GROUP_TIMEFRAME)\n            frame_futures = {}\n\n            def task_done():\n                self._poll_queue.task_done()\n\n            def add(future):\n                # add future to query frame_futures\n                # returns: worker lives on?\n\n                # `None` task signifies thread termination\n                if future is None:\n                    task_done()\n                    return False\n\n                if future.id not in frame_futures and not future.done():\n                    frame_futures[future.id] = future\n                else:\n                    task_done()\n\n                return True\n\n            while True:\n                frame_futures.clear()\n\n                # blocking add first scheduled\n                frame_earliest, future = self._poll_queue.get()\n                if not add(future):\n                    return\n\n                # try grouping if scheduled within grouping timeframe\n                while len(frame_futures) < self._STATUS_QUERY_SIZE:\n                    try:\n                        task = self._poll_queue.get_nowait()\n                    except queue.Empty:\n                        break\n\n                    at, future = task\n                    if at - frame_earliest <= self._POLL_GROUP_TIMEFRAME:\n                        if not add(future):\n                            return\n                    else:\n                        task_done()\n                        self._poll_queue.put(task)\n                        break\n\n                # build a query string with ids of all futures in this frame\n                ids = [future.id for future in frame_futures.values()]\n                _LOGGER.debug(\"Polling for status of futures: %s\", ids)\n                query_string = 'problems/?id=' + ','.join(ids)\n\n                # if futures were cancelled while `add`ing, skip empty frame\n                if not ids:\n                    continue\n\n                # wait until `frame_earliest` before polling\n                delay = frame_earliest - time.time()\n                if delay > 0:\n                    _LOGGER.debug(\"Pausing polling %.2f sec for futures: %s\", delay, ids)\n                    time.sleep(delay)\n                else:\n                    _LOGGER.trace(\"Skipping non-positive delay of %.2f sec\", delay)\n\n                try:\n                    _LOGGER.trace(\"Executing poll API request\")\n\n                    try:\n                        response = self.session.get(posixpath.join(self.endpoint, query_string))\n                    except requests.exceptions.Timeout:\n                        raise RequestTimeout\n\n                    if response.status_code == 401:\n                        raise SolverAuthenticationError()\n                    response.raise_for_status()\n\n                    statuses = response.json()\n                    for status in statuses:\n                        self._handle_problem_status(status, frame_futures[status['id']])\n\n                except BaseException as exception:\n                    if not isinstance(exception, SolverAuthenticationError):\n                        exception = IOError(exception)\n\n                    for id_ in frame_futures.keys():\n                        frame_futures[id_]._set_error(IOError(exception), sys.exc_info())\n\n                for id_ in frame_futures.keys():\n                    task_done()\n\n                time.sleep(0)\n\n        except Exception as err:\n            _LOGGER.exception(err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _do_load_results(self):\n        try:\n            while True:\n                # Select a problem\n                future = self._load_queue.get()\n                # `None` task signifies thread termination\n                if future is None:\n                    break\n                _LOGGER.debug(\"Loading results of: %s\", future.id)\n\n                # Submit the query\n                query_string = 'problems/{}/'.format(future.id)\n                try:\n                    try:\n                        response = self.session.get(posixpath.join(self.endpoint, query_string))\n                    except requests.exceptions.Timeout:\n                        raise RequestTimeout\n\n                    if response.status_code == 401:\n                        raise SolverAuthenticationError()\n                    response.raise_for_status()\n\n                    message = response.json()\n                except BaseException as exception:\n                    if not isinstance(exception, SolverAuthenticationError):\n                        exception = IOError(exception)\n\n                    future._set_error(IOError(exception), sys.exc_info())\n                    continue\n\n                # Dispatch the results, mark the task complete\n                self._handle_problem_status(message, future)\n                self._load_queue.task_done()\n\n                # this is equivalent to a yield to scheduler in other threading libraries\n                time.sleep(0)\n\n        except Exception as err:\n            _LOGGER.error('Load result error: ' + str(err))", "response": "Submit a query asking for the results for a particular problem."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes the binary quadratic problem for submission to a given solver using the qp format for data.", "response": "def encode_bqm_as_qp(solver, linear, quadratic):\n    \"\"\"Encode the binary quadratic problem for submission to a given solver,\n    using the `qp` format for data.\n\n    Args:\n        solver (:class:`dwave.cloud.solver.Solver`):\n            The solver used.\n\n        linear (dict[variable, bias]/list[variable, bias]):\n            Linear terms of the model.\n\n        quadratic (dict[(variable, variable), bias]):\n            Quadratic terms of the model.\n\n    Returns:\n        encoded submission dictionary\n    \"\"\"\n    active = active_qubits(linear, quadratic)\n\n    # Encode linear terms. The coefficients of the linear terms of the objective\n    # are encoded as an array of little endian 64 bit doubles.\n    # This array is then base64 encoded into a string safe for json.\n    # The order of the terms is determined by the _encoding_qubits property\n    # specified by the server.\n    # Note: only active qubits are coded with double, inactive with NaN\n    nan = float('nan')\n    lin = [uniform_get(linear, qubit, 0 if qubit in active else nan)\n           for qubit in solver._encoding_qubits]\n    lin = base64.b64encode(struct.pack('<' + ('d' * len(lin)), *lin))\n\n    # Encode the coefficients of the quadratic terms of the objective\n    # in the same manner as the linear terms, in the order given by the\n    # _encoding_couplers property, discarding tailing zero couplings\n    quad = [quadratic.get((q1,q2), 0) + quadratic.get((q2,q1), 0)\n            for (q1,q2) in solver._encoding_couplers\n            if q1 in active and q2 in active]\n    quad = base64.b64encode(struct.pack('<' + ('d' * len(quad)), *quad))\n\n    # The name for this encoding is 'qp' and is explicitly included in the\n    # message for easier extension in the future.\n    return {\n        'format': 'qp',\n        'lin': lin.decode('utf-8'),\n        'quad': quad.decode('utf-8')\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_qp(msg):\n    # Decode the simple buffers\n    result = msg['answer']\n    result['active_variables'] = _decode_ints(result['active_variables'])\n    active_variables = result['active_variables']\n    if 'num_occurrences' in result:\n        result['num_occurrences'] = _decode_ints(result['num_occurrences'])\n    result['energies'] = _decode_doubles(result['energies'])\n\n    # Measure out the size of the binary solution data\n    num_solutions = len(result['energies'])\n    num_variables = len(result['active_variables'])\n    solution_bytes = -(-num_variables // 8)  # equivalent to int(math.ceil(num_variables / 8.))\n    total_variables = result['num_variables']\n\n    # Figure out the null value for output\n    default = 3 if msg['type'] == 'qubo' else 0\n\n    # Decode the solutions, which will be byte aligned in binary format\n    binary = base64.b64decode(result['solutions'])\n    solutions = []\n    for solution_index in range(num_solutions):\n        # Grab the section of the buffer related to the current\n        buffer_index = solution_index * solution_bytes\n        solution_buffer = binary[buffer_index:buffer_index + solution_bytes]\n        bytes = struct.unpack('B' * solution_bytes, solution_buffer)\n\n        # Assume None values\n        solution = [default] * total_variables\n        index = 0\n        for byte in bytes:\n            # Parse each byte and read how ever many bits can be\n            values = _decode_byte(byte)\n            for _ in range(min(8, len(active_variables) - index)):\n                i = active_variables[index]\n                index += 1\n                solution[i] = values.pop()\n\n        # Switch to the right variable space\n        if msg['type'] == 'ising':\n            values = {0: -1, 1: 1}\n            solution = [values.get(v, default) for v in solution]\n        solutions.append(solution)\n\n    result['solutions'] = solutions\n    return result", "response": "Decode the SAPI response that uses numpy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _decode_ints(message):\n    binary = base64.b64decode(message)\n    return struct.unpack('<' + ('i' * (len(binary) // 4)), binary)", "response": "Helper for decode_qp decodes an int array."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decode_qp_numpy(msg, return_matrix=True):\n    import numpy as np\n\n    result = msg['answer']\n\n    # Build some little endian type encodings\n    double_type = np.dtype(np.double)\n    double_type = double_type.newbyteorder('<')\n    int_type = np.dtype(np.int32)\n    int_type = int_type.newbyteorder('<')\n\n    # Decode the simple buffers\n    result['energies'] = np.frombuffer(base64.b64decode(result['energies']),\n                                       dtype=double_type)\n\n    if 'num_occurrences' in result:\n        result['num_occurrences'] = \\\n            np.frombuffer(base64.b64decode(result['num_occurrences']),\n                        dtype=int_type)\n\n    result['active_variables'] = \\\n        np.frombuffer(base64.b64decode(result['active_variables']),\n                      dtype=int_type)\n\n    # Measure out the binary data size\n    num_solutions = len(result['energies'])\n    active_variables = result['active_variables']\n    num_variables = len(active_variables)\n    total_variables = result['num_variables']\n\n    # Decode the solutions, which will be a continuous run of bits\n    byte_type = np.dtype(np.uint8)\n    byte_type = byte_type.newbyteorder('<')\n    bits = np.unpackbits(np.frombuffer(base64.b64decode(result['solutions']),\n                         dtype=byte_type))\n\n    # Clip off the extra bits from encoding\n    if num_solutions:\n        bits = np.reshape(bits, (num_solutions, bits.size // num_solutions))\n        bits = np.delete(bits, range(num_variables, bits.shape[1]), 1)\n\n    # Switch from bits to spins\n    default = 3\n    if msg['type'] == 'ising':\n        bits = bits.astype(np.int8)\n        bits *= 2\n        bits -= 1\n        default = 0\n\n    # Fill in the missing variables\n    solutions = np.full((num_solutions, total_variables), default, dtype=np.int8)\n    solutions[:, active_variables] = bits\n    result['solutions'] = solutions\n\n    # If the final result shouldn't be numpy formats switch back to python objects\n    if not return_matrix:\n        result['energies'] = result['energies'].tolist()\n        if 'num_occurrences' in result:\n            result['num_occurrences'] = result['num_occurrences'].tolist()\n        result['active_variables'] = result['active_variables'].tolist()\n        result['solutions'] = result['solutions'].tolist()\n\n    return result", "response": "Decode SAPI response results in a qp format explicitly using numpy."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the energy of a state given the Hamiltonian terms.", "response": "def evaluate_ising(linear, quad, state):\n    \"\"\"Calculate the energy of a state given the Hamiltonian.\n\n    Args:\n        linear: Linear Hamiltonian terms.\n        quad: Quadratic Hamiltonian terms.\n        state: Vector of spins describing the system state.\n\n    Returns:\n        Energy of the state evaluated by the given energy function.\n    \"\"\"\n\n    # If we were given a numpy array cast to list\n    if _numpy and isinstance(state, np.ndarray):\n        return evaluate_ising(linear, quad, state.tolist())\n\n    # Accumulate the linear and quadratic values\n    energy = 0.0\n    for index, value in uniform_iterator(linear):\n        energy += state[index] * value\n    for (index_a, index_b), value in six.iteritems(quad):\n        energy += value * state[index_a] * state[index_b]\n    return energy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate a set of all active qubits.", "response": "def active_qubits(linear, quadratic):\n    \"\"\"Calculate a set of all active qubits. Qubit is \"active\" if it has\n    bias or coupling attached.\n\n    Args:\n        linear (dict[variable, bias]/list[variable, bias]):\n            Linear terms of the model.\n\n        quadratic (dict[(variable, variable), bias]):\n            Quadratic terms of the model.\n\n    Returns:\n        set:\n            Active qubits' indices.\n    \"\"\"\n\n    active = {idx for idx,bias in uniform_iterator(linear)}\n    for edge, _ in six.iteritems(quadratic):\n        active.update(edge)\n    return active"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate an Ising problem formulation valid for a particular solver uniformly from h_range and j_range.", "response": "def generate_random_ising_problem(solver, h_range=None, j_range=None):\n    \"\"\"Generates an Ising problem formulation valid for a particular solver,\n    using all qubits and all couplings and linear/quadratic biases sampled\n    uniformly from `h_range`/`j_range`.\n    \"\"\"\n\n    if h_range is None:\n        h_range = solver.properties.get('h_range', [-1, 1])\n    if j_range is None:\n        j_range = solver.properties.get('j_range', [-1, 1])\n\n    lin = {qubit: random.uniform(*h_range) for qubit in solver.nodes}\n    quad = {edge: random.uniform(*j_range) for edge in solver.undirected_edges}\n\n    return lin, quad"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uniform_iterator(sequence):\n\n    if isinstance(sequence, abc.Mapping):\n        return six.iteritems(sequence)\n    else:\n        return enumerate(sequence)", "response": "Uniform iterator on a dict or list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uniform_get(sequence, index, default=None):\n\n    if isinstance(sequence, abc.Mapping):\n        return sequence.get(index, default)\n    else:\n        return sequence[index] if index < len(sequence) else default", "response": "Uniform dict / list item getter where index is interpreted as a key\n    for maps and as numeric index for lists."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstripping elements of values from the beginning of sequence.", "response": "def strip_head(sequence, values):\n    \"\"\"Strips elements of `values` from the beginning of `sequence`.\"\"\"\n    values = set(values)\n    return list(itertools.dropwhile(lambda x: x in values, sequence))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strip_tail(sequence, values):\n    return list(reversed(list(strip_head(reversed(sequence), values))))", "response": "Strip values from the end of sequence."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef click_info_switch(f):\n\n    @wraps(f)\n    def wrapped(ctx, param, value):\n        if not value or ctx.resilient_parsing:\n            return\n        f()\n        ctx.exit()\n    return wrapped", "response": "Decorator to create eager Click info switch option."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting timezone - aware datetime to POSIX timestamp and return seconds since UNIX epoch.", "response": "def datetime_to_timestamp(dt):\n    \"\"\"Convert timezone-aware `datetime` to POSIX timestamp and\n    return seconds since UNIX epoch.\n\n    Note: similar to `datetime.timestamp()` in Python 3.3+.\n    \"\"\"\n\n    epoch = datetime.utcfromtimestamp(0).replace(tzinfo=UTC)\n    return (dt - epoch).total_seconds()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns User - Agent ~ name language version interpreter os version", "response": "def user_agent(name, version):\n    \"\"\"Return User-Agent ~ \"name/version language/version interpreter/version os/version\".\"\"\"\n\n    def _interpreter():\n        name = platform.python_implementation()\n        version = platform.python_version()\n        bitness = platform.architecture()[0]\n        if name == 'PyPy':\n            version = '.'.join(map(str, sys.pypy_version_info[:3]))\n        full_version = [version]\n        if bitness:\n            full_version.append(bitness)\n        return name, \"-\".join(full_version)\n\n    tags = [\n        (name, version),\n        (\"python\", platform.python_version()),\n        _interpreter(),\n        (\"machine\", platform.machine() or 'unknown'),\n        (\"system\", platform.system() or 'unknown'),\n        (\"platform\", platform.platform() or 'unknown'),\n    ]\n\n    return ' '.join(\"{}/{}\".format(name, version) for name, version in tags)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhash mutable arguments containers with immutable keys and values.", "response": "def argshash(self, args, kwargs):\n        \"Hash mutable arguments' containers with immutable keys and values.\"\n        a = repr(args)\n        b = repr(sorted((repr(k), repr(v)) for k, v in kwargs.items()))\n        return a + b"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_context_data(self, **kwargs):\n        ctx = super(UserMediaImageViewMixin, self).get_context_data(**kwargs)\n        ctx.update({\n            'action': self.action,\n            'next': self.next,\n        })\n        return ctx", "response": "Adds action and next to the context."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_success_url(self):\n        if self.next:\n            return self.next\n        if self.object and self.object.content_object:\n            return self.object.content_object.get_absolute_url()\n        raise Exception(\n            'No content object given. Please provide ``next`` in your POST'\n            ' data')", "response": "Returns the success URL for the given content object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dispatch(self, request, *args, **kwargs):\n        self._add_next_and_user(request)\n        self.content_object = None\n        self.content_type = None\n        self.object_id = kwargs.get('object_id', None)\n\n        if kwargs.get('content_type'):\n            # Check if the user forged the URL and posted a non existant\n            # content type\n            try:\n                self.content_type = ContentType.objects.get(\n                    model=kwargs.get('content_type'))\n            except ContentType.DoesNotExist:\n                raise Http404\n\n        if self.content_type:\n            # Check if the user forged the URL and tries to append the image to\n            # an object that does not exist\n            try:\n                self.content_object = \\\n                    self.content_type.get_object_for_this_type(\n                        pk=self.object_id)\n            except ObjectDoesNotExist:\n                raise Http404\n\n        if self.content_object and hasattr(self.content_object, 'user'):\n            # Check if the user forged the URL and tries to append the image to\n            # an object that does not belong to him\n            if not self.content_object.user == self.user:\n                raise Http404\n\n        return super(CreateImageView, self).dispatch(request, *args, **kwargs)", "response": "Adds useful objects to the class and performs security checks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd useful objects to the class.", "response": "def dispatch(self, request, *args, **kwargs):\n        \"\"\"Adds useful objects to the class.\"\"\"\n        self._add_next_and_user(request)\n        return super(DeleteImageView, self).dispatch(request, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking sure that a user can only delete his own images.", "response": "def get_queryset(self):\n        \"\"\"\n        Making sure that a user can only delete his own images.\n\n        Even when he forges the request URL.\n\n        \"\"\"\n        queryset = super(DeleteImageView, self).get_queryset()\n        queryset = queryset.filter(user=self.user)\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dispatch(self, request, *args, **kwargs):\n        self._add_next_and_user(request)\n        return super(UpdateImageView, self).dispatch(request, *args, **kwargs)", "response": "Adds useful objects to the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure that a user can only edit his own images.", "response": "def get_queryset(self):\n        \"\"\"\n        Making sure that a user can only edit his own images.\n\n        Even when he forges the request URL.\n\n        \"\"\"\n        queryset = super(UpdateImageView, self).get_queryset()\n        queryset = queryset.filter(user=self.user)\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _delete_images(self, instance):\n        UserMediaImage.objects.filter(\n            content_type=ContentType.objects.get_for_model(instance),\n            object_id=instance.pk,\n            user=instance.user,\n        ).delete()", "response": "Deletes all user media images of the given instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans the image data.", "response": "def clean_image(self):\n        \"\"\"\n        It seems like in Django 1.5 something has changed.\n\n        When Django tries to validate the form, it checks if the generated\n        filename fit into the max_length. But at this point, self.instance.user\n        is not yet set so our filename generation function cannot create\n        the new file path because it needs the user id. Setting\n        self.instance.user at this point seems to work as a workaround.\n\n        \"\"\"\n        self.instance.user = self.user\n        data = self.cleaned_data.get('image')\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_image_file_path(instance, filename):\n    ext = filename.split('.')[-1]\n    filename = '%s.%s' % (uuid.uuid4(), ext)\n    return os.path.join(\n        'user_media', str(instance.user.pk), 'images', filename)", "response": "Returns a unique filename for images."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete all files in the media directory.", "response": "def image_post_delete_handler(sender, instance, **kwargs):\n    \"\"\"\n    Makes sure that a an image is also deleted from the media directory.\n\n    This should prevent a load of \"dead\" image files on disc.\n\n    \"\"\"\n    for f in glob.glob('{}/{}*'.format(instance.image.storage.location,\n                                       instance.image.name)):\n        if not os.path.isdir(f):\n            instance.image.storage.delete(f)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef box_coordinates(self):\n        if (\n            self.thumb_x is not None and\n            self.thumb_y is not None and\n            self.thumb_x2 is not None and\n            self.thumb_y2 is not None\n        ):\n            return (\n                int(self.thumb_x),\n                int(self.thumb_y),\n                int(self.thumb_x2),\n                int(self.thumb_y2),\n            )\n        return False", "response": "Returns a thumbnail s coordinates."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a thumbnail s large size.", "response": "def large_size(self, as_string=True):\n        \"\"\"Returns a thumbnail's large size.\"\"\"\n        size = getattr(settings, 'USER_MEDIA_THUMB_SIZE_LARGE', (150, 150))\n        if as_string:\n            return u'{}x{}'.format(size[0], size[1])\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef crop_box(im, box=False, **kwargs):\n    if box:\n        im = im.crop(box)\n    return im", "response": "Uses box coordinates to crop an image without resizing it first."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_germanet(host = None, port = None, database_name = 'germanet'):\n    '''\n    Loads a GermaNet instance connected to the given MongoDB instance.\n\n    Arguments:\n    - `host`: the hostname of the MongoDB instance\n    - `port`: the port number of the MongoDB instance\n    - `database_name`: the name of the GermaNet database on the\n      MongoDB instance\n    '''\n    client      = MongoClient(host, port)\n    germanet_db = client[database_name]\n    return GermaNet(germanet_db)", "response": "Loads a GermaNet instance connected to the given MongoDB instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cache_size(self, new_value):\n        '''\n        Set the cache size used to reduce the number of database\n        access operations.\n        '''\n        if type(new_value) == int and 0 < new_value:\n            if self._lemma_cache is not None:\n                self._lemma_cache  = repoze.lru.LRUCache(new_value)\n                self._synset_cache = repoze.lru.LRUCache(new_value)", "response": "Sets the size of the cache used to reduce the number of database\n            access operations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_lemmas(self):\n        '''\n        A generator over all the lemmas in the GermaNet database.\n        '''\n        for lemma_dict in self._mongo_db.lexunits.find():\n            yield Lemma(self, lemma_dict)", "response": "A generator over all the lemmas in the GermaNet database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lemmas(self, lemma, pos = None):\n        '''\n        Looks up lemmas in the GermaNet database.\n\n        Arguments:\n        - `lemma`:\n        - `pos`:\n        '''\n        if pos is not None:\n            if pos not in SHORT_POS_TO_LONG:\n                return None\n            pos         = SHORT_POS_TO_LONG[pos]\n            lemma_dicts = self._mongo_db.lexunits.find({'orthForm': lemma,\n                                                        'category': pos})\n        else:\n            lemma_dicts = self._mongo_db.lexunits.find({'orthForm': lemma})\n        return sorted([Lemma(self, lemma_dict) for lemma_dict in lemma_dicts])", "response": "Returns a list of lemmas in the GermaNet database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_synsets(self):\n        '''\n        A generator over all the synsets in the GermaNet database.\n        '''\n        for synset_dict in self._mongo_db.synsets.find():\n            yield Synset(self, synset_dict)", "response": "A generator over all the synsets in the GermaNet database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef synsets(self, lemma, pos = None):\n        '''\n        Looks up synsets in the GermaNet database.\n\n        Arguments:\n        - `lemma`:\n        - `pos`:\n        '''\n        return sorted(set(lemma_obj.synset\n                          for lemma_obj in self.lemmas(lemma, pos)))", "response": "Returns a list of synsets in the GermaNet database for the given lemma and pos."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Synset object for the given synset_repr.", "response": "def synset(self, synset_repr):\n        '''\n        Looks up a synset in GermaNet using its string representation.\n\n        Arguments:\n        - `synset_repr`: a unicode string containing the lemma, part\n          of speech, and sense number of the first lemma of the synset\n\n        >>> gn.synset(u'funktionieren.v.2')\n        Synset(funktionieren.v.2)\n        '''\n        parts = synset_repr.split('.')\n        if len(parts) != 3:\n            return None\n        lemma, pos, sensenum = parts\n        if not sensenum.isdigit() or pos not in SHORT_POS_TO_LONG:\n            return None\n        sensenum   = int(sensenum, 10)\n        pos        = SHORT_POS_TO_LONG[pos]\n        lemma_dict = self._mongo_db.lexunits.find_one({'orthForm': lemma,\n                                                       'category': pos,\n                                                       'sense':    sensenum})\n        if lemma_dict:\n            return Lemma(self, lemma_dict).synset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_synset_by_id(self, mongo_id):\n        '''\n        Builds a Synset object from the database entry with the given\n        ObjectId.\n\n        Arguments:\n        - `mongo_id`: a bson.objectid.ObjectId object\n        '''\n        cache_hit = None\n        if self._synset_cache is not None:\n            cache_hit = self._synset_cache.get(mongo_id)\n        if cache_hit is not None:\n            return cache_hit\n        synset_dict = self._mongo_db.synsets.find_one({'_id': mongo_id})\n        if synset_dict is not None:\n            synset = Synset(self, synset_dict)\n            if self._synset_cache is not None:\n                self._synset_cache.put(mongo_id, synset)\n            return synset", "response": "Builds a Synset object from the database entry with the given ObjectId."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a Lemma object from the database entry with the given ObjectId.", "response": "def get_lemma_by_id(self, mongo_id):\n        '''\n        Builds a Lemma object from the database entry with the given\n        ObjectId.\n\n        Arguments:\n        - `mongo_id`: a bson.objectid.ObjectId object\n        '''\n        cache_hit = None\n        if self._lemma_cache is not None:\n            cache_hit = self._lemma_cache.get(mongo_id)\n        if cache_hit is not None:\n            return cache_hit\n        lemma_dict = self._mongo_db.lexunits.find_one({'_id': mongo_id})\n        if lemma_dict is not None:\n            lemma = Lemma(self, lemma_dict)\n            if self._lemma_cache is not None:\n                self._lemma_cache.put(mongo_id, lemma)\n            return lemma"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to find the base form of the given word using the data provided by the Projekt deutscher Wortschatz. This method returns a list of potential lemmas.", "response": "def lemmatise(self, word):\n        '''\n        Tries to find the base form (lemma) of the given word, using\n        the data provided by the Projekt deutscher Wortschatz.  This\n        method returns a list of potential lemmas.\n\n        >>> gn.lemmatise(u'M\u00e4nner')\n        [u'Mann']\n        >>> gn.lemmatise(u'XYZ123')\n        [u'XYZ123']\n        '''\n        lemmas = list(self._mongo_db.lemmatiser.find({'word': word}))\n        if lemmas:\n            return [lemma['lemma'] for lemma in lemmas]\n        else:\n            return [word]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread in a GermaNet lexical information file and returns its contents as a list of dictionary structures.", "response": "def read_lexical_file(filename):\n    '''\n    Reads in a GermaNet lexical information file and returns its\n    contents as a list of dictionary structures.\n\n    Arguments:\n    - `filename`: the name of the XML file to read\n    '''\n    with open(filename, 'rb') as input_file:\n        doc = etree.parse(input_file)\n\n    synsets = []\n    assert doc.getroot().tag == 'synsets'\n    for synset in doc.getroot():\n        if synset.tag != 'synset':\n            print('unrecognised child of <synsets>', synset)\n            continue\n        synset_dict = dict(synset.items())\n        synloc = '{0} synset {1},'.format(filename,\n                                          synset_dict.get('id', '???'))\n        warn_attribs(synloc, synset, SYNSET_ATTRIBS)\n        synset_dict['lexunits'] = []\n        synsets.append(synset_dict)\n\n        for child in synset:\n            if child.tag == 'lexUnit':\n                lexunit      = child\n                lexunit_dict = dict(lexunit.items())\n                lexloc       = synloc + ' lexUnit {0},'.format(\n                    lexunit_dict.get('id', '???'))\n                warn_attribs(lexloc, lexunit, LEXUNIT_ATTRIBS)\n                # convert some properties to booleans\n                for key in ['styleMarking', 'artificial', 'namedEntity']:\n                    if key in lexunit_dict:\n                        if lexunit_dict[key] not in MAP_YESNO_TO_BOOL:\n                            print(lexloc, ('lexunit property {0} has '\n                                           'non-boolean value').format(key),\n                                  lexunit_dict[key])\n                            continue\n                        lexunit_dict[key] = MAP_YESNO_TO_BOOL[lexunit_dict[key]]\n                # convert sense to integer number\n                if 'sense' in lexunit_dict:\n                    if lexunit_dict['sense'].isdigit():\n                        lexunit_dict['sense'] = int(lexunit_dict['sense'], 10)\n                    else:\n                        print(lexloc,\n                              'lexunit property sense has non-numeric value',\n                              lexunit_dict['sense'])\n                synset_dict['lexunits'].append(lexunit_dict)\n                lexunit_dict['examples'] = []\n                lexunit_dict['frames']   = []\n                for child in lexunit:\n                    if child.tag in ['orthForm',\n                                     'orthVar',\n                                     'oldOrthForm',\n                                     'oldOrthVar']:\n                        warn_attribs(lexloc, child, set())\n                        if not child.text:\n                            print(lexloc, '{0} with no text'.format(child.tag))\n                            continue\n                        if child.tag in lexunit_dict:\n                            print(lexloc, 'more than one {0}'.format(child.tag))\n                        lexunit_dict[child.tag] = str(child.text)\n                    elif child.tag == 'example':\n                        example = child\n                        text = [child for child in example\n                                if child.tag == 'text']\n                        if len(text) != 1 or not text[0].text:\n                            print(lexloc, '<example> tag without text')\n                        example_dict = {'text': str(text[0].text)}\n                        for child in example:\n                            if child.tag == 'text':\n                                continue\n                            elif child.tag == 'exframe':\n                                if 'exframe' in example_dict:\n                                    print(lexloc,\n                                          'more than one <exframe> '\n                                          'for <example>')\n                                warn_attribs(lexloc, child, set())\n                                if not child.text:\n                                    print(lexloc, '<exframe> with no text')\n                                    continue\n                                example_dict['exframe'] = str(child.text)\n                            else:\n                                print(lexloc,\n                                      'unrecognised child of <example>',\n                                      child)\n                        lexunit_dict['examples'].append(example_dict)\n                    elif child.tag == 'frame':\n                        frame = child\n                        warn_attribs(lexloc, frame, set())\n                        if 0 < len(frame):\n                            print(lexloc, 'unrecognised <frame> children',\n                                list(frame))\n                        if not frame.text:\n                            print(lexloc, '<frame> without text')\n                            continue\n                        lexunit_dict['frames'].append(str(frame.text))\n                    elif child.tag == 'compound':\n                        compound = child\n                        warn_attribs(lexloc, compound, set())\n                        compound_dict = {}\n                        for child in compound:\n                            if child.tag == 'modifier':\n                                modifier_dict = dict(child.items())\n                                warn_attribs(lexloc, child,\n                                             MODIFIER_ATTRIBS, set())\n                                if not child.text:\n                                    print(lexloc, 'modifier without text')\n                                    continue\n                                modifier_dict['text'] = str(child.text)\n                                if 'modifier' not in compound_dict:\n                                    compound_dict['modifier'] = []\n                                compound_dict['modifier'].append(modifier_dict)\n                            elif child.tag == 'head':\n                                head_dict = dict(child.items())\n                                warn_attribs(lexloc, child, HEAD_ATTRIBS, set())\n                                if not child.text:\n                                    print(lexloc, '<head> without text')\n                                    continue\n                                head_dict['text'] = str(child.text)\n                                if 'head' in compound_dict:\n                                    print(lexloc,\n                                          'more than one head in <compound>')\n                                compound_dict['head'] = head_dict\n                            else:\n                                print(lexloc,\n                                      'unrecognised child of <compound>',\n                                      child)\n                                continue\n                    else:\n                        print(lexloc, 'unrecognised child of <lexUnit>', child)\n                        continue\n            elif child.tag == 'paraphrase':\n                paraphrase = child\n                warn_attribs(synloc, paraphrase, set())\n                paraphrase_text = str(paraphrase.text)\n                if not paraphrase_text:\n                    print(synloc, 'WARNING: <paraphrase> tag with no text')\n            else:\n                print(synloc, 'unrecognised child of <synset>', child)\n                continue\n\n    return synsets"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_relation_file(filename):\n    '''\n    Reads the GermaNet relation file ``gn_relations.xml`` which lists\n    all the relations holding between lexical units and synsets.\n\n    Arguments:\n    - `filename`:\n    '''\n    with open(filename, 'rb') as input_file:\n        doc = etree.parse(input_file)\n\n    lex_rels = []\n    con_rels = []\n    assert doc.getroot().tag == 'relations'\n    for child in doc.getroot():\n        if child.tag == 'lex_rel':\n            if 0 < len(child):\n                print('<lex_rel> has unexpected child node')\n            child_dict = dict(child.items())\n            warn_attribs('', child, RELATION_ATTRIBS, RELATION_ATTRIBS_REQD)\n            if child_dict['dir'] not in LEX_REL_DIRS:\n                print('unrecognized <lex_rel> dir', child_dict['dir'])\n            if child_dict['dir'] == 'both' and 'inv' not in child_dict:\n                print('<lex_rel> has dir=both but does not specify inv')\n            lex_rels.append(child_dict)\n        elif child.tag == 'con_rel':\n            if 0 < len(child):\n                print('<con_rel> has unexpected child node')\n            child_dict = dict(child.items())\n            warn_attribs('', child, RELATION_ATTRIBS, RELATION_ATTRIBS_REQD)\n            if child_dict['dir'] not in CON_REL_DIRS:\n                print('unrecognised <con_rel> dir', child_dict['dir'])\n            if (child_dict['dir'] in ['both', 'revert'] and\n                'inv' not in child_dict):\n                print('<con_rel> has dir={0} but does not specify inv'.format(\n                    child_dict['dir']))\n            con_rels.append(child_dict)\n        else:\n            print('unrecognised child of <relations>', child)\n            continue\n\n    return lex_rels, con_rels", "response": "Reads the GermaNet relation file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_paraphrase_file(filename):\n    '''\n    Reads in a GermaNet wiktionary paraphrase file and returns its\n    contents as a list of dictionary structures.\n\n    Arguments:\n    - `filename`:\n    '''\n    with open(filename, 'rb') as input_file:\n        doc = etree.parse(input_file)\n\n    assert doc.getroot().tag == 'wiktionaryParaphrases'\n    paraphrases = []\n    for child in doc.getroot():\n        if child.tag == 'wiktionaryParaphrase':\n            paraphrase = child\n            warn_attribs('', paraphrase, PARAPHRASE_ATTRIBS)\n            if 0 < len(paraphrase):\n                print('unrecognised child of <wiktionaryParaphrase>',\n                      list(paraphrase))\n            paraphrase_dict = dict(paraphrase.items())\n            if paraphrase_dict['edited'] not in MAP_YESNO_TO_BOOL:\n                print('<paraphrase> attribute \"edited\" has unexpected value',\n                      paraphrase_dict['edited'])\n            else:\n                paraphrase_dict['edited'] = MAP_YESNO_TO_BOOL[\n                    paraphrase_dict['edited']]\n            if not paraphrase_dict['wiktionarySenseId'].isdigit():\n                print('<paraphrase> attribute \"wiktionarySenseId\" has '\n                      'non-integer value', paraphrase_dict['edited'])\n            else:\n                paraphrase_dict['wiktionarySenseId'] = \\\n                    int(paraphrase_dict['wiktionarySenseId'], 10)\n            paraphrases.append(paraphrase_dict)\n        else:\n            print('unknown child of <wiktionaryParaphrases>', child)\n\n    return paraphrases", "response": "Reads in a GermaNet wiktionary paraphrase file and returns its contents as a list of dictionary structures."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert_lexical_information(germanet_db, lex_files):\n    '''\n    Reads in the given lexical information files and inserts their\n    contents into the given MongoDB database.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    - `lex_files`: a list of paths to XML files containing lexial\n      information\n    '''\n    # drop the database collections if they already exist\n    germanet_db.lexunits.drop()\n    germanet_db.synsets.drop()\n    # inject data from XML files into the database\n    for lex_file in lex_files:\n        synsets = read_lexical_file(lex_file)\n        for synset in synsets:\n            synset = dict((SYNSET_KEY_REWRITES.get(key, key), value)\n                          for (key, value) in synset.items())\n            lexunits = synset['lexunits']\n            synset['lexunits'] = germanet_db.lexunits.insert(lexunits)\n            synset_id = germanet_db.synsets.insert(synset)\n            for lexunit in lexunits:\n                lexunit['synset']   = synset_id\n                lexunit['category'] = synset['category']\n                germanet_db.lexunits.save(lexunit)\n    # index the two collections by id\n    germanet_db.synsets.create_index('id')\n    germanet_db.lexunits.create_index('id')\n    # also index lexunits by lemma, lemma-pos, and lemma-pos-sensenum\n    germanet_db.lexunits.create_index([('orthForm', DESCENDING)])\n    germanet_db.lexunits.create_index([('orthForm', DESCENDING),\n                                       ('category', DESCENDING)])\n    germanet_db.lexunits.create_index([('orthForm', DESCENDING),\n                                       ('category', DESCENDING),\n                                       ('sense', DESCENDING)])\n    print('Inserted {0} synsets, {1} lexical units.'.format(\n        germanet_db.synsets.count(),\n        germanet_db.lexunits.count()))", "response": "Reads in the given list of lexical information files and inserts their\n    contents into the given MongoDB database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading in the given GermaNet relation file and inserts its contents into the given MongoDB database.", "response": "def insert_relation_information(germanet_db, gn_rels_file):\n    '''\n    Reads in the given GermaNet relation file and inserts its contents\n    into the given MongoDB database.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    - `gn_rels_file`:\n    '''\n    lex_rels, con_rels = read_relation_file(gn_rels_file)\n\n    # cache the lexunits while we work on them\n    lexunits = {}\n    for lex_rel in lex_rels:\n        if lex_rel['from'] not in lexunits:\n            lexunits[lex_rel['from']] = germanet_db.lexunits.find_one(\n                {'id': lex_rel['from']})\n        from_lexunit = lexunits[lex_rel['from']]\n        if lex_rel['to'] not in lexunits:\n            lexunits[lex_rel['to']] = germanet_db.lexunits.find_one(\n                {'id': lex_rel['to']})\n        to_lexunit = lexunits[lex_rel['to']]\n        if 'rels' not in from_lexunit:\n            from_lexunit['rels'] = set()\n        from_lexunit['rels'].add((lex_rel['name'], to_lexunit['_id']))\n        if lex_rel['dir'] == 'both':\n            if 'rels' not in to_lexunit:\n                to_lexunit['rels'] = set()\n            to_lexunit['rels'].add((lex_rel['inv'], from_lexunit['_id']))\n    for lexunit in lexunits.values():\n        if 'rels' in lexunit:\n            lexunit['rels'] = sorted(lexunit['rels'])\n            germanet_db.lexunits.save(lexunit)\n\n    # cache the synsets while we work on them\n    synsets = {}\n    for con_rel in con_rels:\n        if con_rel['from'] not in synsets:\n            synsets[con_rel['from']] = germanet_db.synsets.find_one(\n                {'id': con_rel['from']})\n        from_synset = synsets[con_rel['from']]\n        if con_rel['to'] not in synsets:\n            synsets[con_rel['to']] = germanet_db.synsets.find_one(\n                {'id': con_rel['to']})\n        to_synset = synsets[con_rel['to']]\n        if 'rels' not in from_synset:\n            from_synset['rels'] = set()\n        from_synset['rels'].add((con_rel['name'], to_synset['_id']))\n        if con_rel['dir'] in ['both', 'revert']:\n            if 'rels' not in to_synset:\n                to_synset['rels'] = set()\n            to_synset['rels'].add((con_rel['inv'], from_synset['_id']))\n    for synset in synsets.values():\n        if 'rels' in synset:\n            synset['rels'] = sorted(synset['rels'])\n            germanet_db.synsets.save(synset)\n\n    print('Inserted {0} lexical relations, {1} synset relations.'.format(\n        len(lex_rels), len(con_rels)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads in the GermaNet relation file and inserts its contents into the MongoDB database.", "response": "def insert_paraphrase_information(germanet_db, wiktionary_files):\n    '''\n    Reads in the given GermaNet relation file and inserts its contents\n    into the given MongoDB database.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    - `wiktionary_files`:\n    '''\n    num_paraphrases = 0\n    # cache the lexunits while we work on them\n    lexunits = {}\n    for filename in wiktionary_files:\n        paraphrases = read_paraphrase_file(filename)\n        num_paraphrases += len(paraphrases)\n        for paraphrase in paraphrases:\n            if paraphrase['lexUnitId'] not in lexunits:\n                lexunits[paraphrase['lexUnitId']] = \\\n                    germanet_db.lexunits.find_one(\n                    {'id': paraphrase['lexUnitId']})\n            lexunit = lexunits[paraphrase['lexUnitId']]\n            if 'paraphrases' not in lexunit:\n                lexunit['paraphrases'] = []\n            lexunit['paraphrases'].append(paraphrase)\n    for lexunit in lexunits.values():\n        germanet_db.lexunits.save(lexunit)\n\n    print('Inserted {0} wiktionary paraphrases.'.format(num_paraphrases))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_lemmatisation_data(germanet_db):\n    '''\n    Creates the lemmatiser collection in the given MongoDB instance\n    using the data derived from the Projekt deutscher Wortschatz.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    '''\n    # drop the database collection if it already exists\n    germanet_db.lemmatiser.drop()\n    num_lemmas = 0\n    input_file = gzip.open(os.path.join(os.path.dirname(__file__),\n                                        LEMMATISATION_FILE))\n    for line in input_file:\n        line = line.decode('iso-8859-1').strip().split('\\t')\n        assert len(line) == 2\n        germanet_db.lemmatiser.insert(dict(list(zip(('word', 'lemma'), line))))\n        num_lemmas += 1\n    input_file.close()\n    # index the collection on 'word'\n    germanet_db.lemmatiser.create_index('word')\n\n    print('Inserted {0} lemmatiser entries.'.format(num_lemmas))", "response": "Inserts the lemmatisation data into the MongoDB database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_infocontent_data(germanet_db):\n    '''\n    For every synset in GermaNet, inserts count information derived\n    from SDEWAC.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    '''\n    gnet           = germanet.GermaNet(germanet_db)\n    # use add one smoothing\n    gn_counts      = defaultdict(lambda: 1.)\n    total_count    = 1\n    input_file     = gzip.open(os.path.join(os.path.dirname(__file__),\n                                            WORD_COUNT_FILE))\n    num_lines_read = 0\n    num_lines      = 0\n    for line in input_file:\n        line       = line.decode('utf-8').strip().split('\\t')\n        num_lines += 1\n        if len(line) != 3:\n            continue\n        count, pos, word = line\n        num_lines_read += 1\n        count           = int(count)\n        synsets         = set(gnet.synsets(word, pos))\n        if not synsets:\n            continue\n        # Although Resnik (1995) suggests dividing count by the number\n        # of synsets, Patwardhan et al (2003) argue against doing\n        # this.\n        count = float(count) / len(synsets)\n        for synset in synsets:\n            total_count += count\n            paths = synset.hypernym_paths\n            scount = float(count) / len(paths)\n            for path in paths:\n                for ss in path:\n                    gn_counts[ss._id] += scount\n    print('Read {0} of {1} lines from count file.'.format(num_lines_read,\n                                                          num_lines))\n    print('Recorded counts for {0} synsets.'.format(len(gn_counts)))\n    print('Total count is {0}'.format(total_count))\n    input_file.close()\n    # update all the synset records in GermaNet\n    num_updates = 0\n    for synset in germanet_db.synsets.find():\n        synset['infocont'] = gn_counts[synset['_id']] / total_count\n        germanet_db.synsets.save(synset)\n        num_updates += 1\n    print('Updated {0} synsets.'.format(num_updates))", "response": "Insert count information for every synset in GermaNet."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the maximum min_depth of all parts of speech in GermaNet.", "response": "def compute_max_min_depth(germanet_db):\n    '''\n    For every part of speech in GermaNet, computes the maximum\n    min_depth in that hierarchy.\n\n    Arguments:\n    - `germanet_db`: a pymongo.database.Database object\n    '''\n    gnet           = germanet.GermaNet(germanet_db)\n    max_min_depths = defaultdict(lambda: -1)\n    for synset in gnet.all_synsets():\n        min_depth = synset.min_depth\n        if max_min_depths[synset.category] < min_depth:\n            max_min_depths[synset.category] = min_depth\n\n    if germanet_db.metainfo.count() == 0:\n        germanet_db.metainfo.insert({})\n    metainfo = germanet_db.metainfo.find_one()\n    metainfo['max_min_depths'] = max_min_depths\n    germanet_db.metainfo.save(metainfo)\n\n    print('Computed maximum min_depth for all parts of speech:')\n    print(u', '.join(u'{0}: {1}'.format(k, v) for (k, v) in\n                     sorted(max_min_depths.items())).encode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_In(self, node):\n        '''in'''\n        try:\n            elts = node.elts\n        except AttributeError:\n            raise ParseError('Invalid value type for `in` operator: {0}'.format(node.__class__.__name__),\n                             col_offset=node.col_offset)\n        return {'$in': list(map(self.field.handle, elts))}", "response": "Handle the In operator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign a value to this Value.", "response": "def AssignVar(self, value):\n    \"\"\"Assign a value to this Value.\"\"\"\n    self.value = value\n    # Call OnAssignVar on options.\n    [option.OnAssignVar() for option in self.options]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Parse(self, value):\n\n    value_line = value.split(' ')\n    if len(value_line) < 3:\n      raise TextFSMTemplateError('Expect at least 3 tokens on line.')\n\n    if not value_line[2].startswith('('):\n      # Options are present\n      options = value_line[1]\n      for option in options.split(','):\n        self._AddOption(option)\n      # Call option OnCreateOptions callbacks\n      [option.OnCreateOptions() for option in self.options]\n\n      self.name = value_line[2]\n      self.regex = ' '.join(value_line[3:])\n    else:\n      # There were no valid options, so there are no options.\n      # Treat this argument as the name.\n      self.name = value_line[1]\n      self.regex = ' '.join(value_line[2:])\n\n    if len(self.name) > self.max_name_len:\n      raise TextFSMTemplateError(\n          \"Invalid Value name '%s' or name too long.\" % self.name)\n\n    if (not re.match(r'^\\(.*\\)$', self.regex) or\n        self.regex.count('(') != self.regex.count(')')):\n      raise TextFSMTemplateError(\n          \"Value '%s' must be contained within a '()' pair.\" % self.regex)\n\n    self.template = re.sub(r'^\\(', '(?P<%s>' % self.name, self.regex)", "response": "Parses a Value declaration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _CheckLine(self, line):\n    for rule in self._cur_state:\n      matched = self._CheckRule(rule, line)\n      if matched:\n        for value in matched.groupdict():\n          self._AssignVar(matched, value)\n\n        if self._Operations(rule):\n          # Not a Continue so check for state transition.\n          if rule.new_state:\n            if rule.new_state not in ('End', 'EOF'):\n              self._cur_state = self.states[rule.new_state]\n            self._cur_state_name = rule.new_state\n          break", "response": "Checks the line through each rule until a match is made."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _make_graphite_api_points_list(influxdb_data):\n    _data = {}\n    for key in influxdb_data.keys():\n        _data[key[0]] = [(datetime.datetime.fromtimestamp(float(d['time'])),\n                          d['value']) for d in influxdb_data.get_points(key[0])]\n    return _data", "response": "Make a list of graphite - api data points dictionary from Influxdb ResultSet data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _setup_logger(self, level, log_file):\n        if logger.handlers:\n            return\n        level = getattr(logging, level.upper())\n        logger.setLevel(level)\n        formatter = logging.Formatter(\n            '[%(levelname)s] %(asctime)s - %(module)s.%(funcName)s() - %(message)s')\n        handler = logging.StreamHandler()\n        logger.addHandler(handler)\n        handler.setFormatter(formatter)\n        if not log_file:\n            return\n        try:\n            handler = TimedRotatingFileHandler(log_file)\n        except IOError:\n            logger.error(\"Could not write to %s, falling back to stdout\",\n                         log_file)\n        else:\n            logger.addHandler(handler)\n            handler.setFormatter(formatter)", "response": "Setup log level and log file if set"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile_regex(self, fmt, query):\n        return re.compile(fmt.format(\n            query.pattern.replace('.', '\\.').replace('*', '[^\\.]*').replace(\n                '{', '(').replace(',', '|').replace('}', ')')\n        ))", "response": "Turn glob ( graphite ) queries into compiled regex"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting an expression and optional schema.", "response": "def find(expression, schema=None):\n    '''\n    Gets an <expression> and optional <schema>.\n    <expression> should be a string of python code.\n    <schema> should be a dictionary mapping field names to types.\n    '''\n    parser = SchemaFreeParser() if schema is None else SchemaAwareParser(schema)\n    return parser.parse(expression)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort(fields):\n    '''\n    Gets a list of <fields> to sort by.\n    Also supports getting a single string for sorting by one field.\n    Reverse sort is supported by appending '-' to the field name.\n    Example: sort(['age', '-height']) will sort by ascending age and descending height.\n    '''\n    from pymongo import ASCENDING, DESCENDING\n    from bson import SON\n\n    if isinstance(fields, str):\n        fields = [fields]\n    if not hasattr(fields, '__iter__'):\n        raise ValueError(\"expected a list of strings or a string. not a {}\".format(type(fields)))\n    \n    sort = []\n    for field in fields:\n        if field.startswith('-'):\n            field = field[1:]\n            sort.append((field, DESCENDING))\n            continue\n        elif field.startswith('+'):\n            field = field[1:]\n        sort.append((field, ASCENDING))\n    return {'$sort': SON(sort)}", "response": "Returns a dict that can be used to sort the items in a sequence of objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn ordered version of nested dicts or lists for comparing.", "response": "def ordered(obj):\n    \"\"\"\n    Return sorted version of nested dicts/lists for comparing.\n\n    Modified from:\n    http://stackoverflow.com/a/25851972\n    \"\"\"\n    if isinstance(obj, collections.abc.Mapping):\n        return sorted((k, ordered(v)) for k, v in obj.items())\n    # Special case str since it's a collections.abc.Iterable\n    elif isinstance(obj, str):\n        return obj\n    elif isinstance(obj, collections.abc.Iterable):\n        return sorted(ordered(x) for x in obj)\n    else:\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo not yield the input class", "response": "def walk_subclasses(root):\n    \"\"\"Does not yield the input class\"\"\"\n    classes = [root]\n    visited = set()\n    while classes:\n        cls = classes.pop()\n        if cls is type or cls in visited:\n            continue\n        classes.extend(cls.__subclasses__())\n        visited.add(cls)\n        if cls is not root:\n            yield cls"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump_key(engine, obj):\n    key = {}\n    for key_column in obj.Meta.keys:\n        key_value = getattr(obj, key_column.name, missing)\n        if key_value is missing:\n            raise MissingKey(\"{!r} is missing {}: {!r}\".format(\n                obj, \"hash_key\" if key_column.hash_key else \"range_key\",\n                key_column.name\n            ))\n        # noinspection PyProtectedMember\n        key_value = engine._dump(key_column.typedef, key_value)\n        key[key_column.dynamo_name] = key_value\n    return key", "response": "dump the hash and range key of an object into a dynamo - friendly format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an expiration date in the future", "response": "def new_expiry(days=DEFAULT_PASTE_LIFETIME_DAYS):\n    \"\"\"Return an expiration `days` in the future\"\"\"\n    now = delorean.Delorean()\n    return now + datetime.timedelta(days=days)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync(obj, engine):\n    snapshot = Condition()\n    # Only expect values (or lack of a value) for columns that have been explicitly set\n    for column in sorted(_obj_tracking[obj][\"marked\"], key=lambda col: col.dynamo_name):\n        value = getattr(obj, column.name, None)\n        value = engine._dump(column.typedef, value)\n        condition = column == value\n        # The renderer shouldn't try to dump the value again.\n        # We're dumping immediately in case the value is mutable,\n        # such as a set or (many) custom data types.\n        condition.dumped = True\n        snapshot &= condition\n    _obj_tracking[obj][\"snapshot\"] = snapshot", "response": "Mark the object as having been persisted at least once."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef printable_name(column, path=None):\n    pieces = [column.name]\n    path = path or path_of(column)\n    for segment in path:\n        if isinstance(segment, str):\n            pieces.append(segment)\n        else:\n            pieces[-1] += \"[{}]\".format(segment)\n    return \".\".join(pieces)", "response": "Given a column and a path return a printable name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields all conditions within the given condition.", "response": "def iter_conditions(condition):\n    \"\"\"Yield all conditions within the given condition.\n\n    If the root condition is and/or/not, it is not yielded (unless a cyclic reference to it is found).\"\"\"\n    conditions = list()\n    visited = set()\n    # Has to be split out, since we don't want to visit the root (for cyclic conditions)\n    # but we don't want to yield it (if it's non-cyclic) because this only yields inner conditions\n    if condition.operation in {\"and\", \"or\"}:\n        conditions.extend(reversed(condition.values))\n    elif condition.operation == \"not\":\n        conditions.append(condition.values[0])\n    else:\n        conditions.append(condition)\n    while conditions:\n        condition = conditions.pop()\n        if condition in visited:\n            continue\n        visited.add(condition)\n        yield condition\n        if condition.operation in {\"and\", \"or\", \"not\"}:\n            conditions.extend(reversed(condition.values))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_columns(condition):\n    # Like iter_conditions, this can't live in each condition without going possibly infinite on the\n    # recursion, or passing the visited set through every call.  That makes the signature ugly, so we\n    # take care of it here.  Luckily, it's pretty easy to leverage iter_conditions and just unpack the\n    # actual columns.\n    visited = set()\n    for condition in iter_conditions(condition):\n        if condition.operation in (\"and\", \"or\", \"not\"):\n            continue\n        # Non-meta conditions always have a column, and each of values has the potential to be a column.\n        # Comparison will only have a list of len 1, but it's simpler to just iterate values and check each\n\n        # unwrap proxies created for paths\n        column = proxied(condition.column)\n\n        # special case for None\n        # this could also have skipped on isinstance(condition, Condition)\n        # but this is slightly more flexible for users to create their own None-sentinel Conditions\n        if column is None:\n            continue\n        if column not in visited:\n            visited.add(column)\n            yield column\n            for value in condition.values:\n                if isinstance(value, ComparisonMixin):\n                    if value not in visited:\n                        visited.add(value)\n                        yield value", "response": "Iterate over all columns in the condition or its inner conditions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a tuple of the ref and value for the given column and value.", "response": "def _value_ref(self, column, value, *, dumped=False, inner=False):\n        \"\"\"inner=True uses column.typedef.inner_type instead of column.typedef\"\"\"\n        ref = \":v{}\".format(self.next_index)\n\n        # Need to dump this value\n        if not dumped:\n            typedef = column.typedef\n            for segment in path_of(column):\n                typedef = typedef[segment]\n            if inner:\n                typedef = typedef.inner_typedef\n            value = self.engine._dump(typedef, value)\n\n        self.attr_values[ref] = value\n        self.counts[ref] += 1\n        return ref, value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef any_ref(self, *, column, value=missing, dumped=False, inner=False):\n        # Can't use None since it's a legal value for comparisons (attribute_not_exists)\n        if value is missing:\n            # Simple path ref to the column.\n            name = self._path_ref(column=column)\n            ref_type = \"name\"\n            value = None\n        elif isinstance(value, ComparisonMixin):\n            # value is also a column!  Also a path ref.\n            name = self._path_ref(column=value)\n            ref_type = \"name\"\n            value = None\n        else:\n            # Simple value ref.\n            name, value = self._value_ref(column=column, value=value, dumped=dumped, inner=inner)\n            ref_type = \"value\"\n        return Reference(name=name, type=ref_type, value=value)", "response": "Returns a NamedTuple of name type and value for any type of reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders the expression for the current state of the object.", "response": "def render(self, obj=None, condition=None, atomic=False, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool atomic: *(Optional)*  True if an atomic condition should be created for ``obj`` and rendered as\n            a \"ConditionExpression\".  Default is False.\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, redered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if (atomic or update) and not obj:\n            raise InvalidCondition(\"An object is required to render atomic conditions or updates without an object.\")\n\n        if filter:\n            self.render_filter_expression(filter)\n\n        if projection:\n            self.render_projection_expression(projection)\n\n        if key:\n            self.render_key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        condition = (condition or Condition()) & (get_snapshot(obj) if atomic else Condition())\n        if condition:\n            self.render_condition_expression(condition)\n\n        if update:\n            self.render_update_expression(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces the attr dict at the given key with an instance of a Model", "response": "def _unpack(self, record, key, expected):\n        \"\"\"Replaces the attr dict at the given key with an instance of a Model\"\"\"\n        attrs = record.get(key)\n        if attrs is None:\n            return\n        obj = unpack_from_dynamodb(\n            attrs=attrs,\n            expected=expected,\n            model=self.model,\n            engine=self.engine\n        )\n        object_loaded.send(self.engine, engine=self.engine, obj=obj)\n        record[key] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reformat_record(record):\n    return {\n        \"key\": record[\"dynamodb\"].get(\"Keys\", None),\n        \"new\": record[\"dynamodb\"].get(\"NewImage\", None),\n        \"old\": record[\"dynamodb\"].get(\"OldImage\", None),\n\n        \"meta\": {\n            \"created_at\": record[\"dynamodb\"][\"ApproximateCreationDateTime\"],\n            \"event\": {\n                \"id\": record[\"eventID\"],\n                \"type\": record[\"eventName\"].lower(),\n                \"version\": record[\"eventVersion\"]\n            },\n            \"sequence_number\": record[\"dynamodb\"][\"SequenceNumber\"],\n        }\n    }", "response": "Repack a record into a cleaner structure for consumption."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unpack_shards(shards, stream_arn, session):\n    if not shards:\n        return {}\n\n    # When unpacking tokens, shard id key is \"shard_id\"\n    # When unpacking DescribeStream responses, shard id key is \"ShardId\"\n    if \"ShardId\" in shards[0]:\n        shards = _translate_shards(shards)\n\n    by_id = {shard_token[\"shard_id\"]:\n             Shard(stream_arn=stream_arn, shard_id=shard_token[\"shard_id\"],\n                   iterator_type=shard_token.get(\"iterator_type\"), sequence_number=shard_token.get(\"sequence_number\"),\n                   parent=shard_token.get(\"parent\"), session=session)\n             for shard_token in shards}\n\n    for shard in by_id.values():\n        if shard.parent:\n            shard.parent = by_id[shard.parent]\n            shard.parent.children.append(shard)\n    return by_id", "response": "Unpacks a list of Shards into a single object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the current state as a json - friendly dict.", "response": "def token(self):\n        \"\"\"JSON-serializable representation of the current Shard state.\n\n        The token is enough to rebuild the Shard as part of rebuilding a Stream.\n\n        :returns: Shard state as a json-friendly dict\n        :rtype: dict\n        \"\"\"\n        if self.iterator_type in RELATIVE_ITERATORS:\n            logger.warning(\"creating shard token at non-exact location \\\"{}\\\"\".format(self.iterator_type))\n        token = {\n            \"stream_arn\": self.stream_arn,\n            \"shard_id\": self.shard_id,\n            \"iterator_type\": self.iterator_type,\n            \"sequence_number\": self.sequence_number,\n        }\n        if self.parent:\n            token[\"parent\"] = self.parent.shard_id\n        if not self.iterator_type:\n            del token[\"iterator_type\"]\n        if not self.sequence_number:\n            del token[\"sequence_number\"]\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk_tree(self):\n        shards = collections.deque([self])\n        while shards:\n            shard = shards.popleft()\n            yield shard\n            shards.extend(shard.children)", "response": "Generator that yields each shard in the tree in order."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jump_to(self, *, iterator_type, sequence_number=None):\n        # Just a simple wrapper; let the caller handle RecordsExpired\n        self.iterator_id = self.session.get_shard_iterator(\n            stream_arn=self.stream_arn,\n            shard_id=self.shard_id,\n            iterator_type=iterator_type,\n            sequence_number=sequence_number)\n        self.iterator_type = iterator_type\n        self.sequence_number = sequence_number\n        self.empty_responses = 0", "response": "Move to a new position in the shard using the standard parameters to GetShardIterator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmoving the Shard s iterator to the earliest record after the given position.", "response": "def seek_to(self, position):\n        \"\"\"Move the Shard's iterator to the earliest record after the :class:`~datetime.datetime` time.\n\n        Returns the first records at or past ``position``.  If the list is empty,\n        the seek failed to find records, either because the Shard is exhausted or it\n        reached the HEAD of an open Shard.\n\n        :param position: The position in time to move to.\n        :type position: :class:`~datetime.datetime`\n        :returns: A list of the first records found after ``position``.  May be empty.\n        \"\"\"\n        # 0) We have no way to associate the date with a position,\n        #    so we have to scan the shard from the beginning.\n        self.jump_to(iterator_type=\"trim_horizon\")\n\n        position = int(position.timestamp())\n\n        while (not self.exhausted) and (self.empty_responses < CALLS_TO_REACH_HEAD):\n            records = self.get_records()\n            # We can skip the whole record set if the newest (last) record isn't new enough.\n            if records and records[-1][\"meta\"][\"created_at\"].timestamp() >= position:\n                # Looking for the first number *below* the position.\n                for offset, record in enumerate(reversed(records)):\n                    if record[\"meta\"][\"created_at\"].timestamp() < position:\n                        index = len(records) - offset\n                        return records[index:]\n                return records\n\n        # Either exhausted the Shard or caught up to HEAD.\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_children(self):\n        # Child count is fixed the first time any of the following happen:\n        # 0 :: stream closed or throughput decreased\n        # 1 :: shard was open for ~4 hours\n        # 2 :: throughput increased\n\n        if self.children:\n            return self.children\n\n        # ParentShardId -> [Shard, ...]\n        by_parent = collections.defaultdict(list)\n        # ShardId -> Shard\n        by_id = {}\n\n        for shard in self.session.describe_stream(\n                stream_arn=self.stream_arn,\n                first_shard=self.shard_id)[\"Shards\"]:\n            parent_list = by_parent[shard.get(\"ParentShardId\")]\n            shard = Shard(\n                stream_arn=self.stream_arn,\n                shard_id=shard[\"ShardId\"],\n                parent=shard.get(\"ParentShardId\"),\n                session=self.session)\n            parent_list.append(shard)\n            by_id[shard.shard_id] = shard\n\n        # Find this shard when looking up shards by ParentShardId\n        by_id[self.shard_id] = self\n\n        # Insert this shard's children, then handle its child's descendants etc.\n        to_insert = collections.deque(by_parent[self.shard_id])\n        while to_insert:\n            shard = to_insert.popleft()\n            # ParentShardId -> Shard\n            shard.parent = by_id[shard.parent]\n            shard.parent.children.append(shard)\n            # Continue for any shards that have this shard as their parent\n            to_insert.extend(by_parent[shard.shard_id])\n\n        return self.children", "response": "Loads the children of this Shard from DescribeStream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the next set of records in this shard.", "response": "def get_records(self):\n        \"\"\"Get the next set of records in this shard.  An empty list doesn't guarantee the shard is exhausted.\n\n        :returns: A list of reformatted records.  May be empty.\n        \"\"\"\n        # Won't be able to find new records.\n        if self.exhausted:\n            return []\n\n        # Already caught up, just the one call please.\n        if self.empty_responses >= CALLS_TO_REACH_HEAD:\n            return self._apply_get_records_response(self.session.get_stream_records(self.iterator_id))\n\n        # Up to 5 calls to try and find a result\n        while self.empty_responses < CALLS_TO_REACH_HEAD and not self.exhausted:\n            records = self._apply_get_records_response(self.session.get_stream_records(self.iterator_id))\n            if records:\n                return records\n\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbind a model to a specific base model.", "response": "def bind(self, model, *, skip_table_setup=False):\n        \"\"\"Create backing tables for a model and its non-abstract subclasses.\n\n        :param model: Base model to bind.  Can be abstract.\n        :param skip_table_setup: Don't create or verify the table in DynamoDB.  Default is False.\n        :raises bloop.exceptions.InvalidModel: if ``model`` is not a subclass of :class:`~bloop.models.BaseModel`.\n        \"\"\"\n        # Make sure we're looking at models\n        validate_is_model(model)\n\n        concrete = set(filter(lambda m: not m.Meta.abstract, walk_subclasses(model)))\n        if not model.Meta.abstract:\n            concrete.add(model)\n        logger.debug(\"binding non-abstract models {}\".format(\n            sorted(c.__name__ for c in concrete)\n        ))\n\n        # create_table doesn't block until ACTIVE or validate.\n        # It also doesn't throw when the table already exists, making it safe\n        # to call multiple times for the same unbound model.\n        if skip_table_setup:\n            logger.info(\"skip_table_setup is True; not trying to create tables or validate models during bind\")\n        else:\n            self.session.clear_cache()\n\n        is_creating = {}\n\n        for model in concrete:\n            table_name = self._compute_table_name(model)\n            before_create_table.send(self, engine=self, model=model)\n            if not skip_table_setup:\n                if table_name in is_creating:\n                    continue\n                creating = self.session.create_table(table_name, model)\n                is_creating[table_name] = creating\n\n        for model in concrete:\n            if not skip_table_setup:\n                table_name = self._compute_table_name(model)\n                if is_creating[table_name]:\n                    # polls until table is active\n                    self.session.describe_table(table_name)\n                    if model.Meta.ttl:\n                        self.session.enable_ttl(table_name, model)\n                    if model.Meta.backups and model.Meta.backups[\"enabled\"]:\n                        self.session.enable_backups(table_name, model)\n                self.session.validate_table(table_name, model)\n                model_validated.send(self, engine=self, model=model)\n            model_bound.send(self, engine=self, model=model)\n\n        logger.info(\"successfully bound {} models to the engine\".format(len(concrete)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes one or more objects.", "response": "def delete(self, *objs, condition=None, atomic=False):\n        \"\"\"Delete one or more objects.\n\n        :param objs: objects to delete.\n        :param condition: only perform each delete if this condition holds.\n        :param bool atomic: only perform each delete if the local and DynamoDB versions of the object match.\n        :raises bloop.exceptions.ConstraintViolation: if the condition (or atomic) is not met.\n        \"\"\"\n        objs = set(objs)\n        validate_not_abstract(*objs)\n        for obj in objs:\n            self.session.delete_item({\n                \"TableName\": self._compute_table_name(obj.__class__),\n                \"Key\": dump_key(self, obj),\n                **render(self, obj=obj, atomic=atomic, condition=condition)\n            })\n            object_deleted.send(self, engine=self, obj=obj)\n        logger.info(\"successfully deleted {} objects\".format(len(objs)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, *objs, consistent=False):\n        get_table_name = self._compute_table_name\n        objs = set(objs)\n        validate_not_abstract(*objs)\n\n        table_index, object_index, request = {}, {}, {}\n\n        for obj in objs:\n            table_name = get_table_name(obj.__class__)\n            key = dump_key(self, obj)\n            index = index_for(key)\n\n            if table_name not in object_index:\n                table_index[table_name] = list(sorted(key.keys()))\n                object_index[table_name] = {}\n                request[table_name] = {\"Keys\": [], \"ConsistentRead\": consistent}\n\n            if index not in object_index[table_name]:\n                request[table_name][\"Keys\"].append(key)\n                object_index[table_name][index] = set()\n            object_index[table_name][index].add(obj)\n\n        response = self.session.load_items(request)\n\n        for table_name, list_of_attrs in response.items():\n            for attrs in list_of_attrs:\n                key_shape = table_index[table_name]\n                key = extract_key(key_shape, attrs)\n                index = index_for(key)\n\n                for obj in object_index[table_name].pop(index):\n                    unpack_from_dynamodb(\n                        attrs=attrs, expected=obj.Meta.columns, engine=self, obj=obj)\n                    object_loaded.send(self, engine=self, obj=obj)\n                if not object_index[table_name]:\n                    object_index.pop(table_name)\n\n        if object_index:\n            not_loaded = set()\n            for index in object_index.values():\n                for index_set in index.values():\n                    not_loaded.update(index_set)\n            logger.info(\"loaded {} of {} objects\".format(len(objs) - len(not_loaded), len(objs)))\n            raise MissingObjects(\"Failed to load some objects.\", objects=not_loaded)\n        logger.info(\"successfully loaded {} objects\".format(len(objs)))", "response": "Populate objects from DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a query iterator for the given model or index and key.", "response": "def query(self, model_or_index, key, filter=None, projection=\"all\", consistent=False, forward=True):\n        \"\"\"Create a reusable :class:`~bloop.search.QueryIterator`.\n\n        :param model_or_index: A model or index to query.  For example, ``User`` or ``User.by_email``.\n        :param key:\n            Key condition.  This must include an equality against the hash key, and optionally one\n            of a restricted set of conditions on the range key.\n        :param filter: Filter condition.  Only matching objects will be included in the results.\n        :param projection:\n            \"all\", \"count\", a list of column names, or a list of :class:`~bloop.models.Column`.  When projection is\n            \"count\", you must advance the iterator to retrieve the count.\n        :param bool consistent: Use `strongly consistent reads`__ if True.  Default is False.\n        :param bool forward:  Query in ascending or descending order.  Default is True (ascending).\n\n        :return: A reusable query iterator with helper methods.\n        :rtype: :class:`~bloop.search.QueryIterator`\n\n        __ http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html\n        \"\"\"\n        if isinstance(model_or_index, Index):\n            model, index = model_or_index.model, model_or_index\n        else:\n            model, index = model_or_index, None\n        validate_not_abstract(model)\n        q = Search(\n            mode=\"query\", engine=self, model=model, index=index, key=key, filter=filter,\n            projection=projection, consistent=consistent, forward=forward)\n        return iter(q.prepare())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave one or more objects.", "response": "def save(self, *objs, condition=None, atomic=False):\n        \"\"\"Save one or more objects.\n\n        :param objs: objects to save.\n        :param condition: only perform each save if this condition holds.\n        :param bool atomic: only perform each save if the local and DynamoDB versions of the object match.\n        :raises bloop.exceptions.ConstraintViolation: if the condition (or atomic) is not met.\n        \"\"\"\n        objs = set(objs)\n        validate_not_abstract(*objs)\n        for obj in objs:\n            self.session.save_item({\n                \"TableName\": self._compute_table_name(obj.__class__),\n                \"Key\": dump_key(self, obj),\n                **render(self, obj=obj, atomic=atomic, condition=condition, update=True)\n            })\n            object_saved.send(self, engine=self, obj=obj)\n        logger.info(\"successfully saved {} objects\".format(len(objs)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scan(self, model_or_index, filter=None, projection=\"all\", consistent=False, parallel=None):\n        if isinstance(model_or_index, Index):\n            model, index = model_or_index.model, model_or_index\n        else:\n            model, index = model_or_index, None\n        validate_not_abstract(model)\n        s = Search(\n            mode=\"scan\", engine=self, model=model, index=index, filter=filter,\n            projection=projection, consistent=consistent, parallel=parallel)\n        return iter(s.prepare())", "response": "Create a scan iterator for the current record set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a stream for records from a model.", "response": "def stream(self, model, position):\n        \"\"\"Create a :class:`~bloop.stream.Stream` that provides approximate chronological ordering.\n\n        .. code-block:: pycon\n\n            # Create a user so we have a record\n            >>> engine = Engine()\n            >>> user = User(id=3, email=\"user@domain.com\")\n            >>> engine.save(user)\n            >>> user.email = \"admin@domain.com\"\n            >>> engine.save(user)\n\n            # First record lacks an \"old\" value since it's an insert\n            >>> stream = engine.stream(User, \"trim_horizon\")\n            >>> next(stream)\n            {'key': None,\n             'old': None,\n             'new': User(email='user@domain.com', id=3, verified=None),\n             'meta': {\n                 'created_at': datetime.datetime(2016, 10, 23, ...),\n                 'event': {\n                     'id': '3fe6d339b7cb19a1474b3d853972c12a',\n                     'type': 'insert',\n                     'version': '1.1'},\n                 'sequence_number': '700000000007366876916'}\n            }\n\n\n        :param model: The model to stream records from.\n        :param position: \"trim_horizon\", \"latest\", a stream token, or a :class:`datetime.datetime`.\n        :return: An iterator for records in all shards.\n        :rtype: :class:`~bloop.stream.Stream`\n        :raises bloop.exceptions.InvalidStream: if the model does not have a stream.\n        \"\"\"\n        validate_not_abstract(model)\n        if not model.Meta.stream or not model.Meta.stream.get(\"arn\"):\n            raise InvalidStream(\"{!r} does not have a stream arn\".format(model))\n        stream = Stream(model=model, engine=self)\n        stream.move_to(position=position)\n        return stream"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transaction(self, mode=\"w\"):\n        if mode == \"r\":\n            cls = ReadTransaction\n        elif mode == \"w\":\n            cls = WriteTransaction\n        else:\n            raise ValueError(f\"unknown mode {mode}\")\n        return cls(self)", "response": "Create a new ReadTransaction or WriteTransaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _dump(self, value, **kwargs):\n        value = self.dynamo_dump(value, **kwargs)\n        if value is None:\n            return value\n        return {self.backing_type: value}", "response": "Entry point for serializing values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load(self, value, **kwargs):\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)", "response": "Entry point for deserializing values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the DynamoDB backing type for a given python value s type.", "response": "def backing_type_for(value):\n        \"\"\"Returns the DynamoDB backing type for a given python value's type\n\n        ::\n\n            4 -> 'N'\n            ['x', 3] -> 'L'\n            {2, 4} -> 'SS'\n        \"\"\"\n        if isinstance(value, str):\n            vtype = \"S\"\n        elif isinstance(value, bytes):\n            vtype = \"B\"\n        # NOTE: numbers.Number check must come **AFTER** bool check since isinstance(True, numbers.Number)\n        elif isinstance(value, bool):\n            vtype = \"BOOL\"\n        elif isinstance(value, numbers.Number):\n            vtype = \"N\"\n        elif isinstance(value, dict):\n            vtype = \"M\"\n        elif isinstance(value, list):\n            vtype = \"L\"\n        elif isinstance(value, set):\n            if not value:\n                vtype = \"SS\"  # doesn't matter, Set(x) should dump an empty set the same for all x\n            else:\n                inner = next(iter(value))\n                if isinstance(inner, str):\n                    vtype = \"SS\"\n                elif isinstance(inner, bytes):\n                    vtype = \"BS\"\n                elif isinstance(inner, numbers.Number):\n                    vtype = \"NS\"\n                else:\n                    raise ValueError(f\"Unknown set type for inner value {inner!r}\")\n        else:\n            raise ValueError(f\"Can't dump unexpected type {type(value)!r} for value {value!r}\")\n        return vtype"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmonitors changes in approximately real - time and replicate them", "response": "def stream_replicate():\n    \"\"\"Monitor changes in approximately real-time and replicate them\"\"\"\n    stream = primary.stream(SomeDataBlob, \"trim_horizon\")\n    next_heartbeat = pendulum.now()\n    while True:\n        now = pendulum.now()\n        if now >= next_heartbeat:\n            stream.heartbeat()\n            next_heartbeat = now.add(minutes=10)\n\n        record = next(stream)\n        if record is None:\n            continue\n        if record[\"new\"] is not None:\n            replica.save(record[\"new\"])\n        else:\n            replica.delete(record[\"old\"])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _move_stream_endpoint(coordinator, position):\n    # 0) Everything will be rebuilt from DescribeStream.\n    stream_arn = coordinator.stream_arn\n    coordinator.roots.clear()\n    coordinator.active.clear()\n    coordinator.buffer.clear()\n\n    # 1) Build a Dict[str, Shard] of the current Stream from a DescribeStream call\n    current_shards = coordinator.session.describe_stream(stream_arn=stream_arn)[\"Shards\"]\n    current_shards = unpack_shards(current_shards, stream_arn, coordinator.session)\n\n    # 2) Roots are any shards without parents.\n    coordinator.roots.extend(shard for shard in current_shards.values() if not shard.parent)\n\n    # 3.0) Stream trim_horizon is the combined trim_horizon of all roots.\n    if position == \"trim_horizon\":\n        for shard in coordinator.roots:\n            shard.jump_to(iterator_type=\"trim_horizon\")\n        coordinator.active.extend(coordinator.roots)\n    # 3.1) Stream latest is the combined latest of all shards without children.\n    else:\n        for root in coordinator.roots:\n            for shard in root.walk_tree():\n                if not shard.children:\n                    shard.jump_to(iterator_type=\"latest\")\n                    coordinator.active.append(shard)", "response": "Move to the right of the stream endpoint."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmoves the stream to a specific time.", "response": "def _move_stream_time(coordinator, time):\n    \"\"\"Scan through the *entire* Stream for the first record after ``time``.\n\n    This is an extremely expensive, naive algorithm that starts at trim_horizon and simply\n    dumps records into the void until the first hit.  General improvements in performance are\n    tough; we can use the fact that Shards have a max life of 24hr to pick a pretty-good starting\n    point for any Shard trees with 6 generations.  Even then we can't know how close the oldest one\n    is to rolling off so we either hit trim_horizon, or iterate an extra Shard more than we need to.\n\n    The corner cases are worse; short trees, recent splits, trees with different branch heights.\n    \"\"\"\n    if time > datetime.datetime.now(datetime.timezone.utc):\n        _move_stream_endpoint(coordinator, \"latest\")\n        return\n\n    _move_stream_endpoint(coordinator, \"trim_horizon\")\n    shard_trees = collections.deque(coordinator.roots)\n    while shard_trees:\n        shard = shard_trees.popleft()\n        records = shard.seek_to(time)\n\n        # Success!  This section of some Shard tree is at the desired time.\n        if records:\n            coordinator.buffer.push_all((record, shard) for record in records)\n\n        # Closed shard, keep searching its children.\n        elif shard.exhausted:\n            coordinator.remove_shard(shard, drop_buffered_records=True)\n            shard_trees.extend(shard.children)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _move_stream_token(coordinator, token):\n    stream_arn = coordinator.stream_arn = token[\"stream_arn\"]\n    # 0) Everything will be rebuilt from the DescribeStream masked by the token.\n    coordinator.roots.clear()\n    coordinator.active.clear()\n    coordinator.closed.clear()\n    coordinator.buffer.clear()\n\n    # Injecting the token gives us access to the standard shard management functions\n    token_shards = unpack_shards(token[\"shards\"], stream_arn, coordinator.session)\n    coordinator.roots = [shard for shard in token_shards.values() if not shard.parent]\n    coordinator.active.extend(token_shards[shard_id] for shard_id in token[\"active\"])\n\n    # 1) Build a Dict[str, Shard] of the current Stream from a DescribeStream call\n    current_shards = coordinator.session.describe_stream(stream_arn=stream_arn)[\"Shards\"]\n    current_shards = unpack_shards(current_shards, stream_arn, coordinator.session)\n\n    # 2) Trying to find an intersection with the actual Stream by walking each root shard's tree.\n    #    Prune any Shard with no children that's not part of the actual Stream.\n    #    Raise InvalidStream if the entire token is pruned.\n    unverified = collections.deque(coordinator.roots)\n    while unverified:\n        shard = unverified.popleft()\n        if shard.shard_id not in current_shards:\n            logger.info(\"Unknown or expired shard \\\"{}\\\" - pruning from stream token\".format(shard.shard_id))\n            coordinator.remove_shard(shard, drop_buffered_records=True)\n            unverified.extend(shard.children)\n\n    # 3) Everything was pruned, so the token describes an unknown stream.\n    if not coordinator.roots:\n        raise InvalidStream(\"This token has no relation to the actual Stream.\")\n\n    # 4) Now that everything's verified, grab new iterators for the coordinator's active Shards.\n    for shard in coordinator.active:\n        try:\n            if shard.iterator_type is None:\n                # Descendant of an unknown shard\n                shard.iterator_type = \"trim_horizon\"\n            # Move back to the token's specified position\n            shard.jump_to(iterator_type=shard.iterator_type, sequence_number=shard.sequence_number)\n        except RecordsExpired:\n            # This token shard's sequence_number is beyond the trim_horizon.\n            # The next closest record is at trim_horizon.\n            msg = \"SequenceNumber \\\"{}\\\" in shard \\\"{}\\\" beyond trim horizon: jumping to trim_horizon\"\n            logger.info(msg.format(shard.sequence_number, shard.shard_id))\n            shard.jump_to(iterator_type=\"trim_horizon\")", "response": "Move the Stream to the position described by the token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef advance_shards(self):\n        # Don't poll shards when there are pending records.\n        if self.buffer:\n            return\n\n        # 0) Collect new records from all active shards.\n        record_shard_pairs = []\n        for shard in self.active:\n            records = next(shard)\n            if records:\n                record_shard_pairs.extend((record, shard) for record in records)\n        self.buffer.push_all(record_shard_pairs)\n\n        self.migrate_closed_shards()", "response": "Poll active shards for records and insert them into the buffer. Returns immediately if the buffer is empty."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nkeep active shards with trim_horizon iterators alive by advancing their iterators.", "response": "def heartbeat(self):\n        \"\"\"Keep active shards with \"trim_horizon\", \"latest\" iterators alive by advancing their iterators.\"\"\"\n        for shard in self.active:\n            if shard.sequence_number is None:\n                records = next(shard)\n                # Success!  This shard now has an ``at_sequence`` iterator\n                if records:\n                    self.buffer.push_all((record, shard) for record in records)\n        self.migrate_closed_shards()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a JSON - serializable representation of the current Stream state.", "response": "def token(self):\n        \"\"\"JSON-serializable representation of the current Stream state.\n\n        Use :func:`Engine.stream(YourModel, token) <bloop.engine.Engine.stream>` to create an identical stream,\n        or :func:`stream.move_to(token) <bloop.stream.Stream.move_to>` to move an existing stream to this position.\n\n        :returns: Stream state as a json-friendly dict\n        :rtype: dict\n        \"\"\"\n        # 0) Trace roots and active shards\n        active_ids = []\n        shard_tokens = []\n        for root in self.roots:\n            for shard in root.walk_tree():\n                shard_tokens.append(shard.token)\n                # dedupe, stream_arn will be in the root token\n                shard_tokens[-1].pop(\"stream_arn\")\n        active_ids.extend((shard.shard_id for shard in self.active))\n\n        # 1) Inject closed shards\n        for shard in self.closed.keys():\n            active_ids.append(shard.shard_id)\n            shard_tokens.append(shard.token)\n            shard_tokens[-1].pop(\"stream_arn\")\n\n        return {\n            \"stream_arn\": self.stream_arn,\n            \"active\": active_ids,\n            \"shards\": shard_tokens\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a Shard from the Coordinator.", "response": "def remove_shard(self, shard, drop_buffered_records=False):\n        \"\"\"Remove a Shard from the Coordinator.  Drops all buffered records from the Shard.\n\n        If the Shard is active or a root, it is removed and any children promoted to those roles.\n\n        :param shard: The shard to remove\n         :type shard: :class:`~bloop.stream.shard.Shard`\n        :param bool drop_buffered_records:\n            Whether records from this shard should be removed.\n            Default is False.\n        \"\"\"\n        try:\n            self.roots.remove(shard)\n        except ValueError:\n            # Wasn't a root Shard\n            pass\n        else:\n            self.roots.extend(shard.children)\n\n        try:\n            self.active.remove(shard)\n        except ValueError:\n            # Wasn't an active Shard\n            pass\n        else:\n            self.active.extend(shard.children)\n\n        if drop_buffered_records:\n            # TODO can this be improved?  Gets expensive for high-volume streams with large buffers\n            heap = self.buffer.heap\n            # Clear buffered records from the shard.  Each record is (ordering, record, shard)\n            to_remove = [x for x in heap if x[2] is shard]\n            for x in to_remove:\n                heap.remove(x)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving the Broker to a specific endpoint or time or load state from a token.", "response": "def move_to(self, position):\n        \"\"\"Set the Coordinator to a specific endpoint or time, or load state from a token.\n\n        :param position: \"trim_horizon\", \"latest\", :class:`~datetime.datetime`, or a\n            :attr:`Coordinator.token <bloop.stream.coordinator.Coordinator.token>`\n        \"\"\"\n        if isinstance(position, collections.abc.Mapping):\n            move = _move_stream_token\n        elif hasattr(position, \"timestamp\") and callable(position.timestamp):\n            move = _move_stream_time\n        elif isinstance(position, str) and position.lower() in [\"latest\", \"trim_horizon\"]:\n            move = _move_stream_endpoint\n        else:\n            raise InvalidPosition(\"Don't know how to move to position {!r}\".format(position))\n        move(self, position)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef heap_item(clock, record, shard):\n    # Primary ordering is by event creation time.\n    # However, creation time is *approximate* and has whole-second resolution.\n    # This means two events in the same shard within one second can't be ordered.\n    ordering = record[\"meta\"][\"created_at\"]\n    # From testing, SequenceNumber isn't a guaranteed ordering either.  However,\n    # it is guaranteed to be unique within a shard.  This will be tie-breaker\n    # for multiple records within the same shard, within the same second.\n    second_ordering = int(record[\"meta\"][\"sequence_number\"])\n    # It's possible though unlikely, that sequence numbers will collide across\n    # multiple shards, within the same second.  The final tie-breaker is\n    # a monotonically increasing integer from the buffer.\n    total_ordering = (ordering, second_ordering, clock())\n    return total_ordering, record, shard", "response": "Create a tuple of ordering record and shard for use in a RecordBuffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push(self, record, shard):\n        heapq.heappush(self.heap, heap_item(self.clock, record, shard))", "response": "Push a new record into the buffer\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npush multiple record pairs at once with only one.", "response": "def push_all(self, record_shard_pairs):\n        \"\"\"Push multiple (record, shard) pairs at once, with only one :meth:`heapq.heapify` call to maintain order.\n\n        :param record_shard_pairs: list of ``(record, shard)`` tuples\n            (see :func:`~bloop.stream.buffer.RecordBuffer.push`).\n        \"\"\"\n        # Faster than inserting one at a time; the heap is sorted once after all inserts.\n        for record, shard in record_shard_pairs:\n            item = heap_item(self.clock, record, shard)\n            self.heap.append(item)\n        heapq.heapify(self.heap)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loaded_columns(obj: BaseModel):\n    for column in sorted(obj.Meta.columns, key=lambda c: c.name):\n        value = getattr(obj, column.name, missing)\n        if value is not missing:\n            yield column.name, value", "response": "Yields each tuple for all columns in an object that are not missing"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\n    context = context or {\"engine\": engine}\n    engine = engine or context.get(\"engine\", None)\n    if not engine:\n        raise ValueError(\"You must provide engine or a context with an engine.\")\n    if model is None and obj is None:\n        raise ValueError(\"You must provide a model or obj to unpack.\")\n    if model is not None and obj is not None:\n        raise ValueError(\"Only specify model or obj.\")\n    if model:\n        obj = model.Meta.init()\n\n    for column in expected:\n        value = attrs.get(column.dynamo_name, None)\n        value = engine._load(column.typedef, value, context=context, **kwargs)\n        setattr(obj, column.name, value)\n    return obj", "response": "Unpacks the given attributes from DynamoDB into an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setdefault(obj, field, default):\n    setattr(obj, field, getattr(obj, field, default))", "response": "Set an object s field to default if it doesn t have a value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\n    if not subclassof(model, BaseModel):\n        raise InvalidModel(f\"{model} is not a subclass of BaseModel\")\n    meta = model.Meta\n    if copy:\n        column = copyfn(column)\n    # TODO elif column.model is not None: logger.warning(f\"Trying to rebind column bound to {column.model}\")\n    column._name = name\n    safe_repr = unbound_repr(column)\n\n    # Guard against name, dynamo_name collisions; if force=True, unbind any matches\n    same_dynamo_name = (\n        util.index(meta.columns, \"dynamo_name\").get(column.dynamo_name) or\n        util.index(meta.indexes, \"dynamo_name\").get(column.dynamo_name)\n    )\n    same_name = (\n        meta.columns_by_name.get(column.name) or\n        util.index(meta.indexes, \"name\").get(column.name)\n    )\n\n    if column.hash_key and column.range_key:\n        raise InvalidModel(f\"Tried to bind {safe_repr} as both a hash and range key.\")\n\n    if force:\n        if same_name:\n            unbind(meta, name=column.name)\n        if same_dynamo_name:\n            unbind(meta, dynamo_name=column.dynamo_name)\n    else:\n        if same_name:\n            raise InvalidModel(\n                f\"The column {safe_repr} has the same name as an existing column \"\n                f\"or index {same_name}.  Did you mean to bind with force=True?\")\n        if same_dynamo_name:\n            raise InvalidModel(\n                f\"The column {safe_repr} has the same dynamo_name as an existing \"\n                f\"column or index {same_name}.  Did you mean to bind with force=True?\")\n        if column.hash_key and meta.hash_key:\n            raise InvalidModel(\n                f\"Tried to bind {safe_repr} but {meta.model} \"\n                f\"already has a different hash_key: {meta.hash_key}\")\n        if column.range_key and meta.range_key:\n            raise InvalidModel(\n                f\"Tried to bind {safe_repr} but {meta.model} \"\n                f\"already has a different range_key: {meta.range_key}\")\n\n    # success!\n    # --------------------------------\n    column.model = meta.model\n    meta.columns.add(column)\n    meta.columns_by_name[name] = column\n    setattr(meta.model, name, column)\n\n    if column.hash_key:\n        meta.hash_key = column\n        meta.keys.add(column)\n    if column.range_key:\n        meta.range_key = column\n        meta.keys.add(column)\n\n    try:\n        for index in meta.indexes:\n            refresh_index(meta, index)\n    except KeyError as e:\n        raise InvalidModel(\n            f\"Binding column {column} removed a required column for index {unbound_repr(index)}\") from e\n\n    if recursive:\n        for subclass in util.walk_subclasses(meta.model):\n            try:\n                bind_column(subclass, name, column, force=False, recursive=False, copy=True)\n            except InvalidModel:\n                pass\n\n    return column", "response": "Bind a column to the given model with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\n    if not subclassof(model, BaseModel):\n        raise InvalidModel(f\"{model} is not a subclass of BaseModel\")\n    meta = model.Meta\n    if copy:\n        index = copyfn(index)\n    # TODO elif index.model is not None: logger.warning(f\"Trying to rebind index bound to {index.model}\")\n    index._name = name\n    safe_repr = unbound_repr(index)\n\n    # Guard against name, dynamo_name collisions; if force=True, unbind any matches\n    same_dynamo_name = (\n        util.index(meta.columns, \"dynamo_name\").get(index.dynamo_name) or\n        util.index(meta.indexes, \"dynamo_name\").get(index.dynamo_name)\n    )\n    same_name = (\n        meta.columns_by_name.get(index.name) or\n        util.index(meta.indexes, \"name\").get(index.name)\n    )\n\n    if isinstance(index, LocalSecondaryIndex) and not meta.range_key:\n            raise InvalidModel(\"An LSI requires the Model to have a range key.\")\n\n    if force:\n        if same_name:\n            unbind(meta, name=index.name)\n        if same_dynamo_name:\n            unbind(meta, dynamo_name=index.dynamo_name)\n    else:\n        if same_name:\n            raise InvalidModel(\n                f\"The index {safe_repr} has the same name as an existing index \"\n                f\"or column {same_name}.  Did you mean to bind with force=True?\")\n        if same_dynamo_name:\n            raise InvalidModel(\n                f\"The index {safe_repr} has the same dynamo_name as an existing \"\n                f\"index or column {same_name}.  Did you mean to bind with force=True?\")\n\n    # success!\n    # --------------------------------\n    index.model = meta.model\n    meta.indexes.add(index)\n    setattr(meta.model, name, index)\n\n    if isinstance(index, LocalSecondaryIndex):\n        meta.lsis.add(index)\n    if isinstance(index, GlobalSecondaryIndex):\n        meta.gsis.add(index)\n\n    try:\n        refresh_index(meta, index)\n    except KeyError as e:\n        raise InvalidModel(\"Index expected a hash or range key that does not exist\") from e\n\n    if recursive:\n        for subclass in util.walk_subclasses(meta.model):\n            try:\n                bind_index(subclass, name, index, force=False, recursive=False, copy=True)\n            except InvalidModel:\n                pass\n\n    return index", "response": "Bind an index to a model with the given name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refresh_index(meta, index) -> None:\n    # All projections include model + index keys\n    projection_keys = set.union(meta.keys, index.keys)\n\n    proj = index.projection\n    mode = proj[\"mode\"]\n\n    if mode == \"keys\":\n        proj[\"included\"] = projection_keys\n    elif mode == \"all\":\n        proj[\"included\"] = meta.columns\n    elif mode == \"include\":  # pragma: no branch\n        if all(isinstance(p, str) for p in proj[\"included\"]):\n            proj[\"included\"] = set(meta.columns_by_name[n] for n in proj[\"included\"])\n        else:\n            proj[\"included\"] = set(proj[\"included\"])\n        proj[\"included\"].update(projection_keys)\n\n    if proj[\"strict\"]:\n        proj[\"available\"] = proj[\"included\"]\n    else:\n        proj[\"available\"] = meta.columns", "response": "Recalculate the projection hash_key and range_key for the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unbind(meta, name=None, dynamo_name=None) -> None:\n    if name is not None:\n        columns = {x for x in meta.columns if x.name == name}\n        indexes = {x for x in meta.indexes if x.name == name}\n    elif dynamo_name is not None:\n        columns = {x for x in meta.columns if x.dynamo_name == dynamo_name}\n        indexes = {x for x in meta.indexes if x.dynamo_name == dynamo_name}\n    else:\n        raise RuntimeError(\"Must provide name= or dynamo_name= to unbind from meta\")\n\n    # Nothing in bloop should allow name or dynamo_name\n    # collisions to exist, so this is either a bug or\n    # the user manually hacked up meta.\n    assert len(columns) <= 1\n    assert len(indexes) <= 1\n    assert not (columns and indexes)\n\n    if columns:\n        [column] = columns\n        meta.columns.remove(column)\n\n        # If these don't line up, there's likely a bug in bloop\n        # or the user manually hacked up columns_by_name\n        expect_same = meta.columns_by_name[column.name]\n        assert expect_same is column\n        meta.columns_by_name.pop(column.name)\n\n        if column in meta.keys:\n            meta.keys.remove(column)\n        if meta.hash_key is column:\n            meta.hash_key = None\n        if meta.range_key is column:\n            meta.range_key = None\n\n        delattr(meta.model, column.name)\n\n    if indexes:\n        [index] = indexes\n        meta.indexes.remove(index)\n        if index in meta.gsis:\n            meta.gsis.remove(index)\n        if index in meta.lsis:\n            meta.lsis.remove(index)\n\n        delattr(meta.model, index.name)", "response": "Unconditionally remove any columns or indexes bound to the given name or dynamo_name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load(cls, attrs, *, context, **kwargs):\n        return unpack_from_dynamodb(\n            model=cls,\n            attrs=attrs or {},\n            expected=cls.Meta.columns,\n            context=context, **kwargs)", "response": "Load a record from DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndumping the object into a dictionary.", "response": "def _dump(cls, obj, *, context, **kwargs):\n        \"\"\" obj -> dict \"\"\"\n        if obj is None:\n            return None\n        dump = context[\"engine\"]._dump\n        filtered = filter(\n            lambda item: item[1] is not None,\n            ((\n                column.dynamo_name,\n                dump(column.typedef, getattr(obj, column.name, None), context=context, **kwargs)\n            ) for column in cls.Meta.columns))\n        return dict(filtered) or None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid_superset(actual_projection, index):\n    projection_type = actual_projection[\"ProjectionType\"]\n    if projection_type == \"ALL\":\n        return True\n    meta = index.model.Meta\n    # all index types provide index keys and model keys\n    provides = set.union(meta.keys, index.keys)\n    if projection_type == \"KEYS_ONLY\":\n        pass\n    elif projection_type == \"INCLUDE\":  # pragma: no branch (unknown projections break loud)\n        by_dynamo_name = {column.dynamo_name: column for column in meta.columns}\n        provides.update(\n            by_dynamo_name[name]\n            for name in actual_projection[\"NonKeyAttributes\"]\n            if name in by_dynamo_name  # ignore columns the projection provides if the model doesn't care about them\n        )\n    else:\n        logger.info(f\"unexpected index ProjectionType '{projection_type}'\")\n        return False\n    expects = index.projection[\"included\"]\n    return provides.issuperset(expects)", "response": "Returns True if the actual index is a valid superset of the expected index"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves an object to DynamoDB.", "response": "def save_item(self, item):\n        \"\"\"Save an object to DynamoDB.\n\n        :param item: Unpacked into kwargs for :func:`boto3.DynamoDB.Client.update_item`.\n        :raises bloop.exceptions.ConstraintViolation: if the condition (or atomic) is not met.\n        \"\"\"\n        try:\n            self.dynamodb_client.update_item(**item)\n        except botocore.exceptions.ClientError as error:\n            handle_constraint_violation(error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_item(self, item):\n        try:\n            self.dynamodb_client.delete_item(**item)\n        except botocore.exceptions.ClientError as error:\n            handle_constraint_violation(error)", "response": "Delete an object in DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads any number of items in chunks handling continuation tokens.", "response": "def load_items(self, items):\n        \"\"\"Loads any number of items in chunks, handling continuation tokens.\n\n        :param items: Unpacked in chunks into \"RequestItems\" for :func:`boto3.DynamoDB.Client.batch_get_item`.\n        \"\"\"\n        loaded_items = {}\n        requests = collections.deque(create_batch_get_chunks(items))\n        while requests:\n            request = requests.pop()\n            try:\n                response = self.dynamodb_client.batch_get_item(RequestItems=request)\n            except botocore.exceptions.ClientError as error:\n                raise BloopException(\"Unexpected error while loading items.\") from error\n\n            # Accumulate results\n            for table_name, table_items in response.get(\"Responses\", {}).items():\n                loaded_items.setdefault(table_name, []).extend(table_items)\n\n            # Push additional request onto the deque.\n            # \"UnprocessedKeys\" is {} if this request is done\n            if response[\"UnprocessedKeys\"]:\n                requests.append(response[\"UnprocessedKeys\"])\n        return loaded_items"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninvoke query or scan by name.", "response": "def search_items(self, mode, request):\n        \"\"\"Invoke query/scan by name.\n\n        Response always includes \"Count\" and \"ScannedCount\"\n\n        :param str mode: \"query\" or \"scan\"\n        :param request: Unpacked into :func:`boto3.DynamoDB.Client.query` or :func:`boto3.DynamoDB.Client.scan`\n        \"\"\"\n        validate_search_mode(mode)\n        method = getattr(self.dynamodb_client, mode)\n        try:\n            response = method(**request)\n        except botocore.exceptions.ClientError as error:\n            raise BloopException(\"Unexpected error during {}.\".format(mode)) from error\n        standardize_query_response(response)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the model s table. Returns True if the table is being created False otherwise.", "response": "def create_table(self, table_name, model):\n        \"\"\"Create the model's table.  Returns True if the table is being created, False otherwise.\n\n        Does not wait for the table to create, and does not validate an existing table.\n        Will not raise \"ResourceInUseException\" if the table exists or is being created.\n\n        :param str table_name: The name of the table to create for the model.\n        :param model: The :class:`~bloop.models.BaseModel` to create the table for.\n        :return: True if the table is being created, False if the table exists\n        :rtype: bool\n        \"\"\"\n        table = create_table_request(table_name, model)\n        try:\n            self.dynamodb_client.create_table(**table)\n            is_creating = True\n        except botocore.exceptions.ClientError as error:\n            handle_table_exists(error, model)\n            is_creating = False\n        return is_creating"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describe_table(self, table_name):\n        if table_name in self._tables:\n            return self._tables[table_name]\n        status, description = None, {}\n        calls = 0\n        while status is not ready:\n            calls += 1\n            try:\n                description = self.dynamodb_client.describe_table(TableName=table_name)[\"Table\"]\n            except botocore.exceptions.ClientError as error:\n                raise BloopException(\"Unexpected error while describing table.\") from error\n            status = simple_table_status(description)\n        logger.debug(\"describe_table: table \\\"{}\\\" was in ACTIVE state after {} calls\".format(table_name, calls))\n        try:\n            ttl = self.dynamodb_client.describe_time_to_live(TableName=table_name)\n        except botocore.exceptions.ClientError as error:\n            raise BloopException(\"Unexpected error while describing ttl.\") from error\n        try:\n            backups = self.dynamodb_client.describe_continuous_backups(TableName=table_name)\n        except botocore.exceptions.ClientError as error:\n            raise BloopException(\"Unexpected error while describing continuous backups.\") from error\n\n        description[\"TimeToLiveDescription\"] = {\n            \"AttributeName\": _read_field(ttl, None, \"TimeToLiveDescription\", \"AttributeName\"),\n            \"TimeToLiveStatus\": _read_field(ttl, None, \"TimeToLiveDescription\", \"TimeToLiveStatus\"),\n        }\n        description[\"ContinuousBackupsDescription\"] = {\n            \"ContinuousBackupsStatus\": _read_field(\n                backups, None, \"ContinuousBackupsDescription\", \"ContinuousBackupsStatus\"),\n        }\n\n        table = self._tables[table_name] = sanitize_table_description(description)\n        return table", "response": "Polls until the table is ready, then returns the first result when the table was ready.\n\n        The returned dict is standardized to ensure all fields are present, even when empty or across different\n        DynamoDB API versions.\n        TTL information is also inserted.\n\n        :param table_name: The name of the table to describe\n        :return: The (sanitized) result of DescribeTable[\"Table\"]\n        :rtype: dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the description of a table against the model.", "response": "def validate_table(self, table_name, model):\n        \"\"\"Polls until a creating table is ready, then verifies the description against the model's requirements.\n\n        The model may have a subset of all GSIs and LSIs on the table, but the key structure must be exactly\n        the same.  The table must have a stream if the model expects one, but not the other way around.  When read or\n        write units are not specified for the model or any GSI, the existing values will always pass validation.\n\n        :param str table_name: The name of the table to validate the model against.\n        :param model: The :class:`~bloop.models.BaseModel` to validate the table of.\n        :raises bloop.exceptions.TableMismatch: When the table does not meet the constraints of the model.\n        \"\"\"\n        actual = self.describe_table(table_name)\n        if not compare_tables(model, actual):\n            raise TableMismatch(\"The expected and actual tables for {!r} do not match.\".format(model.__name__))\n\n        # Fill in values that Meta doesn't know ahead of time (such as arns).\n        # These won't be populated unless Meta explicitly cares about the value\n        if model.Meta.stream:\n            stream_arn = model.Meta.stream[\"arn\"] = actual[\"LatestStreamArn\"]\n            logger.debug(f\"Set {model.__name__}.Meta.stream['arn'] to '{stream_arn}' from DescribeTable response\")\n        if model.Meta.ttl:\n            ttl_enabled = actual[\"TimeToLiveDescription\"][\"TimeToLiveStatus\"].lower() == \"enabled\"\n            model.Meta.ttl[\"enabled\"] = ttl_enabled\n            logger.debug(f\"Set {model.__name__}.Meta.ttl['enabled'] to '{ttl_enabled}' from DescribeTable response\")\n\n        # Fill in meta values that the table didn't care about (eg. billing=None)\n        if model.Meta.encryption is None:\n            sse_enabled = actual[\"SSEDescription\"][\"Status\"].lower() == \"enabled\"\n            model.Meta.encryption = {\"enabled\": sse_enabled}\n            logger.debug(\n                f\"Set {model.__name__}.Meta.encryption['enabled'] to '{sse_enabled}' from DescribeTable response\")\n        if model.Meta.backups is None:\n            backups = actual[\"ContinuousBackupsDescription\"][\"ContinuousBackupsStatus\"] == \"ENABLED\"\n            model.Meta.backups = {\"enabled\": backups}\n            logger.debug(f\"Set {model.__name__}.Meta.backups['enabled'] to '{backups}' from DescribeTable response\")\n        if model.Meta.billing is None:\n            billing_mode = {\n                \"PAY_PER_REQUEST\": \"on_demand\",\n                \"PROVISIONED\": \"provisioned\"\n            }[actual[\"BillingModeSummary\"][\"BillingMode\"]]\n            model.Meta.billing = {\"mode\": billing_mode}\n            logger.debug(f\"Set {model.__name__}.Meta.billing['mode'] to '{billing_mode}' from DescribeTable response\")\n        if model.Meta.read_units is None:\n            read_units = model.Meta.read_units = actual[\"ProvisionedThroughput\"][\"ReadCapacityUnits\"]\n            logger.debug(\n                f\"Set {model.__name__}.Meta.read_units to {read_units} from DescribeTable response\")\n        if model.Meta.write_units is None:\n            write_units = model.Meta.write_units = actual[\"ProvisionedThroughput\"][\"WriteCapacityUnits\"]\n            logger.debug(\n                f\"Set {model.__name__}.Meta.write_units to {write_units} from DescribeTable response\")\n\n        # Replace any ``None`` values for read_units, write_units in GSIs with their actual values\n        gsis = {index[\"IndexName\"]: index for index in actual[\"GlobalSecondaryIndexes\"]}\n        for index in model.Meta.gsis:\n            read_units = gsis[index.dynamo_name][\"ProvisionedThroughput\"][\"ReadCapacityUnits\"]\n            write_units = gsis[index.dynamo_name][\"ProvisionedThroughput\"][\"WriteCapacityUnits\"]\n            if index.read_units is None:\n                index.read_units = read_units\n                logger.debug(\n                    f\"Set {model.__name__}.{index.name}.read_units to {read_units} from DescribeTable response\")\n            if index.write_units is None:\n                index.write_units = write_units\n                logger.debug(\n                    f\"Set {model.__name__}.{index.name}.write_units to {write_units} from DescribeTable response\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nenabling TTL setting on the table according to model. Meta. ttl.", "response": "def enable_ttl(self, table_name, model):\n        \"\"\"Calls UpdateTimeToLive on the table according to model.Meta[\"ttl\"]\n\n        :param table_name: The name of the table to enable the TTL setting on\n        :param model: The model to get TTL settings from\n        \"\"\"\n        self._tables.pop(table_name, None)\n        ttl_name = model.Meta.ttl[\"column\"].dynamo_name\n        request = {\n            \"TableName\": table_name,\n            \"TimeToLiveSpecification\": {\"AttributeName\": ttl_name, \"Enabled\": True}\n        }\n        try:\n            self.dynamodb_client.update_time_to_live(**request)\n        except botocore.exceptions.ClientError as error:\n            raise BloopException(\"Unexpected error while setting TTL.\") from error"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enable_backups(self, table_name, model):\n        self._tables.pop(table_name, None)\n        request = {\n            \"TableName\": table_name,\n            \"PointInTimeRecoverySpecification\": {\"PointInTimeRecoveryEnabled\": True}\n        }\n        try:\n            self.dynamodb_client.update_continuous_backups(**request)\n        except botocore.exceptions.ClientError as error:\n            raise BloopException(\"Unexpected error while setting Continuous Backups.\") from error", "response": "Enables Continuous Backups on the table according to model. Meta [ continuous_backups ]."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap boto3. DynamoDBStreams. Client. describe_stream and returns the stream description.", "response": "def describe_stream(self, stream_arn, first_shard=None):\n        \"\"\"Wraps :func:`boto3.DynamoDBStreams.Client.describe_stream`, handling continuation tokens.\n\n        :param str stream_arn: Stream arn, usually from the model's ``Meta.stream[\"arn\"]``.\n        :param str first_shard: *(Optional)* If provided, only shards after this shard id will be returned.\n        :return: All shards in the stream, or a subset if ``first_shard`` is provided.\n        :rtype: dict\n        \"\"\"\n        description = {\"Shards\": []}\n\n        request = {\"StreamArn\": stream_arn, \"ExclusiveStartShardId\": first_shard}\n        # boto3 isn't down with literal Nones.\n        if first_shard is None:\n            request.pop(\"ExclusiveStartShardId\")\n\n        while request.get(\"ExclusiveStartShardId\") is not missing:\n            try:\n                response = self.stream_client.describe_stream(**request)[\"StreamDescription\"]\n            except botocore.exceptions.ClientError as error:\n                if error.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    raise InvalidStream(f\"The stream arn {stream_arn!r} does not exist.\") from error\n                raise BloopException(\"Unexpected error while describing stream.\") from error\n            # Docs aren't clear if the terminal value is null, or won't exist.\n            # Since we don't terminate the loop on None, the \"or missing\" here\n            # will ensure we stop on a falsey value.\n            request[\"ExclusiveStartShardId\"] = response.pop(\"LastEvaluatedShardId\", None) or missing\n            description[\"Shards\"].extend(response.pop(\"Shards\", []))\n            description.update(response)\n        return description"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping boto3. DynamoDBStreams. Client. get_shard_iterator to validate the input arguments.", "response": "def get_shard_iterator(self, *, stream_arn, shard_id, iterator_type, sequence_number=None):\n        \"\"\"Wraps :func:`boto3.DynamoDBStreams.Client.get_shard_iterator`.\n\n        :param str stream_arn: Stream arn.  Usually :data:`Shard.stream_arn <bloop.stream.shard.Shard.stream_arn>`.\n        :param str shard_id: Shard identifier.  Usually :data:`Shard.shard_id <bloop.stream.shard.Shard.shard_id>`.\n        :param str iterator_type: \"sequence_at\", \"sequence_after\", \"trim_horizon\", or \"latest\"\n        :param sequence_number:\n        :return: Iterator id, valid for 15 minutes.\n        :rtype: str\n        :raises bloop.exceptions.RecordsExpired: Tried to get an iterator beyond the Trim Horizon.\n        \"\"\"\n        real_iterator_type = validate_stream_iterator_type(iterator_type)\n        request = {\n            \"StreamArn\": stream_arn,\n            \"ShardId\": shard_id,\n            \"ShardIteratorType\": real_iterator_type,\n            \"SequenceNumber\": sequence_number\n        }\n        # boto3 isn't down with literal Nones.\n        if sequence_number is None:\n            request.pop(\"SequenceNumber\")\n        try:\n            return self.stream_client.get_shard_iterator(**request)[\"ShardIterator\"]\n        except botocore.exceptions.ClientError as error:\n            if error.response[\"Error\"][\"Code\"] == \"TrimmedDataAccessException\":\n                raise RecordsExpired from error\n            raise BloopException(\"Unexpected error while creating shard iterator\") from error"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps boto3. DynamoDBStreams. Client. get_records method to provide a list of records.", "response": "def get_stream_records(self, iterator_id):\n        \"\"\"Wraps :func:`boto3.DynamoDBStreams.Client.get_records`.\n\n        :param iterator_id: Iterator id.  Usually :data:`Shard.iterator_id <bloop.stream.shard.Shard.iterator_id>`.\n        :return: Dict with \"Records\" list (may be empty) and \"NextShardIterator\" str (may not exist).\n        :rtype: dict\n        :raises bloop.exceptions.RecordsExpired: The iterator moved beyond the Trim Horizon since it was created.\n        :raises bloop.exceptions.ShardIteratorExpired: The iterator was created more than 15 minutes ago.\n        \"\"\"\n        try:\n            return self.stream_client.get_records(ShardIterator=iterator_id)\n        except botocore.exceptions.ClientError as error:\n            if error.response[\"Error\"][\"Code\"] == \"TrimmedDataAccessException\":\n                raise RecordsExpired from error\n            elif error.response[\"Error\"][\"Code\"] == \"ExpiredIteratorException\":\n                raise ShardIteratorExpired from error\n            raise BloopException(\"Unexpected error while getting records.\") from error"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transaction_read(self, items):\n        try:\n            return self.dynamodb_client.transact_get_items(TransactItems=items)\n        except botocore.exceptions.ClientError as error:\n            if error.response[\"Error\"][\"Code\"] == \"TransactionCanceledException\":\n                raise TransactionCanceled from error\n            raise BloopException(\"Unexpected error during transaction read.\") from error", "response": "Reads records from DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps :func:`boto3.DynamoDB.Client.db.transact_write_items`. :param items: Unpacked into \"TransactionItems\" for :func:`boto3.DynamoDB.Client.transact_write_items` :param client_request_token: Idempotency token valid for 10 minutes from first use. Unpacked into \"ClientRequestToken\" :raises bloop.exceptions.TransactionCanceled: if the transaction was canceled.", "response": "def transaction_write(self, items, client_request_token):\n        \"\"\"\n        Wraps :func:`boto3.DynamoDB.Client.db.transact_write_items`.\n\n        :param items: Unpacked into \"TransactionItems\" for :func:`boto3.DynamoDB.Client.transact_write_items`\n        :param client_request_token: Idempotency token valid for 10 minutes from first use.\n            Unpacked into \"ClientRequestToken\"\n        :raises bloop.exceptions.TransactionCanceled: if the transaction was canceled.\n        \"\"\"\n        try:\n            self.dynamodb_client.transact_write_items(\n                TransactItems=items,\n                ClientRequestToken=client_request_token\n            )\n        except botocore.exceptions.ClientError as error:\n            if error.response[\"Error\"][\"Code\"] == \"TransactionCanceledException\":\n                raise TransactionCanceled from error\n            raise BloopException(\"Unexpected error during transaction write.\") from error"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_hash_key(query_on, key):\n    return (\n        isinstance(key, BaseCondition) and\n        (key.operation == \"==\") and\n        (key.column is query_on.hash_key)\n    )", "response": "Only allows == against query_on. hash_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_range_key(query_on, key):\n    return (\n        isinstance(key, BaseCondition) and\n        key.operation in (\"begins_with\", \"between\", \"<\", \">\", \"<=\", \">=\", \"==\") and\n        key.column is query_on.range_key\n    )", "response": "Checks if the given key is a valid range key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare(self):\n        p = PreparedSearch()\n        p.prepare(\n            engine=self.engine,\n            mode=self.mode,\n            model=self.model,\n            index=self.index,\n            key=self.key,\n            filter=self.filter,\n            projection=self.projection,\n            consistent=self.consistent,\n            forward=self.forward,\n            parallel=self.parallel\n        )\n        return p", "response": "Constructs a : class : ~bloop. search. PreparedSearch object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates the search parameters and builds the base request dict for each Query/Scan call.", "response": "def prepare(\n            self, engine=None, mode=None, model=None, index=None, key=None,\n            filter=None, projection=None, consistent=None, forward=None, parallel=None):\n        \"\"\"Validates the search parameters and builds the base request dict for each Query/Scan call.\"\"\"\n\n        self.prepare_iterator_cls(engine, mode)\n        self.prepare_model(model, index, consistent)\n        self.prepare_key(key)\n        self.prepare_projection(projection)\n        self.prepare_filter(filter)\n        self.prepare_constraints(forward, parallel)\n\n        self.prepare_request()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count(self):\n        if self.request[\"Select\"] == \"COUNT\":\n            while not self.exhausted:\n                next(self, None)\n        return self._count", "response": "Number of items that have been loaded from DynamoDB so far including buffered items."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnumbers of items that DynamoDB evaluated before any filter was applied.", "response": "def scanned(self):\n        \"\"\"Number of items that DynamoDB evaluated, before any filter was applied.\"\"\"\n        if self.request[\"Select\"] == \"COUNT\":\n            while not self.exhausted:\n                next(self, None)\n        return self._scanned"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first result.", "response": "def first(self):\n        \"\"\"Return the first result.  If there are no results, raises :exc:`~bloop.exceptions.ConstraintViolation`.\n\n        :return: The first result.\n        :raises bloop.exceptions.ConstraintViolation: No results.\n        \"\"\"\n        self.reset()\n        value = next(self, None)\n        if value is None:\n            raise ConstraintViolation(\"{} did not find any results.\".format(self.mode.capitalize()))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the unique result.", "response": "def one(self):\n        \"\"\"Return the unique result.  If there is not exactly one result,\n        raises :exc:`~bloop.exceptions.ConstraintViolation`.\n\n        :return: The unique result.\n        :raises bloop.exceptions.ConstraintViolation: Not exactly one result.\n        \"\"\"\n        first = self.first()\n        second = next(self, None)\n        if second is not None:\n            raise ConstraintViolation(\"{} found more than one result.\".format(self.mode.capitalize()))\n        return first"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the internal state of the object to the initial state.", "response": "def reset(self):\n        \"\"\"Reset to the initial state, clearing the buffer and zeroing count and scanned.\"\"\"\n        self.buffer.clear()\n        self._count = 0\n        self._scanned = 0\n        self._exhausted = False\n        self.request.pop(\"ExclusiveStartKey\", None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef by_alias(cls, name: str) -> \"TxType\":\n        return {\n            \"get\": TxType.Get,\n            \"check\": TxType.Check,\n            \"delete\": TxType.Delete,\n            \"save\": TxType.Update,\n        }[name]", "response": "get a type by the common bloop operation name"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new PreparedTransaction that can be committed.", "response": "def prepare(self):\n        \"\"\"\n        Create a new PreparedTransaction that can be committed.\n\n        This is called automatically when exiting the transaction as a context:\n\n        .. code-block:: python\n\n            >>> engine = Engine()\n            >>> tx = WriteTransaction(engine)\n            >>> prepared = tx.prepare()\n            >>> prepared.commit()\n\n            # automatically calls commit when exiting\n            >>> with WriteTransaction(engine) as tx:\n            ...     # modify the transaction here\n            ...     pass\n            >>> # tx commits here\n\n        :return:\n        \"\"\"\n        tx = PreparedTransaction()\n        tx.prepare(\n            engine=self.engine,\n            mode=self.mode,\n            items=self._items,\n        )\n        return tx"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare(self, engine, mode, items) -> None:\n        self.tx_id = str(uuid.uuid4()).replace(\"-\", \"\")\n        self.engine = engine\n        self.mode = mode\n        self.items = items\n        self._prepare_request()", "response": "Prepare the cache for the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef commit(self) -> None:\n        now = datetime.now(timezone.utc)\n        if self.first_commit_at is None:\n            self.first_commit_at = now\n\n        if self.mode == \"r\":\n            response = self.engine.session.transaction_read(self._request)\n        elif self.mode == \"w\":\n            if now - self.first_commit_at > MAX_TOKEN_LIFETIME:\n                raise TransactionTokenExpired\n            response = self.engine.session.transaction_write(self._request, self.tx_id)\n        else:\n            raise ValueError(f\"unrecognized mode {self.mode}\")\n\n        self._handle_response(response)", "response": "Commit the current transaction with a fixed transaction id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, *objs) -> \"ReadTransaction\":\n        self._extend([TxItem.new(\"get\", obj) for obj in objs])\n        return self", "response": "Add one or more objects to be loaded in this transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check(self, obj, condition) -> \"WriteTransaction\":\n        self._extend([TxItem.new(\"check\", obj, condition)])\n        return self", "response": "Add a condition to the transaction which must be met for the object to be committed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, *objs, condition=None, atomic=False) -> \"WriteTransaction\":\n        self._extend([TxItem.new(\"save\", obj, condition, atomic) for obj in objs])\n        return self", "response": "Adds one or more objects to be saved in this transaction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode(self, cube_dimensions):\n        return np.asarray([getattr(cube_dimensions[d], s)\n            for d in self._dimensions\n            for s in self._schema],\n                dtype=np.int32)", "response": "Encodes the set of keys in the specified cube dimensions into a numpy array of integers which encode\n            the supplied cube dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode a descriptor into a list of dictionaries for each dimension in this transcoder.", "response": "def decode(self, descriptor):\n        \"\"\" Produce a list of dictionaries for each dimension in this transcoder \"\"\"\n        i = iter(descriptor)\n        n = len(self._schema)\n\n        # Add the name key to our schema\n        schema = self._schema + ('name',)\n        # For each dimensions, generator takes n items off iterator\n        # wrapping the descriptor, making a tuple with the dimension\n        # name appended\n        tuple_gen = (tuple(itertools.islice(i, n)) + (d, )\n            for d in self._dimensions)\n\n        # Generate dictionary by mapping schema keys to generated tuples\n        return [{ k: v for k, v in zip(schema, t) } for t in tuple_gen]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads and store a cub archive from a URL and store it in a file.", "response": "def dl_cub(cub_url, cub_archive_name):\n    \"\"\" Download cub archive from cub_url and store it in cub_archive_name \"\"\"\n    with open(cub_archive_name, 'wb') as f:\n        remote_file = urllib2.urlopen(cub_url)\n        meta = remote_file.info()\n\n        # The server may provide us with the size of the file.\n        cl_header = meta.getheaders(\"Content-Length\")\n        remote_file_size = int(cl_header[0]) if len(cl_header) > 0 else None\n\n        # Initialise variables\n        local_file_size = 0\n        block_size = 128*1024\n\n        # Do the download\n        while True:\n            data = remote_file.read(block_size)\n\n            if not data:\n                break\n\n            f.write(data)\n            local_file_size += len(data)\n\n        if (remote_file_size is not None and\n                not local_file_size == remote_file_size):\n            log.warn(\"Local file size '{}' \"\n                \"does not match remote '{}'\".format(\n                    local_file_size, remote_file_size))\n\n        remote_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the SHA1 hash of a file", "response": "def sha_hash_file(filename):\n    \"\"\" Compute the SHA1 hash of filename \"\"\"\n    hash_sha = hashlib.sha1()\n\n    with open(filename, 'rb') as f:\n        for chunk in iter(lambda: f.read(1024*1024), b\"\"):\n            hash_sha.update(chunk)\n\n    return hash_sha.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install_cub(mb_inc_path):\n    cub_url = 'https://github.com/NVlabs/cub/archive/1.6.4.zip'\n    cub_sha_hash = '0d5659200132c2576be0b3959383fa756de6105d'\n    cub_version_str = 'Current release: v1.6.4 (12/06/2016)'\n    cub_zip_file = 'cub.zip'\n    cub_zip_dir = 'cub-1.6.4'\n    cub_unzipped_path = os.path.join(mb_inc_path, cub_zip_dir)\n    cub_new_unzipped_path = os.path.join(mb_inc_path, 'cub')\n    cub_header = os.path.join(cub_new_unzipped_path, 'cub', 'cub.cuh')\n    cub_readme = os.path.join(cub_new_unzipped_path, 'README.md' )\n\n    # Check for a reasonably valid install\n    cub_installed, _ = is_cub_installed(cub_readme, cub_header, cub_version_str)\n    if cub_installed:\n        log.info(\"NVIDIA cub installation found \"\n            \"at '{}'\".format(cub_new_unzipped_path))\n        return\n\n    log.info(\"No NVIDIA cub installation found\")\n\n    # Do we already have a valid cub zip file\n    have_valid_cub_file = (os.path.exists(cub_zip_file) and\n        os.path.isfile(cub_zip_file) and\n        sha_hash_file(cub_zip_file) == cub_sha_hash)\n\n    if have_valid_cub_file:\n        log.info(\"Valid NVIDIA cub archive found '{}'\".format(cub_zip_file))\n    # Download if we don't have a valid file\n    else:\n        log.info(\"Downloading cub archive '{}'\".format(cub_url))\n        dl_cub(cub_url, cub_zip_file)\n        cub_file_sha_hash = sha_hash_file(cub_zip_file)\n\n        # Compare against our supplied hash\n        if cub_sha_hash != cub_file_sha_hash:\n            msg = ('Hash of file %s downloaded from %s '\n                'is %s and does not match the expected '\n                'hash of %s. Please manually download '\n                'as per the README.md instructions.') % (\n                    cub_zip_file, cub_url,\n                    cub_file_sha_hash, cub_sha_hash)\n\n            raise InstallCubException(msg)\n\n    # Unzip into montblanc/include/cub\n    with zipfile.ZipFile(cub_zip_file, 'r') as zip_file:\n        # Remove any existing installs\n        shutil.rmtree(cub_unzipped_path, ignore_errors=True)\n        shutil.rmtree(cub_new_unzipped_path, ignore_errors=True)\n\n        # Unzip\n        zip_file.extractall(mb_inc_path)\n\n        # Rename. cub_unzipped_path is mb_inc_path/cub_zip_dir\n        shutil.move(cub_unzipped_path, cub_new_unzipped_path)\n\n        log.info(\"NVIDIA cub archive unzipped into '{}'\".format(\n            cub_new_unzipped_path))\n\n\n    there, reason = is_cub_installed(cub_readme, cub_header, cub_version_str)\n\n    if not there:\n        raise InstallCubException(reason)", "response": "Download and installs cub into mb_inc_path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cuda_architecture_flags(device_info):\n    # Figure out the necessary device architectures\n    if len(device_info['devices']) == 0:\n        archs = ['--gpu-architecture=sm_30']\n        log.info(\"No CUDA devices found, defaulting to architecture '{}'\".format(archs[0]))\n    else:\n        archs = set()\n\n        for device in device_info['devices']:\n            arch_str = '--gpu-architecture=sm_{}{}'.format(device['major'], device['minor'])\n            log.info(\"Using '{}' for '{}'\".format(arch_str, device['name']))\n            archs.add(arch_str)\n\n    return list(archs)", "response": "Return a list of architecture flags for CUDA devices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a tensorflow extension that builds the custom tensorflow ops", "response": "def create_tensorflow_extension(nvcc_settings, device_info):\n    \"\"\" Create an extension that builds the custom tensorflow ops \"\"\"\n    import tensorflow as tf\n    import glob\n\n    use_cuda = (bool(nvcc_settings['cuda_available'])\n        and tf.test.is_built_with_cuda())\n\n    # Source and includes\n    source_path = os.path.join('montblanc', 'impl', 'rime', 'tensorflow', 'rime_ops')\n    sources = glob.glob(os.path.join(source_path, '*.cpp'))\n\n    # Header dependencies\n    depends = glob.glob(os.path.join(source_path, '*.h'))\n\n    # Include directories\n    tf_inc = tf.sysconfig.get_include()\n    include_dirs = [os.path.join('montblanc', 'include'), source_path]\n    include_dirs += [tf_inc, os.path.join(tf_inc, \"external\", \"nsync\", \"public\")]\n\n    # Libraries\n    library_dirs = [tf.sysconfig.get_lib()]\n    libraries = ['tensorflow_framework']\n    extra_link_args = ['-fPIC', '-fopenmp', '-g0']\n\n    # Macros\n    define_macros = [\n        ('_MWAITXINTRIN_H_INCLUDED', None),\n        ('_FORCE_INLINES', None),\n        ('_GLIBCXX_USE_CXX11_ABI', 0)]\n\n    # Common flags\n    flags = ['-std=c++11']\n\n    gcc_flags = flags + ['-g0', '-fPIC', '-fopenmp', '-O2']\n    gcc_flags += ['-march=native', '-mtune=native']\n    nvcc_flags = flags + []\n\n    # Add cuda specific build information, if it is available\n    if use_cuda:\n        # CUDA source files\n        sources += glob.glob(os.path.join(source_path, '*.cu'))\n        # CUDA include directories\n        include_dirs += nvcc_settings['include_dirs']\n        # CUDA header dependencies\n        depends += glob.glob(os.path.join(source_path, '*.cuh'))\n        # CUDA libraries\n        library_dirs += nvcc_settings['library_dirs']\n        libraries += nvcc_settings['libraries']\n        # Flags\n        nvcc_flags += ['-x', 'cu']\n        nvcc_flags += ['--compiler-options', '\"-fPIC\"']\n        # --gpu-architecture=sm_xy flags\n        nvcc_flags += cuda_architecture_flags(device_info)\n        # Ideally this would be set in define_macros, but\n        # this must be set differently for gcc and nvcc\n        nvcc_flags += ['-DGOOGLE_CUDA=%d' % int(use_cuda)]\n\n    return Extension(tensorflow_extension_name,\n        sources=sources,\n        include_dirs=include_dirs,\n        depends=depends,\n        library_dirs=library_dirs,\n        libraries=libraries,\n        define_macros=define_macros,\n        # this syntax is specific to this build system\n        # we're only going to use certain compiler args with nvcc and not with gcc\n        # the implementation of this trick is in customize_compiler_for_nvcc() above\n        extra_compile_args={ 'gcc': gcc_flags, 'nvcc': nvcc_flags },\n        extra_link_args=extra_link_args,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninforming montblanc about dimension sizes", "response": "def updated_dimensions(self):\n        \"\"\" Inform montblanc about dimension sizes \"\"\"\n        return [(\"ntime\", args.ntime),      # Timesteps\n                (\"nchan\", args.nchan),      # Channels\n                (\"na\", args.na),            # Antenna\n                (\"npsrc\", len(lm_coords))]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef point_lm(self, context):\n\n        # Shape (npsrc, 2)\n        (ls, us), _ = context.array_extents(context.name)\n        return np.asarray(lm_coords[ls:us], dtype=context.dtype)", "response": "Supply point source lm coordinates to montblanc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsupply point source stokes parameters to montblanc", "response": "def point_stokes(self, context):\n        \"\"\" Supply point source stokes parameters to montblanc \"\"\"\n\n        # Shape (npsrc, ntime, 4)\n        (ls, us), (lt, ut), (l, u) = context.array_extents(context.name)\n\n        data = np.empty(context.shape, context.dtype)\n        data[ls:us,:,l:u] = np.asarray(lm_stokes)[ls:us,None,:]\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uvw(self, context):\n\n        # Shape (ntime, na, 3)\n        (lt, ut), (la, ua), (l, u) = context.array_extents(context.name)\n\n        # Create empty UVW coordinates\n        data = np.empty(context.shape, context.dtype)\n        data[:,:,0] = np.arange(la+1, ua+1)    # U = antenna index\n        data[:,:,1] = 0                        # V = 0\n        data[:,:,2] = 0                        # W = 0\n\n        return data", "response": "Supply antenna coordinates to montblanc"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the number of baselines for the given number of antenna.", "response": "def nr_of_baselines(na, auto_correlations=False):\n    \"\"\"\n    Compute the number of baselines for the\n    given number of antenna. Can specify whether\n    auto-correlations should be taken into\n    account\n    \"\"\"\n    m = (na-1) if auto_correlations is False else (na+1)\n    return (na*m)//2"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the number of antenna for the given number of baselines. Can specify auto - correlations to be taken into account.", "response": "def nr_of_antenna(nbl, auto_correlations=False):\n    \"\"\"\n    Compute the number of antenna for the\n    given number of baselines. Can specify whether\n    auto-correlations should be taken into\n    account\n    \"\"\"\n    t = 1 if auto_correlations is False else -1\n    return int(t + math.sqrt(1 + 8*nbl)) // 2"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nestimate the memory in bytes required for an array of the supplied shape and dtype", "response": "def array_bytes(shape, dtype):\n    \"\"\" Estimates the memory in bytes required for an array of the supplied shape and dtype \"\"\"\n    return np.product(shape)*np.dtype(dtype).itemsize"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a random array of the same shape and type as the supplied array argument or the supplied shape and dtype as the supplied array argument.", "response": "def random_like(ary=None, shape=None, dtype=None):\n    \"\"\"\n    Returns a random array of the same shape and type as the\n    supplied array argument, or the supplied shape and dtype\n    \"\"\"\n    if ary is not None:\n        shape, dtype = ary.shape, ary.dtype\n    elif shape is None or dtype is None:\n        raise ValueError((\n            'random_like(ary, shape, dtype) must be supplied '\n            'with either an array argument, or the shape and dtype '\n            'of the desired random array.'))\n\n    if np.issubdtype(dtype, np.complexfloating):\n        return (np.random.random(size=shape) + \\\n            np.random.random(size=shape)*1j).astype(dtype)\n    else:\n        return np.random.random(size=shape).astype(dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flatten(nested):\n    flat_return = list()\n\n    def __inner_flat(nested,flat):\n        for i in nested:\n            __inner_flat(i, flat) if isinstance(i, list) else flat.append(i)\n        return flat\n\n    __inner_flat(nested,flat_return)\n\n    return flat_return", "response": "Return a flat version of the nested argument"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dict_array_bytes(ary, template):\n    shape = shape_from_str_tuple(ary['shape'], template)\n    dtype = dtype_from_str(ary['dtype'], template)\n\n    return array_bytes(shape, dtype)", "response": "Returns the number of bytes required by an array containing the specified shape and dtype."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the number of bytes required by a dictionary of arrays.", "response": "def dict_array_bytes_required(arrays, template):\n    \"\"\"\n    Return the number of bytes required by\n    a dictionary of arrays.\n\n    Arguments\n    ---------------\n    arrays : list\n        A list of dictionaries defining the arrays\n    template : dict\n        A dictionary of key-values, used to replace any\n        string values in the arrays with concrete integral\n        values\n\n    Returns\n    -----------\n    The number of bytes required to represent\n    all the arrays.\n    \"\"\"\n    return np.sum([dict_array_bytes(ary, template)\n        for ary in arrays])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef viable_dim_config(bytes_available, arrays, template,\n        dim_ord, nsolvers=1):\n    \"\"\"\n    Returns the number of timesteps possible, given the registered arrays\n    and a memory budget defined by bytes_available\n\n    Arguments\n    ----------------\n    bytes_available : int\n        The memory budget, or available number of bytes\n        for solving the problem.\n    arrays : list\n        List of dictionaries describing the arrays\n    template : dict\n        Dictionary containing key-values that will be used\n        to replace any string representations of dimensions\n        and types. slvr.template_dict() will return something\n        suitable.\n    dim_ord : list\n        list of dimension string names that the problem should be\n        subdivided by. e.g. ['ntime', 'nbl', 'nchan'].\n        Multple dimensions can be reduced simultaneously using\n        the following syntax 'nbl&na'. This is mostly useful for\n        the baseline-antenna equivalence.\n    nsolvers : int\n        Number of solvers to budget for. Defaults to one.\n\n    Returns\n    ----------\n    A tuple (boolean, dict). The boolean is True if the problem\n    can fit within the supplied budget, False otherwise.\n    THe dictionary contains the reduced dimensions as key and\n    the reduced size as value.\n    e.g. (True, { 'time' : 1, 'nbl' : 1 })\n\n    For a dim_ord = ['ntime', 'nbl', 'nchan'], this method will try and fit\n    a ntime x nbl x nchan problem into the available number of bytes.\n    If this is not possible, it will first set ntime=1, and then try fit an\n    1 x nbl x nchan problem into the budget, then a 1 x 1 x nchan\n    problem.\n\n    One can specify reductions for specific dimensions.\n    For e.g. ['ntime=20', 'nbl=1&na=2', 'nchan=50%']\n\n    will reduce ntime to 20, but no lower. nbl=1&na=2 sets\n    both nbl and na to 1 and 2 in the same operation respectively.\n    nchan=50\\% will continuously halve the nchan dimension\n    until it reaches a value of 1.\n    \"\"\"\n\n    if not isinstance(dim_ord, list):\n        raise TypeError('dim_ord should be a list')\n\n    # Don't accept non-negative memory budgets\n    if bytes_available < 0:\n        bytes_available = 0\n\n    modified_dims = {}\n    T = template.copy()\n\n    bytes_used = dict_array_bytes_required(arrays, T)*nsolvers\n\n    # While more bytes are used than are available, set\n    # dimensions to one in the order specified by the\n    # dim_ord argument.\n    while bytes_used > bytes_available:\n        try:\n            dims = dim_ord.pop(0)\n            montblanc.log.debug('Applying reduction {s}. '\n                'Bytes available: {a} used: {u}'.format(\n                    s=dims,\n                    a=fmt_bytes(bytes_available),\n                    u=fmt_bytes(bytes_used)))\n            dims = dims.strip().split('&')\n        except IndexError:\n            # No more dimensions available for reducing\n            # the problem size. Unable to fit the problem\n            # within the specified memory budget\n            return False, modified_dims\n\n        # Can't fit everything into memory,\n        # Lower dimensions and re-evaluate\n        for dim in dims:\n            match = re.match(__DIM_REDUCTION_RE, dim)\n\n            if not match:\n                raise ValueError(\n                    \"{d} is an invalid dimension reduction string \"\n                    \"Valid strings are for e.g. \"\n                    \"'ntime', 'ntime=20' or 'ntime=20%'\"\n                        .format(d=dim))\n\n            dim_name = match.group('name')\n            dim_value = match.group('value')\n            dim_percent = match.group('percent')\n            dim_value = 1 if dim_value is None else int(dim_value)\n\n            # Attempt reduction by a percentage\n            if dim_percent == '%':\n                dim_value = int(T[dim_name] * int(dim_value) / 100.0)\n                if dim_value < 1:\n                    # This can't be reduced any further\n                    dim_value = 1\n                else:\n                    # Allows another attempt at reduction\n                    # by percentage on this dimension\n                    dim_ord.insert(0, dim)\n\n            # Apply the dimension reduction\n            if T[dim_name] > dim_value:\n                modified_dims[dim_name] = dim_value\n                T[dim_name] = dim_value\n            else:\n                montblanc.log.info(('Ignored reduction of {d} '\n                    'of size {s} to {v}. ').format(\n                        d=dim_name, s=T[dim_name], v=dim_value))\n\n        bytes_used = dict_array_bytes_required(arrays, T)*nsolvers\n\n    return True, modified_dims", "response": "Returns the number of timesteps possible for a given set of arrays and template."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef shape_from_str_tuple(sshape, variables, ignore=None):\n    if ignore is None: ignore = []\n\n    if not isinstance(sshape, tuple) and not isinstance(sshape, list):\n        raise TypeError, 'sshape argument must be a tuple or list'\n\n    if not isinstance(ignore, list):\n        raise TypeError, 'ignore argument must be a list'\n\n    return tuple([int(eval_expr(v,variables)) if isinstance(v,str) else int(v)\n        for v in sshape if v not in ignore])", "response": "Returns a tuple of integers representing the specified string values in the supplied shape parameter\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shape_list(l,shape,dtype):\n    return np.array(l, dtype=dtype).reshape(shape)", "response": "Shape a list of lists into the appropriate shape and data type"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef array_convert_function(sshape_one, sshape_two, variables):\n    if not isinstance(sshape_one, tuple): sshape_one = (sshape_one,)\n    if not isinstance(sshape_two, tuple): sshape_two = (sshape_two,)\n\n    s_one = flatten([eval_expr_names_and_nrs(d) if isinstance(d,str) else d\n        for d in sshape_one])\n    s_two = flatten([eval_expr_names_and_nrs(d) if isinstance(d,str) else d\n        for d in sshape_two])\n\n    if len(s_one) != len(s_two):\n        raise ValueError, ('Flattened shapes %s and %s '\\\n            'do not have the same length. '\n            'Original shapes were %s and %s') % \\\n            (s_one, s_two, sshape_one, sshape_two)\n\n    # Reason about the transpose\n    t_idx = tuple([s_one.index(v) for v in s_two])\n\n    # Figure out the actual numeric shape values to use\n    n_one = shape_from_str_tuple(s_one, variables)\n    n_two = [eval_expr(d,variables)\n        if isinstance(d,str) else d for d in sshape_two]\n\n    def f(ary): return np.reshape(ary, n_one).transpose(t_idx).reshape(n_two)\n\n    return f", "response": "Returns a function defining the conversion process between two NumPy\n    arrays of different shapes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef redistribute_threads(blockdimx, blockdimy, blockdimz,\n    dimx, dimy, dimz):\n    \"\"\"\n    Redistribute threads from the Z dimension towards the X dimension.\n    Also clamp number of threads to the problem dimension size,\n    if necessary\n    \"\"\"\n\n    # Shift threads from the z dimension\n    # into the y dimension\n    while blockdimz > dimz:\n        tmp = blockdimz // 2\n        if tmp < dimz:\n            break\n\n        blockdimy *= 2\n        blockdimz = tmp\n\n    # Shift threads from the y dimension\n    # into the x dimension\n    while blockdimy > dimy:\n        tmp = blockdimy // 2\n        if tmp < dimy:\n            break\n\n        blockdimx *= 2\n        blockdimy = tmp\n\n    # Clamp the block dimensions\n    # if necessary\n    if dimx < blockdimx:\n        blockdimx = dimx\n\n    if dimy < blockdimy:\n        blockdimy = dimy\n\n    if dimz < blockdimz:\n        blockdimz = dimz\n\n    return blockdimx, blockdimy, blockdimz", "response": "Redistribute threads from the Z dimension towards the X dimension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_default_dimensions(cube, slvr_cfg):\n\n    import montblanc.src_types as mbs\n\n    # Pull out the configuration options for the basics\n    autocor = slvr_cfg['auto_correlations']\n\n    ntime = 10\n    na = 7\n    nbands = 1\n    nchan = 16\n    npol = 4\n\n    # Infer number of baselines from number of antenna,\n    nbl = nr_of_baselines(na, autocor)\n\n    if not npol == 4:\n        raise ValueError(\"npol set to {}, but only 4 polarisations \"\n                         \"are currently supported.\")\n\n    # Register these dimensions on this solver.\n    cube.register_dimension('ntime', ntime,\n        description=\"Timesteps\")\n    cube.register_dimension('na', na,\n        description=\"Antenna\")\n    cube.register_dimension('nbands', nbands,\n        description=\"Bands\")\n    cube.register_dimension('nchan', nchan,\n        description=\"Channels\")\n    cube.register_dimension('npol', npol,\n        description=\"Polarisations\")\n    cube.register_dimension('nbl', nbl,\n        description=\"Baselines\")\n\n    # Register dependent dimensions\n    cube.register_dimension('npolchan', nchan*npol,\n        description='Polarised channels')\n    cube.register_dimension('nvis', ntime*nbl*nchan,\n        description='Visibilities')\n\n    # Convert the source types, and their numbers\n    # to their number variables and numbers\n    # { 'point':10 } => { 'npsrc':10 }\n    src_cfg = default_sources()\n    src_nr_vars = sources_to_nr_vars(src_cfg)\n    # Sum to get the total number of sources\n    cube.register_dimension('nsrc', sum(src_nr_vars.itervalues()),\n        description=\"Sources (Total)\")\n\n    # Register the individual source types\n    for nr_var, nr_of_src in src_nr_vars.iteritems():\n        cube.register_dimension(nr_var, nr_of_src,\n            description='{} sources'.format(mbs.SOURCE_DIM_TYPES[nr_var]))", "response": "Register the default dimensions for a RIME solver."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhack to get IP address from the interface", "response": "def get_ip_address(ifname):\n    \"\"\" Hack to get IP address from the interface \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    return socket.inet_ntoa(fcntl.ioctl(\n        s.fileno(),\n        0x8915,  # SIOCGIFADDR\n        struct.pack('256s', ifname[:15])\n    )[20:24])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nvcc_compiler_settings():\n\n    search_paths = os.environ.get('PATH', '').split(os.pathsep)\n    nvcc_path = find_in_path('nvcc', search_paths)\n    default_cuda_path = os.path.join('usr', 'local', 'cuda')\n    cuda_path = os.environ.get('CUDA_PATH', default_cuda_path)\n\n    nvcc_found = os.path.exists(nvcc_path)\n    cuda_path_found = os.path.exists(cuda_path)\n\n    # Can't find either NVCC or some CUDA_PATH\n    if not nvcc_found and not cuda_path_found:\n        raise InspectCudaException(\"Neither nvcc '{}' \"\n            \"or the CUDA_PATH '{}' were found!\".format(\n                nvcc_path, cuda_path))\n\n    # No NVCC, try find it in the CUDA_PATH\n    if not nvcc_found:\n        log.warn(\"nvcc compiler not found at '{}'. \"\n            \"Searching within the CUDA_PATH '{}'\"\n                .format(nvcc_path, cuda_path))\n\n        bin_dir = os.path.join(cuda_path, 'bin')\n        nvcc_path = find_in_path('nvcc', bin_dir)\n        nvcc_found = os.path.exists(nvcc_path)\n\n        if not nvcc_found:\n            raise InspectCudaException(\"nvcc not found in '{}' \"\n                \"or under the CUDA_PATH at '{}' \"\n                .format(search_paths, cuda_path))\n\n    # No CUDA_PATH found, infer it from NVCC\n    if not cuda_path_found:\n        cuda_path = os.path.normpath(\n            os.path.join(os.path.dirname(nvcc_path), \"..\"))\n\n        log.warn(\"CUDA_PATH not found, inferring it as '{}' \"\n            \"from the nvcc location '{}'\".format(\n                cuda_path, nvcc_path))\n\n        cuda_path_found = True\n\n    # Set up the compiler settings\n    include_dirs = []\n    library_dirs = []\n    define_macros = []\n\n    if cuda_path_found:\n        include_dirs.append(os.path.join(cuda_path, 'include'))\n        if sys.platform == 'win32':\n            library_dirs.append(os.path.join(cuda_path, 'bin'))\n            library_dirs.append(os.path.join(cuda_path, 'lib', 'x64'))\n        else:\n            library_dirs.append(os.path.join(cuda_path, 'lib64'))\n            library_dirs.append(os.path.join(cuda_path, 'lib'))\n    if sys.platform == 'darwin':\n        library_dirs.append(os.path.join(default_cuda_path, 'lib'))\n\n    return {\n        'cuda_available' : True,\n        'nvcc_path' : nvcc_path,\n        'include_dirs': include_dirs,\n        'library_dirs': library_dirs,\n        'define_macros': define_macros,\n        'libraries' : ['cudart', 'cuda'],\n        'language': 'c++',\n    }", "response": "Find NVCC and CUDA installation and infer the NVCC_BASE_NAME and NVCC_BASE_NAME from the NVCC_BASE_NAME environment variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inspect_cuda_version_and_devices(compiler, settings):\n    try:\n        output = build_and_run(compiler, '''\n            #include <cuda.h>\n            #include <stdio.h>\n\n            __device__ void test(int * in, int * out)\n            {\n                int tid = blockIdx.x*blockDim.x + threadIdx.x;\n                out[tid] = in[tid];\n            }\n\n            int main(int argc, char* argv[]) {\n\n              printf(\"{\\\\n\");\n              printf(\"  \\\\\"cuda_version\\\\\": %d,\\\\n\", CUDA_VERSION);\n\n              printf(\"  \\\\\"devices\\\\\": [\\\\n\");\n\n              int nr_of_devices = 0;\n              cudaGetDeviceCount(&nr_of_devices);\n\n              for(int d=0; d < nr_of_devices; ++d)\n              {\n                cudaDeviceProp p;\n                cudaGetDeviceProperties(&p, d);\n\n                printf(\"    {\\\\n\");\n\n                bool last = (d == nr_of_devices-1);\n\n                printf(\"      \\\\\"name\\\\\": \\\\\"%s\\\\\",\\\\n\", p.name);\n                printf(\"      \\\\\"major\\\\\": %d,\\\\n\", p.major);\n                printf(\"      \\\\\"minor\\\\\": %d,\\\\n\", p.minor);\n                printf(\"      \\\\\"memory\\\\\": %lu\\\\n\", p.totalGlobalMem);\n\n                printf(\"    }%s\\\\n\", last ? \"\" : \",\");\n              }\n\n              printf(\"  ]\\\\n\");\n              printf(\"}\\\\n\");\n\n              return 0;\n            }\n        ''',\n        filename='test.cu',\n        include_dirs=settings['include_dirs'],\n        library_dirs=settings['library_dirs'],\n        libraries=settings['libraries'])\n\n    except Exception as e:\n        msg = (\"Running the CUDA device check \"\n            \"stub failed\\n{}\".format(str(e)))\n        raise InspectCudaException(msg), None, sys.exc_info()[2]\n\n    return output", "response": "This function returns the CUDA_VERSION information and CUDA device information in JSON format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninjecting deep into distutils to customize gcc / nvcc dispatch", "response": "def customize_compiler_for_nvcc(compiler, nvcc_settings):\n    \"\"\"inject deep into distutils to customize gcc/nvcc dispatch \"\"\"\n\n    # tell the compiler it can process .cu files\n    compiler.src_extensions.append('.cu')\n\n    # save references to the default compiler_so and _compile methods\n    default_compiler_so = compiler.compiler_so\n    default_compile = compiler._compile\n\n    # now redefine the _compile method. This gets executed for each\n    # object but distutils doesn't have the ability to change compilers\n    # based on source extension: we add it.\n    def _compile(obj, src, ext, cc_args, extra_postargs, pp_opts):\n        # Use NVCC for .cu files\n        if os.path.splitext(src)[1] == '.cu':\n            compiler.set_executable('compiler_so', nvcc_settings['nvcc_path'])\n\n        default_compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n        # reset the default compiler_so, which we might have changed for cuda\n        compiler.compiler_so = default_compiler_so\n\n    # inject our redefined _compile method into the class\n    compiler._compile = _compile"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inspect_cuda():\n    nvcc_settings = nvcc_compiler_settings()\n    sysconfig.get_config_vars()\n    nvcc_compiler = ccompiler.new_compiler()\n    sysconfig.customize_compiler(nvcc_compiler)\n    customize_compiler_for_nvcc(nvcc_compiler, nvcc_settings)\n\n    output = inspect_cuda_version_and_devices(nvcc_compiler, nvcc_settings)\n\n    return json.loads(output), nvcc_settings", "response": "Return cuda device information and cuda setup"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef template_dict(self):\n        slvr = self\n\n        D = {\n            # Constants\n            'LIGHTSPEED': montblanc.constants.C,\n        }\n\n        # Map any types\n        D.update(self.type_dict())\n\n        # Update with dimensions\n        D.update(self.dim_local_size_dict())\n\n        # Add any registered properties to the dictionary\n        for p in self._properties.itervalues():\n            D[p.name] = getattr(self, p.name)\n\n        return D", "response": "Returns a dictionary suitable for templating strings with\n            properties and dimensions related to this Solver object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rime_solver(slvr_cfg):\n    from montblanc.impl.rime.tensorflow.RimeSolver import RimeSolver\n    return RimeSolver(slvr_cfg)", "response": "Factory function that produces a RIME solver"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_sources(obj, argspec=None):\n\n    if argspec is None:\n        argspec = [DEFAULT_ARGSPEC]\n\n    return { n: m for n, m in inspect.getmembers(obj, callable)\n        if not n.startswith('_') and\n        inspect.getargspec(m).args in argspec }", "response": "Find sources on this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sources(self):\n\n        try:\n            return self._sources\n        except AttributeError:\n            self._sources = find_sources(self)\n\n        return self._sources", "response": "Returns a dictionary of source methods found on this object keyed on method name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the parallactic angles per timestep for the given set of unique times antenna positions and field centre.", "response": "def parallactic_angles(times, antenna_positions, field_centre):\n    \"\"\"\n    Computes parallactic angles per timestep for the given\n    reference antenna position and field centre.\n\n    Arguments:\n        times: ndarray\n            Array of unique times with shape (ntime,),\n            obtained from TIME column of MS table\n        antenna_positions: ndarray of shape (na, 3)\n            Antenna positions, obtained from POSITION\n            column of MS ANTENNA sub-table\n        field_centre : ndarray of shape (2,)\n            Field centre, should be obtained from MS PHASE_DIR\n\n    Returns:\n        An array of parallactic angles per time-step\n\n    \"\"\"\n    import pyrap.quanta as pq\n\n    try:\n        # Create direction measure for the zenith\n        zenith = pm.direction('AZEL','0deg','90deg')\n    except AttributeError as e:\n        if pm is None:\n            raise ImportError(\"python-casacore import failed\")\n\n        raise\n\n    # Create position measures for each antenna\n    reference_positions = [pm.position('itrf',\n        *(pq.quantity(x,'m') for x in pos))\n        for pos in antenna_positions]\n\n    # Compute field centre in radians\n    fc_rad = pm.direction('J2000',\n        *(pq.quantity(f,'rad') for f in field_centre))\n\n    return np.asarray([\n            # Set current time as the reference frame\n            pm.do_frame(pm.epoch(\"UTC\", pq.quantity(t, \"s\")))\n            and\n            [   # Set antenna position as the reference frame\n                pm.do_frame(rp)\n                and\n                pm.posangle(fc_rad, zenith).get_value(\"rad\")\n                for rp in reference_positions\n            ]\n        for t in times])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncache constant arrays associated with an array name. The intent of this decorator is to avoid the cost of recreating and storing many arrays of constant data, especially data created by np.zeros or np.ones. Instead, a single array of the first given shape is created and any further requests for constant data of the same (or smaller) shape are served from the cache. Requests for larger shapes or different types are regarded as a cache miss and will result in replacement of the existing cache value.", "response": "def constant_cache(method):\n    \"\"\"\n    Caches constant arrays associated with an array name.\n\n    The intent of this decorator is to avoid the cost\n    of recreating and storing many arrays of constant data,\n    especially data created by np.zeros or np.ones.\n    Instead, a single array of the first given shape is created\n    and any further requests for constant data of the same\n    (or smaller) shape are served from the cache.\n\n    Requests for larger shapes or different types are regarded\n    as a cache miss and will result in replacement of the\n    existing cache value.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, context):\n        # Defer to method if no caching is enabled\n        if not self._is_cached:\n            return method(self, context)\n\n        name = context.name\n        cached = self._constant_cache.get(name, None)\n\n        # No cached value, call method and return\n        if cached is None:\n            data = self._constant_cache[name] = method(self, context)\n            return data\n\n        # Can we just slice the existing cache entry?\n        # 1. Are all context.shape's entries less than or equal\n        #    to the shape of the cached data?\n        # 2. Do they have the same dtype?\n        cached_ok = (cached.dtype == context.dtype and\n            all(l <= r for l,r in zip(context.shape, cached.shape)))\n\n        # Need to return something bigger or a different type\n        if not cached_ok:\n            data = self._constant_cache[name] = method(self, context)\n            return data\n\n        # Otherwise slice the cached data\n        return cached[tuple(slice(0, s) for s in context.shape)]\n\n    f = wrapper\n    f.__decorator__ = constant_cache.__name__\n\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncaches chunks of default data. This decorator caches generated default data so as to avoid recomputing it on a subsequent queries to the provider.", "response": "def chunk_cache(method):\n    \"\"\"\n    Caches chunks of default data.\n\n    This decorator caches generated default data so as to\n    avoid recomputing it on a subsequent queries to the\n    provider.\n    \"\"\"\n\n    @functools.wraps(method)\n    def wrapper(self, context):\n        # Defer to the method if no caching is enabled\n        if not self._is_cached:\n            return method(self, context)\n\n        # Construct the key for the given index\n        name = context.name\n        idx = context.array_extents(name)\n        key = tuple(i for t in idx for i in t)\n        # Access the sub-cache for this array\n        array_cache = self._chunk_cache[name]\n\n        # Cache miss, call the function\n        if key not in array_cache:\n            array_cache[key] = method(self, context)\n\n        return array_cache[key]\n\n    f = wrapper\n    f.__decorator__ = chunk_cache.__name__\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a DefaultsSourceProvider object for each array in the hypercube.", "response": "def _create_defaults_source_provider(cube, data_source):\n    \"\"\"\n    Create a DefaultsSourceProvider object. This provides default\n    data sources for each array defined on the hypercube. The data sources\n    may either by obtained from the arrays 'default' data source\n    or the 'test' data source.\n    \"\"\"\n    from montblanc.impl.rime.tensorflow.sources import (\n        find_sources, DEFAULT_ARGSPEC)\n    from montblanc.impl.rime.tensorflow.sources import constant_cache\n\n    # Obtain default data sources for each array,\n    # Just take from defaults if test data isn't specified\n    staging_area_data_source = ('default' if not data_source == 'test'\n                                                      else data_source)\n\n    cache = True\n\n    default_prov = DefaultsSourceProvider(cache=cache)\n\n    # Create data sources on the source provider from\n    # the cube array data sources\n    for n, a in cube.arrays().iteritems():\n        # Unnecessary for temporary arrays\n        if 'temporary' in a.tags:\n            continue\n\n        # Obtain the data source\n        data_source = a.get(staging_area_data_source)\n\n        # Array marked as constant, decorate the data source\n        # with a constant caching decorator\n        if cache is True and 'constant' in a.tags:\n            data_source = constant_cache(data_source)\n\n        method = types.MethodType(data_source, default_prov)\n        setattr(default_prov, n, method)\n\n    def _sources(self):\n        \"\"\"\n        Override the sources method to also handle lambdas that look like\n        lambda s, c: ..., as defined in the config module\n        \"\"\"\n\n        try:\n            return self._sources\n        except AttributeError:\n            self._sources = find_sources(self, [DEFAULT_ARGSPEC] + [['s', 'c']])\n\n        return self._sources\n\n    # Monkey patch the sources method\n    default_prov.sources = types.MethodType(_sources, default_prov)\n\n    return default_prov"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _construct_tensorflow_expression(slvr_cfg, feed_data, device, shard):\n    zero = tf.constant(0)\n    src_count = zero\n    src_ph_vars = feed_data.src_ph_vars\n\n    LSA = feed_data.local\n\n    polarisation_type = slvr_cfg['polarisation_type']\n\n    # Pull RIME inputs out of the feed staging_area\n    # of the relevant shard, adding the feed once\n    # inputs to the dictionary\n    D = LSA.feed_many[shard].get_to_attrdict()\n    D.update({k: fo.var for k, fo in LSA.feed_once.iteritems()})\n\n    with tf.device(device):\n        # Infer chunk dimensions\n        model_vis_shape = tf.shape(D.model_vis)\n        ntime, nbl, nchan, npol = [model_vis_shape[i] for i in range(4)]\n\n        # Infer float and complex type\n        FT, CT = D.uvw.dtype, D.model_vis.dtype\n\n        # Compute sine and cosine of parallactic angles\n        # for the beam\n        beam_sin, beam_cos = rime.parallactic_angle_sin_cos(\n                                        D.parallactic_angles)\n\n        # Compute sine and cosine of feed rotation angle\n        feed_sin, feed_cos = rime.parallactic_angle_sin_cos(\n                                        D.parallactic_angles[:, :] +\n                                        D.feed_angles[None, :])\n\n        # Compute feed rotation\n        feed_rotation = rime.feed_rotation(feed_sin, feed_cos, CT=CT,\n                                           feed_type=polarisation_type)\n\n    def antenna_jones(lm, stokes, alpha, ref_freq):\n        \"\"\"\n        Compute the jones terms for each antenna.\n\n        lm, stokes and alpha are the source variables.\n        \"\"\"\n\n        # Compute the complex phase\n        cplx_phase = rime.phase(lm, D.uvw, D.frequency, CT=CT)\n\n        # Check for nans/infs in the complex phase\n        phase_msg = (\"Check that '1 - l**2  - m**2 >= 0' holds \"\n                    \"for all your lm coordinates. This is required \"\n                    \"for 'n = sqrt(1 - l**2 - m**2) - 1' \"\n                    \"to be finite.\")\n\n        phase_real = tf.check_numerics(tf.real(cplx_phase), phase_msg)\n        phase_imag = tf.check_numerics(tf.imag(cplx_phase), phase_msg)\n\n        # Compute the square root of the brightness matrix\n        # (as well as the sign)\n        bsqrt, sgn_brightness = rime.b_sqrt(stokes, alpha,\n            D.frequency, ref_freq, CT=CT,\n            polarisation_type=polarisation_type)\n\n        # Check for nans/infs in the bsqrt\n        bsqrt_msg = (\"Check that your stokes parameters \"\n                    \"satisfy I**2 >= Q**2 + U**2 + V**2. \"\n                    \"Montblanc performs a cholesky decomposition \"\n                    \"of the brightness matrix and the above must \"\n                    \"hold for this to produce valid values.\")\n\n        bsqrt_real = tf.check_numerics(tf.real(bsqrt), bsqrt_msg)\n        bsqrt_imag = tf.check_numerics(tf.imag(bsqrt), bsqrt_msg)\n\n        # Compute the direction dependent effects from the beam\n        ejones = rime.e_beam(lm, D.frequency,\n            D.pointing_errors, D.antenna_scaling,\n            beam_sin, beam_cos,\n            D.beam_extents, D.beam_freq_map, D.ebeam)\n\n        deps = [phase_real, phase_imag, bsqrt_real, bsqrt_imag]\n        deps = [] # Do nothing for now\n\n        # Combine the brightness square root, complex phase,\n        # feed rotation and beam dde's\n        with tf.control_dependencies(deps):\n            antenna_jones = rime.create_antenna_jones(bsqrt, cplx_phase,\n                                                    feed_rotation, ejones, FT=FT)\n            return antenna_jones, sgn_brightness\n\n    # While loop condition for each point source type\n    def point_cond(coherencies, npsrc, src_count):\n        return tf.less(npsrc, src_ph_vars.npsrc)\n\n    def gaussian_cond(coherencies, ngsrc, src_count):\n        return tf.less(ngsrc, src_ph_vars.ngsrc)\n\n    def sersic_cond(coherencies, nssrc, src_count):\n        return tf.less(nssrc, src_ph_vars.nssrc)\n\n    # While loop bodies\n    def point_body(coherencies, npsrc, src_count):\n        \"\"\" Accumulate visiblities for point source batch \"\"\"\n        S = LSA.sources['npsrc'][shard].get_to_attrdict()\n\n        # Maintain source counts\n        nsrc = tf.shape(S.point_lm)[0]\n        src_count += nsrc\n        npsrc +=  nsrc\n\n        ant_jones, sgn_brightness = antenna_jones(S.point_lm,\n            S.point_stokes, S.point_alpha, S.point_ref_freq)\n        shape = tf.ones(shape=[nsrc,ntime,nbl,nchan], dtype=FT)\n        coherencies = rime.sum_coherencies(D.antenna1, D.antenna2,\n            shape, ant_jones, sgn_brightness, coherencies)\n\n        return coherencies, npsrc, src_count\n\n    def gaussian_body(coherencies, ngsrc, src_count):\n        \"\"\" Accumulate coherencies for gaussian source batch \"\"\"\n        S = LSA.sources['ngsrc'][shard].get_to_attrdict()\n\n        # Maintain source counts\n        nsrc = tf.shape(S.gaussian_lm)[0]\n        src_count += nsrc\n        ngsrc += nsrc\n\n        ant_jones, sgn_brightness = antenna_jones(S.gaussian_lm,\n            S.gaussian_stokes, S.gaussian_alpha, S.gaussian_ref_freq)\n        gauss_shape = rime.gauss_shape(D.uvw, D.antenna1, D.antenna2,\n            D.frequency, S.gaussian_shape)\n        coherencies = rime.sum_coherencies(D.antenna1, D.antenna2,\n            gauss_shape, ant_jones, sgn_brightness, coherencies)\n\n        return coherencies, ngsrc, src_count\n\n    def sersic_body(coherencies, nssrc, src_count):\n        \"\"\" Accumulate coherencies for sersic source batch \"\"\"\n        S = LSA.sources['nssrc'][shard].get_to_attrdict()\n\n        # Maintain source counts\n        nsrc = tf.shape(S.sersic_lm)[0]\n        src_count += nsrc\n        nssrc += nsrc\n\n        ant_jones, sgn_brightness = antenna_jones(S.sersic_lm,\n            S.sersic_stokes, S.sersic_alpha, S.sersic_ref_freq)\n        sersic_shape = rime.sersic_shape(D.uvw, D.antenna1, D.antenna2,\n            D.frequency, S.sersic_shape)\n        coherencies = rime.sum_coherencies(D.antenna1, D.antenna2,\n            sersic_shape, ant_jones, sgn_brightness, coherencies)\n\n        return coherencies, nssrc, src_count\n\n    with tf.device(device):\n        base_coherencies = tf.zeros(shape=[ntime,nbl,nchan,npol], dtype=CT)\n\n        # Evaluate point sources\n        summed_coherencies, npsrc, src_count = tf.while_loop(\n            point_cond, point_body,\n            [base_coherencies, zero, src_count])\n\n        # Evaluate gaussians\n        summed_coherencies, ngsrc, src_count = tf.while_loop(\n            gaussian_cond, gaussian_body,\n            [summed_coherencies, zero, src_count])\n\n        # Evaluate sersics\n        summed_coherencies, nssrc, src_count = tf.while_loop(\n            sersic_cond, sersic_body,\n            [summed_coherencies, zero, src_count])\n\n        # Post process visibilities to produce model visibilites and chi squared\n        model_vis, chi_squared = rime.post_process_visibilities(\n            D.antenna1, D.antenna2, D.direction_independent_effects, D.flag,\n            D.weight, D.model_vis, summed_coherencies, D.observed_vis)\n\n    # Create enstaging_area operation\n    put_op = LSA.output.put_from_list([D.descriptor, model_vis, chi_squared])\n\n    # Return descriptor and enstaging_area operation\n    return D.descriptor, put_op", "response": "Constructs a tensorflow expression for computing the RIME."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the data from the data source checking the return values", "response": "def _get_data(data_source, context):\n    \"\"\" Get data from the data source, checking the return values \"\"\"\n    try:\n        # Get data from the data source\n        data = data_source.source(context)\n\n        # Complain about None values\n        if data is None:\n            raise ValueError(\"'None' returned from \"\n                \"data source '{n}'\".format(n=context.name))\n        # We want numpy arrays\n        elif not isinstance(data, np.ndarray):\n            raise TypeError(\"Data source '{n}' did not \"\n                \"return a numpy array, returned a '{t}'\".format(\n                    t=type(data)))\n        # And they should be the right shape and type\n        elif data.shape != context.shape or data.dtype != context.dtype:\n            raise ValueError(\"Expected data of shape '{esh}' and \"\n                \"dtype '{edt}' for data source '{n}', but \"\n                \"shape '{rsh}' and '{rdt}' was found instead\".format(\n                    n=context.name, esh=context.shape, edt=context.dtype,\n                    rsh=data.shape, rdt=data.dtype))\n\n        return data\n\n    except Exception as e:\n        ex = ValueError(\"An exception occurred while \"\n            \"obtaining data from data source '{ds}'\\n\\n\"\n            \"{e}\\n\\n\"\n            \"{help}\".format(ds=context.name,\n                e=str(e), help=context.help()))\n\n        raise ex, None, sys.exc_info()[2]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _supply_data(data_sink, context):\n    try:\n        data_sink.sink(context)\n    except Exception as e:\n        ex = ValueError(\"An exception occurred while \"\n            \"supplying data to data sink '{ds}'\\n\\n\"\n            \"{e}\\n\\n\"\n            \"{help}\".format(ds=context.name,\n                e=str(e), help=context.help()))\n\n        raise ex, None, sys.exc_info()[2]", "response": "Supply data to the data sink"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _apply_source_provider_dim_updates(cube, source_providers, budget_dims):\n    # Create a mapping between a dimension and a\n    # list of (global_size, provider_name) tuples\n    update_map = collections.defaultdict(list)\n\n    for prov in source_providers:\n        for dim_tuple in prov.updated_dimensions():\n            name, size = dim_tuple\n\n            # Don't accept any updates on the nsrc dimension\n            # This is managed internally\n            if name == 'nsrc':\n                continue\n\n            dim_update = DimensionUpdate(size, prov.name())\n            update_map[name].append(dim_update)\n\n    # No dimensions were updated, quit early\n    if len(update_map) == 0:\n        return cube.bytes_required()\n\n    # Ensure that the global sizes we receive\n    # for each dimension are unique. Tell the user\n    # when conflicts occur\n    update_list = []\n\n    for name, updates in update_map.iteritems():\n        if not all(updates[0].size == du.size for du in updates[1:]):\n            raise ValueError(\"Received conflicting \"\n                \"global size updates '{u}'\"\n                \" for dimension '{n}'.\".format(n=name, u=updates))\n\n        update_list.append((name, updates[0].size))\n\n    montblanc.log.info(\"Updating dimensions {} from \"\n                        \"source providers.\".format(str(update_list)))\n\n    # Now update our dimensions\n    for name, global_size in update_list:\n        # Defer to existing any existing budgeted extent sizes\n        # Otherwise take the global_size\n        extent_size = budget_dims.get(name, global_size)\n\n        # Take the global_size if extent_size was previously zero!\n        extent_size = global_size if extent_size == 0 else extent_size\n\n        # Clamp extent size to global size\n        if extent_size > global_size:\n            extent_size = global_size\n\n        # Update the dimension\n        cube.update_dimension(name,\n            global_size=global_size,\n            lower_extent=0,\n            upper_extent=extent_size)\n\n    # Handle global number of sources differently\n    # It's equal to the number of\n    # point's, gaussian's, sersic's combined\n    nsrc = sum(cube.dim_global_size(*mbu.source_nr_vars()))\n\n    # Extent size will be equal to whatever source type\n    # we're currently iterating over. So just take\n    # the maximum extent size given the sources\n    es = max(cube.dim_extent_size(*mbu.source_nr_vars()))\n\n    cube.update_dimension('nsrc',\n        global_size=nsrc,\n        lower_extent=0,\n        upper_extent=es)\n\n    # Return our cube size\n    return cube.bytes_required()", "response": "Applies the list of suggested dimension updates to the hypercube."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _setup_hypercube(cube, slvr_cfg):\n    mbu.register_default_dimensions(cube, slvr_cfg)\n\n    # Configure the dimensions of the beam cube\n    cube.register_dimension('beam_lw', 2,\n                            description='E Beam cube l width')\n\n    cube.register_dimension('beam_mh', 2,\n                            description='E Beam cube m height')\n\n    cube.register_dimension('beam_nud', 2,\n                            description='E Beam cube nu depth')\n\n    # =========================================\n    # Register hypercube Arrays and Properties\n    # =========================================\n\n    from montblanc.impl.rime.tensorflow.config import (A, P)\n\n    def _massage_dtypes(A, T):\n        def _massage_dtype_in_dict(D):\n            new_dict = D.copy()\n            new_dict['dtype'] = mbu.dtype_from_str(D['dtype'], T)\n            return new_dict\n\n        return [_massage_dtype_in_dict(D) for D in A]\n\n    dtype = slvr_cfg['dtype']\n    is_f32 = dtype == 'float'\n\n    T = {\n        'ft' : np.float32 if is_f32 else np.float64,\n        'ct' : np.complex64 if is_f32 else np.complex128,\n        'int' : int,\n    }\n\n    cube.register_properties(_massage_dtypes(P, T))\n    cube.register_arrays(_massage_dtypes(A, T))", "response": "Setup the hypercube given a solver configuration"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npartition data sources into a single object.", "response": "def _partition(iter_dims, data_sources):\n    \"\"\"\n    Partition data sources into\n\n    1. Dictionary of data sources associated with radio sources.\n    2. List of data sources to feed multiple times.\n    3. List of data sources to feed once.\n    \"\"\"\n\n    src_nr_vars = set(source_var_types().values())\n    iter_dims = set(iter_dims)\n\n    src_data_sources = collections.defaultdict(list)\n    feed_many = []\n    feed_once = []\n\n    for ds in data_sources:\n        # Is this data source associated with\n        # a radio source (point, gaussian, etc.?)\n        src_int = src_nr_vars.intersection(ds.shape)\n\n        if len(src_int) > 1:\n            raise ValueError(\"Data source '{}' contains multiple \"\n                            \"source types '{}'\".format(ds.name, src_int))\n        elif len(src_int) == 1:\n            # Yep, record appropriately and iterate\n            src_data_sources[src_int.pop()].append(ds)\n            continue\n\n        # Are we feeding this data source multiple times\n        # (Does it possess dimensions on which we iterate?)\n        if len(iter_dims.intersection(ds.shape)) > 0:\n            feed_many.append(ds)\n            continue\n\n        # Assume this is a data source that we only feed once\n        feed_once.append(ds)\n\n    return src_data_sources, feed_many, feed_once"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall the tensorflow compute", "response": "def _compute(self, feed_dict, shard):\n        \"\"\" Call the tensorflow compute \"\"\"\n\n        try:\n            descriptor, enq = self._tfrun(self._tf_expr[shard], feed_dict=feed_dict)\n            self._inputs_waiting.decrement(shard)\n\n        except Exception as e:\n            montblanc.log.exception(\"Compute Exception\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _consume(self, data_sinks, cube, global_iter_args):\n        try:\n            return self._consume_impl(data_sinks, cube, global_iter_args)\n        except Exception as e:\n            montblanc.log.exception(\"Consumer Exception\")\n            raise e, None, sys.exc_info()[2]", "response": "Internal function to consume a single instance of a class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconsume the local cache and call the data sinks.", "response": "def _consume_impl(self, data_sinks, cube, global_iter_args):\n        \"\"\" Consume \"\"\"\n\n        LSA = self._tf_feed_data.local\n        output = self._tfrun(LSA.output.get_op)\n\n        # Expect the descriptor in the first tuple position\n        assert len(output) > 0\n        assert LSA.output.fed_arrays[0] == 'descriptor'\n\n        descriptor = output['descriptor']\n        # Make it read-only so we can hash the contents\n        descriptor.flags.writeable = False\n\n        dims = self._transcoder.decode(descriptor)\n        cube.update_dimensions(dims)\n\n        # Obtain and remove input data from the source cache\n        try:\n            input_data = self._source_cache.pop(descriptor.data)\n        except KeyError:\n            raise ValueError(\"No input data cache available \"\n                \"in source cache for descriptor {}!\"\n                    .format(descriptor))\n\n        # For each array in our output, call the associated data sink\n        gen = ((n, a) for n, a in output.iteritems() if not n == 'descriptor')\n\n        for n, a in gen:\n            sink_context = SinkContext(n, cube,\n                self.config(), global_iter_args,\n                cube.array(n) if n in cube.arrays() else {},\n                a, input_data)\n\n            _supply_data(data_sinks[n], sink_context)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a SolverConfiguration object that can be used to configure the RIME Solver.", "response": "def rime_solver_cfg(**kwargs):\n    \"\"\"\n    Produces a SolverConfiguration object, inherited from\n    a simple python dict, and containing the options required\n    to configure the RIME Solver.\n\n    Keyword arguments\n    -----------------\n    Any keyword arguments are inserted into the\n    returned dict.\n\n    Returns\n    -------\n    A SolverConfiguration object.\n    \"\"\"\n    from configuration import (load_config, config_validator,\n        raise_validator_errors)\n\n    def _merge_copy(d1, d2):\n        return { k: _merge_copy(d1[k], d2[k]) if k in d1\n                                                and isinstance(d1[k], dict)\n                                                and isinstance(d2[k], dict)\n                                            else d2[k] for k in d2 }\n\n    try:\n        cfg_file = kwargs.pop('cfg_file')\n    except KeyError as e:\n        slvr_cfg = kwargs\n    else:\n        cfg = load_config(cfg_file)\n        slvr_cfg = _merge_copy(cfg, kwargs)\n\n    # Validate the configuration, raising any errors\n    validator = config_validator()\n    validator.validate(slvr_cfg)\n    raise_validator_errors(validator)\n\n    return validator.document"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a dictionary of beam filenames keyed on correlations and real imaginary pairs and the corresponding beam filenames.", "response": "def _create_filenames(filename_schema, feed_type):\n    \"\"\"\n    Returns a dictionary of beam filename pairs,\n    keyed on correlation,from the cartesian product\n    of correlations and real, imaginary pairs\n\n    Given 'beam_$(corr)_$(reim).fits' returns:\n    {\n      'xx' : ('beam_xx_re.fits', 'beam_xx_im.fits'),\n      'xy' : ('beam_xy_re.fits', 'beam_xy_im.fits'),\n      ...\n      'yy' : ('beam_yy_re.fits', 'beam_yy_im.fits'),\n    }\n\n    Given 'beam_$(CORR)_$(REIM).fits' returns:\n    {\n      'xx' : ('beam_XX_RE.fits', 'beam_XX_IM.fits'),\n      'xy' : ('beam_XY_RE.fits', 'beam_XY_IM.fits'),\n      ...\n      'yy' : ('beam_YY_RE.fits', 'beam_YY_IM.fits'),\n    }\n\n    \"\"\"\n    template = FitsFilenameTemplate(filename_schema)\n\n    def _re_im_filenames(corr, template):\n        try:\n            return tuple(template.substitute(\n                corr=corr.lower(), CORR=corr.upper(),\n                reim=ri.lower(), REIM=ri.upper())\n                    for ri in REIM)\n        except KeyError:\n            raise ValueError(\"Invalid filename schema '%s'. \"\n                            \"FITS Beam filename schemas \"\n                            \"must follow forms such as \"\n                            \"'beam_$(corr)_$(reim).fits' or \"\n                            \"'beam_$(CORR)_$(REIM).fits.\" % filename_schema)\n\n    if feed_type == 'linear':\n        CORRELATIONS = LINEAR_CORRELATIONS\n    elif feed_type == 'circular':\n        CORRELATIONS = CIRCULAR_CORRELATIONS\n    else:\n        raise ValueError(\"Invalid feed_type '{}'. \"\n            \"Should be 'linear' or 'circular'\")\n\n    return collections.OrderedDict(\n        (c, _re_im_filenames(c, template))\n        for c in CORRELATIONS)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a dict of filenames returns a dictionary mapping for filenames Returns a dictionary mapping for filenames Returns a dictionary mapping for filenames Returns a dictionary mapping for filenames", "response": "def _open_fits_files(filenames):\n    \"\"\"\n    Given a {correlation: filename} mapping for filenames\n    returns a {correlation: file handle} mapping\n    \"\"\"\n    kw = { 'mode' : 'update', 'memmap' : False }\n\n    def _fh(fn):\n        \"\"\" Returns a filehandle or None if file does not exist \"\"\"\n        return fits.open(fn, **kw) if os.path.exists(fn) else None\n\n    return collections.OrderedDict(\n            (corr, tuple(_fh(fn) for fn in files))\n        for corr, files in filenames.iteritems() )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a FitsAxes object for the archive.", "response": "def _create_axes(filenames, file_dict):\n    \"\"\" Create a FitsAxes object \"\"\"\n\n    try:\n        # Loop through the file_dictionary, finding the\n        # first open FITS file.\n        f = iter(f for tup in file_dict.itervalues()\n            for f in tup if f is not None).next()\n    except StopIteration as e:\n        raise (ValueError(\"No FITS files were found. \"\n            \"Searched filenames: '{f}'.\" .format(\n                f=filenames.values())),\n                    None, sys.exc_info()[2])\n\n\n    # Create a FitsAxes object\n    axes = FitsAxes(f[0].header)\n\n    # Scale any axes in degrees to radians\n    for i, u in enumerate(axes.cunit):\n        if u == 'DEG':\n            axes.cunit[i] = 'RAD'\n            axes.set_axis_scale(i, np.pi/180.0)\n\n    return axes"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitialises the object by generating appropriate filenames and axes and populating the object properties.", "response": "def _initialise(self, feed_type=\"linear\"):\n        \"\"\"\n        Initialise the object by generating appropriate filenames,\n        opening associated file handles and inspecting the FITS axes\n        of these files.\n        \"\"\"\n        self._filenames = filenames = _create_filenames(self._filename_schema,\n                                                        feed_type)\n        self._files = files = _open_fits_files(filenames)\n        self._axes = axes = _create_axes(filenames, files)\n        self._dim_indices = dim_indices = l_ax, m_ax, f_ax = tuple(\n            axes.iaxis(d) for d in self._fits_dims)\n\n        # Complain if we can't find required axes\n        for i, ax in zip(dim_indices, self._fits_dims):\n            if i == -1:\n                raise ValueError(\"'%s' axis not found!\" % ax)\n\n        self._cube_extents = _cube_extents(axes, l_ax, m_ax, f_ax,\n            self._l_sign, self._m_sign)\n        self._shape = tuple(axes.naxis[d] for d in dim_indices) + (4,)\n        self._beam_freq_map = axes.grid[f_ax]\n\n        # Now describe our dimension sizes\n        self._dim_updates = [(n, axes.naxis[i]) for n, i\n            in zip(self._beam_dims, dim_indices)]\n\n        self._initialised = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef model_vis(self, context):\n        column = self._vis_column\n        msshape = None\n\n        # Do we have a column descriptor for the supplied column?\n        try:\n            coldesc = self._manager.column_descriptors[column]\n        except KeyError as e:\n            coldesc = None\n\n        # Try to get the shape from the descriptor\n        if coldesc is not None:\n            try:\n                msshape = [-1] + coldesc['shape'].tolist()\n            except KeyError as e:\n                msshape = None\n\n        # Otherwise guess it and warn\n        if msshape is None:\n            guessed_shape = [self._manager._nchan, 4]\n\n            montblanc.log.warn(\"Could not obtain 'shape' from the '{c}' \"\n                \"column descriptor. Guessing it is '{gs}'.\".format(\n                    c=column, gs=guessed_shape))\n\n            msshape = [-1] + guessed_shape\n\n        lrow, urow = MS.row_extents(context)\n\n        self._manager.ordered_main_table.putcol(column,\n            context.data.reshape(msshape),\n            startrow=lrow, nrow=urow-lrow)", "response": "Model the visibility of the specified entry in the main table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform any logic on solution start", "response": "def start(self, start_context):\n        \"\"\" Perform any logic on solution start \"\"\"\n        for p in self._providers:\n            p.start(start_context)\n\n        if self._clear_start:\n            self.clear_cache()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform any logic on solution stop", "response": "def stop(self, stop_context):\n        \"\"\" Perform any logic on solution stop \"\"\"\n        for p in self._providers:\n            p.stop(stop_context)\n\n        if self._clear_stop:\n            self.clear_cache()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_base_ant_pairs(self, context):\n    k = 0 if context.cfg['auto_correlations'] == True else 1\n    na = context.dim_global_size('na')\n    gen = (i.astype(context.dtype) for i in np.triu_indices(na, k))\n\n    # Cache np.triu_indices(na, k) as its likely that (na, k) will\n    # stay constant much of the time. Assumption here is that this\n    # method will be grafted onto a DefaultsSourceProvider with\n    # the appropriate members.\n    if self._is_cached:\n        array_cache = self._chunk_cache['default_base_ant_pairs']\n        key = (k, na)\n\n        # Cache miss\n        if key not in array_cache:\n            array_cache[key] = tuple(gen)\n\n        return array_cache[key]\n\n    return tuple(gen)", "response": "Compute base antenna pairs for a given context."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef identity_on_pols(self, context):\n    A = np.empty(context.shape, context.dtype)\n    A[:,:,:] = [[[1,0,0,1]]]\n    return A", "response": "This function returns an array that is the identity matrix for each of the pols in the context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef default_stokes(self, context):\n    A = np.empty(context.shape, context.dtype)\n    A[:,:,:] = [[[1,0,0,0]]]\n    return A", "response": "Default Stokes method for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef frequency(self, context):\n        channels = self._manager.spectral_window_table.getcol(MS.CHAN_FREQ)\n        return channels.reshape(context.shape).astype(context.dtype)", "response": "Return the frequency data source"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ref_frequency(self, context):\n        num_chans = self._manager.spectral_window_table.getcol(MS.NUM_CHAN)\n        ref_freqs = self._manager.spectral_window_table.getcol(MS.REF_FREQUENCY)\n\n        data = np.hstack((np.repeat(rf, bs) for bs, rf in zip(num_chans, ref_freqs)))\n        return data.reshape(context.shape).astype(context.dtype)", "response": "Return the reference frequency data source"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the UVW data for the current antenna.", "response": "def uvw(self, context):\n        \"\"\" Per-antenna UVW coordinate data source \"\"\"\n\n        # Hacky access of private member\n        cube = context._cube\n\n        # Create antenna1 source context\n        a1_actual = cube.array(\"antenna1\", reify=True)\n        a1_ctx = SourceContext(\"antenna1\", cube, context.cfg,\n            context.iter_args, cube.array(\"antenna1\"),\n            a1_actual.shape, a1_actual.dtype)\n\n        # Create antenna2 source context\n        a2_actual = cube.array(\"antenna2\", reify=True)\n        a2_ctx = SourceContext(\"antenna2\", cube, context.cfg,\n            context.iter_args, cube.array(\"antenna2\"),\n            a2_actual.shape, a2_actual.dtype)\n\n        # Get antenna1 and antenna2 data\n        ant1 = self.antenna1(a1_ctx).ravel()\n        ant2 = self.antenna2(a2_ctx).ravel()\n\n        # Obtain per baseline UVW data\n        lrow, urow = MS.uvw_row_extents(context)\n        uvw = self._manager.ordered_uvw_table.getcol(MS.UVW,\n                                                startrow=lrow,\n                                                nrow=urow-lrow)\n\n        # Perform the per-antenna UVW decomposition\n        ntime, nbl = context.dim_extent_size('ntime', 'nbl')\n        na = context.dim_global_size('na')\n        chunks = np.repeat(nbl, ntime).astype(ant1.dtype)\n\n        auvw = mbu.antenna_uvw(uvw, ant1, ant2, chunks, nr_of_antenna=na)\n\n        return auvw.reshape(context.shape).astype(context.dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nobserves visibility data source", "response": "def observed_vis(self, context):\n        \"\"\" Observed visibility data source \"\"\"\n        lrow, urow = MS.row_extents(context)\n\n        data = self._manager.ordered_main_table.getcol(\n            self._vis_column, startrow=lrow, nrow=urow-lrow)\n\n        return data.reshape(context.shape).astype(context.dtype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the tensorflow library", "response": "def load_tf_lib():\n    \"\"\" Load the tensorflow library \"\"\"\n    from os.path import join as pjoin\n    import pkg_resources\n\n    import tensorflow as tf\n\n    path = pjoin('ext', 'rime.so')\n    rime_lib_path = pkg_resources.resource_filename(\"montblanc\", path)\n    return tf.load_op_library(rime_lib_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nraising an exception if any of the errors occurred on the validator.", "response": "def raise_validator_errors(validator):\n    \"\"\"\n    Raise any errors associated with the validator.\n\n    Parameters\n    ----------\n    validator : :class:`cerberus.Validator`\n        Validator\n\n    Raises\n    ------\n    ValueError\n        Raised if errors existed on `validator`.\n        Message describing each error and information\n        associated with the configuration option\n        causing the error.\n    \"\"\"\n\n    if len(validator._errors) == 0:\n        return\n\n    def _path_str(path, name=None):\n        \"\"\" String of the document/schema path. `cfg[\"foo\"][\"bar\"]` \"\"\"\n        L = [name] if name is not None else []\n        L.extend('[\"%s\"]' % p for p in path)\n        return \"\".join(L)\n\n    def _path_leaf(path, dicts):\n        \"\"\" Dictionary Leaf of the schema/document given the path \"\"\"\n        for p in path:\n            dicts = dicts[p]\n\n        return dicts\n\n    wrap = partial(textwrap.wrap, initial_indent=' '*4,\n                                subsequent_indent=' '*8)\n\n    msg = [\"There were configuration errors:\"]\n\n    for e in validator._errors:\n        schema_leaf = _path_leaf(e.document_path, validator.schema)\n        doc_str = _path_str(e.document_path, \"cfg\")\n\n        msg.append(\"Invalid configuration option %s == '%s'.\" % (doc_str, e.value))\n\n        try:\n            otype = schema_leaf[\"type\"]\n            msg.extend(wrap(\"Type must be '%s'.\" % otype))\n        except KeyError:\n            pass\n\n        try:\n            allowed = schema_leaf[\"allowed\"]\n            msg.extend(wrap(\"Allowed values are '%s'.\" % allowed))\n        except KeyError:\n            pass\n\n        try:\n            description = schema_leaf[\"__description__\"]\n            msg.extend(wrap(\"Description: %s\" % description))\n        except KeyError:\n            pass\n\n    raise ValueError(\"\\n\".join(msg))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef indented(text, level, indent=2):\n    return \"\\n\".join(\"%s%s\" % (level * indent * \" \", s) for s in text.splitlines())", "response": "Take a multiline text and indent it as a block"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dumped(text, level, indent=2):\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "response": "Put curly brackets round an indented text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy_file(\n    source_path,\n    target_path,\n    allow_undo=True,\n    no_confirm=False,\n    rename_on_collision=True,\n    silent=False,\n    extra_flags=0,\n    hWnd=None\n):\n    \"\"\"Perform a shell-based file copy. Copying in\n    this way allows the possibility of undo, auto-renaming,\n    and showing the \"flying file\" animation during the copy.\n\n    The default options allow for undo, don't automatically\n    clobber on a name clash, automatically rename on collision\n    and display the animation.\n    \"\"\"\n    return _file_operation(\n        shellcon.FO_COPY,\n        source_path,\n        target_path,\n        allow_undo,\n        no_confirm,\n        rename_on_collision,\n        silent,\n        extra_flags,\n        hWnd\n    )", "response": "Perform a shell - based file copy."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a shell - based file move.", "response": "def move_file(\n    source_path,\n    target_path,\n    allow_undo=True,\n    no_confirm=False,\n    rename_on_collision=True,\n    silent=False,\n    extra_flags=0,\n    hWnd=None\n):\n    \"\"\"Perform a shell-based file move. Moving in\n    this way allows the possibility of undo, auto-renaming,\n    and showing the \"flying file\" animation during the copy.\n\n    The default options allow for undo, don't automatically\n    clobber on a name clash, automatically rename on collision\n    and display the animation.\n    \"\"\"\n    return _file_operation(\n        shellcon.FO_MOVE,\n        source_path,\n        target_path,\n        allow_undo,\n        no_confirm,\n        rename_on_collision,\n        silent,\n        extra_flags,\n        hWnd\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rename_file(\n    source_path,\n    target_path,\n    allow_undo=True,\n    no_confirm=False,\n    rename_on_collision=True,\n    silent=False,\n    extra_flags=0,\n    hWnd=None\n):\n    \"\"\"Perform a shell-based file rename. Renaming in\n    this way allows the possibility of undo, auto-renaming,\n    and showing the \"flying file\" animation during the copy.\n\n    The default options allow for undo, don't automatically\n    clobber on a name clash, automatically rename on collision\n    and display the animation.\n    \"\"\"\n    return _file_operation(\n        shellcon.FO_RENAME,\n        source_path,\n        target_path,\n        allow_undo,\n        no_confirm,\n        rename_on_collision,\n        silent,\n        extra_flags,\n        hWnd\n    )", "response": "Perform a shell - based file rename."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms a shell - based file delete.", "response": "def delete_file(\n    source_path,\n    allow_undo=True,\n    no_confirm=False,\n    silent=False,\n    extra_flags=0,\n    hWnd=None\n):\n    \"\"\"Perform a shell-based file delete. Deleting in\n    this way uses the system recycle bin, allows the\n    possibility of undo, and showing the \"flying file\"\n    animation during the delete.\n\n    The default options allow for undo, don't automatically\n    clobber on a name clash and display the animation.\n    \"\"\"\n    return _file_operation(\n        shellcon.FO_DELETE,\n        source_path,\n        None,\n        allow_undo,\n        no_confirm,\n        False,\n        silent,\n        extra_flags,\n        hWnd\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npick out info from MS documents with embedded structured storage", "response": "def structured_storage(filename):\n    \"\"\"Pick out info from MS documents with embedded\n     structured storage(typically MS Word docs etc.)\n\n    Returns a dictionary of information found\n    \"\"\"\n\n    if not pythoncom.StgIsStorageFile(filename):\n        return {}\n\n    flags = storagecon.STGM_READ | storagecon.STGM_SHARE_EXCLUSIVE\n    storage = pythoncom.StgOpenStorage(filename, None, flags)\n    try:\n        properties_storage = storage.QueryInterface(pythoncom.IID_IPropertySetStorage)\n    except pythoncom.com_error:\n        return {}\n\n    property_sheet = properties_storage.Open(FMTID_USER_DEFINED_PROPERTIES)\n    try:\n        data = property_sheet.ReadMultiple(PROPERTIES)\n    finally:\n        property_sheet = None\n\n    title, subject, author, created_on, keywords, comments, template_used, \\\n     updated_by, edited_on, printed_on, saved_on, \\\n     n_pages, n_words, n_characters, \\\n     application = data\n\n    result = {}\n    if title:\n        result['title'] = title\n    if subject:\n        result['subject'] = subject\n    if author:\n        result['author'] = author\n    if created_on:\n        result['created_on'] = created_on\n    if keywords:\n        result['keywords'] = keywords\n    if comments:\n        result['comments'] = comments\n    if template_used:\n        result['template_used'] = template_used\n    if updated_by:\n        result['updated_by'] = updated_by\n    if edited_on:\n        result['edited_on'] = edited_on\n    if printed_on:\n        result['printed_on'] = printed_on\n    if saved_on:\n        result['saved_on'] = saved_on\n    if n_pages:\n        result['n_pages'] = n_pages\n    if n_words:\n        result['n_words'] = n_words\n    if n_characters:\n        result['n_characters'] = n_characters\n    if application:\n        result['application'] = application\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef CreateShortcut(Path, Target, Arguments=\"\", StartIn=\"\", Icon=(\"\", 0), Description=\"\"):\n    lnk = shortcut(Target)\n    lnk.arguments = Arguments\n    lnk.working_directory = StartIn\n    lnk.icon_location = Icon\n    lnk.description = Description\n    lnk.write(Path)", "response": "Create a Windows shortcut."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef undelete(self, original_filepath):\n        candidates = self.versions(original_filepath)\n        if not candidates:\n            raise x_not_found_in_recycle_bin(\"%s not found in the Recycle Bin\" % original_filepath)\n        #\n        # NB Can't use max(key=...) until Python 2.6+\n        #\n        newest = sorted(candidates, key=lambda entry: entry.recycle_date())[-1]\n        return newest.undelete()", "response": "Restore the most recent version of a filepath returning\n        the filepath it was restored to"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a list of arrays to feed in fed_arrays return a list of queue types obtained from tuples in the data_sources dictionary", "response": "def _get_queue_types(fed_arrays, data_sources):\n    \"\"\"\n    Given a list of arrays to feed in fed_arrays, return\n    a list of associated queue types, obtained from tuples\n    in the data_sources dictionary\n    \"\"\"\n    try:\n        return [data_sources[n].dtype for n in fed_arrays]\n    except KeyError as e:\n        raise ValueError(\"Array '{k}' has no data source!\"\n            .format(k=e.message)), None, sys.exc_info()[2]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a queue wrapper for a single input sequence of items.", "response": "def create_queue_wrapper(name, queue_size, fed_arrays, data_sources, *args, **kwargs):\n    \"\"\"\n    Arguments\n        name: string\n            Name of the queue\n        queue_size: integer\n            Size of the queue\n        fed_arrays: list\n            array names that will be fed by this queue\n        data_sources: dict\n            (lambda/method, dtype) tuples, keyed on array names\n\n    \"\"\"\n\n    qtype = SingleInputMultiQueueWrapper if 'count' in kwargs else QueueWrapper\n    return qtype(name, queue_size, fed_arrays, data_sources, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a string containing assignment statements containing python literals or builtin functions and returns a dictionary containing the names of the variables and values of the functions.", "response": "def parse_python_assigns(assign_str):\n    \"\"\"\n    Parses a string, containing assign statements\n    into a dictionary.\n\n    .. code-block:: python\n\n        h5 = katdal.open('123456789.h5')\n        kwargs = parse_python_assigns(\"spw=3; scans=[1,2];\"\n                                      \"targets='bpcal,radec';\"\n                                      \"channels=slice(0,2048)\")\n        h5.select(**kwargs)\n\n    Parameters\n    ----------\n    assign_str: str\n        Assignment string. Should only contain assignment statements\n        assigning python literals or builtin function calls, to variable names.\n        Multiple assignment statements should be separated by semi-colons.\n\n    Returns\n    -------\n    dict\n        Dictionary { name: value } containing\n        assignment results.\n    \"\"\"\n\n\n    if not assign_str:\n        return {}\n\n    def _eval_value(stmt_value):\n        # If the statement value is a call to a builtin, try evaluate it\n        if isinstance(stmt_value, ast.Call):\n            func_name = stmt_value.func.id\n\n            if func_name not in _BUILTIN_WHITELIST:\n                raise ValueError(\"Function '%s' in '%s' is not builtin. \"\n                                 \"Available builtins: '%s'\"\n                                    % (func_name, assign_str, list(_BUILTIN_WHITELIST)))\n\n            # Recursively pass arguments through this same function\n            if stmt_value.args is not None:\n                args = tuple(_eval_value(a) for a in stmt_value.args)\n            else:\n                args = ()\n\n            # Recursively pass keyword arguments through this same function\n            if stmt_value.keywords is not None:\n                kwargs = {kw.arg : _eval_value(kw.value) for kw\n                                          in stmt_value.keywords}\n            else:\n                kwargs = {}\n\n            return getattr(__builtin__, func_name)(*args, **kwargs)\n        # Try a literal eval\n        else:\n            return ast.literal_eval(stmt_value)\n\n    # Variable dictionary\n    variables = {}\n\n    # Parse the assignment string\n    stmts = ast.parse(assign_str, mode='single').body\n\n    for i, stmt in enumerate(stmts):\n        if not isinstance(stmt, ast.Assign):\n            raise ValueError(\"Statement %d in '%s' is not a \"\n                             \"variable assignment.\" % (i, assign_str))\n\n        # Evaluate assignment lhs\n        values = _eval_value(stmt.value)\n\n        # \"a = b = c\" => targets 'a' and 'b' with 'c' as result\n        for target in stmt.targets:\n            # a = 2\n            if isinstance(target, ast.Name):\n                variables[target.id] = values\n\n            # Tuple/List unpacking case\n            # (a, b) = 2\n            elif isinstance(target, (ast.Tuple, ast.List)):\n                # Require all tuple/list elements to be variable names,\n                # although anything else is probably a syntax error\n                if not all(isinstance(e, ast.Name) for e in target.elts):\n                    raise ValueError(\"Tuple unpacking in assignment %d \"\n                                     \"in expression '%s' failed as not all \"\n                                     \"tuple contents are variable names.\")\n\n                # Promote for zip and length checking\n                if not isinstance(values, (tuple, list)):\n                    elements = (values,)\n                else:\n                    elements = values\n\n                if not len(target.elts) == len(elements):\n                    raise ValueError(\"Unpacking '%s' into a tuple/list in \"\n                                     \"assignment %d of expression '%s' failed. \"\n                                     \"The number of tuple elements did not match \"\n                                     \"the number of values.\"\n                                        % (values, i, assign_str))\n\n                # Unpack\n                for variable, value in zip(target.elts, elements):\n                    variables[variable.id] = value\n            else:\n                raise TypeError(\"'%s' types are not supported\"\n                                \"as assignment targets.\" % type(target))\n\n\n    return variables"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_sinks(obj):\n    SINK_ARGSPEC = ['self', 'context']\n\n    return { n: m for n, m in inspect.getmembers(obj, inspect.ismethod)\n        if inspect.getargspec(m)[0] == SINK_ARGSPEC }", "response": "Find sink methods on this object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sinks(self):\n\n        try:\n            return self._sinks\n        except AttributeError:\n            self._sinks = find_sinks(self)\n\n        return self._sinks", "response": "Returns a dictionary of sink methods that are defined on this object keyed on method name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _antenna_uvw(uvw, antenna1, antenna2, chunks, nr_of_antenna):\n\n    if antenna1.ndim != 1:\n        raise ValueError(\"antenna1 shape should be (row,)\")\n\n    if antenna2.ndim != 1:\n        raise ValueError(\"antenna2 shape should be (row,)\")\n\n    if uvw.ndim != 2 or uvw.shape[1] != 3:\n        raise ValueError(\"uvw shape should be (row, 3)\")\n\n    if not (uvw.shape[0] == antenna1.shape[0] == antenna2.shape[0]):\n        raise ValueError(\"First dimension of uvw, antenna1 \"\n                         \"and antenna2 do not match\")\n\n    if chunks.ndim != 1:\n        raise ValueError(\"chunks shape should be (utime,)\")\n\n    if nr_of_antenna < 1:\n        raise ValueError(\"nr_of_antenna < 1\")\n\n    ant_uvw_shape = (chunks.shape[0], nr_of_antenna, 3)\n    antenna_uvw = np.full(ant_uvw_shape, np.nan, dtype=uvw.dtype)\n\n    start = 0\n\n    for ci, chunk in enumerate(chunks):\n        end = start + chunk\n\n        # one pass should be enough!\n        _antenna_uvw_loop(uvw, antenna1, antenna2, antenna_uvw, ci, start, end)\n\n        start = end\n\n    return antenna_uvw", "response": "Generate antenna_uvw from antenna1 and antenna2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nraising informative exception for an invalid decomposition", "response": "def _raise_decomposition_errors(uvw, antenna1, antenna2,\n                                chunks, ant_uvw, max_err):\n    \"\"\" Raises informative exception for an invalid decomposition \"\"\"\n\n    start = 0\n\n    problem_str = []\n\n    for ci, chunk in enumerate(chunks):\n        end = start + chunk\n\n        ant1 = antenna1[start:end]\n        ant2 = antenna2[start:end]\n        cuvw = uvw[start:end]\n\n        ant1_uvw = ant_uvw[ci, ant1, :]\n        ant2_uvw = ant_uvw[ci, ant2, :]\n        ruvw = ant2_uvw - ant1_uvw\n\n        # Identifty rows where any of the UVW components differed\n        close = np.isclose(ruvw, cuvw)\n        problems = np.nonzero(np.logical_or.reduce(np.invert(close), axis=1))\n\n        for row in problems[0]:\n            problem_str.append(\"[row %d [%d, %d] (chunk %d)]: \"\n                               \"original %s recovered %s \"\n                               \"ant1 %s ant2 %s\" % (\n                                    start+row, ant1[row], ant2[row], ci,\n                                    cuvw[row], ruvw[row],\n                                    ant1_uvw[row], ant2_uvw[row]))\n\n            # Exit inner loop early\n            if len(problem_str) >= max_err:\n                break\n\n        # Exit outer loop early\n        if len(problem_str) >= max_err:\n            break\n\n        start = end\n\n    # Return early if nothing was wrong\n    if len(problem_str) == 0:\n        return\n\n    # Add a preamble and raise exception\n    problem_str = [\"Antenna UVW Decomposition Failed\",\n                   \"The following differences were found \"\n                   \"(first 100):\"] + problem_str\n    raise AntennaUVWDecompositionError('\\n'.join(problem_str))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _raise_missing_antenna_errors(ant_uvw, max_err):\n\n    # Find antenna uvw coordinates where any UVW component was nan\n    # nan + real == nan\n    problems = np.nonzero(np.add.reduce(np.isnan(ant_uvw), axis=2))\n    problem_str = []\n\n    for c, a in zip(*problems):\n        problem_str.append(\"[chunk %d antenna %d]\" % (c, a))\n\n        # Exit early\n        if len(problem_str) >= max_err:\n            break\n\n    # Return early if nothing was wrong\n    if len(problem_str) == 0:\n        return\n\n    # Add a preamble and raise exception\n    problem_str = [\"Antenna were missing\"] + problem_str\n    raise AntennaMissingError('\\n'.join(problem_str))", "response": "Raises an informative error for missing antenna."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef antenna_uvw(uvw, antenna1, antenna2, chunks,\n                nr_of_antenna, check_missing=False,\n                check_decomposition=False, max_err=100):\n    \"\"\"\n    Computes per-antenna UVW coordinates from baseline ``uvw``,\n    ``antenna1`` and ``antenna2`` coordinates logically grouped\n    into baseline chunks.\n\n    The example below illustrates two baseline chunks\n    of size 6 and 5, respectively.\n\n    .. code-block:: python\n\n        uvw = ...\n        ant1 = np.array([0, 0, 0, 1, 1, 2, 0, 0, 0, 1, 1], dtype=np.int32)\n        ant2 = np.array([1, 2, 3, 2, 3, 3, 1, 2, 3, 1, 2], dtype=np.int32)\n        chunks = np.array([6, 5], dtype=np.int32)\n\n        ant_uv = antenna_uvw(uvw, ant1, ant2, chunks, nr_of_antenna=4)\n\n    The first antenna of the first baseline of a chunk is chosen as the origin\n    of the antenna coordinate system, while the second antenna is set to the\n    negative of the baseline UVW coordinate. Subsequent antenna UVW coordinates\n    are iteratively derived from the first two coordinates. Thus,\n    the baseline indices need not be properly ordered (within the chunk).\n\n    If it is not possible to derive coordinates for an antenna,\n    it's coordinate will be set to nan.\n\n    Parameters\n    ----------\n    uvw : np.ndarray\n        Baseline UVW coordinates of shape (row, 3)\n    antenna1 : np.ndarray\n        Baseline first antenna of shape (row,)\n    antenna2 : np.ndarray\n        Baseline second antenna of shape (row,)\n    chunks : np.ndarray\n        Number of baselines per unique timestep with shape (chunks,)\n        :code:`np.sum(chunks) == row` should hold.\n    nr_of_antenna : int\n        Total number of antenna in the solution.\n    check_missing (optional) : bool\n        If ``True`` raises an exception if it was not possible\n        to compute UVW coordinates for all antenna (i.e. some were nan).\n        Defaults to ``False``.\n    check_decomposition (optional) : bool\n        If ``True``, checks that the antenna decomposition accurately\n        reproduces the coordinates in ``uvw``, or that\n        :code:`ant_uvw[c,ant1,:] - ant_uvw[c,ant2,:] == uvw[s:e,:]`\n        where ``s`` and ``e`` are the start and end rows\n        of chunk ``c`` respectively. Defaults to ``False``.\n    max_err (optional) : integer\n        Maximum numbers of errors when checking for missing antenna\n        or innacurate decompositions. Defaults to ``100``.\n\n    Returns\n    -------\n    np.ndarray\n        Antenna UVW coordinates of shape (chunks, nr_of_antenna, 3)\n    \"\"\"\n\n    ant_uvw = _antenna_uvw(uvw, antenna1, antenna2, chunks, nr_of_antenna)\n\n    if check_missing:\n        _raise_missing_antenna_errors(ant_uvw, max_err=max_err)\n\n    if check_decomposition:\n        _raise_decomposition_errors(uvw, antenna1, antenna2, chunks,\n                                    ant_uvw, max_err=max_err)\n\n    return ant_uvw", "response": "Computes per - antenna UVW coordinates from baseline antenna1 and antenna2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef default_sources(**kwargs):\n    S = OrderedDict()\n    total = 0\n\n    invalid_types = [t for t in kwargs.keys() if t not in SOURCE_VAR_TYPES]\n\n    for t in invalid_types:\n        montblanc.log.warning('Source type %s is not yet '\n            'implemented in montblanc. '\n            'Valid source types are %s' % (t, SOURCE_VAR_TYPES.keys()))\n\n    # Zero all source types\n    for k, v in SOURCE_VAR_TYPES.iteritems():\n        # Try get the number of sources for this source\n        # from the kwargs\n        value = kwargs.get(k, 0)\n\n        try:\n            value = int(value)\n        except ValueError:\n            raise TypeError(('Supplied value %s '\n                'for source %s cannot be '\n                'converted to an integer') % \\\n                    (value, k))\n\n        total += value\n        S[k] = value\n\n    # Add a point source if no others exist\n    if total == 0:\n        S[POINT_TYPE] = 1\n\n    return S", "response": "Returns a dictionary mapping source types\n    to number of sources."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sources_to_nr_vars(sources):\n\n    sources = default_sources(**sources)\n\n    try:\n        return OrderedDict((SOURCE_VAR_TYPES[name], nr)\n            for name, nr in sources.iteritems())\n    except KeyError as e:\n        raise KeyError((\n            'No source type ''%s'' is '\n            'registered. Valid source types '\n            'are %s') % (e, SOURCE_VAR_TYPES.keys()))", "response": "Converts a source type to number of sources mapping into a base base"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a range of source numbers and a dictionary containing the numbers of each source returns a dictionary containing the start and end indices of each source variable type and the number of each source variable type.", "response": "def source_range_tuple(start, end, nr_var_dict):\n    \"\"\"\n    Given a range of source numbers, as well as a dictionary\n    containing the numbers of each source, returns a dictionary\n    containing tuples of the start and end index\n    for each source variable type.\n    \"\"\"\n\n    starts = np.array([0 for nr_var in SOURCE_VAR_TYPES.itervalues()])\n    ends = np.array([nr_var_dict[nr_var] if nr_var in nr_var_dict else 0\n        for nr_var in SOURCE_VAR_TYPES.itervalues()])\n    sum_counts = np.cumsum(ends)\n    idx = np.arange(len(starts))\n\n    # Find the intervals containing the\n    # start and ending indices\n    start_idx, end_idx = np.searchsorted(\n        sum_counts, [start, end], side='right')\n\n    # Handle edge cases\n    if end >= sum_counts[-1]:\n        end = sum_counts[-1]\n        end_idx = len(sum_counts) - 1\n\n    # Find out which variable counts fall within the range\n    # of the supplied indices and zero those outside this range\n    invalid = np.logical_not(np.logical_and(start_idx <= idx, idx <= end_idx))\n    starts[invalid] = ends[invalid] = 0\n\n    # Modify the associated starting and ending positions\n    starts[start_idx] = start\n    ends[end_idx] = end\n\n    if start >= sum_counts[0]:\n        starts[start_idx] -= sum_counts[start_idx-1]\n\n    if end >= sum_counts[0]:\n        ends[end_idx] -= sum_counts[end_idx-1]\n\n    return OrderedDict((n, (starts[i], ends[i]))\n        for i, n in enumerate(SOURCE_VAR_TYPES.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef source_range(start, end, nr_var_dict):\n\n    return OrderedDict((k, e-s)\n        for k, (s, e)\n        in source_range_tuple(start, end, nr_var_dict).iteritems())", "response": "Given a range of source numbers and a dictionary containing the numbers of each source returns a dictionary containing the numbers of each source and the number of each source variable type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a range of source numbers and a dictionary containing the numbers of each source variable type returns a dictionary containing the slices for each source variable type.", "response": "def source_range_slices(start, end, nr_var_dict):\n    \"\"\"\n    Given a range of source numbers, as well as a dictionary\n    containing the numbers of each source, returns a dictionary\n    containing slices for each source variable type.\n    \"\"\"\n\n    return OrderedDict((k, slice(s,e,1))\n        for k, (s, e)\n        in source_range_tuple(start, end, nr_var_dict).iteritems())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef point_lm(self, context):\n        lm = np.empty(context.shape, context.dtype)\n\n        # Print the array schema\n        montblanc.log.info(context.array_schema.shape)\n        # Print the space of iteration\n        montblanc.log.info(context.iter_args)\n\n        (ls, us) = context.dim_extents('npsrc')\n\n        lm[:,0] = 0.0008\n        lm[:,1] = 0.0036\n\n        lm[:,:] = 0\n        return lm", "response": "Return a lm coordinate array to montblanc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a stokes parameter array to montblanc", "response": "def point_stokes(self, context):\n        \"\"\" Return a stokes parameter array to montblanc \"\"\"\n        stokes = np.empty(context.shape, context.dtype)\n        stokes[:,:,0] = 1\n        stokes[:,:,1:4] = 0\n        return stokes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a reference frequency array to montblanc", "response": "def ref_frequency(self, context):\n        \"\"\" Return a reference frequency array to montblanc \"\"\"\n        ref_freq = np.empty(context.shape, context.dtype)\n        ref_freq[:] = 1.415e9\n\n        return ref_freq"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, scopes=[], add_scopes=[], rm_scopes=[], note='',\n               note_url=''):\n        \"\"\"Update this authorization.\n\n        :param list scopes: (optional), replaces the authorization scopes with\n            these\n        :param list add_scopes: (optional), scopes to be added\n        :param list rm_scopes: (optional), scopes to be removed\n        :param str note: (optional), new note about authorization\n        :param str note_url: (optional), new note URL about this authorization\n        :returns: bool\n\n        \"\"\"\n        success = False\n        json = None\n        if scopes:\n            d = {'scopes': scopes}\n            json = self._json(self._post(self._api, data=d), 200)\n        if add_scopes:\n            d = {'add_scopes': add_scopes}\n            json = self._json(self._post(self._api, data=d), 200)\n        if rm_scopes:\n            d = {'remove_scopes': rm_scopes}\n            json = self._json(self._post(self._api, data=d), 200)\n        if note or note_url:\n            d = {'note': note, 'note_url': note_url}\n            json = self._json(self._post(self._api, data=d), 200)\n\n        if json:\n            self._update_(json)\n            success = True\n\n        return success", "response": "Update this authorization.\n\n        :param list scopes: (optional), replaces the authorization scopes with\n            these\n        :param list add_scopes: (optional), scopes to be added\n        :param list rm_scopes: (optional), scopes to be removed\n        :param str note: (optional), new note about authorization\n        :param str note_url: (optional), new note URL about this authorization\n        :returns: bool"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over the labels for every issue associated with this .", "response": "def iter_labels(self, number=-1, etag=None):\n        \"\"\"Iterate over the labels for every issue associated with this\n        milestone.\n\n        .. versionchanged:: 0.9\n\n            Add etag parameter.\n\n        :param int number: (optional), number of labels to return. Default: -1\n            returns all available labels.\n        :param str etag: (optional), ETag header from a previous response\n        :returns: generator of :class:`Label <github3.issues.label.Label>`\\ s\n        \"\"\"\n        url = self._build_url('labels', base_url=self._api)\n        return self._iter(int(number), url, Label, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef current_function(frame):\n\n    if frame is None:\n        return None\n\n    code = frame.f_code\n    # Attempting to extract the function reference for these calls appears\n    # to be problematic\n    if code.co_name == '__del__' or code.co_name == '_remove' or \\\n       code.co_name == '_removeHandlerRef':\n        return None\n\n    try:\n        # Solution follows suggestion at http://stackoverflow.com/a/37099372\n        lst = [referer for referer in gc.get_referrers(code)\n               if getattr(referer, \"__code__\", None) is code and\n               inspect.getclosurevars(referer).nonlocals.items() <=\n               frame.f_locals.items()]\n        if lst:\n            return lst[0]\n        else:\n            return None\n    except ValueError:\n        # inspect.getclosurevars can fail with ValueError: Cell is empty\n        return None", "response": "Returns the currently running function that is currently running in the stack frame."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the name of the currently running function in the stack frame.", "response": "def current_module_name(frame):\n    \"\"\"\n    Get name of module of currently running function from inspect/trace\n    stack frame.\n\n    Parameters\n    ----------\n    frame : stack frame\n      Stack frame obtained via trace or inspect\n\n    Returns\n    -------\n    modname : string\n      Currently running function module name\n    \"\"\"\n\n    if frame is None:\n        return None\n\n    if hasattr(frame.f_globals, '__name__'):\n        return frame.f_globals['__name__']\n    else:\n        mod = inspect.getmodule(frame)\n        if mod is None:\n            return ''\n        else:\n            return mod.__name__"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a record of called functions using the trace mechanism.", "response": "def _trace(self, frame, event, arg):\n        \"\"\"\n        Build a record of called functions using the trace mechanism\n        \"\"\"\n\n        # Return if this is not a function call\n        if event != 'call':\n            return\n\n        # Filter calling and called functions by module names\n        src_mod = current_module_name(frame.f_back)\n        dst_mod = current_module_name(frame)\n\n        # Avoid tracing the tracer (specifically, call from\n        # ContextCallTracer.__exit__ to CallTracer.stop)\n        if src_mod == __modulename__ or dst_mod == __modulename__:\n            return\n\n        # Apply source and destination module filters\n        if not self.srcmodflt.match(src_mod):\n            return\n        if not self.dstmodflt.match(dst_mod):\n            return\n\n        # Get calling and called functions\n        src_func = current_function(frame.f_back)\n        dst_func = current_function(frame)\n\n        # Filter calling and called functions by qnames\n        if not self.srcqnmflt.match(function_qname(src_func)):\n            return\n        if not self.dstqnmflt.match(function_qname(dst_func)):\n            return\n\n        # Get calling and called function full names\n        src_name = function_fqname(src_func)\n        dst_name = function_fqname(dst_func)\n\n        # Modify full function names if necessary\n        if self.fnmsub is not None:\n            src_name = re.sub(self.fnmsub[0], self.fnmsub[1], src_name)\n            dst_name = re.sub(self.fnmsub[0], self.fnmsub[1], dst_name)\n\n        # Update calling function count\n        if src_func is not None:\n            if src_name in self.fncts:\n                self.fncts[src_name][0] += 1\n            else:\n                self.fncts[src_name] = [1, 0]\n\n        # Update called function count\n        if dst_func is not None and src_func is not None:\n            if dst_name in self.fncts:\n                self.fncts[dst_name][1] += 1\n            else:\n                self.fncts[dst_name] = [0, 1]\n\n        # Update caller/calling pair count\n        if dst_func is not None and src_func is not None:\n            key = (src_name, dst_name)\n            if key in self.calls:\n                self.calls[key] += 1\n            else:\n                self.calls[key] = 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop(self):\n\n        # Stop tracing\n        sys.settrace(None)\n\n        # Build group structure if group filter is defined\n        if self.grpflt is not None:\n            # Iterate over graph nodes (functions)\n            for k in self.fncts:\n                # Construct group identity string\n                m = self.grpflt.search(k)\n                # If group identity string found, append current node\n                # to that group\n                if m is not None:\n                    ms = m.group(0)\n                    if ms in self.group:\n                        self.group[ms].append(k)\n                    else:\n                        self.group[ms] = [k, ]", "response": "Stop tracing and build group structure if necessary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndefaulting colour generating function for the set of colours in the cache", "response": "def _clrgen(n, h0, hr):\n        \"\"\"Default colour generating function\n\n        Parameters\n        ----------\n\n        n : int\n          Number of colours to generate\n        h0 : float\n          Initial H value in HSV colour specification\n        hr : float\n          Size of H value range to use for colour generation\n          (final H value is h0 + hr)\n\n        Returns\n        -------\n        clst : list of strings\n          List of HSV format colour specification strings\n        \"\"\"\n\n        n0 = n if n == 1 else n-1\n        clst = ['%f,%f,%f' % (h0 + hr*hi/n0, 0.35, 0.85) for\n                hi in range(n)]\n        return clst"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef graph(self, fnm=None, size=None, fntsz=None, fntfm=None, clrgen=None,\n              rmsz=False, prog='dot'):\n        \"\"\"\n        Construct call graph\n\n        Parameters\n        ----------\n        fnm : None or string, optional (default None)\n          Filename of graph file to be written. File type is determined by\n          the file extentions (e.g. dot for 'graph.dot' and SVG for\n          'graph.svg'). If None, a file is not written.\n        size : string or None, optional (default None)\n          Graph image size specification string.\n        fntsz : int or None, optional (default None)\n          Font size for text.\n        fntnm : string or None, optional (default None)\n          Font family specification string.\n        clrgen : function or None, optional (default None)\n          Function to call to generate the group colours. This function\n          should take an integer specifying the number of groups as an\n          argument and return a list of graphviz-compatible colour\n          specification strings.\n        rmsz : bool, optional (default False)\n          If True, remove the width and height specifications from an\n          SVG format output file so that the size scales properly when\n          viewed in a web browser\n        prog : string, optional (default 'dot')\n          Name of graphviz layout program to use.\n\n        Returns\n        -------\n        pgr : pygraphviz.AGraph\n          Call graph of traced function calls\n        \"\"\"\n\n        # Default colour generation function\n        if clrgen is None:\n            clrgen = lambda n: self._clrgen(n, 0.330, 0.825)\n\n        # Generate color list\n        clrlst = clrgen(len(self.group))\n\n        # Initialise a pygraphviz graph\n        g = pgv.AGraph(strict=False, directed=True, landscape=False,\n                       rankdir='LR', newrank=True, fontsize=fntsz,\n                       fontname=fntfm, size=size, ratio='compress',\n                       color='black', bgcolor='#ffffff00')\n        # Set graph attributes\n        g.node_attr.update(penwidth=0.25, shape='box', style='rounded,filled')\n\n        # Iterate over functions adding them as graph nodes\n        for k in self.fncts:\n            g.add_node(k, fontsize=fntsz, fontname=fntfm)\n            # If lnksub regex pair is provided, compute an href link\n            # target from the node name and add it as an attribute to\n            # the node\n            if self.lnksub is not None:\n                lnktgt = re.sub(self.lnksub[0], self.lnksub[1], k)\n                g.get_node(k).attr.update(href=lnktgt, target=\"_top\")\n            # If function has no calls to it, set its rank to \"source\"\n            if self.fncts[k][1] == 0:\n                g.get_node(k).attr.update(rank='source')\n\n        # If groups defined, construct a subgraph for each and add the\n        # nodes in each group to the corresponding subgraph\n        if self.group:\n            fngrpnm = {}\n            # Iterate over group number/group name pairs\n            for k in zip(range(len(self.group)), sorted(self.group)):\n                g.add_subgraph(self.group[k[1]], name='cluster_' + k[1],\n                               label=k[1], penwidth=2, style='dotted',\n                               pencolor=clrlst[k[0]])\n                # Iterate over nodes in current group\n                for l in self.group[k[1]]:\n                    # Create record of function group number\n                    fngrpnm[l] = k[0]\n                    # Set common group colour for current node\n                    g.get_node(l).attr.update(fillcolor=clrlst[k[0]])\n\n        # Iterate over function calls, adding each as an edge\n        for k in self.calls:\n            # If groups defined, set edge colour according to group of\n            # calling function, otherwise set a standard colour\n            if self.group:\n                g.add_edge(k[0], k[1], penwidth=2, color=clrlst[fngrpnm[k[0]]])\n            else:\n                g.add_edge(k[0], k[1], color='grey')\n\n        # Call layout program\n        g.layout(prog=prog)\n\n        # Write graph file if filename provided\n        if fnm is not None:\n            ext = os.path.splitext(fnm)[1]\n            if ext == '.dot':\n                g.write(fnm)\n            else:\n                if ext == '.svg' and rmsz:\n                    img = g.draw(format='svg').decode('utf-8')\n                    cp = re.compile(r'\\n<svg width=\\\"[^\\\"]*\\\" '\n                                    'height=\\\"[^\\\"]*\\\"')\n                    img = cp.sub(r'\\n<svg', img, count=1)\n                    with open(fnm, 'w') as fd:\n                        fd.write(img)\n                else:\n                    g.draw(fnm)\n\n        # Return graph object\n        return g", "response": "Constructs a graphviz. A graphviz object for the current group of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a review comment on this pull request.", "response": "def create_review_comment(self, body, commit_id, path, position):\n        \"\"\"Create a review comment on this pull request.\n\n        All parameters are required by the GitHub API.\n\n        :param str body: The comment text itself\n        :param str commit_id: The SHA of the commit to comment on\n        :param str path: The relative path of the file to comment on\n        :param int position: The line index in the diff to comment on.\n        :returns: The created review comment.\n        :rtype: :class:`~github3.pulls.ReviewComment`\n        \"\"\"\n        url = self._build_url('comments', base_url=self._api)\n        data = {'body': body, 'commit_id': commit_id, 'path': path,\n                'position': int(position)}\n        json = self._json(self._post(url, data=data), 201)\n        return ReviewComment(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the diff of the current repository and the current version of the repository.", "response": "def diff(self):\n        \"\"\"Return the diff\"\"\"\n        resp = self._get(self._api,\n                         headers={'Accept': 'application/vnd.github.diff'})\n        return resp.content if self._boolean(resp, 200, 404) else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_merged(self):\n        url = self._build_url('merge', base_url=self._api)\n        return self._boolean(self._get(url), 204, 404)", "response": "Checks to see if the pull request was merged."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over the comments on this pull request.", "response": "def iter_comments(self, number=-1, etag=None):\n        \"\"\"Iterate over the comments on this pull request.\n\n        :param int number: (optional), number of comments to return. Default:\n            -1 returns all available comments.\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`ReviewComment <ReviewComment>`\\ s\n        \"\"\"\n        url = self._build_url('comments', base_url=self._api)\n        return self._iter(int(number), url, ReviewComment, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over the files associated with this pull request.", "response": "def iter_files(self, number=-1, etag=None):\n        \"\"\"Iterate over the files associated with this pull request.\n\n        :param int number: (optional), number of files to return. Default:\n            -1 returns all available files.\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`PullFile <PullFile>`\\ s\n        \"\"\"\n        url = self._build_url('files', base_url=self._api)\n        return self._iter(int(number), url, PullFile, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_issue_comments(self, number=-1, etag=None):\n        url = self._build_url(base_url=self.links['comments'])\n        return self._iter(int(number), url, IssueComment, etag=etag)", "response": "Iterate over the issue comments on this pull request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging this pull request.", "response": "def merge(self, commit_message='', sha=None):\n        \"\"\"Merge this pull request.\n\n        :param str commit_message: (optional), message to be used for the\n            merge commit\n        :returns: bool\n        \"\"\"\n        parameters = {'commit_message': commit_message}\n        if sha:\n            parameters['sha'] = sha\n        url = self._build_url('merge', base_url=self._api)\n        json = self._json(self._put(url, data=dumps(parameters)), 200)\n        self.merge_commit_sha = json['sha']\n        return json['merged']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the patch of the resource", "response": "def patch(self):\n        \"\"\"Return the patch\"\"\"\n        resp = self._get(self._api,\n                         headers={'Accept': 'application/vnd.github.patch'})\n        return resp.content if self._boolean(resp, 200, 404) else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates this pull request.", "response": "def update(self, title=None, body=None, state=None):\n        \"\"\"Update this pull request.\n\n        :param str title: (optional), title of the pull\n        :param str body: (optional), body of the pull request\n        :param str state: (optional), ('open', 'closed')\n        :returns: bool\n        \"\"\"\n        data = {'title': title, 'body': body, 'state': state}\n        json = None\n        self._remove_none(data)\n\n        if data:\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n\n        if json:\n            self._update_(json)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reply(self, body):\n        url = self._build_url('comments', base_url=self.pull_request_url)\n        index = self._api.rfind('/') + 1\n        in_reply_to = self._api[index:]\n        json = self._json(self._post(url, data={\n            'body': body, 'in_reply_to': in_reply_to\n        }), 201)\n        return ReviewComment(json, self) if json else None", "response": "Reply to this review comment with a new review comment."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a user to this team.", "response": "def add_member(self, login):\n        \"\"\"Add ``login`` to this team.\n\n        :returns: bool\n        \"\"\"\n        warnings.warn(\n            'This is no longer supported by the GitHub API, see '\n            'https://developer.github.com/changes/2014-09-23-one-more-week'\n            '-before-the-add-team-member-api-breaking-change/',\n            DeprecationWarning)\n        url = self._build_url('members', login, base_url=self._api)\n        return self._boolean(self._put(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_repo(self, repo):\n        url = self._build_url('repos', repo, base_url=self._api)\n        return self._boolean(self._put(url), 204, 404)", "response": "Add repo to this team."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef edit(self, name, permission=''):\n        if name:\n            data = {'name': name, 'permission': permission}\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n            if json:\n                self._update_(json)\n                return True\n        return False", "response": "Edit this team s nacmsite."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if this team has access to repo.", "response": "def has_repo(self, repo):\n        \"\"\"Checks if this team has access to ``repo``\n\n        :param str repo: (required), form: 'user/repo'\n        :returns: bool\n        \"\"\"\n        url = self._build_url('repos', repo, base_url=self._api)\n        return self._boolean(self._get(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninvites the user to join this team.", "response": "def invite(self, username):\n        \"\"\"Invite the user to join this team.\n\n        This returns a dictionary like so::\n\n            {'state': 'pending', 'url': 'https://api.github.com/teams/...'}\n\n        :param str username: (required), user to invite to join this team.\n        :returns: dictionary\n        \"\"\"\n        url = self._build_url('memberships', username, base_url=self._api)\n        return self._json(self._put(url), 200)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef membership_for(self, username):\n        url = self._build_url('memberships', username, base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return json or {}", "response": "Retrieve the membership information for the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_member(self, login):\n        warnings.warn(\n            'This is no longer supported by the GitHub API, see '\n            'https://developer.github.com/changes/2014-09-23-one-more-week'\n            '-before-the-add-team-member-api-breaking-change/',\n            DeprecationWarning)\n        url = self._build_url('members', login, base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)", "response": "Removes the login from this team."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef revoke_membership(self, username):\n        url = self._build_url('memberships', username, base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)", "response": "Revoke this user s team membership."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove repo from this team.", "response": "def remove_repo(self, repo):\n        \"\"\"Remove ``repo`` from this team.\n\n        :param str repo: (required), form: 'user/repo'\n        :returns: bool\n        \"\"\"\n        url = self._build_url('repos', repo, base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_member(self, login, team):\n        warnings.warn(\n            'This is no longer supported by the GitHub API, see '\n            'https://developer.github.com/changes/2014-09-23-one-more-week'\n            '-before-the-add-team-member-api-breaking-change/',\n            DeprecationWarning)\n        for t in self.iter_teams():\n            if team == t.name:\n                return t.add_member(login)\n        return False", "response": "Add a user to a team and thereby to this organization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding repo to team.", "response": "def add_repo(self, repo, team):\n        \"\"\"Add ``repo`` to ``team``.\n\n        .. note::\n            This method is of complexity O(n). This iterates over all teams in\n            your organization and only adds the repo when the team name\n            matches the team parameter above. If you want constant time, you\n            should retrieve the team and call ``add_repo`` on that team\n            directly.\n\n        :param str repo: (required), form: 'user/repo'\n        :param str team: (required), team name\n        \"\"\"\n        for t in self.iter_teams():\n            if team == t.name:\n                return t.add_repo(repo)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new repository for this organization if the authenticated user is a member.", "response": "def create_repo(self,\n                    name,\n                    description='',\n                    homepage='',\n                    private=False,\n                    has_issues=True,\n                    has_wiki=True,\n                    has_downloads=True,\n                    team_id=0,\n                    auto_init=False,\n                    gitignore_template=''):\n        \"\"\"Create a repository for this organization if the authenticated user\n        is a member.\n\n        :param str name: (required), name of the repository\n        :param str description: (optional)\n        :param str homepage: (optional)\n        :param bool private: (optional), If ``True``, create a private\n            repository. API default: ``False``\n        :param bool has_issues: (optional), If ``True``, enable issues for\n            this repository. API default: ``True``\n        :param bool has_wiki: (optional), If ``True``, enable the wiki for\n            this repository. API default: ``True``\n        :param bool has_downloads: (optional), If ``True``, enable downloads\n            for this repository. API default: ``True``\n        :param int team_id: (optional), id of the team that will be granted\n            access to this repository\n        :param bool auto_init: (optional), auto initialize the repository.\n        :param str gitignore_template: (optional), name of the template; this\n            is ignored if auto_int = False.\n        :returns: :class:`Repository <github3.repos.Repository>`\n\n        .. warning: ``name`` should be no longer than 100 characters\n        \"\"\"\n        url = self._build_url('repos', base_url=self._api)\n        data = {'name': name, 'description': description,\n                'homepage': homepage, 'private': private,\n                'has_issues': has_issues, 'has_wiki': has_wiki,\n                'has_downloads': has_downloads, 'auto_init': auto_init,\n                'gitignore_template': gitignore_template}\n        if team_id > 0:\n            data.update({'team_id': team_id})\n        json = self._json(self._post(url, data), 201)\n        return Repository(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if login is conceal.", "response": "def conceal_member(self, login):\n        \"\"\"Conceal ``login``'s membership in this organization.\n\n        :returns: bool\n        \"\"\"\n        url = self._build_url('public_members', login, base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassumes the authenticated user owns this organization create and return a new team.", "response": "def create_team(self, name, repo_names=[], permission=''):\n        \"\"\"Assuming the authenticated user owns this organization,\n        create and return a new team.\n\n        :param str name: (required), name to be given to the team\n        :param list repo_names: (optional) repositories, e.g.\n            ['github/dotfiles']\n        :param str permission: (optional), options:\n\n            - ``pull`` -- (default) members can not push or administer\n                repositories accessible by this team\n            - ``push`` -- members can push and pull but not administer\n                repositories accessible by this team\n            - ``admin`` -- members can push, pull and administer\n                repositories accessible by this team\n\n        :returns: :class:`Team <Team>`\n        \"\"\"\n        data = {'name': name, 'repo_names': repo_names,\n                'permission': permission}\n        url = self._build_url('teams', base_url=self._api)\n        json = self._json(self._post(url, data), 201)\n        return Team(json, self._session) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit(self,\n             billing_email=None,\n             company=None,\n             email=None,\n             location=None,\n             name=None):\n        \"\"\"Edit this organization.\n\n        :param str billing_email: (optional) Billing email address (private)\n        :param str company: (optional)\n        :param str email: (optional) Public email address\n        :param str location: (optional)\n        :param str name: (optional)\n        :returns: bool\n        \"\"\"\n        json = None\n        data = {'billing_email': billing_email, 'company': company,\n                'email': email, 'location': location, 'name': name}\n        self._remove_none(data)\n\n        if data:\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n\n        if json:\n            self._update_(json)\n            return True\n        return False", "response": "Edit this organization.\n\n        :param str billing_email: (optional) Billing email address (private)\n        :param str company: (optional)\n        :param str email: (optional) Public email address\n        :param str location: (optional)\n        :param str name: (optional)\n        :returns: bool"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_public_member(self, login):\n        url = self._build_url('public_members', login, base_url=self._api)\n        return self._boolean(self._get(url), 204, 404)", "response": "Check if the user with login is a public member."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over repos for this organization.", "response": "def iter_repos(self, type='', number=-1, etag=None):\n        \"\"\"Iterate over repos for this organization.\n\n        :param str type: (optional), accepted values:\n            ('all', 'public', 'member', 'private', 'forks', 'sources'), API\n            default: 'all'\n        :param int number: (optional), number of members to return. Default:\n            -1 will return all available.\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        url = self._build_url('repos', base_url=self._api)\n        params = {}\n        if type in ('all', 'public', 'member', 'private', 'forks', 'sources'):\n            params['type'] = type\n        return self._iter(int(number), url, Repository, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_teams(self, number=-1, etag=None):\n        url = self._build_url('teams', base_url=self._api)\n        return self._iter(int(number), url, Team, etag=etag)", "response": "Iterate over teams that are part of this organization."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake login s membership in this organization public.", "response": "def publicize_member(self, login):\n        \"\"\"Make ``login``'s membership in this organization public.\n\n        :returns: bool\n        \"\"\"\n        url = self._build_url('public_members', login, base_url=self._api)\n        return self._boolean(self._put(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_repo(self, repo, team):\n        for t in self.iter_teams():\n            if team == t.name:\n                return t.remove_repo(repo)\n        return False", "response": "Remove repo from team."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef team(self, team_id):\n        json = None\n        if int(team_id) > 0:\n            url = self._build_url('teams', str(team_id))\n            json = self._json(self._get(url), 200)\n        return Team(json, self._session) if json else None", "response": "Returns a Team object with information about team specified by team_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edit(self, state):\n        if state and state.lower() == 'active':\n            data = dumps({'state': state.lower()})\n            json = self._json(self._patch(self._api, data=data))\n            self._update_attributes(json)\n        return self", "response": "Edit the user s membership."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self):\n        url = self._api\n        return self._boolean(\n            self._delete(url, headers=Release.CUSTOM_HEADERS),\n            204,\n            404\n        )", "response": "Users with push access to the repository can delete a release.\n\n        :returns: True if successful; False if not successful"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edit(self, tag_name=None, target_commitish=None, name=None, body=None,\n             draft=None, prerelease=None):\n        \"\"\"Users with push access to the repository can edit a release.\n\n        If the edit is successful, this object will update itself.\n\n        :param str tag_name: (optional), Name of the tag to use\n        :param str target_commitish: (optional), The \"commitish\" value that\n            determines where the Git tag is created from. Defaults to the\n            repository's default branch.\n        :param str name: (optional), Name of the release\n        :param str body: (optional), Description of the release\n        :param boolean draft: (optional), True => Release is a draft\n        :param boolean prerelease: (optional), True => Release is a prerelease\n        :returns: True if successful; False if not successful\n        \"\"\"\n        url = self._api\n        data = {\n            'tag_name': tag_name,\n            'target_commitish': target_commitish,\n            'name': name,\n            'body': body,\n            'draft': draft,\n            'prerelease': prerelease,\n        }\n        self._remove_none(data)\n\n        r = self._session.patch(\n            url, data=json.dumps(data), headers=Release.CUSTOM_HEADERS\n        )\n\n        successful = self._boolean(r, 200, 404)\n        if successful:\n            # If the edit was successful, let's update the object.\n            self.__init__(r.json(), self)\n\n        return successful", "response": "Users with push access to the repository can edit a release."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_assets(self, number=-1, etag=None):\n        url = self._build_url('assets', base_url=self._api)\n        return self._iter(number, url, Asset, etag=etag)", "response": "Iterate over the assets available for this release."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_asset(self, content_type, name, asset):\n        headers = Release.CUSTOM_HEADERS.copy()\n        headers.update({'Content-Type': content_type})\n        url = self.upload_urlt.expand({'name': name})\n        r = self._post(url, data=asset, json=False, headers=headers,\n                       verify=False)\n        if r.status_code in (201, 202):\n            return Asset(r.json(), self)\n        raise GitHubError(r)", "response": "Upload an asset to this release."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download(self, path=''):\n        headers = {\n            'Accept': 'application/octet-stream'\n            }\n        resp = self._get(self._api, allow_redirects=False, stream=True,\n                         headers=headers)\n        if resp.status_code == 302:\n            # Amazon S3 will reject the redirected request unless we omit\n            # certain request headers\n            headers.update({\n                'Content-Type': None,\n                })\n            with self._session.no_auth():\n                resp = self._get(resp.headers['location'], stream=True,\n                                 headers=headers)\n\n        if self._boolean(resp, 200, 404):\n            stream_response_to_file(resp, path)\n            return True\n        return False", "response": "Download the data for this asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edit(self, name, label=None):\n        if not name:\n            return False\n        edit_data = {'name': name, 'label': label}\n        self._remove_none(edit_data)\n        r = self._patch(\n            self._api,\n            data=json.dumps(edit_data),\n            headers=Release.CUSTOM_HEADERS\n        )\n        successful = self._boolean(r, 200, 404)\n        if successful:\n            self.__init__(r.json(), self)\n\n        return successful", "response": "Edit this asset.\n\n        :param str name: (required), The file name of the asset\n        :param str label: (optional), An alternate description of the asset\n        :returns: boolean"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ls(args):\n    table = []\n    queues = list(resources.sqs.queues.filter(QueueNamePrefix=\"github\"))\n    max_age = datetime.now(tzutc()) - timedelta(days=15)\n    for topic in resources.sns.topics.all():\n        account_id = ARN(topic.arn).account_id\n        try:\n            bucket = resources.s3.Bucket(\"deploy-status-{}\".format(account_id))\n            status_objects = bucket.objects.filter(Prefix=ARN(topic.arn).resource)\n            recent_status_objects = {o.key: o for o in status_objects if o.last_modified > max_age}\n        except ClientError:\n            continue\n        if ARN(topic.arn).resource.startswith(\"github\"):\n            for queue in queues:\n                queue_name = os.path.basename(queue.url)\n                if queue_name.startswith(ARN(topic.arn).resource):\n                    row = dict(Topic=topic, Queue=queue)\n                    status_object = bucket.Object(os.path.join(queue_name, \"status\"))\n                    if status_object.key not in recent_status_objects:\n                        continue\n                    try:\n                        github, owner, repo, events, instance = os.path.dirname(status_object.key).split(\"-\", 4)\n                        status = json.loads(status_object.get()[\"Body\"].read().decode(\"utf-8\"))\n                        row.update(status, Owner=owner, Repo=repo, Instance=instance,\n                                   Updated=status_object.last_modified)\n                    except Exception:\n                        pass\n                    table.append(row)\n    args.columns = [\"Owner\", \"Repo\", \"Instance\", \"Status\", \"Ref\", \"Commit\", \"Updated\", \"Topic\", \"Queue\"]\n    page_output(tabulate(table, args))", "response": "List all configured SNS - SQS message buses and instances subscribed to them."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef grant(args):\n    try:\n        role = resources.iam.Role(args.iam_role_or_instance)\n        role.load()\n    except ClientError:\n        role = get_iam_role_for_instance(args.iam_role_or_instance)\n    role.attach_policy(PolicyArn=ensure_deploy_iam_policy().arn)\n    for private_repo in [args.repo] + list(private_submodules(args.repo)):\n        gh_owner_name, gh_repo_name = parse_repo_name(private_repo)\n        secret = secrets.put(argparse.Namespace(secret_name=\"deploy.{}.{}\".format(gh_owner_name, gh_repo_name),\n                                                iam_role=role.name,\n                                                instance_profile=None,\n                                                iam_group=None,\n                                                iam_user=None,\n                                                generate_ssh_key=True))\n        get_repo(private_repo).create_key(__name__ + \".\" + role.name, secret[\"ssh_public_key\"])\n        logger.info(\"Created deploy key %s for IAM role %s to access GitHub repo %s\",\n                    secret[\"ssh_key_fingerprint\"], role.name, private_repo)", "response": "Grant the given role or instance to the given GitHub repo."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete this file. :param str message: (required), commit message to describe the removal :param str branch: (optional), branch where the file exists. Defaults to the default branch of the repository. :param dict committer: (optional), if no information is given the authenticated user's information will be used. You must specify both a name and email. :param dict author: (optional), if omitted this will be filled in with committer information. If passed, you must specify both a name and email. :returns: :class:`Commit <github3.git.Commit>`", "response": "def delete(self, message, branch=None, committer=None, author=None):\n        \"\"\"Delete this file.\n\n        :param str message: (required), commit message to describe the removal\n        :param str branch: (optional), branch where the file exists.\n            Defaults to the default branch of the repository.\n        :param dict committer: (optional), if no information is given the\n            authenticated user's information will be used. You must specify\n            both a name and email.\n        :param dict author: (optional), if omitted this will be filled in with\n            committer information. If passed, you must specify both a name and\n            email.\n        :returns: :class:`Commit <github3.git.Commit>`\n\n        \"\"\"\n        json = None\n        if message:\n            data = {'message': message, 'sha': self.sha, 'branch': branch,\n                    'committer': validate_commmitter(committer),\n                    'author': validate_commmitter(author)}\n            self._remove_none(data)\n            json = self._json(self._delete(self._api, data=dumps(data)), 200)\n            if 'commit' in json:\n                json = Commit(json['commit'], self)\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, message, content, branch=None, committer=None,\n               author=None):\n        \"\"\"Update this file.\n\n        :param str message: (required), commit message to describe the update\n        :param str content: (required), content to update the file with\n        :param str branch: (optional), branch where the file exists.\n            Defaults to the default branch of the repository.\n        :param dict committer: (optional), if no information is given the\n            authenticated user's information will be used. You must specify\n            both a name and email.\n        :param dict author: (optional), if omitted this will be filled in with\n            committer information. If passed, you must specify both a name and\n            email.\n        :returns: :class:`Commit <github3.git.Commit>`\n\n        \"\"\"\n        if content and not isinstance(content, bytes):\n            raise ValueError(  # (No coverage)\n                'content must be a bytes object')  # (No coverage)\n\n        json = None\n        if message and content:\n            content = b64encode(content).decode('utf-8')\n            data = {'message': message, 'content': content, 'branch': branch,\n                    'sha': self.sha,\n                    'committer': validate_commmitter(committer),\n                    'author': validate_commmitter(author)}\n            self._remove_none(data)\n            json = self._json(self._put(self._api, data=dumps(data)), 200)\n            if 'content' in json and 'commit' in json:\n                self.__init__(json['content'], self)\n                json = Commit(json['commit'], self)\n        return json", "response": "Update the file with the given message and content."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef edit(self, description='', files={}):\n        data = {}\n        json = None\n        if description:\n            data['description'] = description\n        if files:\n            data['files'] = files\n        if data:\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n        if json:\n            self._update_(json)\n            return True\n        return False", "response": "Edit this gist s entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nforking this gist. :returns: :class:`Gist <Gist>` if successful, ``None`` otherwise", "response": "def fork(self):\n        \"\"\"Fork this gist.\n\n        :returns: :class:`Gist <Gist>` if successful, ``None`` otherwise\n\n        \"\"\"\n        url = self._build_url('forks', base_url=self._api)\n        json = self._json(self._post(url), 201)\n        return Gist(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_starred(self):\n        url = self._build_url('star', base_url=self._api)\n        return self._boolean(self._get(url), 204, 404)", "response": "Check to see if this gist is starred by the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over the commits on this gist.", "response": "def iter_commits(self, number=-1, etag=None):\n        \"\"\"Iter over the commits on this gist.\n\n        These commits will be requested from the API and should be the same as\n        what is in ``Gist.history``.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n\n            Added param ``etag``.\n\n        :param int number: (optional), number of commits to iterate over.\n            Default: -1 will iterate over all commits associated with this\n            gist.\n        :param str etag: (optional), ETag from a previous request to this\n            endpoint.\n        :returns: generator of\n            :class:`GistHistory <github3.gists.history.GistHistory>`\n\n        \"\"\"\n        url = self._build_url('commits', base_url=self._api)\n        return self._iter(int(number), url, GistHistory)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_forks(self, number=-1, etag=None):\n        url = self._build_url('forks', base_url=self._api)\n        return self._iter(int(number), url, Gist, etag=etag)", "response": "Iterate over forks of this gist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef star(self):\n        url = self._build_url('star', base_url=self._api)\n        return self._boolean(self._put(url), 204, 404)", "response": "Star this gist.\n\n        :returns: bool -- True if successful, False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unstar(self):\n        url = self._build_url('star', base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)", "response": "Un - star this gist."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates this comment. :param str body: (required) :returns: bool", "response": "def update(self, body):\n        \"\"\"Update this comment.\n\n        :param str body: (required)\n        :returns: bool\n        \"\"\"\n        json = None\n        if body:\n            json = self._json(self._post(self._api, data={'body': body}), 200)\n\n        if json:\n            self._update_(json)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scp(args):\n    if args.scp_args[0] == \"--\":\n        del args.scp_args[0]\n    user_or_hostname_chars = string.ascii_letters + string.digits\n    for i, arg in enumerate(args.scp_args):\n        if arg[0] in user_or_hostname_chars and \":\" in arg:\n            hostname, colon, path = arg.partition(\":\")\n            username, at, hostname = hostname.rpartition(\"@\")\n            hostname = resolve_instance_public_dns(hostname)\n            if not (username or at):\n                try:\n                    username, at = get_linux_username(), \"@\"\n                except Exception:\n                    logger.info(\"Unable to determine IAM username, using local username\")\n            args.scp_args[i] = username + at + hostname + colon + path\n    os.execvp(\"scp\", [\"scp\"] + args.scp_args)", "response": "Transfer files to or from EC2 instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist S3 buckets. See also aws s3 ls NAME to list bucket contents.", "response": "def ls(args):\n    \"\"\"\n    List S3 buckets. See also \"aws s3 ls\". Use \"aws s3 ls NAME\" to list bucket contents.\n    \"\"\"\n    table = []\n    for bucket in filter_collection(resources.s3.buckets, args):\n        bucket.LocationConstraint = clients.s3.get_bucket_location(Bucket=bucket.name)[\"LocationConstraint\"]\n        cloudwatch = resources.cloudwatch\n        bucket_region = bucket.LocationConstraint or \"us-east-1\"\n        if bucket_region != cloudwatch.meta.client.meta.region_name:\n            cloudwatch = boto3.Session(region_name=bucket_region).resource(\"cloudwatch\")\n        data = get_cloudwatch_metric_stats(\"AWS/S3\", \"NumberOfObjects\",\n                                           start_time=datetime.utcnow() - timedelta(days=2),\n                                           end_time=datetime.utcnow(), period=3600, BucketName=bucket.name,\n                                           StorageType=\"AllStorageTypes\", resource=cloudwatch)\n        bucket.NumberOfObjects = int(data[\"Datapoints\"][-1][\"Average\"]) if data[\"Datapoints\"] else None\n        data = get_cloudwatch_metric_stats(\"AWS/S3\", \"BucketSizeBytes\",\n                                           start_time=datetime.utcnow() - timedelta(days=2),\n                                           end_time=datetime.utcnow(), period=3600, BucketName=bucket.name,\n                                           StorageType=\"StandardStorage\", resource=cloudwatch)\n        bucket.BucketSizeBytes = format_number(data[\"Datapoints\"][-1][\"Average\"]) if data[\"Datapoints\"] else None\n        table.append(bucket)\n    page_output(tabulate(table, args))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, name, color):\n        json = None\n\n        if name and color:\n            if color[0] == '#':\n                color = color[1:]\n            json = self._json(self._patch(self._api, data=dumps({\n                'name': name, 'color': color})), 200)\n\n        if json:\n            self._update_(json)\n            return True\n\n        return False", "response": "Update this label.\n\n        :param str name: (required), new name of the label\n        :param str color: (required), color code, e.g., 626262, no leading '#'\n        :returns: bool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef basic_auth(self, username, password):\n        if not (username and password):\n            return\n\n        self.auth = (username, password)\n\n        # Disable token authentication\n        self.headers.pop('Authorization', None)", "response": "Set the Basic Auth credentials on this Session."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_url(self, *args, **kwargs):\n        parts = [kwargs.get('base_url') or self.base_url]\n        parts.extend(args)\n        parts = [str(p) for p in parts]\n        key = tuple(parts)\n        __logs__.info('Building a url from %s', key)\n        if not key in __url_cache__:\n            __logs__.info('Missed the cache building the url')\n            __url_cache__[key] = '/'.join(parts)\n        return __url_cache__[key]", "response": "Builds a new API url from scratch."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef retrieve_client_credentials(self):\n        client_id = self.params.get('client_id')\n        client_secret = self.params.get('client_secret')\n        return (client_id, client_secret)", "response": "Retrieve the client credentials."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing an application token for authentication.", "response": "def token_auth(self, token):\n        \"\"\"Use an application token for authentication.\n\n        :param str token: Application token retrieved from GitHub's\n            /authorizations endpoint\n        \"\"\"\n        if not token:\n            return\n\n        self.headers.update({\n            'Authorization': 'token {0}'.format(token)\n            })\n        # Unset username/password so we stop sending them\n        self.auth = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edit(self, config={}, events=[], add_events=[], rm_events=[],\n             active=True):\n        \"\"\"Edit this hook.\n\n        :param dict config: (optional), key-value pairs of settings for this\n            hook\n        :param list events: (optional), which events should this be triggered\n            for\n        :param list add_events: (optional), events to be added to the list of\n           events that this hook triggers for\n        :param list rm_events: (optional), events to be remvoed from the list\n            of events that this hook triggers for\n        :param bool active: (optional), should this event be active\n        :returns: bool\n        \"\"\"\n        data = {'config': config, 'active': active}\n        if events:\n            data['events'] = events\n\n        if add_events:\n            data['add_events'] = add_events\n\n        if rm_events:\n            data['remove_events'] = rm_events\n\n        json = self._json(self._patch(self._api, data=dumps(data)), 200)\n\n        if json:\n            self._update_(json)\n            return True\n\n        return False", "response": "Edit this hook.\n\n        :param dict config: (optional), key-value pairs of settings for this\n            hook\n        :param list events: (optional), which events should this be triggered\n            for\n        :param list add_events: (optional), events to be added to the list of\n           events that this hook triggers for\n        :param list rm_events: (optional), events to be remvoed from the list\n            of events that this hook triggers for\n        :param bool active: (optional), should this event be active\n        :returns: bool"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npinging this hook. :returns: bool", "response": "def ping(self):\n        \"\"\"Ping this hook.\n\n        :returns: bool\n        \"\"\"\n        url = self._build_url('pings', base_url=self._api)\n        return self._boolean(self._post(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef requires_auth(func):\n    @wraps(func)\n    def auth_wrapper(self, *args, **kwargs):\n        auth = False\n        if hasattr(self, '_session'):\n            auth = (self._session.auth or\n                    self._session.headers.get('Authorization'))\n\n        if auth:\n            return func(self, *args, **kwargs)\n        else:\n            from .models import GitHubError\n            # Mock a 401 response\n            r = generate_fake_error_response(\n                '{\"message\": \"Requires authentication\"}'\n            )\n            raise GitHubError(r)\n    return auth_wrapper", "response": "Decorator to note which object methods require authorization."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequire client_id and client_secret to be associated. This is used to note and enforce which methods require a client_id and client_secret to be used.", "response": "def requires_app_credentials(func):\n    \"\"\"Require client_id and client_secret to be associated.\n\n    This is used to note and enforce which methods require a client_id and\n    client_secret to be used.\n\n    \"\"\"\n    @wraps(func)\n    def auth_wrapper(self, *args, **kwargs):\n        client_id, client_secret = self._session.retrieve_client_credentials()\n        if client_id and client_secret:\n            return func(self, *args, **kwargs)\n        else:\n            from .models import GitHubError\n            # Mock a 401 response\n            r = generate_fake_error_response(\n                '{\"message\": \"Requires username/password authentication\"}'\n            )\n            raise GitHubError(r)\n\n    return auth_wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef audit_1_1(self):\n        for row in self.credential_report:\n            if row[\"user\"] == \"<root_account>\":\n                for field in \"password_last_used\", \"access_key_1_last_used_date\", \"access_key_2_last_used_date\":\n                    if row[field] != \"N/A\" and self.parse_date(row[field]) > datetime.now(tzutc()) - timedelta(days=1):\n                        raise Exception(\"Root account last used less than a day ago ({})\".format(field))", "response": "1. 1 Avoid the use of the root account ( Scored"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef audit_1_2(self):\n        for row in self.credential_report:\n            if row[\"user\"] == \"<root_account>\" or json.loads(row[\"password_enabled\"]):\n                if not json.loads(row[\"mfa_active\"]):\n                    raise Exception(\"Account {} has a console password but no MFA\".format(row[\"user\"]))", "response": "1. 2 Audit 1. 2"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef audit_1_4(self):\n        for row in self.credential_report:\n            for access_key in \"1\", \"2\":\n                if json.loads(row[\"access_key_{}_active\".format(access_key)]):\n                    last_rotated = row[\"access_key_{}_last_rotated\".format(access_key)]\n                    if self.parse_date(last_rotated) < datetime.now(tzutc()) - timedelta(days=90):\n                        msg = \"Active access key {} in account {} last rotated over 90 days ago\"\n                        raise Exception(msg.format(access_key, row[\"user\"]))", "response": "1. 4 Audit 1. 4"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef audit_1_15(self):\n        for policy in resources.iam.policies.all():\n            self.assertEqual(len(list(policy.attached_users.all())), 0, \"{} has users attached to it\".format(policy))", "response": "1. 15 Audit IAM policies are attached only to groups or roles or their users."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef audit_2_3(self):\n        raise NotImplementedError()\n        import boto3\n        s3 = boto3.session.Session(region_name=\"us-east-1\").resource(\"s3\")\n        # s3 = boto3.resource(\"s3\")\n        # for trail in self.trails:\n        #    for grant in s3.Bucket(trail[\"S3BucketName\"]).Acl().grants:\n        #    print(s3.Bucket(trail[\"S3BucketName\"]).Policy().policy)\n        for bucket in s3.buckets.all():\n            print(bucket)\n            try:\n                print(\"    Policy:\", bucket.Policy().policy)\n            except Exception:\n                pass\n            for grant in bucket.Acl().grants:\n                try:\n                    print(\"    Grant:\", grant)\n                except Exception:\n                    pass", "response": "2. 3 Audit CloudTrail logs to S3 buckets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef audit_2_4(self):\n        for trail in self.trails:\n            self.assertIn(\"CloudWatchLogsLogGroupArn\", trail)\n            trail_status = clients.cloudtrail.get_trail_status(Name=trail[\"TrailARN\"])\n            self.assertGreater(trail_status[\"LatestCloudWatchLogsDeliveryTime\"],\n                               datetime.now(tzutc()) - timedelta(days=1))", "response": "2. 4 Audit CloudTrail trails"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef audit_2_5(self):\n        import boto3\n        for region in boto3.Session().get_available_regions(\"config\"):\n            aws_config = boto3.session.Session(region_name=region).client(\"config\")\n            res = aws_config.describe_configuration_recorder_status()\n            self.assertGreater(len(res[\"ConfigurationRecordersStatus\"]), 0)", "response": "2. 5 Audit AWS Config"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets information about an authorization id.", "response": "def authorization(self, id_num):\n        \"\"\"Get information about authorization ``id``.\n\n        :param int id_num: (required), unique id of the authorization\n        :returns: :class:`Authorization <Authorization>`\n        \"\"\"\n        json = None\n        if int(id_num) > 0:\n            url = self._build_url('authorizations', str(id_num))\n            json = self._json(self._get(url), 200)\n        return Authorization(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authorize(self, login, password, scopes=None, note='', note_url='',\n                  client_id='', client_secret=''):\n        \"\"\"Obtain an authorization token from the GitHub API for the GitHub\n        API.\n\n        :param str login: (required)\n        :param str password: (required)\n        :param list scopes: (optional), areas you want this token to apply to,\n            i.e., 'gist', 'user'\n        :param str note: (optional), note about the authorization\n        :param str note_url: (optional), url for the application\n        :param str client_id: (optional), 20 character OAuth client key for\n            which to create a token\n        :param str client_secret: (optional), 40 character OAuth client secret\n            for which to create the token\n        :returns: :class:`Authorization <Authorization>`\n        \"\"\"\n        json = None\n        # TODO: Break this behaviour in 1.0 (Don't rely on self._session.auth)\n        auth = None\n        if self._session.auth:\n            auth = self._session.auth\n        elif login and password:\n            auth = (login, password)\n\n        if auth:\n            url = self._build_url('authorizations')\n            data = {'note': note, 'note_url': note_url,\n                    'client_id': client_id, 'client_secret': client_secret}\n            if scopes:\n                data['scopes'] = scopes\n\n            with self._session.temporary_basic_auth(*auth):\n                json = self._json(self._post(url, data=data), 201)\n\n        return Authorization(json, self) if json else None", "response": "Obtain an authorization token for the GitHub API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_authorization(self, access_token):\n        p = self._session.params\n        auth = (p.get('client_id'), p.get('client_secret'))\n        if access_token and auth:\n            url = self._build_url('applications', str(auth[0]), 'tokens',\n                                  str(access_token))\n            resp = self._get(url, auth=auth, params={\n                'client_id': None, 'client_secret': None\n            })\n            return self._boolean(resp, 200, 404)\n        return False", "response": "Check if the token is valid for the application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new gist.", "response": "def create_gist(self, description, files, public=True):\n        \"\"\"Create a new gist.\n\n        If no login was provided, it will be anonymous.\n\n        :param str description: (required), description of gist\n        :param dict files: (required), file names with associated dictionaries\n            for content, e.g. ``{'spam.txt': {'content': 'File contents\n            ...'}}``\n        :param bool public: (optional), make the gist public if True\n        :returns: :class:`Gist <github3.gists.Gist>`\n        \"\"\"\n        new_gist = {'description': description, 'public': public,\n                    'files': files}\n        url = self._build_url('gists')\n        json = self._json(self._post(url, data=new_gist), 201)\n        return Gist(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an issue on the project repository owned by owner repository title body assignee and milestone labels are all optional.", "response": "def create_issue(self,\n                     owner,\n                     repository,\n                     title,\n                     body=None,\n                     assignee=None,\n                     milestone=None,\n                     labels=[]):\n        \"\"\"Create an issue on the project 'repository' owned by 'owner'\n        with title 'title'.\n\n        body, assignee, milestone, labels are all optional.\n\n        :param str owner: (required), login of the owner\n        :param str repository: (required), repository name\n        :param str title: (required), Title of issue to be created\n        :param str body: (optional), The text of the issue, markdown\n            formatted\n        :param str assignee: (optional), Login of person to assign\n            the issue to\n        :param int milestone: (optional), id number of the milestone to\n            attribute this issue to (e.g. ``m`` is a :class:`Milestone\n            <github3.issues.Milestone>` object, ``m.number`` is what you pass\n            here.)\n        :param list labels: (optional), List of label names.\n        :returns: :class:`Issue <github3.issues.Issue>` if successful, else\n            None\n        \"\"\"\n        repo = None\n        if owner and repository and title:\n            repo = self.repository(owner, repository)\n\n        if repo:\n            return repo.create_issue(title, body, assignee, milestone, labels)\n\n        # Regardless, something went wrong. We were unable to create the\n        # issue\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_key(self, title, key):\n        created = None\n\n        if title and key:\n            url = self._build_url('user', 'keys')\n            req = self._post(url, data={'title': title, 'key': key})\n            json = self._json(req, 201)\n            if json:\n                created = Key(json, self)\n        return created", "response": "Create a new key for the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting user key pointed to by key_id.", "response": "def delete_key(self, key_id):\n        \"\"\"Delete user key pointed to by ``key_id``.\n\n        :param int key_id: (required), unique id used by Github\n        :returns: bool\n        \"\"\"\n        key = self.key(key_id)\n        if key:\n            return key.delete()\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef emojis(self):\n        url = self._build_url('emojis')\n        return self._json(self._get(url), 200)", "response": "Retrieves a dictionary of all of the emojis that GitHub supports."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting GitHub s timeline resources in Atom format.", "response": "def feeds(self):\n        \"\"\"List GitHub's timeline resources in Atom format.\n\n        :returns: dictionary parsed to include URITemplates\n        \"\"\"\n        url = self._build_url('feeds')\n        json = self._json(self._get(url), 200)\n        del json['ETag']\n        del json['Last-Modified']\n\n        urls = [\n            'timeline_url', 'user_url', 'current_user_public_url',\n            'current_user_url', 'current_user_actor_url',\n            'current_user_organization_url',\n            ]\n\n        for url in urls:\n            json[url] = URITemplate(json[url])\n\n        links = json.get('_links', {})\n        for d in links.values():\n            d['href'] = URITemplate(d['href'])\n\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake the authenticated user follow login. :param str login: (required), user to follow :returns: bool", "response": "def follow(self, login):\n        \"\"\"Make the authenticated user follow login.\n\n        :param str login: (required), user to follow\n        :returns: bool\n        \"\"\"\n        resp = False\n        if login:\n            url = self._build_url('user', 'following', login)\n            resp = self._boolean(self._put(url), 204, 404)\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the gist with the specified id number.", "response": "def gist(self, id_num):\n        \"\"\"Gets the gist using the specified id number.\n\n        :param int id_num: (required), unique id of the gist\n        :returns: :class:`Gist <github3.gists.Gist>`\n        \"\"\"\n        url = self._build_url('gists', str(id_num))\n        json = self._json(self._get(url), 200)\n        return Gist(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the template for language.", "response": "def gitignore_template(self, language):\n        \"\"\"Returns the template for language.\n\n        :returns: str\n        \"\"\"\n        url = self._build_url('gitignore', 'templates', language)\n        json = self._json(self._get(url), 200)\n        if not json:\n            return ''\n        return json.get('source', '')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gitignore_templates(self):\n        url = self._build_url('gitignore', 'templates')\n        return self._json(self._get(url), 200) or []", "response": "Returns the list of available templates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_following(self, login):\n        json = False\n        if login:\n            url = self._build_url('user', 'following', login)\n            json = self._boolean(self._get(url), 204, 404)\n        return json", "response": "Check if the authenticated user is following login."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the authenticated user is subscribed to login or repository.", "response": "def is_subscribed(self, login, repo):\n        \"\"\"Check if the authenticated user is subscribed to login/repo.\n\n        :param str login: (required), owner of repository\n        :param str repo: (required), name of repository\n        :returns: bool\n        \"\"\"\n        json = False\n        if login and repo:\n            url = self._build_url('user', 'subscriptions', login, repo)\n            json = self._boolean(self._get(url), 204, 404)\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef issue(self, owner, repository, number):\n        repo = self.repository(owner, repository)\n        if repo:\n            return repo.issue(number)\n        return None", "response": "Fetch issue number from github3."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_all_repos(self, number=-1, since=None, etag=None, per_page=None):\n        url = self._build_url('repositories')\n        return self._iter(int(number), url, Repository,\n                          params={'since': since, 'per_page': per_page},\n                          etag=etag)", "response": "Iterate over every repository in the order they were created."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter_all_users(self, number=-1, etag=None, per_page=None):\n        url = self._build_url('users')\n        return self._iter(int(number), url, User,\n                          params={'per_page': per_page}, etag=etag)", "response": "Iterate over every user in the order they signed up for GitHub."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate over authorizations for the authenticated user.", "response": "def iter_authorizations(self, number=-1, etag=None):\n        \"\"\"Iterate over authorizations for the authenticated user. This will\n        return a 404 if you are using a token for authentication.\n\n        :param int number: (optional), number of authorizations to return.\n            Default: -1 returns all available authorizations\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Authorization <Authorization>`\\ s\n        \"\"\"\n        url = self._build_url('authorizations')\n        return self._iter(int(number), url, Authorization, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter_emails(self, number=-1, etag=None):\n        url = self._build_url('user', 'emails')\n        return self._iter(int(number), url, dict, etag=etag)", "response": "Iterate over the email addresses for the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\niterating over public events.", "response": "def iter_events(self, number=-1, etag=None):\n        \"\"\"Iterate over public events.\n\n        :param int number: (optional), number of events to return. Default: -1\n            returns all available events\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Event <github3.events.Event>`\\ s\n        \"\"\"\n        url = self._build_url('events')\n        return self._iter(int(number), url, Event, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over a generator of followers of the user with login name. If login is not provided return a generator of followers of the authenticated user.", "response": "def iter_followers(self, login=None, number=-1, etag=None):\n        \"\"\"If login is provided, iterate over a generator of followers of that\n        login name; otherwise return a generator of followers of the\n        authenticated user.\n\n        :param str login: (optional), login of the user to check\n        :param int number: (optional), number of followers to return. Default:\n            -1 returns all followers\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`User <github3.users.User>`\\ s\n        \"\"\"\n        if login:\n            return self.user(login).iter_followers()\n        return self._iter_follow('followers', int(number), etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over a generator of users being followed by login. If login is not provided return a generator of users being followed by login ; otherwise return a generator of people being followed by login.", "response": "def iter_following(self, login=None, number=-1, etag=None):\n        \"\"\"If login is provided, iterate over a generator of users being\n        followed by login; otherwise return a generator of people followed by\n        the authenticated user.\n\n        :param str login: (optional), login of the user to check\n        :param int number: (optional), number of people to return. Default: -1\n            returns all people you follow\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`User <github3.users.User>`\\ s\n        \"\"\"\n        if login:\n            return self.user(login).iter_following()\n        return self._iter_follow('following', int(number), etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter_gists(self, username=None, number=-1, etag=None):\n        if username:\n            url = self._build_url('users', username, 'gists')\n        else:\n            url = self._build_url('gists')\n        return self._iter(int(number), url, Gist, etag=etag)", "response": "Returns an iterator over the gists for the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_notifications(self, all=False, participating=False, number=-1,\n                           etag=None):\n        \"\"\"Iterate over the user's notification.\n\n        :param bool all: (optional), iterate over all notifications\n        :param bool participating: (optional), only iterate over notifications\n            in which the user is participating\n        :param int number: (optional), how many notifications to return\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of\n            :class:`Thread <github3.notifications.Thread>`\n        \"\"\"\n        params = None\n        if all:\n            params = {'all': all}\n        elif participating:\n            params = {'participating': participating}\n\n        url = self._build_url('notifications')\n        return self._iter(int(number), url, Thread, params, etag=etag)", "response": "Iterate over the user s notifications."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over the issues in the organization.", "response": "def iter_org_issues(self, name, filter='', state='', labels='', sort='',\n                        direction='', since=None, number=-1, etag=None):\n        \"\"\"Iterate over the organnization's issues if the authenticated user\n        belongs to it.\n\n        :param str name: (required), name of the organization\n        :param str filter: accepted values:\n            ('assigned', 'created', 'mentioned', 'subscribed')\n            api-default: 'assigned'\n        :param str state: accepted values: ('open', 'closed')\n            api-default: 'open'\n        :param str labels: comma-separated list of label names, e.g.,\n            'bug,ui,@high'\n        :param str sort: accepted values: ('created', 'updated', 'comments')\n            api-default: created\n        :param str direction: accepted values: ('asc', 'desc')\n            api-default: desc\n        :param since: (optional), Only issues after this date will\n            be returned. This can be a `datetime` or an ISO8601 formatted\n            date string, e.g., 2012-05-20T23:10:27Z\n        :type since: datetime or string\n        :param int number: (optional), number of issues to return. Default:\n            -1, returns all available issues\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Issue <github3.issues.Issue>`\n        \"\"\"\n        url = self._build_url('orgs', name, 'issues')\n        # issue_params will handle the since parameter\n        params = issue_params(filter, state, labels, sort, direction, since)\n        return self._iter(int(number), url, Issue, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting issues on owner or repository.", "response": "def iter_repo_issues(self, owner, repository, milestone=None,\n                         state=None, assignee=None, mentioned=None,\n                         labels=None, sort=None, direction=None, since=None,\n                         number=-1, etag=None):\n        \"\"\"List issues on owner/repository. Only owner and repository are\n        required.\n\n        .. versionchanged:: 0.9.0\n\n            - The ``state`` parameter now accepts 'all' in addition to 'open'\n              and 'closed'.\n\n        :param str owner: login of the owner of the repository\n        :param str repository: name of the repository\n        :param int milestone: None, '*', or ID of milestone\n        :param str state: accepted values: ('all', 'open', 'closed')\n            api-default: 'open'\n        :param str assignee: '*' or login of the user\n        :param str mentioned: login of the user\n        :param str labels: comma-separated list of label names, e.g.,\n            'bug,ui,@high'\n        :param str sort: accepted values: ('created', 'updated', 'comments')\n            api-default: created\n        :param str direction: accepted values: ('asc', 'desc')\n            api-default: desc\n        :param since: (optional), Only issues after this date will\n            be returned. This can be a `datetime` or an ISO8601 formatted\n            date string, e.g., 2012-05-20T23:10:27Z\n        :type since: datetime or string\n        :param int number: (optional), number of issues to return.\n            Default: -1 returns all issues\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Issue <github3.issues.Issue>`\\ s\n        \"\"\"\n        if owner and repository:\n            repo = self.repository(owner, repository)\n            return repo.iter_issues(milestone, state, assignee, mentioned,\n                                    labels, sort, direction, since, number,\n                                    etag)\n        return iter([])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_orgs(self, login=None, number=-1, etag=None):\n        if login:\n            url = self._build_url('users', login, 'orgs')\n        else:\n            url = self._build_url('user', 'orgs')\n\n        return self._iter(int(number), url, Organization, etag=etag)", "response": "Iterate over public organizations for login if provided otherwise iterate over private organizations for the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist public repositories for the authenticated user.", "response": "def iter_repos(self, type=None, sort=None, direction=None, number=-1,\n                   etag=None):\n        \"\"\"List public repositories for the authenticated user.\n\n        .. versionchanged:: 0.6\n           Removed the login parameter for correctness. Use iter_user_repos\n           instead\n\n        :param str type: (optional), accepted values:\n            ('all', 'owner', 'public', 'private', 'member')\n            API default: 'all'\n        :param str sort: (optional), accepted values:\n            ('created', 'updated', 'pushed', 'full_name')\n            API default: 'created'\n        :param str direction: (optional), accepted values:\n            ('asc', 'desc'), API default: 'asc' when using 'full_name',\n            'desc' otherwise\n        :param int number: (optional), number of repositories to return.\n            Default: -1 returns all repositories\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Repository <github3.repos.Repository>`\n            objects\n        \"\"\"\n        url = self._build_url('user', 'repos')\n\n        params = {}\n        if type in ('all', 'owner', 'public', 'private', 'member'):\n            params.update(type=type)\n        if sort in ('created', 'updated', 'pushed', 'full_name'):\n            params.update(sort=sort)\n        if direction in ('asc', 'desc'):\n            params.update(direction=direction)\n\n        return self._iter(int(number), url, Repository, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_starred(self, login=None, sort=None, direction=None, number=-1,\n                     etag=None):\n        \"\"\"Iterate over repositories starred by ``login`` or the authenticated\n        user.\n\n        .. versionchanged:: 0.5\n           Added sort and direction parameters (optional) as per the change in\n           GitHub's API.\n\n        :param str login: (optional), name of user whose stars you want to see\n        :param str sort: (optional), either 'created' (when the star was\n            created) or 'updated' (when the repository was last pushed to)\n        :param str direction: (optional), either 'asc' or 'desc'. Default:\n            'desc'\n        :param int number: (optional), number of repositories to return.\n            Default: -1 returns all repositories\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        if login:\n            return self.user(login).iter_starred(sort, direction)\n\n        params = {'sort': sort, 'direction': direction}\n        self._remove_none(params)\n        url = self._build_url('user', 'starred')\n        return self._iter(int(number), url, Repository, params, etag)", "response": "Iterate over repositories starred by login or authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_subscriptions(self, login=None, number=-1, etag=None):\n        if login:\n            return self.user(login).iter_subscriptions()\n\n        url = self._build_url('user', 'subscriptions')\n        return self._iter(int(number), url, Repository, etag=etag)", "response": "Iterate over repositories subscribed to by login or the logged in user."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the authenticated user s teams across all of the organizations.", "response": "def iter_user_teams(self, number=-1, etag=None):\n        \"\"\"Gets the authenticated user's teams across all of organizations.\n\n        List all of the teams across all of the organizations to which the\n        authenticated user belongs. This method requires user or repo scope\n        when authenticating via OAuth.\n\n        :returns: generator of :class:`Team <github3.orgs.Team>` objects\n        \"\"\"\n        url = self._build_url('user', 'teams')\n        return self._iter(int(number), url, Team, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs the user into GitHub for protected API calls.", "response": "def login(self, username=None, password=None, token=None,\n              two_factor_callback=None):\n        \"\"\"Logs the user into GitHub for protected API calls.\n\n        :param str username: login name\n        :param str password: password for the login\n        :param str token: OAuth token\n        :param func two_factor_callback: (optional), function you implement to\n            provide the Two Factor Authentication code to GitHub when necessary\n        \"\"\"\n        if username and password:\n            self._session.basic_auth(username, password)\n        elif token:\n            self._session.token_auth(token)\n\n        # The Session method handles None for free.\n        self._session.two_factor_auth_callback(two_factor_callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef markdown(self, text, mode='', context='', raw=False):\n        data = None\n        json = False\n        headers = {}\n        if raw:\n            url = self._build_url('markdown', 'raw')\n            data = text\n            headers['content-type'] = 'text/plain'\n        else:\n            url = self._build_url('markdown')\n            data = {}\n\n            if text:\n                data['text'] = text\n\n            if mode in ('markdown', 'gfm'):\n                data['mode'] = mode\n\n            if context:\n                data['context'] = context\n            json = True\n\n        if data:\n            req = self._post(url, data=data, json=json, headers=headers)\n            if req.ok:\n                return req.content\n        return ''", "response": "Render an arbitrary markdown document."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the user s membership in the specified organization.", "response": "def membership_in(self, organization):\n        \"\"\"Retrieve the user's membership in the specified organization.\"\"\"\n        url = self._build_url('user', 'memberships', 'orgs',\n                              str(organization))\n        json = self._json(self._get(url), 200)\n        return Membership(json, self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef meta(self):\n        url = self._build_url('meta')\n        return self._json(self._get(url), 200)", "response": "Returns a dictionary with arrays of addresses in CIDR format\n        specifying the addresses that the incoming service hooks will originate\n        from."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an easter egg of the API.", "response": "def octocat(self, say=None):\n        \"\"\"Returns an easter egg of the API.\n\n        :params str say: (optional), pass in what you'd like Octocat to say\n        :returns: ascii art of Octocat\n        \"\"\"\n        url = self._build_url('octocat')\n        req = self._get(url, params={'s': say})\n        return req.content if req.ok else ''"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef organization(self, login):\n        url = self._build_url('orgs', login)\n        json = self._json(self._get(url), 200)\n        return Organization(json, self) if json else None", "response": "Returns a Organization object for the login name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist organizations of which the user is a current or pending member.", "response": "def organization_memberships(self, state=None, number=-1, etag=None):\n        \"\"\"List organizations of which the user is a current or pending member.\n\n        :param str state: (option), state of the membership, i.e., active,\n            pending\n        :returns: iterator of :class:`Membership <github3.orgs.Membership>`\n        \"\"\"\n        params = None\n        url = self._build_url('user', 'memberships', 'orgs')\n        if state is not None and state.lower() in ('active', 'pending'):\n            params = {'state': state.lower()}\n        return self._iter(int(number), url, Membership,\n                          params=params,\n                          etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pubsubhubbub(self, mode, topic, callback, secret=''):\n        from re import match\n        m = match('https?://[\\w\\d\\-\\.\\:]+/\\w+/[\\w\\._-]+/events/\\w+', topic)\n        status = False\n        if mode and topic and callback and m:\n            data = [('hub.mode', mode), ('hub.topic', topic),\n                    ('hub.callback', callback)]\n            if secret:\n                data.append(('hub.secret', secret))\n            url = self._build_url('hub')\n            # This is not JSON data. It is meant to be form data\n            # application/x-www-form-urlencoded works fine here, no need for\n            # multipart/form-data\n            status = self._boolean(self._post(url, data=data, json=False), 204,\n                                   404)\n        return status", "response": "Create a pubsubhubbub hook."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch pull request number from owner repository", "response": "def pull_request(self, owner, repository, number):\n        \"\"\"Fetch pull_request #:number: from :owner:/:repository\n\n        :param str owner: (required), owner of the repository\n        :param str repository: (required), name of the repository\n        :param int number: (required), issue number\n        :return: :class:`Issue <github3.issues.Issue>`\n        \"\"\"\n        r = self.repository(owner, repository)\n        return r.pull_request(number) if r else None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary with information from the rate limit API.", "response": "def rate_limit(self):\n        \"\"\"Returns a dictionary with information from /rate_limit.\n\n        The dictionary has two keys: ``resources`` and ``rate``. In\n        ``resources`` you can access information about ``core`` or ``search``.\n\n        Note: the ``rate`` key will be deprecated before version 3 of the\n        GitHub API is finalized. Do not rely on that key. Instead, make your\n        code future-proof by using ``core`` in ``resources``, e.g.,\n\n        ::\n\n            rates = g.rate_limit()\n            rates['resources']['core']  # => your normal ratelimit info\n            rates['resources']['search']  # => your search ratelimit info\n\n        .. versionadded:: 0.8\n\n        :returns: dict\n        \"\"\"\n        url = self._build_url('rate_limit')\n        return self._json(self._get(url), 200)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Repository object for the specified combination of owner and repository.", "response": "def repository(self, owner, repository):\n        \"\"\"Returns a Repository object for the specified combination of\n        owner and repository\n\n        :param str owner: (required)\n        :param str repository: (required)\n        :returns: :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        json = None\n        if owner and repository:\n            url = self._build_url('repos', owner, repository)\n            json = self._json(self._get(url), 200)\n        return Repository(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrevokes an authorization for an OAuth application.", "response": "def revoke_authorization(self, access_token):\n        \"\"\"Revoke specified authorization for an OAuth application.\n\n        Revoke all authorization tokens created by your application. This will\n        only work if you have already called ``set_client_id``.\n\n        :param str access_token: (required), the access_token to revoke\n        :returns: bool -- True if successful, False otherwise\n        \"\"\"\n        client_id, client_secret = self._session.retrieve_client_credentials()\n        url = self._build_url('applications', str(client_id), 'tokens',\n                              access_token)\n        with self._session.temporary_basic_auth(client_id, client_secret):\n            response = self._delete(url, params={'client_id': None,\n                                                 'client_secret': None})\n\n        return self._boolean(response, 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for code in the repository.", "response": "def search_code(self, query, sort=None, order=None, per_page=None,\n                    text_match=False, number=-1, etag=None):\n        \"\"\"Find code via the code search API.\n\n        The query can contain any combination of the following supported\n        qualifiers:\n\n        - ``in`` Qualifies which fields are searched. With this qualifier you\n          can restrict the search to just the file contents, the file path, or\n          both.\n        - ``language`` Searches code based on the language it\u2019s written in.\n        - ``fork`` Specifies that code from forked repositories should be\n          searched.  Repository forks will not be searchable unless the fork\n          has more stars than the parent repository.\n        - ``size`` Finds files that match a certain size (in bytes).\n        - ``path`` Specifies the path that the resulting file must be at.\n        - ``extension`` Matches files with a certain extension.\n        - ``user`` or ``repo`` Limits searches to a specific user or\n          repository.\n\n        For more information about these qualifiers, see: http://git.io/-DvAuA\n\n        :param str query: (required), a valid query as described above, e.g.,\n            ``addClass in:file language:js repo:jquery/jquery``\n        :param str sort: (optional), how the results should be sorted;\n            option(s): ``indexed``; default: best match\n        :param str order: (optional), the direction of the sorted results,\n            options: ``asc``, ``desc``; default: ``desc``\n        :param int per_page: (optional)\n        :param bool text_match: (optional), if True, return matching search\n            terms. See http://git.io/iRmJxg for more information\n        :param int number: (optional), number of repositories to return.\n            Default: -1, returns all available repositories\n        :param str etag: (optional), previous ETag header value\n        :return: generator of :class:`CodeSearchResult\n            <github3.search.CodeSearchResult>`\n        \"\"\"\n        params = {'q': query}\n        headers = {}\n\n        if sort == 'indexed':\n            params['sort'] = sort\n\n        if sort and order in ('asc', 'desc'):\n            params['order'] = order\n\n        if text_match:\n            headers = {\n                'Accept': 'application/vnd.github.v3.full.text-match+json'\n                }\n\n        url = self._build_url('search', 'code')\n        return SearchIterator(number, url, CodeSearchResult, self, params,\n                              etag, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search_issues(self, query, sort=None, order=None, per_page=None,\n                      text_match=False, number=-1, etag=None):\n        \"\"\"Find issues by state and keyword\n\n        The query can contain any combination of the following supported\n        qualifers:\n\n        - ``type`` With this qualifier you can restrict the search to issues\n          or pull request only.\n        - ``in`` Qualifies which fields are searched. With this qualifier you\n          can restrict the search to just the title, body, comments, or any\n          combination of these.\n        - ``author`` Finds issues created by a certain user.\n        - ``assignee`` Finds issues that are assigned to a certain user.\n        - ``mentions`` Finds issues that mention a certain user.\n        - ``commenter`` Finds issues that a certain user commented on.\n        - ``involves`` Finds issues that were either created by a certain user,\n          assigned to that user, mention that user, or were commented on by\n          that user.\n        - ``state`` Filter issues based on whether they\u2019re open or closed.\n        - ``labels`` Filters issues based on their labels.\n        - ``language`` Searches for issues within repositories that match a\n          certain language.\n        - ``created`` or ``updated`` Filters issues based on times of creation,\n          or when they were last updated.\n        - ``comments`` Filters issues based on the quantity of comments.\n        - ``user`` or ``repo`` Limits searches to a specific user or\n          repository.\n\n        For more information about these qualifiers, see: http://git.io/d1oELA\n\n        :param str query: (required), a valid query as described above, e.g.,\n            ``windows label:bug``\n        :param str sort: (optional), how the results should be sorted;\n            options: ``created``, ``comments``, ``updated``;\n            default: best match\n        :param str order: (optional), the direction of the sorted results,\n            options: ``asc``, ``desc``; default: ``desc``\n        :param int per_page: (optional)\n        :param bool text_match: (optional), if True, return matching search\n          terms. See http://git.io/QLQuSQ for more information\n        :param int number: (optional), number of issues to return.\n            Default: -1, returns all available issues\n        :param str etag: (optional), previous ETag header value\n        :return: generator of :class:`IssueSearchResult\n            <github3.search.IssueSearchResult>`\n        \"\"\"\n        params = {'q': query}\n        headers = {}\n\n        if sort in ('comments', 'created', 'updated'):\n            params['sort'] = sort\n\n        if order in ('asc', 'desc'):\n            params['order'] = order\n\n        if text_match:\n            headers = {\n                'Accept': 'application/vnd.github.v3.full.text-match+json'\n                }\n\n        url = self._build_url('search', 'issues')\n        return SearchIterator(number, url, IssueSearchResult, self, params,\n                              etag, headers)", "response": "Search for issues in the repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching the repositories in the repository tree.", "response": "def search_repositories(self, query, sort=None, order=None,\n                            per_page=None, text_match=False, number=-1,\n                            etag=None):\n        \"\"\"Find repositories via various criteria.\n\n        The query can contain any combination of the following supported\n        qualifers:\n\n        - ``in`` Qualifies which fields are searched. With this qualifier you\n          can restrict the search to just the repository name, description,\n          readme, or any combination of these.\n        - ``size`` Finds repositories that match a certain size (in\n          kilobytes).\n        - ``forks`` Filters repositories based on the number of forks, and/or\n          whether forked repositories should be included in the results at\n          all.\n        - ``created`` or ``pushed`` Filters repositories based on times of\n          creation, or when they were last updated. Format: ``YYYY-MM-DD``.\n          Examples: ``created:<2011``, ``pushed:<2013-02``,\n          ``pushed:>=2013-03-06``\n        - ``user`` or ``repo`` Limits searches to a specific user or\n          repository.\n        - ``language`` Searches repositories based on the language they're\n          written in.\n        - ``stars`` Searches repositories based on the number of stars.\n\n        For more information about these qualifiers, see: http://git.io/4Z8AkA\n\n        :param str query: (required), a valid query as described above, e.g.,\n            ``tetris language:assembly``\n        :param str sort: (optional), how the results should be sorted;\n            options: ``stars``, ``forks``, ``updated``; default: best match\n        :param str order: (optional), the direction of the sorted results,\n            options: ``asc``, ``desc``; default: ``desc``\n        :param int per_page: (optional)\n        :param bool text_match: (optional), if True, return matching search\n            terms. See http://git.io/4ct1eQ for more information\n        :param int number: (optional), number of repositories to return.\n            Default: -1, returns all available repositories\n        :param str etag: (optional), previous ETag header value\n        :return: generator of :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        params = {'q': query}\n        headers = {}\n\n        if sort in ('stars', 'forks', 'updated'):\n            params['sort'] = sort\n\n        if order in ('asc', 'desc'):\n            params['order'] = order\n\n        if text_match:\n            headers = {\n                'Accept': 'application/vnd.github.v3.full.text-match+json'\n                }\n\n        url = self._build_url('search', 'repositories')\n        return SearchIterator(number, url, RepositorySearchResult, self,\n                              params, etag, headers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for users via the Search API.", "response": "def search_users(self, query, sort=None, order=None, per_page=None,\n                     text_match=False, number=-1, etag=None):\n        \"\"\"Find users via the Search API.\n\n        The query can contain any combination of the following supported\n        qualifers:\n\n\n        - ``type`` With this qualifier you can restrict the search to just\n          personal accounts or just organization accounts.\n        - ``in`` Qualifies which fields are searched. With this qualifier you\n          can restrict the search to just the username, public email, full\n          name, or any combination of these.\n        - ``repos`` Filters users based on the number of repositories they\n          have.\n        - ``location`` Filter users by the location indicated in their\n          profile.\n        - ``language`` Search for users that have repositories that match a\n          certain language.\n        - ``created`` Filter users based on when they joined.\n        - ``followers`` Filter users based on the number of followers they\n          have.\n\n        For more information about these qualifiers see: http://git.io/wjVYJw\n\n        :param str query: (required), a valid query as described above, e.g.,\n            ``tom repos:>42 followers:>1000``\n        :param str sort: (optional), how the results should be sorted;\n            options: ``followers``, ``repositories``, or ``joined``; default:\n            best match\n        :param str order: (optional), the direction of the sorted results,\n            options: ``asc``, ``desc``; default: ``desc``\n        :param int per_page: (optional)\n        :param bool text_match: (optional), if True, return matching search\n            terms. See http://git.io/_V1zRwa for more information\n        :param int number: (optional), number of search results to return;\n            Default: -1 returns all available\n        :param str etag: (optional), ETag header value of the last request.\n        :return: generator of :class:`UserSearchResult\n            <github3.search.UserSearchResult>`\n        \"\"\"\n        params = {'q': query}\n        headers = {}\n\n        if sort in ('followers', 'repositories', 'joined'):\n            params['sort'] = sort\n\n        if order in ('asc', 'desc'):\n            params['order'] = order\n\n        if text_match:\n            headers = {\n                'Accept': 'application/vnd.github.v3.full.text-match+json'\n                }\n\n        url = self._build_url('search', 'users')\n        return SearchIterator(number, url, UserSearchResult, self, params,\n                              etag, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef star(self, login, repo):\n        resp = False\n        if login and repo:\n            url = self._build_url('user', 'starred', login, repo)\n            resp = self._boolean(self._put(url), 204, 404)\n        return resp", "response": "Star to login or repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unfollow(self, login):\n        resp = False\n        if login:\n            url = self._build_url('user', 'following', login)\n            resp = self._boolean(self._delete(url), 204, 404)\n        return resp", "response": "Make the authenticated user stop following login\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the user s information with the provided parameters.", "response": "def update_user(self, name=None, email=None, blog=None,\n                    company=None, location=None, hireable=False, bio=None):\n        \"\"\"If authenticated as this user, update the information with\n        the information provided in the parameters. All parameters are\n        optional.\n\n        :param str name: e.g., 'John Smith', not login name\n        :param str email: e.g., 'john.smith@example.com'\n        :param str blog: e.g., 'http://www.example.com/jsmith/blog'\n        :param str company: company name\n        :param str location: where you are located\n        :param bool hireable: defaults to False\n        :param str bio: GitHub flavored markdown\n        :returns: bool\n        \"\"\"\n        user = self.user()\n        return user.update(name, email, blog, company, location, hireable,\n                           bio)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a User object for the specified login name if no login name is provided.", "response": "def user(self, login=None):\n        \"\"\"Returns a User object for the specified login name if\n        provided. If no login name is provided, this will return a User\n        object for the authenticated user.\n\n        :param str login: (optional)\n        :returns: :class:`User <github3.users.User>`\n        \"\"\"\n        if login:\n            url = self._build_url('users', login)\n        else:\n            url = self._build_url('user')\n\n        json = self._json(self._get(url), 200)\n        return User(json, self._session) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zen(self):\n        url = self._build_url('zen')\n        resp = self._get(url)\n        return resp.content if resp.status_code == 200 else ''", "response": "Returns a quote from the Zen of GitHub. Yet another API Easter Egg\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef admin_stats(self, option):\n        stats = {}\n        if option.lower() in ('all', 'repos', 'hooks', 'pages', 'orgs',\n                              'users', 'pulls', 'issues', 'milestones',\n                              'gists', 'comments'):\n            url = self._build_url('enterprise', 'stats', option.lower())\n            stats = self._json(self._get(url), 200)\n        return stats", "response": "This method returns a simple way to get statistics about your system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating this key. :param str title: (required), title of the key :param str key: (required), text of the key file :returns: bool", "response": "def update(self, title, key):\n        \"\"\"Update this key.\n\n        :param str title: (required), title of the key\n        :param str key: (required), text of the key file\n        :returns: bool\n        \"\"\"\n        json = None\n        if title and key:\n            data = {'title': title, 'key': key}\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n        if json:\n            self._update_(json)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the email addresses in addresses to the authenticated user s account.", "response": "def add_email_addresses(self, addresses=[]):\n        \"\"\"Add the email addresses in ``addresses`` to the authenticated\n        user's account.\n\n        :param list addresses: (optional), email addresses to be added\n        :returns: list of email addresses\n        \"\"\"\n        json = []\n        if addresses:\n            url = self._build_url('user', 'emails')\n            json = self._json(self._post(url, data=addresses), 201)\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_email_addresses(self, addresses=[]):\n        url = self._build_url('user', 'emails')\n        return self._boolean(self._delete(url, data=dumps(addresses)),\n                             204, 404)", "response": "Delete the email addresses in addresses from the authenticated user s account."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_assignee_on(self, login, repository):\n        url = self._build_url('repos', login, repository, 'assignees',\n                              self.login)\n        return self._boolean(self._get(url), 204, 404)", "response": "Checks if this user can be assigned to issues on login or repository."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if this user is following login.", "response": "def is_following(self, login):\n        \"\"\"Checks if this user is following ``login``.\n\n        :param str login: (required)\n        :returns: bool\n\n        \"\"\"\n        url = self.following_urlt.expand(other_user=login)\n        return self._boolean(self._get(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iter_events(self, public=False, number=-1, etag=None):\n        path = ['events']\n        if public:\n            path.append('public')\n        url = self._build_url(*path, base_url=self._api)\n        return self._iter(int(number), url, Event, etag=etag)", "response": "Iterate over events performed by this user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_followers(self, number=-1, etag=None):\n        url = self._build_url('followers', base_url=self._api)\n        return self._iter(int(number), url, User, etag=etag)", "response": "Iterate over the followers of this user."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over the public keys of this user.", "response": "def iter_keys(self, number=-1, etag=None):\n        \"\"\"Iterate over the public keys of this user.\n\n        .. versionadded:: 0.5\n\n        :param int number: (optional), number of keys to return. Default: -1\n            returns all available keys\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Key <Key>`\\ s\n        \"\"\"\n        url = self._build_url('keys', base_url=self._api)\n        return self._iter(int(number), url, Key, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iter_org_events(self, org, number=-1, etag=None):\n        url = ''\n        if org:\n            url = self._build_url('events', 'orgs', org, base_url=self._api)\n        return self._iter(int(number), url, Event, etag=etag)", "response": "Iterate over events as they appear on the user s organization."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over organizations the user is member of.", "response": "def iter_orgs(self, number=-1, etag=None):\n        \"\"\"Iterate over organizations the user is member of\n\n        :param int number: (optional), number of organizations to return.\n            Default: -1 returns all available organization\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: list of :class:`Event <github3.orgs.Organization>`\\ s\n        \"\"\"\n        # Import here, because a toplevel import causes an import loop\n        from .orgs import Organization\n        url = self._build_url('orgs', base_url=self._api)\n        return self._iter(int(number), url, Organization, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over repositories starred by this user.", "response": "def iter_starred(self, sort=None, direction=None, number=-1, etag=None):\n        \"\"\"Iterate over repositories starred by this user.\n\n        .. versionchanged:: 0.5\n           Added sort and direction parameters (optional) as per the change in\n           GitHub's API.\n\n        :param int number: (optional), number of starred repos to return.\n            Default: -1, returns all available repos\n        :param str sort: (optional), either 'created' (when the star was\n            created) or 'updated' (when the repository was last pushed to)\n        :param str direction: (optional), either 'asc' or 'desc'. Default:\n            'desc'\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        from .repos import Repository\n\n        params = {'sort': sort, 'direction': direction}\n        self._remove_none(params)\n        url = self.starred_urlt.expand(owner=None, repo=None)\n        return self._iter(int(number), url, Repository, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate over repositories subscribed to by this user.", "response": "def iter_subscriptions(self, number=-1, etag=None):\n        \"\"\"Iterate over repositories subscribed to by this user.\n\n        :param int number: (optional), number of subscriptions to return.\n            Default: -1, returns all available\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Repository <github3.repos.Repository>`\n        \"\"\"\n        from .repos import Repository\n        url = self._build_url('subscriptions', base_url=self._api)\n        return self._iter(int(number), url, Repository, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, name=None, email=None, blog=None, company=None,\n               location=None, hireable=False, bio=None):\n        \"\"\"If authenticated as this user, update the information with\n        the information provided in the parameters.\n\n        :param str name: e.g., 'John Smith', not login name\n        :param str email: e.g., 'john.smith@example.com'\n        :param str blog: e.g., 'http://www.example.com/jsmith/blog'\n        :param str company:\n        :param str location:\n        :param bool hireable: defaults to False\n        :param str bio: GitHub flavored markdown\n        :returns: bool\n        \"\"\"\n        user = {'name': name, 'email': email, 'blog': blog,\n                'company': company, 'location': location,\n                'hireable': hireable, 'bio': bio}\n        self._remove_none(user)\n        url = self._build_url('user')\n        json = self._json(self._patch(url, data=dumps(user)), 200)\n        if json:\n            self._update_(json)\n            return True\n        return False", "response": "Update the information with\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_subscription(self):\n        url = self._build_url('subscription', base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)", "response": "Delete the current subscription for this thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_subscription(self, subscribed, ignored):\n        url = self._build_url('subscription', base_url=self._api)\n        sub = {'subscribed': subscribed, 'ignored': ignored}\n        json = self._json(self._put(url, data=dumps(sub)), 200)\n        return Subscription(json, self) if json else None", "response": "Sets the user s subscription for this thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef subscription(self):\n        url = self._build_url('subscription', base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return Subscription(json, self) if json else None", "response": "Checks the status of the user s subscription to this thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, subscribed, ignored):\n        sub = {'subscribed': subscribed, 'ignored': ignored}\n        json = self._json(self._put(self._api, data=dumps(sub)), 200)\n        self.__init__(json, self._session)", "response": "Set the user s subscription for this subscription\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef locate_ami(product, region=None, channel=\"releases\", stream=\"released\", root_store=\"ssd\", virt=\"hvm\"):\n    if region is None:\n        region = clients.ec2.meta.region_name\n    if product.startswith(\"com.ubuntu.cloud\"):\n        partition = \"aws\"\n        if region.startswith(\"cn-\"):\n            partition = \"aws-cn\"\n        elif region.startswith(\"us-gov-\"):\n            partition = \"aws-govcloud\"\n        if partition not in {\"aws\", \"aws-cn\", \"aws-govcloud\"}:\n            raise AegeaException(\"Unrecognized partition {}\".format(partition))\n        manifest_url = \"https://cloud-images.ubuntu.com/{channel}/streams/v1/com.ubuntu.cloud:{stream}:{partition}.json\"\n        manifest_url = manifest_url.format(partition=partition, channel=channel, stream=stream)\n        manifest = requests.get(manifest_url).json()\n        if product not in manifest[\"products\"]:\n            raise AegeaException(\"Ubuntu version {} not found in Ubuntu cloud image manifest\".format(product))\n        versions = manifest[\"products\"][product][\"versions\"]\n        for version in sorted(versions.keys(), reverse=True)[:8]:\n            for ami in versions[version][\"items\"].values():\n                if ami[\"crsn\"] == region and ami[\"root_store\"] == root_store and ami[\"virt\"] == virt:\n                    logger.info(\"Found %s for %s\", ami[\"id\"], \":\".join([product, version, region, root_store, virt]))\n                    return ami[\"id\"]\n    elif product.startswith(\"Amazon Linux\"):\n        filters = {\"root-device-type\": \"ebs\" if root_store == \"ssd\" else root_store, \"virtualization-type\": virt,\n                   \"architecture\": \"x86_64\", \"owner-alias\": \"amazon\", \"state\": \"available\"}\n        images = resources.ec2.images.filter(Filters=[dict(Name=k, Values=[v]) for k, v in filters.items()])\n        for image in sorted(images, key=lambda i: i.creation_date, reverse=True):\n            if root_store == \"ebs\" and not image.name.endswith(\"x86_64-gp2\"):\n                continue\n            if image.name.startswith(\"amzn-ami-\" + virt) and image.description.startswith(product):\n                return image.image_id\n    raise AegeaException(\"No AMI found for {} {} {} {}\".format(product, region, root_store, virt))", "response": "Locate an AMI in a given region."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_collaborator(self, login):\n        resp = False\n        if login:\n            url = self._build_url('collaborators', login, base_url=self._api)\n            resp = self._boolean(self._put(url), 204, 404)\n        return resp", "response": "Add login as a collaborator to a user s repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the tarball or zipball archive for this repo at ref.", "response": "def archive(self, format, path='', ref='master'):\n        \"\"\"Get the tarball or zipball archive for this repo at ref.\n\n        See: http://developer.github.com/v3/repos/contents/#get-archive-link\n\n        :param str format: (required), accepted values: ('tarball',\n            'zipball')\n        :param path: (optional), path where the file should be saved\n            to, default is the filename provided in the headers and will be\n            written in the current directory.\n            it can take a file-like object as well\n        :type path: str, file\n        :param str ref: (optional)\n        :returns: bool -- True if successful, False otherwise\n\n        \"\"\"\n        resp = None\n        if format in ('tarball', 'zipball'):\n            url = self._build_url(format, ref, base_url=self._api)\n            resp = self._get(url, allow_redirects=True, stream=True)\n\n        if resp and self._boolean(resp, 200, 404):\n            stream_response_to_file(resp, path)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef asset(self, id):\n        data = None\n        if int(id) > 0:\n            url = self._build_url('releases', 'assets', str(id),\n                                  base_url=self._api)\n            data = self._json(self._get(url, headers=Release.CUSTOM_HEADERS),\n                              200)\n        return Asset(data, self) if data else None", "response": "Returns a single Asset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef blob(self, sha):\n        url = self._build_url('git', 'blobs', sha, base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return Blob(json) if json else None", "response": "Get the blob indicated by sha."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef branch(self, name):\n        json = None\n        if name:\n            url = self._build_url('branches', name, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Branch(json, self) if json else None", "response": "Get the branch with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef commit(self, sha):\n        url = self._build_url('commits', sha, base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return RepoCommit(json, self) if json else None", "response": "Get a single ( repo ) commit."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit_comment(self, comment_id):\n        url = self._build_url('comments', str(comment_id), base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return RepoComment(json, self) if json else None", "response": "Get a single commit comment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compare_commits(self, base, head):\n        url = self._build_url('compare', base + '...' + head,\n                              base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return Comparison(json) if json else None", "response": "Compare two commits.\n\n        :param str base: (required), base for the comparison\n        :param str head: (required), compare this against base\n        :returns: :class:`Comparison <github3.repos.comparison.Comparison>` if\n            successful, else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef contents(self, path, ref=None):\n        url = self._build_url('contents', path, base_url=self._api)\n        json = self._json(self._get(url, params={'ref': ref}), 200)\n        if isinstance(json, dict):\n            return Contents(json, self)\n        elif isinstance(json, list):\n            return dict((j.get('name'), Contents(j, self)) for j in json)\n        return None", "response": "Get the contents of the file pointed to by path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a blob with content.", "response": "def create_blob(self, content, encoding):\n        \"\"\"Create a blob with ``content``.\n\n        :param str content: (required), content of the blob\n        :param str encoding: (required), ('base64', 'utf-8')\n        :returns: string of the SHA returned\n        \"\"\"\n        sha = ''\n        if encoding in ('base64', 'utf-8'):\n            url = self._build_url('git', 'blobs', base_url=self._api)\n            data = {'content': content, 'encoding': encoding}\n            json = self._json(self._post(url, data=data), 201)\n            if json:\n                sha = json.get('sha')\n        return sha"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a comment on a commit.", "response": "def create_comment(self, body, sha, path=None, position=None, line=1):\n        \"\"\"Create a comment on a commit.\n\n        :param str body: (required), body of the message\n        :param str sha: (required), commit id\n        :param str path: (optional), relative path of the file to comment\n            on\n        :param str position: (optional), line index in the diff to comment on\n        :param int line: (optional), line number of the file to comment on,\n            default: 1\n        :returns: :class:`RepoComment <github3.repos.comment.RepoComment>` if\n            successful, otherwise None\n\n        \"\"\"\n        json = None\n        if body and sha and (line and int(line) > 0):\n            data = {'body': body, 'line': line, 'path': path,\n                    'position': position}\n            self._remove_none(data)\n            url = self._build_url('commits', sha, 'comments',\n                                  base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n        return RepoComment(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_commit(self, message, tree, parents, author={}, committer={}):\n        json = None\n        if message and tree and isinstance(parents, list):\n            url = self._build_url('git', 'commits', base_url=self._api)\n            data = {'message': message, 'tree': tree, 'parents': parents,\n                    'author': author, 'committer': committer}\n            json = self._json(self._post(url, data=data), 201)\n        return Commit(json, self) if json else None", "response": "Create a commit on this repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a deployment. :param str ref: (required), The ref to deploy. This can be a branch, tag, or sha. :param bool force: Optional parameter to bypass any ahead/behind checks or commit status checks. Default: False :param str payload: Optional JSON payload with extra information about the deployment. Default: \"\" :param bool auto_merge: Optional parameter to merge the default branch into the requested deployment branch if necessary. Default: False :param str description: Optional short description. Default: \"\" :param str environment: Optional name for the target deployment environment (e.g., production, staging, qa). Default: \"production\" :returns: :class:`Deployment <github3.repos.deployment.Deployment>`", "response": "def create_deployment(self, ref, force=False, payload='',\n                          auto_merge=False, description='', environment=None):\n        \"\"\"Create a deployment.\n\n        :param str ref: (required), The ref to deploy. This can be a branch,\n            tag, or sha.\n        :param bool force: Optional parameter to bypass any ahead/behind\n            checks or commit status checks. Default: False\n        :param str payload: Optional JSON payload with extra information about\n            the deployment. Default: \"\"\n        :param bool auto_merge: Optional parameter to merge the default branch\n            into the requested deployment branch if necessary. Default: False\n        :param str description: Optional short description. Default: \"\"\n        :param str environment: Optional name for the target deployment\n            environment (e.g., production, staging, qa). Default: \"production\"\n        :returns: :class:`Deployment <github3.repos.deployment.Deployment>`\n        \"\"\"\n        json = None\n        if ref:\n            url = self._build_url('deployments', base_url=self._api)\n            data = {'ref': ref, 'force': force, 'payload': payload,\n                    'auto_merge': auto_merge, 'description': description,\n                    'environment': environment}\n            self._remove_none(data)\n            headers = Deployment.CUSTOM_HEADERS\n            json = self._json(self._post(url, data=data, headers=headers),\n                              201)\n        return Deployment(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_file(self, path, message, content, branch=None,\n                    committer=None, author=None):\n        \"\"\"Create a file in this repository.\n\n        See also: http://developer.github.com/v3/repos/contents/#create-a-file\n\n        :param str path: (required), path of the file in the repository\n        :param str message: (required), commit message\n        :param bytes content: (required), the actual data in the file\n        :param str branch: (optional), branch to create the commit on.\n            Defaults to the default branch of the repository\n        :param dict committer: (optional), if no information is given the\n            authenticated user's information will be used. You must specify\n            both a name and email.\n        :param dict author: (optional), if omitted this will be filled in with\n            committer information. If passed, you must specify both a name and\n            email.\n        :returns: {\n            'content': :class:`Contents <github3.repos.contents.Contents>`:,\n            'commit': :class:`Commit <github3.git.Commit>`}\n\n        \"\"\"\n        if content and not isinstance(content, bytes):\n            raise ValueError(  # (No coverage)\n                'content must be a bytes object')  # (No coverage)\n\n        json = None\n        if path and message and content:\n            url = self._build_url('contents', path, base_url=self._api)\n            content = b64encode(content).decode('utf-8')\n            data = {'message': message, 'content': content, 'branch': branch,\n                    'committer': validate_commmitter(committer),\n                    'author': validate_commmitter(author)}\n            self._remove_none(data)\n            json = self._json(self._put(url, data=dumps(data)), 201)\n            if 'content' in json and 'commit' in json:\n                json['content'] = Contents(json['content'], self)\n                json['commit'] = Commit(json['commit'], self)\n        return json", "response": "Create a file in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_fork(self, organization=None):\n        url = self._build_url('forks', base_url=self._api)\n        if organization:\n            resp = self._post(url, data={'organization': organization})\n        else:\n            resp = self._post(url)\n        json = self._json(resp, 202)\n\n        return Repository(json, self) if json else None", "response": "Create a fork of this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_hook(self, name, config, events=['push'], active=True):\n        json = None\n        if name and config and isinstance(config, dict):\n            url = self._build_url('hooks', base_url=self._api)\n            data = {'name': name, 'config': config, 'events': events,\n                    'active': active}\n            json = self._json(self._post(url, data=data), 201)\n        return Hook(json, self) if json else None", "response": "Create a new hook on this repository."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_issue(self,\n                     title,\n                     body=None,\n                     assignee=None,\n                     milestone=None,\n                     labels=None):\n        \"\"\"Creates an issue on this repository.\n\n        :param str title: (required), title of the issue\n        :param str body: (optional), body of the issue\n        :param str assignee: (optional), login of the user to assign the\n            issue to\n        :param int milestone: (optional), id number of the milestone to\n            attribute this issue to (e.g. ``m`` is a :class:`Milestone\n            <github3.issues.milestone.Milestone>` object, ``m.number`` is\n            what you pass here.)\n        :param labels: (optional), labels to apply to this\n            issue\n        :type labels: list of strings\n        :returns: :class:`Issue <github3.issues.issue.Issue>` if successful,\n            otherwise None\n        \"\"\"\n        issue = {'title': title, 'body': body, 'assignee': assignee,\n                 'milestone': milestone, 'labels': labels}\n        self._remove_none(issue)\n        json = None\n\n        if issue:\n            url = self._build_url('issues', base_url=self._api)\n            json = self._json(self._post(url, data=issue), 201)\n\n        return Issue(json, self) if json else None", "response": "Creates an issue on this repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_key(self, title, key):\n        json = None\n        if title and key:\n            data = {'title': title, 'key': key}\n            url = self._build_url('keys', base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n        return Key(json, self) if json else None", "response": "Create a deploy key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_label(self, name, color):\n        json = None\n        if name and color:\n            data = {'name': name, 'color': color.strip('#')}\n            url = self._build_url('labels', base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n        return Label(json, self) if json else None", "response": "Create a label for this repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new milestone for this repository.", "response": "def create_milestone(self, title, state=None, description=None,\n                         due_on=None):\n        \"\"\"Create a milestone for this repository.\n\n        :param str title: (required), title of the milestone\n        :param str state: (optional), state of the milestone, accepted\n            values: ('open', 'closed'), default: 'open'\n        :param str description: (optional), description of the milestone\n        :param str due_on: (optional), ISO 8601 formatted due date\n        :returns: :class:`Milestone <github3.issues.milestone.Milestone>` if\n            successful, otherwise None\n        \"\"\"\n        url = self._build_url('milestones', base_url=self._api)\n        if state not in ('open', 'closed'):\n            state = None\n        data = {'title': title, 'state': state,\n                'description': description, 'due_on': due_on}\n        self._remove_none(data)\n        json = None\n        if data:\n            json = self._json(self._post(url, data=data), 201)\n        return Milestone(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_pull(self, title, base, head, body=None):\n        data = {'title': title, 'body': body, 'base': base,\n                'head': head}\n        return self._create_pull(data)", "response": "Create a pull request of head onto base branch in this repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_pull_from_issue(self, issue, base, head):\n        if int(issue) > 0:\n            data = {'issue': issue, 'base': base, 'head': head}\n            return self._create_pull(data)\n        return None", "response": "Create a pull request from an issue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_ref(self, ref, sha):\n        json = None\n        if ref and ref.count('/') >= 2 and sha:\n            data = {'ref': ref, 'sha': sha}\n            url = self._build_url('git', 'refs', base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n        return Reference(json, self) if json else None", "response": "Create a new reference in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_release(self, tag_name, target_commitish=None, name=None,\n                       body=None, draft=False, prerelease=False):\n        \"\"\"Create a release for this repository.\n\n        :param str tag_name: (required), name to give to the tag\n        :param str target_commitish: (optional), vague concept of a target,\n            either a SHA or a branch name.\n        :param str name: (optional), name of the release\n        :param str body: (optional), description of the release\n        :param bool draft: (optional), whether this release is a draft or not\n        :param bool prerelease: (optional), whether this is a prerelease or\n            not\n        :returns: :class:`Release <github3.repos.release.Release>`\n        \"\"\"\n        data = {'tag_name': str(tag_name),\n                'target_commitish': target_commitish,\n                'name': name,\n                'body': body,\n                'draft': draft,\n                'prerelease': prerelease\n                }\n        self._remove_none(data)\n\n        url = self._build_url('releases', base_url=self._api)\n        json = self._json(self._post(\n            url, data=data, headers=Release.CUSTOM_HEADERS\n            ), 201)\n        return Release(json, self)", "response": "Create a release for this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_status(self, sha, state, target_url=None, description=None,\n                      context='default'):\n        \"\"\"Create a status object on a commit.\n\n        :param str sha: (required), SHA of the commit to create the status on\n        :param str state: (required), state of the test; only the following\n            are accepted: 'pending', 'success', 'error', 'failure'\n        :param str target_url: (optional), URL to associate with this status.\n        :param str description: (optional), short description of the status\n        :param str context: (optional), A string label to differentiate this\n            status from the status of other systems\n        :returns: the status created if successful\n        :rtype: :class:`~github3.repos.status.Status`\n        \"\"\"\n        json = None\n        if sha and state:\n            data = {'state': state, 'target_url': target_url,\n                    'description': description, 'context': context}\n            url = self._build_url('statuses', sha, base_url=self._api)\n            self._remove_none(data)\n            json = self._json(self._post(url, data=data), 201)\n        return Status(json) if json else None", "response": "Create a status object on a commit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_tag(self, tag, message, sha, obj_type, tagger,\n                   lightweight=False):\n        \"\"\"Create a tag in this repository.\n\n        :param str tag: (required), name of the tag\n        :param str message: (required), tag message\n        :param str sha: (required), SHA of the git object this is tagging\n        :param str obj_type: (required), type of object being tagged, e.g.,\n            'commit', 'tree', 'blob'\n        :param dict tagger: (required), containing the name, email of the\n            tagger and the date it was tagged\n        :param bool lightweight: (optional), if False, create an annotated\n            tag, otherwise create a lightweight tag (a Reference).\n        :returns: If lightweight == False: :class:`Tag <github3.git.Tag>` if\n            successful, else None. If lightweight == True: :class:`Reference\n            <github3.git.Reference>`\n        \"\"\"\n        if lightweight and tag and sha:\n            return self.create_ref('refs/tags/' + tag, sha)\n\n        json = None\n        if tag and message and sha and obj_type and len(tagger) == 3:\n            data = {'tag': tag, 'message': message, 'object': sha,\n                    'type': obj_type, 'tagger': tagger}\n            url = self._build_url('git', 'tags', base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n            if json:\n                self.create_ref('refs/tags/' + tag, sha)\n        return Tag(json) if json else None", "response": "Creates a tag in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a tree on this repository.", "response": "def create_tree(self, tree, base_tree=''):\n        \"\"\"Create a tree on this repository.\n\n        :param list tree: (required), specifies the tree structure.\n            Format: [{'path': 'path/file', 'mode':\n            'filemode', 'type': 'blob or tree', 'sha': '44bfc6d...'}]\n        :param str base_tree: (optional), SHA1 of the tree you want\n            to update with new data\n        :returns: :class:`Tree <github3.git.Tree>` if successful, else None\n        \"\"\"\n        json = None\n        if tree and isinstance(tree, list):\n            data = {'tree': tree, 'base_tree': base_tree}\n            url = self._build_url('git', 'trees', base_url=self._api)\n            json = self._json(self._post(url, data=data), 201)\n        return Tree(json) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a file from the contents repository.", "response": "def delete_file(self, path, message, sha, branch=None, committer=None,\n                    author=None):\n        \"\"\"Delete the file located at ``path``.\n\n        This is part of the Contents CrUD (Create Update Delete) API. See\n        http://developer.github.com/v3/repos/contents/#delete-a-file for more\n        information.\n\n        :param str path: (required), path to the file being removed\n        :param str message: (required), commit message for the deletion\n        :param str sha: (required), blob sha of the file being removed\n        :param str branch: (optional), if not provided, uses the repository's\n            default branch\n        :param dict committer: (optional), if no information is given the\n            authenticated user's information will be used. You must specify\n            both a name and email.\n        :param dict author: (optional), if omitted this will be filled in with\n            committer information. If passed, you must specify both a name and\n            email.\n        :returns: :class:`Commit <github3.git.Commit>` if successful\n\n        \"\"\"\n        json = None\n        if path and message and sha:\n            url = self._build_url('contents', path, base_url=self._api)\n            data = {'message': message, 'sha': sha, 'branch': branch,\n                    'committer': validate_commmitter(committer),\n                    'author': validate_commmitter(author)}\n            self._remove_none(data)\n            json = self._json(self._delete(url, data=dumps(data)), 200)\n            if json and 'commit' in json:\n                json = Commit(json['commit'])\n        return json"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_key(self, key_id):\n        if int(key_id) <= 0:\n            return False\n        url = self._build_url('keys', str(key_id), base_url=self._api)\n        return self._boolean(self._delete(url), 204, 404)", "response": "Delete the key with the specified id from your deploy keys list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef edit(self,\n             name,\n             description=None,\n             homepage=None,\n             private=None,\n             has_issues=None,\n             has_wiki=None,\n             has_downloads=None,\n             default_branch=None):\n        \"\"\"Edit this repository.\n\n        :param str name: (required), name of the repository\n        :param str description: (optional), If not ``None``, change the\n            description for this repository. API default: ``None`` - leave\n            value unchanged.\n        :param str homepage: (optional), If not ``None``, change the homepage\n            for this repository. API default: ``None`` - leave value unchanged.\n        :param bool private: (optional), If ``True``, make the repository\n            private. If ``False``, make the repository public. API default:\n            ``None`` - leave value unchanged.\n        :param bool has_issues: (optional), If ``True``, enable issues for\n            this repository. If ``False``, disable issues for this repository.\n            API default: ``None`` - leave value unchanged.\n        :param bool has_wiki: (optional), If ``True``, enable the wiki for\n            this repository. If ``False``, disable the wiki for this\n            repository. API default: ``None`` - leave value unchanged.\n        :param bool has_downloads: (optional), If ``True``, enable downloads\n            for this repository. If ``False``, disable downloads for this\n            repository. API default: ``None`` - leave value unchanged.\n        :param str default_branch: (optional), If not ``None``, change the\n            default branch for this repository. API default: ``None`` - leave\n            value unchanged.\n        :returns: bool -- True if successful, False otherwise\n        \"\"\"\n        edit = {'name': name, 'description': description, 'homepage': homepage,\n                'private': private, 'has_issues': has_issues,\n                'has_wiki': has_wiki, 'has_downloads': has_downloads,\n                'default_branch': default_branch}\n        self._remove_none(edit)\n        json = None\n        if edit:\n            json = self._json(self._patch(self._api, data=dumps(edit)), 200)\n            self._update_(json)\n            return True\n        return False", "response": "Edit this repository.\n\n        :param str name: (required), name of the repository\n        :param str description: (optional), If not ``None``, change the\n            description for this repository. API default: ``None`` - leave\n            value unchanged.\n        :param str homepage: (optional), If not ``None``, change the homepage\n            for this repository. API default: ``None`` - leave value unchanged.\n        :param bool private: (optional), If ``True``, make the repository\n            private. If ``False``, make the repository public. API default:\n            ``None`` - leave value unchanged.\n        :param bool has_issues: (optional), If ``True``, enable issues for\n            this repository. If ``False``, disable issues for this repository.\n            API default: ``None`` - leave value unchanged.\n        :param bool has_wiki: (optional), If ``True``, enable the wiki for\n            this repository. If ``False``, disable the wiki for this\n            repository. API default: ``None`` - leave value unchanged.\n        :param bool has_downloads: (optional), If ``True``, enable downloads\n            for this repository. If ``False``, disable downloads for this\n            repository. API default: ``None`` - leave value unchanged.\n        :param str default_branch: (optional), If not ``None``, change the\n            default branch for this repository. API default: ``None`` - leave\n            value unchanged.\n        :returns: bool -- True if successful, False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a single ( git ) commit.", "response": "def git_commit(self, sha):\n        \"\"\"Get a single (git) commit.\n\n        :param str sha: (required), sha of the commit\n        :returns: :class:`Commit <github3.git.Commit>` if successful,\n            otherwise None\n        \"\"\"\n        json = {}\n        if sha:\n            url = self._build_url('git', 'commits', sha, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Commit(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a single hook.", "response": "def hook(self, id_num):\n        \"\"\"Get a single hook.\n\n        :param int id_num: (required), id of the hook\n        :returns: :class:`Hook <github3.repos.hook.Hook>` if successful,\n            otherwise None\n        \"\"\"\n        json = None\n        if int(id_num) > 0:\n            url = self._build_url('hooks', str(id_num), base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Hook(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the user is a possible assignee for an issue on this repository.", "response": "def is_assignee(self, login):\n        \"\"\"Check if the user is a possible assignee for an issue on this\n        repository.\n\n        :returns: :class:`bool`\n        \"\"\"\n        if not login:\n            return False\n        url = self._build_url('assignees', login, base_url=self._api)\n        return self._boolean(self._get(url), 204, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef issue(self, number):\n        json = None\n        if int(number) > 0:\n            url = self._build_url('issues', str(number), base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Issue(json, self) if json else None", "response": "Get the issue specified by number."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the specified deploy key.", "response": "def key(self, id_num):\n        \"\"\"Get the specified deploy key.\n\n        :param int id_num: (required), id of the key\n        :returns: :class:`Key <github3.users.Key>` if successful, else None\n        \"\"\"\n        json = None\n        if int(id_num) > 0:\n            url = self._build_url('keys', str(id_num), base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Key(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef label(self, name):\n        json = None\n        if name:\n            url = self._build_url('labels', name, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Label(json, self) if json else None", "response": "Get the label specified by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_branches(self, number=-1, etag=None):\n        url = self._build_url('branches', base_url=self._api)\n        return self._iter(int(number), url, Branch, etag=etag)", "response": "Iterate over the branches in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over the code frequency of the same user s additions and deletions.", "response": "def iter_code_frequency(self, number=-1, etag=None):\n        \"\"\"Iterate over the code frequency per week.\n\n        Returns a weekly aggregate of the number of additions and deletions\n        pushed to this repository.\n\n        :param int number: (optional), number of weeks to return. Default: -1\n            returns all weeks\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of lists ``[seconds_from_epoch, additions,\n            deletions]``\n\n        .. note:: All statistics methods may return a 202. On those occasions,\n                  you will not receive any objects. You should store your\n                  iterator and check the new ``last_status`` attribute. If it\n                  is a 202 you should wait before re-requesting.\n\n        .. versionadded:: 0.7\n\n        \"\"\"\n        url = self._build_url('stats', 'code_frequency', base_url=self._api)\n        return self._iter(int(number), url, list, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over comments on a single commit.", "response": "def iter_comments_on_commit(self, sha, number=1, etag=None):\n        \"\"\"Iterate over comments for a single commit.\n\n        :param sha: (required), sha of the commit to list comments on\n        :type sha: str\n        :param int number: (optional), number of comments to return. Default:\n            -1 returns all comments\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of\n            :class:`RepoComment <github3.repos.comment.RepoComment>`\\ s\n        \"\"\"\n        url = self._build_url('commits', sha, 'comments', base_url=self._api)\n        return self._iter(int(number), url, RepoComment, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_commit_activity(self, number=-1, etag=None):\n        url = self._build_url('stats', 'commit_activity', base_url=self._api)\n        return self._iter(int(number), url, dict, etag=etag)", "response": "Iterate over last year of commit activity by week."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_commits(self, sha=None, path=None, author=None, number=-1,\n                     etag=None, since=None, until=None):\n        \"\"\"Iterate over commits in this repository.\n\n        :param str sha: (optional), sha or branch to start listing commits\n            from\n        :param str path: (optional), commits containing this path will be\n            listed\n        :param str author: (optional), GitHub login, real name, or email to\n            filter commits by (using commit author)\n        :param int number: (optional), number of commits to return. Default:\n            -1 returns all commits\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :param since: (optional), Only commits after this date will\n            be returned. This can be a `datetime` or an `ISO8601` formatted\n            date string.\n        :type since: datetime or string\n        :param until: (optional), Only commits before this date will\n            be returned. This can be a `datetime` or an `ISO8601` formatted\n            date string.\n        :type until: datetime or string\n\n        :returns: generator of\n            :class:`RepoCommit <github3.repos.commit.RepoCommit>`\\ s\n        \"\"\"\n        params = {'sha': sha, 'path': path, 'author': author,\n                  'since': timestamp_parameter(since),\n                  'until': timestamp_parameter(until)}\n\n        self._remove_none(params)\n        url = self._build_url('commits', base_url=self._api)\n        return self._iter(int(number), url, RepoCommit, params, etag)", "response": "Iterate over commits in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over the contributors to this repository.", "response": "def iter_contributors(self, anon=False, number=-1, etag=None):\n        \"\"\"Iterate over the contributors to this repository.\n\n        :param bool anon: (optional), True lists anonymous contributors as\n            well\n        :param int number: (optional), number of contributors to return.\n            Default: -1 returns all contributors\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`User <github3.users.User>`\\ s\n        \"\"\"\n        url = self._build_url('contributors', base_url=self._api)\n        params = {}\n        if anon:\n            params = {'anon': True}\n        return self._iter(int(number), url, User, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_contributor_statistics(self, number=-1, etag=None):\n        url = self._build_url('stats', 'contributors', base_url=self._api)\n        return self._iter(int(number), url, ContributorStats, etag=etag)", "response": "Iterate over the contributors list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_deployments(self, number=-1, etag=None):\n        url = self._build_url('deployments', base_url=self._api)\n        i = self._iter(int(number), url, Deployment, etag=etag)\n        i.headers.update(Deployment.CUSTOM_HEADERS)\n        return i", "response": "Iterate over deployments for this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_forks(self, sort='', number=-1, etag=None):\n        url = self._build_url('forks', base_url=self._api)\n        params = {}\n        if sort in ('newest', 'oldest', 'watchers'):\n            params = {'sort': sort}\n        return self._iter(int(number), url, Repository, params, etag)", "response": "Iterate over forks of this repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over the hooks registered on this repository.", "response": "def iter_hooks(self, number=-1, etag=None):\n        \"\"\"Iterate over hooks registered on this repository.\n\n        :param int number: (optional), number of hoks to return. Default: -1\n            returns all hooks\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Hook <github3.repos.hook.Hook>`\\ s\n        \"\"\"\n        url = self._build_url('hooks', base_url=self._api)\n        return self._iter(int(number), url, Hook, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_issues(self,\n                    milestone=None,\n                    state=None,\n                    assignee=None,\n                    mentioned=None,\n                    labels=None,\n                    sort=None,\n                    direction=None,\n                    since=None,\n                    number=-1,\n                    etag=None):\n        \"\"\"Iterate over issues on this repo based upon parameters passed.\n\n        .. versionchanged:: 0.9.0\n\n            The ``state`` parameter now accepts 'all' in addition to 'open'\n            and 'closed'.\n\n        :param int milestone: (optional), 'none', or '*'\n        :param str state: (optional), accepted values: ('all', 'open',\n            'closed')\n        :param str assignee: (optional), 'none', '*', or login name\n        :param str mentioned: (optional), user's login name\n        :param str labels: (optional), comma-separated list of labels, e.g.\n            'bug,ui,@high'\n        :param sort: (optional), accepted values:\n            ('created', 'updated', 'comments', 'created')\n        :param str direction: (optional), accepted values: ('asc', 'desc')\n        :param since: (optional), Only issues after this date will\n            be returned. This can be a `datetime` or an `ISO8601` formatted\n            date string, e.g., 2012-05-20T23:10:27Z\n        :type since: datetime or string\n        :param int number: (optional), Number of issues to return.\n            By default all issues are returned\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Issue <github3.issues.issue.Issue>`\\ s\n        \"\"\"\n        url = self._build_url('issues', base_url=self._api)\n\n        params = {'assignee': assignee, 'mentioned': mentioned}\n        if milestone in ('*', 'none') or isinstance(milestone, int):\n            params['milestone'] = milestone\n        self._remove_none(params)\n        params.update(\n            issue_params(None, state, labels, sort, direction,\n                         since)\n        )\n\n        return self._iter(int(number), url, Issue, params, etag)", "response": "Iterate over issues on this repo based upon parameters passed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_issue_events(self, number=-1, etag=None):\n        url = self._build_url('issues', 'events', base_url=self._api)\n        return self._iter(int(number), url, IssueEvent, etag=etag)", "response": "Iterates over issue events on this repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate over the programming languages used in the repository.", "response": "def iter_languages(self, number=-1, etag=None):\n        \"\"\"Iterate over the programming languages used in the repository.\n\n        :param int number: (optional), number of languages to return. Default:\n            -1 returns all used languages\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of tuples\n        \"\"\"\n        url = self._build_url('languages', base_url=self._api)\n        return self._iter(int(number), url, tuple, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an iterator over the milestones on this repository.", "response": "def iter_milestones(self, state=None, sort=None, direction=None,\n                        number=-1, etag=None):\n        \"\"\"Iterates over the milestones on this repository.\n\n        :param str state: (optional), state of the milestones, accepted\n            values: ('open', 'closed')\n        :param str sort: (optional), how to sort the milestones, accepted\n            values: ('due_date', 'completeness')\n        :param str direction: (optional), direction to sort the milestones,\n            accepted values: ('asc', 'desc')\n        :param int number: (optional), number of milestones to return.\n            Default: -1 returns all milestones\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of\n            :class:`Milestone <github3.issues.milestone.Milestone>`\\ s\n        \"\"\"\n        url = self._build_url('milestones', base_url=self._api)\n        accepted = {'state': ('open', 'closed'),\n                    'sort': ('due_date', 'completeness'),\n                    'direction': ('asc', 'desc')}\n        params = {'state': state, 'sort': sort, 'direction': direction}\n        for (k, v) in list(params.items()):\n            if not (v and (v in accepted[k])):  # e.g., '' or None\n                del params[k]\n        if not params:\n            params = None\n        return self._iter(int(number), url, Milestone, params, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over events on a network of repositories.", "response": "def iter_network_events(self, number=-1, etag=None):\n        \"\"\"Iterates over events on a network of repositories.\n\n        :param int number: (optional), number of events to return. Default: -1\n            returns all available events\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Event <github3.events.Event>`\\ s\n        \"\"\"\n        base = self._api.replace('repos', 'networks', 1)\n        url = self._build_url('events', base_url=base)\n        return self._iter(int(number), url, Event, etag)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_notifications(self, all=False, participating=False, since=None,\n                           number=-1, etag=None):\n        \"\"\"Iterates over the notifications for this repository.\n\n        :param bool all: (optional), show all notifications, including ones\n            marked as read\n        :param bool participating: (optional), show only the notifications the\n            user is participating in directly\n        :param since: (optional), filters out any notifications updated\n            before the given time. This can be a `datetime` or an `ISO8601`\n            formatted date string, e.g., 2012-05-20T23:10:27Z\n        :type since: datetime or string\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Thread <github3.notifications.Thread>`\n        \"\"\"\n        url = self._build_url('notifications', base_url=self._api)\n        params = {\n            'all': all,\n            'participating': participating,\n            'since': timestamp_parameter(since)\n        }\n        for (k, v) in list(params.items()):\n            if not v:\n                del params[k]\n        return self._iter(int(number), url, Thread, params, etag)", "response": "Iterates over the notifications for this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates over pages builds of this repository.", "response": "def iter_pages_builds(self, number=-1, etag=None):\n        \"\"\"Iterate over pages builds of this repository.\n\n        :returns: generator of :class:`PagesBuild\n            <github3.repos.pages.PagesBuild>`\n        \"\"\"\n        url = self._build_url('pages', 'builds', base_url=self._api)\n        return self._iter(int(number), url, PagesBuild, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_pulls(self, state=None, head=None, base=None, sort='created',\n                   direction='desc', number=-1, etag=None):\n        \"\"\"List pull requests on repository.\n\n        .. versionchanged:: 0.9.0\n\n            - The ``state`` parameter now accepts 'all' in addition to 'open'\n              and 'closed'.\n\n            - The ``sort`` parameter was added.\n\n            - The ``direction`` parameter was added.\n\n        :param str state: (optional), accepted values: ('all', 'open',\n            'closed')\n        :param str head: (optional), filters pulls by head user and branch\n            name in the format ``user:ref-name``, e.g., ``seveas:debian``\n        :param str base: (optional), filter pulls by base branch name.\n            Example: ``develop``.\n        :param str sort: (optional), Sort pull requests by ``created``,\n            ``updated``, ``popularity``, ``long-running``. Default: 'created'\n        :param str direction: (optional), Choose the direction to list pull\n            requests. Accepted values: ('desc', 'asc'). Default: 'desc'\n        :param int number: (optional), number of pulls to return. Default: -1\n            returns all available pull requests\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of\n            :class:`PullRequest <github3.pulls.PullRequest>`\\ s\n        \"\"\"\n        url = self._build_url('pulls', base_url=self._api)\n        params = {}\n        if state and state.lower() in ('all', 'open', 'closed'):\n            params['state'] = state.lower()\n        params.update(head=head, base=base, sort=sort, direction=direction)\n        self._remove_none(params)\n        return self._iter(int(number), url, PullRequest, params, etag)", "response": "Returns an iterator over the pull requests on the repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over the refs for this repository.", "response": "def iter_refs(self, subspace='', number=-1, etag=None):\n        \"\"\"Iterates over references for this repository.\n\n        :param str subspace: (optional), e.g. 'tags', 'stashes', 'notes'\n        :param int number: (optional), number of refs to return. Default: -1\n            returns all available refs\n        :param str etag: (optional), ETag from a previous request to the same\n            endpoint\n        :returns: generator of :class:`Reference <github3.git.Reference>`\\ s\n        \"\"\"\n        if subspace:\n            args = ('git', 'refs', subspace)\n        else:\n            args = ('git', 'refs')\n        url = self._build_url(*args, base_url=self._api)\n        return self._iter(int(number), url, Reference, etag=etag)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_releases(self, number=-1, etag=None):\n        url = self._build_url('releases', base_url=self._api)\n        iterator = self._iter(int(number), url, Release, etag=etag)\n        iterator.headers.update(Release.CUSTOM_HEADERS)\n        return iterator", "response": "Iterates over releases for this repository."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_statuses(self, sha, number=-1, etag=None):\n        url = ''\n        if sha:\n            url = self._build_url('statuses', sha, base_url=self._api)\n        return self._iter(int(number), url, Status, etag=etag)", "response": "Iterates over the statuses of a specific SHA."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_tags(self, number=-1, etag=None):\n        url = self._build_url('tags', base_url=self._api)\n        return self._iter(int(number), url, RepoTag, etag=etag)", "response": "Iterates over tags on this repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmarks all notifications in this repository as read.", "response": "def mark_notifications(self, last_read=''):\n        \"\"\"Mark all notifications in this repository as read.\n\n        :param str last_read: (optional), Describes the last point that\n            notifications were checked. Anything updated since this time will\n            not be updated. Default: Now. Expected in ISO 8601 format:\n            ``YYYY-MM-DDTHH:MM:SSZ``. Example: \"2012-10-09T23:39:01Z\".\n        :returns: bool\n        \"\"\"\n        url = self._build_url('notifications', base_url=self._api)\n        mark = {'read': True}\n        if last_read:\n            mark['last_read_at'] = last_read\n        return self._boolean(self._put(url, data=dumps(mark)),\n                             205, 404)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge(self, base, head, message=''):\n        url = self._build_url('merges', base_url=self._api)\n        data = {'base': base, 'head': head}\n        if message:\n            data['commit_message'] = message\n        json = self._json(self._post(url, data=data), 201)\n        return RepoCommit(json, self) if json else None", "response": "Perform a merge from head into base."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef milestone(self, number):\n        json = None\n        if int(number) > 0:\n            url = self._build_url('milestones', str(number),\n                                  base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Milestone(json, self) if json else None", "response": "Get the milestone identified by number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting information about this repository s pages site.", "response": "def pages(self):\n        \"\"\"Get information about this repository's pages site.\n\n        :returns: :class:`PagesInfo <github3.repos.pages.PagesInfo>`\n        \"\"\"\n        url = self._build_url('pages', base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return PagesInfo(json) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the pull request indicated by number.", "response": "def pull_request(self, number):\n        \"\"\"Get the pull request indicated by ``number``.\n\n        :param int number: (required), number of the pull request.\n        :returns: :class:`PullRequest <github3.pulls.PullRequest>`\n        \"\"\"\n        json = None\n        if int(number) > 0:\n            url = self._build_url('pulls', str(number), base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return PullRequest(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the README for this repository.", "response": "def readme(self):\n        \"\"\"Get the README for this repository.\n\n        :returns: :class:`Contents <github3.repos.contents.Contents>`\n        \"\"\"\n        url = self._build_url('readme', base_url=self._api)\n        json = self._json(self._get(url), 200)\n        return Contents(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a reference in the system.", "response": "def ref(self, ref):\n        \"\"\"Get a reference pointed to by ``ref``.\n\n        The most common will be branches and tags. For a branch, you must\n        specify 'heads/branchname' and for a tag, 'tags/tagname'. Essentially,\n        the system should return any reference you provide it in the namespace,\n        including notes and stashes (provided they exist on the server).\n\n        :param str ref: (required)\n        :returns: :class:`Reference <github3.git.Reference>`\n        \"\"\"\n        json = None\n        if ref:\n            url = self._build_url('git', 'refs', ref, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Reference(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a single release.", "response": "def release(self, id):\n        \"\"\"Get a single release.\n\n        :param int id: (required), id of release\n        :returns: :class:`Release <github3.repos.release.Release>`\n        \"\"\"\n        json = None\n        if int(id) > 0:\n            url = self._build_url('releases', str(id), base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Release(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_collaborator(self, login):\n        resp = False\n        if login:\n            url = self._build_url('collaborators', login, base_url=self._api)\n            resp = self._boolean(self._delete(url), 204, 404)\n        return resp", "response": "Removes the collaborator login from the repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tag(self, sha):\n        json = None\n        if sha:\n            url = self._build_url('git', 'tags', sha, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Tag(json) if json else None", "response": "Get an annotated tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tree(self, sha):\n        json = None\n        if sha:\n            url = self._build_url('git', 'trees', sha, base_url=self._api)\n            json = self._json(self._get(url), 200)\n        return Tree(json, self) if json else None", "response": "Get a tree.\n\n        :param str sha: (required), sha of the object for this tree\n        :returns: :class:`Tree <github3.git.Tree>`"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_label(self, name, color, new_name=''):\n        label = self.label(name)\n        resp = False\n        if label:\n            upd = label.update\n            resp = upd(new_name, color) if new_name else upd(name, color)\n        return resp", "response": "Update the label name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef weekly_commit_count(self):\n        url = self._build_url('stats', 'participation', base_url=self._api)\n        resp = self._get(url)\n        if resp.status_code == 202:\n            return {}\n        json = self._json(resp, 200)\n        if json.get('ETag'):\n            del json['ETag']\n        if json.get('Last-Modified'):\n            del json['Last-Modified']\n        return json", "response": "Returns the total commit counts for the weekly participation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rename(args):\n    old_name, new_name = args.names\n    add_tags(resources.ec2.Instance(resolve_instance_id(old_name)), Name=new_name, dry_run=args.dry_run)", "response": "Supply two names: Existing instance name or ID and new name to assign to the instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_status(self, state, target_url='', description=''):\n        json = None\n\n        if state in ('pending', 'success', 'error', 'failure'):\n            data = {'state': state, 'target_url': target_url,\n                    'description': description}\n            response = self._post(self.statuses_url, data=data,\n                                  headers=Deployment.CUSTOM_HEADERS)\n            json = self._json(response, 201)\n\n        return DeploymentStatus(json, self) if json else None", "response": "Create a new deployment status for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_statuses(self, number=-1, etag=None):\n        i = self._iter(int(number), self.statuses_url, DeploymentStatus,\n                       etag=etag)\n        i.headers = Deployment.CUSTOM_HEADERS\n        return i", "response": "Iterate over the deployment statuses for this deployment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gist(self):\n        from .gist import Gist\n        json = self._json(self._get(self._api), 200)\n        return Gist(json, self)", "response": "Retrieve the gist at this version."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, sha, force=False):\n        data = {'sha': sha, 'force': force}\n        json = self._json(self._patch(self._api, data=dumps(data)), 200)\n        if json:\n            self._update_(json)\n            return True\n        return False", "response": "Update this reference.\n\n        :param str sha: (required), sha of the reference\n        :param bool force: (optional), force the update or not\n        :returns: bool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_table(table, column_names=None, column_specs=None, max_col_width=32, auto_col_width=False):\n    orig_col_args = dict(column_names=column_names, column_specs=column_specs)\n    if len(table) > 0:\n        col_widths = [0] * len(table[0])\n    elif column_specs is not None:\n        col_widths = [0] * (len(column_specs) + 1)\n    elif column_names is not None:\n        col_widths = [0] * len(column_names)\n    my_col_names, id_column = [], None\n    if column_specs is not None:\n        column_names = [\"Row\"]\n        column_names.extend([col[\"name\"] for col in column_specs])\n        column_specs = [{\"name\": \"Row\", \"type\": \"float\"}] + column_specs\n    if column_names is not None:\n        for i in range(len(column_names)):\n            if column_names[i].lower() == \"id\":\n                id_column = i\n            my_col = ansi_truncate(str(column_names[i]), max_col_width if i not in {0, id_column} else 99)\n            my_col_names.append(my_col)\n            col_widths[i] = max(col_widths[i], len(strip_ansi_codes(my_col)))\n    trunc_table = []\n    for row in table:\n        my_row = []\n        for i in range(len(row)):\n            my_item = ansi_truncate(str(row[i]), max_col_width if i not in {0, id_column} else 99)\n            my_row.append(my_item)\n            col_widths[i] = max(col_widths[i], len(strip_ansi_codes(my_item)))\n        trunc_table.append(my_row)\n\n    type_colormap = {\"boolean\": BLUE(),\n                     \"integer\": YELLOW(),\n                     \"float\": WHITE(),\n                     \"string\": GREEN()}\n    for i in \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"int64\":\n        type_colormap[i] = type_colormap[\"integer\"]\n    type_colormap[\"double\"] = type_colormap[\"float\"]\n\n    def col_head(i):\n        if column_specs is not None:\n            return BOLD() + type_colormap[column_specs[i][\"type\"]] + column_names[i] + ENDC()\n        else:\n            return BOLD() + WHITE() + column_names[i] + ENDC()\n\n    formatted_table = [border(\"\u250c\") + border(\"\u252c\").join(border(\"\u2500\") * i for i in col_widths) + border(\"\u2510\")]\n    if len(my_col_names) > 0:\n        padded_column_names = [col_head(i) + \" \" * (col_widths[i] - len(my_col_names[i]))\n                               for i in range(len(my_col_names))]\n        formatted_table.append(border(\"\u2502\") + border(\"\u2502\").join(padded_column_names) + border(\"\u2502\"))\n        formatted_table.append(border(\"\u251c\") + border(\"\u253c\").join(border(\"\u2500\") * i for i in col_widths) + border(\"\u2524\"))\n\n    for row in trunc_table:\n        padded_row = [row[i] + \" \" * (col_widths[i] - len(strip_ansi_codes(row[i]))) for i in range(len(row))]\n        formatted_table.append(border(\"\u2502\") + border(\"\u2502\").join(padded_row) + border(\"\u2502\"))\n    formatted_table.append(border(\"\u2514\") + border(\"\u2534\").join(border(\"\u2500\") * i for i in col_widths) + border(\"\u2518\"))\n\n    if auto_col_width:\n        if not sys.stdout.isatty():\n            raise AegeaException(\"Cannot auto-format table, output is not a terminal\")\n        table_width = len(strip_ansi_codes(formatted_table[0]))\n        tty_cols, tty_rows = get_terminal_size()\n        if table_width > max(tty_cols, 80):\n            return format_table(table, max_col_width=max_col_width - 1, auto_col_width=True, **orig_col_args)\n    return \"\\n\".join(formatted_table)", "response": "Pretty printer for the log entries in a tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(args):\n    from . import config\n    for key in args.key.split(\".\"):\n        config = getattr(config, key)\n    print(json.dumps(config))", "response": "Get an Aegea configuration parameter by name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(args):\n    from . import config, tweak\n\n    class ConfigSaver(tweak.Config):\n        @property\n        def config_files(self):\n            return [config.config_files[2]]\n\n    config_saver = ConfigSaver(use_yaml=True, save_on_exit=False)\n    c = config_saver\n    for key in args.key.split(\".\")[:-1]:\n        try:\n            c = c[key]\n        except KeyError:\n            c[key] = {}\n            c = c[key]\n    c[args.key.split(\".\")[-1]] = json.loads(args.value) if args.json else args.value\n    config_saver.save()", "response": "Set an Aegea configuration parameter to a given value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nobtaining an authorization token for the GitHub API.", "response": "def authorize(login, password, scopes, note='', note_url='', client_id='',\n              client_secret='', two_factor_callback=None):\n    \"\"\"Obtain an authorization token for the GitHub API.\n\n    :param str login: (required)\n    :param str password: (required)\n    :param list scopes: (required), areas you want this token to apply to,\n        i.e., 'gist', 'user'\n    :param str note: (optional), note about the authorization\n    :param str note_url: (optional), url for the application\n    :param str client_id: (optional), 20 character OAuth client key for which\n        to create a token\n    :param str client_secret: (optional), 40 character OAuth client secret for\n        which to create the token\n    :param func two_factor_callback: (optional), function to call when a\n        Two-Factor Authentication code needs to be provided by the user.\n    :returns: :class:`Authorization <Authorization>`\n\n    \"\"\"\n    gh = GitHub()\n    gh.login(two_factor_callback=two_factor_callback)\n    return gh.authorize(login, password, scopes, note, note_url, client_id,\n                        client_secret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs and return an authenticated GitHub session.", "response": "def login(username=None, password=None, token=None, url=None,\n          two_factor_callback=None):\n    \"\"\"Construct and return an authenticated GitHub session.\n\n    This will return a GitHubEnterprise session if a url is provided.\n\n    :param str username: login name\n    :param str password: password for the login\n    :param str token: OAuth token\n    :param str url: (optional), URL of a GitHub Enterprise instance\n    :param func two_factor_callback: (optional), function you implement to\n        provide the Two Factor Authentication code to GitHub when necessary\n    :returns: :class:`GitHub <github3.github.GitHub>`\n\n    \"\"\"\n    g = None\n\n    if (username and password) or token:\n        g = GitHubEnterprise(url) if url is not None else GitHub()\n        g.login(username, password, token, two_factor_callback)\n\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_followers(username, number=-1, etag=None):\n    return gh.iter_followers(username, number, etag) if username else []", "response": "List the followers of username."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_following(username, number=-1, etag=None):\n    return gh.iter_following(username, number, etag) if username else []", "response": "List the people username follows."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an iterator over the issues in the repository.", "response": "def iter_repo_issues(owner, repository, milestone=None, state=None,\n                     assignee=None, mentioned=None, labels=None, sort=None,\n                     direction=None, since=None, number=-1, etag=None):\n    \"\"\"List issues on owner/repository. Only owner and repository are\n    required.\n\n    .. versionchanged:: 0.9.0\n\n        - The ``state`` parameter now accepts 'all' in addition to 'open'\n          and 'closed'.\n\n    :param str owner: login of the owner of the repository\n    :param str repository: name of the repository\n    :param int milestone: None, '*', or ID of milestone\n    :param str state: accepted values: ('all', 'open', 'closed')\n        api-default: 'open'\n    :param str assignee: '*' or login of the user\n    :param str mentioned: login of the user\n    :param str labels: comma-separated list of label names, e.g.,\n        'bug,ui,@high'\n    :param str sort: accepted values: ('created', 'updated', 'comments')\n        api-default: created\n    :param str direction: accepted values: ('asc', 'desc')\n        api-default: desc\n    :param since: (optional), Only issues after this date will\n        be returned. This can be a `datetime` or an ISO8601 formatted\n        date string, e.g., 2012-05-20T23:10:27Z\n    :type since: datetime or string\n    :param int number: (optional), number of issues to return.\n        Default: -1 returns all issues\n    :param str etag: (optional), ETag from a previous request to the same\n        endpoint\n    :returns: generator of :class:`Issue <github3.issues.Issue>`\\ s\n\n    \"\"\"\n    if owner and repository:\n        return gh.iter_repo_issues(owner, repository, milestone, state,\n                                   assignee, mentioned, labels, sort,\n                                   direction, since, number, etag)\n    return iter([])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist the organizations associated with username.", "response": "def iter_orgs(username, number=-1, etag=None):\n    \"\"\"List the organizations associated with ``username``.\n\n    :param str username: (required), login of the user\n    :param int number: (optional), number of orgs to return. Default: -1,\n        return all of the issues\n    :param str etag: (optional), ETag from a previous request to the same\n        endpoint\n    :returns: generator of\n        :class:`Organization <github3.orgs.Organization>`\n\n    \"\"\"\n    return gh.iter_orgs(username, number, etag) if username else []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_user_repos(login, type=None, sort=None, direction=None, number=-1,\n                    etag=None):\n    \"\"\"List public repositories for the specified ``login``.\n\n    .. versionadded:: 0.6\n\n    .. note:: This replaces github3.iter_repos\n\n    :param str login: (required)\n    :param str type: (optional), accepted values:\n        ('all', 'owner', 'member')\n        API default: 'all'\n    :param str sort: (optional), accepted values:\n        ('created', 'updated', 'pushed', 'full_name')\n        API default: 'created'\n    :param str direction: (optional), accepted values:\n        ('asc', 'desc'), API default: 'asc' when using 'full_name',\n        'desc' otherwise\n    :param int number: (optional), number of repositories to return.\n        Default: -1 returns all repositories\n    :param str etag: (optional), ETag from a previous request to the same\n        endpoint\n    :returns: generator of :class:`Repository <github3.repos.Repository>`\n        objects\n\n    \"\"\"\n    if login:\n        return gh.iter_user_repos(login, type, sort, direction, number, etag)\n    return iter([])", "response": "List public repositories for the specified login."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef markdown(text, mode='', context='', raw=False):\n    return gh.markdown(text, mode, context, raw)", "response": "Render an arbitrary markdown document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_repositories(query, sort=None, order=None, per_page=None,\n                        text_match=False, number=-1, etag=None):\n    \"\"\"Find repositories via various criteria.\n\n    .. warning::\n\n        You will only be able to make 5 calls with this or other search\n        functions. To raise the rate-limit on this set of endpoints, create an\n        authenticated :class:`GitHub <github3.github.GitHub>` Session with\n        ``login``.\n\n    The query can contain any combination of the following supported\n    qualifers:\n\n    - ``in`` Qualifies which fields are searched. With this qualifier you\n      can restrict the search to just the repository name, description,\n      readme, or any combination of these.\n    - ``size`` Finds repositories that match a certain size (in\n      kilobytes).\n    - ``forks`` Filters repositories based on the number of forks, and/or\n      whether forked repositories should be included in the results at\n      all.\n    - ``created`` or ``pushed`` Filters repositories based on times of\n      creation, or when they were last updated. Format: ``YYYY-MM-DD``.\n      Examples: ``created:<2011``, ``pushed:<2013-02``,\n      ``pushed:>=2013-03-06``\n    - ``user`` or ``repo`` Limits searches to a specific user or\n      repository.\n    - ``language`` Searches repositories based on the language they're\n      written in.\n    - ``stars`` Searches repositories based on the number of stars.\n\n    For more information about these qualifiers, see: http://git.io/4Z8AkA\n\n    :param str query: (required), a valid query as described above, e.g.,\n        ``tetris language:assembly``\n    :param str sort: (optional), how the results should be sorted;\n        options: ``stars``, ``forks``, ``updated``; default: best match\n    :param str order: (optional), the direction of the sorted results,\n        options: ``asc``, ``desc``; default: ``desc``\n    :param int per_page: (optional)\n    :param bool text_match: (optional), if True, return matching search\n        terms. See http://git.io/4ct1eQ for more information\n    :param int number: (optional), number of repositories to return.\n        Default: -1, returns all available repositories\n    :param str etag: (optional), previous ETag header value\n    :return: generator of :class:`Repository <github3.repos.Repository>`\n    \"\"\"\n    return gh.search_repositories(query, sort, order, per_page, text_match,\n                                  number, etag)", "response": "Search repositories via various criteria."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef limits(args):\n    # https://aws.amazon.com/about-aws/whats-new/2014/06/19/amazon-ec2-service-limits-report-now-available/\n    # Console-only APIs: getInstanceLimits, getAccountLimits, getAutoscalingLimits, getHostLimits\n    # http://boto3.readthedocs.io/en/latest/reference/services/dynamodb.html#DynamoDB.Client.describe_limits\n    attrs = [\"max-instances\", \"vpc-max-security-groups-per-interface\", \"vpc-max-elastic-ips\"]\n    table = clients.ec2.describe_account_attributes(AttributeNames=attrs)[\"AccountAttributes\"]\n    page_output(tabulate(table, args))", "response": "Describe limits in effect on your AWS account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd labels to this issue.", "response": "def add_labels(self, *args):\n        \"\"\"Add labels to this issue.\n\n        :param str args: (required), names of the labels you wish to add\n        :returns: list of :class:`Label`\\ s\n        \"\"\"\n        url = self._build_url('labels', base_url=self._api)\n        json = self._json(self._post(url, data=args), 200)\n        return [Label(l, self) for l in json] if json else []"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassigns user login to this issue.", "response": "def assign(self, login):\n        \"\"\"Assigns user ``login`` to this issue. This is a short cut for\n        ``issue.edit``.\n\n        :param str login: username of the person to assign this issue to\n        :returns: bool\n        \"\"\"\n        if not login:\n            return False\n        number = self.milestone.number if self.milestone else None\n        labels = [str(l) for l in self.labels]\n        return self.edit(self.title, self.body, login, self.state, number,\n                         labels)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a single issue comment by its id.", "response": "def comment(self, id_num):\n        \"\"\"Get a single comment by its id.\n\n        The catch here is that id is NOT a simple number to obtain. If\n        you were to look at the comments on issue #15 in\n        sigmavirus24/Todo.txt-python, the first comment's id is 4150787.\n\n        :param int id_num: (required), comment id, see example above\n        :returns: :class:`IssueComment <github3.issues.comment.IssueComment>`\n        \"\"\"\n        json = None\n        if int(id_num) > 0:  # Might as well check that it's positive\n            owner, repo = self.repository\n            url = self._build_url('repos', owner, repo, 'issues', 'comments',\n                                  str(id_num))\n            json = self._json(self._get(url), 200)\n        return IssueComment(json) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a comment on this issue.", "response": "def create_comment(self, body):\n        \"\"\"Create a comment on this issue.\n\n        :param str body: (required), comment body\n        :returns: :class:`IssueComment <github3.issues.comment.IssueComment>`\n        \"\"\"\n        json = None\n        if body:\n            url = self._build_url('comments', base_url=self._api)\n            json = self._json(self._post(url, data={'body': body}),\n                              201)\n        return IssueComment(json, self) if json else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit(self, title=None, body=None, assignee=None, state=None,\n             milestone=None, labels=None):\n        \"\"\"Edit this issue.\n\n        :param str title: Title of the issue\n        :param str body: markdown formatted body (description) of the issue\n        :param str assignee: login name of user the issue should be assigned\n            to\n        :param str state: accepted values: ('open', 'closed')\n        :param int milestone: the NUMBER (not title) of the milestone to\n            assign this to [1]_, or 0 to remove the milestone\n        :param list labels: list of labels to apply this to\n        :returns: bool\n\n        .. [1] Milestone numbering starts at 1, i.e. the first milestone you\n               create is 1, the second is 2, etc.\n        \"\"\"\n        json = None\n        data = {'title': title, 'body': body, 'assignee': assignee,\n                'state': state, 'milestone': milestone, 'labels': labels}\n        self._remove_none(data)\n        if data:\n            if 'milestone' in data and data['milestone'] == 0:\n                data['milestone'] = None\n            json = self._json(self._patch(self._api, data=dumps(data)), 200)\n        if json:\n            self._update_(json)\n            return True\n        return False", "response": "Edit this issue.\n\n        :param str title: Title of the issue\n        :param str body: markdown formatted body (description) of the issue\n        :param str assignee: login name of user the issue should be assigned\n            to\n        :param str state: accepted values: ('open', 'closed')\n        :param int milestone: the NUMBER (not title) of the milestone to\n            assign this to [1]_, or 0 to remove the milestone\n        :param list labels: list of labels to apply this to\n        :returns: bool\n\n        .. [1] Milestone numbering starts at 1, i.e. the first milestone you\n               create is 1, the second is 2, etc."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_comments(self, number=-1):\n        url = self._build_url('comments', base_url=self._api)\n        return self._iter(int(number), url, IssueComment)", "response": "Iterate over the comments on this issue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_events(self, number=-1):\n        url = self._build_url('events', base_url=self._api)\n        return self._iter(int(number), url, IssueEvent)", "response": "Iterate over events associated with this issue only."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_label(self, name):\n        url = self._build_url('labels', name, base_url=self._api)\n        # Docs say it should be a list of strings returned, practice says it\n        # is just a 204/404 response. I'm tenatively changing this until I\n        # hear back from Support.\n        return self._boolean(self._delete(url), 204, 404)", "response": "Removes a label from this issue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplace all labels on this issue with labels.", "response": "def replace_labels(self, labels):\n        \"\"\"Replace all labels on this issue with ``labels``.\n\n        :param list labels: label names\n        :returns: bool\n        \"\"\"\n        url = self._build_url('labels', base_url=self._api)\n        json = self._json(self._put(url, data=dumps(labels)), 200)\n        return [Label(l, self) for l in json] if json else []"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nre-opens a closed issue. :returns: bool", "response": "def reopen(self):\n        \"\"\"Re-open a closed issue.\n\n        :returns: bool\n        \"\"\"\n        assignee = self.assignee.login if self.assignee else ''\n        number = self.milestone.number if self.milestone else None\n        labels = [str(l) for l in self.labels]\n        return self.edit(self.title, self.body, assignee, 'open',\n                         number, labels)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert an ISO 8601 formatted string in UTC into a timezone - aware datetime object.", "response": "def _strptime(self, time_str):\n        \"\"\"Convert an ISO 8601 formatted string in UTC into a\n        timezone-aware datetime object.\"\"\"\n        if time_str:\n            # Parse UTC string into naive datetime, then add timezone\n            dt = datetime.strptime(time_str, __timeformat__)\n            return dt.replace(tzinfo=UTC())\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of requests before GitHub imposes a ratelimit.", "response": "def ratelimit_remaining(self):\n        \"\"\"Number of requests before GitHub imposes a ratelimit.\n\n        :returns: int\n        \"\"\"\n        json = self._json(self._get(self._github_url + '/rate_limit'), 200)\n        core = json.get('resources', {}).get('core', {})\n        self._remaining = core.get('remaining', 0)\n        return self._remaining"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(self, conditional=False):\n        headers = {}\n        if conditional:\n            if self.last_modified:\n                headers['If-Modified-Since'] = self.last_modified\n            elif self.etag:\n                headers['If-None-Match'] = self.etag\n\n        headers = headers or None\n        json = self._json(self._get(self._api, headers=headers), 200)\n        if json is not None:\n            self.__init__(json, self._session)\n        return self", "response": "Re - retrieve the information for this object and returns the refreshed instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nedits this comment. :param str body: (required), new body of the comment, Markdown formatted :returns: bool", "response": "def edit(self, body):\n        \"\"\"Edit this comment.\n\n        :param str body: (required), new body of the comment, Markdown\n            formatted\n        :returns: bool\n        \"\"\"\n        if body:\n            json = self._json(self._patch(self._api,\n                              data=dumps({'body': body})), 200)\n            if json:\n                self._update_(json)\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that the given table is valid for conversion to a grid table.", "response": "def check_table(table):\n    \"\"\"\n    Ensure the table is valid for converting to grid table.\n\n    * The table must a list of lists\n    * Each row must contain the same number of columns\n    * The table must not be empty\n\n    Parameters\n    ----------\n    table : list of lists of str\n        The list of rows of strings to convert to a grid table\n\n    Returns\n    -------\n    message : str\n        If no problems are found, this message is empty, otherwise it\n        tries to describe the problem that was found.\n    \"\"\"\n    if not type(table) is list:\n        return \"Table must be a list of lists\"\n\n    if len(table) == 0:\n        return \"Table must contain at least one row and one column\"\n\n    for i in range(len(table)):\n        if not type(table[i]) is list:\n            return \"Table must be a list of lists\"\n        if not len(table[i]) == len(table[0]):\n            \"Each row must have the same number of columns\"\n\n    return \"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the span containing the row column pair", "response": "def get_span(spans, row, column):\n    \"\"\"\n    Gets the span containing the [row, column] pair\n\n    Parameters\n    ----------\n    spans : list of lists of lists\n        A list containing spans, which are lists of [row, column] pairs\n        that define where a span is inside a table.\n\n    Returns\n    -------\n    span : list of lists\n        A span containing the [row, column] pair\n    \"\"\"\n    for i in range(len(spans)):\n        if [row, column] in spans[i]:\n            return spans[i]\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_unassigned_table_cell(table):\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            if table[row][column] is None:\n                return row, column\n    return row, column", "response": "Search through a table and return the first row column pair of the None type cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, dte, values):\n        '''insert *values* at date *dte*.'''\n        if len(values):\n            dte = self.dateconvert(dte)\n            if not self:\n                self._date = np.array([dte])\n                self._data = np.array([values])\n            else:\n                # search for the date\n                index = self._skl.rank(dte)\n                if index < 0:\n                    # date not available\n                    N = len(self._data)\n                    index = -1-index\n                    self._date.resize((N+1,))\n                    self._data.resize((N+1, self.count()))\n                    if index < N:\n                        self._date[index+1:] = self._date[index:-1]\n                        self._data[index+1:] = self._data[index:-1]\n                self._date[index] = dte\n                self._data[index] = values\n            self._skl.insert(dte)", "response": "insert values at date dte."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts node names into node instances...", "response": "def _translate_nodes(root, *nodes):\n    \"\"\"\n    Convert node names into node instances...\n    \"\"\"\n    #name2node = {[n, None] for n in nodes if type(n) is str}\n    name2node = dict([[n, None] for n in nodes if type(n) is str])\n    for n in root.traverse():\n        if n.name in name2node:\n            if name2node[n.name] is not None:\n                raise TreeError(\"Ambiguous node name: {}\".format(str(n.name)))\n            else:\n                name2node[n.name] = n\n\n    if None in list(name2node.values()):\n        notfound = [key for key, value in six.iteritems(name2node) if value is None]\n        raise ValueError(\"Node names not found: \"+str(notfound))\n\n    valid_nodes = []\n    for n in nodes:\n        if type(n) is not str:\n            if type(n) is not root.__class__:\n                raise TreeError(\"Invalid target node: \"+str(n))\n            else:\n                valid_nodes.append(n)\n\n    valid_nodes.extend(list(name2node.values()))\n    if len(valid_nodes) == 1:\n        return valid_nodes[0]\n    else:\n        return valid_nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_feature(self, pr_name, pr_value):\n        setattr(self, pr_name, pr_value)\n        self.features.add(pr_name)", "response": "Add or update a feature."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds or update several features.", "response": "def add_features(self, **features):\n        \"\"\" Add or update several features. \"\"\"\n        for fname, fvalue in six.iteritems(features):\n            setattr(self, fname, fvalue)\n            self.features.add(fname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef del_feature(self, pr_name):\n        if hasattr(self, pr_name):\n            delattr(self, pr_name)\n            self.features.remove(pr_name)", "response": "Permanently deletes a node s feature."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_child(self, child=None, name=None, dist=None, support=None):\n\n        if child is None:\n            child = self.__class__()\n        if name is not None:\n            child.name = name\n        if dist is not None:\n            child.dist = dist\n        if support is not None:\n            child.support = support\n\n        self.children.append(child)\n        child.up = self\n        return child", "response": "Adds a new child node to this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError as e:\n            raise TreeError(\"child not found\")\n        else:\n            child.up = None\n            return child", "response": "Removes a child from this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_sister(self, sister=None, name=None, dist=None):\n        if self.up == None:\n            raise TreeError(\"A parent node is required to add a sister\")\n        else:\n            return self.up.add_child(child=sister, name=name, dist=dist)", "response": "Adds a sister node to this node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a sister node.", "response": "def remove_sister(self, sister=None):\n        \"\"\"\n        Removes a sister node. It has the same effect as\n        **`TreeNode.up.remove_child(sister)`**\n\n        If a sister node is not supplied, the first sister will be deleted\n        and returned.\n\n        :argument sister: A node instance\n\n        :return: The node removed\n        \"\"\"\n        sisters = self.get_sisters()\n        if len(sisters) > 0:\n            if sister is None:\n                sister = sisters.pop(0)\n            return self.up.remove_child(sister)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, prevent_nondicotomic=True, preserve_branch_length=False):\n        parent = self.up\n        if parent:\n            if preserve_branch_length:\n                if len(self.children) == 1:\n                    self.children[0].dist += self.dist\n                elif len(self.children) > 1:\n                    parent.dist += self.dist\n\n            for ch in self.children:\n                parent.add_child(ch)\n\n            parent.remove_child(self)\n\n        # Avoids parents with only one child\n        if prevent_nondicotomic and parent and\\\n              len(parent.children) < 2:\n            parent.delete(prevent_nondicotomic=False,\n                          preserve_branch_length=preserve_branch_length)", "response": "Deletes the node from the tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detach(self):\n        if self.up:\n            self.up.children.remove(self)\n            self.up = None\n        return self", "response": "Detachs this node from its parent\n            and returns the referent to itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prune(self, nodes, preserve_branch_length=False):\n\n        def cmp_nodes(x, y):\n            # if several nodes are in the same path of two kept nodes,\n            # only one should be maintained. This prioritize internal\n            # nodes that are already in the to_keep list and then\n            # deeper nodes (closer to the leaves).\n            if n2depth[x] > n2depth[y]:\n                return -1\n            elif n2depth[x] < n2depth[y]:\n                return 1\n            else:\n                return 0\n\n        to_keep = set(_translate_nodes(self, *nodes))\n        start, node2path = self.get_common_ancestor(to_keep, get_path=True)\n        to_keep.add(self)\n\n        # Calculate which kept nodes are visiting the same nodes in\n        # their path to the common ancestor.\n        n2count = {}\n        n2depth = {}\n        for seed, path in six.iteritems(node2path):\n            for visited_node in path:\n                if visited_node not in n2depth:\n                    depth = visited_node.get_distance(start, topology_only=True)\n                    n2depth[visited_node] = depth\n                if visited_node is not seed:\n                    n2count.setdefault(visited_node, set()).add(seed)\n\n        # if several internal nodes are in the path of exactly the same kept\n        # nodes, only one (the deepest) should be maintain.\n        visitors2nodes = {}\n        for node, visitors in six.iteritems(n2count):\n            # keep nodes connection at least two other nodes\n            if len(visitors)>1:\n                visitor_key = frozenset(visitors)\n                visitors2nodes.setdefault(visitor_key, set()).add(node)\n\n        for visitors, nodes in six.iteritems(visitors2nodes):\n            if not (to_keep & nodes):\n                sorted_nodes = sorted(nodes, key=cmp_to_key(cmp_nodes))\n                to_keep.add(sorted_nodes[0])\n\n        for n in self.get_descendants('postorder'):\n            if n not in to_keep:\n                if preserve_branch_length:\n                    if len(n.children) == 1:\n                        n.children[0].dist += n.dist\n                    elif len(n.children) > 1 and n.up:\n                        n.up.dist += n.dist\n\n                n.delete(prevent_nondicotomic=False)", "response": "Prune the topology of a node to conserve only a selected list of leaf node names or node objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an indepent list of sister nodes.", "response": "def get_sisters(self):\n        \"\"\" Returns an indepent list of sister nodes.\"\"\"\n        if self.up != None:\n            return [ch for ch in self.up.children if ch != self]\n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_leaves(self, is_leaf_fn=None):\n        for n in self.traverse(strategy=\"preorder\", is_leaf_fn=is_leaf_fn):\n            if not is_leaf_fn:\n                if n.is_leaf():\n                    yield n\n            else:\n                if is_leaf_fn(n):\n                    yield n", "response": "Returns an iterator over the leaves under this node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an iterator over the leaf names under this node.", "response": "def iter_leaf_names(self, is_leaf_fn=None):\n        \"\"\"Returns an iterator over the leaf names under this node.\"\"\"\n        for n in self.iter_leaves(is_leaf_fn=is_leaf_fn):\n            yield n.name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator over all descendant nodes.", "response": "def iter_descendants(self, strategy=\"levelorder\", is_leaf_fn=None):\n        \"\"\" Returns an iterator over all descendant nodes.\"\"\"\n        for n in self.traverse(strategy=strategy, is_leaf_fn=is_leaf_fn):\n            if n is not self:\n                yield n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all leaves and internal node names in the hierarchy.", "response": "def get_descendants(self, strategy=\"levelorder\", is_leaf_fn=None):\n        \"\"\" Returns a list of all (leaves and internal) descendant nodes.\"\"\"\n        return [n for n in self.iter_descendants(\n            strategy=strategy, is_leaf_fn=is_leaf_fn)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an iterator to traverse the tree under this node.", "response": "def traverse(self, strategy=\"levelorder\", is_leaf_fn=None):\n        \"\"\" Returns an iterator to traverse tree under this node.\n        \n        Parameters:\n        -----------\n        strategy: \n            set the way in which tree will be traversed. Possible \n            values are: \"preorder\" (first parent and then children)\n            'postorder' (first children and the parent) and \n            \"levelorder\" (nodes are visited in order from root to leaves)\n\n        is_leaf_fn: \n            If supplied, ``is_leaf_fn`` function will be used to \n            interrogate nodes about if they are terminal or internal. \n            ``is_leaf_fn`` function should receive a node instance as first\n            argument and return True or False. Use this argument to \n            traverse a tree by dynamically collapsing internal nodes matching\n            ``is_leaf_fn``.\n        \"\"\"\n        if strategy == \"preorder\":\n            return self._iter_descendants_preorder(is_leaf_fn=is_leaf_fn)\n        elif strategy == \"levelorder\":\n            return self._iter_descendants_levelorder(is_leaf_fn=is_leaf_fn)\n        elif strategy == \"postorder\":\n            return self._iter_descendants_postorder(is_leaf_fn=is_leaf_fn)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iter_prepostorder(self, is_leaf_fn=None):\n        to_visit = [self]\n        if is_leaf_fn is not None:\n            _leaf = is_leaf_fn\n        else:\n            _leaf = self.__class__.is_leaf\n\n        while to_visit:\n            node = to_visit.pop(-1)\n            try:\n                node = node[1]\n            except TypeError:\n                # PREORDER ACTIONS\n                yield (False, node)\n                if not _leaf(node):\n                    # ADD CHILDREN\n                    to_visit.extend(reversed(node.children + [[1, node]]))\n            else:\n                #POSTORDER ACTIONS\n                yield (True, node)", "response": "Iterate over all nodes in both\n        pre and postorder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _iter_descendants_levelorder(self, is_leaf_fn=None):\n        tovisit = deque([self])\n        while len(tovisit) > 0:\n            node = tovisit.popleft()\n            yield node\n            if not is_leaf_fn or not is_leaf_fn(node):\n                tovisit.extend(node.children)", "response": "Iterate over all nodes in the tree in level - order."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over all descendant nodes in the tree.", "response": "def _iter_descendants_preorder(self, is_leaf_fn=None):\n        \"\"\" Iterator over all descendant nodes. \"\"\"\n        to_visit = deque()\n        node = self\n        while node is not None:\n            yield node\n            if not is_leaf_fn or not is_leaf_fn(node):\n                to_visit.extendleft(reversed(node.children))\n            try:\n                node = to_visit.popleft()\n            except:\n                node = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over the list of all ancestor nodes from the current node to the current tree root.", "response": "def iter_ancestors(self):\n        \"\"\" \n        Iterates over the list of all ancestor nodes from \n        current node to the current tree root.\n        \"\"\"\n        node = self\n        while node.up is not None:\n            yield node.up\n            node = node.up"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, \n        features=None, \n        outfile=None, \n        format=0, \n        is_leaf_fn=None,\n        format_root_node=False, \n        dist_formatter=None, \n        support_formatter=None,\n        name_formatter=None):\n\n        \"\"\"\n        Returns the newick representation of current node. Several\n        arguments control the way in which extra data is shown for\n        every node:\n\n        Parameters:\n        -----------\n        features: \n            a list of feature names to be exported using the Extended Newick \n            Format (i.e. features=[\"name\", \"dist\"]). Use an empty list to \n            export all available features in each node (features=[])\n\n        outfile:\n            writes the output to a given file\n\n        format: \n            defines the newick standard used to encode the tree. \n\n        format_root_node: \n            If True, it allows features and branch information from root node\n            to be exported as a part of the newick text string. For newick \n            compatibility reasons, this is False by default.\n\n        is_leaf_fn: \n            See :func:`TreeNode.traverse` for documentation.\n\n        **Example:**\n             t.get_newick(features=[\"species\",\"name\"], format=1)\n        \"\"\"\n        nw = write_newick(self, features=features,\n                          format=format,\n                          is_leaf_fn=is_leaf_fn,\n                          format_root_node=format_root_node,\n                          dist_formatter=dist_formatter,\n                          support_formatter=support_formatter,\n                          name_formatter=name_formatter)\n\n        if outfile is not None:\n            with open(outfile, \"w\") as OUT:\n                OUT.write(nw)\n        else:\n            return nw", "response": "Writes the current node to a newick file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the absolute root node of current tree structure.", "response": "def get_tree_root(self):\n        \"\"\" Returns the absolute root node of current tree structure.\"\"\"\n        root = self\n        while root.up is not None:\n            root = root.up\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_common_ancestor(self, *target_nodes, **kargs):\n        get_path = kargs.get(\"get_path\", False)\n\n        if len(target_nodes) == 1 and type(target_nodes[0]) \\\n                in set([set, tuple, list, frozenset]):\n            target_nodes = target_nodes[0]\n\n        # Convert node names into node instances\n        target_nodes = _translate_nodes(self, *target_nodes)\n\n        # If only one node is provided, use self as the second target\n        if type(target_nodes) != list:\n            target_nodes = [target_nodes, self]\n\n        n2path = {}\n        reference = []\n        ref_node = None\n        for n in target_nodes:\n            current = n\n            while current:\n                n2path.setdefault(n, set()).add(current)\n                if not ref_node:\n                    reference.append(current)\n                current = current.up\n            if not ref_node:\n                ref_node = n\n\n        common = None\n        for n in reference:\n            broken = False\n            for node, path in six.iteritems(n2path):\n                if node is not ref_node and n not in path:\n                    broken = True\n                    break\n\n            if not broken:\n                common = n\n                break\n        if not common:\n            raise TreeError(\"Nodes are not connected!\")\n\n        if get_path:\n            return common, n2path\n        else:\n            return common", "response": "Returns the first common ancestor between this node and a given list of target_nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_search_nodes(self, **conditions):\n        for n in self.traverse():\n            conditions_passed = 0\n            for key, value in six.iteritems(conditions):\n                if hasattr(n, key) and getattr(n, key) == value:\n                    conditions_passed +=1\n            if conditions_passed == len(conditions):\n                yield n", "response": "Iterate over nodes in an interative way."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the list of nodes matching a given set of conditions.", "response": "def search_nodes(self, **conditions):\n        \"\"\"\n        Returns the list of nodes matching a given set of conditions.\n        **Example:**\n        tree.search_nodes(dist=0.0, name=\"human\")\n        \"\"\"\n        matching_nodes = []\n        for n in self.iter_search_nodes(**conditions):\n            matching_nodes.append(n)\n        return matching_nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_distance(self, target, target2=None, topology_only=False):\n        if target2 is None:\n            target2 = self\n            root = self.get_tree_root()\n        else:\n            # is target node under current node?\n            root = self\n\n        target, target2 = _translate_nodes(root, target, target2)\n        ancestor = root.get_common_ancestor(target, target2)\n\n        dist = 0.0\n        for n in [target2, target]:\n            current = n\n            while current != ancestor:\n                if topology_only:\n                    if  current!=target:\n                        dist += 1\n                else:\n                    dist += current.dist\n                current = current.up\n        return dist", "response": "Returns the distance between two nodes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the node s farthest descendant or ancestor node and the distance to it.", "response": "def get_farthest_node(self, topology_only=False):\n        \"\"\"\n        Returns the node's farthest descendant or ancestor node, and the\n        distance to it.\n\n        :argument False topology_only: If set to True, distance\n          between nodes will be referred to the number of nodes\n          between them. In other words, topological distance will be\n          used instead of branch length distances.\n\n        :return: A tuple containing the farthest node referred to the\n          current node and the distance to it.\n\n        \"\"\"\n        # Init fasthest node to current farthest leaf\n        farthest_node, farthest_dist = self.get_farthest_leaf(\n            topology_only=topology_only)\n\n        prev = self\n        cdist = 0.0 if topology_only else prev.dist\n        current = prev.up\n        while current is not None:\n            for ch in current.children:\n                if ch != prev:\n                    if not ch.is_leaf():\n                        fnode, fdist = ch.get_farthest_leaf(\n                            topology_only=topology_only)\n                    else:\n                        fnode = ch\n                        fdist = 0\n                    if topology_only:\n                        fdist += 1.0\n                    else:\n                        fdist += ch.dist\n                    if cdist+fdist > farthest_dist:\n                        farthest_dist = cdist + fdist\n                        farthest_node = fnode\n            prev = current\n            if topology_only:\n                cdist += 1\n            else:\n                cdist  += prev.dist\n            current = prev.up\n        return farthest_node, farthest_dist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the node s farthest descendant node and the distance to it.", "response": "def get_farthest_leaf(self, topology_only=False, is_leaf_fn=None):\n        \"\"\"\n        Returns node's farthest descendant node (which is always a leaf), and the\n        distance to it.\n\n        :argument False topology_only: If set to True, distance\n          between nodes will be referred to the number of nodes\n          between them. In other words, topological distance will be\n          used instead of branch length distances.\n\n        :return: A tuple containing the farthest leaf referred to the\n          current node and the distance to it.\n        \"\"\"\n        min_node, min_dist, max_node, max_dist = self._get_farthest_and_closest_leaves(\n        topology_only=topology_only, is_leaf_fn=is_leaf_fn)\n        return max_node, max_dist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the node that divides the current tree into two distance - balanced partitions.", "response": "def get_midpoint_outgroup(self):\n        \"\"\"\n        Returns the node that divides the current tree into two \n        distance-balanced partitions.\n        \"\"\"\n        # Gets the farthest node to the current root\n        root = self.get_tree_root()\n        nA, r2A_dist = root.get_farthest_leaf()\n        nB, A2B_dist = nA.get_farthest_node()\n\n        outgroup = nA\n        middist = A2B_dist / 2.0\n        cdist = 0\n        current = nA\n        while current is not None:\n            cdist += current.dist\n            if cdist > (middist): # Deja de subir cuando se pasa del maximo\n                break\n            else:\n                current = current.up\n        return current"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef populate(self, \n        size, \n        names_library=None, \n        reuse_names=False,\n        random_branches=False, \n        branch_range=(0, 1),\n        support_range=(0, 1)):\n        \"\"\"\n        Generates a random topology by populating current node.\n\n        :argument None names_library: If provided, names library\n          (list, set, dict, etc.) will be used to name nodes.\n\n        :argument False reuse_names: If True, node names will not be\n          necessarily unique, which makes the process a bit more\n          efficient.\n\n        :argument False random_branches: If True, branch distances and support\n          values will be randomized.\n\n        :argument (0,1) branch_range: If random_branches is True, this\n        range of values will be used to generate random distances.\n\n        :argument (0,1) support_range: If random_branches is True,\n        this range of values will be used to generate random branch\n        support values.\n\n        \"\"\"\n        NewNode = self.__class__\n\n        if len(self.children) > 1:\n            connector = NewNode()\n            for ch in self.get_children():\n                ch.detach()\n                connector.add_child(child = ch)\n            root = NewNode()\n            self.add_child(child = connector)\n            self.add_child(child = root)\n        else:\n            root = self\n\n        next_deq = deque([root])\n        for i in range(size-1):\n            if random.randint(0, 1):\n                p = next_deq.pop()\n            else:\n                p = next_deq.popleft()\n\n            c1 = p.add_child()\n            c2 = p.add_child()\n            next_deq.extend([c1, c2])\n            if random_branches:\n                c1.dist = random.uniform(*branch_range)\n                c2.dist = random.uniform(*branch_range)\n                c1.support = random.uniform(*branch_range)\n                c2.support = random.uniform(*branch_range)\n            else:\n                c1.dist = 1.0\n                c2.dist = 1.0\n                c1.support = 1.0\n                c2.support = 1.0\n\n        # next contains leaf nodes\n        charset = \"abcdefghijklmnopqrstuvwxyz\"\n        if names_library:\n            names_library = deque(names_library)\n        else:\n            avail_names = itertools.combinations_with_replacement(charset, 10)\n        for n in next_deq:\n            if names_library:\n                if reuse_names:\n                    tname = random.sample(names_library, 1)[0]\n                else:\n                    tname = names_library.pop()\n            else:\n                tname = ''.join(next(avail_names))\n            n.name = tname", "response": "Populates the current node with random nodes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the outgroup of this node.", "response": "def set_outgroup(self, outgroup):\n        \"\"\"\n        Sets a descendant node as the outgroup of a tree.  This function\n        can be used to root a tree or even an internal node.\n\n        Parameters:\n        -----------\n        outgroup: \n            a node instance within the same tree structure that will be \n            used as a basal node.\n        \"\"\"\n        outgroup = _translate_nodes(self, outgroup)\n\n        if self == outgroup:\n            ##return\n            ## why raise an error for this?\n            raise TreeError(\"Cannot set myself as outgroup\")\n\n        parent_outgroup = outgroup.up\n\n        # Detects (sub)tree root\n        n = outgroup\n        while n.up is not self:\n            n = n.up\n\n        # If outgroup is a child from root, but with more than one\n        # sister nodes, creates a new node to group them\n\n        self.children.remove(n)\n        if len(self.children) != 1:\n            down_branch_connector = self.__class__()\n            down_branch_connector.dist = 0.0\n            down_branch_connector.support = n.support\n            for ch in self.get_children():\n                down_branch_connector.children.append(ch)\n                ch.up = down_branch_connector\n                self.children.remove(ch)\n        else:\n            down_branch_connector = self.children[0]\n\n        # Connects down branch to myself or to outgroup\n        quien_va_ser_padre = parent_outgroup\n        if quien_va_ser_padre is not self:\n            # Parent-child swapping\n            quien_va_ser_hijo = quien_va_ser_padre.up\n            quien_fue_padre = None\n            buffered_dist = quien_va_ser_padre.dist\n            buffered_support = quien_va_ser_padre.support\n\n            while quien_va_ser_hijo is not self:\n                quien_va_ser_padre.children.append(quien_va_ser_hijo)\n                quien_va_ser_hijo.children.remove(quien_va_ser_padre)\n\n                buffered_dist2 = quien_va_ser_hijo.dist\n                buffered_support2 = quien_va_ser_hijo.support\n                quien_va_ser_hijo.dist = buffered_dist\n                quien_va_ser_hijo.support = buffered_support\n                buffered_dist = buffered_dist2\n                buffered_support = buffered_support2\n\n                quien_va_ser_padre.up = quien_fue_padre\n                quien_fue_padre = quien_va_ser_padre\n\n                quien_va_ser_padre = quien_va_ser_hijo\n                quien_va_ser_hijo = quien_va_ser_padre.up\n\n            quien_va_ser_padre.children.append(down_branch_connector)\n            down_branch_connector.up = quien_va_ser_padre\n            quien_va_ser_padre.up = quien_fue_padre\n\n            down_branch_connector.dist += buffered_dist\n            outgroup2 = parent_outgroup\n            parent_outgroup.children.remove(outgroup)\n            outgroup2.dist = 0\n\n        else:\n            outgroup2 = down_branch_connector\n\n        outgroup.up = self\n        outgroup2.up = self\n        # outgroup is always the first children. Some function my\n        # trust on this fact, so do no change this.\n        self.children = [outgroup,outgroup2]\n        middist = (outgroup2.dist + outgroup.dist)/2\n        outgroup.dist = middist\n        outgroup2.dist = middist\n        outgroup2.support = outgroup.support"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unroot(self):\n        if len(self.children)==2:\n            if not self.children[0].is_leaf():\n                self.children[0].delete()\n            elif not self.children[1].is_leaf():\n                self.children[1].delete()\n            else:\n                raise TreeError(\"Cannot unroot a tree with only two leaves\")", "response": "Unroots the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the ASCII representation of the tree.", "response": "def _asciiArt(self, char1='-', show_internal=True, compact=False, attributes=None):\n        \"\"\"\n        Returns the ASCII representation of the tree.\n        Code based on the PyCogent GPL project.\n        \"\"\"\n        if not attributes:\n            attributes = [\"name\"]\n        \n        # toytree edit:\n        # removed six dependency for map with comprehension\n        # node_name = ', '.join(map(str, [getattr(self, v) for v in attributes if hasattr(self, v)]))\n        _attrlist = [getattr(self, v) for v in attributes if hasattr(self, v)]\n        node_name = \", \".join([str(i) for i in _attrlist])\n\n        LEN = max(3, len(node_name) if not self.children or show_internal else 3)\n        PAD = ' ' * LEN\n        PA = ' ' * (LEN-1)\n        if not self.is_leaf():\n            mids = []\n            result = []\n            for c in self.children:\n                if len(self.children) == 1:\n                    char2 = '/'\n                elif c is self.children[0]:\n                    char2 = '/'\n                elif c is self.children[-1]:\n                    char2 = '\\\\'\n                else:\n                    char2 = '-'\n                (clines, mid) = c._asciiArt(char2, show_internal, compact, attributes)\n                mids.append(mid+len(result))\n                result.extend(clines)\n                if not compact:\n                    result.append('')\n            if not compact:\n                result.pop()\n            (lo, hi, end) = (mids[0], mids[-1], len(result))\n            prefixes = [PAD] * (lo+1) + [PA+'|'] * (hi-lo-1) + [PAD] * (end-hi)\n            mid = int((lo + hi) / 2)\n            prefixes[mid] = char1 + '-'*(LEN-2) + prefixes[mid][-1]\n            result = [p+l for (p,l) in zip(prefixes, result)]\n            if show_internal:\n                stem = result[mid]\n                result[mid] = stem[0] + node_name + stem[len(node_name)+1:]\n            return (result, mid)\n        else:\n            return ([char1 + '-' + node_name], 0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an ASCII representation of the tree.", "response": "def get_ascii(self, show_internal=True, compact=False, attributes=None):\n        \"\"\"\n        Returns a string containing an ascii drawing of the tree.\n        \n        Parameters:\n        -----------\n        show_internal: \n            include internal edge names.\n        compact: \n            use exactly one line per tip.\n        attributes: \n            A list of node attributes to shown in the ASCII representation.\n        \"\"\"\n        (lines, mid) = self._asciiArt(show_internal=show_internal,\n                                      compact=compact, \n                                      attributes=attributes)\n        return '\\n'+'\\n'.join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts the branches of a given tree according to the size of each partition.", "response": "def ladderize(self, direction=0):\n        \"\"\"\n        Sort the branches of a given tree (swapping children nodes)\n        according to the size of each partition.\n        \"\"\"\n        if not self.is_leaf():\n            n2s = {}\n            for n in self.get_children():\n                s = n.ladderize(direction=direction)\n                n2s[n] = s\n\n            self.children.sort(key=lambda x: n2s[x])\n            if direction == 1:\n                self.children.reverse()\n            size = sum(n2s.values())\n        else:\n            size = 1\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sort_descendants(self, attr=\"name\"):\n        node2content = self.get_cached_content(store_attr=attr, container_type=list)\n        for n in self.traverse():\n            if not n.is_leaf():\n                n.children.sort(key=lambda x: str(sorted(node2content[x])))", "response": "This function sorts the nodes in a given tree by node names considering node names."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_cached_content(self, store_attr=None, container_type=set, _store=None):\n        if _store is None:\n            _store = {}\n\n        for ch in self.children:\n            ch.get_cached_content(store_attr=store_attr,\n                                  container_type=container_type,\n                                  _store=_store)\n        if self.children:\n            val = container_type()\n            for ch in self.children:\n                if type(val) == list:\n                    val.extend(_store[ch])\n                if type(val) == set:\n                    val.update(_store[ch])\n            _store[self] = val\n        else:\n            if store_attr is None:\n                val = self\n            else:\n                val = getattr(self, store_attr)\n            _store[self] = container_type([val])\n        return _store", "response": "Returns a dictionary pointing to the preloaded content of each internal node under this tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the robinson - foulds symmetric distance between two trees.", "response": "def robinson_foulds(self, \n        t2, \n        attr_t1=\"name\", \n        attr_t2=\"name\",\n        unrooted_trees=False, \n        expand_polytomies=False,\n        polytomy_size_limit=5, \n        skip_large_polytomies=False,\n        correct_by_polytomy_size=False, \n        min_support_t1=0.0,\n        min_support_t2=0.0):\n        \"\"\"\n        Returns the Robinson-Foulds symmetric distance between current\n        tree and a different tree instance.\n\n        Parameters:\n        -----------\n        t2: \n            reference tree\n        attr_t1: \n            Compare trees using a custom node attribute as a node name.\n        attr_t2: \n            Compare trees using a custom node attribute as a node name in target tree.\n        attr_t2: \n            If True, consider trees as unrooted.\n        False expand_polytomies: \n            If True, all polytomies in the reference and target tree will be \n            expanded into all possible binary trees. Robinson-foulds distance \n            will be calculated between all tree combinations and the minimum \n            value will be returned.\n            See also, :func:`NodeTree.expand_polytomy`.\n\n        Returns:\n        --------\n        (rf, rf_max, common_attrs, names, edges_t1, edges_t2, \n         discarded_edges_t1, discarded_edges_t2)\n        \"\"\"\n        ref_t = self\n        target_t = t2\n        if not unrooted_trees and (len(ref_t.children) > 2 or len(target_t.children) > 2):\n            raise TreeError(\"Unrooted tree found! You may want to activate the unrooted_trees flag.\")\n\n        if expand_polytomies and correct_by_polytomy_size:\n            raise TreeError(\"expand_polytomies and correct_by_polytomy_size are mutually exclusive.\")\n\n        if expand_polytomies and unrooted_trees:\n            raise TreeError(\"expand_polytomies and unrooted_trees arguments cannot be enabled at the same time\")\n\n        attrs_t1 = set([getattr(n, attr_t1) for n in ref_t.iter_leaves() if hasattr(n, attr_t1)])\n        attrs_t2 = set([getattr(n, attr_t2) for n in target_t.iter_leaves() if hasattr(n, attr_t2)])\n        common_attrs = attrs_t1 & attrs_t2\n        # release mem\n        attrs_t1, attrs_t2 = None, None\n\n        # Check for duplicated items (is it necessary? can we optimize? what's the impact in performance?')\n        size1 = len([True for n in ref_t.iter_leaves() if getattr(n, attr_t1, None) in common_attrs])\n        size2 = len([True for n in target_t.iter_leaves() if getattr(n, attr_t2, None) in common_attrs])\n        if size1 > len(common_attrs):\n            raise TreeError('Duplicated items found in source tree')\n        if size2 > len(common_attrs):\n            raise TreeError('Duplicated items found in reference tree')\n\n        if expand_polytomies:\n            ref_trees = [\n                TreeNode(nw) for nw in\n                ref_t.expand_polytomies(\n                    map_attr=attr_t1,\n                    polytomy_size_limit=polytomy_size_limit,\n                    skip_large_polytomies=skip_large_polytomies\n                    )\n                ]\n            target_trees = [\n                TreeNode(nw) for nw in\n                target_t.expand_polytomies(\n                    map_attr=attr_t2,\n                    polytomy_size_limit=polytomy_size_limit,\n                    skip_large_polytomies=skip_large_polytomies,\n                    )\n                ]\n            attr_t1, attr_t2 = \"name\", \"name\"\n        else:\n            ref_trees = [ref_t]\n            target_trees = [target_t]\n\n        polytomy_correction = 0\n        if correct_by_polytomy_size:\n            corr1 = sum([0]+[len(n.children) - 2 for n in ref_t.traverse() if len(n.children) > 2])\n            corr2 = sum([0]+[len(n.children) - 2 for n in target_t.traverse() if len(n.children) > 2])\n            if corr1 and corr2:\n                raise TreeError(\"Both trees contain polytomies! Try expand_polytomies=True instead\")\n            else:\n                polytomy_correction = max([corr1, corr2])\n\n        min_comparison = None\n        for t1 in ref_trees:\n            t1_content = t1.get_cached_content()\n            t1_leaves = t1_content[t1]\n            if unrooted_trees:\n                edges1 = set([\n                        tuple(sorted([tuple(sorted([getattr(n, attr_t1) for n in content if hasattr(n, attr_t1) and getattr(n, attr_t1) in common_attrs])),\n                                      tuple(sorted([getattr(n, attr_t1) for n in t1_leaves-content if hasattr(n, attr_t1) and getattr(n, attr_t1) in common_attrs]))]))\n                        for content in six.itervalues(t1_content)])\n                edges1.discard(((),()))\n            else:\n                edges1 = set([\n                        tuple(sorted([getattr(n, attr_t1) for n in content if hasattr(n, attr_t1) and getattr(n, attr_t1) in common_attrs]))\n                        for content in six.itervalues(t1_content)])\n                edges1.discard(())\n\n            if min_support_t1:\n                support_t1 = dict([\n                        (tuple(sorted([getattr(n, attr_t1) for n in content if hasattr(n, attr_t1) and getattr(n, attr_t1) in common_attrs])), branch.support)\n                        for branch, content in six.iteritems(t1_content)])\n\n            for t2 in target_trees:\n                t2_content = t2.get_cached_content()\n                t2_leaves = t2_content[t2]\n                if unrooted_trees:\n                    edges2 = set([\n                            tuple(sorted([\n                                        tuple(sorted([getattr(n, attr_t2) for n in content if hasattr(n, attr_t2) and getattr(n, attr_t2) in common_attrs])),\n                                        tuple(sorted([getattr(n, attr_t2) for n in t2_leaves-content if hasattr(n, attr_t2) and getattr(n, attr_t2) in common_attrs]))]))\n                            for content in six.itervalues(t2_content)])\n                    edges2.discard(((),()))\n                else:\n                    edges2 = set([\n                            tuple(sorted([getattr(n, attr_t2) for n in content if hasattr(n, attr_t2) and getattr(n, attr_t2) in common_attrs]))\n                            for content in six.itervalues(t2_content)])\n                    edges2.discard(())\n\n                if min_support_t2:\n                    support_t2 = dict([\n                        (tuple(sorted(([getattr(n, attr_t2) for n in content if hasattr(n, attr_t2) and getattr(n, attr_t2) in common_attrs]))), branch.support)\n                        for branch, content in six.iteritems(t2_content)])\n\n\n                # if a support value is passed as a constraint, discard lowly supported branches from the analysis\n                discard_t1, discard_t2 = set(), set()\n                if min_support_t1 and unrooted_trees:\n                    discard_t1 = set([p for p in edges1 if support_t1.get(p[0], support_t1.get(p[1], 999999999)) < min_support_t1])\n                elif min_support_t1:\n                    discard_t1 = set([p for p in edges1 if support_t1[p] < min_support_t1])\n\n                if min_support_t2 and unrooted_trees:\n                    discard_t2 = set([p for p in edges2 if support_t2.get(p[0], support_t2.get(p[1], 999999999)) < min_support_t2])\n                elif min_support_t2:\n                    discard_t2 = set([p for p in edges2 if support_t2[p] < min_support_t2])\n\n\n                #rf = len(edges1 ^ edges2) - (len(discard_t1) + len(discard_t2)) - polytomy_correction # poly_corr is 0 if the flag is not enabled\n                #rf = len((edges1-discard_t1) ^ (edges2-discard_t2)) - polytomy_correction\n\n                # the two root edges are never counted here, as they are always\n                # present in both trees because of the common attr filters\n                rf = len(((edges1 ^ edges2) - discard_t2) - discard_t1) - polytomy_correction\n\n                if unrooted_trees:\n                    # thought this may work, but it does not, still I don't see why\n                    #max_parts = (len(common_attrs)*2) - 6 - len(discard_t1) - len(discard_t2)\n                    max_parts = (len([p for p in edges1 - discard_t1 if len(p[0])>1 and len(p[1])>1]) +\n                                 len([p for p in edges2 - discard_t2 if len(p[0])>1 and len(p[1])>1]))\n                else:\n                    # thought this may work, but it does not, still I don't see why\n                    #max_parts = (len(common_attrs)*2) - 4 - len(discard_t1) - len(discard_t2)\n\n                    # Otherwise we need to count the actual number of valid\n                    # partitions in each tree -2 is to avoid counting the root\n                    # partition of the two trees (only needed in rooted trees)\n                    max_parts = (len([p for p in edges1 - discard_t1 if len(p)>1]) +\n                                 len([p for p in edges2 - discard_t2 if len(p)>1])) - 2\n\n                    # print max_parts\n\n                if not min_comparison or min_comparison[0] > rf:\n                    min_comparison = [rf, max_parts, common_attrs, edges1, edges2, discard_t1, discard_t2]\n\n        return min_comparison"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_edges(self, cached_content=None):\n        if not cached_content:\n            cached_content = self.get_cached_content()\n        all_leaves = cached_content[self]\n        for n, side1 in six.iteritems(cached_content):\n            yield (side1, all_leaves - side1)", "response": "Iterate over the edges of a tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the unique ID representing the topology of the current tree.", "response": "def get_topology_id(self, attr=\"name\"):\n        \"\"\"\n        Returns the unique ID representing the topology of the current tree. \n        Two trees with the same topology will produce the same id. If trees are\n        unrooted, make sure that the root node is not binary or use the\n        tree.unroot() function before generating the topology id.\n\n        This is useful to detect the number of unique topologies over a bunch \n        of trees, without requiring full distance methods.\n\n        The id is, by default, calculated based on the terminal node's names. \n        Any other node attribute could be used instead.\n        \"\"\"\n        edge_keys = []\n        for s1, s2 in self.get_edges():\n            k1 = sorted([getattr(e, attr) for e in s1])\n            k2 = sorted([getattr(e, attr) for e in s2])\n            edge_keys.append(sorted([k1, k2]))\n        return md5(str(sorted(edge_keys)).encode('utf-8')).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_monophyly(self, \n        values, \n        target_attr, \n        ignore_missing=False,\n        unrooted=False):\n        \"\"\"\n        Returns True if a given target attribute is monophyletic under\n        this node for the provided set of values.\n\n        If not all values are represented in the current tree\n        structure, a ValueError exception will be raised to warn that\n        strict monophyly could never be reached (this behaviour can be\n        avoided by enabling the `ignore_missing` flag.\n        \n        Parameters:\n        -----------\n        values: \n            a set of values for which monophyly is expected.\n        \n        target_attr: \n            node attribute being used to check monophyly (i.e. species for \n            species trees, names for gene family trees, or any custom feature\n            present in the tree).\n\n        ignore_missing: \n            Avoid raising an Exception when missing attributes are found.\n\n        unrooted: \n            If True, tree will be treated as unrooted, thus allowing to find\n            monophyly even when current outgroup is spliting a monophyletic group.\n\n        Returns: \n        --------\n        the following tuple\n        IsMonophyletic (boolean),\n        clade type ('monophyletic', 'paraphyletic' or 'polyphyletic'),\n        leaves breaking the monophyly (set)\n        \"\"\"\n        if type(values) != set:\n\n            values = set(values)\n\n        # This is the only time I traverse the tree, then I use cached\n        # leaf content\n        n2leaves = self.get_cached_content()\n\n        # Raise an error if requested attribute values are not even present\n        if ignore_missing:\n            found_values = set([getattr(n, target_attr) for n in n2leaves[self]])\n            missing_values = values - found_values\n            values = values & found_values\n\n        # Locate leaves matching requested attribute values\n        targets = set([leaf for leaf in n2leaves[self]\n                   if getattr(leaf, target_attr) in values])\n        if not ignore_missing:\n            if values - set([getattr(leaf, target_attr) for leaf in targets]):\n                raise ValueError('The monophyly of the provided values could never be reached, as not all of them exist in the tree.'\n                                 ' Please check your target attribute and values, or set the ignore_missing flag to True')\n\n        if unrooted:\n            smallest = None\n            for side1, side2 in self.iter_edges(cached_content=n2leaves):\n                if targets.issubset(side1) and (not smallest or len(side1) < len(smallest)):\n                    smallest = side1\n                elif targets.issubset(side2) and (not smallest or len(side2) < len(smallest)):\n                        smallest = side2\n                if smallest is not None and len(smallest) == len(targets):\n                    break\n            foreign_leaves = smallest - targets\n        else:\n            # Check monophyly with get_common_ancestor. Note that this\n            # step does not require traversing the tree again because\n            # targets are node instances instead of node names, and\n            # get_common_ancestor function is smart enough to detect it\n            # and avoid unnecessary traversing.\n            common = self.get_common_ancestor(targets)\n            observed = n2leaves[common]\n            foreign_leaves = set([leaf for leaf in observed\n                              if getattr(leaf, target_attr) not in values])\n\n        if not foreign_leaves:\n            return True, \"monophyletic\", foreign_leaves\n        else:\n            # if the requested attribute is not monophyletic in this\n            # node, let's differentiate between poly and paraphyly.\n            poly_common = self.get_common_ancestor(foreign_leaves)\n            # if the common ancestor of all foreign leaves is self\n            # contained, we have a paraphyly. Otherwise, polyphyly.\n            polyphyletic = [leaf for leaf in poly_common if\n                            getattr(leaf, target_attr) in values]\n            if polyphyletic:\n                return False, \"polyphyletic\", foreign_leaves\n            else:\n                return False, \"paraphyletic\", foreign_leaves", "response": "Checks that a given target attribute is monophyly under the current tree and returns True if it is monophyletic under the current tree."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of nodes that match the provided monophyly - isomorphic values.", "response": "def get_monophyletic(self, values, target_attr):\n        \"\"\"\n        Returns a list of nodes matching the provided monophyly\n        criteria. For a node to be considered a match, all\n        `target_attr` values within and node, and exclusively them,\n        should be grouped.\n\n        :param values: a set of values for which monophyly is\n            expected.\n\n        :param target_attr: node attribute being used to check\n            monophyly (i.e. species for species trees, names for gene\n            family trees).\n        \"\"\"\n        if type(values) != set:\n            values = set(values)\n\n        n2values = self.get_cached_content(store_attr=target_attr)\n\n        is_monophyletic = lambda node: n2values[node] == values\n        for match in self.iter_leaves(is_leaf_fn=is_monophyletic):\n            if is_monophyletic(match):\n                yield match"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a tree with one or more polytomies, this functions returns the list of all trees (in newick format) resulting from the combination of all possible solutions of the multifurcated nodes. .. warning: Please note that the number of of possible binary trees grows exponentially with the number and size of polytomies. Using this function with large multifurcations is not feasible: polytomy size: 3 number of binary trees: 3 polytomy size: 4 number of binary trees: 15 polytomy size: 5 number of binary trees: 105 polytomy size: 6 number of binary trees: 945 polytomy size: 7 number of binary trees: 10395 polytomy size: 8 number of binary trees: 135135 polytomy size: 9 number of binary trees: 2027025 http://ajmonline.org/2010/darwin.php", "response": "def expand_polytomies(self, \n        map_attr=\"name\", \n        polytomy_size_limit=5,\n        skip_large_polytomies=False):\n        \"\"\"\n        Given a tree with one or more polytomies, this functions returns the\n        list of all trees (in newick format) resulting from the combination of\n        all possible solutions of the multifurcated nodes.\n\n        .. warning:\n\n           Please note that the number of of possible binary trees grows\n           exponentially with the number and size of polytomies. Using this\n           function with large multifurcations is not feasible:\n\n           polytomy size: 3 number of binary trees: 3\n           polytomy size: 4 number of binary trees: 15\n           polytomy size: 5 number of binary trees: 105\n           polytomy size: 6 number of binary trees: 945\n           polytomy size: 7 number of binary trees: 10395\n           polytomy size: 8 number of binary trees: 135135\n           polytomy size: 9 number of binary trees: 2027025\n\n        http://ajmonline.org/2010/darwin.php\n        \"\"\"\n\n        class TipTuple(tuple):\n            pass\n\n        def add_leaf(tree, label):\n            yield (label, tree)\n            if not isinstance(tree, TipTuple) and isinstance(tree, tuple):\n                for left in add_leaf(tree[0], label):\n                    yield (left, tree[1])\n            for right in add_leaf(tree[1], label):\n                yield (tree[0], right)\n\n        def enum_unordered(labels):\n            if len(labels) == 1:\n                yield labels[0]\n            else:\n                for tree in enum_unordered(labels[1:]):\n                    for new_tree in add_leaf(tree, labels[0]):\n                        yield new_tree\n\n        n2subtrees = {}\n        for n in self.traverse(\"postorder\"):\n            if n.is_leaf():\n                subtrees = [getattr(n, map_attr)]\n            else:\n                subtrees = []\n                if len(n.children) > polytomy_size_limit:\n                    if skip_large_polytomies:\n                        for childtrees in itertools.product(*[n2subtrees[ch] for ch in n.children]):\n                            subtrees.append(TipTuple(childtrees))\n                    else:\n                        raise TreeError(\"Found polytomy larger than current limit: %s\" %n)\n                else:\n                    for childtrees in itertools.product(*[n2subtrees[ch] for ch in n.children]):\n                        subtrees.extend([TipTuple(subtree) for subtree in enum_unordered(childtrees)])\n\n            n2subtrees[n] = subtrees\n        return [\"%s;\"%str(nw) for nw in n2subtrees[self]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resolve_polytomy(self, \n        default_dist=0.0, \n        default_support=0.0,\n        recursive=True):\n        \"\"\"\n        Resolve all polytomies under current node by creating an\n        arbitrary dicotomic structure among the affected nodes. This\n        function randomly modifies current tree topology and should\n        only be used for compatibility reasons (i.e. programs\n        rejecting multifurcated node in the newick representation).\n\n        :param 0.0 default_dist: artificial branch distance of new\n            nodes.\n\n        :param 0.0 default_support: artificial branch support of new\n            nodes.\n\n        :param True recursive: Resolve any polytomy under this\n             node. When False, only current node will be checked and fixed.\n        \"\"\"\n        def _resolve(node):\n            if len(node.children) > 2:\n                children = list(node.children)\n                node.children = []\n                next_node = root = node\n                for i in range(len(children) - 2):\n                    next_node = next_node.add_child()\n                    next_node.dist = default_dist\n                    next_node.support = default_support\n\n                next_node = root\n                for ch in children:\n                    next_node.add_child(ch)\n                    if ch != children[-2]:\n                        next_node = next_node.children[0]\n        target = [self]\n        if recursive:\n            target.extend([n for n in self.get_descendants()])\n        for n in target:\n            _resolve(n)", "response": "This function resolves all polytomies under current node by creating an arbitrary dicotomic structure among the affected nodes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove all empty lines from the text.", "response": "def truncate_empty_lines(lines):\n    \"\"\"\n    Removes all empty lines from above and below the text.\n\n    We can't just use text.strip() because that would remove the leading\n    space for the table.\n\n    Parameters\n    ----------\n    lines : list of str\n\n    Returns\n    -------\n    lines : list of str\n        The text lines without empty lines above or below\n    \"\"\"\n    while lines[0].rstrip() == '':\n        lines.pop(0)\n    while lines[len(lines) - 1].rstrip() == '':\n        lines.pop(-1)\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef jstimestamp_slow(dte):\r\n    '''Convert a date or datetime object into a javsacript timestamp'''\r\n    year, month, day, hour, minute, second = dte.timetuple()[:6]\r\n    days = date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1\r\n    hours = days*24 + hour\r\n    minutes = hours*60 + minute\r\n    seconds = minutes*60 + second\r\n    if isinstance(dte,datetime):\r\n        return 1000*seconds + 0.001*dte.microsecond\r\n    else:\r\n        return 1000*seconds", "response": "Convert a date or datetime object into a javsacript timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef jstimestamp(dte):\r\n    '''Convert a date or datetime object into a javsacript timestamp.'''\r\n    days = date(dte.year, dte.month, 1).toordinal() - _EPOCH_ORD + dte.day - 1\r\n    hours = days*24\r\n    \r\n    if isinstance(dte,datetime):\r\n        hours += dte.hour\r\n        minutes = hours*60 + dte.minute\r\n        seconds = minutes*60 + dte.second\r\n        return 1000*seconds + int(0.001*dte.microsecond)\r\n    else:\r\n        return 3600000*hours", "response": "Convert a date or datetime object into a javsacript timestamp."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string or html file to an rst table string.", "response": "def html2rst(html_string, force_headers=False, center_cells=False,\n             center_headers=False):\n    \"\"\"\n    Convert a string or html file to an rst table string.\n\n    Parameters\n    ----------\n    html_string : str\n        Either the html string, or the filepath to the html\n    force_headers : bool\n        Make the first row become headers, whether or not they are\n        headers in the html file.\n    center_cells : bool\n        Whether or not to center the contents of the cells\n    center_headers : bool\n        Whether or not to center the contents of the header cells\n\n    Returns\n    -------\n    str\n        The html table converted to an rst grid table\n\n    Notes\n    -----\n    This function **requires** BeautifulSoup_ to work.\n\n    Example\n    -------\n    >>> html_text = '''\n    ... <table>\n    ...     <tr>\n    ...         <th>\n    ...             Header 1\n    ...         </th>\n    ...         <th>\n    ...             Header 2\n    ...         </th>\n    ...         <th>\n    ...             Header 3\n    ...         </th>\n    ...     <tr>\n    ...         <td>\n    ...             <p>This is a paragraph</p>\n    ...         </td>\n    ...         <td>\n    ...             <ul>\n    ...                 <li>List item 1</li>\n    ...                 <li>List item 2</li>\n    ...             </ul>\n    ...         </td>\n    ...         <td>\n    ...             <ol>\n    ...                 <li>Ordered 1</li>\n    ...                 <li>Ordered 2</li>\n    ...             </ol>\n    ...         </td>\n    ...     </tr>\n    ... </table>\n    ... '''\n    >>> import dashtable\n    >>> print(dashtable.html2rst(html_text))\n    +---------------------+----------------+--------------+\n    | Header 1            | Header 2       | Header 3     |\n    +=====================+================+==============+\n    | This is a paragraph | -  List item 1 | #. Ordered 1 |\n    |                     | -  List item 2 | #. Ordered 2 |\n    +---------------------+----------------+--------------+\n\n    .. _BeautifulSoup: https://www.crummy.com/software/BeautifulSoup/\n    \"\"\"\n\n    if os.path.isfile(html_string):\n        file = open(html_string, 'r', encoding='utf-8')\n        lines = file.readlines()\n        file.close()\n        html_string = ''.join(lines)\n\n    table_data, spans, use_headers = html2data(\n        html_string)\n\n    if table_data == '':\n        return ''\n    if force_headers:\n        use_headers = True\n\n    return data2rst(table_data, spans, use_headers, center_cells, center_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a list of lists of rows and columns that will make up a span", "response": "def make_span(row, column, extra_rows, extra_columns):\n    \"\"\"\n    Create a list of rows and columns that will make up a span\n\n    Parameters\n    ----------\n    row : int\n        The row of the first cell in the span\n    column : int\n        The column of the first cell in the span\n    extra_rows : int\n        The number of rows that make up the span\n    extra_columns : int\n        The number of columns that make up the span\n\n    Returns\n    -------\n    span : list of lists of int\n        A span is a list of [row, column] pairs that make up a span\n    \"\"\"\n    span = [[row, column]]\n\n    for r in range(row, row + extra_rows + 1):\n        span.append([r, column])\n\n    for c in range(column, column + extra_columns + 1):\n        span.append([row, c])\n    span.append([r, c])\n\n    return span"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_cell(table, span, widths, heights, use_headers):\n    width = get_span_char_width(span, widths)\n    height = get_span_char_height(span, heights)\n    text_row = span[0][0]\n    text_column = span[0][1]\n    text = table[text_row][text_column]\n\n    lines = text.split(\"\\n\")\n    for i in range(len(lines)):\n        width_difference = width - len(lines[i])\n        lines[i] = ''.join([lines[i], \" \" * width_difference])\n\n    height_difference = height - len(lines)\n    empty_lines = []\n    for i in range(0, height_difference):\n        empty_lines.append(\" \" * width)\n    lines.extend(empty_lines)\n\n    output = [\n        ''.join([\"+\", (width * \"-\") + \"+\"])\n    ]\n\n    for i in range(0, height):\n        output.append(\"|\" + lines[i] + \"|\")\n\n    if use_headers and span[0][0] == 0:\n        symbol = \"=\"\n    else:\n        symbol = \"-\"\n\n    output.append(\n        ''.join([\"+\", width * symbol, \"+\"])\n    )\n\n    text = \"\\n\".join(output)\n\n    row_count = get_span_row_count(span)\n    column_count = get_span_column_count(span)\n\n    cell = Cell(text, text_row, text_column, row_count, column_count)\n\n    return cell", "response": "Convert the contents of a span of a table to a grid table cell"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the SQLAlchemy database.", "response": "def init_db(self, app, entry_point_group='invenio_db.models', **kwargs):\n        \"\"\"Initialize Flask-SQLAlchemy extension.\"\"\"\n        # Setup SQLAlchemy\n        app.config.setdefault(\n            'SQLALCHEMY_DATABASE_URI',\n            'sqlite:///' + os.path.join(app.instance_path, app.name + '.db')\n        )\n        app.config.setdefault('SQLALCHEMY_ECHO', False)\n\n        # Initialize Flask-SQLAlchemy extension.\n        database = kwargs.get('db', db)\n        database.init_app(app)\n\n        # Initialize versioning support.\n        self.init_versioning(app, database, kwargs.get('versioning_manager'))\n\n        # Initialize model bases\n        if entry_point_group:\n            for base_entry in pkg_resources.iter_entry_points(\n                    entry_point_group):\n                base_entry.load()\n\n        # All models should be loaded by now.\n        sa.orm.configure_mappers()\n        # Ensure that versioning classes have been built.\n        if app.config['DB_VERSIONING']:\n            manager = self.versioning_manager\n            if manager.pending_classes:\n                if not versioning_models_registered(manager, database.Model):\n                    manager.builder.configure_versioned_classes()\n            elif 'transaction' not in database.metadata.tables:\n                manager.declarative_base = database.Model\n                manager.create_transaction_model()\n                manager.plugins.after_build_tx_class(manager)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the versioning support using SQLAlchemy - Continuum.", "response": "def init_versioning(self, app, database, versioning_manager=None):\n        \"\"\"Initialize the versioning support using SQLAlchemy-Continuum.\"\"\"\n        try:\n            pkg_resources.get_distribution('sqlalchemy_continuum')\n        except pkg_resources.DistributionNotFound:  # pragma: no cover\n            default_versioning = False\n        else:\n            default_versioning = True\n\n        app.config.setdefault('DB_VERSIONING', default_versioning)\n\n        if not app.config['DB_VERSIONING']:\n            return\n\n        if not default_versioning:  # pragma: no cover\n            raise RuntimeError(\n                'Please install extra versioning support first by running '\n                'pip install invenio-db[versioning].'\n            )\n\n        # Now we can import SQLAlchemy-Continuum.\n        from sqlalchemy_continuum import make_versioned\n        from sqlalchemy_continuum import versioning_manager as default_vm\n        from sqlalchemy_continuum.plugins import FlaskPlugin\n\n        # Try to guess user model class:\n        if 'DB_VERSIONING_USER_MODEL' not in app.config:  # pragma: no cover\n            try:\n                pkg_resources.get_distribution('invenio_accounts')\n            except pkg_resources.DistributionNotFound:\n                user_cls = None\n            else:\n                user_cls = 'User'\n        else:\n            user_cls = app.config.get('DB_VERSIONING_USER_MODEL')\n\n        plugins = [FlaskPlugin()] if user_cls else []\n\n        # Call make_versioned() before your models are defined.\n        self.versioning_manager = versioning_manager or default_vm\n        make_versioned(\n            user_cls=user_cls,\n            manager=self.versioning_manager,\n            plugins=plugins,\n        )\n\n        # Register models that have been loaded beforehand.\n        builder = self.versioning_manager.builder\n\n        for tbl in database.metadata.tables.values():\n            builder.instrument_versioned_classes(\n                database.mapper, get_class_by_table(database.Model, tbl)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an html string to data table", "response": "def extract_table(html_string, row_count, column_count):\n    \"\"\"\n    Convert an html string to data table\n\n    Parameters\n    ----------\n    html_string : str\n    row_count : int\n    column_count : int\n\n    Returns\n    -------\n    data_table : list of lists of str\n    \"\"\"\n    try:\n        from bs4 import BeautifulSoup\n        from bs4.element import Tag\n    except ImportError:\n        print(\"ERROR: You must have BeautifulSoup to use html2data\")\n        return\n\n    #html_string = convertRichText(html_string)\n\n    data_table = []\n    for row in range(0, row_count):\n        data_table.append([])\n        for column in range(0, column_count):\n            data_table[-1].append(None)\n\n    soup = BeautifulSoup(html_string, 'html.parser')\n\n    table = soup.find('table')\n\n    if not table:\n        return ''\n\n    trs = table.findAll('tr')\n    if len(trs) == 0:\n        return [['']]\n\n    for tr in range(len(trs)):\n        ths = trs[tr].findAll('th')\n        if len(ths) == 0:\n            tds = trs[tr].findAll('td')\n        else:\n            tds = ths\n\n        if len(tds) == 0:\n            tds = []\n            for i in range(0, column_count):\n                tds.append(Tag(\"\", name=\"\"))\n\n        for i in range(len(tds)):\n            td = tds[i]\n            row, column = find_unassigned_table_cell(data_table)\n\n            r_span_count = 1\n            c_span_count = 1\n\n            if td.has_attr('rowspan'):\n                r_span_count = int(td['rowspan'])\n            if td.has_attr('colspan'):\n                c_span_count = int(td['colspan'])\n\n            for row_prime in range(row, row + r_span_count):\n                for column_prime in range(column, column + c_span_count):\n                    if row_prime == row and column_prime == column:\n\n                        items = []\n                        for item in td.contents:\n                            items.append(str(item))\n                        string = ''.join(items).strip()\n\n                        text = restructify(string).rstrip()\n\n                        data_table[row_prime][column_prime] = text\n                    else:\n                        data_table[row_prime][column_prime] = \"\"\n\n            if i + 1 < column_count and i == len(tds) - 1:\n                for x in range(len(tds), column_count):\n                    if data_table[row][x] is None:\n                        data_table[row][x] = \"\"\n    for row in range(len(data_table)):\n        for column in range(len(data_table[row])):\n            if not data_table[row][column]:\n                data_table[row][column] = \"\"\n\n    return data_table"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nensuring SQLite checks foreign key constraints.", "response": "def do_sqlite_connect(dbapi_connection, connection_record):\n    \"\"\"Ensure SQLite checks foreign key constraints.\n\n    For further details see \"Foreign key support\" sections on\n    https://docs.sqlalchemy.org/en/latest/dialects/sqlite.html#foreign-key-support\n    \"\"\"\n    # Enable foreign key constraint checking\n    cursor = dbapi_connection.cursor()\n    cursor.execute('PRAGMA foreign_keys=ON')\n    cursor.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying hacks defined on the SQLAlchemy object.", "response": "def apply_driver_hacks(self, app, info, options):\n        \"\"\"Call before engine creation.\"\"\"\n        # Don't forget to apply hacks defined on parent object.\n        super(SQLAlchemy, self).apply_driver_hacks(app, info, options)\n\n        if info.drivername == 'sqlite':\n            connect_args = options.setdefault('connect_args', {})\n\n            if 'isolation_level' not in connect_args:\n                # disable pysqlite's emitting of the BEGIN statement entirely.\n                # also stops it from emitting COMMIT before any DDL.\n                connect_args['isolation_level'] = None\n\n            if not event.contains(Engine, 'connect', do_sqlite_connect):\n                event.listen(Engine, 'connect', do_sqlite_connect)\n            if not event.contains(Engine, 'begin', do_sqlite_begin):\n                event.listen(Engine, 'begin', do_sqlite_begin)\n\n            from sqlite3 import register_adapter\n\n            def adapt_proxy(proxy):\n                \"\"\"Get current object and try to adapt it again.\"\"\"\n                return proxy._get_current_object()\n\n            register_adapter(LocalProxy, adapt_proxy)\n\n        elif info.drivername == 'postgresql+psycopg2':  # pragma: no cover\n            from psycopg2.extensions import adapt, register_adapter\n\n            def adapt_proxy(proxy):\n                \"\"\"Get current object and try to adapt it again.\"\"\"\n                return adapt(proxy._get_current_object())\n\n            register_adapter(LocalProxy, adapt_proxy)\n\n        elif info.drivername == 'mysql+pymysql':  # pragma: no cover\n            from pymysql import converters\n\n            def escape_local_proxy(val, mapping):\n                \"\"\"Get current object and try to adapt it again.\"\"\"\n                return converters.escape_item(\n                    val._get_current_object(),\n                    self.engine.dialect.encoding,\n                    mapping=mapping,\n                )\n\n            converters.conversions[LocalProxy] = escape_local_proxy\n            converters.encoders[LocalProxy] = escape_local_proxy"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rolling(self, op):\n        missing   = self.missing\n        ismissing = self.ismissing\n        window = self.window\n        it = iter(self.iterable)\n        queue = deque(islice(it, window))\n        ol = self.skiplist((e for e in queue if e == e))\n        yield op(ol,missing)\n        for newelem in it:\n            oldelem = queue.popleft()\n            if not ismissing(oldelem):\n                ol.remove(oldelem)\n            queue.append(newelem)\n            if not ismissing(newelem):\n                ol.insert(newelem)\n            yield op(ol, missing)", "response": "Fast rolling operation with O ( log n ) updates where n is the window size\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_span_column_count(span):\n    columns = 1\n    first_column = span[0][1]\n\n    for i in range(len(span)):\n        if span[i][1] > first_column:\n            columns += 1\n            first_column = span[i][1]\n\n    return columns", "response": "Returns the number of columns in a single column."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn self as a dictionary with _underscore subdicts corrected.", "response": "def to_dict(self):\n        \"returns self as a dictionary with _underscore subdicts corrected.\"\n        ndict = {}\n        for key, val in self.__dict__.items():\n            if key[0] == \"_\":\n                ndict[key[1:]] = val\n            else:\n                ndict[key] = val\n        return ndict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the total width of the column widths that make up the span plus the extra.", "response": "def get_span_char_width(span, column_widths):\n    \"\"\"\n    Sum the widths of the columns that make up the span, plus the extra.\n\n    Parameters\n    ----------\n    span : list of lists of int\n        list of [row, column] pairs that make up the span\n    column_widths : list of int\n        The widths of the columns that make up the table\n\n    Returns\n    -------\n    total_width : int\n        The total width of the span\n    \"\"\"\n\n    start_column = span[0][1]\n    column_count = get_span_column_count(span)\n    total_width = 0\n\n    for i in range(start_column, start_column + column_count):\n        total_width += column_widths[i]\n\n    total_width += column_count - 1\n\n    return total_width"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrebuild a model s EncryptedType properties when the SECRET_KEY is changed.", "response": "def rebuild_encrypted_properties(old_key, model, properties):\n    \"\"\"Rebuild a model's EncryptedType properties when the SECRET_KEY is changed.\n\n    :param old_key: old SECRET_KEY.\n    :param model: the affected db model.\n    :param properties: list of properties to rebuild.\n    \"\"\"\n    inspector = reflection.Inspector.from_engine(db.engine)\n    primary_key_names = inspector.get_primary_keys(model.__tablename__)\n\n    new_secret_key = current_app.secret_key\n    db.session.expunge_all()\n    try:\n        with db.session.begin_nested():\n            current_app.secret_key = old_key\n            db_columns = []\n            for primary_key in primary_key_names:\n                db_columns.append(getattr(model, primary_key))\n            for prop in properties:\n                db_columns.append(getattr(model, prop))\n            old_rows = db.session.query(*db_columns).all()\n    except Exception as e:\n        current_app.logger.error(\n            'Exception occurred while reading encrypted properties. '\n            'Try again before starting the server with the new secret key.')\n        raise e\n    finally:\n        current_app.secret_key = new_secret_key\n        db.session.expunge_all()\n\n    for old_row in old_rows:\n        primary_keys, old_entries = old_row[:len(primary_key_names)], \\\n                                    old_row[len(primary_key_names):]\n        primary_key_fields = dict(zip(primary_key_names, primary_keys))\n        update_values = dict(zip(properties, old_entries))\n        model.query.filter_by(**primary_key_fields).\\\n            update(update_values)\n    db.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the name of the versioned model class.", "response": "def versioning_model_classname(manager, model):\n    \"\"\"Get the name of the versioned model class.\"\"\"\n    if manager.options.get('use_module_name', True):\n        return '%s%sVersion' % (\n            model.__module__.title().replace('.', ''), model.__name__)\n    else:\n        return '%sVersion' % (model.__name__,)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef versioning_models_registered(manager, base):\n    declared_models = base._decl_class_registry.keys()\n    return all(versioning_model_classname(manager, c) in declared_models\n               for c in manager.pending_classes)", "response": "Return True if all versioning models have been registered."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vector_to_symmetric(v):\r\n    '''Convert an iterable into a symmetric matrix.'''\r\n    np = len(v)\r\n    N = (int(sqrt(1 + 8*np)) - 1)//2\r\n    if N*(N+1)//2 != np:\r\n        raise ValueError('Cannot convert vector to symmetric matrix')\r\n    sym = ndarray((N,N))\r\n    iterable = iter(v)\r\n    for r in range(N):\r\n        for c in range(r+1):\r\n            sym[r,c] = sym[c,r] = iterable.next()\r\n    return sym", "response": "Convert an iterable into a symmetric matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cov(self, ddof=None, bias=0):\r\n        '''The covariance matrix from the aggregate sample. It accepts an\r\n        optional parameter for the degree of freedoms.\r\n\r\n        :parameter ddof: If not ``None`` normalization is by (N - ddof), where N is\r\n            the number of observations; this overrides the value implied by bias.\r\n            The default value is None.\r\n        '''\r\n        N = self.n\r\n        M = N if bias else N-1\r\n        M = M if ddof is None else N-ddof\r\n        return (self.sxx - outer(self.sx,self.sx)/N)/M", "response": "The covariance matrix from the aggregate sample. It accepts an optional parameter for the degree of freedoms."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the Calmar ratio for a Weiner process", "response": "def calmar(sharpe, T = 1.0):\n    '''\n    Calculate the Calmar ratio for a Weiner process\n    \n    @param sharpe:    Annualized Sharpe ratio\n    @param T:         Time interval in years\n    '''\n    x = 0.5*T*sharpe*sharpe\n    return x/qp(x)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a table of data to a simple rst table.", "response": "def data2simplerst(table, spans=[[[0, 0]]], use_headers=True, headers_row=0):\n    \"\"\"\n    Convert table data to a simple rst table\n\n    Parameters\n    ----------\n    table : list of lists of str\n        A table of strings.\n    spans : list of lists of lists of int\n        A list of spans. A span is a list of [Row, Column] pairs of\n        table cells that are joined together.\n    use_headers : bool, optional\n        Whether or not to include headers in the table. A header is\n        a cell that is underlined with \"=\"\n    headers_row : int\n        The row that will be the headers. In a simple rst table, the\n        headers do not need to be at the top.\n\n    Returns\n    -------\n    str\n        The simple rst table\n\n    Example\n    -------\n    >>> table = [\n    ...     [\"Inputs\", \"\", \"Output\"],\n    ...     [\"A\", \"B\", \"A or B\"],\n    ...     [\"False\", \"False\", \"False\"],\n    ...     [\"True\", \"False\", \"True\"],\n    ...     [\"False\", \"True\", \"True\"],\n    ...     [\"True\", \"True\", \"True\"],\n    ... ]\n    >>> spans = [\n    ...     [ [0, 0], [0, 1] ]\n    ... ]\n    >>> print(data2simplerst(table, spans, headers_row=1))\n    ======  =====  ======\n       Inputs      Output\n    -------------  ------\n      A       B    A or B\n    ======  =====  ======\n    False   False  False\n     True   False   True\n    False   True    True\n     True   True    True\n    ======  =====  ======\n    \"\"\"\n\n    table = copy.deepcopy(table)\n\n    table_ok = check_table(table)\n    if not table_ok == \"\":\n        return \"ERROR: \" + table_ok\n\n    if not spans == [[[0, 0]]]:\n        for span in spans:\n            span_ok = check_span(span, table)\n            if not span_ok == \"\":\n                return \"ERROR: \" + span_ok\n\n    table = ensure_table_strings(table)\n    table = multis_2_mono(table)\n\n    output = []\n\n    column_widths = []\n    for col in table[0]:\n        column_widths.append(0)\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            if len(table[row][column]) > column_widths[column]:\n                column_widths[column] = len(table[row][column])\n\n    underline = ''\n    for col in column_widths:\n        underline = ''.join([underline + col * '=', '  '])\n\n    output.append(underline)\n\n    for row in range(len(table)):\n        string = ''\n        column = 0\n\n        while column < len(table[row]):\n            span = get_span(spans, row, column)\n\n            if (span and span[0] == [row, column] and\n                    not table[row][column] == ''):\n                span_col_count = get_span_column_count(span)\n\n                end_col = column + span_col_count\n                width = sum(column_widths[column:end_col])\n                width += 2 * (span_col_count - 1)\n\n                string += center_line(width, table[row][column]) + '  '\n\n            elif table[row][column] == '':\n                pass\n\n            else:\n                string += center_line(\n                    column_widths[column], table[row][column]) + '  '\n\n            column += 1\n\n        output.append(string)\n\n        if row == headers_row and use_headers:\n            output.append(underline)\n\n        else:\n            if row_includes_spans(table, row, spans):\n                new_underline = ''\n                column = 0\n                while column < len(table[row]):\n                    span = get_span(spans, row, column)\n                    if (span and span[0] == [row, column] and\n                            not table[row][column] == ''):\n                        span_col_count = get_span_column_count(span)\n\n                        end_column = column + span_col_count\n                        width = sum(column_widths[column:end_column])\n                        width += 2 * (span_col_count - 1)\n\n                        new_underline += (width * '-') + '  '\n\n                    elif table[row][column] == '':\n                        pass\n\n                    else:\n                        new_underline += (column_widths[column] * '-') + '  '\n                    column += 1\n                output.append(new_underline)\n\n    for i in range(len(output)):\n        output[i] = output[i].rstrip()\n\n    output.append(underline)\n\n    return '\\n'.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_links(converted_text, html):\n    soup = BeautifulSoup(html, 'html.parser')\n\n    link_exceptions = [\n        'footnote-reference',\n        'fn-backref',\n        'citation-reference'\n    ]\n\n    footnotes = {}\n    citations = {}\n    backrefs = {}\n\n    links = soup.find_all('a')\n    for link in links:\n        href = link.get('href')\n        text = process_tag(link)\n        classes = dict(link.attrs).get('class', '')\n\n        if 'footnote-reference' in classes:\n            footnotes[href] = '#' + link.get('id')\n\n        elif 'citation-reference' in classes:\n            text = process_tag(link)\n            citations[text] = '#' + link.get('id')\n\n        elif 'fn-backref' in classes:\n            sibling = link.findNext('td')\n            text = process_tag(sibling)\n            backrefs[href] = text\n\n        excepted_link = False\n        for class_type in classes:\n            if class_type in link_exceptions:\n                excepted_link = True\n\n        if not excepted_link:\n            if text.endswith('_'):\n                text = text[0:-1]\n            if len(text.split(' ')) > 1:\n                text = text[1:-1]\n            converted_text += '.. _' + text + ': ' + href + '\\n'\n\n    if len(footnotes.keys()) > 0:\n        converted_text += '\\n'\n\n    for key in footnotes.keys():\n        text = backrefs[footnotes[key]]\n        converted_text += '.. [' + key + '] ' + text + '\\n'\n\n    if len(citations.keys()) > 0:\n        converted_text += '\\n'\n\n    for key in citations.keys():\n        text = backrefs[citations[key]]\n        converted_text += '.. ' + key[0:-1] + ' ' + text + '\\n'\n\n    return converted_text.rstrip()", "response": "Add the links to the bottom of the text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self, providers, symbols, start, end, logger, backend, **kwargs):\r\n        '''Load symbols data.\r\n\r\n        :keyword providers: Dictionary of registered data providers.\r\n        :keyword symbols: list of symbols to load.\r\n        :keyword start: start date.\r\n        :keyword end: end date.\r\n        :keyword logger: instance of :class:`logging.Logger` or ``None``.\r\n        :keyword backend: :class:`dynts.TimeSeries` backend name.\r\n\r\n        There is no need to override this function, just use one\r\n        the three hooks available.\r\n        '''\r\n        # Preconditioning on dates\r\n        logger = logger or logging.getLogger(self.__class__.__name__)\r\n        start, end = self.dates(start, end)\r\n        data = {}\r\n        for sym in symbols:\r\n            # Get ticker, field and provider\r\n            symbol = self.parse_symbol(sym, providers)\r\n            provider = symbol.provider\r\n            if not provider:\r\n                raise MissingDataProvider(\r\n                    'data provider for %s not available' % sym\r\n                )\r\n            pre = self.preprocess(symbol, start, end, logger, backend, **kwargs)\r\n            if pre.intervals:\r\n                result = None\r\n                for st, en in pre.intervals:\r\n                    logger.info('Loading %s from %s. From %s to %s',\r\n                                symbol.ticker, provider, st, en)\r\n                    res = provider.load(symbol, st, en, logger, backend,\r\n                                        **kwargs)\r\n                    if result is None:\r\n                        result = res\r\n                    else:\r\n                        result.update(res)\r\n            else:\r\n                result = pre.result\r\n            # onresult hook\r\n            result = self.onresult(symbol, result, logger, backend, **kwargs)\r\n            data[sym] = result\r\n        # last hook\r\n        return self.onfinishload(data, logger, backend, **kwargs)", "response": "Load symbols data from the given provider and list of symbols."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a symbol to obtain information regarding ticker field and provider. Must return an instance of SymbolData.", "response": "def parse_symbol(self, symbol, providers):\r\n        '''Parse a symbol to obtain information regarding ticker,\r\n        field and provider. Must return an instance of :attr:`symboldata`.\r\n\r\n        :keyword symbol: string associated with market data to load.\r\n        :keyword providers: dictionary of :class:`dynts.data.DataProvider`\r\n                            instances available.\r\n\r\n        For example::\r\n\r\n            intc\r\n            intc:open\r\n            intc:volume:google\r\n            intc:google\r\n\r\n        are all valid inputs returning a :class:`SymbolData` instance with\r\n        the following triplet of information::\r\n\r\n            intc,None,yahoo\r\n            intc,open,yahoo\r\n            intc,volume,google\r\n            intc,None,google\r\n\r\n        assuming ``yahoo`` is the provider in\r\n        :attr:`dynts.conf.Settings.default_provider`.\r\n\r\n        This function is called before retrieving data.\r\n        '''\r\n        separator = settings.field_separator\r\n        symbol = str(symbol)\r\n        bits = symbol.split(separator)\r\n        pnames = providers.keys()\r\n        ticker = symbol\r\n        provider = None\r\n        field = None\r\n        if len(bits) == 2:\r\n            ticker = bits[0]\r\n            if bits[1] in pnames:\r\n                provider = bits[1]\r\n            else:\r\n                field = bits[1]\r\n        elif len(bits) == 3:\r\n            ticker = bits[0]\r\n            if bits[1] in pnames:\r\n                provider = bits[1]\r\n                field = bits[2]\r\n            elif bits[2] in pnames:\r\n                provider = bits[2]\r\n                field = bits[1]\r\n            else:\r\n                raise BadSymbol(\r\n                        'Could not parse %s. Unrecognized provider.' % symbol)\r\n        elif len(bits) > 3:\r\n            raise BadSymbol('Could not parse %s.' % symbol)\r\n\r\n        return self.symbol_for_ticker(ticker, field, provider, providers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef symbol_for_ticker(self, ticker, field, provider, providers):\r\n        '''Return an instance of *symboldata* containing\r\ninformation about the data provider, the data provider ticker name\r\nand the data provider field.'''\r\n        provider = provider or settings.default_provider\r\n        if provider:\r\n            provider = providers.get(provider, None)\r\n        return self.symboldata(ticker, field, provider)", "response": "Return an instance of *symboldata* containing the data provider ticker name\r\nand the data provider field."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef preprocess(self, ticker, start, end, logger, backend, **kwargs):\r\n        '''Preprocess **hook**. This is first loading hook and it is\r\n**called before requesting data** from a dataprovider.\r\nIt must return an instance of :attr:`TimeSerieLoader.preprocessdata`.\r\nBy default it returns::\r\n\r\n    self.preprocessdata(intervals = ((start,end),))\r\n\r\nIt could be overritten to modify the intervals.\r\nIf the intervals is ``None`` or an empty container,\r\nthe :func:`dynts.data.DataProvider.load` method won't be called,\r\notherwise it will be called as many times as the number of intervals\r\nin the return tuple (by default once).\r\n'''\r\n        return self.preprocessdata(intervals = ((start, end),))", "response": "Preprocess the data from a data provider."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(self, provider):\r\n        '''Register a new data provider. *provider* must be an instance of\r\n    DataProvider. If provider name is already available, it will be replaced.'''\r\n        if isinstance(provider,type):\r\n            provider = provider()\r\n        self[provider.code] = provider", "response": "Register a new data provider."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(timeseries_expression, method=None, functions=None, debug=False):\r\n    '''Function for parsing :ref:`timeseries expressions <dsl-script>`.\r\n    If succesful, it returns an instance of :class:`dynts.dsl.Expr` which\r\n    can be used to to populate timeseries or scatters once data is available.\r\n\r\n    Parsing is implemented using the ply_ module,\r\n    an implementation of lex and yacc parsing tools for Python.\r\n\r\n    :parameter expression: A :ref:`timeseries expressions <dsl-script>` string.\r\n    :parameter method: Not yet used.\r\n    :parameter functions: dictionary of functions to use when parsing.\r\n        If not provided the :data:`dynts.function_registry`\r\n        will be used.\r\n\r\n        Default ``None``.\r\n    :parameter debug: debug flag for ply_.  Default ``False``.\r\n\r\n    For examples and usage check the :ref:`dsl documentation <dsl>`.\r\n\r\n    .. _ply: http://www.dabeaz.com/ply/\r\n    '''\r\n    if not parsefunc:\r\n        raise ExpressionError('Could not parse. No parser installed.')\r\n    functions = functions if functions is not None else function_registry\r\n    expr_str = str(timeseries_expression).lower()\r\n    return parsefunc(expr_str, functions, method, debug)", "response": "Function for parsing a time series expression."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef evaluate(expression, start=None, end=None, loader=None, logger=None,\r\n             backend=None, **kwargs):\r\n    '''Evaluate a timeseries ``expression`` into\r\n    an instance of :class:`dynts.dsl.dslresult` which can be used\r\n    to obtain timeseries and/or scatters.\r\n    This is probably the most used function of the library.\r\n\r\n    :parameter expression: A timeseries expression string or an instance\r\n        of :class:`dynts.dsl.Expr` obtained using the :func:`~.parse`\r\n        function.\r\n    :parameter start: Start date or ``None``.\r\n    :parameter end: End date or ``None``. If not provided today values is used.\r\n    :parameter loader: Optional :class:`dynts.data.TimeSerieLoader`\r\n        class or instance to use.\r\n\r\n        Default ``None``.\r\n    :parameter logger: Optional python logging instance, used if you required\r\n        logging.\r\n\r\n        Default ``None``.\r\n    :parameter backend: :class:`dynts.TimeSeries` backend name or ``None``.\r\n\r\n    The ``expression`` is parsed and the :class:`~.Symbol` are sent to the\r\n    :class:`dynts.data.TimeSerieLoader` instance for retrieving\r\n    actual timeseries data.\r\n    It returns an instance of :class:`~.DSLResult`.\r\n\r\n    Typical usage::\r\n\r\n        >>> from dynts import api\r\n        >>> r = api.evaluate('min(GS,window=30)')\r\n        >>> r\r\n        min(GS,window=30)\r\n        >>> ts = r.ts()\r\n    '''\r\n    if isinstance(expression, str):\r\n        expression = parse(expression)\r\n    if not expression or expression.malformed():\r\n        raise CouldNotParse(expression)\r\n    symbols = expression.symbols()\r\n    start = start if not start else todate(start)\r\n    end = end if not end else todate(end)\r\n    data = providers.load(symbols, start, end, loader=loader,\r\n                          logger=logger, backend=backend, **kwargs)\r\n    return DSLResult(expression, data, backend=backend)", "response": "Evaluate a timeseries expression into a list of time series objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_consensus_tree(self, cutoff=0.0, best_tree=None):\n        if best_tree:\n            raise NotImplementedError(\"best_tree option not yet supported.\")\n        cons = ConsensusTree(self.treelist, cutoff)\n        cons.update()\n        return cons.ttree", "response": "Returns an extended majority rule consensus tree as a Toytree object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw_tree_grid(self, \n        nrows=None, \n        ncols=None, \n        start=0, \n        fixed_order=False, \n        shared_axis=False, \n        **kwargs):\n        \"\"\"        \n        Draw a slice of x*y trees into a x,y grid non-overlapping. \n\n        Parameters:\n        -----------\n        x (int):\n            Number of grid cells in x dimension. Default=automatically set.\n        y (int):\n            Number of grid cells in y dimension. Default=automatically set.\n        start (int):\n            Starting index of tree slice from .treelist.\n        kwargs (dict):\n            Toytree .draw() arguments as a dictionary. \n        \"\"\"\n        # return nothing if tree is empty\n        if not self.treelist:\n            print(\"Treelist is empty\")\n            return None, None\n\n        # make a copy of the treelist so we don't modify the original\n        if not fixed_order:\n            treelist = self.copy().treelist\n        else:\n            if fixed_order is True:\n                fixed_order = self.treelist[0].get_tip_labels()\n            treelist = [\n                ToyTree(i, fixed_order=fixed_order) \n                for i in self.copy().treelist\n            ]\n\n        # apply kwargs styles to the individual tree styles\n        for tree in treelist:\n            tree.style.update(kwargs)\n\n        # get reasonable values for x,y given treelist length\n        if not (ncols or nrows):\n            ncols = 5\n            nrows = 1\n        elif not (ncols and nrows):\n            if ncols:\n                if ncols == 1:\n                    if self.ntrees <= 5:\n                        nrows = self.ntrees\n                    else:\n                        nrows = 2\n                else:\n                    if self.ntrees <= 10:\n                        nrows = 2\n                    else:\n                        nrows = 3\n\n            if nrows:\n                if nrows == 1:\n                    if self.ntrees <= 5:\n                        ncols = self.ntrees \n                    else:\n                        ncols = 5\n                else:\n                    if self.ntrees <= 10:\n                        ncols = 5\n                    else:\n                        ncols = 3\n        else:\n            pass\n\n        # Return TereGrid object for debugging\n        draw = TreeGrid(treelist)\n        if kwargs.get(\"debug\"):\n            return draw\n\n        # Call update to draw plot. Kwargs still here for width, height, axes\n        canvas, axes = draw.update(nrows, ncols, start, shared_axis, **kwargs)\n        return canvas, axes", "response": "Draw a slice of x * y trees into a x y grid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_cloud_tree(self, \n        axes=None, \n        html=False,\n        fixed_order=True,\n        **kwargs):\n        \"\"\"\n        Draw a series of trees overlapping each other in coordinate space.\n        The order of tip_labels is fixed in cloud trees so that trees with \n        discordant relationships can be seen in conflict. To change the tip\n        order use the 'fixed_order' argument in toytree.mtree() when creating\n        the MultiTree object.\n\n        Parameters:\n            axes (toyplot.Cartesian): toyplot Cartesian axes object.\n            html (bool): whether to return the drawing as html (default=PNG).\n            edge_styles: (list): option to enter a list of edge dictionaries.\n            **kwargs (dict): styling options should be input as a dictionary.\n        \"\"\"\n        # return nothing if tree is empty\n        if not self.treelist:\n            print(\"Treelist is empty\")\n            return None, None\n\n        # return nothing if tree is empty\n        if not self.all_tips_shared:\n            print(\"All trees in treelist do not share the same tips\")\n            return None, None            \n\n        # make a copy of the treelist so we don't modify the original\n        if not fixed_order:\n            raise Exception(\n                \"fixed_order must be either True or a list with the tip order\")\n\n        # set fixed order on a copy of the tree list\n        if isinstance(fixed_order, (list, tuple)):\n            pass\n        elif fixed_order is True:\n            fixed_order = self.treelist[0].get_tip_labels()\n        else:\n            raise Exception(\n                \"fixed_order argument must be True or a list with the tip order\")\n        treelist = [\n            ToyTree(i, fixed_order=fixed_order) for i in self.copy().treelist\n        ]  \n\n        # give advice if user tries to enter tip_labels\n        if kwargs.get(\"tip_labels\"):\n            print(TIP_LABELS_ADVICE)\n\n        # set autorender format to png so we don't bog down notebooks\n        try:\n            changed_autoformat = False\n            if not html:\n                toyplot.config.autoformat = \"png\"\n                changed_autoformat = True\n\n            # dict of global cloud tree style \n            mstyle = STYLES['m']\n\n            # if trees in treelist already have some then we don't quash...\n            mstyle.update(\n                {i: j for (i, j) in kwargs.items() if \n                (j is not None) & (i != \"tip_labels\")}\n            )\n            for tree in treelist:\n                tree.style.update(mstyle)\n\n            # Send a copy of MultiTree to init Drawing object.\n            draw = CloudTree(treelist, **kwargs)\n\n            # and create drawing\n            if kwargs.get(\"debug\"):\n                return draw\n\n            # allow user axes, and kwargs for width, height\n            canvas, axes = draw.update(axes)\n            return canvas, axes\n\n        finally:\n            if changed_autoformat:\n                toyplot.config.autoformat = \"html\"", "response": "Draw a series of trees overlapping each other in coordinate space."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhash ladderized tree topologies", "response": "def hash_trees(self):\n        \"hash ladderized tree topologies\"       \n        observed = {}\n        for idx, tree in enumerate(self.treelist):\n            nwk = tree.write(tree_format=9)\n            hashed = md5(nwk.encode(\"utf-8\")).hexdigest()\n            if hashed not in observed:\n                observed[hashed] = idx\n                self.treedict[idx] = 1\n            else:\n                idx = observed[hashed]\n                self.treedict[idx] += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter_clades(self):\n        \"Remove conflicting clades and those < cutoff to get majority rule\"\n        passed = []\n        carrs = np.array([list(i[0]) for i in self.clade_counts], dtype=int)\n        freqs = np.array([i[1] for i in self.clade_counts])\n\n        for idx in range(carrs.shape[0]):\n            conflict = False\n            if freqs[idx] < self.cutoff:\n                continue\n            \n            for pidx in passed:\n                intersect = np.max(carrs[idx] + carrs[pidx]) > 1\n                \n                # is either one a subset of the other?\n                subset_test0 = np.all(carrs[idx] - carrs[pidx] >= 0)\n                subset_test1 = np.all(carrs[pidx] - carrs[idx] >= 0)\n                if intersect:\n                    if (not subset_test0) and (not subset_test1):\n                        conflict = True\n\n            if not conflict:\n                passed.append(idx)\n\n        rclades = []\n        for idx in passed:\n            rclades.append((carrs[idx], freqs[idx]))\n        self.fclade_counts = rclades", "response": "Remove conflicting clades and those < cutoff to get majority rule"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_trees(self):\n        \"Build an unrooted consensus tree from filtered clade counts.\"\n\n        # storage\n        nodes = {}\n        idxarr = np.arange(len(self.fclade_counts[0][0]))\n        queue = []\n\n        ## create dict of clade counts and set keys\n        countdict = defaultdict(int)\n        for clade, count in self.fclade_counts:\n            mask = np.int_(list(clade)).astype(np.bool)\n            ccx = idxarr[mask]\n            queue.append((len(ccx), frozenset(ccx)))\n            countdict[frozenset(ccx)] = count\n\n        while queue:\n            queue.sort()\n            (clade_size, clade) = queue.pop(0)\n            new_queue = []\n\n            # search for ancestors of clade\n            for (_, ancestor) in queue:\n                if clade.issubset(ancestor):\n                    # update ancestor such that, in the following example:\n                    # ancestor == {1, 2, 3, 4}\n                    # clade == {2, 3}\n                    # new_ancestor == {1, {2, 3}, 4}\n                    new_ancestor = (ancestor - clade) | frozenset([clade])\n                    countdict[new_ancestor] = countdict.pop(ancestor)\n                    ancestor = new_ancestor\n\n                new_queue.append((len(ancestor), ancestor))\n\n            # if the clade is a tip, then we have a name\n            if clade_size == 1:\n                name = list(clade)[0]\n                name = self.namedict[name]\n            else:\n                name = None\n\n            # the clade will not be in nodes if it is a tip\n            children = [nodes.pop(c) for c in clade if c in nodes]\n            node = TreeNode(name=name)\n            for child in children:\n                node.add_child(child)\n            if not node.is_leaf():\n                node.dist = int(round(100 * countdict[clade]))\n                node.support = int(round(100 * countdict[clade]))\n            else:\n                node.dist = int(100)\n                node.support = int(100)\n\n            nodes[clade] = node\n            queue = new_queue\n        nodelist = list(nodes.values())\n        tre = nodelist[0]\n\n        #tre.unroot()\n        ## return the tree and other trees if present\n        self.ttree = ToyTree(tre.write(format=0))\n        self.ttree._coords.update()\n        self.nodelist = nodelist", "response": "Build an unrooted consensus tree from filtered clade counts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing the phonetic representations of 2 words and return a boolean value.", "response": "def sounds_like(self, word1, word2):\n        \"\"\"Compare the phonetic representations of 2 words, and return a boolean value.\"\"\"\n        return self.phonetics(word1) == self.phonetics(word2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the similarity of the words in the sequence.", "response": "def distance(self, word1, word2, metric='levenshtein'):\n        \"\"\"Get the similarity of the words, using the supported distance metrics.\"\"\"\n        if metric in self.distances:\n            distance_func = self.distances[metric]\n            return distance_func(self.phonetics(word1), self.phonetics(word2))\n        else:\n            raise DistanceMetricError('Distance metric not supported! Choose from levenshtein, hamming.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_output_row_heights(table, spans):\n    heights = []\n    for row in table:\n        heights.append(-1)\n\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            text = table[row][column]\n            span = get_span(spans, row, column)\n            row_count = get_span_row_count(span)\n            height = len(text.split('\\n'))\n            if row_count == 1 and height > heights[row]:\n                heights[row] = height\n\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            span = get_span(spans, row, column)\n            row_count = get_span_row_count(span)\n            if row_count > 1:\n                text_row = span[0][0]\n                text_column = span[0][1]\n\n                end_row = text_row + row_count\n\n                text = table[text_row][text_column]\n\n                height = len(text.split('\\n')) - (row_count - 1)\n\n                add_row = 0\n                while height > sum(heights[text_row:end_row]):\n                    heights[text_row + add_row] += 1\n                    if add_row + 1 < row_count:\n                        add_row += 1\n                    else:\n                        add_row = 0\n    return heights", "response": "Get the heights of the rows of the output table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef smedian(olist,nobs):\r\n    '''Generalised media for odd and even number of samples'''\r\n    if nobs:\r\n        rem = nobs % 2\r\n        midpoint = nobs // 2\r\n        me = olist[midpoint]\r\n        if not rem:\r\n            me = 0.5 * (me + olist[midpoint-1])\r\n        return me\r\n    else:\r\n        return NaN", "response": "Generalised media for odd and even number of samples"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a rolling mean function to an array.", "response": "def roll_mean(input, window):\r\n    '''Apply a rolling mean function to an array.\r\nThis is a simple rolling aggregation.'''\r\n    nobs, i, j, sum_x = 0,0,0,0.\r\n    N = len(input)\r\n\r\n    if window > N:\r\n        raise ValueError('Out of bound')\r\n\r\n    output = np.ndarray(N-window+1,dtype=input.dtype)\r\n\r\n    for val in input[:window]:\r\n        if val == val:\r\n            nobs += 1\r\n            sum_x += val\r\n\r\n    output[j] = NaN if not nobs else sum_x / nobs\r\n\r\n    for val in input[window:]:\r\n        prev = input[j]\r\n        if prev == prev:\r\n            sum_x -= prev\r\n            nobs -= 1\r\n\r\n        if val == val:\r\n            nobs += 1\r\n            sum_x += val\r\n\r\n        j += 1\r\n        output[j] = NaN if not nobs else sum_x / nobs\r\n\r\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef roll_sd(input, window, scale = 1.0, ddof = 0):\r\n    '''Apply a rolling standard deviation function\r\nto an array. This is a simple rolling aggregation of squared\r\nsums.'''\r\n    nobs, i, j, sx, sxx = 0,0,0,0.,0.\r\n    N = len(input)\r\n    sqrt = np.sqrt\r\n\r\n    if window > N:\r\n        raise ValueError('Out of bound')\r\n\r\n    output = np.ndarray(N-window+1,dtype=input.dtype)\r\n\r\n    for val in input[:window]:\r\n        if val == val:\r\n            nobs += 1\r\n            sx += val\r\n            sxx += val*val\r\n\r\n    nn = nobs - ddof\r\n    output[j] = NaN if nn<=0 else sqrt(scale * (sxx - sx*sx/nobs) / nn)\r\n\r\n    for val in input[window:]:\r\n        prev = input[j]\r\n        if prev == prev:\r\n            sx -= prev\r\n            sxx -= prev*prev\r\n            nobs -= 1\r\n\r\n        if val == val:\r\n            nobs += 1\r\n            sx += val\r\n            sxx += val*val\r\n\r\n        j += 1\r\n        nn = nobs - ddof\r\n        output[j] = NaN if nn<=0 else sqrt(scale * (sxx - sx*sx/nobs) / nn)\r\n\r\n    return output", "response": "Apply a rolling standard deviation function\r\n            to an array. This is a simple rolling aggregation of squared\r\nTuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_span(span, table):\n\n    if not type(span) is list:\n        return \"Spans must be a list of lists\"\n\n    for pair in span:\n        if not type(pair) is list:\n            return \"Spans must be a list of lists of int\"\n        if not len(pair) == 2:\n            return \"Spans must be a [Row, Column] pair of integers\"\n\n    total_rows = get_span_row_count(span)\n    total_columns = get_span_column_count(span)\n\n    if not len(span) == total_rows * total_columns:\n        return ''.join([\"Spans must be rectangular in shape. \",\n                        str(span) + \" is invalid\"])\n\n    if max(span, key=lambda x: x[0])[0] > len(table) - 1:\n        return ' '.join([\"One of the span's rows extends beyond the\",\n                         \"bounds of the table:\", str(span)])\n\n    if max(span, key=lambda x: x[1])[1] > len(table[0]) - 1:\n        return ' '.join([\"One of the span's columns extends beyond the\",\n                         \"bounds of the table:\", str(span)])\n\n    test_span = copy.deepcopy(span)\n\n    checked = [test_span.pop(0)]\n\n    while len(test_span) > 0:\n        row = test_span[0][0]\n        col = test_span[0][1]\n        matched = False\n\n        for i in range(len(checked)):\n            if row == checked[i][0] and abs(col - checked[i][1]) == 1:\n                matched = True\n\n            elif abs(row - checked[i][0]) == 1 and col == checked[i][1]:\n                matched = True\n\n        if matched:\n            checked.append(test_span.pop(0))\n\n        else:\n            checked.extend(test_span)\n            return 'This span is not valid: ' + str(checked)\n\n    return \"\"", "response": "Checks that the given span is valid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge_all_cells(cells):\n    current = 0\n\n    while len(cells) > 1:\n        count = 0\n\n        while count < len(cells):\n            cell1 = cells[current]\n            cell2 = cells[count]\n\n            merge_direction = get_merge_direction(cell1, cell2)\n            if not merge_direction == \"NONE\":\n                merge_cells(cell1, cell2, merge_direction)\n\n                if current > count:\n                    current -= 1\n\n                cells.pop(count)\n\n            else:\n                count += 1\n\n        current += 1\n\n        if current >= len(cells):\n            current = 0\n\n    return cells[0].text", "response": "Loop through list of cells and piece them together one by one."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bpp2newick(bppnewick):\n    \"converts bpp newick format to normal newick\"\n    regex1 = re.compile(r\" #[-+]?[0-9]*\\.?[0-9]*[:]\")\n    regex2 = re.compile(r\" #[-+]?[0-9]*\\.?[0-9]*[;]\")\n    regex3 = re.compile(r\": \")\n    new = regex1.sub(\":\", bppnewick)\n    new = regex2.sub(\";\", new)\n    new = regex3.sub(\":\", new)\n    return new", "response": "converts bpp newick format to normal newick"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing to produce balanced trees returns a tip node from the smaller clade", "response": "def return_small_clade(treenode):\n    \"used to produce balanced trees, returns a tip node from the smaller clade\"\n    node = treenode\n    while 1:\n        if node.children:\n            c1, c2 = node.children\n            node = sorted([c1, c2], key=lambda x: len(x.get_leaves()))[0]\n        else:\n            return node"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fuzzy_match_tipnames(ttree, names, wildcard, regex, mrca=True, mono=True):\n    # require arguments\n    if not any([names, wildcard, regex]):\n        raise ToytreeError(\n            \"must enter an outgroup, wildcard selector, or regex pattern\")\n\n    # get list of **nodes** from {list, wildcard, or regex}\n    tips = []\n    if names:\n        if isinstance(names, (str, int)):\n            names = [names]\n        notfound = [i for i in names if i not in ttree.get_tip_labels()]\n        if any(notfound):\n            raise ToytreeError(\n                \"Sample {} is not in the tree\".format(notfound))\n        tips = [i for i in ttree.treenode.get_leaves() if i.name in names]\n\n    # use regex to match tipnames\n    elif regex:\n        tips = [\n            i for i in ttree.treenode.get_leaves() if re.match(regex, i.name)\n        ]               \n        if not any(tips):\n            raise ToytreeError(\"No Samples matched the regular expression\")\n\n    # use wildcard substring matching\n    elif wildcard:\n        tips = [i for i in ttree.treenode.get_leaves() if wildcard in i.name]\n        if not any(tips):\n            raise ToytreeError(\"No Samples matched the wildcard\")\n\n    # build list of **tipnames** from matched nodes\n    if not tips:\n        raise ToytreeError(\"no matching tipnames\")       \n    tipnames = [i.name for i in tips]\n\n    # if a single tipname matched no need to check for monophyly\n    if len(tips) == 1:\n        if mrca:\n            return tips[0]\n        else:\n            return tipnames\n\n    # if multiple nodes matched, check if they're monophyletic\n    mbool, mtype, mnames = (\n        ttree.treenode.check_monophyly(\n            tipnames, \"name\", ignore_missing=True)\n    )\n\n    # get mrca node\n    node = ttree.treenode.get_common_ancestor(tips)\n\n    # raise an error if required to be monophyletic but not\n    if mono:\n        if not mbool:\n            raise ToytreeError(\n                \"Taxon list cannot be paraphyletic\")\n\n    # return tips or nodes\n    if not mrca:\n        return tipnames\n    else:\n        return node", "response": "This function returns a list of internal mrca nodes that match the given list of tipnames."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef node_scale_root_height(self, treeheight=1):\n        # make tree height = 1 * treeheight\n        ctree = self._ttree.copy()\n        _height = ctree.treenode.height\n        for node in ctree.treenode.traverse():\n            node.dist = (node.dist / _height) * treeheight\n        ctree._coords.update()\n        return ctree", "response": "Returns a toytree with all nodes scaled so that the root \n        height equals the value entered for treeheight."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a toytree copy with node heights modified while retaining the same topology but not necessarily node branching order.", "response": "def node_slider(self, seed=None):\n        \"\"\"\n        Returns a toytree copy with node heights modified while retaining \n        the same topology but not necessarily node branching order. \n        Node heights are moved up or down uniformly between their parent \n        and highest child node heights in 'levelorder' from root to tips.\n        The total tree height is retained at 1.0, only relative edge\n        lengths change.\n        \"\"\"\n        # I don't think user's should need to access prop\n        prop = 0.999\n        assert isinstance(prop, float), \"prop must be a float\"\n        assert prop < 1, \"prop must be a proportion >0 and < 1.\"\n        random.seed(seed)\n\n        ctree = self._ttree.copy()\n        for node in ctree.treenode.traverse():\n\n            ## slide internal nodes \n            if node.up and node.children:\n\n                ## get min and max slides\n                minjit = max([i.dist for i in node.children]) * prop\n                maxjit = (node.up.height * prop) - node.height\n                newheight = random.uniform(-minjit, maxjit)\n\n                ## slide children\n                for child in node.children:\n                    child.dist += newheight\n\n                ## slide self to match\n                node.dist -= newheight\n        ctree._coords.update()\n        return ctree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node_multiplier(self, multiplier=0.5, seed=None):\n        random.seed(seed)\n        ctree = self._ttree.copy()\n        low, high = sorted([multiplier, 1. / multiplier])\n        mult = random.uniform(low, high)\n        for node in ctree.treenode.traverse():\n            node.dist = node.dist * mult\n        ctree._coords.update()\n        return ctree", "response": "Returns a toytree with all nodes multiplied by a constant \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tree with branch lengths transformed so that the tree is ultrametric.", "response": "def make_ultrametric(self, strategy=1):\n        \"\"\"\n        Returns a tree with branch lengths transformed so that the tree is \n        ultrametric. Strategies include (1) tip-align: extend tips to the length\n        of the fartest tip from the root; (2) non-parametric rate-smoothing: \n        minimize ancestor-descendant local rates on branches to align tips (\n        not yet supported); and (3) penalized-likelihood: not yet supported.\n        \"\"\"\n        ctree = self._ttree.copy()\n\n        if strategy == 1:\n            for node in ctree.treenode.traverse():\n                if node.is_leaf():\n                    node.dist = node.height + 1\n\n        else:\n            raise NotImplementedError(\n                \"Strategy {} not yet implemented. Seeking developers.\"\n                .format(strategy))\n\n        return ctree"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coaltree(ntips, ne=None, seed=None):\n\n        # seed generator\n        random.seed(seed)\n\n        # convert units\n        coalunits = False\n        if not ne:\n            coalunits = True\n            ne = 10000\n\n        # build tree: generate N tips as separate Nodes then attach together \n        # at internal nodes drawn randomly from coalescent waiting times.\n        tips = [\n            toytree.tree().treenode.add_child(name=str(i)) \n            for i in range(ntips)\n        ]\n        while len(tips) > 1:\n            rtree = toytree.tree()\n            tip1 = tips.pop(random.choice(range(len(tips))))\n            tip2 = tips.pop(random.choice(range(len(tips))))\n            kingman = (4. * ne) / float(ntips * (ntips - 1))\n            dist = random.expovariate(1. / kingman)\n            rtree.treenode.add_child(tip1, dist=tip2.height + dist)\n            rtree.treenode.add_child(tip2, dist=tip1.height + dist)\n            tips.append(rtree.treenode)\n\n        # build new tree from the newick string\n        self = toytree.tree(tips[0].write())    \n        self.treenode.ladderize()\n\n        # make tree edges in units of 2N (then N doesn't matter!)\n        if coalunits:\n            for node in self.treenode.traverse():\n                node.dist /= (2. * ne)\n\n        # ensure tips are at zero (they sometime vary just slightly)\n        for node in self.treenode.traverse():\n            if node.is_leaf():\n                node.dist += node.height\n\n        # set tipnames\n        for tip in self.get_tip_labels():\n            node = self.treenode.search_nodes(name=tip)[0]\n            node.name = \"r{}\".format(node.name)\n\n        # decompose fills in internal node names and idx\n        self._coords.update()\n        return self", "response": "Returns a coalescent tree with ntips samples and waiting times drawn from the kingman coalescent."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a random tree with N tips and a root height set to 1 or a user - entered treeheight value.", "response": "def unittree(ntips, treeheight=1.0, seed=None):\n        \"\"\"\n        Returns a random tree topology w/ N tips and a root height set to\n        1 or a user-entered treeheight value. Descendant nodes are evenly \n        spaced between the root and time 0.\n\n        Parameters\n        -----------\n        ntips (int):\n            The number of tips in the randomly generated tree\n\n        treeheight(float):\n            Scale tree height (all edges) so that root is at this height.\n\n        seed (int):\n            Random number generator seed.\n        \"\"\"\n        # seed generator\n        random.seed(seed)\n\n        # generate tree with N tips.\n        tmptree = TreeNode()\n        tmptree.populate(ntips)\n        self = toytree.tree(newick=tmptree.write())\n\n        # set tip names by labeling sequentially from 0\n        self = (\n            self\n            .ladderize()\n            .mod.make_ultrametric()\n            .mod.node_scale_root_height(treeheight)\n        )\n\n        # set tipnames randomly (doesn't have to match idx)\n        nidx = list(range(self.ntips))\n        random.shuffle(nidx)\n        for tidx, node in enumerate(self.treenode.get_leaves()):\n            node.name = \"r{}\".format(nidx[tidx])\n\n        # fill internal node names and idx\n        self._coords.update()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an imbalanced ( comb - like ) tree topology.", "response": "def imbtree(ntips, treeheight=1.0):\n        \"\"\"\n        Return an imbalanced (comb-like) tree topology.\n        \"\"\"\n        rtree = toytree.tree()\n        rtree.treenode.add_child(name=\"0\")\n        rtree.treenode.add_child(name=\"1\")\n\n        for i in range(2, ntips):\n            # empty node\n            cherry = toytree.tree()\n            # add new child\n            cherry.treenode.add_child(name=str(i))\n            # add old tree\n            cherry.treenode.add_child(rtree.treenode)\n            # update rtree\n            rtree = cherry\n        \n        # get toytree from newick            \n        tre = toytree.tree(rtree.write(tree_format=9))\n        tre = tre.mod.make_ultrametric()\n        self = tre.mod.node_scale_root_height(treeheight)\n        self._coords.update()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a balanced tree topology.", "response": "def baltree(ntips, treeheight=1.0):\n        \"\"\"\n        Returns a balanced tree topology.\n        \"\"\"\n        # require even number of tips\n        if ntips % 2:\n            raise ToytreeError(\"balanced trees must have even number of tips.\")\n\n        # make first cherry\n        rtree = toytree.tree()\n        rtree.treenode.add_child(name=\"0\")\n        rtree.treenode.add_child(name=\"1\")\n\n        # add tips in a balanced way\n        for i in range(2, ntips):\n\n            # get node to split\n            node = return_small_clade(rtree.treenode)\n\n            # add two children\n            node.add_child(name=node.name)\n            node.add_child(name=str(i))\n\n            # rename ancestral node\n            node.name = None\n\n        # rename tips so names are in order\n        idx = 0\n        for node in rtree.treenode.traverse(\"postorder\"):\n            if node.is_leaf():\n                node.name = str(idx)\n                idx += 1\n        \n        # get toytree from newick            \n        tre = toytree.tree(rtree.write(tree_format=9))\n        tre = tre.mod.make_ultrametric()\n        self = tre.mod.node_scale_root_height(treeheight)\n        self._coords.update()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the height of a span in the number of newlines it fills.", "response": "def get_span_char_height(span, row_heights):\n    \"\"\"\n    Get the height of a span in the number of newlines it fills.\n\n    Parameters\n    ----------\n    span : list of list of int\n        A list of [row, column] pairs that make up the span\n    row_heights : list of int\n        A list of the number of newlines for each row in the table\n\n    Returns\n    -------\n    total_height : int\n        The height of the span in number of newlines\n    \"\"\"\n    start_row = span[0][0]\n    row_count = get_span_row_count(span)\n    total_height = 0\n\n    for i in range(start_row, start_row + row_count):\n        total_height += row_heights[i]\n    total_height += row_count - 1\n\n    return total_height"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an html table to a data table and spans.", "response": "def html2data(html_string):\n    \"\"\"\n    Convert an html table to a data table and spans.\n\n    Parameters\n    ----------\n    html_string : str\n        The string containing the html table\n\n    Returns\n    -------\n    table : list of lists of str\n    spans : list of lists of lists of int\n        A span is a list of [row, column] pairs that define what cells\n        are merged in a table.\n    use_headers : bool\n    \"\"\"\n    spans = extract_spans(html_string)\n\n    column_count = get_html_column_count(html_string)\n    row_count = get_html_row_count(spans)\n\n    count = 0\n    while count < len(spans):\n        if len(spans[count]) == 1:\n            spans.pop(count)\n        else:\n            count += 1\n\n    table = extract_table(html_string, row_count, column_count)\n\n    use_headers = headers_present(html_string)\n\n    return table, spans, use_headers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn newick represenation of the tree in its current state.", "response": "def newick(self, tree_format=0):\n        \"Returns newick represenation of the tree in its current state.\"\n        # checks one of root's children for features and extra feats.\n        if self.treenode.children:\n            features = {\"name\", \"dist\", \"support\", \"height\", \"idx\"}\n            testnode = self.treenode.children[0]\n            extrafeat = {i for i in testnode.features if i not in features}\n            features.update(extrafeat)\n            return self.treenode.write(format=tree_format)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_edge_values(self, feature='idx'):\n        elist = []\n        for cidx in self._coords.edges[:, 1]:\n            node = self.treenode.search_nodes(idx=cidx)[0]\n            elist.append(\n                (node.__getattribute__(feature) if hasattr(node, feature) else \"\")\n                )\n        return elist", "response": "Returns the edge values in the order they are plotted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the edge values from a dictionary mapping node idx to values.", "response": "def get_edge_values_from_dict(self, node_value_dict=None, include_stem=True):\n        \"\"\"\n        Enter a dictionary mapping node 'idx' or tuple of tipnames to values \n        that you want mapped to the stem and descendant edges that node. \n        Edge values are returned in proper plot order to be entered to the \n        edge_colors or edge_widths arguments to draw(). To see node idx values \n        use node_labels=True in draw(). If dictionary keys are integers it is\n        assumed they are node idxs. \n\n        Note: it is safer to use tip labels to identify clades than node idxs \n        since tree tranformations (e.g., rooting) can change the mapping of \n        idx values to nodes on the tree.\n\n        This function is most convenient for applying values to clades. To\n        instead map values to specific edges (e.g., a single internal edge) \n        it will be easier to use tre.get_edge_values() and then to set the \n        values of the internal edges manually.\n\n        Example 1: \n          tre = toytree.tree(\"((a,b),(c,d));\")\n          tre.get_edge_values_from_dict({5: 'green', 6: 'red'})\n          # ['green', 'green', 'green', 'red', 'red', 'red']\n\n        Example 2: \n          tre = toytree.tree(\"((a,b),(c,d));\")\n          tre.get_edge_values_from_dict({(a, b): 'green', (c, d): 'red'})          \n          # ['green', 'green', 'green', 'red', 'red', 'red']\n        \"\"\"\n        # map node idxs to the order in which edges are plotted\n        idxs = {j: i for (i, j) in enumerate(self.get_edge_values())}\n        values = [None] * self._coords.edges.shape[0]\n        if node_value_dict is None:\n            return values\n\n        # convert tipname lists to node idxs\n        rmap = {}\n        for (key, val) in node_value_dict.items():\n            if isinstance(key, (str, tuple)):\n                node = fuzzy_match_tipnames(self, key, None, None, True, False)\n                rmap[node.idx] = val\n            else:\n                rmap[key] = val\n        node_value_dict = rmap\n\n        # map over tree\n        for node in self.treenode.traverse(\"levelorder\"):\n            if node.idx in node_value_dict:\n\n                # add value to stem edge\n                if include_stem:\n                    if not node.is_root():\n                        values[idxs[node.idx]] = node_value_dict[node.idx]\n            \n                # add value to descendants edges\n                for desc in node.get_descendants():\n                    values[idxs[desc.idx]] = node_value_dict[node.idx]\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_mrca_idx_from_tip_labels(self, names=None, wildcard=None, regex=None):\n        if not any([names, wildcard, regex]):\n            raise ToytreeError(\"at least one argument required\")\n        node = fuzzy_match_tipnames(\n            self, names, wildcard, regex, True, False)\n        return node.idx", "response": "Returns the node idx label for the most recent common ancestor node that includes the selected tips."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the node values from the tree object in the tree object order.", "response": "def get_node_values(\n        self, \n        feature=None, \n        show_root=False, \n        show_tips=False, \n        ):\n        \"\"\"\n        Returns node values from tree object in node plot order. To modify\n        values you must modify the .treenode object directly by setting new\n        'features'. For example\n\n        for node in ttree.treenode.traverse():\n            node.add_feature(\"PP\", 100)\n\n        By default node and tip values are hidden (set to \"\") so that they\n        are not shown on the tree plot. To include values for these nodes\n        use the 'show_root'=True, or 'show_tips'=True arguments.\n\n        tree.get_node_values(\"support\", True, True)\n        \"\"\"\n        # access nodes in the order they will be plotted\n        ndict = self.get_node_dict(return_internal=True, return_nodes=True)\n        nodes = [ndict[i] for i in range(self.nnodes)[::-1]]\n\n        # get features\n        if feature:\n            vals = [i.__getattribute__(feature) if hasattr(i, feature)\n                    else \"\" for i in nodes]\n        else:\n            vals = [\" \" for i in nodes]\n\n        # apply hiding rules\n        if not show_root:\n            vals = [i if not j.is_root() else \"\" for i, j in zip(vals, nodes)]\n        if not show_tips:\n            vals = [i if not j.is_leaf() else \"\" for i, j in zip(vals, nodes)]\n\n        # convert float to ints for prettier printing unless all floats\n        # raise exception and skip if there are true strings (names)\n        try:\n            if all([Decimal(str(i)) % 1 == 0 for i in vals if i]):\n                vals = [int(i) if isinstance(i, float) else i for i in vals]\n        except Exception:\n            pass\n\n        return vals"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary mapping idx to name where idx is", "response": "def get_node_dict(self, return_internal=False, return_nodes=False):\n        \"\"\"\n        Return node labels as a dictionary mapping {idx: name} where idx is \n        the order of nodes in 'preorder' traversal. Used internally by the\n        func .get_node_values() to return values in proper order. \n\n        return_internal: if True all nodes are returned, if False only tips.\n        return_nodes: if True returns TreeNodes, if False return node names.\n        \"\"\"\n        if return_internal:\n            if return_nodes:\n                return {\n                    i.idx: i for i in self.treenode.traverse(\"preorder\")\n                }\n            else:\n                return {\n                    i.idx: i.name for i in self.treenode.traverse(\"preorder\")\n                }\n        else:\n            if return_nodes:\n                return {\n                    i.idx: i for i in self.treenode.traverse(\"preorder\")\n                    if i.is_leaf()\n                }\n            else:\n                return {\n                    i.idx: i.name for i in self.treenode.traverse(\"preorder\")\n                    if i.is_leaf()\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the coordinates of the tip positions for a tree.", "response": "def get_tip_coordinates(self, axis=None):\n        \"\"\"\n        Returns coordinates of the tip positions for a tree. If no argument\n        for axis then a 2-d array is returned. The first column is the x \n        coordinates the second column is the y-coordinates. If you enter an \n        argument for axis then a 1-d array will be returned of just that axis.\n        \"\"\"\n        # get coordinates array\n        coords = self.get_node_coordinates()\n        if axis == 'x':\n            return coords[:self.ntips, 0]\n        elif axis == 'y':\n            return coords[:self.ntips, 1]\n        return coords[:self.ntips]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_tip_labels(self, idx=None):\n        if not idx:\n            return self.treenode.get_leaf_names()[::-1]\n        else:\n            treenode = self.treenode.search_nodes(idx=idx)[0]\n            return treenode.get_leaf_names()[::-1]", "response": "Returns the tip labels of the given node in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if there is a bifurcating entry in the tree.", "response": "def is_bifurcating(self, include_root=True):\n        \"\"\"\n        Returns False if there is a polytomy in the tree, including if the tree\n        is unrooted (basal polytomy), unless you use the include_root=False\n        argument.\n        \"\"\"\n        ctn1 = -1 + (2 * len(self))\n        ctn2 = -2 + (2 * len(self))\n        if self.is_rooted():\n            return bool(ctn1 == sum(1 for i in self.treenode.traverse()))\n        if include_root:\n            return bool(ctn2 == -1 + sum(1 for i in self.treenode.traverse()))\n        return bool(ctn2 == sum(1 for i in self.treenode.traverse()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new tree with internal nodes with dist < = min_dist and support < = 50.", "response": "def collapse_nodes(self, min_dist=1e-6, min_support=0):\n        \"\"\"\n        Returns a copy of the tree where internal nodes with dist <= min_dist\n        are deleted, resulting in a collapsed tree. e.g.:\n\n        newtre = tre.collapse_nodes(min_dist=0.001)\n        newtre = tre.collapse_nodes(min_support=50)\n        \"\"\"\n        nself = self.copy()\n        for node in nself.treenode.traverse():\n            if not node.is_leaf():\n                if (node.dist <= min_dist) | (node.support < min_support):\n                    node.delete()\n        nself._coords.update()\n        return nself"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a copy of the tree with the selected tips removed.", "response": "def drop_tips(self, names=None, wildcard=None, regex=None):\n        \"\"\"\n        Returns a copy of the tree with the selected tips removed. The entered\n        value can be a name or list of names. To prune on an internal node to\n        create a subtree see the .prune() function instead.\n\n        Parameters:\n        tips: list of tip names.\n\n        # example:\n        ptre = tre.drop_tips(['a', 'b'])\n        \"\"\"\n        # make a deepcopy of the tree\n        nself = self.copy()\n\n        # return if nothing to drop\n        if not any([names, wildcard, regex]):\n            return nself\n\n        # get matching names list with fuzzy match\n        tipnames = fuzzy_match_tipnames(\n            ttree=nself,\n            names=names,\n            wildcard=wildcard,\n            regex=regex,\n            mrca=False,\n            mono=False,\n        )\n\n        if len(tipnames) == len(nself):\n            raise ToytreeError(\"You cannot drop all tips from the tree.\")\n\n        if not tipnames:\n            raise ToytreeError(\"No tips selected.\")\n\n        keeptips = [i for i in nself.get_tip_labels() if i not in tipnames]\n        nself.treenode.prune(keeptips, preserve_branch_length=True)\n        nself._coords.update()\n        return nself"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rotate_node(\n        self, \n        names=None, \n        wildcard=None, \n        regex=None, \n        idx=None, \n        # modify_tree=False,\n        ):\n        \"\"\"\n        Returns a ToyTree with the selected node rotated for plotting.\n        tip colors do not align correct currently if nodes are rotated...\n        \"\"\"\n        # make a copy\n        revd = {j: i for (i, j) in enumerate(self.get_tip_labels())}\n        neworder = {}\n\n        # get node to rotate\n        treenode = fuzzy_match_tipnames(\n            self, names, wildcard, regex, True, True)\n        children = treenode.up.children\n        names = [[j.name for j in i.get_leaves()] for i in children]\n        nidxs = [[revd[i] for i in j] for j in names]\n\n        # get size of the big clade\n        move = max((len(i) for i in nidxs))\n        if len(nidxs[0]) > len(nidxs[1]):\n            move = min((len(i) for i in nidxs))\n\n        # newdict\n        cnames = list(itertools.chain(*names))\n        tdict = {i: None for i in cnames}\n        cycle = itertools.cycle(itertools.chain(*nidxs))\n        for m in range(move):\n            next(cycle)\n        for t in cnames:\n            tdict[t] = next(cycle)\n\n        for key in revd:\n            if key in tdict:\n                neworder[key] = tdict[key]\n            else:\n                neworder[key] = revd[key]\n\n        revd = {j: i for (i, j) in neworder.items()}\n        neworder = [revd[i] for i in range(self.ntips)]\n\n        # returns a new tree (i.e., copy) modified w/ a fixed order\n        nself = ToyTree(self.newick, fixed_order=neworder)\n        nself._coords.update()\n        return nself", "response": "Rotate a node in the ToyTree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_polytomy(\n        self,\n        dist=1.0,\n        support=100,\n        recursive=True):\n        \"\"\"\n        Returns a copy of the tree with all polytomies randomly resolved.\n        Does not transform tree in-place.\n        \"\"\"\n        nself = self.copy()\n        nself.treenode.resolve_polytomy(\n            default_dist=dist,\n            default_support=support,\n            recursive=recursive)\n        nself._coords.update()\n        return nself", "response": "Returns a new tree with all polytomies randomly resolved."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unroot(self):\n        nself = self.copy()\n        nself.treenode.unroot()\n        nself.treenode.ladderize()\n        nself._coords.update()\n        return nself", "response": "Returns a copy of the tree unrooted. Does not transform tree in - place."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef root(self, names=None, wildcard=None, regex=None):\n        # make a deepcopy of the tree\n        nself = self.copy()\n\n        # get treenode of the common ancestor of selected tips\n        try:\n            node = fuzzy_match_tipnames(\n                nself, names, wildcard, regex, True, True)       \n\n        except ToytreeError:           \n            # try reciprocal taxon list\n            tipnames = fuzzy_match_tipnames(\n                nself, names, wildcard, regex, False, False)\n            tipnames = list(set(self.get_tip_labels()) - set(node))\n            node = fuzzy_match_tipnames(\n                nself, tipnames, None, None, True, True)\n\n        # split root node if more than di- as this is the unrooted state\n        if not nself.is_bifurcating():\n            nself.treenode.resolve_polytomy()\n\n        # root the object with ete's translate\n        nself.treenode.set_outgroup(node)\n        nself._coords.update()\n\n        # get features\n        testnode = nself.treenode.get_leaves()[0]\n        features = {\"name\", \"dist\", \"support\", \"height\"}\n        extrafeat = {i for i in testnode.features if i not in features}\n        features.update(extrafeat)\n\n        # if there is a new node now, clean up its features\n        nnode = [i for i in nself.treenode.traverse() if not hasattr(i, \"idx\")]\n        if nnode:\n            # nnode is the node that was added\n            # rnode is the location where it *should* have been added\n            nnode = nnode[0]\n            rnode = [i for i in nself.treenode.children if i != node][0]\n\n            # get idxs of existing nodes\n            idxs = [int(i.idx) for i in nself.treenode.traverse()\n                    if hasattr(i, \"idx\")]\n\n            # newnode is a tip\n            if len(node.is_leaf()) == 1:\n                nnode.name = str(\"rerooted\")\n                rnode.name = node\n                rnode.add_feature(\"idx\", max(idxs) + 1)\n                rnode.dist *= 2\n                sister = rnode.get_sisters()[0]\n                sister.dist *= 2\n                rnode.support = 100\n                for feature in extrafeat:\n                    nnode.add_feature(feature, getattr(rnode, feature))\n                    rnode.del_feature(feature)\n\n            # newnode is internal\n            else:\n                nnode.add_feature(\"idx\", max(idxs) + 1)\n                nnode.name = str(\"rerooted\")\n                nnode.dist *= 2\n                sister = nnode.get_sisters()[0]\n                sister.dist *= 2\n                nnode.support = 100\n\n        # store tree back into newick and reinit Toytree with new newick\n        # if NHX format then preserve the NHX features.\n        nself.treenode.ladderize()\n        nself._coords.update()\n        return nself", "response": "Return a new tree with the rooted state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw(\n        self,\n        tree_style=None,\n        height=None,\n        width=None,\n        axes=None,        \n        orient=None,\n        tip_labels=None,\n        tip_labels_colors=None,\n        tip_labels_style=None,\n        tip_labels_align=None,\n        node_labels=None,\n        node_labels_style=None,\n        node_sizes=None,\n        node_colors=None,\n        node_style=None,\n        node_hover=None,\n        node_markers=None,\n        edge_colors=None,\n        edge_widths=None,\n        edge_type=None,\n        edge_style=None,\n        edge_align_style=None,\n        use_edge_lengths=None,\n        scalebar=None,\n        padding=None,\n        xbaseline=0,\n        ybaseline=0,\n        **kwargs):\n        \"\"\"\n        Plot a Toytree tree, returns a tuple of Toyplot (Canvas, Axes) objects.\n\n        Parameters:\n        -----------\n        tree_style: str\n            One of several preset styles for tree plotting. The default is 'n'\n            (normal). Other options inlude 'c' (coalescent), 'd' (dark), and\n            'm' (multitree). You also create your own TreeStyle objects.\n            The tree_style sets a default set of styling on top of which other\n            arguments passed to draw() will override when plotting.\n\n        height: int (optional; default=None)\n            If None the plot height is autosized. If 'axes' arg is used then \n            tree is drawn on an existing Canvas, Axes and this arg is ignored.\n\n        width: int (optional; default=None)\n            Similar to height (above). \n\n        axes: Toyplot.Cartesian (default=None)\n            A toyplot cartesian axes object. If provided tree is drawn on it.\n            If not provided then a new Canvas and Cartesian axes are created\n            and returned with the tree plot added to it.\n\n        use_edge_lengths: bool (default=False)\n            Use edge lengths from .treenode (.get_edge_lengths) else\n            edges are set to length >=1 to make tree ultrametric.\n\n        tip_labels: [True, False, list]\n            If True then the tip labels from .treenode are added to the plot.\n            If False no tip labels are added. If a list of tip labels\n            is provided it must be the same length as .get_tip_labels().\n\n        tip_labels_colors:\n            ...\n\n        tip_labels_style:\n            ...\n\n        tip_labels_align:\n            ...\n\n        node_labels: [True, False, list]\n            If True then nodes are shown, if False then nodes are suppressed\n            If a list of node labels is provided it must be the same length\n            and order as nodes in .get_node_values(). Node labels can be \n            generated in the proper order using the the .get_node_labels() \n            function from a Toytree tree to draw info from the tree features.\n            For example: node_labels=tree.get_node_labels(\"support\").\n\n        node_sizes: [int, list, None]\n            If None then nodes are not shown, otherwise, if node_labels\n            then node_size can be modified. If a list of node sizes is\n            provided it must be the same length and order as nodes in\n            .get_node_dict().\n\n        node_colors: [list]\n            Use this argument only if you wish to set different colors for\n            different nodes, in which case you must enter a list of colors\n            as string names or HEX values the length and order of nodes in\n            .get_node_dict(). If all nodes will be the same color then use\n            instead the node_style dictionary:\n            e.g., node_style={\"fill\": 'red'}\n\n        node_style: [dict]\n\n        ...\n\n        node_hover: [True, False, list, dict]\n            Default is True in which case node hover will show the node\n            values. If False then no hover is shown. If a list or dict\n            is provided (which should be in node order) then the values\n            will be shown in order. If a dict then labels can be provided\n            as well.\n        \"\"\"\n        # allow ts as a shorthand for tree_style\n        if kwargs.get(\"ts\"):\n            tree_style = kwargs.get(\"ts\")\n\n        # pass a copy of this tree so that any mods to .style are not saved\n        nself = deepcopy(self)\n        if tree_style:\n            nself.style.update(TreeStyle(tree_style[0]))\n\n        # update kwargs to merge it with user-entered arguments:\n        userargs = {\n            \"height\": height,\n            \"width\": width,\n            \"orient\": orient,\n            \"tip_labels\": tip_labels,\n            \"tip_labels_colors\": tip_labels_colors,\n            \"tip_labels_align\": tip_labels_align,\n            \"tip_labels_style\": tip_labels_style,\n            \"node_labels\": node_labels,\n            \"node_labels_style\": node_labels_style,\n            \"node_sizes\": node_sizes,\n            \"node_colors\": node_colors,\n            \"node_hover\": node_hover,\n            \"node_style\": node_style,\n            \"node_markers\": node_markers,\n            \"edge_type\": edge_type,\n            \"edge_colors\": edge_colors,\n            \"edge_widths\": edge_widths,\n            \"edge_style\": edge_style,\n            \"edge_align_style\": edge_align_style,\n            \"use_edge_lengths\": use_edge_lengths,\n            \"scalebar\": scalebar,\n            \"padding\": padding,\n            \"xbaseline\": xbaseline, \n            \"ybaseline\": ybaseline,\n        }\n        kwargs.update(userargs)\n        censored = {i: j for (i, j) in kwargs.items() if j is not None}\n        nself.style.update(censored)\n\n        # warn user if they entered kwargs that weren't recognized:\n        unrecognized = [i for i in kwargs if i not in userargs]\n        if unrecognized:\n            print(\"unrecognized arguments skipped: {}\".format(unrecognized))\n            print(\"check the docs, argument names may have changed.\")\n\n        # Init Drawing class object.\n        draw = Drawing(nself)\n\n        # Debug returns the object to test with.\n        if kwargs.get(\"debug\"):\n            return draw\n\n        # Make plot. If user provided explicit axes then include them.\n        canvas, axes = draw.update(axes=axes)\n        return canvas, axes", "response": "Function to draw a Toytree tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the direction of the merge between two cells.", "response": "def get_merge_direction(cell1, cell2):\n    \"\"\"\n    Determine the side of cell1 that can be merged with cell2.\n\n    This is based on the location of the two cells in the table as well\n    as the compatability of their height and width.\n\n    For example these cells can merge::\n\n         cell1    cell2      merge \"RIGHT\"\n\n        +-----+  +------+   +-----+------+\n        | foo |  | dog  |   | foo | dog  |\n        |     |  +------+   |     +------+\n        |     |  | cat  |   |     | cat  |\n        |     |  +------+   |     +------+\n        |     |  | bird |   |     | bird |\n        +-----+  +------+   +-----+------+\n\n    But these cells cannot merge::\n\n        +-----+  +------+\n        | foo |  | dog  |\n        |     |  +------+\n        |     |  | cat  |\n        |     |  +------+\n        |     |\n        +-----+\n\n    Parameters\n    ----------\n    cell1 : dashtable.data2rst.Cell\n    cell2 : dashtable.data2rst.Cell\n\n    Returns\n    -------\n    str\n        The side onto which cell2 can be merged. Will be one of\n        [\"LEFT\", \"RIGHT\", \"BOTTOM\", \"TOP\", \"NONE\"]\n    \"\"\"\n    cell1_left = cell1.column\n    cell1_right = cell1.column + cell1.column_count\n    cell1_top = cell1.row\n    cell1_bottom = cell1.row + cell1.row_count\n\n    cell2_left = cell2.column\n    cell2_right = cell2.column + cell2.column_count\n    cell2_top = cell2.row\n    cell2_bottom = cell2.row + cell2.row_count\n\n    if (cell1_right == cell2_left and cell1_top == cell2_top and\n            cell1_bottom == cell2_bottom and\n            cell1.right_sections >= cell2.left_sections):\n        return \"RIGHT\"\n\n    elif (cell1_left == cell2_left and cell1_right == cell2_right and\n            cell1_top == cell2_bottom and\n            cell1.top_sections >= cell2.bottom_sections):\n        return \"TOP\"\n\n    elif (cell1_left == cell2_left and\n          cell1_right == cell2_right and\n          cell1_bottom == cell2_top and\n          cell1.bottom_sections >= cell2.top_sections):\n        return \"BOTTOM\"\n\n    elif (cell1_left == cell2_right and\n          cell1_top == cell2_top and\n          cell1_bottom == cell2_bottom and\n          cell1.left_sections >= cell2.right_sections):\n        return \"LEFT\"\n\n    else:\n        return \"NONE\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_nhx(NHX_string):\n    # store features\n    ndict = {}\n\n    # parse NHX or MB features\n    if \"[&&NHX:\" in NHX_string:\n        NHX_string = NHX_string.replace(\"[&&NHX:\", \"\")\n        NHX_string = NHX_string.replace(\"]\", \"\")\n        \n        for field in NHX_string.split(\":\"):\n            try:\n                pname, pvalue = field.split(\"=\")\n                ndict[pname] = pvalue\n            except ValueError as e:\n                raise NewickError('Invalid NHX format %s' % field)\n    return ndict", "response": "Parse NHX string into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_data_from_intree(self):\n\n        # load string: filename or data stream\n        if isinstance(self.intree, (str, bytes)):\n            \n            # strip it\n            self.intree = self.intree.strip()\n\n            # is a URL: make a list by splitting a string\n            if any([i in self.intree for i in (\"http://\", \"https://\")]):\n                response = requests.get(self.intree)\n                response.raise_for_status()\n                self.data = response.text.strip().split(\"\\n\")\n\n            # is a file: read by lines to a list\n            elif os.path.exists(self.intree):\n                with open(self.intree, 'rU') as indata:\n                    self.data = indata.readlines()\n\n            # is a string: make into a list by splitting\n            else:\n                self.data = self.intree.split(\"\\n\")\n\n        # load iterable: iterable of newick strings\n        elif isinstance(self.intree, (list, set, tuple)):\n            self.data = list(self.intree)", "response": "Load the data from an internal file or string and return as a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_nexus(self):\n        \"get newick data from NEXUS\"\n        if self.data[0].strip().upper() == \"#NEXUS\":\n            nex = NexusParser(self.data)\n            self.data = nex.newicks\n            self.tdict = nex.tdict", "response": "get newick data from NEXUS"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests format of intree nex / nwk extra features", "response": "def get_treenodes(self):\n        \"test format of intree nex/nwk, extra features\"\n\n        if not self.multitree:\n            # get TreeNodes from Newick\n            extractor = Newick2TreeNode(self.data[0].strip(), fmt=self.fmt)\n        \n            # extract one tree\n            self.treenodes.append(extractor.newick_from_string())\n\n        else:\n            for tre in self.data:\n                # get TreeNodes from Newick\n                extractor = Newick2TreeNode(tre.strip(), fmt=self.fmt)\n        \n                # extract one tree\n                self.treenodes.append(extractor.newick_from_string())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a newick string in the New Hampshire format.", "response": "def newick_from_string(self):\n        \"Reads a newick string in the New Hampshire format.\"\n\n        # split on parentheses to traverse hierarchical tree structure\n        for chunk in self.data.split(\"(\")[1:]:\n            # add child to make this node a parent.\n            self.current_parent = (\n                self.root if self.current_parent is None else\n                self.current_parent.add_child()\n            )\n\n            # get all parenth endings from this parenth start\n            subchunks = [ch.strip() for ch in chunk.split(\",\")]\n            if subchunks[-1] != '' and not subchunks[-1].endswith(';'):\n                raise NewickError(\n                    'Broken newick structure at: {}'.format(chunk))\n\n            # Every closing parenthesis will close a node and go up one level.\n            for idx, leaf in enumerate(subchunks):\n                if leaf.strip() == '' and idx == len(subchunks) - 1:\n                    continue\n                closing_nodes = leaf.split(\")\")\n\n                # parse features and apply to the node object\n                self.apply_node_data(closing_nodes[0], \"leaf\")\n\n                # next contain closing nodes and data about the internal nodes.\n                if len(closing_nodes) > 1:\n                    for closing_internal in closing_nodes[1:]:\n                        closing_internal = closing_internal.rstrip(\";\")\n                        # read internal node data and go up one level\n                        self.apply_node_data(closing_internal, \"internal\")\n                        self.current_parent = self.current_parent.up\n        return self.root"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate through data file to extract trees", "response": "def extract_tree_block(self):\n        \"iterate through data file to extract trees\"        \n\n        lines = iter(self.data)\n        while 1:\n            try:\n                line = next(lines).strip()\n            except StopIteration:\n                break\n    \n            # enter trees block\n            if line.lower() == \"begin trees;\":\n                while 1:\n                    # iter through trees block\n                    sub = next(lines).strip().split()\n                    \n                    # skip if a blank line\n                    if not sub:\n                        continue\n\n                    # look for translation\n                    if sub[0].lower() == \"translate\":\n                        while sub[0] != \";\":\n                            sub = next(lines).strip().split()\n                            self.tdict[sub[0]] = sub[-1].strip(\",\")\n\n                    # parse tree blocks\n                    if sub[0].lower().startswith(\"tree\"):\n                        self.newicks.append(sub[-1])\n        \n                    # end of trees block\n                    if sub[0].lower() == \"end;\":\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses command - line arguments and return a list of tuples.", "response": "def parse_command_line():\n    \"\"\" Parse CLI args.\"\"\"\n\n    ## create the parser\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\n  * Example command-line usage: \n\n  ## push test branch to conda --label=conda-test for travis CI\n  ./versioner.py -p toytree -b test -t 0.1.7 \n\n  ## push master as a new tag to git and conda\n  ./versioner.py -p toytree -b master -t 0.1.7 --deploy\n\n  ## build other deps on conda at --label=conda-test\n  ./versioner.py -p toyplot --no-git\n  ./versioner.py -p pypng --no-git\n\n    \"\"\")\n\n    ## add arguments \n    parser.add_argument('-v', '--version', action='version', \n        version=\"0.1\")\n\n    parser.add_argument('-p', #\"--package\", \n        dest=\"package\", \n        default=\"toytree\",\n        type=str, \n        help=\"the tag to put in __init__ and use on conda\")\n\n    parser.add_argument('-b', #\"--branch\", \n        dest=\"branch\", \n        default=\"master\",\n        type=str,\n        help=\"the branch to build conda package from\")\n\n    parser.add_argument('-t', #\"--tag\", \n        dest=\"tag\", \n        default=\"test\",\n        type=str, \n        help=\"the tag to put in __init__ and use on conda\")\n\n    parser.add_argument(\"--deploy\", \n        dest=\"deploy\",\n        action='store_true',\n        help=\"push the tag to git and upload to conda main label\")\n\n    parser.add_argument(\"--no-git\", \n        dest=\"nogit\",\n        action='store_true',\n        help=\"skip git update and only build/upload to conda\")\n\n\n    ## if no args then return help message\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n\n    ## parse args\n    args = parser.parse_args()\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget git and init versions and commits since the init version", "response": "def get_git_status(self):\n        \"\"\"\n        Gets git and init versions and commits since the init version\n        \"\"\"\n        ## get git branch\n        self._get_git_branch()\n\n        ## get tag in the init file\n        self._get_init_release_tag()\n\n        ## get log commits since <tag>\n        try:\n            self._get_log_commits()\n        except Exception as inst:\n            raise Exception(\n        \"\"\"\n        Error: the version in __init__.py is {}, so 'git log' is \n        looking for commits that have happened since that version, but\n        it appears there is not existing tag for that version. You may\n        need to roll back the version in __init__.py to what is actually\n        commited. Check with `git tag`.\n        --------\n        {}\n        \"\"\".format(self.init_version, inst))\n\n        ## where are we at?\n        print(\"__init__.__version__ == '{}':\".format(self.init_version))\n        print(\"'{}' is {} commits ahead of origin/{}\"\n              .format(self.tag, len(self.commits), self.init_version))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npushing git package to local files", "response": "def push_git_package(self):\n        \"\"\"\n        if no conflicts then write new tag to \n        \"\"\"\n        ## check for conflicts, then write to local files\n        self._pull_branch_from_origin()\n\n        ## log commits to releasenotes\n        if self.deploy:\n            self._write_commits_to_release_notes()\n\n        ## writes tag or 'devel' to \n        try:            \n            self._write_new_tag_to_init()\n            self._write_branch_and_tag_to_meta_yaml()\n            self._push_new_tag_to_git()\n\n        except Exception as inst:\n            print(\"\\n Error:\\n\", inst)\n            self._revert_tag_in_init()\n            sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _pull_branch_from_origin(self):\n        try:\n            ## self.repo.git.pull()\n            subprocess.check_call([\"git\", \"pull\", \"origin\", self.branch])\n        except Exception as inst:\n            sys.exit(\"\"\"\n        Your HEAD commit conflicts with origin/{tag}. \n        Resolve, merge, and rerun versioner.py\n        \"\"\")", "response": "Pulls branch from origin"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_init_release_tag(self):\n        self.init_version = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\",\n                                      open(self.init_file, \"r\").read(),\n                                      re.M).group(1)", "response": "Parses the init. py file to get the previous version"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_log_commits(self):\n        ## check if update is necessary\n        cmd = \"git log --pretty=oneline {}..\".format(self.init_version)\n        cmdlist = shlex.split(cmd)\n        commits = subprocess.check_output(cmdlist)\n        \n        ## Split off just the first element, we don't need commit tag\n        self.commits = [x.split(\" \", 1) for x in commits.split(\"\\n\")]", "response": "Get the commits from git log"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _write_commits_to_release_notes(self):\n        with open(self.release_file, 'a') as out:\n            out.write(\"==========\\n{}\\n\".format(self.tag))\n            for commit in self.commits:\n                try:\n                    msg = commit[1]\n                    if msg != \"cosmetic\":\n                        out.write(\"-\" + msg + \"\\n\")\n                except:\n                    pass", "response": "Writes commits to the releasenotes file by appending to the end\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites new version to __init__. py by editing in place", "response": "def _write_new_tag_to_init(self):\n        \"\"\"\n        Write version to __init__.py by editing in place\n        \"\"\"\n        for line in fileinput.input(self.init_file, inplace=1):\n            if line.strip().startswith(\"__version__\"):\n                line = \"__version__ = \\\"\" + self.tag + \"\\\"\"\n            print(line.strip(\"\\n\"))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _write_branch_and_tag_to_meta_yaml(self):\n        ## set the branch to pull source from\n        with open(self.meta_yaml.replace(\"meta\", \"template\"), 'r') as infile:\n            dat = infile.read()\n            newdat = dat.format(**{'tag': self.tag, 'branch': self.branch})\n\n        with open(self.meta_yaml, 'w') as outfile:\n            outfile.write(newdat)", "response": "Write branch and tag to meta. yaml by editing in place\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _revert_tag_in_init(self):\n        for line in fileinput.input(self.init_file, inplace=1):\n            if line.strip().startswith(\"__version__\"):\n                line = \"__version__ = \\\"\" + self.init_version + \"\\\"\"\n            print(line.strip(\"\\n\"))\n        \n        print(\"reverted __init__.__version__ back to {}\"\n              .format(self.init_version))", "response": "Revert the version of the __init__. py file in place."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _push_new_tag_to_git(self):\n        print(\"Pushing new version to git\")            \n\n        ## stage the releasefile and initfileb\n        subprocess.call([\"git\", \"add\", self.release_file])\n        subprocess.call([\"git\", \"add\", self.init_file])\n        subprocess.call([\n            \"git\", \"commit\", \"-m\", \"Updating {}/__init__.py to version {}\"\\\n            .format(self.package, self.tag)])\n\n        ## push changes to origin <tracked branch>\n        subprocess.call([\"git\", \"push\", \"origin\", self.branch])\n\n        ## create a new tag for the version number on deploy\n        if self.deploy:\n            subprocess.call([\n                \"git\", \"tag\", \"-a\", self.tag,\n                \"-m\", \"Updating version to {}\".format(self.tag),\n                ])\n            subprocess.call([\"git\", \"push\", \"origin\"])", "response": "Push a new release file and init file to git"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the Linux build and use converter to build OSX copies", "response": "def build_conda_packages(self):\n        \"\"\"\n        Run the Linux build and use converter to build OSX\n        \"\"\"\n        ## check if update is necessary\n        #if self.nversion == self.pversion:\n        #    raise SystemExit(\"Exited: new version == existing version\")\n\n        ## tmp dir\n        bldir = \"./tmp-bld\"\n        if not os.path.exists(bldir):\n            os.makedirs(bldir)\n\n        ## iterate over builds\n        for pybuild in [\"2.7\", \"3\"]:\n\n            ## build and upload Linux to anaconda.org\n            build = api.build(\n                \"conda-recipe/{}\".format(self.package),\n                 python=pybuild)\n                \n            ## upload Linux build\n            if not self.deploy:\n                cmd = [\"anaconda\", \"upload\", build[0], \"--label\", \"test\", \"--force\"]\n            else:\n                cmd = [\"anaconda\", \"upload\", build[0]]\n            err = subprocess.Popen(cmd).communicate()\n\n            ## build OSX copies \n            api.convert(build[0], output_dir=bldir, platforms=[\"osx-64\"])\n            osxdir = os.path.join(bldir, \"osx-64\", os.path.basename(build[0]))\n            if not self.deploy:\n                cmd = [\"anaconda\", \"upload\", osxdir, \"--label\", \"test\", \"--force\"]\n            else:\n                cmd = [\"anaconda\", \"upload\", osxdir]\n            err = subprocess.Popen(cmd).communicate()\n\n        ## cleanup tmpdir\n        shutil.rmtree(bldir)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the number of rows included in a span in a node - level node - tree tree", "response": "def get_span_row_count(span):\n    \"\"\"\n    Gets the number of rows included in a span\n\n    Parameters\n    ----------\n    span : list of lists of int\n        The [row, column] pairs that make up the span\n\n    Returns\n    -------\n    rows : int\n        The number of rows included in the span\n\n    Example\n    -------\n    Consider this table::\n\n        +--------+-----+\n        | foo    | bar |\n        +--------+     |\n        | spam   |     |\n        +--------+     |\n        | goblet |     |\n        +--------+-----+\n\n    ::\n\n        >>> span = [[0, 1], [1, 1], [2, 1]]\n        >>> print(get_span_row_count(span))\n        3\n    \"\"\"\n    rows = 1\n    first_row = span[0][0]\n\n    for i in range(len(span)):\n        if span[i][0] > first_row:\n            rows += 1\n            first_row = span[i][0]\n\n    return rows"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asarray(x, dtype=None):\r\n    '''Convert ``x`` into a ``numpy.ndarray``.'''\r\n    iterable = scalarasiter(x)\r\n    if isinstance(iterable, ndarray):\r\n        return iterable\r\n    else:\r\n        if not hasattr(iterable, '__len__'):\r\n            iterable = list(iterable)\r\n        if dtype == object_type:\r\n            a = ndarray((len(iterable),), dtype=dtype)\r\n            for i,v in enumerate(iterable):\r\n                a[i] = v\r\n            return a\r\n        else:\r\n            return array(iterable, dtype=dtype)", "response": "Convert x into a numpy. ndarray."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ascolumn(x, dtype = None):\r\n    '''Convert ``x`` into a ``column``-type ``numpy.ndarray``.'''\r\n    x = asarray(x, dtype)\r\n    return x if len(x.shape) >= 2 else x.reshape(len(x),1)", "response": "Convert x into a column - type numpy. ndarray."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multis_2_mono(table):\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            table[row][column] = table[row][column].replace('\\n', ' ')\n\n    return table", "response": "Converts each multiline string in a table to single line."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_html_row_count(spans):\n\n    if spans == []:\n        return 0\n    row_counts = {}\n    for span in spans:\n        span = sorted(span)\n        try:\n            row_counts[str(span[0][1])] += get_span_row_count(span)\n        except KeyError:\n            row_counts[str(span[0][1])] = get_span_row_count(span)\n\n    values = list(row_counts.values())\n    return max(values)", "response": "Get the number of rows in a list of spans"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef levenshtein_distance(word1, word2):\n    if len(word1) < len(word2):\n        return levenshtein_distance(word2, word1)\n\n    if len(word2) == 0:\n        return len(word1)\n\n    previous_row = list(range(len(word2) + 1))\n\n    for i, char1 in enumerate(word1):\n        current_row = [i + 1]\n\n        for j, char2 in enumerate(word2):\n            insertions = previous_row[j + 1] + 1\n            deletions = current_row[j] + 1\n            substitutions = previous_row[j] + (char1 != char2)\n\n            current_row.append(min(insertions, deletions, substitutions))\n\n        previous_row = current_row\n    return previous_row[-1]", "response": "Computes the Levenshtein distance between two words."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrolls Z - Score statistics.", "response": "def zscore(ts, **kwargs):\r\n    '''Rolling Z-Score statistics.\r\n    The Z-score is more formally known as ``standardised residuals``.\r\n    To calculate the standardised residuals of a data set,\r\n    the average value and the standard deviation of the data value\r\n    have to be estimated.\r\n\r\n    .. math::\r\n\r\n        z = \\frac{x - \\mu(x)}{\\sigma(x)}\r\n    '''\r\n    m = ts.rollmean(**kwargs)\r\n    s = ts.rollstddev(**kwargs)\r\n    result = (ts - m)/s\r\n    name = kwargs.get('name', None)\r\n    if name:\r\n        result.name = name\r\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prange(ts, **kwargs):\r\n    '''Rolling Percentage range.\r\n\r\n    Value between 0 and 1 indicating the position in the rolling range.\r\n    '''\r\n    mi = ts.rollmin(**kwargs)\r\n    ma = ts.rollmax(**kwargs)\r\n    return (ts - mi)/(ma - mi)", "response": "Returns the rolling percentage of the sequence in a given time series."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncombines the values from two map objects using the indx values using the op operator.", "response": "def binOp(op, indx, amap, bmap, fill_vec):\r\n    '''\r\n    Combines the values from two map objects using the indx values\r\n    using the op operator. In situations where there is a missing value\r\n    it will use the callable function handle_missing\r\n    '''\r\n    def op_or_missing(id):\r\n        va = amap.get(id, None)\r\n        vb = bmap.get(id, None)\r\n        if va is None or vb is None:\r\n            # This should create as many elements as the number of columns!?\r\n            result = fill_vec\r\n        else:\r\n            try:\r\n                result = op(va, vb)\r\n            except Exception:\r\n                result = None\r\n            if result is None:\r\n                result = fill_vec\r\n            return result\r\n    seq_arys = map(op_or_missing, indx)\r\n    data = np.vstack(seq_arys)\r\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _toVec(shape, val):\r\n    '''\r\n    takes a single value and creates a vecotor / matrix with that value filled\r\n    in it\r\n    '''\r\n    mat = np.empty(shape)\r\n    mat.fill(val)\r\n    return mat", "response": "Returns a vecotor matrix filled with a single value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncenter a line within a given allowed character width.", "response": "def center_line(space, line):\n    \"\"\"\n    Add leading & trailing space to text to center it within an allowed\n    width\n\n    Parameters\n    ----------\n    space : int\n        The maximum character width allowed for the text. If the length\n        of text is more than this value, no space will be added.\\\n    line : str\n        The text that will be centered.\n\n    Returns\n    -------\n    line : str\n        The text with the leading space added to it\n    \"\"\"\n    line = line.strip()\n\n    left_length = math.floor((space - len(line)) / 2)\n    right_length = math.ceil((space - len(line)) / 2)\n\n    left_space = \" \" * int(left_length)\n    right_space = \" \" * int(right_length)\n\n    line = ''.join([left_space, line, right_space])\n\n    return line"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self, function):\r\n        function = inspect.isclass(function) and function() or function\r\n        name = function.name\r\n        self[name] = function", "response": "Register a function in the registry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unregister(self, name):\r\n        try:\r\n            name = name.name\r\n        except AttributeError:\r\n            pass\r\n        return self.pop(name,None)", "response": "Unregister function by name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef row_includes_spans(table, row, spans):\n    for column in range(len(table[row])):\n        for span in spans:\n            if [row, column] in span:\n                return True\n    return False", "response": "Determines if a row includes spans within a row."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _setup_states(state_definitions, prev=()):\n    states = list(prev)\n    for state_def in state_definitions:\n        if len(state_def) != 2:\n            raise TypeError(\n                \"The 'state' attribute of a workflow should be \"\n                \"a two-tuple of strings; got %r instead.\" % (state_def,)\n            )\n        name, title = state_def\n        state = State(name, title)\n        if any(st.name == name for st in states):\n            # Replacing an existing state\n            states = [state if st.name == name else st for st in states]\n        else:\n            states.append(state)\n    return StateList(states)", "response": "Create a StateList object from a states workflow attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a TransitionList object from a transitions workflow attribute.", "response": "def _setup_transitions(tdef, states, prev=()):\n    \"\"\"Create a TransitionList object from a 'transitions' Workflow attribute.\n\n    Args:\n        tdef: list of transition definitions\n        states (StateList): already parsed state definitions.\n        prev (TransitionList): transition definitions from a parent.\n\n    Returns:\n        TransitionList: the list of transitions defined in the 'tdef' argument.\n    \"\"\"\n    trs = list(prev)\n    for transition in tdef:\n        if len(transition) == 3:\n            (name, source, target) = transition\n            if is_string(source) or isinstance(source, State):\n                source = [source]\n            source = [states[src] for src in source]\n            target = states[target]\n            tr = Transition(name, source, target)\n        else:\n            raise TypeError(\n                \"Elements of the 'transition' attribute of a \"\n                \"workflow should be three-tuples; got %r instead.\" % (transition,)\n            )\n\n        if any(prev_tr.name == tr.name for prev_tr in trs):\n            # Replacing an existing state\n            trs = [tr if prev_tr.name == tr.name else prev_tr for prev_tr in trs]\n        else:\n            trs.append(tr)\n    return TransitionList(trs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transition(trname='', field='', check=None, before=None, after=None):\n    if is_callable(trname):\n        raise ValueError(\n            \"The @transition decorator should be called as \"\n            \"@transition(['transition_name'], **kwargs)\")\n    if check or before or after:\n        warnings.warn(\n            \"The use of check=, before= and after= in @transition decorators is \"\n            \"deprecated in favor of @transition_check, @before_transition and \"\n            \"@after_transition decorators.\",\n            DeprecationWarning,\n            stacklevel=2)\n    return TransitionWrapper(trname, field=field, check=check, before=before, after=after)", "response": "Decorator to declare a function as a transition implementation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _make_hook_dict(fun):\n    if not hasattr(fun, 'xworkflows_hook'):\n        fun.xworkflows_hook = {\n            HOOK_BEFORE: [],\n            HOOK_AFTER: [],\n            HOOK_CHECK: [],\n            HOOK_ON_ENTER: [],\n            HOOK_ON_LEAVE: [],\n        }\n    return fun.xworkflows_hook", "response": "Ensure the given function has a xworkflows_hook attribute."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _match_state(self, state):\n        return (self.names == '*'\n                or state in self.names\n                or state.name in self.names)", "response": "Checks whether a given State matches self. names."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether a given Transition matches self. names.", "response": "def _match_transition(self, transition):\n        \"\"\"Checks whether a given Transition matches self.names.\"\"\"\n        return (self.names == '*'\n                or transition in self.names\n                or transition.name in self.names)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef applies_to(self, transition, from_state=None):\n        if '*' in self.names:\n            return True\n        elif self.kind in (HOOK_BEFORE, HOOK_AFTER, HOOK_CHECK):\n            return self._match_transition(transition)\n        elif self.kind == HOOK_ON_ENTER:\n            return self._match_state(transition.target)\n        elif from_state is None:\n            # Testing whether the hook may apply to at least one source of the\n            # transition\n            return any(self._match_state(src) for src in transition.source)\n        else:\n            return self._match_state(from_state)", "response": "Returns True if this hook applies to the given transition."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pre_transition_checks(self):\n        current_state = getattr(self.instance, self.field_name)\n        if current_state not in self.transition.source:\n            raise InvalidTransitionError(\n                \"Transition '%s' isn't available from state '%s'.\" %\n                (self.transition.name, current_state.name))\n\n        for check in self._filter_hooks(HOOK_CHECK):\n            if not check(self.instance):\n                raise ForbiddenTransition(\n                    \"Transition '%s' was forbidden by \"\n                    \"custom pre-transition check.\" % self.transition.name)", "response": "Run the pre - transition checks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _filter_hooks(self, *hook_kinds):\n        hooks = sum((self.hooks.get(kind, []) for kind in hook_kinds), [])\n        return sorted(hook for hook in hooks\n                      if hook.applies_to(self.transition, self.current_state))", "response": "Filter a list of hooks keeping only applicable ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _post_transition(self, result, *args, **kwargs):\n        for hook in self._filter_hooks(HOOK_AFTER, HOOK_ON_ENTER):\n            hook(self.instance, result, *args, **kwargs)", "response": "Performs post - transition actions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_parent_implems(self, parent_implems):\n        for trname, attr, implem in parent_implems.get_custom_implementations():\n            self.implementations[trname] = implem.copy()\n            self.transitions_at[trname] = attr\n            self.custom_implems.add(trname)", "response": "Import previously defined implementations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an implementation. Args: transition (Transition): the transition for which the implementation is added attribute (str): the name of the attribute where the implementation will be available function (callable): the actual implementation function **kwargs: extra arguments for the related ImplementationProperty.", "response": "def add_implem(self, transition, attribute, function, **kwargs):\n        \"\"\"Add an implementation.\n\n        Args:\n            transition (Transition): the transition for which the implementation\n                is added\n            attribute (str): the name of the attribute where the implementation\n                will be available\n            function (callable): the actual implementation function\n            **kwargs: extra arguments for the related ImplementationProperty.\n        \"\"\"\n        implem = ImplementationProperty(\n            field_name=self.state_field,\n            transition=transition,\n            workflow=self.workflow,\n            implementation=function,\n            **kwargs)\n        self.implementations[transition.name] = implem\n        self.transitions_at[transition.name] = attribute\n        return implem"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecide whether a given value should be collected.", "response": "def should_collect(self, value):\n        \"\"\"Decide whether a given value should be collected.\"\"\"\n        return (\n            # decorated with @transition\n            isinstance(value, TransitionWrapper)\n            # Relates to a compatible transition\n            and value.trname in self.workflow.transitions\n            # Either not bound to a state field or bound to the current one\n            and (not value.field or value.field == self.state_field))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncollecting the implementations from a given attributes dict.", "response": "def collect(self, attrs):\n        \"\"\"Collect the implementations from a given attributes dict.\"\"\"\n\n        for name, value in attrs.items():\n            if self.should_collect(value):\n                transition = self.workflow.transitions[value.trname]\n\n                if (\n                        value.trname in self.implementations\n                        and value.trname in self.custom_implems\n                        and name != self.transitions_at[value.trname]):\n                    # We already have an implementation registered.\n                    other_implem_at = self.transitions_at[value.trname]\n                    raise ValueError(\n                        \"Error for attribute %s: it defines implementation \"\n                        \"%s for transition %s, which is already implemented \"\n                        \"at %s.\" % (name, value, transition, other_implem_at))\n\n                implem = self.add_implem(transition, name, value.func)\n                self.custom_implems.add(transition.name)\n                if value.check:\n                    implem.add_hook(Hook(HOOK_CHECK, value.check))\n                if value.before:\n                    implem.add_hook(Hook(HOOK_BEFORE, value.before))\n                if value.after:\n                    implem.add_hook(Hook(HOOK_AFTER, value.after))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a list of custom implementation properties.", "response": "def get_custom_implementations(self):\n        \"\"\"Retrieve a list of cutom implementations.\n\n        Yields:\n            (str, str, ImplementationProperty) tuples: The name of the attribute\n                an implementation lives at, the name of the related transition,\n                and the related implementation.\n        \"\"\"\n        for trname in self.custom_implems:\n            attr = self.transitions_at[trname]\n            implem = self.implementations[trname]\n            yield (trname, attr, implem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks at an object method and registers it for relevent transitions.", "response": "def register_function_hooks(self, func):\n        \"\"\"Looks at an object method and registers it for relevent transitions.\"\"\"\n        for hook_kind, hooks in func.xworkflows_hook.items():\n            for field_name, hook in hooks:\n                if field_name and field_name != self.state_field:\n                    continue\n                for transition in self.workflow.transitions:\n                    if hook.applies_to(transition):\n                        implem = self.implementations[transition.name]\n                        implem.add_hook(hook)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _may_override(self, implem, other):\n        if isinstance(other, ImplementationProperty):\n            # Overriding another custom implementation for the same transition\n            # and field\n            return (other.transition == implem.transition and other.field_name == self.state_field)\n\n        elif isinstance(other, TransitionWrapper):\n            # Overriding the definition that led to adding the current\n            # ImplementationProperty.\n            return (\n                other.trname == implem.transition.name\n                and (not other.field or other.field == self.state_field)\n                and other.func == implem.implementation)\n\n        return False", "response": "Checks whether an ImplementationProperty may override an attribute."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the attrs dict with generated ImplementationProperty.", "response": "def fill_attrs(self, attrs):\n        \"\"\"Update the 'attrs' dict with generated ImplementationProperty.\"\"\"\n        for trname, attrname in self.transitions_at.items():\n\n            implem = self.implementations[trname]\n\n            if attrname in attrs:\n                conflicting = attrs[attrname]\n                if not self._may_override(implem, conflicting):\n                    raise ValueError(\n                        \"Can't override transition implementation %s=%r with %r\" %\n                        (attrname, conflicting, implem))\n\n            attrs[attrname] = implem\n        return attrs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform all actions on a given attribute dict.", "response": "def transform(self, attrs):\n        \"\"\"Perform all actions on a given attribute dict.\"\"\"\n        self.collect(attrs)\n        self.add_missing_implementations()\n        self.fill_attrs(attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs a transition. Args: transition (Transition): the name of the performed transition from_state (State): the source state instance (object): the modified object Kwargs: Any passed when calling the transition", "response": "def log_transition(self, transition, from_state, instance, *args, **kwargs):\n        \"\"\"Log a transition.\n\n        Args:\n            transition (Transition): the name of the performed transition\n            from_state (State): the source state\n            instance (object): the modified object\n\n        Kwargs:\n            Any passed when calling the transition\n        \"\"\"\n        logger = logging.getLogger('xworkflows.transitions')\n        try:\n            instance_repr = u(repr(instance), 'ignore')\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            instance_repr = u(\"<bad repr>\")\n        logger.info(\n            u(\"%s performed transition %s.%s (%s -> %s)\"), instance_repr,\n            self.__class__.__name__, transition.name, from_state.name,\n            transition.target.name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattaching a workflow to the attribute list.", "response": "def _add_workflow(mcs, field_name, state_field, attrs):\n        \"\"\"Attach a workflow to the attribute list (create a StateProperty).\"\"\"\n        attrs[field_name] = StateProperty(state_field.workflow, field_name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _find_workflows(mcs, attrs):\n        workflows = {}\n        for attribute, value in attrs.items():\n            if isinstance(value, Workflow):\n                workflows[attribute] = StateField(value)\n        return workflows", "response": "Finds all occurrences of a workflow in the attributes definitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_transitions(mcs, field_name, workflow, attrs, implems=None):\n        new_implems = ImplementationList(field_name, workflow)\n        if implems:\n            new_implems.load_parent_implems(implems)\n        new_implems.transform(attrs)\n\n        return new_implems", "response": "Collect and enhance transition definitions to a workflow."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self):\n        \"Updates cartesian coordinates for drawing tree graph\"              \n        # get new shape and clear for attrs\n        self.edges = np.zeros((self.ttree.nnodes - 1, 2), dtype=int)\n        self.verts = np.zeros((self.ttree.nnodes, 2), dtype=float)\n        self.lines = []\n        self.coords = []\n\n        # fill with updates\n        self.update_idxs()             # get dimensions of tree\n        self.update_fixed_order()      # in case ntips changed\n        self.assign_vertices()         # get node locations\n        self.assign_coordinates()      # get edge locations\n        self.reorient_coordinates()", "response": "Updates cartesian coordinates for drawing tree graph"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_idxs(self):\n        \"set root idx highest, tip idxs lowest ordered as ladderized\"\n        # internal nodes: root is highest idx\n        idx = self.ttree.nnodes - 1\n        for node in self.ttree.treenode.traverse(\"levelorder\"):\n            if not node.is_leaf():\n                node.add_feature(\"idx\", idx)\n                if not node.name:\n                    node.name = str(idx)\n                idx -= 1\n\n        # external nodes: lowest numbers are for tips (0-N)\n        for node in self.ttree.treenode.get_leaves():\n            node.add_feature(\"idx\", idx)\n            if not node.name:\n                node.name = str(idx)\n            idx -= 1", "response": "set root idx highest tip idxs lowest ordered as ladderized"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_fixed_order(self):\n        \"after pruning fixed order needs update to match new nnodes/ntips.\"\n        # set tips order if fixing for multi-tree plotting (default None)\n        fixed_order = self.ttree._fixed_order\n        self.ttree_fixed_order = None\n        self.ttree_fixed_idx = list(range(self.ttree.ntips))\n\n        # check if fixed_order changed:\n        if fixed_order:\n            fixed_order = [\n                i for i in fixed_order if i in self.ttree.get_tip_labels()]\n            self.ttree._set_fixed_order(fixed_order)\n        else:\n            self.ttree._fixed_idx = list(range(self.ttree.ntips))", "response": "after pruning fixed order needs update to match new nnodes / nips."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassigns the vertices of the nodes to the tree.", "response": "def assign_vertices(self):\n        \"\"\"\n        Sets .edges, .verts for node positions. \n        X and Y positions here refer to base assumption that tree is right\n        facing, reorient_coordinates() will handle re-translating this.        \n        \"\"\"\n        # shortname \n        uselen = bool(self.ttree.style.use_edge_lengths)\n\n        # postorder: children then parents (nidxs from 0 up)\n        # store edge array for connecting child nodes to parent nodes\n        nidx = 0\n        for node in self.ttree.treenode.traverse(\"postorder\"):            \n            if not node.is_root():\n                self.edges[nidx, :] = [node.up.idx, node.idx]\n                nidx += 1\n\n        # store verts array with x,y positions of nodes (lengths of branches)\n        # we want tips to align at the right face (larger axis number)\n        _root = self.ttree.treenode.get_tree_root()\n        _treeheight = _root.get_distance(_root.get_farthest_leaf()[0])\n\n        # set node x, y\n        tidx = len(self.ttree) - 1\n        for node in self.ttree.treenode.traverse(\"postorder\"):\n\n            # Just leaves: x positions are evenly spread and ordered on axis\n            if node.is_leaf() and (not node.is_root()):\n                \n                # set y-positions (heights). Distance from root or zero\n                node.y = _treeheight - _root.get_distance(node)\n                if not uselen:\n                    node.y = 0.0\n                \n                # set x-positions (order of samples)\n                if self.ttree._fixed_order:\n                    node.x = self.ttree._fixed_order.index(node.name)# - tidx\n                else:\n                    node.x = tidx\n                    tidx -= 1\n                \n                # store the x,y vertex positions\n                self.verts[node.idx] = [node.x, node.y]\n\n            # All internal node positions are not evenly spread or ordered\n            else:\n                # height is either distance or nnodes from root\n                node.y = _treeheight - _root.get_distance(node)\n                if not uselen:\n                    node.y = max([i.y for i in node.children]) + 1\n\n                # x position is halfway between childrens x-positions\n                if node.children:\n                    nch = node.children\n                    node.x = sum(i.x for i in nch) / float(len(nch))\n                else:\n                    node.x = tidx\n\n                # store the x,y vertex positions                    \n                self.verts[node.idx] = [node.x, node.y]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a modified. verts array with new coordinates for nodes.", "response": "def reorient_coordinates(self):\n        \"\"\"\n        Returns a modified .verts array with new coordinates for nodes. \n        This does not need to modify .edges. The order of nodes, and therefore\n        of verts rows is still the same because it is still based on the tree\n        branching order (ladderized usually). \n        \"\"\"\n        # if tree is empty then bail out\n        if len(self.ttree) < 2:\n            return\n\n        # down is the default orientation\n        # down-facing tips align at y=0, first ladderized tip at x=0\n        if self.ttree.style.orient in ('down', 0):\n            pass\n\n        # right-facing tips align at x=0, last ladderized tip at y=0\n        elif self.ttree.style.orient in ('right', 3):\n\n            # verts swap x and ys and make xs 0 to negative\n            tmp = np.zeros(self.verts.shape)\n            tmp[:, 1] = self.verts[:, 0]\n            tmp[:, 0] = self.verts[:, 1] * -1\n            self.verts = tmp\n\n            # coords...\n            tmp = np.zeros(self.coords.shape)\n            tmp[:, 1] = self.coords[:, 0]\n            tmp[:, 0] = self.coords[:, 1] * -1\n            self.coords = tmp\n\n        elif self.ttree.style.orient in ('left', 1):\n            raise NotImplementedError(\"todo: left facing\")\n\n        else:\n            raise NotImplementedError(\"todo: up facing\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tsiterator(ts, dateconverter=None, desc=None,\n               clean=False, start_value=None, **kwargs):\n    '''An iterator of timeseries as tuples.'''\n    dateconverter = dateconverter or default_converter\n    yield ['Date'] + ts.names()\n    if clean == 'full':\n        for dt, value in full_clean(ts, dateconverter, desc, start_value):\n             yield (dt,) + tuple(value)\n    else:\n        if clean:\n            ts = ts.clean()\n        for dt, value in ts.items(desc=desc, start_value=start_value):\n            dt = dateconverter(dt)\n            yield (dt,) + tuple(value)", "response": "An iterator of timeseries as tuples."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_baselines(self):\n        if self.style.xbaseline:\n            if self.style.orient in (\"up\", \"down\"):\n                self.coords.coords[:, 0] += self.style.xbaseline\n                self.coords.verts[:, 0] += self.style.xbaseline                \n            else:\n                self.coords.coords[:, 1] += self.style.xbaseline\n                self.coords.verts[:, 1] += self.style.xbaseline", "response": "Modify coords to shift tree position for x y baseline arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding tip - labels to the axes.", "response": "def add_tip_labels_to_axes(self):\n        \"\"\"\n        Add text offset from tips of tree with correction for orientation, \n        and fixed_order which is usually used in multitree plotting.\n        \"\"\"\n        # get tip-coords and replace if using fixed_order\n        xpos = self.ttree.get_tip_coordinates('x')\n        ypos = self.ttree.get_tip_coordinates('y')\n\n        if self.style.orient in (\"up\", \"down\"):\n            if self.ttree._fixed_order:\n                xpos = list(range(self.ttree.ntips))\n                ypos = ypos[self.ttree._fixed_idx]\n            if self.style.tip_labels_align:\n                ypos = np.zeros(self.ttree.ntips)\n\n        if self.style.orient in (\"right\", \"left\"):\n            if self.ttree._fixed_order:\n                xpos = xpos[self.ttree._fixed_idx]\n                ypos = list(range(self.ttree.ntips))\n            if self.style.tip_labels_align:\n                xpos = np.zeros(self.ttree.ntips)\n\n        # pop fill from color dict if using color\n        tstyle = deepcopy(self.style.tip_labels_style)\n        if self.style.tip_labels_colors:\n            tstyle.pop(\"fill\")\n\n        # add tip names to coordinates calculated above\n        self.axes.text(\n            xpos, \n            ypos,\n            self.tip_labels,\n            angle=(0 if self.style.orient in (\"right\", \"left\") else -90),\n            style=tstyle,\n            color=self.style.tip_labels_colors,\n        )\n        \n        # get stroke-width for aligned tip-label lines (optional)\n        # copy stroke-width from the edge_style unless user set it\n        if not self.style.edge_align_style.get(\"stroke-width\"):\n            self.style.edge_align_style[\"stroke-width\"] = (\n                self.style.edge_style[\"stroke-width\"])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_tip_lines_to_axes(self):\n        \"add lines to connect tips to zero axis for tip_labels_align=True\"\n\n        # get tip-coords and align-coords from verts\n        xpos, ypos, aedges, averts = self.get_tip_label_coords() \n        if self.style.tip_labels_align:\n            self.axes.graph(\n                aedges,\n                vcoordinates=averts,\n                estyle=self.style.edge_align_style, \n                vlshow=False,\n                vsize=0,\n            )", "response": "add lines to connect tips to zero axis for tip_labels_align = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfits the tip labels for the current tree level.", "response": "def fit_tip_labels(self):\n        \"\"\"\n        Modifies display range to ensure tip labels fit. This is a bit hackish\n        still. The problem is that the 'extents' range of the rendered text\n        is totally correct. So we add a little buffer here. Should add for \n        user to be able to modify this if needed. If not using edge lengths\n        then need to use unit length for treeheight.\n        \"\"\"\n        # user entered values\n        #if self.style.axes.x_domain_max or self.style.axes.y_domain_min:\n        #    self.axes.x.domain.max = self.style.axes.x_domain_max\n        #    self.axes.y.domain.min = self.style.axes.y_domain_min            \n\n        # IF USE WANTS TO CHANGE IT THEN DO IT AFTER USING AXES\n        # or auto-fit (tree height)\n        #else:\n        if self.style.use_edge_lengths:\n            addon = self.ttree.treenode.height * .85\n        else:\n            addon = self.ttree.treenode.get_farthest_leaf(True)[1]\n\n        # modify display for orientations\n        if self.style.tip_labels:\n            if self.style.orient == \"right\":\n                self.axes.x.domain.max = addon\n            elif self.style.orient == \"down\":\n                self.axes.y.domain.min = -1 * addon"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassign node colors and style to the marker.", "response": "def assign_node_colors_and_style(self):\n        \"\"\"\n        Resolve conflict of 'node_color' and 'node_style['fill'] args which are\n        redundant. Default is node_style.fill unless user entered node_color.\n        To enter multiple colors user must use node_color not style fill. \n        Either way, we build a list of colors to pass to Drawing.node_colors \n        which is then written to the marker as a fill CSS attribute.\n        \"\"\"\n        # SET node_colors and POP node_style.fill\n        colors = self.style.node_colors\n        style = self.style.node_style\n        if colors is None:\n            if style[\"fill\"] in (None, \"none\"):\n                style.pop(\"fill\")\n            else:\n                if isinstance(style[\"fill\"], (list, tuple)):\n                    raise ToytreeError(\n                        \"Use node_color not node_style for multiple node colors\")\n                # check the color\n                color = style[\"fill\"]\n                if isinstance(color, (np.ndarray, np.void, list, tuple)):\n                    color = toyplot.color.to_css(color)\n                self.node_colors = [color] * self.ttree.nnodes\n\n        # otherwise parse node_color\n        else:\n            style.pop(\"fill\")\n            if isinstance(colors, str):\n                # check the color\n                color = colors\n                if isinstance(color, (np.ndarray, np.void, list, tuple)):\n                    color = toyplot.color.to_css(color)\n                self.node_colors = [color] * self.ttree.nnodes\n\n            elif isinstance(colors, (list, tuple)):\n                if len(colors) != len(self.node_colors):\n                    raise ToytreeError(\"node_colors arg is the wrong length\")\n                for cidx in range(len(self.node_colors)):\n                    color = colors[cidx]\n                    if isinstance(color, (np.ndarray, np.void, list, tuple)):\n                        color = toyplot.color.to_css(color)                   \n                    self.node_colors[cidx] = color\n\n        # use CSS none for stroke=None\n        if self.style.node_style[\"stroke\"] is None:\n            self.style.node_style.stroke = \"none\"\n\n        # apply node markers\n        markers = self.style.node_markers\n        if markers is None:\n            self.node_markers = [\"o\"] * self.ttree.nnodes\n        else:\n            if isinstance(markers, str):\n                self.node_markers = [markers] * self.ttree.nnodes\n            elif isinstance(markers, (list, tuple)):\n                for cidx in range(len(self.node_markers)):\n                    self.node_markers[cidx] = markers[cidx]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assign_node_labels_and_sizes(self):\n        \"assign features of nodes to be plotted based on user kwargs\"\n\n        # shorthand\n        nvals = self.ttree.get_node_values()\n\n        # False == Hide nodes and labels unless user entered size \n        if self.style.node_labels is False:\n            self.node_labels = [\"\" for i in nvals]           \n            if self.style.node_sizes is not None:\n                if isinstance(self.style.node_sizes, (list, tuple, np.ndarray)):\n                    assert len(self.node_sizes) == len(self.style.node_sizes)\n                    self.node_sizes = self.style.node_sizes\n\n                elif isinstance(self.style.node_sizes, (int, str)):\n                    self.node_sizes = (\n                        [int(self.style.node_sizes)] * len(nvals)\n                    )\n                self.node_labels = [\" \" if i else \"\" for i in self.node_sizes]\n                    \n                    \n        # True == Show nodes, label=idx, and show hover\n        elif self.style.node_labels is True:\n            # turn on node hover even if user did not set it explicit\n            self.style.node_hover = True\n\n            # get idx labels\n            self.node_labels = self.ttree.get_node_values('idx', 1, 1)\n\n            # use default node size as a list if not provided\n            if not self.style.node_sizes:\n                self.node_sizes = [18] * len(nvals)\n            else:\n                assert isinstance(self.style.node_sizes, (int, str))\n                self.node_sizes = (\n                    [int(self.style.node_sizes)] * len(nvals)\n                )\n\n        # User entered lists or other for node labels or sizes; check lengths.\n        else:\n            # make node labels into a list of values \n            if isinstance(self.style.node_labels, list):\n                assert len(self.style.node_labels) == len(nvals)\n                self.node_labels = self.style.node_labels\n\n            # check if user entered a feature else use entered val\n            elif isinstance(self.style.node_labels, str):\n                self.node_labels = [self.style.node_labels] * len(nvals)\n                if self.style.node_labels in self.ttree.features:\n                    self.node_labels = self.ttree.get_node_values(\n                        self.style.node_labels, 1, 0)\n\n            # default to idx at internals if nothing else\n            else:\n                self.node_labels = self.ttree.get_node_values(\"idx\", 1, 0)\n\n            # make node sizes as a list; set to zero if node label is \"\"\n            if isinstance(self.style.node_sizes, list):\n                assert len(self.style.node_sizes) == len(nvals)\n                self.node_sizes = self.style.node_sizes\n            elif isinstance(self.style.node_sizes, (str, int, float)):\n                self.node_sizes = [int(self.style.node_sizes)] * len(nvals)\n            else:\n                self.node_sizes = [18] * len(nvals)\n\n            # override node sizes to hide based on node labels\n            for nidx, node in enumerate(self.node_labels):\n                if self.node_labels[nidx] == \"\":\n                    self.node_sizes[nidx] = 0\n\n        # ensure string type\n        self.node_labels = [str(i) for i in self.node_labels]", "response": "assign features of nodes to be plotted based on user kwargs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassign tip labels based on user provided kwargs", "response": "def assign_tip_labels_and_colors(self):\n        \"assign tip labels based on user provided kwargs\"\n        # COLOR\n        # tip color overrides tipstyle.fill\n        if self.style.tip_labels_colors:\n            #if self.style.tip_labels_style.fill:\n            #    self.style.tip_labels_style.fill = None\n            if self.ttree._fixed_order:\n                if isinstance(self.style.tip_labels_colors, (list, np.ndarray)):                                     \n                    cols = np.array(self.style.tip_labels_colors)\n                    orde = cols[self.ttree._fixed_idx]\n                    self.style.tip_labels_colors = list(orde)\n\n        # LABELS\n        # False == hide tip labels\n        if self.style.tip_labels is False:\n            self.style.tip_labels_style[\"-toyplot-anchor-shift\"] = \"0px\"\n            self.tip_labels = [\"\" for i in self.ttree.get_tip_labels()]\n\n        # LABELS\n        # user entered something...\n        else:\n            # if user did not change label-offset then shift it here\n            if not self.style.tip_labels_style[\"-toyplot-anchor-shift\"]:\n                self.style.tip_labels_style[\"-toyplot-anchor-shift\"] = \"15px\"\n\n            # if user entered list in get_tip_labels order reverse it for plot\n            if isinstance(self.style.tip_labels, list):\n                self.tip_labels = self.style.tip_labels\n\n            # True assigns tip labels from tree\n            else:\n                if self.ttree._fixed_order:\n                    self.tip_labels = self.ttree._fixed_order\n                else:\n                    self.tip_labels = self.ttree.get_tip_labels()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign edge colors and widths to the node_color attribute.", "response": "def assign_edge_colors_and_widths(self):\n        \"\"\"\n        Resolve conflict of 'node_color' and 'node_style['fill'] args which are\n        redundant. Default is node_style.fill unless user entered node_color.\n        To enter multiple colors user must use node_color not style fill. \n        Either way, we build a list of colors to pass to Drawing.node_colors \n        which is then written to the marker as a fill CSS attribute.\n        \"\"\"\n        # node_color overrides fill. Tricky to catch cuz it can be many types.\n\n        # SET edge_widths and POP edge_style.stroke-width\n        if self.style.edge_widths is None:\n            if not self.style.edge_style[\"stroke-width\"]:\n                self.style.edge_style.pop(\"stroke-width\")\n                self.style.edge_style.pop(\"stroke\")\n                self.edge_widths = [None] * self.nedges\n            else:\n                if isinstance(self.style.edge_style[\"stroke-width\"], (list, tuple)):\n                    raise ToytreeError(\n                        \"Use edge_widths not edge_style for multiple edge widths\")\n                # check the color\n                width = self.style.edge_style[\"stroke-width\"]\n                self.style.edge_style.pop(\"stroke-width\")\n                self.edge_widths = [width] * self.nedges\n        else:\n            self.style.edge_style.pop(\"stroke-width\")            \n            if isinstance(self.style.edge_widths, (str, int)):\n                self.edge_widths = [int(self.style.edge_widths)] * self.nedges\n\n            elif isinstance(self.style.edge_widths, (list, tuple)):\n                if len(self.style.edge_widths) != self.nedges:\n                    raise ToytreeError(\"edge_widths arg is the wrong length\")\n                for cidx in range(self.nedges):\n                    self.edge_widths[cidx] = self.style.edge_widths[cidx]\n\n        # SET edge_colors and POP edge_style.stroke\n        if self.style.edge_colors is None:\n            if self.style.edge_style[\"stroke\"] is None:\n                self.style.edge_style.pop(\"stroke\")\n                self.edge_colors = [None] * self.nedges\n            else:\n                if isinstance(self.style.edge_style[\"stroke\"], (list, tuple)):\n                    raise ToytreeError(\n                        \"Use edge_colors not edge_style for multiple edge colors\")\n                # check the color\n                color = self.style.edge_style[\"stroke\"]\n                if isinstance(color, (np.ndarray, np.void, list, tuple)):\n                    color = toyplot.color.to_css(color)\n                self.style.edge_style.pop(\"stroke\")                    \n                self.edge_colors = [color] * self.nedges\n\n        # otherwise parse node_color\n        else:\n            self.style.edge_style.pop(\"stroke\")                                \n            if isinstance(self.style.edge_colors, (str, int)):\n                # check the color\n                color = self.style.edge_colors\n                if isinstance(color, (np.ndarray, np.void, list, tuple)):\n                    color = toyplot.color.to_css(color)\n                self.edge_colors = [color] * self.nedges\n\n            elif isinstance(self.style.edge_colors, (list, tuple)):\n                if len(self.style.edge_colors) != self.nedges:\n                    raise ToytreeError(\"edge_colors arg is the wrong length\")\n                for cidx in range(self.nedges):\n                    self.edge_colors[cidx] = self.style.edge_colors[cidx]\n\n        # do not allow empty edge_colors or widths\n        self.edge_colors = [i if i else \"#262626\" for i in self.edge_colors]\n        self.edge_widths = [i if i else 2 for i in self.edge_widths]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd nodes to the axes.", "response": "def add_nodes_to_axes(self):\n        \"\"\"\n        Creates a new marker for every node from idx indexes and lists of \n        node_values, node_colors, node_sizes, node_style, node_labels_style.\n        Pulls from node_color and adds to a copy of the style dict for each \n        node to create marker.\n\n        Node_colors has priority to overwrite node_style['fill']\n        \"\"\"\n        # bail out if not any visible nodes (e.g., none w/ size>0)\n        if all([i == \"\" for i in self.node_labels]):\n            return\n       \n        # build markers for each node.\n        marks = []\n        for nidx in self.ttree.get_node_values('idx', 1, 1):\n\n            # select node value from deconstructed lists\n            nlabel = self.node_labels[nidx]\n            nsize = self.node_sizes[nidx]\n            nmarker = self.node_markers[nidx]\n\n            # get styledict copies\n            nstyle = deepcopy(self.style.node_style)\n            nlstyle = deepcopy(self.style.node_labels_style)\n\n            # and mod style dict copies from deconstructed lists\n            nstyle[\"fill\"] = self.node_colors[nidx]\n\n            # create mark if text or node\n            if (nlabel or nsize):\n                mark = toyplot.marker.create(\n                    shape=nmarker, \n                    label=str(nlabel),\n                    size=nsize,\n                    mstyle=nstyle,\n                    lstyle=nlstyle,\n                )\n            else:\n                mark = \"\"\n\n            # store the nodes/marks\n            marks.append(mark)\n\n        # node_hover == True to show all features interactive\n        if self.style.node_hover is True:\n            title = self.get_hover()\n\n        elif isinstance(self.style.node_hover, list):\n            # todo: return advice if improperly formatted\n            title = self.style.node_hover\n\n        # if hover is false then no hover\n        else:\n            title = None\n\n        # add nodes\n        self.axes.scatterplot(\n            self.coords.verts[:, 0],\n            self.coords.verts[:, 1],\n            marker=marks,\n            title=title,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget starting position of tip labels text based on locations of the tree face direction and align options.", "response": "def get_tip_label_coords(self):\n        \"\"\"\n        Get starting position of tip labels text based on locations of the \n        leaf nodes on the tree and style offset and align options. Node\n        positions are found using the .verts attribute of coords and is \n        already oriented for the tree face direction. \n        \"\"\"\n        # number of tips\n        ns = self.ttree.ntips\n\n        # x-coordinate of tips assuming down-face\n        tip_xpos = self.coords.verts[:ns, 0]\n        tip_ypos = self.coords.verts[:ns, 1]\n        align_edges = None\n        align_verts = None\n\n        # handle orientations\n        if self.style.orient in (0, 'down'):\n            # align tips at zero\n            if self.style.tip_labels_align:\n                tip_yend = np.zeros(ns)\n                align_edges = np.array([\n                    (i + len(tip_ypos), i) for i in range(len(tip_ypos))\n                ])\n                align_verts = np.array(\n                    list(zip(tip_xpos, tip_ypos)) + \\\n                    list(zip(tip_xpos, tip_yend))\n                )\n                tip_ypos = tip_yend\n        else:\n            # tip labels align finds the zero axis for orientation...\n            if self.style.tip_labels_align:\n                tip_xend = np.zeros(ns)\n                align_edges = np.array([\n                    (i + len(tip_xpos), i) for i in range(len(tip_xpos))\n                ])\n                align_verts = np.array(\n                    list(zip(tip_xpos, tip_ypos)) + \\\n                    list(zip(tip_xend, tip_ypos))\n                )\n                tip_xpos = tip_xend\n        return tip_xpos, tip_ypos, align_edges, align_verts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate reasonable canvas height and width for tree given N tips", "response": "def get_dims_from_tree_size(self):\n        \"Calculate reasonable canvas height and width for tree given N tips\" \n        ntips = len(self.ttree)\n        if self.style.orient in (\"right\", \"left\"):\n            # height is long tip-wise dimension\n            if not self.style.height:\n                self.style.height = max(275, min(1000, 18 * ntips))\n            if not self.style.width:\n                self.style.width = max(350, min(500, 18 * ntips))\n        else:\n            # width is long tip-wise dimension\n            if not self.style.height:\n                self.style.height = max(275, min(500, 18 * ntips))\n            if not self.style.width:\n                self.style.width = max(350, min(1000, 18 * ntips))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the length longest line in a paragraph", "response": "def get_longest_line_length(text):\n    \"\"\"Get the length longest line in a paragraph\"\"\"\n    lines = text.split(\"\\n\")\n    length = 0\n\n    for i in range(len(lines)):\n        if len(lines[i]) > length:\n            length = len(lines[i])\n\n    return length"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isnumeric(obj):\r\n    '''\r\n    Return true if obj is a numeric value\r\n    '''\r\n    from decimal import Decimal\r\n    if type(obj) == Decimal:\r\n        return True\r\n    else:\r\n        try:\r\n            float(obj)\r\n        except:\r\n            return False\r\n        return True", "response": "Returns true if obj is a numeric value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting a number according to a given number of significant figures.", "response": "def significant_format(number, decimal_sep='.', thousand_sep=',', n=3):\r\n    \"\"\"Format a number according to a given number of significant figures.\r\n    \"\"\"\r\n    str_number = significant(number, n)\r\n\r\n    # sign\r\n    if float(number) < 0:\r\n        sign = '-'\r\n    else:\r\n        sign = ''\r\n\r\n    if str_number[0] == '-':\r\n        str_number = str_number[1:]\r\n    if '.' in str_number:\r\n        int_part, dec_part = str_number.split('.')\r\n    else:\r\n        int_part, dec_part = str_number, ''\r\n    if dec_part:\r\n        dec_part = decimal_sep + dec_part\r\n    if thousand_sep:\r\n        int_part_gd = ''\r\n        for cnt, digit in enumerate(int_part[::-1]):\r\n            if cnt and not cnt % 3:\r\n                int_part_gd += thousand_sep\r\n            int_part_gd += digit\r\n        int_part = int_part_gd[::-1]\r\n    return sign + int_part + dec_part"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts obj to ( unicode ) text string", "response": "def to_text_string(obj, encoding=None):\n    \"\"\"Convert `obj` to (unicode) text string\"\"\"\n    if PY2:\n        # Python 2\n        if encoding is None:\n            return unicode(obj)\n        else:\n            return unicode(obj, encoding)\n    else:\n        # Python 3\n        if encoding is None:\n            return str(obj)\n        elif isinstance(obj, str):\n            # In case this function is not used properly, this could happen\n            return obj\n        else:\n            return str(obj, encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef text_to_qcolor(text):\n    color = QColor()\n    if not is_string(text): # testing for QString (PyQt API#1)\n        text = str(text)\n    if not is_text_string(text):\n        return color\n    if text.startswith('#') and len(text)==7:\n        correct = '#0123456789abcdef'\n        for char in text:\n            if char.lower() not in correct:\n                return color\n    elif text not in list(QColor.colorNames()):\n        return color\n    color.setNamedColor(text)\n    return color", "response": "Create a QColor from a string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a tuple to a QFont object", "response": "def tuple_to_qfont(tup):\n    \"\"\"\n    Create a QFont from tuple:\n        (family [string], size [int], italic [bool], bold [bool])\n    \"\"\"\n    if not isinstance(tup, tuple) or len(tup) != 4 \\\n       or not is_text_string(tup[0]) \\\n       or not isinstance(tup[1], int) \\\n       or not isinstance(tup[2], bool) \\\n       or not isinstance(tup[3], bool):\n        return None\n    font = QFont()\n    family, size, italic, bold = tup\n    font.setFamily(family)\n    font.setPointSize(size)\n    font.setItalic(italic)\n    font.setBold(bold)\n    return font"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a form dialog and return a list of data structures", "response": "def fedit(data, title=\"\", comment=\"\", icon=None, parent=None, apply=None,\n          ok=True, cancel=True, result='list', outfile=None, type='form',\n          scrollbar=False, background_color=None, widget_color=None):\n    \"\"\"\n    Create form dialog and return result\n    (if Cancel button is pressed, return None)\n\n    :param tuple data: datalist, datagroup (see below)\n    :param str title: form title\n    :param str comment: header comment\n    :param QIcon icon: dialog box icon\n    :param QWidget parent: parent widget\n    :param str ok: customized ok button label\n    :param str cancel: customized cancel button label\n    :param tuple apply: (label, function) customized button label and callback\n    :param function apply: function taking two arguments (result, widgets)\n    :param str result: result serialization ('list', 'dict', 'OrderedDict',\n                                             'JSON' or 'XML')\n    :param str outfile: write result to the file outfile.[py|json|xml]\n    :param str type: layout type ('form' or 'questions')\n    :param bool scrollbar: vertical scrollbar\n    :param str background_color: color of the background\n    :param str widget_color: color of the widgets\n\n    :return: Serialized result (data type depends on `result` parameter)\n    \n    datalist: list/tuple of (field_name, field_value)\n    datagroup: list/tuple of (datalist *or* datagroup, title, comment)\n    \n    Tips:\n      * one field for each member of a datalist\n      * one tab for each member of a top-level datagroup\n      * one page (of a multipage widget, each page can be selected with a \n        combo box) for each member of a datagroup inside a datagroup\n       \n    Supported types for field_value:\n      - int, float, str, unicode, bool\n      - colors: in Qt-compatible text form, i.e. in hex format or name (red,...)\n                (automatically detected from a string)\n      - list/tuple:\n          * the first element will be the selected index (or value)\n          * the other elements can be couples (key, value) or only values\n    \"\"\"\n    # Create a QApplication instance if no instance currently exists\n    # (e.g. if the module is used directly from the interpreter)\n    test_travis = os.environ.get('TEST_CI_WIDGETS', None)\n    if test_travis is not None:\n        app = QApplication.instance()\n        if app is None:\n            app = QApplication([])\n        timer = QTimer(app)\n        timer.timeout.connect(app.quit)\n        timer.start(1000)\n    elif QApplication.startingUp():\n        _app = QApplication([])\n        translator_qt = QTranslator()\n        translator_qt.load('qt_' + QLocale.system().name(),\n                       QLibraryInfo.location(QLibraryInfo.TranslationsPath))\n        _app.installTranslator(translator_qt)\n\n    serial = ['list', 'dict', 'OrderedDict', 'JSON', 'XML']\n    if result not in serial:\n        print(\"Warning: '%s' not in %s, default to list\" %\n              (result, ', '.join(serial)), file=sys.stderr)\n        result = 'list'\n\n    layouts = ['form', 'questions']\n    if type not in layouts:\n        print(\"Warning: '%s' not in %s, default to form\" %\n              (type, ', '.join(layouts)), file=sys.stderr)\n        type = 'form'\n\n    dialog = FormDialog(data, title, comment, icon, parent, apply, ok, cancel,\n                        result, outfile, type, scrollbar, background_color,\n                        widget_color)\n    if dialog.exec_():\n        return dialog.get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the FormDialog instance", "response": "def get_dialog(self):\n        \"\"\"Return FormDialog instance\"\"\"\n        dialog = self.parent()\n        while not isinstance(dialog, QDialog):\n            dialog = dialog.parent()\n        return dialog"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges timeseries into a new : class:`~. TimeSeries instance.", "response": "def ts_merge(series):\r\n    '''Merge timeseries into a new :class:`~.TimeSeries` instance.\r\n\r\n    :parameter series: an iterable over :class:`~.TimeSeries`.\r\n    '''\r\n    series = iter(series)\r\n    ts = next(series)\r\n    return ts.merge(series)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the algorithm for the given operation and name.", "response": "def getalgo(self, operation, name):\r\n        '''Return the algorithm for *operation* named *name*'''\r\n        if operation not in self._algorithms:\r\n            raise NotAvailable('{0} not registered.'.format(operation))\r\n        oper = self._algorithms[operation]\r\n        try:\r\n            return oper[name]\r\n        except KeyError:\r\n            raise NotAvailable('{0} algorithm {1} not registered.'\r\n                               .format(operation, name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dates(self, desc=None):\r\n        '''Returns an iterable over ``datetime.date`` instances\r\nin the timeseries.'''\r\n        c = self.dateinverse\r\n        for key in self.keys(desc=desc):\r\n            yield c(key)", "response": "Returns an iterable over datetime. date instances\r\nin the timeseries."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef items(self, desc=None, start_value=None, shift_by=None):\r\n        '''Returns a python ``generator`` which can be used to iterate over\r\n        :func:`dynts.TimeSeries.dates` and :func:`dynts.TimeSeries.values`\r\n        returning a two dimensional\r\n        tuple ``(date,value)`` in each iteration.\r\n        Similar to the python dictionary items\r\n        function.\r\n\r\n        :parameter desc: if ``True`` the iteratioon starts from the more\r\n            recent data and proceeds backwards.\r\n        :parameter shift_by: optional parallel shift in values.\r\n        :parameter start_value: optional start value of timeseries.\r\n        '''\r\n        if self:\r\n            if shift_by is None and start_value is not None:\r\n                for cross in self.values():\r\n                    missings = 0\r\n                    if shift_by is None:\r\n                        shift_by = []\r\n                        for v in cross:\r\n                            shift_by.append(start_value - v)\r\n                            if v != v:\r\n                                missings += 1\r\n                    else:\r\n                        for j in range(len(shift_by)):\r\n                            s = shift_by[j]\r\n                            v = cross[j]\r\n                            if s != s:\r\n                                if v == v:\r\n                                    shift_by[j] = start_value - v\r\n                                else:\r\n                                    missings += 1\r\n                    if not missings:\r\n                        break\r\n            if shift_by:\r\n                for d, v in zip(self.dates(desc=desc), self.values(desc=desc)):\r\n                    yield d, v + shift_by\r\n            else:\r\n                for d, v in zip(self.dates(desc=desc), self.values(desc=desc)):\r\n                    yield d, v", "response": "Returns a generator which can be used to iterate over the items of the time series."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef named_series(self, ordering=None):\r\n        '''Generator of tuples with name and serie data.'''\r\n        series = self.series()\r\n        if ordering:\r\n            series = list(series)\r\n            todo = dict(((n, idx) for idx, n in enumerate(self.names())))\r\n            for name in ordering:\r\n                if name in todo:\r\n                    idx = todo.pop(name)\r\n                    yield name, series[idx]\r\n            for name in todo:\r\n                idx = todo[name]\r\n                yield name, series[idx]\r\n        else:\r\n            for name_serie in zip(self.names(), series):\r\n                yield name_serie", "response": "Generator of tuples with name and serie data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a clone of timeseries", "response": "def clone(self, date=None, data=None, name=None):\r\n        '''Create a clone of timeseries'''\r\n        name = name or self.name\r\n        data = data if data is not None else self.values()\r\n        ts = self.__class__(name)\r\n        ts._dtype = self._dtype\r\n        if date is None:\r\n            # dates not provided\r\n            ts.make(self.keys(), data, raw=True)\r\n        else:\r\n            ts.make(date, data)\r\n        return ts"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reduce(self, size, method='simple', **kwargs):\r\n        '''Trim :class:`Timeseries` to a new *size* using the algorithm\r\n*method*. If *size* is greater or equal than len(self) it does nothing.'''\r\n        if size >= len(self):\r\n            return self\r\n        return self.getalgo('reduce', method)(self, size, **kwargs)", "response": "Trim the time series to a new size using the algorithm\r\n * method*."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean(self, algorithm=None):\r\n        '''Create a new :class:`TimeSeries` with missing data removed or\r\nreplaced by the *algorithm* provided'''\r\n        # all dates\r\n        original_dates = list(self.dates())\r\n        series = []\r\n        all_dates = set()\r\n        for serie in self.series():\r\n            dstart, dend, vend = None, None, None\r\n            new_dates = []\r\n            new_values = []\r\n            missings = []\r\n            values = {}\r\n            for d, v in zip(original_dates, serie):\r\n                if v == v:\r\n                    if dstart is None:\r\n                        dstart = d\r\n                    if missings:\r\n                        for dx, vx in algorithm(dend, vend, d, v, missings):\r\n                            new_dates.append(dx)\r\n                            new_values.append(vx)\r\n                        missings = []\r\n                    dend = d\r\n                    vend = v\r\n                    values[d] = v\r\n                elif dstart is not None and algorithm:\r\n                    missings.append((dt, v))\r\n            if missings:\r\n                for dx, vx in algorithm(dend, vend, None, None, missings):\r\n                    new_dates.append(dx)\r\n                    new_values.append(vx)\r\n                    dend = dx\r\n            series.append((dstart, dend, values))\r\n            all_dates = all_dates.union(values)\r\n        cdate = []\r\n        cdata = []\r\n        for dt in sorted(all_dates):\r\n            cross = []\r\n            for start, end, values in series:\r\n                if start is None or (dt >= start and dt <= end):\r\n                    value = values.get(dt)\r\n                    if value is None:\r\n                        cross = None\r\n                        break\r\n                else:\r\n                    value = nan\r\n                cross.append(value)\r\n            if cross:\r\n                cdate.append(dt)\r\n                cdata.append(cross)\r\n        return self.clone(date=cdate, data=cdata)", "response": "Create a new : class:`TimeSeries` with missing data removed or replaced by the algorithm provided."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the timeseries is consistent", "response": "def isconsistent(self):\r\n        '''Check if the timeseries is consistent'''\r\n        for dt1, dt0 in laggeddates(self):\r\n            if dt1 <= dt0:\r\n                return False\r\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate variance of timeseries. Return a vector containing the variance of each series in the timeseries. Default 0.", "response": "def var(self, ddof=0):\r\n        '''Calculate variance of timeseries. Return a vector containing\r\nthe variances of each series in the timeseries.\r\n\r\n:parameter ddof: delta degree of freedom, the divisor used in the calculation\r\n                 is given by ``N - ddof`` where ``N`` represents the length\r\n                 of timeseries. Default ``0``.\r\n\r\n.. math::\r\n\r\n    var = \\\\frac{\\\\sum_i^N (x - \\\\mu)^2}{N-ddof}\r\n    '''\r\n        N = len(self)\r\n        if N:\r\n            v = self.values()\r\n            mu = sum(v)\r\n            return (sum(v*v) - mu*mu/N)/(N-ddof)\r\n        else:\r\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sd(self):\r\n        '''Calculate standard deviation of timeseries'''\r\n        v = self.var()\r\n        if len(v):\r\n            return np.sqrt(v)\r\n        else:\r\n            return None", "response": "Calculate standard deviation of timeseries"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply function func to the timeseries.", "response": "def apply(self, func, window=None, bycolumn=True, align=None, **kwargs):\r\n        '''Apply function ``func`` to the timeseries.\r\n\r\n        :keyword func: string indicating function to apply\r\n        :keyword window: Rolling window, If not defined ``func`` is applied on\r\n            the whole dataset. Default ``None``.\r\n        :keyword bycolumn: If ``True``, function ``func`` is applied on\r\n            each column separately. Default ``True``.\r\n        :keyword align: string specifying whether the index of the result\r\n            should be ``left`` or ``right`` (default) or ``centered``\r\n            aligned compared to the rolling window of observations.\r\n        :keyword kwargs: dictionary of auxiliary parameters used by\r\n            function ``func``.\r\n        '''\r\n        N = len(self)\r\n        window = window or N\r\n        self.precondition(window <= N and window > 0, OutOfBound)\r\n        return self._rollapply(func,\r\n                               window=window,\r\n                               align=align or self.default_align,\r\n                               bycolumn=bycolumn,\r\n                               **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unwind(self, values, backend, **kwargs):\r\n        '''Unwind expression by applying *values* to the abstract nodes.\r\n\r\n        The ``kwargs`` dictionary can contain data which can be used\r\n        to override values\r\n        '''\r\n        if not hasattr(self, \"_unwind_value\"):\r\n            self._unwind_value = self._unwind(values, backend, **kwargs)\r\n        return self._unwind_value", "response": "Unwind expression by applying values * to the abstract nodes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nloop over children a remove duplicate entries. is a list of duplicate entries. Returns a list of removed entries.", "response": "def removeduplicates(self, entries = None):\r\n        '''\r\n        Loop over children a remove duplicate entries.\r\n        @return - a list of removed entries\r\n        '''\r\n        removed = []\r\n        if entries == None:\r\n            entries = {}\r\n        new_children = []\r\n        for c in self.children:\r\n            cs = str(c)\r\n            cp = entries.get(cs,None)\r\n            if cp:\r\n                new_children.append(cp)\r\n                removed.append(c)\r\n            else:\r\n                dups = c.removeduplicates(entries)\r\n                if dups:\r\n                    removed.extend(dups)\r\n                entries[cs] = c\r\n                new_children.append(c)\r\n        self.children = new_children\r\n        return removed"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a string or html file to a Markdown table string.", "response": "def html2md(html_string):\n    \"\"\"\n    Convert a string or html file to a markdown table string.\n\n    Parameters\n    ----------\n    html_string : str\n        Either the html string, or the filepath to the html\n\n    Returns\n    -------\n    str\n        The html table converted to a Markdown table\n\n    Notes\n    -----\n    This function requires BeautifulSoup_ to work.\n\n    Example\n    -------\n    >>> html_text = '''\n    ... <table>\n    ...     <tr>\n    ...         <th>\n    ...             Header 1\n    ...         </th>\n    ...         <th>\n    ...             Header 2\n    ...         </th>\n    ...         <th>\n    ...             Header 3\n    ...         </th>\n    ...     <tr>\n    ...         <td>\n    ...             <p>This is a paragraph</p>\n    ...         </td>\n    ...         <td>\n    ...             Just text\n    ...         </td>\n    ...         <td>\n    ...             Hot dog\n    ...         </td>\n    ...     </tr>\n    ... </table>\n    ... '''\n    >>> import dashtable\n    >>> print(dashtable.html2md(html_text))\n    |      Header 1       | Header 2  | Header 3 |\n    |---------------------|-----------|----------|\n    | This is a paragraph | Just text | Hot dog  |\n\n    .. _BeautifulSoup: https://www.crummy.com/software/BeautifulSoup/\n    \"\"\"\n\n    if os.path.isfile(html_string):\n        file = open(html_string, 'r', encoding='utf-8')\n        lines = file.readlines()\n        file.close()\n        html_string = ''.join(lines)\n\n    table_data, spans, use_headers = html2data(html_string)\n    if table_data == '':\n        return ''\n\n    return data2md(table_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef table_cells_2_spans(table, spans):\n    new_spans = []\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            span = get_span(spans, row, column)\n\n            if not span:\n                new_spans.append([[row, column]])\n\n    new_spans.extend(spans)\n    new_spans = list(sorted(new_spans))\n\n    return new_spans", "response": "Converts the table data to a list of spans for consistency."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_html_column_count(html_string):\n    try:\n        from bs4 import BeautifulSoup\n    except ImportError:\n        print(\"ERROR: You must have BeautifulSoup to use html2data\")\n        return\n\n    soup = BeautifulSoup(html_string, 'html.parser')\n    table = soup.find('table')\n    if not table:\n        return 0\n\n    column_counts = []\n    trs = table.findAll('tr')\n    if len(trs) == 0:\n        return 0\n\n    for tr in range(len(trs)):\n        if tr == 0:\n            tds = trs[tr].findAll('th')\n            if len(tds) == 0:\n                tds = trs[tr].findAll('td')\n        else:\n            tds = trs[tr].findAll('td')\n\n        count = 0\n        for td in tds:\n            if td.has_attr('colspan'):\n                count += int(td['colspan'])\n            else:\n                count += 1\n\n        column_counts.append(count)\n\n    return max(column_counts)", "response": "Returns the number of columns in an html table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding cushions to start and end of each string in a list of lists.", "response": "def add_cushions(table):\n    \"\"\"\n    Add space to start and end of each string in a list of lists\n\n    Parameters\n    ----------\n    table : list of lists of str\n        A table of rows of strings. For example::\n\n            [\n                ['dog', 'cat', 'bicycle'],\n                ['mouse', trumpet', '']\n            ]\n\n    Returns\n    -------\n    table : list of lists of str\n\n    Note\n    ----\n    Each cell in an rst grid table should to have a cushion of at least\n    one space on each side of the string it contains. For example::\n\n        +-----+-------+\n        | foo | bar   |\n        +-----+-------+\n        | cat | steve |\n        +-----+-------+\n\n    is better than::\n\n        +-----+---+\n        |foo| bar |\n        +-----+---+\n        |cat|steve|\n        +-----+---+\n    \"\"\"\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            lines = table[row][column].split(\"\\n\")\n\n            for i in range(len(lines)):\n                if not lines[i] == \"\":\n                    lines[i] = \" \" + lines[i].rstrip() + \" \"\n\n            table[row][column] = \"\\n\".join(lines)\n\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rollsingle(self, func, window=20, name=None, fallback=False,\n               align='right', **kwargs):\n    '''Efficient rolling window calculation for min, max type functions\n    '''\n    rname = 'roll_{0}'.format(func)\n    if fallback:\n        rfunc = getattr(lib.fallback, rname)\n    else:\n        rfunc = getattr(lib, rname, None)\n        if not rfunc:\n            rfunc = getattr(lib.fallback, rname)\n    data = np.array([list(rfunc(serie, window)) for serie in self.series()])\n    name = name or self.makename(func, window=window)\n    dates = asarray(self.dates())\n    desc = settings.desc\n    if (align == 'right' and not desc) or desc:\n        dates = dates[window-1:]\n    else:\n        dates = dates[:-window+1]\n    return self.clone(dates, data.transpose(), name=name)", "response": "Efficient rolling window calculation for min max type functions\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_ge(self, dt):\r\n        '''Building block of all searches. Find the index\r\ncorresponding to the leftmost value greater or equal to *dt*.\r\nIf *dt* is greater than the\r\n:func:`dynts.TimeSeries.end` a :class:`dynts.exceptions.RightOutOfBound`\r\nexception will raise.\r\n\r\n*dt* must be a python datetime.date instance.'''\r\n        i = bisect_left(self.dates, dt)\r\n        if i != len(self.dates):\r\n            return i\r\n        raise RightOutOfBound", "response": "Build a block of all searches. Find the index\r\ncorresponding to the leftmost value greater or equal to dt*. Raise RightOutOfBound if there are no more entries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the index corresponding to the rightmost value less than or equal to dt*.", "response": "def find_le(self, dt):\r\n        '''Find the index corresponding to the rightmost\r\nvalue less than or equal to *dt*.\r\nIf *dt* is less than :func:`dynts.TimeSeries.end`\r\na :class:`dynts.exceptions.LeftOutOfBound`\r\nexception will raise.\r\n\r\n*dt* must be a python datetime.date instance.'''\r\n        i = bisect_right(self.dates, dt)\r\n        if i:\r\n            return i-1\r\n        raise LeftOutOfBound"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_newick(newick, root_node=None, format=0):\n\n    ## check newick type as a string or filepath, Toytree parses urls to str's\n    if isinstance(newick, six.string_types):   \n        if os.path.exists(newick):\n            if newick.endswith('.gz'):\n                import gzip\n                nw = gzip.open(newick).read()\n            else:\n                nw = open(newick, 'rU').read()\n        else:\n            nw = newick\n\n        ## get re matcher for testing newick formats\n        matcher = compile_matchers(formatcode=format)\n        nw = nw.strip()        \n        if not nw.startswith('(') and nw.endswith(';'):\n            return _read_node_data(nw[:-1], root_node, \"single\", matcher, format)\n\n        elif not nw.startswith('(') or not nw.endswith(';'):\n            raise NewickError('Unexisting tree file or Malformed newick tree structure.')\n        else:\n            return _read_newick_from_string(nw, root_node, matcher, format)\n    else:\n        raise NewickError(\"'newick' argument must be either a filename or a newick string.\")", "response": "Reads a newick tree from either a string or a file and returns a TreeNode object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_newick_from_string(nw, root_node, matcher, formatcode):\n    if nw.count('(') != nw.count(')'):\n        raise NewickError('Parentheses do not match. Broken tree structure?')\n\n    # white spaces and separators are removed\n    nw = re.sub(\"[\\n\\r\\t]+\", \"\", nw)\n\n    current_parent = None\n    # Each chunk represents the content of a parent node, and it could contain\n    # leaves and closing parentheses.\n    # We may find:\n    # leaf, ..., leaf,\n    # leaf, ..., leaf))),\n    # leaf)), leaf, leaf))\n    # leaf))\n    # ) only if formatcode == 100\n\n    for chunk in nw.split(\"(\")[1:]:\n        # If no node has been created so far, this is the root, so use the node.\n        current_parent = root_node if current_parent is None else current_parent.add_child()\n\n        subchunks = [ch.strip() for ch in chunk.split(\",\")]\n        # We should expect that the chunk finished with a comma (if next chunk\n        # is an internal sister node) or a subchunk containing closing parenthesis until the end of the tree.\n        #[leaf, leaf, '']\n        #[leaf, leaf, ')))', leaf, leaf, '']\n        #[leaf, leaf, ')))', leaf, leaf, '']\n        #[leaf, leaf, ')))', leaf), leaf, 'leaf);']\n        if subchunks[-1] != '' and not subchunks[-1].endswith(';'):\n            raise NewickError('Broken newick structure at: %s' %chunk)\n\n        # lets process the subchunks. Every closing parenthesis will close a\n        # node and go up one level.\n        for i, leaf in enumerate(subchunks):\n            if leaf.strip() == '' and i == len(subchunks) - 1:\n                continue # \"blah blah ,( blah blah\"\n            closing_nodes = leaf.split(\")\")\n\n            # first part after splitting by ) always contain leaf info\n            _read_node_data(closing_nodes[0], current_parent, \"leaf\", matcher, formatcode)\n\n            # next contain closing nodes and data about the internal nodes.\n            if len(closing_nodes)>1:\n                for closing_internal in closing_nodes[1:]:\n                    closing_internal =  closing_internal.rstrip(\";\")\n                    # read internal node data and go up one level\n                    _read_node_data(closing_internal, current_parent, \"internal\", matcher, formatcode)\n                    current_parent = current_parent.up\n    return root_node", "response": "Reads a string in the New Hampshire format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_extra_features(node, NHX_string):\n    NHX_string = NHX_string.replace(\"[&&NHX:\", \"\")\n    NHX_string = NHX_string.replace(\"]\", \"\")\n    for field in NHX_string.split(\":\"):\n        try:\n            pname, pvalue = field.split(\"=\")\n        except ValueError as e:\n            raise NewickError('Invalid NHX format %s' %field)\n        node.add_feature(pname, pvalue)", "response": "Reads node s extra data form its NHX string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompiling the newick string against format types? and makes a re. compile", "response": "def compile_matchers(formatcode):\n    \"\"\"\n    Tests newick string against format types? and makes a re.compile\n    \"\"\"\n    matchers = {}\n    for node_type in [\"leaf\", \"single\", \"internal\"]:\n        if node_type == \"leaf\" or node_type == \"single\":\n            container1 = NW_FORMAT[formatcode][0][0]\n            container2 = NW_FORMAT[formatcode][1][0]\n            converterFn1 = NW_FORMAT[formatcode][0][1]\n            converterFn2 = NW_FORMAT[formatcode][1][1]\n            flexible1 = NW_FORMAT[formatcode][0][2]\n            flexible2 = NW_FORMAT[formatcode][1][2]\n        else:\n            container1 = NW_FORMAT[formatcode][2][0]\n            container2 = NW_FORMAT[formatcode][3][0]\n            converterFn1 = NW_FORMAT[formatcode][2][1]\n            converterFn2 = NW_FORMAT[formatcode][3][1]\n            flexible1 = NW_FORMAT[formatcode][2][2]\n            flexible2 = NW_FORMAT[formatcode][3][2]\n\n        if converterFn1 == str:\n            FIRST_MATCH = \"(\"+_NAME_RE+\")\"\n        elif converterFn1 == float:\n            FIRST_MATCH = \"(\"+_FLOAT_RE+\")\"\n        elif converterFn1 is None:\n            FIRST_MATCH = '()'\n\n        if converterFn2 == str:\n            SECOND_MATCH = \"(:\"+_NAME_RE+\")\"\n        elif converterFn2 == float:\n            SECOND_MATCH = \"(:\"+_FLOAT_RE+\")\"\n        elif converterFn2 is None:\n            SECOND_MATCH = '()'\n\n        if flexible1 and node_type != 'leaf':\n            FIRST_MATCH += \"?\"\n        if flexible2:\n            SECOND_MATCH += \"?\"\n\n        matcher_str= '^\\s*%s\\s*%s\\s*(%s)?\\s*$' % (FIRST_MATCH, SECOND_MATCH, _NHX_RE)\n        compiled_matcher = re.compile(matcher_str)\n        matchers[node_type] = [container1, container2, converterFn1, converterFn2, compiled_matcher]\n\n    return matchers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_node_data(subnw, current_node, node_type, matcher, formatcode):\n\n    if node_type == \"leaf\" or node_type == \"single\":\n        if node_type == \"leaf\":\n            node = current_node.add_child()\n        else:\n            node = current_node\n    else:\n        node = current_node\n\n    subnw = subnw.strip()\n    \n    if not subnw and node_type == 'leaf' and formatcode != 100:\n        raise NewickError('Empty leaf node found')\n    elif not subnw:\n        return\n\n    container1, container2, converterFn1, converterFn2, compiled_matcher = matcher[node_type]\n    data = re.match(compiled_matcher, subnw)\n    if data:\n        data = data.groups()\n        # This prevents ignoring errors even in flexible nodes:\n        if subnw and data[0] is None and data[1] is None and data[2] is None:\n            raise NewickError(\"Unexpected newick format '%s'\" %subnw)\n\n        if data[0] is not None and data[0] != '':\n            node.add_feature(container1, converterFn1(data[0].strip()))\n\n        if data[1] is not None and data[1] != '':\n            node.add_feature(container2, converterFn2(data[1][1:].strip()))\n\n        if data[2] is not None \\\n                and data[2].startswith(\"[&&NHX\"):\n            _parse_extra_features(node, data[2])\n    else:\n        raise NewickError(\"Unexpected newick format '%s' \" %subnw[0:50])\n    return", "response": "Reads a leaf node from a subpart of the original newicktree \n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a tree structure and returns its NHX representation.", "response": "def write_newick(rootnode, \n\tfeatures=None, \n\tformat=1, \n\tformat_root_node=True,\n    is_leaf_fn=None, \n    dist_formatter=None,\n    support_formatter=None,\n    name_formatter=None):\n    \"\"\" \n    Iteratively export a tree structure and returns its NHX\n    representation. \n    \"\"\"\n    newick = []\n    leaf = is_leaf_fn if is_leaf_fn else lambda n: not bool(n.children)\n    for postorder, node in rootnode.iter_prepostorder(is_leaf_fn=is_leaf_fn):\n        if postorder:\n            newick.append(\")\")\n            if node.up is not None or format_root_node:\n                newick.append(format_node(node, \"internal\", format,\n                                          dist_formatter=dist_formatter,\n                                          support_formatter=support_formatter,\n                                          name_formatter=name_formatter))\n                newick.append(_get_features_string(node, features))\n        else:\n            if node is not rootnode and node != node.up.children[0]:\n                newick.append(\",\")\n\n            if leaf(node):\n                safe_name = re.sub(\"[\"+_ILEGAL_NEWICK_CHARS+\"]\", \"_\", \\\n                               str(getattr(node, \"name\")))\n                newick.append(format_node(node, \"leaf\", format,\n                              dist_formatter=dist_formatter,\n                              support_formatter=support_formatter,\n                              name_formatter=name_formatter))\n                newick.append(_get_features_string(node, features))\n            else:\n                newick.append(\"(\")\n\n    newick.append(\";\")\n    return ''.join(newick)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_features_string(self, features=None):\n    string = \"\"\n    if features is None:\n        features = []\n    elif features == []:\n        features = self.features\n\n    for pr in features:\n        if hasattr(self, pr):\n            raw = getattr(self, pr)\n            if type(raw) in ITERABLE_TYPES:\n                raw = '|'.join([str(i) for i in raw])\n            elif type(raw) == dict:\n                raw = '|'.join(\n                    map(lambda x,y: \"%s-%s\" %(x, y), six.iteritems(raw)))\n            elif type(raw) == str:\n                pass\n            else:\n                raw = str(raw)\n\n            value = re.sub(\"[\"+_ILEGAL_NEWICK_CHARS+\"]\", \"_\", \\\n                             raw)\n            if string != \"\":\n                string +=\":\"\n            string +=\"%s=%s\"  %(pr, str(value))\n    if string != \"\":\n        string = \"[&&NHX:\"+string+\"]\"\n\n    return string", "response": "Generates the extended newick string NHX with extra data about a node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_column_width(column, table):\n    width = 3\n\n    for row in range(len(table)):\n        cell_width = len(table[row][column])\n        if cell_width > width:\n            width = cell_width\n\n    return width", "response": "Get the character width of a column in a table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a simple Text Mark object", "response": "def get_text_mark(ttree):\n    \"\"\" makes a simple Text Mark object\"\"\"\n    \n    if ttree._orient in [\"right\"]:\n        angle = 0.\n        ypos = ttree.verts[-1*len(ttree.tree):, 1]\n        if ttree._kwargs[\"tip_labels_align\"]:\n            xpos = [ttree.verts[:, 0].max()] * len(ttree.tree)\n            start = xpos\n            finish = ttree.verts[-1*len(ttree.tree):, 0]\n            align_edges = np.array([(i, i+len(xpos)) for i in range(len(xpos))])\n            align_verts = np.array(zip(start, ypos) + zip(finish, ypos))\n        else:\n            xpos = ttree.verts[-1*len(ttree.tree):, 0]\n            \n    elif ttree._orient in ['down']:\n        angle = -90.\n        xpos = ttree.verts[-1*len(ttree.tree):, 0]\n        if ttree._kwargs[\"tip_labels_align\"]:\n            ypos = [ttree.verts[:, 1].min()] * len(ttree.tree)\n            start = ypos\n            finish = ttree.verts[-1*len(ttree.tree):, 1]\n            align_edges = np.array([(i, i+len(ypos)) for i in range(len(ypos))])\n            align_verts = np.array(zip(xpos, start) + zip(xpos, finish))\n        else:\n            ypos = ttree.verts[-1*len(ttree.tree):, 1]\n    \n    table = toyplot.data.Table()\n    table['x'] = toyplot.require.scalar_vector(xpos)\n    table['y'] = toyplot.require.scalar_vector(ypos, table.shape[0])\n    table['text'] = toyplot.broadcast.pyobject(ttree.get_tip_labels(), table.shape[0])\n    table[\"angle\"] = toyplot.broadcast.scalar(angle, table.shape[0])\n    table[\"opacity\"] = toyplot.broadcast.scalar(1.0, table.shape[0])\n    table[\"title\"] = toyplot.broadcast.pyobject(None, table.shape[0])\n    style = toyplot.style.require(ttree._kwargs[\"tip_labels_style\"],\n                                  allowed=toyplot.style.allowed.text)\n    default_color = [toyplot.color.black]\n    color = toyplot.color.broadcast(\n        colors=ttree._kwargs[\"tip_labels_color\"],\n        shape=(table.shape[0], 1),\n        default=default_color,\n        )\n    table[\"fill\"] = color[:, 0]\n    \n    text_mark = toyplot.mark.Text(\n        coordinate_axes=['x', 'y'],\n        table=table,\n        coordinates=['x', 'y'],\n        text=[\"text\"],\n        angle=[\"angle\"],\n        fill=[\"fill\"],\n        opacity=[\"opacity\"],\n        title=[\"title\"],\n        style=style,\n        annotation=True,\n        filename=None\n        )\n    return text_mark"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_edge_mark(ttree):\n    \n    ## tree style\n    if ttree._kwargs[\"tree_style\"] in [\"c\", \"cladogram\"]:\n        a=ttree.edges\n        vcoordinates=ttree.verts\n    else:\n        a=ttree._lines               \n        vcoordinates=ttree._coords    \n   \n    ## fixed args\n    along='x'\n    vmarker='o'\n    vcolor=None\n    vlshow=False            \n    vsize=0.         \n    estyle=ttree._kwargs[\"edge_style\"]\n\n    ## get axes\n    layout = toyplot.layout.graph(a, vcoordinates=vcoordinates)\n    along = toyplot.require.value_in(along, [\"x\", \"y\"])\n    if along == \"x\":\n        coordinate_axes = [\"x\", \"y\"]\n    elif along == \"y\":\n        coordinate_axes = [\"y\", \"x\"]\n        \n    ## broadcast args along axes\n    vlabel = layout.vids\n    vmarker = toyplot.broadcast.pyobject(vmarker, layout.vcount)\n    vsize = toyplot.broadcast.scalar(vsize, layout.vcount)\n    estyle = toyplot.style.require(estyle, allowed=toyplot.style.allowed.line)\n\n    ## fixed args\n    vcolor = toyplot.color.broadcast(colors=None, shape=layout.vcount, default=toyplot.color.black)\n    vopacity = toyplot.broadcast.scalar(1.0, layout.vcount)\n    vtitle = toyplot.broadcast.pyobject(None, layout.vcount)\n    vstyle = None\n    vlstyle = None\n    \n    ## this could be modified in the future to allow diff color edges\n    ecolor = toyplot.color.broadcast(colors=None, shape=layout.ecount, default=toyplot.color.black)\n    ewidth = toyplot.broadcast.scalar(1.0, layout.ecount)\n    eopacity = toyplot.broadcast.scalar(1.0, layout.ecount)\n    hmarker = toyplot.broadcast.pyobject(None, layout.ecount)\n    mmarker = toyplot.broadcast.pyobject(None, layout.ecount)\n    mposition = toyplot.broadcast.scalar(0.5, layout.ecount)\n    tmarker = toyplot.broadcast.pyobject(None, layout.ecount)\n    \n    ## tables are required if I don't want to edit the class\n    vtable = toyplot.data.Table()\n    vtable[\"id\"] = layout.vids\n    for axis, coordinates in zip(coordinate_axes, layout.vcoordinates.T):\n        vtable[axis] = coordinates\n        #_mark_exportable(vtable, axis)\n    vtable[\"label\"] = vlabel\n    vtable[\"marker\"] = vmarker\n    vtable[\"size\"] = vsize\n    vtable[\"color\"] = vcolor\n    vtable[\"opacity\"] = vopacity\n    vtable[\"title\"] = vtitle\n\n    etable = toyplot.data.Table()\n    etable[\"source\"] = layout.edges.T[0]\n    #_mark_exportable(etable, \"source\")\n    etable[\"target\"] = layout.edges.T[1]\n    #_mark_exportable(etable, \"target\")\n    etable[\"shape\"] = layout.eshapes\n    etable[\"color\"] = ecolor\n    etable[\"width\"] = ewidth\n    etable[\"opacity\"] = eopacity\n    etable[\"hmarker\"] = hmarker\n    etable[\"mmarker\"] = mmarker\n    etable[\"mposition\"] = mposition\n    etable[\"tmarker\"] = tmarker\n    \n    edge_mark = toyplot.mark.Graph(\n        coordinate_axes=['x', 'y'],\n        ecolor=[\"color\"],\n        ecoordinates=layout.ecoordinates,\n        efilename=None,\n        eopacity=[\"opacity\"],\n        eshape=[\"shape\"],\n        esource=[\"source\"],\n        estyle=estyle,\n        etable=etable,\n        etarget=[\"target\"],\n        ewidth=[\"width\"],\n        hmarker=[\"hmarker\"],\n        mmarker=[\"mmarker\"],\n        mposition=[\"mposition\"],\n        tmarker=[\"tmarker\"],\n        vcolor=[\"color\"],\n        vcoordinates=['x', 'y'],\n        vfilename=None,\n        vid=[\"id\"],\n        vlabel=[\"label\"],\n        vlshow=False,\n        vlstyle=None,\n        vmarker=[\"marker\"],\n        vopacity=[\"opacity\"],\n        vsize=[\"size\"],\n        vstyle=None,\n        vtable=vtable,\n        vtitle=[\"title\"],\n        )\n    return edge_mark", "response": "returns a simple edge mark object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_styles(mark):\n    \n    markers = [mark._table[key] for key in mark._marker][0]\n    nstyles = []\n    for m in markers:\n        ## fill and stroke are already rgb() since already in markers\n        msty = toyplot.style.combine({\n            \"fill\": m.mstyle['fill'],\n            \"stroke\": m.mstyle['stroke'],\n            \"opacity\": m.mstyle[\"fill-opacity\"],\n        }, m.mstyle)\n        msty = _color_fixup(msty)\n        nstyles.append(msty)\n    \n    ## uses 'marker.size' so we need to loop over it\n    lstyles = []\n    for m in markers:\n        lsty = toyplot.style.combine({\n        \"font-family\": \"Helvetica\",\n        \"-toyplot-vertical-align\": \"middle\",\n        \"fill\": toyplot.color.black,\n        \"font-size\": \"%rpx\" % (m.size * 0.75),\n        \"stroke\": \"none\",\n        \"text-anchor\": \"middle\",\n        }, m.lstyle)\n        ## update fonts\n        fonts = toyplot.font.ReportlabLibrary()\n        layout = toyplot.text.layout(m.label, lsty, fonts)\n        lsty = _color_fixup(layout.style)\n        lstyles.append(lsty)\n    \n    nallkeys = set(itertools.chain(*[i.keys() for i in nstyles]))\n    lallkeys = set(itertools.chain(*[i.keys() for i in lstyles]))\n    nuniquekeys = []\n    nsharedkeys = []\n    for key in nallkeys:\n        vals = [nstyles[i].get(key) for i in range(len(nstyles))]\n        if len(set(vals)) > 1:\n            nuniquekeys.append(key)\n        else:\n            nsharedkeys.append(key)\n    luniquekeys = []\n    lsharedkeys = []\n    for key in lallkeys:\n        vals = [lstyles[i].get(key) for i in range(len(lstyles))]\n        if len(set(vals)) > 1:\n            luniquekeys.append(key)\n        else:\n            lsharedkeys.append(key)\n\n    ## keys shared between mark and text markers\n    repeated = set(lsharedkeys).intersection(set(nsharedkeys))\n    for repeat in repeated:\n        ## if same then keep only one copy of it\n        lidx = lsharedkeys.index(repeat)\n        nidx = nsharedkeys.index(repeat)\n        if lsharedkeys[lidx] == nsharedkeys[nidx]:\n            lsharedkeys.remove(repeat)\n        else:\n            lsharedkeys.remove(repeat)\n            luniquekeys.append(repeat)\n            nsharedkeys.remove(repeat)\n            nuniquekeys.append(repeat)\n            \n    ## check node values\n    natt = [\"%s:%s\" % (key, nstyles[0][key]) for key in sorted(nsharedkeys)]\n    latt = [\"%s:%s\" % (key, lstyles[0][key]) for key in sorted(lsharedkeys)]\n    shared_styles = \";\".join(natt+latt)\n    unique_styles = {\n        \"node\": [{k:v for k,v in nstyles[idx].items() if k in nuniquekeys} for idx in range(len(markers))],\n        \"text\": [{k:v for k,v in lstyles[idx].items() if k in luniquekeys} for idx in range(len(markers))]\n    }\n    \n    return shared_styles, unique_styles", "response": "split the styles of a single mark into two lists of unique and shared styles"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncenters the text within a cell s grid.", "response": "def center_cell_text(cell):\n    \"\"\"\n    Horizontally center the text within a cell's grid\n\n    Like this::\n\n        +---------+     +---------+\n        | foo     | --> |   foo   |\n        +---------+     +---------+\n\n    Parameters\n    ----------\n    cell : dashtable.data2rst.Cell\n\n    Returns\n    -------\n    cell : dashtable.data2rst.Cell\n    \"\"\"\n    lines = cell.text.split('\\n')\n    cell_width = len(lines[0]) - 2\n\n    truncated_lines = ['']\n    for i in range(1, len(lines) - 1):\n        truncated = lines[i][2:len(lines[i]) - 2].rstrip()\n        truncated_lines.append(truncated)\n\n    truncated_lines.append('')\n\n    max_line_length = get_longest_line_length('\\n'.join(truncated_lines))\n    remainder = cell_width - max_line_length\n\n    left_width = math.floor(remainder / 2)\n    left_space = left_width * ' '\n\n    for i in range(len(truncated_lines)):\n        truncated_lines[i] = left_space + truncated_lines[i]\n        right_width = cell_width - len(truncated_lines[i])\n        truncated_lines[i] += right_width * ' '\n\n    for i in range(1, len(lines) - 1):\n        lines[i] = ''.join([\n            lines[i][0], truncated_lines[i], lines[i][-1]\n        ])\n\n    cell.text = '\\n'.join(lines)\n\n    return cell"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the Hamming distance between two words.", "response": "def hamming_distance(word1, word2):\n    \"\"\"\n    Computes the Hamming distance.\n\n    [Reference]: https://en.wikipedia.org/wiki/Hamming_distance\n    [Article]: Hamming, Richard W. (1950), \"Error detecting and error correcting codes\",\n        Bell System Technical Journal 29 (2): 147\u2013160\n    \"\"\"\n    from operator import ne\n    if len(word1) != len(word2):\n        raise WrongLengthException('The words need to be of the same length!')\n\n    return sum(map(ne, word1, word2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef timeseries(name='', backend=None, date=None, data=None, **kwargs):\r\n    '''Create a new :class:`dynts.TimeSeries` instance using a ``backend``\r\n    and populating it with provided the data.\r\n\r\n    :parameter name: optional timeseries name. For multivarate timeseries\r\n                     the :func:`dynts.tsname` utility function can be used\r\n                     to build it.\r\n    :parameter backend: optional backend name.\r\n        If not provided, numpy will be used.\r\n    :parameter date: optional iterable over dates.\r\n    :parameter data: optional iterable over data.\r\n    '''\r\n    backend = backend or settings.backend\r\n    TS = BACKENDS.get(backend)\r\n    if not TS:\r\n        raise InvalidBackEnd(\r\n            'Could not find a TimeSeries class %s' % backend\r\n        )\r\n    return TS(name=name, date=date, data=data, **kwargs)", "response": "Create a new instance of a new TimeSeries with the given name and date and data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nforce each cell in the table to be a string", "response": "def ensure_table_strings(table):\n    \"\"\"\n    Force each cell in the table to be a string\n\n    Parameters\n    ----------\n    table : list of lists\n\n    Returns\n    -------\n    table : list of lists of str\n    \"\"\"\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            table[row][column] = str(table[row][column])\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the number of sections that touch the left side.", "response": "def left_sections(self):\n        \"\"\"\n        The number of sections that touch the left side.\n\n        During merging, the cell's text will grow to include other\n        cells. This property keeps track of the number of sections that\n        are touching the left side. For example::\n\n                        +-----+-----+\n            section --> | foo | dog | <-- section\n                        +-----+-----+\n            section --> | cat |\n                        +-----+\n\n        Has 2 sections on the left, but 1 on the right\n\n        Returns\n        -------\n        sections : int\n            The number of sections on the left\n        \"\"\"\n        lines = self.text.split('\\n')\n        sections = 0\n\n        for i in range(len(lines)):\n            if lines[i].startswith('+'):\n                sections += 1\n        sections -= 1\n\n        return sections"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the number of sections that touch the right side.", "response": "def right_sections(self):\n        \"\"\"\n        The number of sections that touch the right side.\n\n        Returns\n        -------\n        sections : int\n            The number of sections on the right\n        \"\"\"\n        lines = self.text.split('\\n')\n        sections = 0\n        for i in range(len(lines)):\n            if lines[i].endswith('+'):\n                sections += 1\n        return sections - 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef top_sections(self):\n\n        top_line = self.text.split('\\n')[0]\n        sections = len(top_line.split('+')) - 2\n\n        return sections", "response": "Returns the number of sections that touch the top side."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of sections on the bottom side of the text.", "response": "def bottom_sections(self):\n        \"\"\"\n        The number of cells that touch the bottom side.\n\n        Returns\n        -------\n        sections : int\n            The number of sections on the top\n        \"\"\"\n        bottom_line = self.text.split('\\n')[-1]\n        sections = len(bottom_line.split('+')) - 2\n\n        return sections"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_header(self):\n        bottom_line = self.text.split('\\n')[-1]\n\n        if is_only(bottom_line, ['+', '=']):\n            return True\n\n        return False", "response": "Returns True if the cell is a header cell False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a numeric identifier of the latest git changeset.", "response": "def get_git_changeset(filename=None):\r\n    \"\"\"Returns a numeric identifier of the latest git changeset.\r\n\r\n    The result is the UTC timestamp of the changeset in YYYYMMDDHHMMSS format.\r\n    This value isn't guaranteed to be unique, but collisions are very unlikely,\r\n    so it's sufficient for generating the development version numbers.\r\n    \"\"\"\r\n    dirname = os.path.dirname(filename or __file__)\r\n    git_show = sh('git show --pretty=format:%ct --quiet HEAD',\r\n                  cwd=dirname)\r\n    timestamp = git_show.partition('\\n')[0]\r\n    try:\r\n        timestamp = datetime.datetime.utcfromtimestamp(int(timestamp))\r\n    except ValueError:\r\n        return None\r\n    return timestamp.strftime('%Y%m%d%H%M%S')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the html table contains headers and returns True or False", "response": "def headers_present(html_string):\n    \"\"\"\n    Checks if the html table contains headers and returns True/False\n\n    Parameters\n    ----------\n    html_string : str\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    try:\n        from bs4 import BeautifulSoup\n    except ImportError:\n        print(\"ERROR: You must have BeautifulSoup to use html2data\")\n        return\n\n    soup = BeautifulSoup(html_string, 'html.parser')\n    table = soup.find('table')\n    if not table:\n        return False\n\n    th = table.findAll('th')\n    if len(th) > 0:\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_spans(html_string):\n    try:\n        from bs4 import BeautifulSoup\n    except ImportError:\n        print(\"ERROR: You must have BeautifulSoup to use html2data\")\n        return\n\n    soup = BeautifulSoup(html_string, 'html.parser')\n    table = soup.find('table')\n    if not table:\n        return []\n\n    trs = table.findAll('tr')\n    if len(trs) == 0:\n        return []\n\n    spans = []\n    for tr in range(len(trs)):\n        if tr == 0:\n            ths = trs[tr].findAll('th')\n            if len(ths) == 0:\n                ths = trs[tr].findAll('td')\n            tds = ths\n        else:\n            tds = trs[tr].findAll('td')\n\n        column = 0\n        for td in tds:\n            r_span_count = 1\n            c_span_count = 1\n            current_column = column\n\n            if td.has_attr('rowspan'):\n                r_span_count = int(td['rowspan'])\n            if td.has_attr('colspan'):\n                c_span_count = int(td['colspan'])\n                column += c_span_count\n            else:\n                column += 1\n\n            new_span = []\n            for r_index in range(tr, tr + r_span_count):\n                for c_index in range(current_column, column):\n                    if not get_span(spans, r_index, c_index):\n                        new_span.append([r_index, c_index])\n\n            if len(new_span) > 0:\n                spans.append(new_span)\n\n    return spans", "response": "Extracts the spanned cell groups of row and column pairs from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef translation(first, second):\n    if len(first) != len(second):\n        raise WrongLengthException('The lists are not of the same length!')\n    return dict(zip(first, second))", "response": "Create an index of mapped letters zip to dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlagging iterator over dates", "response": "def laggeddates(ts, step=1):\r\n    '''Lagged iterator over dates'''\r\n    if step == 1:\r\n        dates = ts.dates()\r\n        if not hasattr(dates, 'next'):\r\n            dates = dates.__iter__()\r\n        dt0 = next(dates)\r\n        for dt1 in dates:\r\n            yield dt1, dt0\r\n            dt0 = dt1\r\n    else:\r\n        while done:\r\n            done += 1\r\n            lag.append(next(dates))\r\n        for dt1 in dates:\r\n            lag.append(dt1)\r\n            yield dt1, lag.pop(0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_skiplist(*args, use_fallback=False):\n    '''Create a new skiplist'''\n    sl = fallback.Skiplist if use_fallback else Skiplist\n    return sl(*args)", "response": "Create a new skiplist"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef data2md(table):\n\n    table = copy.deepcopy(table)\n\n    table = ensure_table_strings(table)\n    table = multis_2_mono(table)\n    table = add_cushions(table)\n\n    widths = []\n    for column in range(len(table[0])):\n        widths.append(get_column_width(column, table))\n\n    output = '|'\n    for i in range(len(table[0])):\n        output = ''.join(\n            [output, center_line(widths[i], table[0][i]), '|'])\n\n    output = output + '\\n|'\n    for i in range(len(table[0])):\n        output = ''.join([\n            output, center_line(widths[i], \"-\" * widths[i]), '|'])\n    output = output + '\\n|'\n\n    for row in range(1, len(table)):\n        for column in range(len(table[row])):\n            output = ''.join(\n                [output, center_line(widths[column],\n                 table[row][column]), '|'])\n        output = output + '\\n|'\n\n    split = output.split('\\n')\n    split.pop()\n\n    table_string = '\\n'.join(split)\n\n    return table_string", "response": "Converts a list of strings to a markdown table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data2rst(table, spans=[[[0, 0]]], use_headers=True,\n             center_cells=False, center_headers=False):\n    \"\"\"\n    Convert a list of lists of str into a reStructuredText Grid Table\n\n    Parameters\n    ----------\n    table : list of lists of str\n    spans : list of lists of lists of int, optional\n        These are [row, column] pairs of cells that are merged in the\n        table. Rows and columns start in the top left of the table.For\n        example::\n\n            +--------+--------+\n            | [0, 0] | [0, 1] |\n            +--------+--------+\n            | [1, 0] | [1, 1] |\n            +--------+--------+\n\n    use_headers : bool, optional\n        Whether or not the first row of table data will become headers.\n    center_cells : bool, optional\n        Whether or not cells will be centered\n    center_headers: bool, optional\n        Whether or not headers will be centered\n\n    Returns\n    -------\n    str\n        The grid table string\n\n    Example\n    -------\n    >>> spans = [\n    ...     [ [3, 1], [4, 1] ],\n    ...     [ [3, 2], [4, 2] ],\n    ...     [ [2, 1], [2, 2] ],\n    ... ]\n    >>> table = [\n    ...     [\"Header 1\", \"Header 2\", \"Header 3\"],\n    ...     [\"body row 1\", \"column 2\", \"column 3\"],\n    ...     [\"body row 2\", \"Cells may span columns\", \"\"],\n    ...     [\"body row 3\", \"Cells may span rows.\", \"- Cells\\\\n-contain\\\\n-blocks\"],\n    ...     [\"body row 4\", \"\", \"\"],\n    ... ]\n    >>> print(dashtable.data2rst(table, spans))\n    +------------+------------+-----------+\n    | Header 1   | Header 2   | Header 3  |\n    +============+============+===========+\n    | body row 1 | column 2   | column 3  |\n    +------------+------------+-----------+\n    | body row 2 | Cells may span columns.|\n    +------------+------------+-----------+\n    | body row 3 | Cells may  | - Cells   |\n    +------------+ span rows. | - contain |\n    | body row 4 |            | - blocks. |\n    +------------+------------+-----------+\n    \"\"\"\n\n    table = copy.deepcopy(table)\n\n    table_ok = check_table(table)\n    if not table_ok == \"\":\n        return \"ERROR: \" + table_ok\n\n    if not spans == [[[0, 0]]]:\n        for span in spans:\n            span_ok = check_span(span, table)\n            if not span_ok == \"\":\n                return \"ERROR: \" + span_ok\n\n    table = ensure_table_strings(table)\n    table = add_cushions(table)\n\n    spans = table_cells_2_spans(table, spans)\n\n    widths = get_output_column_widths(table, spans)\n    heights = get_output_row_heights(table, spans)\n\n    cells = []\n    for span in spans:\n        cell = make_cell(table, span, widths, heights, use_headers)\n        cells.append(cell)\n\n    cells = list(sorted(cells))\n\n    if center_cells:\n        for cell in cells:\n            if not cell.is_header:\n                center_cell_text(cell)\n                v_center_cell_text(cell)\n\n    if center_headers:\n        for cell in cells:\n            if cell.is_header:\n                center_cell_text(cell)\n                v_center_cell_text(cell)\n\n    grid_table = merge_all_cells(cells)\n\n    return grid_table", "response": "Convert a list of lists of str into a reStructuredText Grid Table"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate reasonable height and width for tree given N tips", "response": "def set_dims_from_tree_size(self):\n        \"Calculate reasonable height and width for tree given N tips\"\n        tlen = len(self.treelist[0])\n        if self.style.orient in (\"right\", \"left\"):\n            # long tip-wise dimension\n            if not self.style.height:\n                self.style.height = max(275, min(1000, 18 * (tlen)))\n            if not self.style.width:\n                self.style.width = max(300, min(500, 18 * (tlen)))\n        else:\n            # long tip-wise dimension\n            if not self.style.width:\n                self.style.width = max(275, min(1000, 18 * (tlen)))\n            if not self.style.height:\n                self.style.height = max(225, min(500, 18 * (tlen)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds tip - labels to the axes.", "response": "def add_tip_labels_to_axes(self):\n        \"\"\"\n        Add text offset from tips of tree with correction for orientation, \n        and fixed_order which is usually used in multitree plotting.\n        \"\"\"\n        # get tip-coords and replace if using fixed_order\n        if self.style.orient in (\"up\", \"down\"):\n            ypos = np.zeros(self.ntips)\n            xpos = np.arange(self.ntips)\n\n        if self.style.orient in (\"right\", \"left\"):\n            xpos = np.zeros(self.ntips)\n            ypos = np.arange(self.ntips)\n\n        # pop fill from color dict if using color\n        if self.style.tip_labels_colors:\n            self.style.tip_labels_style.pop(\"fill\")\n\n        # fill anchor shift if None \n        # (Toytrees fill this at draw() normally when tip_labels != None)\n        if self.style.tip_labels_style[\"-toyplot-anchor-shift\"] is None:\n            self.style.tip_labels_style[\"-toyplot-anchor-shift\"] = \"15px\"\n\n        # add tip names to coordinates calculated above\n        self.axes.text(\n            xpos, \n            ypos,\n            self.tip_labels,\n            angle=(0 if self.style.orient in (\"right\", \"left\") else -90),\n            style=self.style.tip_labels_style,\n            color=self.style.tip_labels_colors,\n        )\n        # get stroke-width for aligned tip-label lines (optional)\n        # copy stroke-width from the edge_style unless user set it\n        if not self.style.edge_align_style.get(\"stroke-width\"):\n            self.style.edge_align_style['stroke-width'] = (\n                self.style.edge_style['stroke-width'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit_tip_labels(self):\n\n        if not self.tip_labels:\n            return \n\n        # longest name (this will include html hacks)\n        longest_name = max([len(i) for i in self.tip_labels])\n        if longest_name > 10:\n            multiplier = 0.85\n        else:\n            multiplier = 0.25\n\n        if self.style.use_edge_lengths:\n            addon = (self.treelist[0].treenode.height + (\n                self.treelist[0].treenode.height * multiplier))\n        else:\n            addon = self.treelist[0].treenode.get_farthest_leaf(True)[1]\n\n        # modify display for orientations\n        if self.style.orient == \"right\":\n            self.axes.x.domain.max = addon\n        elif self.style.orient == \"down\":\n            self.axes.y.domain.min = -1 * addon", "response": "Fits the tip labels to the display."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a p element into a new text.", "response": "def convert_p(element, text):\n    \"\"\"\n    Adds 2 newlines to the end of text\n    \"\"\"\n    depth = -1\n    while element:\n        if (not element.name == '[document]' and\n                not element.parent.get('id') == '__RESTRUCTIFY_WRAPPER__'):\n            depth += 1\n\n        element = element.parent\n\n    if text:\n        text = '    ' * depth + text\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a simple rst table to data", "response": "def simple2data(text):\n    \"\"\"\n    Convert a simple table to data (the kind used by DashTable)\n\n    Parameters\n    ----------\n    text : str\n        A valid simple rst table\n\n    Returns\n    -------\n    table : list of lists of str\n    spans : list of lists of lists of int\n        A span is a [row, column] pair that defines a group of merged\n        cells in the table. In a simple rst table, spans can only be\n        colspans.\n    use_headers : bool\n        Whether or not this table uses headers\n    headers_row : int\n        The row where headers are located\n\n    Notes\n    -----\n    This function requires docutils_.\n\n    .. _docutils: http://docutils.sourceforge.net/\n\n    Example\n    -------\n    >>> html_text = '''\n    ... ======  =====  ======\n    ...    Inputs      Output\n    ... -------------  ------\n    ...   A       B    A or B\n    ... ======  =====  ======\n    ... False   False  False\n    ...  True   False   True\n    ... False   True    True\n    ...  True   True    True\n    ... ======  =====  ======\n    ... '''\n    >>> from dashtable import simple2data\n    >>> table, spans, use_headers, headers_row = simple2data(html_text)\n    >>> from pprint import pprint\n    >>> pprint(table)\n    [['Inputs', 'Output', ''],\n     ['A', 'B', 'A or B'],\n     ['False', 'False', 'False'],\n     ['True, 'False', 'True'],\n     ['False', 'True', 'True'],\n     ['True', 'True', 'True']]\n    >>> print(spans)\n    [[[0, 0], [0, 1]]]\n    >>> print(use_headers)\n    True\n    >>> print(headers_row)\n    1\n    \"\"\"\n    try:\n        import docutils.statemachine\n        import docutils.parsers.rst.tableparser\n    except ImportError:\n        print(\"ERROR: You must install the docutils library to use simple2data\")\n        return\n\n    lines = text.split('\\n')\n    lines = truncate_empty_lines(lines)\n    leading_space = lines[0].replace(lines[0].lstrip(), '')\n    for i in range(len(lines)):\n        lines[i] = lines[i][len(leading_space)::]\n    parser = docutils.parsers.rst.tableparser.SimpleTableParser()\n\n    block = docutils.statemachine.StringList(list(lines))\n    simple_data = list(parser.parse(block))\n\n    column_widths = simple_data.pop(0)\n    column_count = len(column_widths)\n    headers_row = 0\n\n    if len(simple_data[0]) > 0:\n        use_headers = True\n        headers_row = len(simple_data[0]) - 1\n        headers = simple_data[0][0]\n        row_count = len(simple_data[1]) + len(simple_data[0])\n        while len(simple_data[0]) > 0:\n            simple_data[1].insert(0, simple_data[0][-1])\n            simple_data[0].pop(-1)\n        simple_data.pop(0)\n    else:\n        use_headers = False\n        simple_data.pop(0)\n        row_count = len(simple_data[0])\n\n    simple_data = simple_data[0]\n    table = make_empty_table(row_count, column_count)\n    spans = []\n\n    for row in range(len(simple_data)):\n        for column in range(len(simple_data[row])):\n            try:\n                text = '\\n'.join(simple_data[row][column][3]).rstrip()\n                table[row][column] = text\n                extra_rows = simple_data[row][column][0]\n                extra_columns = simple_data[row][column][1]\n                span = make_span(row, column, extra_rows, extra_columns)\n                span = sorted(span)\n                span = list(span for span,_ in itertools.groupby(span))\n                if not len(span) == 1:\n                    spans.append(span)\n            except TypeError:\n                pass\n    spans = sorted(spans)\n    return table, spans, use_headers, headers_row"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the widths of the columns of the output table.", "response": "def get_output_column_widths(table, spans):\n    \"\"\"\n    Gets the widths of the columns of the output table\n\n    Parameters\n    ----------\n    table : list of lists of str\n        The table of rows of text\n    spans : list of lists of int\n        The [row, column] pairs of combined cells\n\n    Returns\n    -------\n    widths : list of int\n        The widths of each column in the output table\n    \"\"\"\n    widths = []\n    for column in table[0]:\n        widths.append(3)\n\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            span = get_span(spans, row, column)\n            column_count = get_span_column_count(span)\n\n            if column_count == 1:\n                text_row = span[0][0]\n                text_column = span[0][1]\n\n                text = table[text_row][text_column]\n\n                length = get_longest_line_length(text)\n                if length > widths[column]:\n                    widths[column] = length\n\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            span = get_span(spans, row, column)\n            column_count = get_span_column_count(span)\n\n            if column_count > 1:\n                text_row = span[0][0]\n                text_column = span[0][1]\n\n                text = table[text_row][text_column]\n\n                end_column = text_column + column_count\n\n                available_space = sum(\n                    widths[text_column:end_column])\n                available_space += column_count - 1\n\n                length = get_longest_line_length(text)\n\n                while length > available_space:\n                    for i in range(text_column, end_column):\n                        widths[i] += 1\n\n                        available_space = sum(\n                            widths[text_column:end_column])\n\n                        available_space += column_count - 1\n                        if length <= available_space:\n                            break\n    return widths"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake an empty table for the given row and column count.", "response": "def make_empty_table(row_count, column_count):\n    \"\"\"\n    Make an empty table\n\n    Parameters\n    ----------\n    row_count : int\n        The number of rows in the new table\n    column_count : int\n        The number of columns in the new table\n\n    Returns\n    -------\n    table : list of lists of str\n        Each cell will be an empty str ('')\n    \"\"\"\n    table = []\n    while row_count > 0:\n        row = []\n        for column in range(column_count):\n            row.append('')\n        table.append(row)\n        row_count -= 1\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef beta(self):\n        '''\\\nThe linear estimation of the parameter vector :math:`\\beta` given by\n\n.. math::\n\n    \\beta = (X^T X)^-1 X^T y\n        \n'''\n        t = self.X.transpose()\n        XX = dot(t,self.X)\n        XY = dot(t,self.y)\n        return linalg.solve(XX,XY)", "response": "Calculates the beta of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef oftype(self, typ):\n        '''Return a generator of formatters codes of type typ'''\n        for key, val in self.items():\n            if val.type == typ:\n                yield key", "response": "Return a generator of formatters codes of type typ"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist of names for series in dataset. It will always return a list or names with length given by .", "response": "def names(self, with_namespace=False):\n        '''List of names for series in dataset.\n\n        It will always return a list or names with length given by\n        :class:`~.DynData.count`.\n        '''\n        N = self.count()\n        names = self.name.split(settings.splittingnames)[:N]\n        n = 0\n        while len(names) < N:\n            n += 1\n            names.append('unnamed%s' % n)\n        if with_namespace and self.namespace:\n            n = self.namespace\n            s = settings.field_separator\n            return [n + s + f for f in names]\n        else:\n            return names"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndumps the timeseries using a specific format.", "response": "def dump(self, format=None, **kwargs):\n        \"\"\"Dump the timeseries using a specific ``format``.\n        \"\"\"\n        formatter = Formatters.get(format, None)\n        if not format:\n            return self.display()\n        elif not formatter:\n            raise FormattingException('Formatter %s not available' % format)\n        else:\n            return formatter(self, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses binary operator and return tuple", "response": "def p_expression_binop(p):\r\n    '''expression : expression PLUS expression\r\n                  | expression MINUS expression\r\n                  | expression TIMES expression\r\n                  | expression DIVIDE expression\r\n                  | expression EQUAL expression\r\n                  | expression CONCAT expression\r\n                  | expression SPLIT expression'''\r\n    v = p[2]\r\n    if v == '+':\r\n        p[0] = PlusOp(p[1], p[3])\r\n    elif v == '-':\r\n        p[0] = MinusOp(p[1], p[3])\r\n    elif v == '*':\r\n        p[0] = MultiplyOp(p[1], p[3])\r\n    elif v == '/':\r\n        p[0] = DivideOp(p[1], p[3])\r\n    elif v == '=':\r\n        p[0] = EqualOp(p[1], p[3])\r\n    elif v == settings.concat_operator:\r\n        p[0] = ConcatenationOp(p[1], p[3])\r\n    elif v == settings.separator_operator:\r\n        p[0] = SplittingOp(p[1], p[3])\r\n    elif v == settings.field_operator:\r\n        p[0] = Symbol(p[1], field=p[3])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the expression group.", "response": "def p_expression_group(p):\r\n    '''expression : LPAREN expression RPAREN\r\n                  | LSQUARE expression RSQUARE'''\r\n    v = p[1]\r\n    if v == '(':\r\n        p[0] = functionarguments(p[2])\r\n    elif v == '[':\r\n        p[0] = tsentry(p[2])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_cells(cell1, cell2, direction):\n\n    cell1_lines = cell1.text.split(\"\\n\")\n    cell2_lines = cell2.text.split(\"\\n\")\n\n    if direction == \"RIGHT\":\n        for i in range(len(cell1_lines)):\n            cell1_lines[i] = cell1_lines[i] + cell2_lines[i][1::]\n        cell1.text = \"\\n\".join(cell1_lines)\n        cell1.column_count += cell2.column_count\n\n    elif direction == \"TOP\":\n        if cell1_lines[0].count('+') > cell2_lines[-1].count('+'):\n            cell2_lines.pop(-1)\n        else:\n            cell1_lines.pop(0)\n        cell2_lines.extend(cell1_lines)\n        cell1.text = \"\\n\".join(cell2_lines)\n        cell1.row_count += cell2.row_count\n        cell1.row = cell2.row\n        cell1.column = cell2.column\n\n    elif direction == \"BOTTOM\":\n        if (cell1_lines[-1].count('+') > cell2_lines[0].count('+') or\n                cell1.is_header):\n            cell2_lines.pop(0)\n        else:\n            cell1_lines.pop(-1)\n        cell1_lines.extend(cell2_lines)\n        cell1.text = \"\\n\".join(cell1_lines)\n        cell1.row_count += cell2.row_count\n\n    elif direction == \"LEFT\":\n        for i in range(len(cell1_lines)):\n            cell1_lines[i] = cell2_lines[i][0:-1] + cell1_lines[i]\n        cell1.text = \"\\n\".join(cell1_lines)\n        cell1.column_count += cell2.column_count\n        cell1.row = cell2.row\n        cell1.column = cell2.column", "response": "Merge two cells into one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over the class - level attributes of a class.", "response": "def iterclass(cls):\n    \"\"\"Iterates over (valid) attributes of a class.\n\n    Args:\n        cls (object): the class to iterate over\n\n    Yields:\n        (str, obj) tuples: the class-level attributes.\n    \"\"\"\n    for field in dir(cls):\n        if hasattr(cls, field):\n            value = getattr(cls, field)\n            yield field, value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a tcp socket to host and port.", "response": "def _mksocket(host, port, q, done, stop):\n    \"\"\"Returns a tcp socket to (host/port). Retries forever if connection fails\"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.settimeout(2)\n    attempt = 0\n    while not stop.is_set():\n        try:\n            s.connect((host, port))\n            return s\n        except Exception as ex:\n            # Simple exponential backoff: sleep for 1,2,4,8,16,30,30...\n            time.sleep(min(30, 2 ** attempt))\n            attempt += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _push(host, port, q, done, mps, stop, test_mode):\n    sock = None\n    retry_line = None\n    while not ( stop.is_set() or ( done.is_set() and retry_line == None and q.empty()) ):\n        stime = time.time()\n\n        if sock == None and not test_mode:\n            sock = _mksocket(host, port, q, done, stop)\n            if sock == None:\n                break\n\n        if retry_line:\n            line = retry_line\n            retry_line = None\n        else:\n            try:\n                line = q.get(True, 1)  # blocking, with 1 second timeout\n            except:\n                if done.is_set():  # no items in queue, and parent finished\n                    break\n                else:  # no items in queue, but parent might send more\n                    continue\n\n        if not test_mode:\n            try:\n                sock.sendall(line.encode('utf-8'))\n            except:\n                sock = None  # notify that we need to make a new socket at start of loop\n                retry_line = line  # can't really put back in q, so remember to retry this line\n                continue\n\n        etime = time.time() - stime  #time that actually elapsed\n\n        #Expected value of wait_time is 1/MPS_LIMIT, ie. MPS_LIMIT per second.\n        if mps > 0:\n            wait_time = (2.0 * random.random()) / (mps)\n            if wait_time > etime:  #if we should wait\n                time.sleep(wait_time - etime)  #then wait\n\n    if sock:\n        sock.close()", "response": "Worker thread. Connect to host and port pull data from q until done is set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log(self, name, val, **tags):\n        global _last_timestamp, _last_metrics\n\n        # do not allow .log after closing\n        assert not self.done.is_set(), \"worker thread has been closed\"\n        # check if valid metric name\n        assert all(c in _valid_metric_chars for c in name), \"invalid metric name \" + name\n\n        val = float(val)  #Duck type to float/int, if possible.\n        if int(val) == val:\n            val = int(val)\n\n        if self.host_tag and 'host' not in tags:\n            tags['host'] = self.host_tag\n\n        # get timestamp from system time, unless it's supplied as a tag\n        timestamp = int(tags.pop('timestamp', time.time()))\n\n        assert not self.done.is_set(), \"tsdb object has been closed\"\n        assert tags != {}, \"Need at least one tag\"\n\n        tagvals = ' '.join(['%s=%s' % (k, v) for k, v in tags.items()])\n\n        # OpenTSDB has major problems if you insert a data point with the same\n        # metric, timestamp and tags. So we keep a temporary set of what points\n        # we have sent for the last timestamp value. If we encounter a duplicate,\n        # it is dropped.\n        unique_str = \"%s, %s, %s, %s, %s\" % (name, timestamp, tagvals, self.host, self.port)\n        if timestamp == _last_timestamp or _last_timestamp == None:\n            if unique_str in _last_metrics:\n                return  # discard duplicate metrics\n            else:\n                _last_metrics.add(unique_str)\n        else:\n            _last_timestamp = timestamp\n            _last_metrics.clear()\n\n        line = \"put %s %d %s %s\\n\" % (name, timestamp, val, tagvals)\n\n        try:\n            self.q.put(line, False)\n            self.queued += 1\n        except queue.Full:\n            print(\"potsdb - Warning: dropping oldest metric because Queue is full. Size: %s\" % self.q.qsize(), file=sys.stderr)\n            self.q.get()  #Drop the oldest metric to make room\n            self.q.put(line, False)\n        return line", "response": "Log a metric name with value val."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of available serial ports", "response": "def available_ports():\n        \"\"\"\n        Scans COM1 through COM255 for available serial ports\n\n        returns a list of available ports\n        \"\"\"\n        ports = []\n\n        for i in range(256):\n            try:\n                p = Serial('COM%d' % i)\n                p.close()\n                ports.append(p)\n            except SerialException:\n                pass\n\n        return ports"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_current_response(self):\n        response = {'port': 0,\n                    'pressed': False,\n                    'key': 0,\n                    'time': 0}\n        if len(self.__response_structs_queue) > 0:\n            # make a copy just in case any other internal members of\n            # XidConnection were tracking the structure\n            response = self.__response_structs_queue[0].copy()\n            # we will now hand over 'response' to the calling code,\n            # so remove it from the internal queue\n            self.__response_structs_queue.pop(0)\n\n        return response", "response": "reads the current response data from the object and returns the current response in a dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetecting xid devices on all of the com ports connected to the computer.", "response": "def detect_xid_devices(self):\n        \"\"\"\n        For all of the com ports connected to the computer, send an\n        XID command '_c1'.  If the device response with '_xid', it is\n        an xid device.\n        \"\"\"\n        self.__xid_cons = []\n\n        for c in self.__com_ports:\n            device_found = False\n            for b in [115200, 19200, 9600, 57600, 38400]:\n                con = XidConnection(c, b)\n\n                try:\n                    con.open()\n                except SerialException:\n                    continue\n\n                con.flush_input()\n                con.flush_output()\n                returnval = con.send_xid_command(\"_c1\", 5).decode('ASCII')\n\n                if returnval.startswith('_xid'):\n                    device_found = True\n                    self.__xid_cons.append(con)\n\n                    if(returnval != '_xid0'):\n                        # set the device into XID mode\n                        con.send_xid_command('c10')\n                        con.flush_input()\n                        con.flush_output()\n\n                    # be sure to reset the timer to avoid the 4.66 hours\n                    # problem. (refer to XidConnection.xid_input_found to\n                    # read about the 4.66 hours)\n                    con.send_xid_command('e1')\n                    con.send_xid_command('e5')\n\n                con.close()\n                if device_found:\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef device_at_index(self, index):\n        if index >= len(self.__xid_cons):\n            raise ValueError(\"Invalid device index\")\n\n        return self.__xid_cons[index]", "response": "Returns the device at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_base_timer(self):\n        (_, _, time) = unpack('<ccI', self.con.send_xid_command(\"e3\", 6))\n        return time", "response": "Query the base timer for the current time"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef poll_for_response(self):\n        key_state = self.con.check_for_keypress()\n\n        if key_state != NO_KEY_DETECTED:\n            response = self.con.get_current_response()\n\n            if self.keymap is not None:\n                response['key'] = self.keymap[response['key']]\n            else:\n                response['key'] -= 1\n\n            self.response_queue.append(response)", "response": "Polls the device for user input and adds the response to the internal response_queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the pulse duration for events in miliseconds when activate_line is called is called", "response": "def set_pulse_duration(self, duration):\n        \"\"\"\n        Sets the pulse duration for events in miliseconds when activate_line\n        is called\n        \"\"\"\n        if duration > 4294967295:\n            raise ValueError('Duration is too long. Please choose a value '\n                             'less than 4294967296.')\n\n        big_endian = hex(duration)[2:]\n        if len(big_endian) % 2 != 0:\n            big_endian = '0'+big_endian\n\n        little_endian = []\n\n        for i in range(0, len(big_endian), 2):\n            little_endian.insert(0, big_endian[i:i+2])\n\n        for i in range(0, 4-len(little_endian)):\n            little_endian.append('00')\n\n        command = 'mp'\n        for i in little_endian:\n            command += chr(int(i, 16))\n\n        self.con.send_xid_command(command, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef activate_line(self, lines=None, bitmask=None,\n                      leave_remaining_lines=False):\n        \"\"\"\n        Triggers an output line on StimTracker.\n\n        There are 8 output lines on StimTracker that can be raised in any\n        combination.  To raise lines 1 and 7, for example, you pass in\n        the list: activate_line(lines=[1, 7]).\n\n        To raise a single line, pass in just an integer, or a list with a\n        single element to the lines keyword argument:\n\n            activate_line(lines=3)\n\n            or\n\n            activate_line(lines=[3])\n\n        The `lines` argument must either be an Integer, list of Integers, or\n        None.\n\n        If you'd rather specify a bitmask for setting the lines, you can use\n        the bitmask keyword argument.  Bitmask must be a Integer value between\n        0 and 255 where 0 specifies no lines, and 255 is all lines.  For a\n        mapping between lines and their bit values, see the `_lines` class\n        variable.\n\n        To use this, call the function as so to activate lines 1 and 6:\n\n            activate_line(bitmask=33)\n\n        leave_remaining_lines tells the function to only operate on the lines\n        specified.  For example, if lines 1 and 8 are active, and you make\n        the following function call:\n\n            activate_line(lines=4, leave_remaining_lines=True)\n\n        This will result in lines 1, 4 and 8 being active.\n\n        If you call activate_line(lines=4) with leave_remaining_lines=False\n        (the default), if lines 1 and 8 were previously active, only line 4\n        will be active after the call.\n        \"\"\"\n        if lines is None and bitmask is None:\n            raise ValueError('Must set one of lines or bitmask')\n        if lines is not None and bitmask is not None:\n            raise ValueError('Can only set one of lines or bitmask')\n\n        if bitmask is not None:\n            if bitmask not in range(0, 256):\n                raise ValueError('bitmask must be an integer between '\n                                 '0 and 255')\n\n        if lines is not None:\n            if not isinstance(lines, list):\n                lines = [lines]\n\n            bitmask = 0\n            for l in lines:\n                if l < 1 or l > 8:\n                    raise ValueError('Line numbers must be between 1 and 8 '\n                                     '(inclusive)')\n                bitmask |= self._lines[l]\n\n        self.con.set_digital_output_lines(bitmask, leave_remaining_lines)", "response": "Activate the specified lines of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the line with the specified number of lines.", "response": "def clear_line(self, lines=None, bitmask=None,\n                   leave_remaining_lines=False):\n        \"\"\"\n        The inverse of activate_line.  If a line is active, it deactivates it.\n\n        This has the same parameters as activate_line()\n        \"\"\"\n        if lines is None and bitmask is None:\n            raise ValueError('Must set one of lines or bitmask')\n        if lines is not None and bitmask is not None:\n            raise ValueError('Can only set one of lines or bitmask')\n\n        if bitmask is not None:\n            if bitmask not in range(0, 256):\n                raise ValueError('bitmask must be an integer between '\n                                 '0 and 255')\n\n        if lines is not None:\n            if not isinstance(lines, list):\n                lines = [lines]\n\n            bitmask = 0\n            for l in lines:\n                if l < 1 or l > 8:\n                    raise ValueError('Line numbers must be between 1 and 8 '\n                                     '(inclusive)')\n                bitmask |= self._lines[l]\n\n        self.con.clear_digital_output_lines(bitmask, leave_remaining_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the device with the proper keymaps and name.", "response": "def init_device(self):\n        \"\"\"\n        Initializes the device with the proper keymaps and name\n        \"\"\"\n        try:\n            product_id = int(self._send_command('_d2', 1))\n        except ValueError:\n            product_id = self._send_command('_d2', 1)\n\n        if product_id == 0:\n            self._impl = ResponseDevice(\n                self.con,\n                'Cedrus Lumina LP-400 Response Pad System',\n                lumina_keymap)\n        elif product_id == 1:\n            self._impl = ResponseDevice(\n                self.con,\n                'Cedrus SV-1 Voice Key',\n                None,\n                'Voice Response')\n        elif product_id == 2:\n            model_id = int(self._send_command('_d3', 1))\n            if model_id == 1:\n                self._impl = ResponseDevice(\n                    self.con,\n                    'Cedrus RB-530',\n                    rb_530_keymap)\n            elif model_id == 2:\n                self._impl = ResponseDevice(\n                    self.con,\n                    'Cedrus RB-730',\n                    rb_730_keymap)\n            elif model_id == 3:\n                self._impl = ResponseDevice(\n                    self.con,\n                    'Cedrus RB-830',\n                    rb_830_keymap)\n            elif model_id == 4:\n                self._impl = ResponseDevice(\n                    self.con,\n                    'Cedrus RB-834',\n                    rb_834_keymap)\n            else:\n                raise XidError('Unknown RB Device')\n        elif product_id == 4:\n            self._impl = StimTracker(\n                self.con,\n                'Cedrus C-POD')\n        elif product_id == b'S':\n            self._impl = StimTracker(\n                self.con,\n                'Cedrus StimTracker')\n\n        elif product_id == -99:\n            raise XidError('Invalid XID device')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending an XID command to the device", "response": "def _send_command(self, command, expected_bytes):\n        \"\"\"\n        Send an XID command to the device\n        \"\"\"\n        response = self.con.send_xid_command(command, expected_bytes)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all Xid devices connected to your computer.", "response": "def get_xid_devices():\n    \"\"\"\n    Returns a list of all Xid devices connected to your computer.\n    \"\"\"\n    devices = []\n    scanner = XidScanner()\n    for i in range(scanner.device_count()):\n        com = scanner.device_at_index(i)\n        com.open()\n        device = XidDevice(com)\n        devices.append(device)\n    return devices"}
