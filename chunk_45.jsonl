{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _return_url(self):\r\n        if type(self).__name__ == \"LoginHandler\" and self.request.method == \"POST\":\r\n            return_url = self.get_argument(\"next\", None)\r\n            if return_url: self.set_cookie(self._RETURN_URL, return_url)", "response": "Set the return url cookie."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef signout(self, redirect_url = \"/\"):\r\n        self.clear_cookie(self._USER_NAME)\r\n        if redirect_url: self.redirect(redirect_url)", "response": "\u6ce8\u9500\u767b\u5f55\u72b6\u6001\r\n\r\n            \u53c2\u6570:\r\n                redirect_url    \u8df3\u8f6c\u94fe\u63a5\uff0c\u4e3a None \u65f6\u4e0d\u8df3\u8f6c (Ajax \u53ef\u80fd\u7528\u5f97\u5230)\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef time_entries(self, start_date=None, end_date=None):\n        '''Array of all time entries'''\n        if self.cache['time_entries']: return self.cache['time_entries']\n        if not start_date:\n            start_date = datetime.date(1900, 1, 1)\n        if not end_date:\n            end_date = datetime.date.today()\n        time_entry_xml = self.bc.list_time_entries(self.id, start_date, end_date)\n        time_entries = []\n        for entry in ET.fromstring(time_entry_xml).findall(\"time-entry\"):\n            time_entries.append(TimeEntry(entry))\n        self.cache['time_entries'] = time_entries\n        return self.cache['time_entries']", "response": "Array of all time entries"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef person(self, person_id):\n        '''Access a Person object by id'''\n        if not self.cache['persons'].get(person_id, None):\n            try:\n                person_xml = self.bc.person(person_id)\n                p = Person(person_xml)\n                self.cache['persons'][person_id] = p\n            except HTTPError:\n                return None\n        return self.cache['persons'][person_id]", "response": "Access a Person object by id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef comments(self):\n        '''Looks through the last 3 messages and returns those comments.'''\n        if self.cache['comments']: return self.cache['comments']\n        comments = []\n        for message in self.messages[0:3]:\n            comment_xml = self.bc.comments(message.id)\n            for comment_node in ET.fromstring(comment_xml).findall(\"comment\"):\n                comments.append(Comment(comment_node))\n        comments.sort()\n        comments.reverse()\n        self.cache['comments'] = comments\n        return self.cache['comments']", "response": "Looks through the last 3 messages and returns those comments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\narraying of all milestones", "response": "def milestones(self):\n        '''Array of all milestones'''\n        if self.cache['milestones']: return self.cache['milestones']\n        milestone_xml = self.bc.list_milestones(self.id)\n        milestones = []\n        for node in ET.fromstring(milestone_xml).findall(\"milestone\"):\n            milestones.append(Milestone(node))\n\n        milestones.sort()\n        milestones.reverse()\n        self.cache['milestones'] = milestones\n        return self.cache['milestones']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_lines(s):\n    lines = s.splitlines(True)\n    if not lines:\n        return ['']\n    if lines[-1].splitlines() != [lines[-1]]:\n        lines.append('')\n    for i,l in enumerate(lines):\n        l2 = l.splitlines()\n        assert len(l2) in (0,1)\n        lines[i] = l2[0] if l2 else ''\n    if PY2 and isinstance(s, str):\n        # Manually split on \\f and \\v\n        lines = [\n            lf for l in lines\n               for lv in l.split('\\v')\n               for lf in lv.split('\\f')\n        ]\n    return lines", "response": "Returns a list of lines from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef with_color_stripped(f):\n    @wraps(f)\n    def colored_len(s):\n        s2 = re.sub(\n            COLOR_BEGIN_RGX + '(.*?)' + COLOR_END_RGX,\n            lambda m: re.sub(COLOR_BEGIN_RGX, '', m.group(1)),\n            s,\n        )\n        if re.search(COLOR_BEGIN_RGX, s2):\n            raise UnterminatedColorError(s)\n        return f(re.sub(COLOR_END_RGX, '', s2))\n    return colored_len", "response": "A function decorator for applying to len or imitators thereof that strips ANSI color sequences from a string before passing it on."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a sequence of lines that contains ANSI color escape sequences add a reset to the end of that sequence and copy all the colors in effect at the beginning of that sequence.", "response": "def carry_over_color(lines):\n    \"\"\"\n    Given a sequence of lines, for each line that contains a ANSI color escape\n    sequence without a reset, add a reset to the end of that line and copy all\n    colors in effect at the end of it to the beginning of the next line.\n    \"\"\"\n    lines2 = []\n    in_effect = ''\n    for s in lines:\n        s = in_effect + s\n        in_effect = ''\n        m = re.search(COLOR_BEGIN_RGX + '(?:(?!' + COLOR_END_RGX + ').)*$', s)\n        if m:\n            s += '\\033[m'\n            in_effect = ''.join(re.findall(COLOR_BEGIN_RGX, m.group(0)))\n        lines2.append(s)\n    return lines2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef breakable_units(s):\n    units = []\n    for run, color in zip(\n        re.split('(' + COLOR_BEGIN_RGX + '|' + COLOR_END_RGX + ')', s),\n        cycle([False, True]),\n    ):\n        if color:\n            units.append(run)\n        else:\n            ### TODO: Keep combining characters together\n            units.extend(run)\n    return units", "response": "Break a string into a list of substrings that can be used to create a list of substrings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef classify(self, tweets):\n        if type(tweets) == str:\n            return self.classifier.classify(tweets)\n\n        return list(map(lambda tweet: self.classifier.classify(tweet), tweets))", "response": "Classify a list of tweets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fasta_iter(fasta):\n    # Adapted from Brent Pedersen.\n    # http://www.biostars.org/p/710/#1412\n    groups = (group for _, group in\n              itertools.groupby(fasta, lambda line: line.startswith('>')))\n    for group in groups:\n        header = next(group)[1:].strip()\n        sequence = ''.join(line.strip() for line in next(groups))\n        yield header, sequence", "response": "Given an open FASTA file yield tuples of header sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over the chromosomes and start and stop positions in a BED file.", "response": "def _bed_iter(bed):\n    \"\"\"\n    Given an open BED file, yield tuples of (`chrom`, `chrom_iter`) where\n    `chrom_iter` yields tuples of (`start`, `stop`).\n    \"\"\"\n    records = (line.split()[:3] for line in bed if\n               not (line.startswith('browser') or line.startswith('track')))\n\n    for chrom, chrom_iter in itertools.groupby(records, lambda x: x[0]):\n        yield chrom, ((int(start), int(stop))\n                      for _, start, stop in chrom_iter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pprint_line(line, annotations=None, annotation_file=None,\n                 block_length=10, blocks_per_line=6):\n    \"\"\"\n    Pretty-print one line.\n    \"\"\"\n    annotations = annotations or []\n\n    if annotation_file:\n        # We just use the first chromosome defined in the BED file.\n        _, chrom_iter = next(_bed_iter(annotation_file))\n        annotations.append(list(chrom_iter))\n\n    print(pprint_sequence(line, annotations=annotations,\n                          block_length=block_length,\n                          blocks_per_line=blocks_per_line, format=AnsiFormat))", "response": "Pretty - print one line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pprint(sequence_file, annotation=None, annotation_file=None,\n           block_length=10, blocks_per_line=6):\n    \"\"\"\n    Pretty-print sequence(s) from a file.\n    \"\"\"\n    annotations = []\n\n    if annotation:\n        annotations.append([(first - 1, last) for first, last in annotation])\n\n    try:\n        # Peek to see if this looks like a FASTA file.\n        line = next(sequence_file)\n        if line.startswith('>'):\n            _pprint_fasta(itertools.chain([line], sequence_file),\n                          annotations=annotations,\n                          annotation_file=annotation_file,\n                          block_length=block_length,\n                          blocks_per_line=blocks_per_line)\n        else:\n            _pprint_line(line.strip(), annotations=annotations,\n                         annotation_file=annotation_file,\n                         block_length=block_length,\n                         blocks_per_line=blocks_per_line)\n    except StopIteration:\n        pass", "response": "Pretty - print a sequence file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n    parser = argparse.ArgumentParser(\n        description='monoseq: pretty-printing DNA and protein sequences',\n        epilog='If INPUT is in FASTA format, each record is pretty-printed '\n        'after printing its name and ANNOTATION (if supplied) is used by '\n        'matching chromosome/record name. If INPUT contains a raw sequence, '\n        'only the first chromosome in ANNOTATION is used.')\n    parser.add_argument(\n        'sequence_file', metavar='INPUT', nargs='?', default=sys.stdin,\n        type=argparse.FileType('r'), help='file to read sequence(s) from, '\n        'can be in FASTA format (default: standard input)')\n    parser.add_argument(\n        '-b', '--block-length', metavar='LENGTH', dest='block_length',\n        type=int, default=10, help='block length in letters (default: 10)')\n    parser.add_argument(\n        '-l', '--blocks-per-line', metavar='BLOCKS', dest='blocks_per_line',\n        type=int, default=6, help='blocks per line (default: 6)')\n    parser.add_argument(\n        '-a', '--annotation', metavar='POS', dest='annotation', nargs=2,\n        action='append', type=int, help='first and last positions of '\n        'subsequence to annotate (allowed more than once)')\n    parser.add_argument(\n        '-e', '--bed', metavar='ANNOTATION', dest='annotation_file',\n        type=argparse.FileType('r'), help='file to read annotation from in '\n        'BED format')\n\n    args = parser.parse_args()\n    pprint(_until_eof(args.sequence_file), annotation=args.annotation,\n           annotation_file=args.annotation_file,\n           block_length=args.block_length,\n           blocks_per_line=args.blocks_per_line)", "response": "Command line interface for the\n    script."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms linear normalization of all values in Map between normMin and normMax :param: map Map to normalize values for :param: normMin Smallest normalized value :param: normMax Largest normalized value :return: A new map with double values within [normMin, normMax]", "response": "def normalize_map_between(dictionary, norm_min, norm_max):\n    \"\"\"\n    Performs linear normalization of all values in Map between normMin and normMax\n\n    :param: map     Map to normalize values for\n    :param: normMin Smallest normalized value\n    :param: normMax Largest normalized value\n    :return: A new map with double values within [normMin, normMax]\n    \"\"\"\n    if len(dictionary) < 2:\n        return {}\n\n    values = list(dictionary.values())\n\n    norm_range = norm_max - norm_min\n    map_min = min(values)\n    map_range = max(values) - map_min\n    range_factor = norm_range / float(map_range)\n\n    normalized_map = {}\n    for key, value in dictionary.items():\n        normalized_map[key] = norm_min + (value - map_min) * range_factor\n\n    return normalized_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads options from a JSON file.", "response": "def load_options(file_name):\n    \"\"\"\n    Loads options from a JSON file. The file should contain general classifier options, intensifier words with their\n    intensification values, negation words and stop words.\n\n    @param file_name Name of file containing the options\n    @throws IOException\n    \"\"\"\n    words = from_json(read_entire_file_into_string(file_name))\n\n    global options, intensifiers, negators, stop_words\n    options = words[\"options\"]\n    intensifiers = words[\"intensifiers\"]\n    negators = words[\"negators\"]\n    stop_words = words[\"stopWords\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef activate_debug():\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.DEBUG)\n    logger.addHandler(ch)\n    logger.setLevel(logging.DEBUG)", "response": "Activate debug logging on console\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_textop_iter(func):\n    op = type(func.__name__,(WrapOpIter,), {'fn':staticmethod(func)})\n    setattr(textops.ops,func.__name__,op)\n    return op", "response": "Decorator to declare custom ITERATOR function as a new textops op\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a list and a dictionary and returns a string containing the unkown keys in the tree tree.", "response": "def eformat(format_str,lst,dct,defvalue='-'):\n    \"\"\" Formats a list and a dictionary, manages unkown keys\n\n    It works like :meth:`string.Formatter.vformat` except that it accepts a defvalue for not matching keys.\n    Defvalue can be a callable that will receive the requested key as argument and return a string\n\n    Args:\n        format_string (str): Same format string as for :meth:`str.format`\n        lst (dict) : the list to format\n        dct (dict) : the dict to format\n        defvalue (str or callable): the default value to display when the data is not in the dict\n\n    Examples:\n\n        >>> d = {'count': '32591', 'soft': 'textops'}\n        >>> l = ['Eric','Guido']\n        >>> eformat('{0} => {soft} : {count} dowloads',l,d)\n        'Eric => textops : 32591 dowloads'\n        >>> eformat('{2} => {software} : {count} dowloads',l,d,'N/A')\n        'N/A => N/A : 32591 dowloads'\n        >>> eformat('{2} => {software} : {count} dowloads',l,d,lambda k:'unknown_tag_%s' % k)\n        'unknown_tag_2 => unknown_tag_software : 32591 dowloads'\n    \"\"\"\n    return vformat(format_str,DefaultList(defvalue,lst),DefaultDict(defvalue,dct))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef je(self):\n        text = self._process()\n        return self.make_string(text,join_str='',return_if_none='')", "response": "Execute operations returns a string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef op(cls,text,*args,**kwargs):\n        return cls.fn(text,*args,**kwargs)", "response": "This method is used to perform a operation on a record set."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns either a custom timeout for the given service or a default timeout for the given service.", "response": "def get_timeout(service):\n    \"\"\" Returns either a custom timeout for the given service, or a default\n    \"\"\"\n    custom_timeout_key = \"RESTCLIENTS_%s_TIMEOUT\" % service.upper()\n    if hasattr(settings, custom_timeout_key):\n        return getattr(settings, custom_timeout_key)\n\n    default_key = \"RESTCLIENTS_DEFAULT_TIMEOUT\"\n    if hasattr(settings, default_key):\n        return getattr(settings, default_key)\n\n    return OLD_DEFAULT_TIMEOUT"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _delegate_or(smethname, func):\n    def delegated(self, *a, **kwa):\n        # Mutate the object before access\n        wrapped = object.__getattribute__(self, '__wrapped_object__')\n        mutator = object.__getattribute__(self, '__wrapped_mutator__')\n        wrapped = mutator(wrapped)\n        object.__setattr__(self, '__wrapped_object__', wrapped)\n\n        # Proxy access or use a fallback function\n        try:\n            meth = getattr(wrapped, smethname)\n        except AttributeError:\n            return func(wrapped, *a, **kwa)\n        if not isinstance(wrapped, type):\n            return meth(*a, **kwa)\n        else:\n            meth = getattr(type(wrapped), smethname)\n            return meth(wrapped, *a, **kwa)\n\n    return delegated", "response": "Creates a method that delegates to the object with the specified name or uses a fallback function if it s missing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dict of all regular class attributes.", "response": "def _list_class_vars(cls, exclude=None):\n    \"\"\"\n    Return a dict of all 'regular' (i.e. not prefixed ``_``) class attributes.\n    \"\"\"\n    cvars = {k: v for k, v in vars(cls).items()\n             if not k.startswith('_')}\n    cvars = deepcopy(cvars)\n    if exclude is not None:\n        for e in exclude:\n            cvars.pop(e)\n    return cvars"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the largest root such that root**2 < n.", "response": "def isqrt(n):\n    \"\"\"\n    Returns the largest root such that root**2 <= n (root + 1)**2 > n.\n\n    Credit goes to:\n    https://gist.github.com/castle-bravo/e841684d6bad8e0598e31862a7afcfc7\n    http://stackoverflow.com/a/23279113/2738025\n    \n    >>> isqrt(4)\n    2\n    >>> isqrt(16)\n    4\n    >>> list(map(isqrt, range(16,26)))\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 5]\n    >>> from random import randint\n    >>> all([isqrt(r**2 + randint(0,r)) == r  for r in range(0,1000)])\n    True\n    >>> r = randint(2**511, 2**512 - 1)\n    >>> isqrt(r**2) == r\n    True\n    >>> isqrt(2**30000) == 2**15000\n    True\n    \"\"\"\n    if n is None or type(n) is not int or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    try: # Attempt to use the native math library's sqrt function.\n        root = int(sqrt(n))\n        if pow(root, 2) == n: # No error from floating point conversion.\n            return root\n    except OverflowError: # Use the integer-only bit-wise algorithm.\n        pass\n\n    root = 0 # Running result.\n    rmdr = 0 # Running remainder n - root**2.\n    for s in reversed(range(0, n.bit_length(), 2)): # Shift n by s bits.\n        bits = n >> s & 3 # The next two most significant bits of n.\n        rmdr = rmdr << 2 | bits # Increase the remainder.\n        cand = root << 2 | 1 # Shifted candidate root value to try.\n        bit_next = int(rmdr >= cand) # The next bit in the remainder.\n        root = root << 1 | bit_next # Add next bit to running result.\n        rmdr -= cand * bit_next # Reduce the remainder if bit was added.\n    return root"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getStackTraceLogger(*args, **kwargs):\n    logger = logging.getLogger(*args, **kwargs)\n    return StackTraceLogger(logger)", "response": "Returns a : class : StackTrace logger that wraps a Python logger instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs error with stack trace and locals information.", "response": "def error(self, message, *args, **kwargs):\n        \"\"\"Log error with stack trace and locals information.\n\n        By default, enables stack trace information in logging messages, so that stacktrace and locals appear in Sentry.\n        \"\"\"\n        kwargs.setdefault('extra', {}).setdefault('stack', True)\n        return self.logger.error(message, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialise the approximator for the current page.", "response": "def _initialise_approximator(self, closest_point=None,\n        wavelengths_required=None, rescale=True, **kwargs):\n        \"\"\"\n        Initialise a spectrum interpolator.\n        \"\"\"\n\n        if self._initialised and not kwargs.get(\"force\", False):\n            logger.debug(\"Ignoring call to re-initialise approximator because \"\n                \"we already have.\")\n            return self._subset_bounds\n\n\n        logger.info(\"Initialising approximator near {0}\".format(closest_point))\n\n        N = self.grid_points.size\n        dtype = [(name, '<f8') for name in self.grid_points.dtype.names]\n        grid_points = self.grid_points.astype(dtype).view(float).reshape(N, -1)\n\n        # If closest_point is given then we will slice a small part of the grid.\n        if closest_point is not None:\n\n            default = 1.0\n            grid_subset = self._configuration.get(\"settings\", \n                { \"grid_subset\": default }).get(\"grid_subset\", default)\n\n            # Use nearest N points in interpolator.\n            # If grid subset is a fraction, scale it to real numbers.\n            if 1 >= grid_subset > 0:\n                grid_subset = int(np.round(grid_subset * N))\n\n            logger.debug(\"Using {0} nearest points for interpolator\".format(\n                grid_subset))\n\n            # Use closest N points.\n            distance = np.sum(np.abs(grid_points - closest_point)/\n                np.ptp(grid_points, axis=0), axis=1)\n            grid_indices = np.argsort(distance)[:grid_subset]\n\n        else:\n            grid_indices = np.ones(N, dtype=bool)\n\n        # What wavelengths will be required? Assume all if not specified.\n        if wavelengths_required is not None:\n            mask = np.zeros(self.wavelengths.size, dtype=bool)\n            for start, end in wavelengths_required:\n                idx = np.clip(\n                    self.wavelengths.searchsorted([start, end]) + [0, 1],\n                    0, self.wavelengths.size)\n                mask[idx[0]:idx[1]] = True\n        else:\n            mask = np.ones(self.wavelengths.size, dtype=bool)\n\n        # Apply model masks.\n        mask *= self._model_mask()\n\n        # Slice small part of the intensities grid.\n        intensities = np.memmap(\n            self._configuration[\"model_grid\"][\"intensities\"],\n            dtype=\"float32\", mode=\"r\", shape=(N, self.wavelengths.size))\n        subset = np.copy(intensities[grid_indices, :])\n        subset[:, ~mask] = np.nan\n        del intensities\n\n        # Create an interpolator.\n        try:\n            interpolator = interpolate.LinearNDInterpolator(\n                grid_points[grid_indices], subset, rescale=rescale)\n\n        except TypeError:\n            logger.warn(\"Could not rescale the LinearNDInterpolator because \"\\\n                \"you need a newer version of scipy\")\n            interpolator = interpolate.LinearNDInterpolator(\n                grid_points[grid_indices], subset)\n\n        generate.init()\n        generate.wavelengths.append(self.wavelengths)\n        generate.intensities.append(interpolator)\n        \n        self._initialised = True\n\n        # Return the subset boundaries of the grid.\n        self._subset_bounds = {}\n        for name in self.grid_points.dtype.names:\n            points = self.grid_points[name][grid_indices]\n            self._subset_bounds[name] = (min(points), max(points))\n\n        return self._subset_bounds"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the Division object for the given row of election results.", "response": "def get_division(self, row):\n        \"\"\"\n        Gets the Division object for the given row of election results.\n        \"\"\"\n\n        # back out of Alaska county\n\n        if (\n            row[\"level\"] == geography.DivisionLevel.COUNTY\n            and row[\"statename\"] == \"Alaska\"\n        ):\n            print(\"Do not take the Alaska county level result\")\n            return None\n\n        kwargs = {\"level__name\": row[\"level\"]}\n\n        if row[\"reportingunitname\"]:\n            name = row[\"reportingunitname\"]\n        else:\n            name = row[\"statename\"]\n\n        if row[\"level\"] in [\n            geography.DivisionLevel.COUNTY,\n            geography.DivisionLevel.TOWNSHIP,\n        ]:\n            kwargs[\"code\"] = row[\"fipscode\"]\n        else:\n            kwargs[\"name\"] = name\n        try:\n            return geography.Division.objects.get(**kwargs)\n        except ObjectDoesNotExist:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_office(self, row, division):\n        AT_LARGE_STATES = [\"AK\", \"DE\", \"MT\", \"ND\", \"SD\", \"VT\", \"WY\"]\n\n        if division.level.name not in [\n            geography.DivisionLevel.STATE,\n            geography.DivisionLevel.COUNTRY,\n        ]:\n            state = division.parent\n        else:\n            state = division\n\n        if row[\"officename\"] == \"President\":\n            return government.Office.objects.get(\n                label=\"President\", name=\"President of the United States\"\n            )\n        elif row[\"officename\"] == \"Governor\":\n            jurisdiction = government.Jurisdiction.objects.get(division=state)\n\n            return government.Office.objects.get(\n                slug__endswith=\"governor\", jurisdiction=jurisdiction\n            )\n        elif row[\"officename\"] == \"U.S. Senate\":\n            body = government.Body.objects.get(label=\"U.S. Senate\")\n            if row[\"seatnum\"] == \"2\" or \"Class II\" in row[\"description\"]:\n                senate_class = 2\n            else:\n                senate_class = self.senate_class\n            return government.Office.objects.get(\n                body=body, division=state, senate_class=senate_class\n            )\n        elif row[\"officename\"].startswith(\"U.S. House\"):\n            body = government.Body.objects.get(\n                label=\"U.S. House of Representatives\"\n            )\n\n            if row[\"statepostal\"] in AT_LARGE_STATES:\n                code = \"00\"\n            else:\n                if row[\"seatnum\"]:\n                    code = (\n                        row[\"seatnum\"].zfill(2)\n                        if int(row[\"seatnum\"]) < 10\n                        else row[\"seatnum\"]\n                    )\n                else:\n                    seatnum = row[\"seatname\"].split(\" \")[1]\n                    code = seatnum.zfill(2) if int(seatnum) < 10 else seatnum\n\n            district = state.children.get(\n                level__name=geography.DivisionLevel.DISTRICT, code=code\n            )\n            return government.Office.objects.get(body=body, division=district)", "response": "Gets the Office object for the given row of election results."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the Race object for the given row of election results.", "response": "def get_race(self, row, division):\n        \"\"\"\n        Gets the Race object for the given row of election results.\n\n        In order to get the race, we must know the office. This function\n        will get the office as well.\n\n        The only way to know if a Race is a special is based on the string\n        of the `racetype` field from the AP data.\n        \"\"\"\n\n        office = self.get_office(row, division)\n\n        try:\n            return election.Race.objects.get(\n                office=office,\n                cycle__name=row[\"electiondate\"].split(\"-\")[0],\n                special=(\n                    (row[\"seatnum\"] == (\"2\") and office.body.slug == \"senate\")\n                    or (\n                        # AP has inconsistent data for senate specials for 2018-11-06\n                        \"Class II\" in row.get(\"description\", \"\")\n                        and office.body.slug == \"senate\"\n                    )\n                    or (row[\"racetype\"].startswith(\"Special\"))\n                ),\n            )\n        except ObjectDoesNotExist:\n            print(\n                \"Could not find race for {} {}\".format(\n                    row[\"electiondate\"].split(\"-\")[0], office.label\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the Election object for the given row of election results.", "response": "def get_election(self, row, race):\n        \"\"\"\n        Gets the Election object for the given row of election results.\n        Depends on knowing the Race object.\n\n        If this is the presidential election, this will determine the\n        Division attached to the election based on the row's statename.\n\n        This function depends on knowing the Race object from `get_race`.\n        \"\"\"\n        election_day = election.ElectionDay.objects.get(\n            date=row[\"electiondate\"]\n        )\n\n        if row[\"racetypeid\"] in [\"D\", \"E\"]:\n            party = government.Party.objects.get(ap_code=\"Dem\")\n        elif row[\"racetypeid\"] in [\"R\", \"S\"]:\n            party = government.Party.objects.get(ap_code=\"GOP\")\n        else:\n            party = None\n\n        if row[\"racetype\"] == \"Runoff\" and party:\n            election_type = election.ElectionType.objects.get_or_create(\n                slug=election.ElectionType.PRIMARY_RUNOFF,\n                label=\"Primary Runoff\",\n                number_of_winners=1,\n            )[0]\n\n            return election.Election.objects.get_or_create(\n                election_type=election_type,\n                election_day=election_day,\n                division=race.office.division,\n                race=race,\n                party=party,\n            )[0]\n\n        try:\n            return election.Election.objects.get(\n                election_day=election_day,\n                division=race.office.division,\n                race=race,\n                party=party,\n            )\n        except ObjectDoesNotExist:\n            print(\n                \"Could not find election for {0} {1} {2}\".format(\n                    race, row[\"party\"], row[\"last\"]\n                )\n            )\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_or_create_party(self, row):\n        if row[\"party\"] in [\"Dem\", \"GOP\"]:\n            aggregable = False\n        else:\n            aggregable = True\n\n        defaults = {\"label\": row[\"party\"], \"aggregate_candidates\": aggregable}\n\n        party, created = government.Party.objects.get_or_create(\n            ap_code=row[\"party\"], defaults=defaults\n        )\n\n        return party", "response": "Gets or creates a Party object based on AP code of the row of the election data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets or creates a Person object for the given row of AP data.", "response": "def get_or_create_person(self, row):\n        \"\"\"\n        Gets or creates the Person object for the given row of AP data.\n        \"\"\"\n        person, created = entity.Person.objects.get_or_create(\n            first_name=row[\"first\"], last_name=row[\"last\"]\n        )\n\n        return person"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_or_create_candidate(self, row, party, race):\n\n        person = self.get_or_create_person(row)\n\n        id_components = row[\"id\"].split(\"-\")\n        candidate_id = \"{0}-{1}\".format(id_components[1], id_components[2])\n\n        defaults = {\"party\": party, \"incumbent\": row.get(\"incumbent\")}\n\n        if person.last_name == \"None of these candidates\":\n            candidate_id = \"{0}-{1}\".format(id_components[0], candidate_id)\n\n        candidate, created = election.Candidate.objects.update_or_create(\n            person=person,\n            race=race,\n            ap_candidate_id=candidate_id,\n            defaults=defaults,\n        )\n\n        return candidate", "response": "Gets or creates a Candidate object for the given row of AP data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create_ap_election_meta(self, row, election):\n        APElectionMeta.objects.get_or_create(\n            ap_election_id=row[\"raceid\"], election=election\n        )", "response": "Gets or creates the APElectionMeta object for the given row of APElectionData."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create_votes(self, row, division, candidate_election):\n        vote.Votes.objects.get_or_create(\n            division=division,\n            count=row[\"votecount\"],\n            pct=row[\"votepct\"],\n            winning=row[\"winner\"],\n            runoff=row[\"runoff\"],\n            candidate_election=candidate_election,\n        )", "response": "Gets or creates the Vote object for the given row of AP data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a row of AP election data to determine what model objects need to be created.", "response": "def process_row(self, row):\n        \"\"\"\n        Processes a row of AP election data to determine what model objects\n        need to be created.\n        \"\"\"\n        division = self.get_division(row)\n        if not division:\n            return None\n\n        race = self.get_race(row, division)\n        election = self.get_election(row, race)\n        if not election:\n            return None\n\n        party = self.get_or_create_party(row)\n        candidate = self.get_or_create_candidate(row, party, race)\n        candidate_election = self.get_or_create_candidate_election(\n            row, election, candidate, party\n        )\n\n        self.get_or_create_ap_election_meta(row, election)\n        self.get_or_create_votes(row, division, candidate_election)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        orm['samples.Cohort'].objects.filter(autocreated=True, batch__isnull=False).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_editor(name, userid):\n    url = _make_add_account_url(name, userid)\n    return _process_resp(url,\n                         get_sea_resource(url),\n                         _is_editor_added\n                         )", "response": "Add an editor to the user s list of UW s."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete the user s UW NetID of the editor.", "response": "def delete_editor(userid):\n    \"\"\"\n    :param userid: a string representing the user's UW NetID\n    :return: True if request is successful, False otherwise.\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    url = _make_del_account_url(userid)\n    return _process_resp(url,\n                         get_sea_resource(url),\n                         _is_editor_deleted\n                         )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting bot permissions for the specified user in the specified calendar.", "response": "def set_bot_permissions(calendar_id, userid, level):\n    \"\"\"\n    :param calendar_id: an integer representing calendar ID\n    :param userid: a string representing the user's UW NetID\n    :param level: a string representing the permission level\n    :return: True if request is successful, False otherwise.\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    url = _make_set_permissions_url(\n        calendar_id, userid, level)\n    return _process_resp(url,\n                         get_bot_resource(url),\n                         _is_permission_set\n                         )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the permissions of the user in the specified calendar.", "response": "def set_sea_permissions(calendar_id, userid, level):\n    \"\"\"\n    :param calendar_id: an integer representing calendar ID\n    :param userid: a string representing the user's UW NetID\n    :param level: a string representing the permission level\n    :return: True if request is successful, False otherwise.\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    url = _make_set_permissions_url(\n        calendar_id, userid, level)\n    return _process_resp(url,\n                         get_sea_resource(url),\n                         _is_permission_set\n                         )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the permissions of a user in a calendar.", "response": "def set_tac_permissions(calendar_id, userid, level):\n    \"\"\"\n    :param calendar_id: an integer representing calendar ID\n    :param userid: a string representing the user's UW NetID\n    :param level: a string representing the permission level\n    :return: True if request is successful, False otherwise.\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    url = _make_set_permissions_url(\n        calendar_id, userid, level)\n    return _process_resp(url,\n                         get_tac_resource(url),\n                         _is_permission_set\n                         )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _process_resp(request_id, response, is_success_func):\n    if response.status != 200:\n        raise DataFailureException(request_id,\n                                   response.status,\n                                   response.reason\n                                   )\n    if response.data is None:\n        raise NoDataReturned()\n    root = objectify.fromstring(response.data)\n    if root.ResponseMessage is None or\\\n            root.ResponseMessage.attrib['Code'] is None:\n        raise UnknownError()\n    resp_code = int(root.ResponseMessage.attrib['Code'])\n    func = partial(is_success_func)\n    if func(resp_code):\n        return True\n    _check_err(resp_code, request_id)", "response": "Process the response from the Campus API."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck possible error code returned in the response body.", "response": "def _check_err(code, request_id):\n    \"\"\"\n    :param code: an integer value\n    :param request_id: campus url identifying the request\n    Check possible error code returned in the response body\n    raise the corresponding TrumbaException\n    \"\"\"\n    if code == 3006:\n        raise CalendarNotExist()\n    elif code == 3007:\n        raise CalendarOwnByDiffAccount()\n    elif code == 3008:\n        raise AccountNotExist()\n    elif code == 3009 or code == 3013:\n        raise AccountUsedByDiffUser()\n    elif code == 3010:\n        raise InvalidPermissionLevel()\n    elif code == 3011:\n        raise FailedToClosePublisher()\n    elif code == 3014:\n        raise InvalidEmail()\n    elif code == 3015:\n        raise NoAllowedPermission()\n    elif code == 3016:\n        raise AccountNameEmpty()\n    elif code == 3017 or code == 3018:\n        raise ErrorCreatingEditor()\n    else:\n        logging.getLogger(__name__).warn(\n            \"Unexpected Error Code: %s with %s\" % (\n                code, request_id))\n        raise UnexpectedError()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handle_args():\n\n    default_database_name = dbconfig.testdb_corpus_url.database\n    parser = argparse.ArgumentParser(\n        prog=os.path.basename(__file__),\n        # formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        formatter_class=MyFormatter,\n        description=textwrap.dedent(\"\"\"\\\n        Dump the raw VOEvents as XML files, collected into bzip2'd tarballs.\n\n        If start or end times are specified, then the range is start-inclusive\n        end-exclusive, i.e.\n\n            start <= author_datetime < end\n\n        NB when writing compressed tarballs in Python, the entire file is\n        composed in memory before writing to file. This means that setting\n        `nsplit` too large will result in very high memory usage! The default\n        value of 5000 seems to peak at <250MB of RAM (though this varies\n        according to the size of the VOEvent packets, and assumes\n        `prefetch=False`). Some quick tests suggest typical RAM usage\n            ~= 40MB + 30MB*(nsplit/1000) .\n        \"\"\"),\n\n    )\n    parser.add_argument('tarfile_pathstem',\n                        help='Path to tarball to create, e.g. `foobar`. '\n                             'Suffix ``.tar.bz2`` will be appended.'\n                        )\n\n    parser.add_argument('-d', '--dbname', nargs='?',\n                        default=str(default_database_name),\n                        help='Database name')\n\n    parser.add_argument('-n', '--nsplit',\n                        type=int,\n                        default=5000,\n                        help=\n                        \"Output multiple files, `NSPLIT` packets per tarball.\"\n                        \"Naming convention is `<stem>.001.tar.bz2, <stem>.002.tar.bz2, ...`\"\n                        )\n    parser.add_argument('-s', '--start',\n                        type=iso8601.parse_date,\n                        default=None,\n                        help=\"Filter events by author_date>=`START`\")\n    parser.add_argument('-e', '--end',\n                        type=iso8601.parse_date,\n                        default=datetime.datetime.now(tz=pytz.UTC),\n                        help=\n                        \"Filter events by author_date<`END`\")\n    parser.add_argument('-p', '--prefetch', action='store_true', default=False,\n                        help=\n                        \"Bulk-fetch XML packets from DB (~3x faster, but \"\n                        \"uses considerably more RAM, depending on value of \"\n                        \"`nsplit`.)\"\n                        )\n    parser.add_argument('-a', '--all', action='store_true', default=False,\n                        help=\n                        \"Ignore any datetime filters, dump **all** VOEvents.\"\n                        \"(This option is provided to allow dumping of VOEvents\"\n                        \"with author_datetime=Null, which are otherwise ignored.)\"\n                        )\n    return parser.parse_args()", "response": "Handles command line options and returns a list of arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        fields = orm['avocado.DataField'].objects.filter(app_name='variants',\n            model_name='evs', field_name__in=('all_maf', 'aa_maf', 'ea_maf'))\n        for f in fields:\n            f.field_name = f.field_name.replace('maf', 'af')\n            f.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbumping the minor version in version. py.", "response": "def bump_minor_version():\n    \"\"\"Bump the minor version in version.py.\"\"\"\n    version = load_version_as_list()\n    print('current version: {}'.format(format_version_string(version)))\n    version[-1] += 1\n    print('new version: {}'.format(format_version_string(version)))\n\n    contents = \"__version__ = '{}'\\n\".format(format_version_string(version))\n\n    with open(VERSION_PATH, 'w') as wfile:\n        wfile.write(contents)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndisplays a list of active endpoints.", "response": "def apiv1_root_view():\n    \"\"\"\n    API root url. Shows a list of active endpoints.\n    \"\"\"\n    docs_url = current_app.config.get('DOCS_URL',\n                                      'http://' + request.host + '/docs')\n    message = \"Welcome to the voeventdb REST API, \" \\\n              \"interface version '{}'.\".format(\n        apiv1.name)\n    api_details = {\n        'message': message,\n        'api_version': apiv1.name,\n        'git_sha': package_version_dict['full-revisionid'][:8],\n        'version_tag': package_version_dict['version'],\n        'endpoints': [str(r) for r in get_apiv1_rules()],\n        'docs_url': docs_url\n    }\n\n    if 'text/html' in request.headers.get(\"Accept\", \"\"):\n        return render_template('landing.html',\n                               **api_details\n                               )\n    else:\n        return jsonify(api_details)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dict containing key details for the given IVORN.", "response": "def packet_synopsis(url_encoded_ivorn=None):\n    \"\"\"\n    Result:\n        Nested dict providing key details, e.g.::\n\n            {\"coords\": [\n                            {\n                                \"dec\": 10.9712,\n                                \"error\": 0.05,\n                                \"ra\": 233.7307,\n                                \"time\": \"2015-10-01T15:04:22.930000+00:00\"\n                            },\n                            ...\n                        ],\n             \"refs\":   [\n                            {\n                                \"cite_type\": u\"followup\",\n                                \"description\": \"This is the XRT Position ...\",\n                                \"ref_ivorn\": \"ivo://nasa.gsfc.gcn/SWIFT#BAT_...\"\n                            },\n                            ...\n                        ],\n             \"voevent\": {\n                            \"author_datetime\": \"2015-10-01T15:04:46+00:00\",\n                            \"author_ivorn\": \"ivo://nasa.gsfc.tan/gcn\",\n                            \"ivorn\": \"ivo://nasa.gsfc.gcn/SWIFT#BAT_GRB_Pos_657286-112\",\n                            \"received\": \"2015-11-19T20:41:38.226431+00:00\",\n                            \"role\": \"observation\",\n                            \"stream\": \"nasa.gsfc.gcn/SWIFT\",\n                            \"version\": \"2.0\"\n                        }\n             \"relevant_urls\": [ \"http://address1.foo.bar\",\n                                \"http://address2.foo.bar\"\n                                ]\n            }\n\n\n    Returns some key details for the packet specified by IVORN.\n\n    The required IVORN should be appended to the URL after ``/synopsis/``\n    in :ref:`URL-encoded <url-encoding>` form.\n\n    \"\"\"\n    ivorn = validate_ivorn(url_encoded_ivorn)\n\n    voevent_row = db_session.query(Voevent).filter(\n        Voevent.ivorn == ivorn).one()\n\n    cites = db_session.query(Cite). \\\n        filter(Cite.voevent_id == voevent_row.id).all()\n    coords = db_session.query(Coord). \\\n        filter(Coord.voevent_id == voevent_row.id).all()\n\n    v_dict = voevent_row.to_odict(exclude=('id', 'xml'))\n\n    cite_list = [c.to_odict(exclude=('id', 'voevent_id')) for c in cites]\n    coord_list = [c.to_odict(exclude=('id', 'voevent_id')) for c in coords]\n\n    relevant_urls = lookup_relevant_urls(voevent_row, cites)\n\n    result = {'voevent': v_dict,\n              'refs': cite_list,\n              'coords': coord_list,\n              'relevant_urls': relevant_urls,\n              }\n\n    return jsonify(make_response_dict(result))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the XML packet contents stored for a given IVORN.", "response": "def packet_xml(url_encoded_ivorn=None):\n    \"\"\"\n    Returns the XML packet contents stored for a given IVORN.\n\n    The required IVORN should be appended to the URL after ``/xml/``\n    in :ref:`URL-encoded <url-encoding>` form.\n    \"\"\"\n    # Handle Apache / Debug server difference...\n    # Apache conf must include the setting::\n    #   AllowEncodedSlashes NoDecode\n    # otherwise urlencoded paths have\n    # double-slashes ('//') replaced with single-slashes ('/').\n    # However, the werkzeug simple-server decodes these by default,\n    # resulting in differing dev / production behaviour, which we handle here.\n\n    ivorn = validate_ivorn(url_encoded_ivorn)\n    xml = db_session.query(Voevent.xml).filter(\n        Voevent.ivorn == ivorn\n    ).scalar()\n    r = make_response(xml)\n    r.mimetype = 'text/xml'\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps response in JSON or JSONP style", "response": "def json_or_jsonp(func):\n    \"\"\"Wrap response in JSON or JSONP style\"\"\"\n    @wraps(func)\n    def _(*args, **kwargs):\n        mimetype = 'application/javascript'\n        callback = request.args.get('callback', None)\n        if callback is None:\n            content = func(*args, **kwargs)\n\n        else:\n            content = \"%s(%s)\" % (callback, func(*args, **kwargs))\n        return current_app.response_class(content, mimetype=mimetype)\n    return _"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_response_headers(headers):\n\n    def decorator(func):\n        @wraps(func)\n        def _(*args, **kwargs):\n            rsp = make_response(func(*args, **kwargs))\n            rsp_headers = rsp.headers\n            for header, value in headers.items():\n                rsp_headers[header] = value\n            return rsp\n        return _\n    return decorator", "response": "Decorator to add headers passed in to the response object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap_ptr_class(struct, constructor, destructor, classname=None):\n\n    class WrapperClass(ctypes.c_void_p):\n\n        def __init__(self, val=None):\n            if val:\n                super(WrapperClass, self).__init__(val)\n            else:\n                super(WrapperClass, self).__init__(constructor())\n\n        def __del__(self):\n            destructor(self)\n            self.value = None\n\n        def __getattr__(self, name):\n            return getattr(ctypes.cast(self.value,\n                                       ctypes.POINTER(struct)).contents, name)\n\n        def __setattr__(self, name, value):\n            if name == 'value' or name.startswith('_'):\n                super(WrapperClass, self).__setattr__(name, value)\n            else:\n                cont = ctypes.cast(self.value, ctypes.POINTER(struct)).contents\n                if isinstance(value, str):\n                    value = value.encode('utf-8')\n                setattr(cont, name, value)\n\n    WrapperClass.__name__ = classname or struct.__name__.lstrip('_')\n    return WrapperClass", "response": "Creates a wrapper class for pointer to struct class which appropriately acquires and releases memory\nystal."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef truncate_file(f):\n    if isinstance(f, InMemoryUploadedFile):\n        f.file = StringIO()\n    else:\n        f.seek(0)\n        f.truncate(0)", "response": "Clear uploaded file and allow write to it.\n    Only for not too big files!!!\n    Also can clear simple opened file.\n    Examples:\n        truncate_file(request.FILES['file'])\n\n        with open('/tmp/file', 'rb+') as f:\n            truncate_file(f)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_dirs_for_file_path(file_path, mode=0o775):\n    dirname = os.path.dirname(file_path)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname, mode=mode)", "response": "Make dirs for file file_path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to RabbitMQ returning the connection handle.", "response": "def connect(self):\n        \"\"\"Connect to RabbitMQ, returning the connection handle.\n\n        When the connection is established, the on_connection_open method\n        will be invoked by pika.\n\n        :rtype: pika.SelectConnection\n        \"\"\"\n        logger.debug('Connecting to %s', self._url)\n        return pika.SelectConnection(pika.URLParameters(self._url),\n                                     self.on_connection_open,\n                                     stop_ioloop_on_close=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall by pika when the connection to RabbitMQ is closed.", "response": "def on_connection_closed(self, _, reply_code, reply_text):\n        \"\"\"Called by pika when the connection to RabbitMQ is closed\n        unexpectedly.\n\n        Since it is unexpected, we will reconnect to RabbitMQ if it disconnects.\n\n        :param pika.connection.Connection _: The closed connection object\n        :param int reply_code: The server provided reply_code if given\n        :param str reply_text: The server provided reply_text if given\n        \"\"\"\n        self._channel = None\n        if self._closing:\n            self._connection.ioloop.stop()\n        else:\n            logger.warning('Connection closed, reopening in 5 seconds: (%s) %s', reply_code, reply_text)\n            self._connection.add_timeout(5, self.reconnect)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_channel_open(self, channel):\n        logger.debug('Channel opened')\n        self._channel = channel\n        self.add_on_channel_close_callback()\n        self.setup_qos()", "response": "Called by pika when the channel is opened."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeclares the exchange and declare it", "response": "def setup_exchange(self):\n        \"\"\"Declare the exchange\n\n        When completed, the on_exchange_declareok method will be invoked by pika.\n        \"\"\"\n        logger.debug('Declaring exchange %s', self._exchange)\n        self._channel.exchange_declare(self.on_exchange_declareok,\n                                       self._exchange,\n                                       self._exchange_type,\n                                       durable=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_queue(self):\n        logger.debug(\"Declaring queue %s\" % self._queue)\n        self._channel.queue_declare(self.on_queue_declareok, self._queue, durable=True)", "response": "Declare the queue and set the durable flag"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninvokes by pika when the queue is declared and the exchange is provided.", "response": "def on_queue_declareok(self, _):\n        \"\"\"Invoked by pika when queue is declared\n\n        This method will start consuming or first bind the queue to the exchange\n        if an exchange is provided.\n\n        After binding, the on_bindok method will be invoked by pika.\n\n        :param pika.frame.Method _: The Queue.DeclareOk frame\n        \"\"\"\n        logger.debug(\"Binding %s to %s with %s\", self._exchange, self._queue, self._routing_key)\n        if self._exchange:\n            self._channel.queue_bind(self.on_bindok, self._queue, self._exchange, self._routing_key)\n        else:\n            self.start_consuming()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninvokes by pika when a Basic. Cancel frame is received.", "response": "def on_consumer_cancelled(self, method_frame):\n        \"\"\"Invoked by pika when RabbitMQ sends a Basic.Cancel for a consumer\n        receiving messages.\n\n        :param pika.frame.Method method_frame: The Basic.Cancel frame\n        \"\"\"\n        logger.debug('Consumer was cancelled remotely, shutting down: %r', method_frame)\n        if self._channel:\n            self._channel.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninvoke by pika when a message is delivered from RabbitMQ.", "response": "def on_message(self, _, basic_deliver, properties, body):\n        \"\"\"Invoked by pika when a message is delivered from RabbitMQ.\n\n        The channel is passed for your convenience. The basic_deliver object\n        that is passed in carries the exchange, routing key, delivery tag\n        and a redelivered flag for the message. The properties passed in is\n        an instance of BasicProperties with the message properties and the\n        body is the message that was sent.\n\n        We'll json-decode the message body, and if that succeeds, call the\n        handler that was given to us. Messages that contain invalid json\n        will be discarded.\n\n        :type _: pika.channel.Channel\n        :type basic_deliver: pika.Spec.Basic.Deliver\n        :type properties: pika.Spec.BasicProperties\n        :type body: str|unicode\n        \"\"\"\n        logger.debug('Received message # %s from %s: %s', basic_deliver.delivery_tag, properties.app_id, body)\n        try:\n            decoded = json.loads(body.decode('-utf-8'))\n        except ValueError:\n            logger.warning('Discarding message containing invalid json: %s', body)\n        else:\n            self._handler(decoded)\n\n        self.acknowledge_message(basic_deliver.delivery_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef acknowledge_message(self, delivery_tag):\n        logger.debug('Acknowledging message %s', delivery_tag)\n        self._channel.basic_ack(delivery_tag)", "response": "Acknowledge the message delivery from RabbitMQ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open_channel(self):\n        logger.debug('Creating new channel')\n        self._connection.channel(on_open_callback=self.on_channel_open)", "response": "Open a new channel with RabbitMQ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        logger.debug('Stopping')\n        self._closing = True\n        self.stop_consuming()\n        self._connection.ioloop.start()\n        logger.debug('Stopped')", "response": "Stop the connection to RabbitMQ by stopping the consumer with RabbitMQ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntell RabbitMQ that we would like to stop consuming.", "response": "def stop_consuming(self):\n        \"\"\"Tell RabbitMQ that we would like to stop consuming.\"\"\"\n        if self._channel:\n            logger.debug('Sending a Basic.Cancel RPC command to RabbitMQ')\n            self._channel.basic_cancel(self.on_cancelok, self._consumer_tag)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef togpx(self):\n        element = create_elem(self.__class__._elem_name,\n                              {'lat': str(self.latitude),\n                               'lon': str(self.longitude)})\n        if self.name:\n            element.append(create_elem('name', text=self.name))\n        if self.description:\n            element.append(create_elem('desc', text=self.description))\n        if self.elevation:\n            element.append(create_elem('ele', text=str(self.elevation)))\n        if self.time:\n            element.append(create_elem('time', text=self.time.isoformat()))\n        return element", "response": "Generate a GPX waypoint element subtree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distance(self, method='haversine'):\n        distances = []\n        for segment in self:\n            if len(segment) < 2:\n                distances.append([])\n            else:\n                distances.append(segment.distance(method))\n        return distances", "response": "Calculate distances between locations in segments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the bearing between locations in segments.", "response": "def bearing(self, format='numeric'):\n        \"\"\"Calculate bearing between locations in segments.\n\n        Args:\n            format (str): Format of the bearing string to return\n\n        Returns:\n            list of list of float: Groups of bearings between points in\n                segments\n        \"\"\"\n        bearings = []\n        for segment in self:\n            if len(segment) < 2:\n                bearings.append([])\n            else:\n                bearings.append(segment.bearing(format))\n        return bearings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the final bearing between locations in segments.", "response": "def final_bearing(self, format='numeric'):\n        \"\"\"Calculate final bearing between locations in segments.\n\n        Args:\n            format (str): Format of the bearing string to return\n\n        Returns:\n            list of list of float: Groups of bearings between points in\n                segments\n        \"\"\"\n        bearings = []\n        for segment in self:\n            if len(segment) < 2:\n                bearings.append([])\n            else:\n                bearings.append(segment.final_bearing(format))\n        return bearings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inverse(self):\n        inverses = []\n        for segment in self:\n            if len(segment) < 2:\n                inverses.append([])\n            else:\n                inverses.append(segment.inverse())\n        return inverses", "response": "Calculate the inverse geodesic between locations in segments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the midpoint between locations in segments.", "response": "def midpoint(self):\n        \"\"\"Calculate the midpoint between locations in segments.\n\n        Returns:\n            list of Point: Groups of midpoint between points in segments\n        \"\"\"\n        midpoints = []\n        for segment in self:\n            if len(segment) < 2:\n                midpoints.append([])\n            else:\n                midpoints.append(segment.midpoint())\n        return midpoints"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef range(self, location, distance):\n        return (segment.range(location, distance) for segment in self)", "response": "Test whether locations are within a given range of location."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef destination(self, bearing, distance):\n        return (segment.destination(bearing, distance) for segment in self)", "response": "Calculate the destination locations for given distance and bearings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates sunrise times for locations.", "response": "def sunrise(self, date=None, zenith=None):\n        \"\"\"Calculate sunrise times for locations.\n\n        Args:\n            date (datetime.date): Calculate rise or set for given date\n            zenith (str): Calculate sunrise events, or end of twilight\n        Returns:\n            list of list of datetime.datetime: The time for the sunrise for\n                each point in each segment\n        \"\"\"\n        return (segment.sunrise(date, zenith) for segment in self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating sunset times for each segment in the list", "response": "def sunset(self, date=None, zenith=None):\n        \"\"\"Calculate sunset times for locations.\n\n        Args:\n            date (datetime.date): Calculate rise or set for given date\n            zenith (str): Calculate sunset events, or start of twilight times\n\n        Returns:\n            list of list of datetime.datetime: The time for the sunset for each\n                point in each segment\n        \"\"\"\n        return (segment.sunset(date, zenith) for segment in self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates sunrise and sunset times for locations.", "response": "def sun_events(self, date=None, zenith=None):\n        \"\"\"Calculate sunrise/sunset times for locations.\n\n        Args:\n            date (datetime.date): Calculate rise or set for given date\n            zenith (str): Calculate rise/set events, or twilight times\n\n        Returns:\n            list of list of 2-tuple of datetime.datetime: The time for the\n                sunrise and sunset events for each point in each segment\n        \"\"\"\n        return (segment.sun_events(date, zenith) for segment in self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef togpx(self):\n        metadata = create_elem('metadata')\n        if self.name:\n            metadata.append(create_elem('name', text=self.name))\n        if self.desc:\n            metadata.append(create_elem('desc', text=self.desc))\n        if self.author:\n            element = create_elem('author')\n            if self.author['name']:\n                element.append(create_elem('name', text=self.author['name']))\n            if self.author['email']:\n                attr = dict(zip(self.author['email'].split('@'),\n                                ('id', 'domain')))\n                element.append(create_elem('email', attr))\n            if self.author['link']:\n                element.append(create_elem('link', text=self.author['link']))\n            metadata.append(element)\n        if self.copyright:\n            if self.copyright['name']:\n                author = {'author': self.copyright['name']}\n            else:\n                author = None\n            element = create_elem('copyright', author)\n            if self.copyright['year']:\n                element.append(create_elem('year',\n                                           text=self.copyright['year']))\n            if self.copyright['license']:\n                license = create_elem('license')\n                element.append(license)\n            metadata.append(element)\n        if self.link:\n            for link in self.link:\n                if isinstance(link, basestring):\n                    element = create_elem('link', {'href': link})\n                else:\n                    element = create_elem('link', {'href': link['href']})\n                    if link['text']:\n                        element.append(create_elem('text', text=link['text']))\n                    if link['type']:\n                        element.append(create_elem('type', text=link['type']))\n                metadata.append(element)\n        if isinstance(self.time, (time.struct_time, tuple)):\n            text = time.strftime('%Y-%m-%dT%H:%M:%S%z', self.time)\n        elif isinstance(self.time, utils.Timestamp):\n            text = self.time.isoformat()\n        else:\n            text = time.strftime('%Y-%m-%dT%H:%M:%S%z')\n        metadata.append(create_elem('time', text=text))\n        if self.keywords:\n            metadata.append(create_elem('keywords', text=self.keywords))\n        if self.bounds:\n            if not isinstance(self.bounds, dict):\n                latitudes = list(map(attrgetter('latitude'), self.bounds))\n                longitudes = list(map(attrgetter('longitude'), self.bounds))\n                bounds = {\n                    'minlat': str(min(latitudes)),\n                    'maxlat': str(max(latitudes)),\n                    'minlon': str(min(longitudes)),\n                    'maxlon': str(max(longitudes)),\n                }\n            else:\n                bounds = dict((k, str(v)) for k, v in self.bounds.items())\n            metadata.append(create_elem('bounds', bounds))\n        if self.extensions:\n            element = create_elem('extensions')\n            for i in self.extensions:\n                element.append(i)\n            metadata.append(self.extensions)\n        return metadata", "response": "Generate a GPX metadata element subtree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport information from GPX metadata.", "response": "def import_metadata(self, elements):\n        \"\"\"Import information from GPX metadata.\n\n        Args:\n            elements (etree.Element): GPX metadata subtree\n        \"\"\"\n        metadata_elem = lambda name: etree.QName(GPX_NS, name)\n\n        for child in elements.getchildren():\n            tag_ns, tag_name = child.tag[1:].split('}')\n            if not tag_ns == GPX_NS:\n                continue\n            if tag_name in ('name', 'desc', 'keywords'):\n                setattr(self, tag_name, child.text)\n            elif tag_name == 'time':\n                self.time = utils.Timestamp.parse_isoformat(child.text)\n            elif tag_name == 'author':\n                self.author['name'] = child.findtext(metadata_elem('name'))\n                aemail = child.find(metadata_elem('email'))\n                if aemail:\n                    self.author['email'] = '%s@%s' % (aemail.get('id'),\n                                                      aemail.get('domain'))\n                self.author['link'] = child.findtext(metadata_elem('link'))\n            elif tag_name == 'bounds':\n                self.bounds = {\n                    'minlat': child.get('minlat'),\n                    'maxlat': child.get('maxlat'),\n                    'minlon': child.get('minlon'),\n                    'maxlon': child.get('maxlon'),\n                }\n            elif tag_name == 'extensions':\n                self.extensions = child.getchildren()\n            elif tag_name == 'copyright':\n                if child.get('author'):\n                    self.copyright['name'] = child.get('author')\n                self.copyright['year'] = child.findtext(metadata_elem('year'))\n                self.copyright['license'] = child.findtext(metadata_elem('license'))\n            elif tag_name == 'link':\n                link = {\n                    'href': child.get('href'),\n                    'type': child.findtext(metadata_elem('type')),\n                    'text': child.findtext(metadata_elem('text')),\n                }\n                self.link.append(link)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nimport locations from a GPX file.", "response": "def import_locations(self, gpx_file):\n        \"\"\"Import GPX data files.\n\n        ``import_locations()`` returns a list with :class:`~gpx.Waypoint`\n        objects.\n\n        It expects data files in GPX format, as specified in `GPX 1.1 Schema\n        Documentation`_, which is XML such as::\n\n            <?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n            <gpx version=\"1.1\" creator=\"PocketGPSWorld.com\"\n            xmlns=\"http://www.topografix.com/GPX/1/1\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\n\n              <wpt lat=\"52.015\" lon=\"-0.221\">\n                <name>Home</name>\n                <desc>My place</desc>\n              </wpt>\n              <wpt lat=\"52.167\" lon=\"0.390\">\n                <name>MSR</name>\n                <desc>Microsoft Research, Cambridge</desc>\n              </wpt>\n            </gpx>\n\n        The reader uses the :mod:`ElementTree` module, so should be very fast\n        when importing data.  The above file processed by\n        ``import_locations()`` will return the following ``list`` object::\n\n            [Waypoint(52.015, -0.221, \"Home\", \"My place\"),\n             Waypoint(52.167, 0.390, \"MSR\", \"Microsoft Research, Cambridge\")]\n\n        Args:\n            gpx_file (iter): GPX data to read\n\n        Returns:\n            list: Locations with optional comments\n\n        .. _GPX 1.1 Schema Documentation: http://www.topografix.com/GPX/1/1/\n        \"\"\"\n        self._gpx_file = gpx_file\n        data = utils.prepare_xml_read(gpx_file, objectify=True)\n\n        try:\n            self.metadata.import_metadata(data.metadata)\n        except AttributeError:\n            pass\n\n        for waypoint in data.wpt:\n            latitude = waypoint.get('lat')\n            longitude = waypoint.get('lon')\n            try:\n                name = waypoint.name.text\n            except AttributeError:\n                name = None\n            try:\n                description = waypoint.desc.text\n            except AttributeError:\n                description = None\n            try:\n                elevation = float(waypoint.ele.text)\n            except AttributeError:\n                elevation = None\n            try:\n                time = utils.Timestamp.parse_isoformat(waypoint.time.text)\n            except AttributeError:\n                time = None\n            self.append(Waypoint(latitude, longitude, name, description,\n                                 elevation, time))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate GPX element tree from waypoints object.", "response": "def export_gpx_file(self):\n        \"\"\"Generate GPX element tree from ``Waypoints`` object.\n\n        Returns:\n            etree.ElementTree: GPX element tree depicting ``Waypoints`` object\n        \"\"\"\n        gpx = create_elem('gpx', GPX_ELEM_ATTRIB)\n        if not self.metadata.bounds:\n            self.metadata.bounds = self[:]\n        gpx.append(self.metadata.togpx())\n        for place in self:\n            gpx.append(place.togpx())\n\n        return etree.ElementTree(gpx)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_locations(self, gpx_file):\n        self._gpx_file = gpx_file\n        data = utils.prepare_xml_read(gpx_file, objectify=True)\n\n        try:\n            self.metadata.import_metadata(data.metadata)\n        except AttributeError:\n            pass\n\n        for segment in data.trk.trkseg:\n            points = point.TimedPoints()\n            for trackpoint in segment.trkpt:\n                latitude = trackpoint.get('lat')\n                longitude = trackpoint.get('lon')\n                try:\n                    name = trackpoint.name.text\n                except AttributeError:\n                    name = None\n                try:\n                    description = trackpoint.desc.text\n                except AttributeError:\n                    description = None\n                try:\n                    elevation = float(trackpoint.ele.text)\n                except AttributeError:\n                    elevation = None\n                try:\n                    time = utils.Timestamp.parse_isoformat(trackpoint.time.text)\n                except AttributeError:\n                    time = None\n                points.append(Trackpoint(latitude, longitude, name,\n                                         description, elevation, time))\n            self.append(points)", "response": "Import GPX data files into a series of lists representing trackpoints with optional comments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_gpx_file(self):\n        gpx = create_elem('gpx', GPX_ELEM_ATTRIB)\n        if not self.metadata.bounds:\n            self.metadata.bounds = [j for i in self for j in i]\n        gpx.append(self.metadata.togpx())\n        track = create_elem('trk')\n        gpx.append(track)\n        for segment in self:\n            chunk = create_elem('trkseg')\n            track.append(chunk)\n            for place in segment:\n                chunk.append(place.togpx())\n\n        return etree.ElementTree(gpx)", "response": "Generate GPX element tree from Trackpoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports GPX data files into a series of lists representing trackQuickly loaded Routepoint objects.", "response": "def import_locations(self, gpx_file):\n        \"\"\"Import GPX data files.\n\n        ``import_locations()`` returns a series of lists representing track\n        segments with :class:`Routepoint` objects as contents.\n\n        It expects data files in GPX format, as specified in `GPX 1.1 Schema\n        Documentation`_, which is XML such as::\n\n            <?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n            <gpx version=\"1.1\" creator=\"upoints/0.12.2\"\n            xmlns=\"http://www.topografix.com/GPX/1/1\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\n              <rte>\n                <rtept lat=\"52.015\" lon=\"-0.221\">\n                  <name>Home</name>\n                  <desc>My place</desc>\n                </rtept>\n                <rtept lat=\"52.167\" lon=\"0.390\">\n                  <name>MSR</name>\n                  <desc>Microsoft Research, Cambridge</desc>\n                </rtept>\n              </rte>\n            </gpx>\n\n        The reader uses the :mod:`ElementTree` module, so should be very fast\n        when importing data.  The above file processed by\n        ``import_locations()`` will return the following ``list`` object::\n\n            [[Routepoint(52.015, -0.221, \"Home\", \"My place\"),\n              Routepoint(52.167, 0.390, \"MSR\", \"Microsoft Research, Cambridge\")], ]\n\n        Args:\n            gpx_file (iter): GPX data to read\n\n        Returns:\n            list: Locations with optional comments\n\n        .. _GPX 1.1 Schema Documentation: http://www.topografix.com/GPX/1/1/\n        \"\"\"\n        self._gpx_file = gpx_file\n        data = utils.prepare_xml_read(gpx_file, objectify=True)\n\n        try:\n            self.metadata.import_metadata(data.metadata)\n        except AttributeError:\n            pass\n\n        for route in data.rte:\n            points = point.TimedPoints()\n            for routepoint in route.rtept:\n                latitude = routepoint.get('lat')\n                longitude = routepoint.get('lon')\n                try:\n                    name = routepoint.name.text\n                except AttributeError:\n                    name = None\n                try:\n                    description = routepoint.desc.text\n                except AttributeError:\n                    description = None\n                try:\n                    elevation = float(routepoint.ele.text)\n                except AttributeError:\n                    elevation = None\n                try:\n                    time = utils.Timestamp.parse_isoformat(routepoint.time.text)\n                except AttributeError:\n                    time = None\n                points.append(Routepoint(latitude, longitude, name,\n                                         description, elevation, time))\n            self.append(points)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npreparing various input types for parsing with readlines.", "response": "def prepare_read(data, method='readlines', mode='r'):\n    \"\"\"Prepare various input types for parsing.\n\n    Args:\n        data (iter): Data to read\n        method (str): Method to process data with\n        mode (str): Custom mode to process with, if data is a file\n\n    Returns:\n        list: List suitable for parsing\n\n    Raises:\n        TypeError: Invalid value for data\n    \"\"\"\n    if hasattr(data, 'readlines'):\n        data = getattr(data, method)()\n    elif isinstance(data, list):\n        if method == 'read':\n            return ''.join(data)\n    elif isinstance(data, basestring):\n        data = getattr(open(data, mode), method)()\n    else:\n        raise TypeError('Unable to handle data of type %r' % type(data))\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_csv_read(data, field_names, *args, **kwargs):\n    if hasattr(data, 'readlines') or isinstance(data, list):\n        pass\n    elif isinstance(data, basestring):\n        data = open(data)\n    else:\n        raise TypeError('Unable to handle data of type %r' % type(data))\n    return csv.DictReader(data, field_names, *args, **kwargs)", "response": "Prepare various input types for CSV parsing."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares various input types for XML parsing.", "response": "def prepare_xml_read(data, objectify=False):\n    \"\"\"Prepare various input types for XML parsing.\n\n    Args:\n        data (iter): Data to read\n        objectify (bool): Parse using lxml's objectify data binding\n\n    Returns:\n        etree.ElementTree: Tree suitable for parsing\n\n    Raises:\n        TypeError: Invalid value for data\n    \"\"\"\n    mod = _objectify if objectify else etree\n    if hasattr(data, 'readlines'):\n        data = mod.parse(data).getroot()\n    elif isinstance(data, list):\n        data = mod.fromstring(''.join(data))\n    elif isinstance(data, basestring):\n        data = mod.parse(open(data)).getroot()\n    else:\n        raise TypeError('Unable to handle data of type %r' % type(data))\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a simple namespace - aware objectify element creator.", "response": "def element_creator(namespace=None):\n    \"\"\"Create a simple namespace-aware objectify element creator.\n\n    Args:\n        namespace (str): Namespace to work in\n\n    Returns:\n        function: Namespace-aware element creator\n    \"\"\"\n    ELEMENT_MAKER = _objectify.ElementMaker(namespace=namespace,\n                                            annotate=False)\n\n    def create_elem(tag, attr=None, text=None):\n        \"\"\":class:`objectify.Element` wrapper with namespace defined.\n\n        Args:\n            tag (str): Tag name\n            attr (dict): Default attributes for tag\n            text (str): Text content for the tag\n\n        Returns:\n            _objectify.ObjectifiedElement: objectify element\n        \"\"\"\n        if not attr:\n            attr = {}\n        if text:\n            element = getattr(ELEMENT_MAKER, tag)(text, **attr)\n        else:\n            element = getattr(ELEMENT_MAKER, tag)(**attr)\n        return element\n\n    return create_elem"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert decimal angle to degrees minutes and possibly seconds.", "response": "def to_dms(angle, style='dms'):\n    \"\"\"Convert decimal angle to degrees, minutes and possibly seconds.\n\n    Args:\n        angle (float): Angle to convert\n        style (str): Return fractional or whole minutes values\n\n    Returns:\n        tuple of int: Angle converted to degrees, minutes and possibly seconds\n\n    Raises:\n        ValueError: Unknown value for ``style``\n    \"\"\"\n    sign = 1 if angle >= 0 else -1\n    angle = abs(angle) * 3600\n    minutes, seconds = divmod(angle, 60)\n    degrees, minutes = divmod(minutes, 60)\n    if style == 'dms':\n        return tuple(sign * abs(i) for i in (int(degrees), int(minutes),\n                                             seconds))\n    elif style == 'dm':\n        return tuple(sign * abs(i) for i in (int(degrees),\n                                             (minutes + seconds / 60)))\n    else:\n        raise ValueError('Unknown style type %r' % style)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dd(degrees, minutes, seconds=0):\n    sign = -1 if any(i < 0 for i in (degrees, minutes, seconds)) else 1\n    return sign * (abs(degrees) + abs(minutes) / 60 + abs(seconds) / 3600)", "response": "Convert degrees minutes and seconds to decimal degrees."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a tuple of compass direction names.", "response": "def __chunk(segment, abbr=False):\n    \"\"\"Generate a ``tuple`` of compass direction names.\n\n    Args:\n        segment (list): Compass segment to generate names for\n        abbr (bool): Names should use single letter abbreviations\n\n    Returns:\n        bool: Direction names for compass segment\n    \"\"\"\n    names = ('north', 'east', 'south', 'west', 'north')\n    if not abbr:\n        sjoin = '-'\n    else:\n        names = [s[0].upper() for s in names]\n        sjoin = ''\n    if segment % 2 == 0:\n        return (names[segment].capitalize(),\n                sjoin.join((names[segment].capitalize(), names[segment],\n                            names[segment + 1])),\n                sjoin.join((names[segment].capitalize(), names[segment + 1])),\n                sjoin.join((names[segment + 1].capitalize(), names[segment],\n                            names[segment + 1])))\n    else:\n        return (names[segment].capitalize(),\n                sjoin.join((names[segment].capitalize(), names[segment + 1],\n                            names[segment])),\n                sjoin.join((names[segment + 1].capitalize(), names[segment])),\n                sjoin.join((names[segment + 1].capitalize(),\n                            names[segment + 1], names[segment])))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts angle in to direction name.", "response": "def angle_to_name(angle, segments=8, abbr=False):\n    \"\"\"Convert angle in to direction name.\n\n    Args:\n        angle (float): Angle in degrees to convert to direction name\n        segments (int): Number of segments to split compass in to\n        abbr (bool): Whether to return abbreviated direction string\n\n    Returns:\n        str: Direction name for ``angle``\n    \"\"\"\n    if segments == 4:\n        string = COMPASS_NAMES[int((angle + 45) / 90) % 4 * 2]\n    elif segments == 8:\n        string = COMPASS_NAMES[int((angle + 22.5) / 45) % 8 * 2]\n    elif segments == 16:\n        string = COMPASS_NAMES[int((angle + 11.25) / 22.5) % 16]\n    else:\n        raise ValueError('Segments parameter must be 4, 8 or 16 not %r'\n                         % segments)\n    if abbr:\n        return ''.join(i[0].capitalize() for i in string.split('-'))\n    else:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_iso6709(coordinates):\n    matches = iso6709_matcher.match(coordinates)\n    if matches:\n        latitude, longitude, altitude = matches.groups()\n    else:\n        raise ValueError('Incorrect format for string')\n    sign = 1 if latitude[0] == '+' else -1\n    latitude_head = len(latitude.split('.')[0])\n    if latitude_head == 3:  # \u00b1DD(.D{1,4})?\n        latitude = float(latitude)\n    elif latitude_head == 5:  # \u00b1DDMM(.M{1,4})?\n        latitude = float(latitude[:3]) + (sign * (float(latitude[3:]) / 60))\n    elif latitude_head == 7:  # \u00b1DDMMSS(.S{1,4})?\n        latitude = float(latitude[:3]) + (sign * (float(latitude[3:5]) / 60)) \\\n            + (sign * (float(latitude[5:]) / 3600))\n    else:\n        raise ValueError('Incorrect format for latitude %r' % latitude)\n    sign = 1 if longitude[0] == '+' else -1\n    longitude_head = len(longitude.split('.')[0])\n    if longitude_head == 4:  # \u00b1DDD(.D{1,4})?\n        longitude = float(longitude)\n    elif longitude_head == 6:  # \u00b1DDDMM(.M{1,4})?\n        longitude = float(longitude[:4]) + (sign * (float(longitude[4:]) / 60))\n    elif longitude_head == 8:  # \u00b1DDDMMSS(.S{1,4})?\n        longitude = float(longitude[:4]) \\\n            + (sign * (float(longitude[4:6]) / 60)) \\\n            + (sign * (float(longitude[6:]) / 3600))\n    else:\n        raise ValueError('Incorrect format for longitude %r' % longitude)\n    if altitude:\n        altitude = float(altitude)\n    return latitude, longitude, altitude", "response": "Parse ISO 6709 coordinate strings and return a new object with the ISO 6709 coordinates as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproducing ISO 6709 coordinate strings. This function will produce ISO 6709-1983(E) \"Standard representation of latitude, longitude and altitude for geographic point locations\" elements. See also: from_iso6709 Args: latitude (float): Location's latitude longitude (float): Location's longitude altitude (float): Location's altitude format (str): Format type for string precision (int): Latitude/longitude precision Returns: str: ISO 6709 coordinates string Raises: ValueError: Unknown value for ``format`` .. _Latitude, Longitude and Altitude format for geospatial information: http://www.w3.org/2005/Incubator/geo/Wiki/LatitudeLongitudeAltitude .. _wikipedia ISO 6709 page: http://en.wikipedia.org/wiki/ISO_6709", "response": "def to_iso6709(latitude, longitude, altitude=None, format='dd', precision=4):\n    \"\"\"Produce ISO 6709 coordinate strings.\n\n    This function will produce ISO 6709-1983(E) \"Standard representation of\n    latitude, longitude and altitude for geographic point locations\" elements.\n\n    See also:\n       from_iso6709\n\n    Args:\n        latitude (float): Location's latitude\n        longitude (float): Location's longitude\n        altitude (float): Location's altitude\n        format (str): Format type for string\n        precision (int): Latitude/longitude precision\n\n    Returns:\n        str: ISO 6709 coordinates string\n\n    Raises:\n        ValueError: Unknown value for ``format``\n\n    .. _Latitude, Longitude and Altitude format for geospatial information:\n       http://www.w3.org/2005/Incubator/geo/Wiki/LatitudeLongitudeAltitude\n    .. _wikipedia ISO 6709 page: http://en.wikipedia.org/wiki/ISO_6709\n    \"\"\"\n    text = []\n    if format == 'd':\n        text.append('%+03i%+04i' % (latitude, longitude))\n    elif format == 'dd':\n        text.append('%+0*.*f%+0*.*f' % (precision + 4, precision, latitude,\n                                        precision + 5, precision, longitude))\n    elif format in ('dm', 'dms'):\n        if format == 'dm':\n            latitude_dms = to_dms(latitude, 'dm')\n            longitude_dms = to_dms(longitude, 'dm')\n        elif format == 'dms':\n            latitude_dms = to_dms(latitude)\n            longitude_dms = to_dms(longitude)\n        latitude_sign = '-' if any(i < 0 for i in latitude_dms) else '+'\n        latitude_dms = tuple(abs(i) for i in latitude_dms)\n        longitude_sign = '-' if any(i < 0 for i in longitude_dms) else '+'\n        longitude_dms = tuple(abs(i) for i in longitude_dms)\n        if format == 'dm':\n            text.append('%s%02i%02i' % ((latitude_sign, ) + latitude_dms))\n            text.append('%s%03i%02i' % ((longitude_sign, ) + longitude_dms))\n        elif format == 'dms':\n            text.append('%s%02i%02i%02i' % ((latitude_sign, ) + latitude_dms))\n            text.append('%s%03i%02i%02i'\n                        % ((longitude_sign, ) + longitude_dms))\n    else:\n        raise ValueError('Unknown format type %r' % format)\n    if altitude and int(altitude) == altitude:\n        text.append('%+i' % altitude)\n    elif altitude:\n        text.append('%+.3f' % altitude)\n    text.append('/')\n    return ''.join(text)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef angle_to_distance(angle, units='metric'):\n    distance = math.radians(angle) * BODY_RADIUS\n\n    if units in ('km', 'metric'):\n        return distance\n    elif units in ('sm', 'imperial', 'US customary'):\n        return distance / STATUTE_MILE\n    elif units in ('nm', 'nautical'):\n        return distance / NAUTICAL_MILE\n    else:\n        raise ValueError('Unknown units type %r' % units)", "response": "Convert angle in to distance along a great circle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a distance in to an angle along a great circle.", "response": "def distance_to_angle(distance, units='metric'):\n    \"\"\"Convert a distance in to an angle along a great circle.\n\n    Args:\n        distance (float): Distance to convert to degrees\n        units (str): Unit type to be used for distances\n\n    Returns:\n        float: Angle in degrees\n\n    Raises:\n        ValueError: Unknown value for ``units``\n    \"\"\"\n    if units in ('km', 'metric'):\n        pass\n    elif units in ('sm', 'imperial', 'US customary'):\n        distance *= STATUTE_MILE\n    elif units in ('nm', 'nautical'):\n        distance *= NAUTICAL_MILE\n    else:\n        raise ValueError('Unknown units type %r' % units)\n\n    return math.degrees(distance / BODY_RADIUS)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_grid_locator(locator):\n    if not len(locator) in (4, 6, 8):\n        raise ValueError('Locator must be 4, 6 or 8 characters long %r'\n                         % locator)\n\n    # Convert the locator string to a list, because we need it to be mutable to\n    # munge the values\n    locator = list(locator)\n\n    # Convert characters to numeric value, fields are always uppercase\n    locator[0] = ord(locator[0]) - 65\n    locator[1] = ord(locator[1]) - 65\n\n    # Values for square are always integers\n    locator[2] = int(locator[2])\n    locator[3] = int(locator[3])\n\n    if len(locator) >= 6:\n        # Some people use uppercase for the subsquare data, in spite of\n        # lowercase being the accepted style, so handle that too.\n        locator[4] = ord(locator[4].lower()) - 97\n        locator[5] = ord(locator[5].lower()) - 97\n\n    if len(locator) == 8:\n        # Extended square values are always integers\n        locator[6] = int(locator[6])\n        locator[7] = int(locator[7])\n\n    # Check field values within 'A'(0) to 'R'(17), and square values are within\n    # 0 to 9\n    if not 0 <= locator[0] <= 17 \\\n       or not 0 <= locator[1] <= 17 \\\n       or not 0 <= locator[2] <= 9 \\\n       or not 0 <= locator[3] <= 9:\n        raise ValueError('Invalid values in locator %r' % locator)\n\n    # Check subsquare values are within 'a'(0) to 'x'(23)\n    if len(locator) >= 6:\n        if not 0 <= locator[4] <= 23 \\\n           or not 0 <= locator[5] <= 23:\n            raise ValueError('Invalid values in locator %r' % locator)\n\n    # Extended square values must be within 0 to 9\n    if len(locator) == 8:\n        if not 0 <= locator[6] <= 9 \\\n           or not 0 <= locator[7] <= 9:\n            raise ValueError('Invalid values in locator %r' % locator)\n\n    longitude = LONGITUDE_FIELD * locator[0] \\\n        + LONGITUDE_SQUARE * locator[2]\n    latitude = LATITUDE_FIELD * locator[1] \\\n        + LATITUDE_SQUARE * locator[3]\n\n    if len(locator) >= 6:\n        longitude += LONGITUDE_SUBSQUARE * locator[4]\n        latitude += LATITUDE_SUBSQUARE * locator[5]\n\n    if len(locator) == 8:\n        longitude += LONGITUDE_EXTSQUARE * locator[6] + LONGITUDE_EXTSQUARE / 2\n        latitude += LATITUDE_EXTSQUARE * locator[7] + LATITUDE_EXTSQUARE / 2\n    else:\n        longitude += LONGITUDE_EXTSQUARE * 5\n        latitude += LATITUDE_EXTSQUARE * 5\n\n    # Rebase longitude and latitude to normal geodesic\n    longitude -= 180\n    latitude -= 90\n\n    return latitude, longitude", "response": "Calculate geodesic latitude and longitude from Maidenhead locator string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_grid_locator(latitude, longitude, precision='square'):\n    if precision not in ('square', 'subsquare', 'extsquare'):\n        raise ValueError('Unsupported precision value %r' % precision)\n\n    if not -90 <= latitude <= 90:\n        raise ValueError('Invalid latitude value %r' % latitude)\n    if not -180 <= longitude <= 180:\n        raise ValueError('Invalid longitude value %r' % longitude)\n\n    latitude += 90.0\n    longitude += 180.0\n\n    locator = []\n\n    field = int(longitude / LONGITUDE_FIELD)\n    locator.append(chr(field + 65))\n    longitude -= field * LONGITUDE_FIELD\n\n    field = int(latitude / LATITUDE_FIELD)\n    locator.append(chr(field + 65))\n    latitude -= field * LATITUDE_FIELD\n\n    square = int(longitude / LONGITUDE_SQUARE)\n    locator.append(str(square))\n    longitude -= square * LONGITUDE_SQUARE\n\n    square = int(latitude / LATITUDE_SQUARE)\n    locator.append(str(square))\n    latitude -= square * LATITUDE_SQUARE\n\n    if precision in ('subsquare', 'extsquare'):\n        subsquare = int(longitude / LONGITUDE_SUBSQUARE)\n        locator.append(chr(subsquare + 97))\n        longitude -= subsquare * LONGITUDE_SUBSQUARE\n\n        subsquare = int(latitude / LATITUDE_SUBSQUARE)\n        locator.append(chr(subsquare + 97))\n        latitude -= subsquare * LATITUDE_SUBSQUARE\n\n    if precision == 'extsquare':\n        extsquare = int(longitude / LONGITUDE_EXTSQUARE)\n        locator.append(str(extsquare))\n\n        extsquare = int(latitude / LATITUDE_EXTSQUARE)\n        locator.append(str(extsquare))\n\n    return ''.join(locator)", "response": "Returns a Maidenhead locator string for a given latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a string location into a tuple of latitude and longitude of the current node.", "response": "def parse_location(location):\n    \"\"\"Parse latitude and longitude from string location.\n\n    Args:\n        location (str): String to parse\n\n    Returns:\n        tuple of float: Latitude and longitude of location\n    \"\"\"\n    def split_dms(text, hemisphere):\n        \"\"\"Split degrees, minutes and seconds string.\n\n        Args:\n            text (str): Text to split\n\n        Returns::\n            float: Decimal degrees\n        \"\"\"\n        out = []\n        sect = []\n        for i in text:\n            if i.isdigit():\n                sect.append(i)\n            else:\n                out.append(sect)\n                sect = []\n        d, m, s = [float(''.join(i)) for i in out]\n        if hemisphere in 'SW':\n            d, m, s = [-1 * x for x in (d, m, s)]\n        return to_dd(d, m, s)\n\n    for sep in ';, ':\n        chunks = location.split(sep)\n        if len(chunks) == 2:\n            if chunks[0].endswith('N'):\n                latitude = float(chunks[0][:-1])\n            elif chunks[0].endswith('S'):\n                latitude = -1 * float(chunks[0][:-1])\n            else:\n                latitude = float(chunks[0])\n            if chunks[1].endswith('E'):\n                longitude = float(chunks[1][:-1])\n            elif chunks[1].endswith('W'):\n                longitude = -1 * float(chunks[1][:-1])\n            else:\n                longitude = float(chunks[1])\n            return latitude, longitude\n        elif len(chunks) == 4:\n            if chunks[0].endswith(('s', '\"')):\n                latitude = split_dms(chunks[0], chunks[1])\n            else:\n                latitude = float(chunks[0])\n                if chunks[1] == 'S':\n                    latitude = -1 * latitude\n            if chunks[2].endswith(('s', '\"')):\n                longitude = split_dms(chunks[2], chunks[3])\n            else:\n                longitude = float(chunks[2])\n                if chunks[3] == 'W':\n                    longitude = -1 * longitude\n            return latitude, longitude"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating sunrise or sunset for a specific location. This function calculates the time sunrise or sunset, or optionally the beginning or end of a specified twilight period. Source:: Almanac for Computers, 1990 published by Nautical Almanac Office United States Naval Observatory Washington, DC 20392 Args: latitude (float): Location's latitude longitude (float): Location's longitude date (datetime.date): Calculate rise or set for given date mode (str): Which time to calculate timezone (int): Offset from UTC in minutes zenith (str): Calculate rise/set events, or twilight times Returns: datetime.time or None: The time for the given event in the specified timezone, or ``None`` if the event doesn't occur on the given date Raises: ValueError: Unknown value for ``mode``", "response": "def sun_rise_set(latitude, longitude, date, mode='rise', timezone=0,\n                 zenith=None):\n    \"\"\"Calculate sunrise or sunset for a specific location.\n\n    This function calculates the time sunrise or sunset, or optionally the\n    beginning or end of a specified twilight period.\n\n    Source::\n\n        Almanac for Computers, 1990\n        published by Nautical Almanac Office\n        United States Naval Observatory\n        Washington, DC 20392\n\n    Args:\n        latitude (float): Location's latitude\n        longitude (float): Location's longitude\n        date (datetime.date): Calculate rise or set for given date\n        mode (str): Which time to calculate\n        timezone (int): Offset from UTC in minutes\n        zenith (str): Calculate rise/set events, or twilight times\n\n    Returns:\n        datetime.time or None: The time for the given event in the specified\n            timezone, or ``None`` if the event doesn't occur on the given date\n\n    Raises:\n        ValueError: Unknown value for ``mode``\n    \"\"\"\n    if not date:\n        date = datetime.date.today()\n\n    zenith = ZENITH[zenith]\n\n    # First calculate the day of the year\n    # Thanks, datetime this would have been ugly without you!!!\n    n = (date - datetime.date(date.year - 1, 12, 31)).days\n\n    # Convert the longitude to hour value and calculate an approximate time\n    lng_hour = longitude / 15\n\n    if mode == 'rise':\n        t = n + ((6 - lng_hour) / 24)\n    elif mode == 'set':\n        t = n + ((18 - lng_hour) / 24)\n    else:\n        raise ValueError('Unknown mode value %r' % mode)\n\n    # Calculate the Sun's mean anomaly\n    m = (0.9856 * t) - 3.289\n\n    # Calculate the Sun's true longitude\n    l = m + 1.916 * math.sin(math.radians(m)) + 0.020 \\\n        * math.sin(2 * math.radians(m)) + 282.634\n    l = abs(l) % 360\n\n    # Calculate the Sun's right ascension\n    ra = math.degrees(math.atan(0.91764 * math.tan(math.radians(l))))\n\n    # Right ascension value needs to be in the same quadrant as L\n    l_quandrant = (math.floor(l / 90)) * 90\n    ra_quandrant = (math.floor(ra / 90)) * 90\n    ra = ra + (l_quandrant - ra_quandrant)\n\n    # Right ascension value needs to be converted into hours\n    ra = ra / 15\n\n    # Calculate the Sun's declination\n    sin_dec = 0.39782 * math.sin(math.radians(l))\n    cos_dec = math.cos(math.asin(sin_dec))\n\n    # Calculate the Sun's local hour angle\n    cos_h = (math.radians(zenith) -\n             (sin_dec * math.sin(math.radians(latitude)))) \\\n        / (cos_dec * math.cos(math.radians(latitude)))\n\n    if cos_h > 1:\n        # The sun never rises on this location (on the specified date)\n        return None\n    elif cos_h < -1:\n        # The sun never sets on this location (on the specified date)\n        return None\n\n    # Finish calculating H and convert into hours\n    if mode == 'rise':\n        h = 360 - math.degrees(math.acos(cos_h))\n    else:\n        h = math.degrees(math.acos(cos_h))\n    h = h / 15\n\n    # Calculate local mean time of rising/setting\n    t = h + ra - (0.06571 * t) - 6.622\n\n    # Adjust back to UTC\n    utc = t - lng_hour\n\n    # Convert UT value to local time zone of latitude/longitude\n    local_t = utc + timezone / 60\n    if local_t < 0:\n        local_t += 24\n    elif local_t > 23:\n        local_t -= 24\n\n    hour = int(local_t)\n    if hour == 0:\n        minute = int(60 * local_t)\n    else:\n        minute = int(60 * (local_t % hour))\n    if minute < 0:\n        minute += 60\n    return datetime.time(hour, minute)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sun_events(latitude, longitude, date, timezone=0, zenith=None):\n    return (sun_rise_set(latitude, longitude, date, 'rise', timezone, zenith),\n            sun_rise_set(latitude, longitude, date, 'set', timezone, zenith))", "response": "Convenience function for calculating sunrise and sunset events for a given location."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an Xearth compatible marker file from a list of dictionaries.", "response": "def dump_xearth_markers(markers, name='identifier'):\n    \"\"\"Generate an Xearth compatible marker file.\n\n    ``dump_xearth_markers()`` writes a simple Xearth_ marker file from\n    a dictionary of :class:`trigpoints.Trigpoint` objects.\n\n    It expects a dictionary in one of the following formats. For support of\n    :class:`Trigpoint` that is::\n\n        {500936: Trigpoint(52.066035, -0.281449, 37.0, \"Broom Farm\"),\n         501097: Trigpoint(52.010585, -0.173443, 97.0, \"Bygrave\"),\n         505392: Trigpoint(51.910886, -0.186462, 136.0, \"Sish Lane\")}\n\n    And generates output of the form::\n\n        52.066035 -0.281449 \"500936\" # Broom Farm, alt 37m\n        52.010585 -0.173443 \"501097\" # Bygrave, alt 97m\n        51.910886 -0.186462 \"205392\" # Sish Lane, alt 136m\n\n    Or similar to the following if the ``name`` parameter is set to ``name``::\n\n        52.066035 -0.281449 \"Broom Farm\" # 500936 alt 37m\n        52.010585 -0.173443 \"Bygrave\" # 501097 alt 97m\n        51.910886 -0.186462 \"Sish Lane\" # 205392 alt 136m\n\n    Point objects should be provided in the following format::\n\n        {\"Broom Farm\": Point(52.066035, -0.281449),\n         \"Bygrave\": Point(52.010585, -0.173443),\n         \"Sish Lane\": Point(51.910886, -0.186462)}\n\n    And generates output of the form::\n\n        52.066035 -0.281449 \"Broom Farm\"\n        52.010585 -0.173443 \"Bygrave\"\n        51.910886 -0.186462 \"Sish Lane\"\n\n    Note:\n        xplanet_ also supports xearth marker files, and as such can use the\n        output from this function.\n\n    See also:\n       upoints.xearth.Xearths.import_locations\n\n    Args:\n        markers (dict): Dictionary of identifier keys, with :class:`Trigpoint`\n            values\n        name (str): Value to use as Xearth display string\n\n    Returns:\n        list: List of strings representing an Xearth marker file\n\n    Raises:\n        ValueError: Unsupported value for ``name``\n\n    .. _xearth: http://hewgill.com/xearth/original/\n    .. _xplanet: http://xplanet.sourceforge.net/\n    \"\"\"\n    output = []\n    for identifier, point in markers.items():\n        line = ['%f %f ' % (point.latitude, point.longitude), ]\n        if hasattr(point, 'name') and point.name:\n            if name == 'identifier':\n                line.append('\"%s\" # %s' % (identifier, point.name))\n            elif name == 'name':\n                line.append('\"%s\" # %s' % (point.name, identifier))\n            elif name == 'comment':\n                line.append('\"%s\" # %s' % (identifier, point.comment))\n            else:\n                raise ValueError('Unknown name type %r' % name)\n            if hasattr(point, 'altitude') and point.altitude:\n                line.append(', alt %im' % point.altitude)\n        else:\n            line.append('\"%s\"' % identifier)\n        output.append(''.join(line))\n    # Return the list sorted on the marker name\n    return sorted(output, key=lambda x: x.split()[2])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calc_radius(latitude, ellipsoid='WGS84'):\n    ellipsoids = {\n        'Airy (1830)': (6377.563, 6356.257),  # Ordnance Survey default\n        'Bessel': (6377.397, 6356.079),\n        'Clarke (1880)': (6378.249145, 6356.51486955),\n        'FAI sphere': (6371, 6371),  # Idealised\n        'GRS-67': (6378.160, 6356.775),\n        'International': (6378.388, 6356.912),\n        'Krasovsky': (6378.245, 6356.863),\n        'NAD27': (6378.206, 6356.584),\n        'WGS66': (6378.145, 6356.758),\n        'WGS72': (6378.135, 6356.751),\n        'WGS84': (6378.137, 6356.752),  # GPS default\n    }\n\n    # Equatorial radius, polar radius\n    major, minor = ellipsoids[ellipsoid]\n    # eccentricity of the ellipsoid\n    eccentricity = 1 - (minor ** 2 / major ** 2)\n\n    sl = math.sin(math.radians(latitude))\n    return (major * (1 - eccentricity)) / (1 - eccentricity * sl ** 2) ** 1.5", "response": "Calculate the earth radius for a given latitude."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isoformat(self):\n        text = [self.strftime('%Y-%m-%dT%H:%M:%S'), ]\n        if self.tzinfo:\n            text.append(self.tzinfo.as_timezone())\n        else:\n            text.append('+00:00')\n        return ''.join(text)", "response": "Generate an ISO 8601 formatted time stamp."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_isoformat(timestamp):\n        if len(timestamp) == 20:\n            zone = TzOffset('+00:00')\n            timestamp = timestamp[:-1]\n        elif len(timestamp) == 24:\n            zone = TzOffset('%s:%s' % (timestamp[-5:-2], timestamp[-2:]))\n            timestamp = timestamp[:-5]\n        elif len(timestamp) == 25:\n            zone = TzOffset(timestamp[-6:])\n            timestamp = timestamp[:-6]\n        timestamp = Timestamp.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')\n        timestamp = timestamp.replace(tzinfo=zone)\n        return timestamp", "response": "Parse an ISO 8601 formatted time stamp."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwaits until generator is paused before running method.", "response": "def _wait(self, generator, method, timeout=None, *args, **kwargs):\n        \"\"\"Wait until generator is paused before running 'method'.\"\"\"\n        if self.debug:\n            print(\"waiting for %s to pause\" % generator)\n\n        original_timeout = timeout\n        while timeout is None or timeout > 0:\n            last_time = time.time()\n            if self._lock.acquire(False):  # timeout param was added in 3.2\n                try:\n                    if self.can_resume():\n                        return method(generator, *args, **kwargs)\n                    elif self.has_terminated():\n                        raise RuntimeError(\"%s has already terminated\" % generator)\n                finally:\n                    self._lock.release()\n\n            if timeout is not None:\n                timeout -= time.time() - last_time\n\n        msg = \"%s did not pause after %ss\" % (generator, original_timeout)\n        if self.debug:\n            print(msg)\n        raise WaitTimeoutError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if the generator can be resumed i. e. is not running or closed.", "response": "def can_resume(self):\n        \"\"\"Test if the generator can be resumed, i.e. is not running or closed.\"\"\"\n        # TOCHECK relies on generator.gi_frame\n        # Equivalent to `inspect.getgeneratorstate(self.generator) in\n        # (inspect.GEN_CREATED, inspect.GEN_SUSPENDED)`,\n        # which is only available starting 3.2.\n        gen = self.generator\n        return (gen is not None\n                and not gen.gi_running\n                and gen.gi_frame is not None)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ansi_c_quoting(s):\n    '''shlex does not handle ANSI-C Quoting properly. Words of the form\n    $'string' are treated specially. The word expands to string, with\n    backslash-escaped characters replaced as specified by the ANSI C\n    standard. This is a hacky workaround to parse these the way we want to.'''\n    in_single_quotes = False\n    in_double_quotes = False\n    maybe_ansi_c_quote = False\n    in_ansi_c_quote = False\n    to_del = []\n    s = list(s)\n\n    for index, ch in enumerate(s):\n        if ch == '\\'':\n            if in_ansi_c_quote:\n                in_ansi_c_quote = toggle(in_ansi_c_quote)\n                s[index] = '\"'\n            else:\n                in_single_quotes = toggle(in_single_quotes)\n        if ch == '\"':\n            if in_ansi_c_quote:\n                s[index] = '\\\\\"'\n            else:\n                in_double_quotes = toggle(in_double_quotes)\n        if ch == '$' and not in_single_quotes and not in_double_quotes:\n            maybe_ansi_c_quote = True\n        if maybe_ansi_c_quote and ch == '\\'':\n            maybe_ansi_c_quote = False\n            in_ansi_c_quote = True\n            s[index] = '\"'\n            to_del.append(index-1)\n        if in_ansi_c_quote and ch in '\\a\\b\\f\\n\\r\\t\\v':\n            s[index] = repr(ch)[1:-1]\n    to_del.reverse()\n    for i in to_del:\n        del s[i]\n    return ''.join(s)", "response": "shlex does not handle ANSI - C Quoting properly. Words of the form\n    string are treated specially."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nappends opening tags to document body list.", "response": "def visit(spht, node):\n        \"\"\"Append opening tags to document body list.\n\n        :param sphinx.writers.html.SmartyPantsHTMLTranslator spht: Object to modify.\n        :param sphinxcontrib.imgur.nodes.ImgurJavaScriptNode node: This class' instance.\n        \"\"\"\n        html_attrs_bq = {'async': '', 'src': '//s.imgur.com/min/embed.js', 'charset': 'utf-8'}\n        spht.body.append(spht.starttag(node, 'script', '', **html_attrs_bq))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending opening tags to document body list.", "response": "def visit(spht, node):\n        \"\"\"Append opening tags to document body list.\n\n        :param sphinx.writers.html.SmartyPantsHTMLTranslator spht: Object to modify.\n        :param sphinxcontrib.imgur.nodes.ImgurEmbedNode node: This class' instance.\n        \"\"\"\n        html_attrs_bq = {'CLASS': 'imgur-embed-pub', 'lang': spht.settings.language_code, 'data-id': node.imgur_id}\n        if node.hide_post_details:\n            html_attrs_bq['data-context'] = 'false'\n        spht.body.append(spht.starttag(node, 'blockquote', '', **html_attrs_bq))\n        html_attrs_ah = dict(href='https://imgur.com/{}'.format(node.imgur_id), CLASS='reference external')\n        spht.body.append(spht.starttag(node, 'a', 'Loading...', **html_attrs_ah))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates attributes after Sphinx cache is updated. :param dict album_cache: Cache of Imgur albums to read. Keys are Imgur IDs, values are Album instances. :param dict image_cache: Cache of Imgur images to read. Keys are Imgur IDs, values are Image instances. :param function warn_node: sphinx.environment.BuildEnvironment.warn_node without needing node argument.", "response": "def finalize(self, album_cache, image_cache, warn_node):\n        \"\"\"Update attributes after Sphinx cache is updated.\n\n        :param dict album_cache: Cache of Imgur albums to read. Keys are Imgur IDs, values are Album instances.\n        :param dict image_cache: Cache of Imgur images to read. Keys are Imgur IDs, values are Image instances.\n        :param function warn_node: sphinx.environment.BuildEnvironment.warn_node without needing node argument.\n        \"\"\"\n        album = album_cache[self.imgur_id] if self.album else None\n        image = image_cache[album.cover_id] if self.album else image_cache[self.imgur_id]\n        options = self.options\n\n        # Determine target. Code in directives.py handles defaults and unsets target_* if :target: is set.\n        if options['target_gallery'] and (album.in_gallery if album else image.in_gallery):\n            options['target'] = '//imgur.com/gallery/{}'.format(album.imgur_id if album else image.imgur_id)\n        elif options['target_page']:\n            options['target'] = '//imgur.com/{}'.format(album.imgur_id if album else image.imgur_id)\n        elif options['target_largest'] and not album:\n            options['target'] = '//i.imgur.com/' + image.filename(full_size=True)\n        elif not options['target'] and (options['width'] or options['height'] or options['scale']):\n            options['target'] = '//i.imgur.com/' + image.filename(full_size=True)\n\n        # Handle scale with no API data.\n        if options['scale']:\n            if not image.width and not options['width'] and not image.height and not options['height']:\n                options['scale'] = ''\n                warn_node('Could not obtain image size. :scale: option is ignored.')\n            elif not image.width and not options['width']:\n                warn_node('Could not obtain image width. :scale: option is partially ignored.')\n            elif not image.width or not image.height:\n                warn_node('Could not obtain image height. :scale: option is partially ignored.')\n\n        # Handle scale, width, and height.\n        if options['scale'] and (options['width'] or image.width):\n            match = RE_WIDTH_HEIGHT.match(options['width'] or '%dpx' % image.width)\n            options['width'] = '{}{}'.format(int(float(match.group(1)) * (options['scale'] / 100.0)), match.group(2))\n        if options['scale'] and (options['height'] or image.height):\n            match = RE_WIDTH_HEIGHT.match(options['height'] or '%dpx' % image.height)\n            options['height'] = '{}{}'.format(int(float(match.group(1)) * (options['scale'] / 100.0)), match.group(2))\n\n        # Set src and style.\n        self.src = '//i.imgur.com/' + image.filename(options['width'], options['height'])\n        style = [p for p in ((k, options[k]) for k in ('width', 'height')) if p[1]]\n        if style:\n            self.style = '; '.join('{}: {}'.format(k, v) for k, v in style)\n\n        # Determine alt text.\n        if not options['alt']:\n            options['alt'] = image.title or self.src[2:]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending opening tags to document body list.", "response": "def visit(spht, node):\n        \"\"\"Append opening tags to document body list.\n\n        :param sphinx.writers.html.SmartyPantsHTMLTranslator spht: Object to modify.\n        :param sphinxcontrib.imgur.nodes.ImgurImageNode node: This class' instance.\n        \"\"\"\n        if node.options['target']:\n            html_attrs_ah = dict(CLASS='reference external image-reference', href=node.options['target'])\n            spht.body.append(spht.starttag(node, 'a', '', **html_attrs_ah))\n\n        html_attrs_img = dict(src=node.src, alt=node.options['alt'])\n        if node.options['align']:\n            html_attrs_img['CLASS'] = 'align-{}'.format(node.options['align'])\n        if node.style:\n            html_attrs_img['style'] = node.style\n        spht.body.append(spht.starttag(node, 'img', '' if node.options['target'] else '\\n', **html_attrs_img))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_errors(self):\n        # use this to make sure that sweep, sstart, sstop, and sinterval\n        # all have values if one of them has values\n        # (P^Q^R^S) OR (-P and -Q and -R and -S)\n        # above is the minimal form for this logical statement in DNF\n        if not ((self._inn(self.args.sweep) and self._inn(self.args.sstart)\n                 and self._inn(self.args.sstop) and self._inn(self.args.sinterval))\n                or\n                (not self._inn(self.args.sweep) and not self._inn(self.args.sstart) and not\n                 self._inn(self.args.sstop) and not self._inn(self.args.sinterval))):\n            mutually_inclusive = [\"sweep\", \"sstart\", \"sstop\", \"sinterval\"]\n            print_str = \"\"\n            for each in mutually_inclusive:\n                print_str += \"    {0}: {1}\\n\".format(each, getattr(self.args, each))\n            raise AssertionError(\"\"\"You specified one or more of the --sweep,\n            --sstart, --stop, or --sinterval arguments but did not specify all of\n            them. All of them are required when running the program in sweep mode.\n            Do not specify any of these arguments if not running the program in\n            sweep mode.\\n{0}\"\"\".format(print_str))", "response": "Check if there are any errors in the arguments for sweep make\n        and raise an AssertionError if there are any errors."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_content(self, path):\n        \"Attempts to open the file and read the content.\"\n        log.debug('Opening {0} in {1} load_content'.format(path, __name__))\n        with open(path) as fin:\n            self.path = path\n            self.content = fin.read()", "response": "Attempts to open the file and read the content."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compute_allele_frequencies(self, using=None):\n        \"Computes the allele frequencies across all samples in this cohort.\"\n        if using is None:\n            using = router.db_for_write(self.__class__)\n        cursor = connections[using].cursor()\n\n        with transition(self, 'Recomputed Allele Frequencies'):\n            with transaction.commit_manually(using):\n                # TODO update to use model._meta.db_table..\n                try:\n                    # Update count on cohort instance\n                    cursor.execute('''\n                        UPDATE \"cohort\" SET \"count\" = (\n                            SELECT COUNT(id)\n                            FROM \"cohort_sample\"\n                            WHERE \"cohort_id\" = \"cohort\".\"id\"\n                        ) WHERE \"id\" = %s\n                    ''', [self.id])\n\n                    # Calculate frequencies for all variants associated with\n                    # all samples in this cohort\n                    cursor.execute('''\n                        INSERT INTO cohort_variant (cohort_id, variant_id, af)\n                        (\n                            SELECT c.id, r.variant_id,\n                                COUNT(r.id) / c.\"count\"::float\n                            FROM sample_result r\n                                INNER JOIN sample s ON (r.sample_id = s.id)\n                                INNER JOIN cohort_sample cs ON\n                                    (cs.sample_id = s.id)\n                                INNER JOIN cohort c ON (cs.cohort_id = c.id)\n                            WHERE c.id = %s\n                            GROUP BY c.id, r.variant_id, c.\"count\"\n                        )\n                    ''', [self.id])\n                    transaction.commit()\n                except DatabaseError, e:\n                    transaction.rollback()\n                    log.exception(e)\n                    raise", "response": "Computes the allele frequencies across all samples in this cohort."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        samples = orm['samples.Sample'].objects.select_related('batch__project')\n        for sample in samples:\n            sample.project = sample.batch.project\n            sample.save()", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the locator and trigger a latitude and longitude update.", "response": "def locator(self, value):\n        \"\"\"Update the locator, and trigger a latitude and longitude update.\n\n        Args:\n            value (str): New Maidenhead locator string\n        \"\"\"\n        self._locator = value\n        self._latitude, self._longitude = utils.from_grid_locator(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport the locations from the baken data files and returns a dictionary containing the names and values of the baken objects.", "response": "def import_locations(self, baken_file):\n        \"\"\"Import baken data files.\n\n        ``import_locations()`` returns a dictionary with keys containing the\n        section title, and values consisting of a collection :class:`Baken`\n        objects.\n\n        It expects data files in the format used by the baken_ amateur radio\n        package, which is Windows INI style files such as:\n\n        .. code-block:: ini\n\n            [Abeche, Chad]\n            latitude=14.460000\n            longitude=20.680000\n            height=0.000000\n\n            [GB3BUX]\n            frequency=50.000\n            locator=IO93BF\n            power=25 TX\n            antenna=2 x Turnstile\n            height=460\n            mode=A1A\n\n        The reader uses the :mod:`configparser` module, so should be reasonably\n        robust against encodings and such.  The above file processed by\n        ``import_locations()`` will return the following ``dict`` object::\n\n            {\"Abeche, Chad\": Baken(14.460, 20.680, None, None, None, 0.000,\n                                   None, None, None, None, None),\n             \"GB3BUX\": : Baken(None, None, \"2 x Turnstile\", None, 50.000,\n                               460.000, \"IO93BF\", \"A1A\", None, 25, None)}\n\n        Args::\n            baken_file (iter): Baken data to read\n\n        Returns:\n            dict: Named locations and their associated values\n\n        .. _baken: http://www.qsl.net:80/g4klx/\n        \"\"\"\n        self._baken_file = baken_file\n        data = ConfigParser()\n        if hasattr(baken_file, 'readlines'):\n            data.readfp(baken_file)\n        elif isinstance(baken_file, list):\n            data.read(baken_file)\n        elif isinstance(baken_file, basestring):\n            data.readfp(open(baken_file))\n        else:\n            raise TypeError('Unable to handle data of type %r'\n                            % type(baken_file))\n        valid_locator = re.compile(r\"[A-Z]{2}\\d{2}[A-Z]{2}\")\n        for name in data.sections():\n            elements = {}\n            for item in ('latitude', 'longitude', 'antenna', 'direction',\n                         'frequency', 'height', 'locator', 'mode', 'operator',\n                         'power', 'qth'):\n                if data.has_option(name, item):\n                    if item in ('antenna', 'locator', 'mode', 'power', 'qth'):\n                        elements[item] = data.get(name, item)\n                    elif item == 'operator':\n                        elements[item] = elements[item].split(',')\n                    elif item == 'direction':\n                        elements[item] = data.get(name, item).split(',')\n                    else:\n                        try:\n                            elements[item] = data.getfloat(name, item)\n                        except ValueError:\n                            logging.debug('Multiple frequency workaround for '\n                                          '%r entry' % name)\n                            elements[item] = \\\n                                map(float, data.get(name, item).split(','))\n                else:\n                    elements[item] = None\n            if elements['latitude'] is None \\\n               and not valid_locator.match(elements['locator']):\n                logging.info('Skipping %r entry, as it contains no location '\n                             'data' % name)\n                continue\n\n            self[name] = Baken(**elements)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when schedule is intialized. Fetch schedules from DB etc here", "response": "def setup_schedule(self):\n        \"Called when schedule is intialized. Fetch schedules from DB etc here\"\n\n        log.info(\"SQLAlchemyScheduler.setup_schedule called\")\n\n        if 'celery.backend_cleanup' not in self._schedule:\n            self._schedule['celery.backend_cleanup'] = ScheduleEntry(\n                name='celery.backend_cleanup',\n                task='celery.backend_cleanup',\n                schedule=crontab('0', '4', '*'),\n                options= {'expires': 12 * 3600}\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares paths for distlib. wheel. Wheel to install into.", "response": "def _build_paths(venv=None):\n    \"\"\"Prepare paths for distlib.wheel.Wheel to install into.\n    \"\"\"\n    if venv:\n        paths = venv.paths\n    else:\n        paths = sysconfig.get_paths()\n    return {\n        \"prefix\": sys.prefix if not venv else venv.venv_dir.as_posix(),\n        \"data\": paths[\"data\"],\n        \"scripts\": paths[\"scripts\"],\n        \"headers\": paths[\"include\"],\n        \"purelib\": paths[\"purelib\"],\n        \"platlib\": paths[\"platlib\"],\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching for funds matching a search term.", "response": "def funds(self, term, field=None, **kwargs):\n        \"\"\"Search for funds matching a search term.\n\n        Args:\n          term (str): Fund id to search on\n          field (str): The field to search on.\n            Options are title, amount, org_name and type.\n          kwargs (dict): additional keywords passed into\n            requests.session.get params keyword.\n        \"\"\"\n        params = kwargs\n        params['q'] = term\n        if field:\n            params['f'] = field\n        else:\n            params['f'] = 'fu.org.n'\n        baseuri = self._BASE_URI + 'funds'\n        res = self.session.get(baseuri, params=params)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat the label for an office into something we like for twitter.", "response": "def format_office_label(office, division_label):\n    \"\"\"\n    Format the label for office into something we like for twitter.\n    \"\"\"\n    if office.body:\n        if office.body.slug == \"senate\":\n            return \"the Senate in {}\".format(division_label)\n        else:\n            if office.division.code == \"00\":\n                return \"the House seat in {} at-large district\".format(\n                    possessive_state(division_label)\n                )\n            else:\n                return \"the House seat in {} {} District\".format(\n                    possessive_state(division_label),\n                    ordinal(office.division.code),\n                )\n    else:\n        # TODO: President\n        return \"governor in {}\".format(division_label)\n    return office.label"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nignores the size since a complete line must be processed.", "response": "def readline(self, size=-1):\n        \"Ignore the `size` since a complete line must be processed.\"\n        while True:\n            try:\n                record = next(self.reader)\n            except StopIteration:\n                break\n\n            # Ensure this is a valid record\n            if checks.record_is_valid(record):\n                if self.use_cache:\n                    # Ensures the cache is updated and available\n                    self.variants.ensure_cache(record)\n\n                # Calculate the MD5 of the variant itself (not the record)\n                md5 = calculate_md5(record)\n\n                # Ensure this variant is not already loaded\n                if not self.use_cache or md5 not in self.variants:\n                    cleaned = self.process_line(record)\n                    cleaned.append(md5)\n                    return self.outdel.join(cleaned) + '\\n'\n\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_gene(self, gene_name):\n        if not gene_name:\n            return\n\n        gene_pk = self.genes.get(gene_name)\n        if gene_pk:\n            return gene_pk\n\n        chrom = self.chromosomes[self.variants.chrom]\n        gene = Gene.objects.find(gene_name, chrom, create=True)\n        if gene:\n            return gene.pk", "response": "Get a gene from the cache or attempt to disambiguate or add a\n        new record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_transcript(self, gene_pk, refseq_id):\n        \"Get a transcript from the cache or add a new record.\"\n        if not refseq_id:\n            return\n        transcript_pk = self.transcripts.get(refseq_id)\n        if transcript_pk:\n            return transcript_pk\n        gene = Gene(pk=gene_pk)\n        transcript = Transcript(refseq_id=refseq_id, gene=gene)\n        try:\n            transcript.save()\n        except IntegrityError:\n            transcript = Transcript.objects.get(refseq_id=refseq_id, gene=gene)\n        self.transcripts[refseq_id] = transcript.pk\n        return transcript.pk", "response": "Get a transcript from the cache or add a new record."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef readline(self, size=-1):\n        \"Ignore the `size` since a complete line must be processed.\"\n        while True:\n            try:\n                record = next(self.reader)\n            except StopIteration:\n                break\n\n            # Ensure this is a valid record\n            if checks.record_is_valid(record):\n                # Process the line\n                cleaned = self.process_line(record)\n                if cleaned:\n                    lines = []\n                    for c in cleaned:\n                        lines.append(self.outdel.join([str(x) for x in c]))\n                    return '\\n'.join(lines) + '\\n'\n\n        return ''", "response": "Ignore the size since a complete line must be processed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n\n        Project = orm['samples.Project']\n        Cohort = orm['samples.Cohort']\n\n        now = datetime.datetime.now()\n\n        # Create default project\n        try:\n            project = Project.objects.get(name=DEFAULT_PROJECT_NAME)\n        except Project.DoesNotExist:\n            project = Project(name=DEFAULT_PROJECT_NAME,\n                label=DEFAULT_PROJECT_NAME, created=now, modified=now)\n            project.save()\n\n        # Create default cohort\n        try:\n            cohort = Cohort.objects.get(name=DEFAULT_COHORT_NAME)\n        except Cohort.DoesNotExist:\n            cohort = Cohort(name=DEFAULT_COHORT_NAME, published=True,\n                autocreated=True, created=now, modified=now)\n            cohort.save()", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef result(self) -> workflow.IntervalGeneratorType:\n        config = cast(SentenceSegementationConfig, self.config)\n\n        index = -1\n        labels = None\n\n        while True:\n\n            # 1. Find the start of the sentence.\n            start = -1\n            while True:\n                # Check the ``labels`` generated from step (2).\n                if labels is None:\n                    # https://www.python.org/dev/peps/pep-0479/\n                    try:\n                        index, labels = next(self.index_labels_generator)\n                    except StopIteration:\n                        return\n                # Check if we found a valid sentence char.\n                if labels[SentenceValidCharacterLabeler]:\n                    start = index\n                    break\n                # Trigger next(...) action.\n                labels = None\n                index = -1\n\n            # 2. Find the ending.\n            end = -1\n            try:\n                while True:\n                    index, labels = next(self.index_labels_generator)\n\n                    # Detected invalid char.\n                    if config.enable_strict_sentence_charset and \\\n                            not labels[SentenceValidCharacterLabeler] and \\\n                            not labels[WhitespaceLabeler]:\n                        end = index\n                        break\n\n                    # Detected sentence ending.\n                    if self._labels_indicate_sentence_ending(labels):\n                        # Consume the ending span.\n                        while True:\n                            index, labels = next(self.index_labels_generator)\n                            is_ending = (self._labels_indicate_sentence_ending(labels) or\n                                         (config.extend_ending_with_delimiters and\n                                          labels[DelimitersLabeler]))\n\n                            if not is_ending:\n                                end = index\n                                break\n                        # yeah we found the ending.\n                        break\n            except StopIteration:\n                end = len(self.input_sequence)\n                # Trigger next(...) action.\n                labels = None\n                index = -1\n\n            yield start, end", "response": "Generate intervals indicating the valid sentences."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the geonames. org country database exports.", "response": "def import_locations(self, data):\n        \"\"\"Parse geonames.org country database exports.\n\n        ``import_locations()`` returns a list of :class:`trigpoints.Trigpoint`\n        objects generated from the data exported by geonames.org_.\n\n        It expects data files in the following tab separated format::\n\n            2633441\tAfon Wyre\tAfon Wyre\tRiver Wayrai,River Wyrai,Wyre\t52.3166667\t-4.1666667\tH\tSTM\tGB\tGB\t00\t\t\t\t0\t\t-9999\tEurope/London\t1994-01-13\n            2633442\tWyre\tWyre\tViera\t59.1166667\t-2.9666667\tT\tISL\tGB\tGB\tV9\t\t\t\t0\t\t1\tEurope/London\t2004-09-24\n            2633443\tWraysbury\tWraysbury\tWyrardisbury\t51.45\t-0.55\tP\tPPL\tGB\t\tP9\t\t\t\t0\t\t28\tEurope/London\t2006-08-21\n\n        Files containing the data in this format can be downloaded from the\n        geonames.org_ site in their `database export page`_.\n\n        Files downloaded from the geonames site when processed by\n        ``import_locations()`` will return ``list`` objects of the following\n        style::\n\n            [Location(2633441, \"Afon Wyre\", \"Afon Wyre\",\n                      ['River Wayrai', 'River Wyrai', 'Wyre'],\n                      52.3166667, -4.1666667, \"H\", \"STM\", \"GB\", ['GB'], \"00\",\n                      None, None, None, 0, None, -9999, \"Europe/London\",\n                      datetime.date(1994, 1, 13)),\n             Location(2633442, \"Wyre\", \"Wyre\", ['Viera'], 59.1166667,\n                      -2.9666667, \"T\", \"ISL\", \"GB\", ['GB'], \"V9\", None, None,\n                      None, 0, None, 1, \"Europe/London\",\n                      datetime.date(2004, 9, 24)),\n             Location(2633443, \"Wraysbury\", \"Wraysbury\", ['Wyrardisbury'],\n                      51.45, -0.55, \"P\", \"PPL\", \"GB\", None, \"P9\", None, None,\n                      None, 0, None, 28, \"Europe/London\",\n                      datetime.date(2006, 8, 21))]\n\n        Args:\n            data (iter): geonames.org locations data to read\n\n        Returns:\n            list: geonames.org identifiers with :class:`Location` objects\n\n        Raises:\n            FileFormatError: Unknown file format\n\n        .. _geonames.org: http://www.geonames.org/\n        .. _database export page: http://download.geonames.org/export/dump/\n        \"\"\"\n        self._data = data\n        field_names = ('geonameid', 'name', 'asciiname', 'alt_names',\n                       'latitude', 'longitude', 'feature_class',\n                       'feature_code', 'country', 'alt_country', 'admin1',\n                       'admin2', 'admin3', 'admin4', 'population', 'altitude',\n                       'gtopo30', 'tzname', 'modified_date')\n        comma_split = lambda s: s.split(',')\n        date_parse = lambda s: datetime.date(*map(int, s.split('-')))\n        or_none = lambda x, s: x(s) if s else None\n        str_or_none = lambda s: or_none(str, s)\n        float_or_none = lambda s: or_none(float, s)\n        int_or_none = lambda s: or_none(int, s)\n        tz_parse = lambda s: self.timezones[s][0] if self.timezones else None\n        field_parsers = (int_or_none, str_or_none, str_or_none, comma_split,\n                         float_or_none, float_or_none, str_or_none,\n                         str_or_none, str_or_none, comma_split, str_or_none,\n                         str_or_none, str_or_none, str_or_none, int_or_none,\n                         int_or_none, int_or_none, tz_parse, date_parse)\n        data = utils.prepare_csv_read(data, field_names, delimiter=r\"\t\")\n        for row in data:\n            try:\n                for name, parser in zip(field_names, field_parsers):\n                    row[name] = parser(row[name])\n            except ValueError:\n                raise utils.FileFormatError('geonames.org')\n            self.append(Location(**row))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the geonames. org_ timezone exports.", "response": "def import_timezones_file(self, data):\n        \"\"\"Parse geonames.org_ timezone exports.\n\n        ``import_timezones_file()`` returns a dictionary with keys containing\n        the timezone identifier, and values consisting of a UTC offset and UTC\n        offset during daylight savings time in minutes.\n\n        It expects data files in the following format::\n\n            Europe/Andorra\t1.0\t2.0\n            Asia/Dubai\t4.0\t4.0\n            Asia/Kabul\t4.5\t4.5\n\n        Files containing the data in this format can be downloaded from the\n        geonames site in their `database export page`_\n\n        Files downloaded from the geonames site when processed by\n        ``import_timezones_file()`` will return ``dict`` object of the\n        following style::\n\n            {\"Europe/Andorra\": (60, 120),\n             \"Asia/Dubai\": (240, 240),\n             \"Asia/Kabul\": (270, 270)}\n\n        Args:\n            data (iter): geonames.org timezones data to read\n\n        Returns:\n            list: geonames.org timezone identifiers with their UTC offsets\n\n        Raises:\n            FileFormatError: Unknown file format\n\n        .. _geonames.org: http://www.geonames.org/\n        .. _database export page: http://download.geonames.org/export/dump/\n        \"\"\"\n        self._tzfile = data\n        field_names = ('ident', 'gmt_offset', 'dst_offset')\n        time_parse = lambda n: int(float(n) * 60)\n        data = utils.prepare_csv_read(data, field_names, delimiter=r\"\t\")\n\n        self.timezones = {}\n        for row in data:\n            if row['ident'] == 'TimeZoneId':\n                continue\n            try:\n                delta = list(map(time_parse,\n                                 (row['gmt_offset'], row['dst_offset'])))\n            except ValueError:\n                raise utils.FileFormatError('geonames.org')\n            self.timezones[row['ident']] = delta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a bridge user to the list of BridgeUser objects", "response": "def add_user(bridge_user):\n    \"\"\"\n    Add the bridge_user given\n    Return a list of BridgeUser objects with custom fields\n    \"\"\"\n    resp = post_resource(admin_uid_url(None) +\n                         (\"?%s\" % CUSTOM_FIELD),\n                         json.dumps(bridge_user.to_json_post(),\n                                    separators=(',', ':')))\n    return _process_json_resp_data(resp, no_custom_fields=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef change_uid(bridge_id, new_uwnetid, no_custom_fields=True):\n    url = author_id_url(bridge_id)\n    if not no_custom_fields:\n        url += (\"?%s\" % CUSTOM_FIELD)\n    resp = patch_resource(url, '{\"user\":{\"uid\":\"%s@uw.edu\"}}' % new_uwnetid)\n    return _process_json_resp_data(resp,\n                                   no_custom_fields=no_custom_fields)", "response": "Change the UID of a bridge user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace_uid(old_uwnetid, new_uwnetid, no_custom_fields=True):\n    url = author_uid_url(old_uwnetid)\n    if not no_custom_fields:\n        url += (\"?%s\" % CUSTOM_FIELD)\n    resp = patch_resource(url, '{\"user\":{\"uid\":\"%s@uw.edu\"}}' % new_uwnetid)\n    return _process_json_resp_data(resp,\n                                   no_custom_fields=no_custom_fields)", "response": "Replace the UID of a BridgeUser object with a new one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user(uwnetid, include_course_summary=True):\n    url = author_uid_url(uwnetid) + \"?%s\" % CUSTOM_FIELD\n    if include_course_summary:\n        url = \"%s&%s\" % (url, COURSE_SUMMARY)\n    resp = get_resource(url)\n    return _process_json_resp_data(resp)", "response": "Get BridgeUsers object with custom fields"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user_by_id(bridge_id, include_course_summary=True):\n    url = author_id_url(bridge_id) + \"?%s\" % CUSTOM_FIELD\n    if include_course_summary:\n        url = \"%s&%s\" % (url, COURSE_SUMMARY)\n    resp = get_resource(url)\n    return _process_json_resp_data(resp)", "response": "Get BridgeUsers object by id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of BridgeUser objects with custom fields.", "response": "def get_all_users(include_course_summary=True):\n    \"\"\"\n    Return a list of BridgeUser objects with custom fields.\n    \"\"\"\n    url = author_uid_url(None) + \"?%s\" % CUSTOM_FIELD\n\n    if include_course_summary:\n        url = \"%s&%s\" % (url, COURSE_SUMMARY)\n\n    url = \"%s&%s\" % (url, PAGE_MAX_ENTRY)\n\n    resp = get_resource(url)\n\n    return _process_json_resp_data(resp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the user attributes provided.", "response": "def update_user(bridge_user):\n    \"\"\"\n    Update only the user attributes provided.\n    Return a list of BridgeUsers objects with custom fields.\n    \"\"\"\n    if bridge_user.bridge_id:\n        url = author_id_url(bridge_user.bridge_id)\n    else:\n        url = author_uid_url(bridge_user.netid)\n    resp = patch_resource(url + (\"?%s\" % CUSTOM_FIELD),\n                          json.dumps(bridge_user.to_json_patch(),\n                                     separators=(',', ':')))\n    return _process_json_resp_data(resp)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _process_json_resp_data(resp, no_custom_fields=False):\n    bridge_users = []\n    while True:\n        resp_data = json.loads(resp)\n        link_url = None\n        if \"meta\" in resp_data and\\\n                \"next\" in resp_data[\"meta\"]:\n            link_url = resp_data[\"meta\"][\"next\"]\n\n        bridge_users = _process_apage(resp_data, bridge_users,\n                                      no_custom_fields)\n        if link_url is None:\n            break\n        resp = get_resource(link_url)\n\n    return bridge_users", "response": "process the response and return a list of BridgeUser objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __push_import_modules(self):\n        for module in self.__import_modules:\n            sys.modules[module.__name__] = module", "response": "Push custom modules to the import namespace under its own __name__."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __find_child_classes(self, file):\n\n        child_classes = []\n        folder, name = os.path.split(file)\n        name = os.path.splitext(name)[0]\n\n        import imp\n        module = imp.load_source(name, file)\n\n        def filter_classes(m):\n            if inspect.isclass(m):\n                if inspect.getmro(m)[1] == self.__base_class:\n                    return True\n            return False\n\n        for name, obj in inspect.getmembers(module, filter_classes):\n            child_classes.append(obj)\n\n        return child_classes", "response": "Find all child classes of the base class in file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the image and label for the next image.", "response": "def _category(self):\n        \"\"\" Type of the image: LOLA or WAC\n\n        Note: Specify the attribute ``grid``, ``img`` and ``lbl`\n        \"\"\"\n\n        if self.fname.split('_')[0] == 'WAC':\n            self.grid = 'WAC'\n            self.img = os.path.join(self.wacpath, self.fname + '.IMG')\n            self.lbl = ''\n        elif self.fname.split('_')[0] == 'LDEM':\n            self.grid = 'LOLA'\n            self.img = os.path.join(self.lolapath, self.fname + '.IMG')\n            self.lbl = os.path.join(self.lolapath, self.fname + '.LBL')\n        else:\n            raise ValueError(\"%s : This type of image is not recognized. Possible\\\n                             images are from %s only\" % (self.fname, ', '.join(('WAC', 'LOLA'))))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _report(self, blocknr, blocksize, size):\n        ''' helper for downloading the file '''\n\n        current = blocknr * blocksize\n        sys.stdout.write(\"\\r{0:.2f}%\".format(100.0 * current / size))", "response": "helper for downloading the file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _detect_size(self, url):\n\n        site = urllib.urlopen(url)\n        meta = site.info()\n        return float(meta.getheaders(\"Content-Length\")[0]) / 1e6", "response": "Helper that detects the size of the image to be downloaded"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _maybe_download(self):\n        if self.grid == 'WAC':\n            urlpath = 'http://lroc.sese.asu.edu/data/LRO-L-LROC-5-RDR-V1.0/LROLRC_2001/DATA/BDR/WAC_GLOBAL/'\n            r = requests.get(urlpath)  # List file in the cloud\n            images = [elt.split('\"')[7].split('.')[0]\n                      for elt in r.iter_lines() if len(elt.split('\"')) > 7]\n            if self.fname not in images:\n                raise ValueError(\"%s : Image does not exist\\n.\\\n                                 Possible images are:\\n %s\" % (self.fname, '\\n, '.join(images[2:])))\n            elif not os.path.isfile(self.img):\n                urlname = os.path.join(urlpath, self.img.split('/')[-1])\n                print(\"The size is ?: %.1f Mo \\n\\n\" %\n                      (self._detect_size(urlname)))\n                download = self._user_yes_no_query(\n                    'Do you really want to download %s ?\\n\\n' % (self.fname))\n                if download:\n                    self._downloadfile(urlname, self.img)\n                else:\n                    raise ValueError(\"You need to download the file somehow\")\n\n        elif self.grid == 'LOLA':\n            urlpath = 'http://imbrium.mit.edu/DATA/LOLA_GDR/CYLINDRICAL/IMG/'\n            r = requests.get(urlpath)  # List file in this server\n            images = [elt.split('\"')[7].split('.')[0]\n                      for elt in r.iter_lines() if len(elt.split('\"')) > 7]\n            if self.fname not in images:\n                raise ValueError(\"%s : Image does not exist\\n.\\\n                                 Possible images are:\\n %s\" % (self.fname, '\\n, '.join(images[2:])))\n\n            elif (not os.path.isfile(self.img)) and (self.fname in images):\n                urlname = os.path.join(urlpath, self.img.split('/')[-1])\n                print(\"The size is ?: %.1f Mo \\n\\n\" %\n                      (self._detect_size(urlname)))\n                download = self._user_yes_no_query(\n                    'Do you really want to download %s ?\\n\\n' % (self.fname))\n                if download:\n                    self._downloadfile(urlname, self.img)\n                else:\n                    raise ValueError(\"You need to download the file somehow\")\n\n                urlname = os.path.join(urlpath, self.lbl.split('/')[-1])\n                self._downloadfile(urlname, self.lbl)", "response": "Helper to download the image if not in path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload info on the image and return the image object.", "response": "def _load_info_lbl(self):\n        \"\"\" Load info on the image\n\n        Note:\n            If the image is from LOLA, the .LBL is parsed and the\n            information is returned.\n            If the image is from WAC, the .IMG file is parsed using\n            the library `pvl`_ which provide nice method to extract\n            the information in the header of the image.\n\n        .. _pvl: http://pvl.readthedocs.org/en/latest/\n\n        \"\"\"\n        if self.grid == 'WAC':\n            label = load_label(self.img)\n            for key, val in label.iteritems():\n                if type(val) == pvl._collections.PVLObject:\n                    for key, value in val.iteritems():\n                        try:\n                            setattr(self, key, value.value)\n                        except:\n                            setattr(self, key, value)\n                else:\n                    setattr(self, key, val)\n            self.start_byte = self.RECORD_BYTES\n            self.bytesize = 4\n            self.projection = str(label['IMAGE_MAP_PROJECTION'][\n                'MAP_PROJECTION_TYPE'])\n            self.dtype = np.float32\n        else:\n            with open(self.lbl, 'r') as f:\n                for line in f:\n                    attr = [f.strip() for f in line.split('=')]\n                    if len(attr) == 2:\n                        setattr(self, attr[0], attr[1].split(' ')[0])\n            self.start_byte = 0\n            self.bytesize = 2\n            self.projection = ''\n            self.dtype = np.int16"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the corresponding latitude in degree", "response": "def lat_id(self, line):\n        ''' Return the corresponding latitude\n\n        Args:\n            line (int): Line number\n\n        Returns:\n            Correponding latitude in degree\n        '''\n        if self.grid == 'WAC':\n            lat = ((1 + self.LINE_PROJECTION_OFFSET - line) *\n                   self.MAP_SCALE * 1e-3 / self.A_AXIS_RADIUS)\n            return lat * 180 / np.pi\n        else:\n            lat = float(self.CENTER_LATITUDE) - \\\n                (line - float(self.LINE_PROJECTION_OFFSET) - 1)\\\n                / float(self.MAP_RESOLUTION)\n            return lat"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef long_id(self, sample):\n        ''' Return the corresponding longitude\n\n        Args:\n            sample (int): sample number on a line\n\n        Returns:\n            Correponding longidude in degree\n        '''\n        if self.grid == 'WAC':\n            lon = self.CENTER_LONGITUDE + (sample - self.SAMPLE_PROJECTION_OFFSET - 1)\\\n                * self.MAP_SCALE * 1e-3 / (self.A_AXIS_RADIUS * np.cos(self.CENTER_LATITUDE * np.pi / 180.0))\n            return lon * 180 / np.pi\n        else:\n            lon = float(self.CENTER_LONGITUDE) + \\\n                (sample - float(self.SAMPLE_PROJECTION_OFFSET) - 1)\\\n                / float(self.MAP_RESOLUTION)\n            return lon", "response": "Return the corresponding longitude in degree"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _control_sample(self, sample):\n        ''' Control the asked sample is ok '''\n        if sample > float(self.SAMPLE_LAST_PIXEL):\n            return int(self.SAMPLE_LAST_PIXEL)\n        elif sample < float(self.SAMPLE_FIRST_PIXEL):\n            return int(self.SAMPLE_FIRST_PIXEL)\n        else:\n            return sample", "response": "Control the asked sample is ok"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sample_id(self, lon):\n        ''' Return the corresponding sample\n\n        Args:\n            lon (int): longidute in degree\n\n        Returns:\n            Correponding sample\n\n        '''\n        if self.grid == 'WAC':\n            sample = np.rint(float(self.SAMPLE_PROJECTION_OFFSET) + 1.0 +\n                             (lon * np.pi / 180.0 - float(self.CENTER_LONGITUDE)) *\n                             self.A_AXIS_RADIUS *\n                             np.cos(self.CENTER_LATITUDE * np.pi / 180.0)\n                             / (self.MAP_SCALE * 1e-3))\n        else:\n            sample = np.rint(float(self.SAMPLE_PROJECTION_OFFSET) + float(self.MAP_RESOLUTION)\n                             * (lon - float(self.CENTER_LONGITUDE))) + 1\n        return self._control_sample(sample)", "response": "Return the corresponding sample_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _control_line(self, line):\n        ''' Control the asked line is ok '''\n        if line > float(self.LINE_LAST_PIXEL):\n            return int(self.LINE_LAST_PIXEL)\n        elif line < float(self.LINE_FIRST_PIXEL):\n            return int(self.LINE_FIRST_PIXEL)\n        else:\n            return line", "response": "Control the asked line is ok"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the corresponding line_id", "response": "def line_id(self, lat):\n        ''' Return the corresponding line\n\n        Args:\n            lat (int): latitude in degree\n\n        Returns:\n            Correponding line\n\n        '''\n        if self.grid == 'WAC':\n            line = np.rint(1.0 + self.LINE_PROJECTION_OFFSET -\n                           self.A_AXIS_RADIUS * np.pi * lat / (self.MAP_SCALE * 1e-3 * 180))\n        else:\n            line = np.rint(float(self.LINE_PROJECTION_OFFSET) - float(self.MAP_RESOLUTION)\n                           * (lat - float(self.CENTER_LATITUDE))) + 1\n        return self._control_line(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef array(self, size_chunk, start, bytesize):\n        ''' Read part of the binary file\n\n        Args:\n            size_chunk (int) : Size of the chunk to read\n            start (int): Starting byte\n            bytesize (int): Ending byte\n\n        Returns:\n            (np.array): array of the corresponding values\n        '''\n\n        with open(self.img, 'rb') as f1:\n            f1.seek(self.start_byte + start * self.bytesize)\n            data = f1.read(size_chunk * self.bytesize)\n            Z = np.fromstring(data, dtype=self.dtype, count=size_chunk)\n            if self.grid == 'LOLA':\n                return Z * float(self.SCALING_FACTOR)\n            else:\n                return Z", "response": "Read part of the binary file\n            and return a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting all the image from the image.", "response": "def extract_all(self):\n        ''' Extract all the image\n\n        Returns:\n            A tupple of three arrays ``(X,Y,Z)`` with ``X`` contains the\n            longitudes, ``Y`` contains the latitude and ``Z`` the values\n            extracted from the image.\n\n        Note:\n            All return arrays have the same size.\n\n            All coordinate are in degree.\n\n        '''\n\n        longmin, longmax, latmin, latmax = self.Boundary()\n        sample_min, sample_max = map(\n            int, (self.SAMPLE_FIRST_PIXEL, self.SAMPLE_LAST_PIXEL))\n        line_min, line_max = map(\n            int, (self.LINE_FIRST_PIXEL, self.LINE_LAST_PIXEL))\n\n        X = np.array(map(self.long_id, (range(sample_min, sample_max + 1, 1))))\n        Y = np.array(map(self.lat_id, (range(line_min, line_max + 1, 1))))\n        for i, line in enumerate(range(int(line_min), int(line_max) + 1)):\n            start = (line - 1) * int(self.SAMPLE_LAST_PIXEL) + sample_min\n            chunk_size = int(sample_max - sample_min)\n            Za = self.array(chunk_size, start, self.bytesize)\n            if i == 0:\n                Z = Za\n            else:\n                Z = np.vstack((Z, Za))\n\n        X, Y = np.meshgrid(X, Y)\n\n        return X, Y, Z"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract part of the image img from the window.", "response": "def extract_grid(self, longmin, longmax, latmin, latmax):\n        ''' Extract part of the image ``img``\n\n        Args:\n            longmin (float): Minimum longitude of the window\n            longmax (float): Maximum longitude of the window\n            latmin (float): Minimum latitude of the window\n            latmax (float): Maximum latitude of the window\n\n        Returns:\n            A tupple of three arrays ``(X,Y,Z)`` with ``X`` contains the\n            longitudes, ``Y`` contains the latitude and ``Z`` the values\n            extracted from the window.\n\n        Note:\n            All return arrays have the same size.\n\n            All coordinate are in degree.\n\n        '''\n\n        sample_min, sample_max = map(\n            int, map(self.sample_id, [longmin, longmax]))\n        line_min, line_max = map(int, map(self.line_id, [latmax, latmin]))\n        X = np.array(map(self.long_id, (range(sample_min, sample_max, 1))))\n        Y = np.array(map(self.lat_id, (range(line_min, line_max + 1, 1))))\n\n        for i, line in enumerate(range(int(line_min), int(line_max) + 1)):\n            start = (line - 1) * int(self.SAMPLE_LAST_PIXEL) + sample_min\n            chunk_size = int(sample_max - sample_min)\n            Za = self.array(chunk_size, start, self.bytesize)\n            if i == 0:\n                Z = Za\n            else:\n                Z = np.vstack((Z, Za))\n\n        X, Y = np.meshgrid(X, Y)\n\n        return X, Y, Z"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the image boundary", "response": "def boundary(self):\n        \"\"\" Get the image boundary\n\n        Returns:\n            A tupple composed by the westernmost_longitude,\n            the westernmost_longitude, the minimum_latitude and\n            the maximum_latitude.\n\n        \"\"\"\n\n        return (int(self.WESTERNMOST_LONGITUDE),\n                int(self.EASTERNMOST_LONGITUDE),\n                int(self.MINIMUM_LATITUDE),\n                int(self.MAXIMUM_LATITUDE))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lambert_window(self, radius, lat0, long0):\n        ''' Square Lambert Azimuthal equal area projection of\n        a window centered at (lat0, long0) with a given radius (km).\n\n        Args:\n            radius(float): Radius of the window (km).\n            lat0(float): Latitude at the center (degree).\n            long0(float): Longitude at the center (degree).\n\n        Returns:\n            A tuple ``(longll, longtr, latll, lattr)` with ``longll``\n            the longitude of the lower left corner, ``longtr`` the\n            longitude of the top right corner, ``latll`` the latitude\n            of the lower left corner and ``lattr`` the latitude of the\n            top right corner.\n\n        Note:\n            All return coordinates are in degree\n\n        '''\n\n        radius = radius * 360.0 / (np.pi * 2 * 1734.4)\n        radius = radius * np.pi / 180.0\n        lat0 = lat0 * np.pi / 180.0\n        long0 = long0 * np.pi / 180.0\n\n        bot = self._kp_func(lat0 - radius, long0, lat0, long0)\n        bot = bot * (np.cos(lat0) * np.sin(lat0 - radius) -\n                     np.sin(lat0) * np.cos(lat0 - radius))\n        x = bot\n        y = bot\n        rho = np.sqrt(x**2 + y**2)\n        c = 2.0 * np.arcsin(rho / float(2.0))\n        latll = np.arcsin(np.cos(c) * np.sin(lat0) + y * np.sin(c)\n                          * np.cos(lat0) / rho) * float(180.0) / np.pi\n        lon = long0 + np.arctan2(x * np.sin(c), rho * np.cos(lat0)\n                                 * np.cos(c) - y * np.sin(lat0) * np.sin(c))\n        longll = lon * 180.0 / np.pi\n\n        x = -bot\n        y = -bot\n        rho = np.sqrt(x**2 + y**2)\n        c = 2.0 * np.arcsin(rho / 2.0)\n        lattr = np.arcsin(np.cos(c) * np.sin(lat0) + y * np.sin(c)\n                          * np.cos(lat0) / rho) * float(180.0) / np.pi\n        lon = long0 + np.arctan2(x * np.sin(c), rho * np.cos(lat0)\n                                 * np.cos(c) - y * np.sin(lat0) * np.sin(c))\n        longtr = lon * 180.0 / np.pi\n\n        return longll, longtr, latll, lattr", "response": "Square Lambert Azimuthal equal area projection of the base of the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cylindrical_window(self, radius, lat0, long0):\n        ''' Cylindrical projection of a window centered\n        at (lat0, long0) with a given radius (km).\n\n        Args:\n            radius(float): Radius of the window (km).\n            lat0(float): Latitude at the center (degree).\n            long0(float): Longitude at the center (degree).\n\n        Returns:\n            A tuple ``(longll, longtr, latll, lattr)`` with ``longll``\n            the longitude of the lower left corner, ``longtr`` the\n            longitude of the top right corner, ``latll`` the latitude\n            of the lower left corner and ``lattr`` the latitude of the\n            top right corner.\n\n        Note:\n            All return coordinates are in degree        \n        '''\n\n        # Passage en radian\n        radi = radius * 2 * np.pi / (2 * 1734.4 * np.pi)\n        lamb0 = long0 * np.pi / 180.0\n        phi0 = lat0 * np.pi / 180.0\n\n        # Long/lat min (voir wikipedia)\n        longll = -radi / np.cos(phi0) + lamb0\n        latll = np.arcsin((-radi + np.sin(phi0) / np.cos(phi0)) * np.cos(phi0))\n        if np.isnan(latll):\n            latll = -90 * np.pi / 180.0\n        # Long/lat max (voir wikipedia)\n        longtr = radi / np.cos(phi0) + lamb0\n        lattr = np.arcsin((radi + np.tan(phi0)) * np.cos(phi0))\n\n        return longll * 180 / np.pi, longtr * 180 / np.pi, latll * 180 / np.pi, lattr * 180 / np.pi", "response": "This function computes the cylindrical projection of a window centered at ( lat0 long0 ) with a given radius."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncontrols on longitude values.", "response": "def _control_longitude(self):\n        ''' Control on longitude values '''\n\n        if self.lonm < 0.0:\n            self.lonm = 360.0 + self.lonm\n        if self.lonM < 0.0:\n            self.lonM = 360.0 + self.lonM\n        if self.lonm > 360.0:\n            self.lonm = self.lonm - 360.0\n        if self.lonM > 360.0:\n            self.lonM = self.lonM - 360.0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _confirm_resolution(self, implemented_res):\n        ''' Control on resolution '''\n\n        assert self.ppd in implemented_res, \\\n            ' Resolution %d ppd not implemented yet\\n.\\\n            Consider using one of the implemented resolutions %s'\\\n            % (self.ppd, ', '.join([f + ' ppd' for f in map(str, implemented_res)]))\n\n        if self.ppd == 256:\n            assert (np.abs(self.latM) < 60) and (np.abs(self.latm) < 60),\\\n                'This resolution is available in\\n \\\n                in cylindrical geometry only for -60<latitude<60 '", "response": "Confirm that the resolution is available in the cylindrical geometry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _define_case(self):\n        ''' Identify case '''\n\n        lonBool = self._map_center(\n            'long', self.lonM) != self._map_center('long', self.lonm)\n        latBool = self._map_center(\n            'lat', self.latM) != self._map_center('lat', self.latm)\n\n        if not lonBool and not latBool:\n            print('No overlap - Processing should be quick')\n            return self._cas_1()\n        elif lonBool and not latBool:\n            print('Longitude overlap - 2 images have to be proceded \\n \\\n                  Processing could take a few seconds')\n            return self._cas_2()\n        elif not lonBool and latBool:\n            print('Latitude overlap - 2 images have to be proceded \\n\\\n                  Processing could take a few seconds')\n            return self._cas_3()\n        else:\n            print('Latitude/Longidude overlaps - 4 images have to be proceded \\n\\\n                  Processing could take a few seconds')\n            return self._cas_4()", "response": "Define the identify case"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats longitude to fit the image name", "response": "def _format_lon(self, lon):\n        ''' Format longitude to fit the image name '''\n\n        lonf = self._map_center('long', lon)\n        st = str(lonf).split('.')\n        loncenter = ''.join((\"{0:0>3}\".format(st[0]), st[1]))\n        return loncenter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_lat(self, lat):\n        ''' Format latitude to fit the image name '''\n\n        if self.ppd in [4, 8, 16, 32, 64]:\n            latcenter = '000N'\n        elif self.ppd in [128]:\n            if lat < 0:\n                latcenter = '450S'\n            else:\n                latcenter = '450N'\n\n        return latcenter", "response": "Format latitude to fit the image name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the map in the good format", "response": "def _format_name_map(self, lonc, latc):\n        ''' Return the name of the map in the good format '''\n\n        return '_'.join(['WAC', 'GLOBAL'] +\n                        ['E' + latc + lonc, \"{0:0>3}\".format(self.ppd) + 'P'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _cas_2(self):\n        ''' Longitude overlap (2 images). '''\n\n        lonc_left = self._format_lon(self.lonm)\n        lonc_right = self._format_lon(self.lonM)\n        latc = self._format_lat(self.latm)\n\n        print(lonc_left, lonc_right, self.lonm, self.lonM)\n        img_name_left = self._format_name_map(lonc_left, latc)\n        print(img_name_left)\n        img_left = BinaryTable(img_name_left, self.path_pdsfiles)\n        X_left, Y_left, Z_left = img_left.extract_grid(self.lonm,\n                                                       float(\n                                                           img_left.EASTERNMOST_LONGITUDE),\n                                                       self.latm,\n                                                       self.latM)\n\n        img_name_right = self._format_name_map(lonc_right, latc)\n        img_right = BinaryTable(img_name_right, self.path_pdsfiles)\n        X_right, Y_right, Z_right = img_right.extract_grid(float(img_right.WESTERNMOST_LONGITUDE),\n                                                           self.lonM,\n                                                           self.latm,\n                                                           self.latM)\n\n        X_new = np.hstack((X_left, X_right))\n        Y_new = np.hstack((Y_left, Y_right))\n        Z_new = np.hstack((Z_left, Z_right))\n\n        return X_new, Y_new, Z_new", "response": "Longitude overlap ( 2 images."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cas_3(self):\n        ''' Latitude overlap (2 images). '''\n\n        lonc = self._format_lon(self.lonm)\n        latc_top = self._format_lat(self.latM)\n        latc_bot = self._format_lat(self.latm)\n\n        img_name_top = self._format_name_map(lonc, latc_top)\n        print(img_name_top)\n        img_top = BinaryTable(img_name_top, self.path_pdsfiles)\n        print(self.lonm, self.lonM, float(img_top.MINIMUM_LATITUDE), self.latM)\n        X_top, Y_top, Z_top = img_top.extract_grid(self.lonm,\n                                                   self.lonM,\n                                                   float(\n                                                       img_top.MINIMUM_LATITUDE),\n                                                   self.latM)\n\n        img_name_bottom = self._format_name_map(lonc, latc_bot)\n        print(img_name_bottom)\n        img_bottom = BinaryTable(img_name_bottom, self.path_pdsfiles)\n        X_bottom, Y_bottom, Z_bottom = img_bottom.extract_grid(self.lonm,\n                                                               self.lonM,\n                                                               self.latm,\n                                                               float(img_bottom.MAXIMUM_LATITUDE))\n\n        X_new = np.vstack((X_top, X_bottom))\n        Y_new = np.vstack((Y_top, Y_bottom))\n        Z_new = np.vstack((Z_top, Z_bottom))\n\n        return X_new, Y_new, Z_new", "response": "Return the 2 - dimensional overlap of the 2 - dimensional map."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a formated longitude format for the file", "response": "def _format_lon(self, lon):\n        ''' Returned a formated longitude format for the file '''\n        if self.ppd in [4, 16, 64, 128]:\n            return None\n        else:\n            return map(lambda x: \"{0:0>3}\".format(int(x)), self._map_center('long', lon))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a formated latitude format for the file", "response": "def _format_lat(self, lat):\n        ''' Returned a formated latitude format for the file '''\n        if self.ppd in [4, 16, 64, 128]:\n            return None\n        else:\n            if lat < 0:\n                return map(lambda x: \"{0:0>2}\"\n                           .format(int(np.abs(x))) + 'S', self._map_center('lat', lat))\n            else:\n                return map(lambda x: \"{0:0>2}\"\n                           .format(int(x)) + 'N', self._map_center('lat', lat))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_name_map(self, lon, lat):\n        ''' Return the name of the map in the good format '''\n\n        if self.ppd in [4, 16, 64, 128]:\n            lolaname = '_'.join(['LDEM', str(self.ppd)])\n        elif self.ppd in [512]:\n            lolaname = '_'.join(\n                ['LDEM', str(self.ppd), lat[0], lat[1], lon[0], lon[1]])\n        return lolaname", "response": "Return the name of the map in the good format"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the requested resource or update it using Bothell account", "response": "def get_bot_resource(url):\n    \"\"\"\n    Get the requested resource or update resource using Bothell account\n    :returns: http response with content in xml\n    \"\"\"\n    response = None\n    response = TrumbaBot_DAO().getURL(url,\n                                      {\"Content-Type\": \"application/xml\"})\n    _log_xml_resp(\"Bothell\", url, response)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the requested resource or update it using Seattle account", "response": "def get_sea_resource(url):\n    \"\"\"\n    Get the requested resource or update resource using Seattle account\n    :returns: http response with content in xml\n    \"\"\"\n    response = None\n    response = TrumbaSea_DAO().getURL(url,\n                                      {\"Accept\": \"application/xml\"})\n    _log_xml_resp(\"Seattle\", url, response)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_tac_resource(url):\n    response = None\n    response = TrumbaTac_DAO().getURL(url,\n                                      {\"Accept\": \"application/xml\"})\n    _log_xml_resp(\"Tacoma\", url, response)\n    return response", "response": "Get the requested resource or update it using Tacoma account\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nposting the requested resource of Bothell calendars", "response": "def post_bot_resource(url, body):\n    \"\"\"\n    Get the requested resource of Bothell calendars\n    :returns: http response with content in json\n    \"\"\"\n    response = None\n    response = TrumbaBot_DAO().postURL(\n        url,\n        {\"Content-Type\": \"application/json\"},\n        body)\n    _log_json_resp(\"Bothell\", url, body, response)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post_sea_resource(url, body):\n    response = None\n    response = TrumbaSea_DAO().postURL(\n        url,\n        {\"Content-Type\": \"application/json\"},\n        body)\n    _log_json_resp(\"Seattle\", url, body, response)\n    return response", "response": "Post the requested resource using the Seattle account"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_tac_resource(url, body):\n    response = None\n    response = TrumbaTac_DAO().postURL(\n        url,\n        {\"Content-Type\": \"application/json\"},\n        body)\n    _log_json_resp(\"Tacoma\", url, body, response)\n    return response", "response": "Post the requested resource of Tacoma calendars\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new sick model from a file describing the parameter names fluxes and wavelengths.", "response": "def create(output_prefix, grid_flux_filename, wavelength_filenames,\n    clobber=False, grid_flux_filename_format=\"csv\", **kwargs):\n    \"\"\"\n    Create a new *sick* model from files describing the parameter names, fluxes,\n    and wavelengths.\n    \"\"\"\n\n    if not clobber:\n        # Check to make sure the output files won't exist already.\n        output_suffixes = (\".yaml\", \".pkl\", \"-wavelengths.memmap\",\n            \"-intensities.memmap\")\n        for path in [output_prefix + suffix for suffix in output_suffixes]:\n            if os.path.exists(path):\n                raise IOError(\"output filename {} already exists\".format(path))\n\n    # Read the grid_flux filename.\n    # param1 param2 param3 param4 channelname1 channelname2\n    kwds = kwargs.pop(\"__grid_flux_filename_kwargs\", {})\n    kwds.update({\"format\": grid_flux_filename_format})\n    grid_flux_tbl = Table.read(grid_flux_filename, **kwds)\n\n    # Distinguish column names between parameters (real numbers) and filenames\n    str_columns = \\\n        np.array([_[1].startswith(\"|S\") for _ in grid_flux_tbl.dtype.descr])\n\n    # Check the number of channels provided.\n    if str_columns.sum() != len(wavelength_filenames):\n        raise ValueError(\"expected {0} wavelength filenames because {1} has {0}\"\n            \" string columns ({2}) but found {3} wavelength filenames\".format(\n                sum(str_columns), grid_flux_filename, \n                \", \".join(np.array(grid_flux_tbl.colnames)[str_columns]), \n                len(wavelength_filenames)))\n\n    # Create a record array of the grid points.\n    grid_points = \\\n        grid_flux_tbl.as_array()[np.array(grid_flux_tbl.colnames)[~str_columns]]\n\n    # To-do: make sure they are all floats.\n\n    # Sort the grid points.\n    grid_indices = grid_points.argsort(order=grid_points.dtype.names)\n    grid_points = grid_points[grid_indices]\n    grid_flux_tbl = grid_flux_tbl[grid_indices]\n\n    # Check the wavelength filenames.\n    channel_wavelengths = np.array(map(load_simple_data, wavelength_filenames))\n\n    # Sort the channels by starting wavelength.\n    c_indices = np.argsort([each.min() for each in channel_wavelengths])\n    channel_names = np.array(grid_flux_tbl.colnames)[str_columns][c_indices]\n    channel_wavelengths = channel_wavelengths[c_indices]\n    channel_sizes = [len(_) for _ in channel_wavelengths]\n    num_pixels = sum(channel_sizes)\n\n    # Create the model YAML file.\n    with open(output_prefix + \".yaml\", \"w\") as fp:\n        header = \"\\n\".join([\n            \"# Model created on {0}\".format(strftime(\"%Y-%m-%d %H:%M:%S\")),\n            \"# Grid parameters: {0}\".format(\", \".join(grid_points.dtype.names)),\n            \"# Channel names: {0}\".format(\", \".join(channel_names))\n            ])\n        fp.write(header + \"\\n\" + yaml.safe_dump({ \"model_grid\": {\n                \"grid_points\": output_prefix + \".pkl\",\n                \"intensities\": output_prefix + \"-intensities.memmap\",\n                \"wavelengths\": output_prefix + \"-wavelengths.memmap\"\n            }}, stream=None, allow_unicode=True, default_flow_style=False))\n\n    # Create the pickled model file, with meta data.\n    metadata = {\n        \"grid_flux_filename\": grid_flux_filename,\n        \"wavelength_filenames\": wavelength_filenames,\n        \"channel_names\": channel_names,\n        \"channel_sizes\": channel_sizes,\n        \"channel_resolutions\": [float(\"inf\")] * len(channel_names),\n        \"sick_version\": sick_version\n    }\n    logger.debug(\"Dumping grid points and metadata to file\")\n    with open(output_prefix + \".pkl\", \"wb\") as fp:\n        pickle.dump((grid_points, metadata), fp, -1)\n\n    # Create the memory-mapped dispersion file.\n    logger.debug(\"Creating memory-mapped dispersion file.\")\n    wavelengths_memmap = np.memmap(output_prefix + \"-wavelengths.memmap\",\n        dtype=\"float32\", mode=\"w+\", shape=(num_pixels, ))\n    wavelengths_memmap[:] = np.hstack(channel_wavelengths)\n    wavelengths_memmap.flush()\n    del wavelengths_memmap\n\n    # Create the memory-mapped intensities file.\n    logger.debug(\"Creating memory-mapped intensities file.\")\n    intensities_memmap = np.memmap(output_prefix + \"-intensities.memmap\",\n        shape=(grid_points.size, num_pixels), dtype=\"float32\",\n        mode=\"w+\")\n    \n    n = len(grid_flux_tbl)\n    for i, row in enumerate(grid_flux_tbl):\n        logger.debug(\"Loading point {0}/{1} into the intensities map\"\\\n            .format(i + 1, n))\n        j = 0\n        for channel_name in channel_names:\n            try:\n                data = load_simple_data(row[channel_name])\n            except:\n                logger.exception(\"Could not load data from {0} for channel {1}\"\\\n                    .format(row[channel_name], channel_name))\n                raise\n            intensities_memmap[i, j:j + data.size] = data\n            j += data.size\n\n    intensities_memmap.flush()\n    del intensities_memmap\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        for qde_xtf in orm['xtf.QualifiedDublinCoreElement'].objects.all().order_by('id'):\n            qde = orm.QualifiedDublinCoreElement()\n            qde.content = qde_xtf.content\n            qde.term = qde_xtf.term\n            qde.qualifier = qde_xtf.qualifier\n            #import pdb;pdb.set_trace()\n            c= orm['contenttypes.ContentType'].objects.get(pk=qde_xtf.content_type.pk)\n            #c.name = qde_xtf.content_type.name\n            #c.app_label = qde_xtf.content_type.app_label\n            #c.model = qde_xtf.content_type.model\n            qde.content_type = c\n            #qde.content_type = qde_xtf.content_type\n            qde.object_id = qde_xtf.object_id\n            qde.save()\n        for qdeh_xtf in  orm['xtf.QualifiedDublinCoreElementHistory'].objects.all().order_by('id'):\n            qdeh = orm.QualifiedDublinCoreElementHistory()\n            qdeh.content = qdeh_xtf.content\n            qdeh.term = qdeh_xtf.term\n            qdeh.qualifier = qdeh_xtf.qualifier\n            c= orm['contenttypes.ContentType'].objects.get(pk=qdeh_xtf.content_type.pk)\n            #c.name = qdeh_xtf.content_type.name\n            #c.app_label = qdeh_xtf.content_type.app_label\n            #c.model = qdeh_xtf.content_type.model\n            qdeh.content_type = c\n            #qdeh.content_type = qdeh_xtf.content_type\n            qdeh.object_id = qdeh_xtf.object_id\n            qdeh.qdce = orm['dublincore.QualifiedDublinCoreElement'].objects.get(pk=qdeh_xtf.qdce.pk)\n            qdeh.qdce_id_stored = qdeh_xtf.qdce_id_stored\n            qdeh.save()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef last_modified_date(filename):\n    mtime = os.path.getmtime(filename)\n    dt = datetime.datetime.utcfromtimestamp(mtime)\n    return dt.replace(tzinfo=pytz.utc)", "response": "Last modified timestamp as a UTC datetime"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call(self, command, params=None, expect_body=True, stream=False):\n        if self._socket is None:\n            raise SerfConnectionError('handshake must be made first')\n\n        header = msgpack.packb({\"Seq\": self._counter(), \"Command\": command})\n\n        if params is not None:\n            body = msgpack.packb(params)\n            self._socket.sendall(header + body)\n        else:\n            self._socket.sendall(header)\n\n        unpacker = msgpack.Unpacker(object_hook=self._decode_addr_key)\n\n        def read_from_socket():\n            try:\n                buf = self._socket.recv(self._socket_recv_size)\n                if len(buf) == 0:  # Connection was closed.\n                    raise SerfConnectionError(\"Connection closed by peer\")\n                unpacker.feed(buf)\n            except socket.timeout:\n                raise SerfTimeout(\n                    \"timeout while waiting for an RPC response. (Have %s so\"\n                    \"far)\", response)\n\n        if stream:\n            def keep_reading_from_stream(init=[]):\n                sub_response = SerfResult()\n                while True:\n                    if init is not None:\n                        it = init\n                        init = None\n                    else:\n                        if self._socket is None:\n                            return\n                        read_from_socket()\n                        it = unpacker\n                    for msg in it:\n                        if sub_response.head is None:\n                            sub_response.head = msg\n                        elif sub_response.body is None:\n                            sub_response.body = msg\n                            yield sub_response\n                            sub_response = SerfResult()\n            mem = []\n            messages_expected = 1\n            while messages_expected > 0:\n                read_from_socket()\n                # Might have received enough to deserialise one or more\n                # messages, try to fill out the response object.\n                for message in unpacker:\n                    mem.append(message)\n                    messages_expected -= 1\n\n            # Disable timeout while we are in streaming mode\n            self._socket.settimeout(None)\n\n            response = SerfResult()\n            response.head = mem.pop()\n            response.body = keep_reading_from_stream(mem)\n        else:\n            # The number of msgpack messages that are expected\n            # in response to this command.\n            messages_expected = 2 if expect_body else 1\n\n            response = SerfResult()\n            # Continue reading from the network until the expected number of\n            # msgpack messages have been received.\n            while messages_expected > 0:\n                read_from_socket()\n                # Might have received enough to deserialise one or more\n                # messages, try to fill out the response object.\n                for message in unpacker:\n                    if response.head is None:\n                        response.head = message\n                    elif response.body is None:\n                        response.body = message\n                    else:\n                        raise SerfProtocolError(\n                            \"protocol handler got more than 2 messages. \"\n                            \"Unexpected message is: %s\", message)\n\n                    # Expecting one fewer message now.\n                    messages_expected -= 1\n\n        return response", "response": "Send a command to Serf for evaluation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the connection with the Serf agent and does the initial handshake.", "response": "def handshake(self):\n        \"\"\"\n        Sets up the connection with the Serf agent and does the\n        initial handshake.\n        \"\"\"\n        if self._socket is None:\n            self._socket = self._connect()\n        return self.call('handshake', {\"Version\": 1}, expect_body=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auth(self, auth_key):\n        if self._socket is None:\n            self._socket = self._connect()\n        return self.call('auth', {\"AuthKey\": auth_key}, expect_body=False)", "response": "Performs the initial authentication on connect\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _decode_addr_key(self, obj_dict):\n        key = b'Addr'\n        if key in obj_dict:\n            try:\n                # Try to convert a packed IPv6 address.\n                # Note: Call raises ValueError if address is actually IPv4.\n                ip_addr = socket.inet_ntop(socket.AF_INET6, obj_dict[key])\n\n                # Check if the address is an IPv4 mapped IPv6 address:\n                # ie. ::ffff:xxx.xxx.xxx.xxx\n                if ip_addr.startswith('::ffff:'):\n                    ip_addr = ip_addr.lstrip('::ffff:')\n\n                obj_dict[key] = ip_addr.encode('utf-8')\n            except ValueError:\n                # Try to convert a packed IPv4 address.\n                ip_addr = socket.inet_ntop(socket.AF_INET, obj_dict[key])\n                obj_dict[key] = ip_addr.encode('utf-8')\n\n        return obj_dict", "response": "Decode the addr field into a proper format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits until the connection to the host and port is successful within the timeout.", "response": "def wait_for_service(host, port, timeout=DEFAULT_TIMEOUT):\n    \"\"\"\n    Return True if connection to the host and port is successful within the timeout.\n\n    @param host: str: hostname of the server\n    @param port: int: TCP port to which to connect\n    @param timeout: int: length of time in seconds to try to connect before giving up\n    @return: bool\n    \"\"\"\n    service = ServiceURL('tcp://{}:{}'.format(host, port), timeout)\n    return service.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_for_url(url, timeout=DEFAULT_TIMEOUT):\n    service = ServiceURL(url, timeout)\n    return service.wait()", "response": "Wait for a given url to be established within the timeout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_available(self):\n        if self.scheme in NOOP_PROTOCOLS:\n            return True\n\n        if not self.port:\n            raise RuntimeError('port is required')\n\n        s = socket.socket()\n        try:\n            s.connect((self.host, self.port))\n        except Exception:\n            return False\n        else:\n            return True", "response": "Return True if the connection to the host and port is successful."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef change_window(self, size_window):\n        ''' Change the region of interest\n\n        Args:\n            size_window (float): Radius of the region of interest (km)\n\n        Notes:\n            Change the attributes ``size_window`` and ``window`` to\n            correspond to the new region of interest.\n\n        '''\n        self.size_window = size_window\n        self.window = self.lambert_window(\n            self.size_window, self.lat0, self.lon0)", "response": "Change the region of interest to the new size window."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding scale to the map instance", "response": "def _add_scale(self, m, ax1):\n        ''' Add scale to the map instance '''\n\n        lol, loM, lam, laM = self.lambert_window(\n            0.6 * self.size_window, self.lat0, self.lon0)\n        m.drawmapscale(loM, lam, self.lon0, self.lat0, 10,\n                       barstyle='fancy', units='km',\n                       fontsize=24, yoffset=None,\n                       labelstyle='simple',\n                       fontcolor='k',\n                       fillcolor1='w',\n                       fillcolor2='k', ax=ax1,\n                       format='%d',\n                       zorder=2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds colorbar to the map instance", "response": "def _add_colorbar(self, m, CS, ax, name):\n        ''' Add colorbar to the map instance '''\n\n        cb = m.colorbar(CS, \"right\", size=\"5%\", pad=\"2%\")\n        cb.set_label(name, size=34)\n        cb.ax.tick_params(labelsize=18)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_arrays(self, type_img):\n        ''' Return arrays the region of interest\n\n        Args:\n            type_img (str): Either lola or wac.\n\n        Returns:\n            A tupple of three arrays ``(X,Y,Z)`` with ``X`` contains the\n            longitudes, ``Y`` contains the latitude and ``Z`` the values\n            extracted for the region of interest.\n\n        Note:\n            The argument has to be either lola or wac. Note case sensitive.\n            All return arrays have the same size.\n\n            All coordinates are in degree.\n        '''\n\n        if type_img.lower() == 'lola':\n            return LolaMap(self.ppdlola, *self.window, path_pdsfile=self.path_pdsfiles).image()\n        elif type_img.lower() == 'wac':\n            return WacMap(self.ppdwac, *self.window, path_pdsfile=self.path_pdsfiles).image()\n        else:\n            raise ValueError('The img type has to be either \"Lola\" or \"Wac\"')", "response": "Returns the arrays of the region of interest\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat the basemap plot to show lat / long properly", "response": "def _format_coordinate(self, ax, m):\n        ''' Format the basemap plot to show lat/long properly '''\n        lon_m, lon_M, lat_m, lat_M = self.window\n        xlocs = np.linspace(lon_m, lon_M, 5)\n        ylocs = np.linspace(lat_m, lat_M, 5)\n        xlocs = map(lambda x: float('%1.2f' % (x)), xlocs)\n        ylocs = map(lambda x: float('%1.2f' % (x)), ylocs)\n        m.drawparallels(ylocs, labels=[1, 0, 0, 1], ax=ax, fontsize=18)\n        m.drawmeridians(xlocs, labels=[1, 0, 0, 1], ax=ax, fontsize=18)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_profile(self, img_type, coordinate, num_points):\n        ''' Extract a profile from (lat1,lon1) to (lat2,lon2)\n\n        Args:\n            img_type (str): Either lola or wac.\n            coordinate (float,float,float,flaot): A tupple\n                ``(lon0,lon1,lat0,lat1)`` with:\n\n                - lon0: First point longitude\n                - lat0: First point latitude\n                - lon1: Second point longitude\n                - lat1: Second point latitude\n\n            num_points (int): Number of points to use in the\n                interpolation process.\n\n        Note:\n            Be carefull, longitude has to be in between 0-360 !\n        '''\n\n        lon0, lon1, lat0, lat1 = coordinate\n        X, Y, Z = self.get_arrays(img_type)\n        y0, x0 = np.argmin(np.abs(X[0, :] - lon0)\n                           ), np.argmin(np.abs(Y[:, 0] - lat0))\n        y1, x1 = np.argmin(np.abs(X[0, :] - lon1)\n                           ), np.argmin(np.abs(Y[:, 0] - lat1))\n        x, y = np.linspace(x0, x1, num_points), np.linspace(y0, y1, num_points)\n        zi = scipy.ndimage.map_coordinates(Z, np.vstack((x, y)))\n\n        return zi", "response": "Extract a profile from lat1 lon1 lat2 and flaot coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw a profile between two points.", "response": "def draw_profile(self, coordinates, num_points=500, save=False,\n                     name='BaseProfile.png'):\n        ''' Draw a profile between a point (lon0,lat0) and (lon1,lat1).\n\n        Args:\n            coordinates: Tupples which list the different desired\n                profiles.\n\n                Each profil has to be defined as a tupple which follows\n                (lon0,lon1,lat0,lat1) with (lon0,lat0) the first point\n                coordintes and (lon1,lat1) the second point\n                coordinates. Both in degree.\n            num_points (Optional[int]): Number of points to use\n                in the interpolation process. Defaults to 100.\n            save (Optional[bool]): Weither or not to save the image.\n                Defaults to False.\n            name (Optional[str]): Absolut path to save the resulting\n                image. Default to 'BaseProfile.png' in the working\n                directory.\n\n        Example:\n            Here is an example for a region located (10E,10N) 20 km\n            in diameter with three different profiles:\n\n                - One North-South\n                - One East-West\n                - One inclined\n\n            >>> Region = Area(10,10,20)\n            >>> midlon = (Region.window[0]+Region.window[1])/2.0\n            >>> midlat = (Region.window[2]+Region.window[3])/2.0\n            >>> profile1 = (midlon,midlon,Region.window[2],Region.window[3])\n            >>> profile2 = (Region.window[0],Region.window[1],midlat,midlat)\n            >>> Region.draw_profile((profile1,profile2,Region.window,))\n\n        Warning:\n            If only one profile is given, ``coordinates = (profile1,)``.\n            If more than one is given, use ``coordinates = (profile1,profile2,profile3,)``\n\n            IF YOU DECIDE TO CHANGE THE PATH, YOU HAVE TO WRITE\n            region.draw_profile(\n                (profile1,profile2,region.window,), save = True, name = newpath)\n\n            FOR SOME REASON, USING ONLY\n            region.draw_profile(\n                (profile1,profile2,region.window,), True, newpath)\n            IS NOT WORKING\n\n        '''\n\n        fig = plt.figure(figsize=(27, len(coordinates) * 8))\n        gs = gridspec.GridSpec(len(coordinates), 4)\n\n        if len(coordinates) == 4:\n            assert type(coordinates[0]) == tuple,\\\n                \"If only one tupple is given,\\n\\\n                the correct syntax is (tuple,) !! Not (tuple) ;)\"\n\n        for i, coordinate in enumerate(coordinates):\n\n            ax1 = plt.subplot(gs[i, :2])\n            ax2 = plt.subplot(gs[i, 2:])\n\n            # Image unit\n            lon_m, lon_M, lat_m, lat_M = self.window\n            m = Basemap(llcrnrlon=lon_m, llcrnrlat=lat_m, urcrnrlon=lon_M, urcrnrlat=lat_M,\n                        resolution='i', projection='laea', rsphere=1734400, lat_0=self.lat0, lon_0=self.lon0)\n            X, Y, Z = self.get_arrays('lola')\n            X, Y = m(X, Y)\n            CS = m.pcolormesh(X, Y, Z, cmap='gist_earth',\n                              alpha=1, ax=ax1, zorder=1)\n            self._format_coordinate(ax1, m)\n\n            lon1, lon0, lat1, lat0 = coordinate\n            lon0, lat0 = m(lon0, lat0)\n            lon1, lat1 = m(lon1, lat1)\n            ax1.plot([lon1, lon0], [lat1, lat0], 'ro-')\n\n            # Profile\n            print(coordinate)\n            z_interpolated = self.get_profile('lola', coordinate, num_points)\n            ax2.plot(z_interpolated, lw=2, marker='o')\n            ax2.set_ylabel('Topographic profile (m)', fontsize=24)\n            ax2.tick_params(labelsize=18)\n\n        if save == True:\n            fig.savefig(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lola_image(self, save=False, name='BaseLola.png'):\n        ''' Draw the topography of the region of interest\n\n        Args:\n            save (Optional[bool]): Weither or not to save the image.\n                Defaults to False.\n            name (Optional[str]): Absolut path to save the resulting\n                image. Default to 'BaseLola.png' in the working\n                directory.\n\n        Returns:\n            An image correponding to the region tography. Realized\n            from the data taken by the LOLA instrument on board of LRO.\n\n        Note:\n            Nice to use in a jupyter notebook with ``%matplotib inline``\n            activated.\n\n            Feel free to modify this method to plot exactly what you need.\n\n        '''\n\n        fig = plt.figure(figsize=(10, 8))\n        ax1 = fig.add_subplot(111)\n\n        lon_m, lon_M, lat_m, lat_M = self.lambert_window(\n            self.size_window, self.lat0, self.lon0)\n        m = Basemap(llcrnrlon=lon_m, llcrnrlat=lat_m, urcrnrlon=lon_M, urcrnrlat=lat_M,\n                    resolution='i', projection='laea', rsphere=1734400, lat_0=self.lat0, lon_0=self.lon0)\n\n        Xl, Yl, Zl = self.get_arrays('Lola')\n        Xl, Yl = m(Xl, Yl)\n\n        CS = m.pcolormesh(Xl, Yl, Zl, cmap='gist_earth',\n                          alpha=.5, ax=ax1, zorder=1)\n        # m.contour(Xl,Yl,Zl,20, colors = 'black', alpha = 1.0 , zorder=2)\n\n        xc, yc = m(self.lon0, self.lat0)\n        ax1.scatter(xc, yc, s=200, marker='v', zorder=2)\n\n        self._add_scale(m, ax1)\n        self._add_colorbar(m, CS, ax1, 'Topography')\n\n        if save == True:\n            fig.savefig(name, rasterized=True, dpi=50,\n                        bbox_inches='tight', pad_inches=0.1)", "response": "Draw the topography of the region of interest and return the realized base - level image."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, name: str, pattern: str) -> None:\n        self.patterns[name] = URITemplate(\n            pattern, converters=self.converters)", "response": "add url pattern for name\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lookup(self, path_info: str) -> MatchResult:\n        for name, pattern in self.patterns.items():\n            match = pattern.match(path_info)\n            if match is None:\n                continue\n            match.name = name\n            return match\n        return None", "response": "lookup url match for path_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate url for named url pattern with kwargs", "response": "def generate(self, name: str, **kwargs: Dict[str, str]) -> str:\n        \"\"\" generate url for named url pattern with kwargs\n        \"\"\"\n        template = self.patterns[name]\n        return template.substitute(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self, name: str, **kwargs):\n        path = self.urlmapper.generate(name, **kwargs)\n        return self.make_full_qualified_url(path)", "response": "generate full qualified url for named url pattern with kwargs\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nappends application url to path", "response": "def make_full_qualified_url(self, path: str) -> str:\n        \"\"\" append application url to path\"\"\"\n        return self.application_uri.rstrip('/') + '/' + path.lstrip('/')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding url pattern dispatching to application", "response": "def add_url(self, name: str, pattern: str, application: Callable) -> None:\n        \"\"\" add url pattern dispatching to application\"\"\"\n        self.urlmapper.add(name, self.prefix + pattern)\n        self.register_app(name, application)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_subroute(self, pattern: str) -> \"URLDispatcher\":\n        return URLDispatcher(\n            urlmapper=self.urlmapper,\n            prefix=self.prefix + pattern,\n            applications=self.applications,\n            extra_environ=self.extra_environ)", "response": "create new URLDispatcher routed by pattern"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detect_view_name(self, environ: Dict[str, Any]) -> str:\n        script_name = environ.get('SCRIPT_NAME', '')\n        path_info = environ.get('PATH_INFO', '')\n        match = self.urlmapper.lookup(path_info)\n        if match is None:\n            return None\n\n        splited = match.split_path_info(path_info)\n        extra_path_info = splited[1]\n        pos_args = []  # type: List[str]\n\n        routing_args = environ.get('wsgiorg.routing_args', ((), {}))\n        (cur_pos, cur_named) = routing_args\n        new_pos = list(cur_pos) + list(pos_args)\n        new_named = match.new_named_args(cur_named)\n        environ['wsgiorg.routing_args'] = (new_pos, new_named)\n        environ['webdispatch.urlmapper'] = self.urlmapper\n        urlgenerator = URLGenerator(environ, self.urlmapper)\n        environ['webdispatch.urlgenerator'] = urlgenerator\n        environ['SCRIPT_NAME'] = script_name + splited[0]\n        environ['PATH_INFO'] = extra_path_info\n\n        return match.name", "response": "detect view name from environ"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when views not found", "response": "def on_view_not_found(\n            self,\n            environ: Dict[str, Any],\n            start_response: Callable[[str, List[Tuple[str, str]]], None],\n    ) -> Iterable[bytes]:\n        \"\"\" called when views not found\"\"\"\n        start_response('404 Not Found', [('Content-type', 'text/plain')])\n        return [b'Not found']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self):\n        # fetch data\n        sess = requests.session()\n        request = sess.get('https://{}/{}'.format(self.locale,\n                                                  self.product_id),\n                           allow_redirects=True,\n                           timeout=2)\n        sess.close()\n\n        # raise exception, e.g. if we are blocked because of too many requests\n        request.raise_for_status()\n\n        soup = BeautifulSoup(request.text, 'html.parser')\n\n        # parse name\n        raw = soup.find('h1', attrs={'class': 'gh-headline'})\n        self.device.name = raw.string.replace('\\n', '')\n\n        # parse prices\n        self.device.prices = []\n        for tmp in soup.select('div.offer__price .gh_price'):\n            matches = re.search(_REGEX, tmp.string)\n            raw = '{}.{}'.format(matches.group(1),\n                                 matches.group(2))\n            self.device.prices += [float(raw)]\n\n        # parse unit\n        price_match = soup.find('span', attrs={'class': 'gh_price'})\n        matches = re.search(r'\u20ac|\u00a3|PLN', price_match.string)\n        self.device.price_currency = matches.group()\n\n        return self.device", "response": "Get new data parses it and returns a device."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_input(self, flag, path):\n        path = os.path.abspath(path)\n        if os.path.exists(path):\n            if flag:\n                self.args.append(flag)\n            self.args.append(path)\n        else:\n            utils.die(\"input file for flag '%s' does not exists:\\n  %s\" % (\n                      flag, path))", "response": "Checks that the given file exists and appends it to the args list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_path(self, path):\n        path = os.path.abspath(path)\n        if os.path.exists(path):\n            return path\n        else:\n            utils.die(\"input file does not exists:\\n  {}\".format(path))", "response": "Checks that the path exists and returns it as a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the command and return the result.", "response": "def run(self):\n        \"\"\"\n        Call this function at the end of your class's `__init__` function.\n        \"\"\"\n        stderr = os.path.abspath(os.path.join(self.outdir, self.name + '.log'))\n\n        if self.pipe:\n            self.args += ('|', self.pipe, '2>>'+stderr)\n\n        if self.gzip:\n            self.args += ('|', 'gzip', '1>', self.gzip)\n        else:\n            self.args.append('2>>'+stderr)\n            self.args.append('1>>'+stderr)\n\n        # Print timestamp to log\n\n        log = open(stderr, 'a')\n        log.write(\"[gloTK] timestamp={}\\n\".format(utils.timestamp()))\n\n        cmd = ' '.join(map(str, self.args))\n        print(cmd)\n        log.write(cmd)\n\n        start = time.time()\n        save_cwd = os.getcwd()\n        try:\n            utils.safe_mkdir(self.outdir)\n            os.chdir(self.outdir)\n            spawn_pid = os.spawnle(os.P_NOWAIT, self.shell, self.shell, '-c', cmd, self.env)\n            wait_pid, retcode, rusage = os.wait4(spawn_pid, 0)\n            if wait_pid != spawn_pid:\n                utils.die(\"could not wait for process %d: got %d\" % (spawn_pid, wait_pid))\n            os.chdir(save_cwd)\n        except OSError as e:\n            utils.info(e)\n            utils.die(\"could not run wrapper for command:\\n%s\" % cmd)\n\n        elapsed = time.time() - start\n        retcode = os.WEXITSTATUS(retcode)\n\n        if (self.return_ok is not None) and (self.return_ok != retcode):\n            # Give some context to the non-zero return.\n            if os.path.isfile(stderr):\n                subprocess.call(['tail', '-3', stderr])\n            utils.die(\"non-zero return (%d) from command:\\n%s\" % (retcode, cmd))\n        log.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_jar(self, mem=None):\n        cmd = config.get_command('java')\n        if mem:\n            cmd.append('-Xmx%s' % mem)\n        cmd.append('-jar')\n        cmd += self.cmd\n        self.run(cmd)", "response": "Run the java jar command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_check_digit(digits):\n        ints = [int(d) for d in digits]\n        l = len(ints)\n        odds = slice((l - 1) % 2, l, 2)\n        even = slice(l % 2, l, 2)\n        checksum = 3 * sum(ints[odds]) + sum(ints[even])\n        return str(-checksum % 10)", "response": "Calculate and return the GS1 check digit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the identifier s company prefix part.", "response": "def company_prefix(self):\n        \"\"\"Return the identifier's company prefix part.\"\"\"\n        offset = self.EXTRA_DIGITS\n        return self._id[offset:self._ref_idx]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the identifier s elements as tuple.", "response": "def elements(self):\n        \"\"\"Return the identifier's elements as tuple.\"\"\"\n        offset = self.EXTRA_DIGITS\n        if offset:\n            return (self._id[:offset], self.company_prefix, self._reference,\n                    self.check_digit)\n        else:\n            return (self.company_prefix, self._reference, self.check_digit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string representation of the identifier with its elements separated by the given separator.", "response": "def separated(self, separator='-'):\n        \"\"\"Return a string representation of the identifier with its elements\n        separated by the given separator.\"\"\"\n        return separator.join((part for part in self.elements() if part))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find(self, symbol, chrom=None, create=False):\n        queryset = self.get_query_set()\n\n        # Filter by chromosome if one is specified\n        if chrom:\n            queryset = queryset.filter(chr=chrom)\n\n        # Look for direct match\n        matches = queryset.filter(symbol__iexact=symbol)\n\n        try:\n            return matches[0]\n        except IndexError:\n            pass\n\n        # Attempt to disambiguate, only if this is the only synonym may it be\n        # associated\n        potential = list(\n            queryset.filter(synonyms__label__iexact=symbol).distinct())\n\n        if len(potential) == 1:\n            return potential[0]\n\n        # Only if there are no matches should we create a new record,\n        # otherwise the synonym war will continue\n        if create and len(potential) == 0:\n            instance = self.model(chr=chrom, symbol=symbol)\n            try:\n                instance.save()\n            except IntegrityError:\n                instance = queryset.get(chr=chrom, symbol=symbol)\n            return instance", "response": "Find a gene based on the symbol or disambiguate using synonyms."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning ratings episode number to be used for making graphs", "response": "def graphdata(data):\n    \"\"\"returns ratings and episode number\n    to be used for making graphs\"\"\"\n    data = jh.get_ratings(data)\n    num = 1\n    rating_final = []\n    episode_final = []\n    for k,v in data.iteritems():\n        rating=[]\n        epinum=[]\n        for r in v:\n            if r != None:\n                rating.append(float(r))\n                epinum.append(num)\n                num+=1\n        rating_final.append(rating)\n        episode_final.append(epinum)\n    return rating_final,episode_final"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef graph(data):\n    title = data['name'] + ' (' + data['rating'] + ') '\n    plt.title(title)\n    plt.xlabel('Episode Number')\n    plt.ylabel('Ratings')\n    rf,ef=graphdata(data)\n    col=['red', 'green' , 'orange']\n    for i in range(len(rf)):\n        x,y=ef[i],rf[i]\n        k = i + 1\n        plt.plot(x, y,color=col[i%3])\n    x1, x2, y1, y2 = plt.axis()\n    y2 = 10\n    if y1 > 7:\n        y1 = 7\n    plt.axis([x1, x2, y1, y2])\n    plt.show()", "response": "Draws a graph of rating vs episode number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_simple_model(self, instance, **options): # noqa\n        options = self.init_options(**options)\n        fields, include, exclude, related = options['fields'], options['include'], options['exclude'], options['related'] # noqa\n\n        result = dict(\n            model=smart_unicode(instance._meta),\n            pk=smart_unicode(\n                instance._get_pk_val(), strings_only=True),\n            fields=dict(),\n        )\n\n        default_fields = set([field.name for field in instance._meta.fields if field.serialize])\n        serialized_fields = fields or (default_fields | include) - exclude\n\n        for fname in serialized_fields:\n\n            # Respect `to_simple__<fname>`\n            to_simple = getattr(\n                self.scheme, 'to_simple__{0}'.format(fname), None)\n\n            if to_simple:\n                result['fields'][fname] = to_simple(instance, serializer=self)\n                continue\n\n            related_options = related.get(fname, dict())\n            if related_options:\n                related_options = self.init_options(**related_options)\n\n            if fname in default_fields and not related_options:\n                field = instance._meta.get_field(fname)\n                value = field.value_from_object(instance)\n\n            else:\n                value = getattr(instance, fname, None)\n                if isinstance(value, Manager):\n                    value = value.all()\n\n            result['fields'][fname] = self.to_simple(\n                value, **related_options)\n\n        if self.format != 'django':\n            fields = result['fields']\n            fields['id'] = result['pk']\n            result = fields\n\n        return result", "response": "Convert a resource to a simple python structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_memcached_usage(socket=None):\n    cmd = 'echo \\'stats\\' | nc -U {0}'.format(socket)\n    output = getoutput(cmd)\n    curr_items = None\n    bytes_ = None\n\n    rows = output.split('\\n')[:-1]\n    for row in rows:\n        row = row.split()\n        if row[1] == 'curr_items':\n            curr_items = int(row[2])\n        if row[1] == 'bytes':\n            bytes_ = int(row[2])\n    return (bytes_, curr_items)", "response": "Returns memcached statistics.\n\n    :param socket: Path to memcached's socket file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the identifier s elements as tuple.", "response": "def elements(self):\n        \"\"\"Return the identifier's elements (gs1_prefix, registration_group,\n        registrant, publication, check_digit) as tuple.\"\"\"\n        return (self.gs1_prefix, self.registration_group, self.registrant,\n                self.publication, self.check_digit)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abbr_month_date_time_str(adatetime):\n    return \"%s %d, %d at %s\" % (adatetime.strftime(\"%b\"),\n                                adatetime.day,\n                                adatetime.year,\n                                time_str(adatetime))", "response": "Return a date value in the format of\n    Month day 4 - digit - year at hour : minute [ APM ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef string_literal(self):\n        return quotedString.setParseAction(\n            lambda s, l, t: \"'{string}'\".format(string=removeQuotes(s, l, t)))", "response": "A literal string that can be used as a literal in the log file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef factory(\n        method,\n        description=\"\",\n        request_example=None,\n        request_ctor=None,\n        responses=None,\n        method_choices=HTTP_METHODS,\n    ):\n        \"\"\"\n        desc: Describes a single HTTP method of a URI\n        args:\n            -   name: method\n                type: str\n                desc: The HTTP request method to use\n            -   name: description\n                type: str\n                desc: The description of what this call does\n                required: false\n                default: \"\"\n            -   name: request_example\n                type: dict\n                desc: An example JSON request body\n                required: false\n                default: null\n            -   name: request_ctor\n                type: method\n                desc: Docstring will be parsed into help for @request_example\n                required: false\n                default: null\n            -   name: responses\n                type: list\n                subtypes: [RouteMethodResponse]\n                desc: >\n                    Each object describes a possible response and describes\n                    the condition(s) that may cause it\n                ctor: pymarshal.api_docs.routes.RouteMethodResponse.__init__\n            -   name: method_choices\n                type: list\n                subtypes: [\"str\"]\n                desc: The HTTP methods to allow for @method\n                hide: true\n                required: false\n                default: [DELETE, GET, PATCH, POST, PUT]\n        \"\"\"\n        return RouteMethod(\n            method,\n            description,\n            request_example,\n            DocString.from_ctor(request_ctor) if request_ctor else None,\n            responses,\n            method_choices,\n        )", "response": "Creates a new instance of RouteMethod for a single HTTP method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef factory(\n        description=\"\",\n        codes=[200],\n        response_example=None,\n        response_ctor=None,\n    ):\n        \"\"\"\n        desc: Describes a response to an API call\n        args:\n            -   name: description\n                type: str\n                desc: A description of the condition that causes this response\n                required: false\n                default: \"\"\n            -   name: codes\n                type: int\n                desc: >\n                    One or more HTTP status codes associated with\n                    this response\n                required: false\n                default: [200]\n            -   name: response_example\n                type: dict\n                desc: An example JSON response body\n                required: false\n                default: null\n            -   name: response_help\n                type: DocString\n                desc: Help for @response_example\n                required: false\n                default: null\n        \"\"\"\n        return RouteMethodResponse(\n            description,\n            codes,\n            response_example,\n            DocString.from_ctor(response_ctor) if response_ctor else None,\n        )", "response": "Creates a RouteMethodResponse object for the given parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_absolute_name(self):\n        res = []\n        current = self\n\n        while type(current) != type(None):\n            if current.__matched_index:\n                res.append('$')\n            res.append(current.get_type().db_field)\n            current = current._get_parent()\n        return '.'.join(reversed(res))", "response": "Returns the full dotted name of this field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef startswith(self, prefix, ignore_case=False, options=None):\n        return self.regex('^' + re.escape(prefix), ignore_case=ignore_case, options=options)", "response": "A method to check if a field starts with a given prefix string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef endswith(self, suffix, ignore_case=False, options=None):\n        return self.regex(re.escape(suffix) + '$', ignore_case=ignore_case, options=options)", "response": "A query to check if a field ends with a given suffix string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef regex(self, expression, ignore_case=False, options=None):\n        regex = {'$regex' : expression}\n        if options is not None:\n            regex['$options'] = options\n        if ignore_case:\n            regex['$options'] = regex.get('$options', '') + 'i'\n        expr = {\n            self : regex\n        }\n        return QueryExpression(expr)", "response": "A query to check if a field matches a given regular expression"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn documents near the given point.", "response": "def near(self, x, y, max_distance=None):\n        \"\"\" Return documents near the given point\n        \"\"\"\n        expr = {\n            self : {'$near' : [x, y]}\n        }\n        if max_distance is not None:\n            expr[self]['$maxDistance'] = max_distance\n        # if bucket_size is not None:\n        #     expr['$bucketSize'] = max_distance\n        return QueryExpression(expr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning documents near the given point using sphere distances", "response": "def near_sphere(self, x, y, max_distance=None):\n        \"\"\" Return documents near the given point using sphere distances\n        \"\"\"\n        expr = {\n            self : {'$nearSphere' : [x, y]}\n        }\n        if max_distance is not None:\n            expr[self]['$maxDistance'] = max_distance\n        return QueryExpression(expr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a QueryExpression that returns the record that is within the given radius.", "response": "def within_radius(self, x, y, radius):\n        \"\"\"\n            Adapted from the Mongo docs::\n\n                session.query(Places).filter(Places.loc.within_radius(1, 2, 50)\n        \"\"\"\n        return QueryExpression({\n            self : {'$within' : {\n                    '$center' : [[x, y], radius],\n                }}\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a QueryExpression that returns a copy of the object that is within the specified radius of the center of the spherical location.", "response": "def within_radius_sphere(self, x, y, radius):\n        \"\"\"\n            Adapted from the Mongo docs::\n\n                session.query(Places).filter(Places.loc.within_radius_sphere(1, 2, 50)\n        \"\"\"\n        return QueryExpression({\n            self : {'$within' : {\n                    '$centerSphere' : [[x, y], radius],\n                }}\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef in_(self, *values):\n        ''' A query to check if this query field is one of the values\n            in ``values``.  Produces a MongoDB ``$in`` expression.\n        '''\n        return QueryExpression({\n            self : { '$in' : [self.get_type().wrap_value(value) for value in values] }\n        })", "response": "A query to check if this field is one of the values\n            in values. Returns a MongoDB query expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a query expression where this field == value.", "response": "def eq_(self, value):\n        ''' Creates a query expression where ``this field == value``\n\n            .. note:: The prefered usage is via an operator: ``User.name == value``\n        '''\n        if isinstance(value, QueryField):\n            return self.__cached_id == value.__cached_id\n        return QueryExpression({ self : self.get_type().wrap_value(value) })"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a query expression where this field!= value.", "response": "def ne_(self, value):\n        ''' Creates a query expression where ``this field != value``\n\n            .. note:: The prefered usage is via an operator: ``User.name != value``\n        '''\n        if isinstance(value, QueryField):\n            return self.__cached_id != value.__cached_id\n        return self.__comparator('$ne', value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef not_(self):\n        ''' Negates this instance's query expression using MongoDB's ``$not``\n            operator\n\n            **Example**: ``(User.name == 'Jeff').not_()``\n\n            .. note:: Another usage is via an operator, but parens are needed\n                to get past precedence issues: ``~ (User.name == 'Jeff')``\n            '''\n        ret_obj = {}\n        for k, v in self.obj.items():\n            if not isinstance(v, dict):\n                ret_obj[k] = {'$ne' : v }\n                continue\n            num_ops = len([x for x in v if x[0] == '$'])\n            if num_ops != len(v) and num_ops != 0:\n                raise BadQueryException('$ operator used in field name')\n\n            if num_ops == 0:\n                ret_obj[k] = {'$ne' : v }\n                continue\n\n            for op, value in v.items():\n                k_dict = ret_obj.setdefault(k, {})\n                not_dict = k_dict.setdefault('$not', {})\n                not_dict[op] = value\n\n\n        return QueryExpression(ret_obj)", "response": "Returns a QueryExpression that does not include this instance s object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the given expression to this instance s MongoDB or expression starting a new one if one does not exst .", "response": "def or_(self, expression):\n        ''' Adds the given expression to this instance's MongoDB ``$or``\n            expression, starting a new one if one does not exst\n\n            **Example**: ``(User.name == 'Jeff').or_(User.name == 'Jack')``\n\n            .. note:: The prefered usageis via an operator: ``User.name == 'Jeff' | User.name == 'Jack'``\n\n            '''\n\n        if '$or' in self.obj:\n            self.obj['$or'].append(expression.obj)\n            return self\n        self.obj = {\n            '$or' : [self.obj, expression.obj]\n        }\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_resource(url):\n    response = R25_DAO().getURL(url, {\"Accept\": \"text/xml\"})\n    if response.status != 200:\n        raise DataFailureException(url, response.status, response.data)\n\n    tree = etree.fromstring(response.data.strip())\n\n    # XHTML response is an error response\n    xhtml = tree.xpath(\"//xhtml:html\", namespaces=nsmap)\n    if len(xhtml):\n        raise DataFailureException(url, 500, response.data)\n\n    return tree", "response": "Issue a GET request to R25 with the given url and return a response as an etree element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef weather(api_key, latitude, longitude, date_time=None):\n    # type:(str, float, float) -> Weather\n    \"\"\"\n    This is a shortcut method that can be used to perform a basic weather request with the default settings.\n\n    :param str api_key: Darksky.net API key\n    :param float latitude: The requested latitude. Maybe different from the value returned from an API request\n    :param float longitude: The requested longitude. Maybe different from the value returned from an API request\n    :param date_time: The requested date/time.\n\n    :rtype: Weather\n    \"\"\"\n    return DarkSky(api_key).weather(latitude, longitude, date_time)", "response": "This method is used to perform a basic weather request with the default settings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef url(self):\n        # type:() -> str\n        \"\"\"\n        Build and returns a URL used to make a Dark Sky API call.\n        \"\"\"\n        url = \"https://api.darksky.net/forecast/{key}/{lat},{lon}\".format(key=self.api_key,\n                                                                          lat=self.latitude,\n                                                                          lon=self.longitude)\n\n        if isinstance(self._date, datetime):\n            url += \",{:%Y-%m-%dT%H:%M:%S}\".format(self._date)\n\n        url += \"?units={}\".format(self.units)\n\n        if self.lang != \"auto\":\n            url += \"&lang={}\".format(self.lang)\n\n        if len(self._exclude) > 0:\n            url += \"&exclude=\"\n            for e in self._exclude:\n                url += \"{},\".format(e)\n            url = url.strip(\",\")\n\n        if self._extend:\n            url += \"&extend=hourly\"\n\n        return url", "response": "Builds and returns a URL used to make a Dark Sky API call."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef weather(self, latitude=None, longitude=None, date=None):\n        # type:(float, float, datetime) -> Weather\n        \"\"\"\n        :param float latitude: Locations latitude\n        :param float longitude: Locations longitude\n        :param datetime or str or int date: Date/time for historical weather data\n\n        :raises requests.exceptions.HTTPError: Raises on bad http response\n        :raises TypeError: Raises on invalid param types\n\n        :rtype: Weather\n\n        Example uses\n\n        .. code-block:: python\n\n            # DarkSky instantiation\n            >>> darksky = pydarksky.DarkSky(api_key)\n\n            # Pre-define values\n            >>> darksky.latitude = -34.9285\n            >>> darksky.longitude = 138.6005\n            >>> weather = darksky.weather()\n\n            # Pass values as params\n            >>> weather = darksky.weather(latitude=-34.9285, longitude=138.6005)\n\n            # Pass values from dict\n            >>> kwargs = {\"longitude\": 138.6005, \"latitude\": -34.9285}\n            >>> weather = darksky.weather(**kwargs)\n        \"\"\"\n\n        # If params are default(None) check if latitude/longitude have already been defined(Not None)\n        # Otherwise TypeError is raised\n        if latitude is None:\n            if self.latitude is None:\n                raise TypeError(\"latitude must be type '<class 'str'>' is None\")\n        else:\n            self.latitude = latitude\n\n        if longitude is None:\n            if self.longitude is None:\n                raise TypeError(\"longitude must be type '<class 'str'>' is None\")\n        else:\n            self.longitude = longitude\n\n        self._date = date\n\n        url = self.url\n\n        log.debug(url)\n\n        self._response = requests.get(url, headers={\"Accept-Encoding\": \"gzip\"}, timeout=5)\n        self._response.raise_for_status()\n\n        self._weather = Weather(self._response.text)\n        return self._weather", "response": "Returns a Weather object for the given latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvert the values in self. exclude that are not in self. EXCLUDES.", "response": "def exclude_invert(self):\n        # type:() -> None\n        \"\"\"\n        Inverts the values in self.exclude\n\n        .. code-block:: python\n\n            >>> import pydarksky\n            >>> darksky = pydarksky.DarkSky('0' * 32)\n\n            >>> darksky.EXCLUDES\n            ('currently', 'minutely', 'hourly', 'daily', 'alerts', 'flags')\n\n            >>> darksky.exclude = [\"alerts\", \"flags\"]\n\n            >>> darksky.exclude\n            ['alerts', 'flags']\n\n            >>> darksky.exclude_invert()\n\n            >>> darksky.exclude\n            ['currently', 'minutely', 'hourly', 'daily']\n\n        \"\"\"\n        tmp = self.exclude\n        self._exclude = []\n        for i in self.EXCLUDES:\n            if i not in tmp:\n                self._exclude.append(i)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nattempting to authenticate the request.", "response": "def authenticate(self, request):\n        \"\"\" Attempt to authenticate the request.\n\n        :param request: django.http.Request instance\n\n        :return bool: True if success else raises HTTP_401\n\n        \"\"\"\n        authenticators = self._meta.authenticators\n\n        if request.method == 'OPTIONS' and ADREST_ALLOW_OPTIONS:\n            self.auth = AnonimousAuthenticator(self)\n            return True\n\n        error_message = \"Authorization required.\"\n        for authenticator in authenticators:\n            auth = authenticator(self)\n            try:\n                if not auth.authenticate(request):\n                    raise AssertionError(error_message)\n\n                self.auth = auth\n                auth.configure(request)\n                return True\n            except AssertionError, e:\n                error_message = str(e)\n\n        raise HttpError(error_message, status=status.HTTP_401_UNAUTHORIZED)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_rights(self, resources, request=None):\n        if not self.auth:\n            return True\n\n        try:\n            if not self.auth.test_rights(resources, request=request):\n                raise AssertionError()\n\n        except AssertionError, e:\n            raise HttpError(\"Access forbiden. {0}\".format(e), status=status.HTTP_403_FORBIDDEN)", "response": "Check rights for resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_lexicon(self, data_set_reader, n_grams, min_total_occurrences, min_sentiment_value, filters):\n        counter = self.count_n_grams_py_polarity(data_set_reader, n_grams, filters)\n        lexicon = {}\n\n        pos = sum(map(lambda i: i.num_positive, counter.values()))\n        neg = sum(map(lambda i: i.num_negative, counter.values()))\n        ratio = neg / float(pos)\n\n        for key, value in counter.items():\n            if value.get_total_occurrences() <= min_total_occurrences:\n                continue\n\n            over = value.num_positive\n            under = value.num_negative\n\n            sentiment_value = math.log(ratio * over / under)\n            if abs(sentiment_value) >= min_sentiment_value:\n                lexicon[key] = sentiment_value\n\n                if RegexFilters.WHITESPACE.split(key).length == 1 and not classifier_options.is_special_class_word(key):\n                    for related_word in adjectives.get_adverb_and_adjectives(key):\n                        if related_word in counter and related_word not in lexicon:\n                            lexicon[related_word] = sentiment_value\n\n        return map_utils.normalize_map_between(lexicon, -5, 5)", "response": "Creates a lexicon from a dataset containing n - grams and their sentiment values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncounting the number of times it appeared in positive context and the number of times it appeared in negative context.", "response": "def count_n_grams_py_polarity(self, data_set_reader, n_grams, filters):\n        \"\"\"\n        Returns a map of n-gram and the number of times it appeared in positive context and the number of times it\n        appeared in negative context in dataset file.\n\n        :param data_set_reader: Dataset containing tweets and their classification\n        :param n_grams: n-grams to count occurrences for\n        :param filters: filters to apply to tweets in dataset before searching for n-grams\n        :return: Map of Counter instances for n-grams in nGrams Collection\n        \"\"\"\n        self.data_set_reader = data_set_reader\n        token_trie = TokenTrie(n_grams)\n\n        counter = {}\n\n        # Todo: parallelize\n        for entry in data_set_reader.items():\n            tweet = filters.apply(entry.get_tweet())\n            tokens = token_trie.find_optimal_tokenization(RegexFilters.WHITESPACE.split(tweet))\n\n            for n_gram in tokens:\n                n_gram_words = RegexFilters.WHITESPACE.split(n_gram)\n                if self.contains_illegal_word(n_gram_words):\n                    continue\n                if not n_gram in counter:\n                    counter[n_gram] = self.Counter()\n\n                if entry.get_classification().is_positive():\n                    counter[n_gram].num_positive += 1\n                elif entry.get_classification().is_negative():\n                    counter[n_gram].num_negative += 1\n\n        return counter"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_config(paths=DEFAULT_CONFIG_PATHS):\n    config = Config()\n    for path in paths:\n        if os.path.isfile(path):\n            config.load_pyfile(path)\n\n    return config", "response": "Attempt to load config from paths in order."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_pyfile(self, path):\n        with open(path) as config_file:\n            contents = config_file.read()\n            try:\n                exec(compile(contents, path, 'exec'), self)\n            except Exception as e:\n                raise MalformedConfig(path, six.text_type(e))", "response": "Load the python file as config.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_queryset(self, *args, **kwargs):\n        select_sql = {}\n        encrypted_fields = []\n        for f in self.model._meta.get_fields_with_model():\n            field = f[0]\n            if isinstance(field, PGPMixin):\n                select_sql[field.name] = self.get_decrypt_sql(field).format(\n                    field.model._meta.db_table,\n                    field.name,\n                    settings.PGPFIELDS_PRIVATE_KEY,\n                )\n                encrypted_fields.append(field.name)\n        return super(PGPEncryptedManager, self).get_queryset(\n            *args, **kwargs).defer(*encrypted_fields).extra(select=select_sql)", "response": "Django queryset. extra is used here to add decryption sql to query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of parameters specific to a channel for a model.", "response": "def channel_parameters(parameter_prefix, channel_names, configuration_entry):\n    \"\"\"\n    Return parameters specific to a channel for a model.\n    \"\"\"\n\n    if configuration_entry in (True, False):\n        return ([], [parameter_prefix])[configuration_entry]\n\n    parameters = []\n    if isinstance(configuration_entry, dict):\n        for name in set(channel_names).intersection(configuration_entry):\n            if configuration_entry[name] is True:\n                parameters.append(parameter_prefix + \"_\" + name)\n    else:\n        raise TypeError(\"incorrect type\")\n\n    return parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, filename, clobber=False, **kwargs):\n\n        if os.path.exists(filename) and not clobber:\n            raise IOError(\"filename {} already exists\".format(filename))\n\n        kwds = {\n            \"allow_unicode\": True, \n            \"default_flow_style\": False\n        }\n        kwds.update(kwargs)\n        with open(filename, \"w+\") as fp:\n            yaml.safe_dump(self._configuration, stream=fp, **kwds)\n        return True", "response": "Save the current configuration to a YAML - formatted file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _latex_labels(self, labels):\n\n        config = self._configuration.get(\"latex_labels\", {})\n        return [config.get(label, label) for label in labels]", "response": "Return LaTeX -ify labels based on information provided in the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parameters(self):\n\n        try:\n            return self._parameters\n\n        except AttributeError:\n            None\n\n        parameters = []\n        parameters.extend(self.grid_points.dtype.names)\n\n        model_configuration = self._configuration.get(\"model\", {})\n\n        # Continuum\n        # Note: continuum cannot just be 'True', it should be a dictionary\n        n = len(parameters)\n        continuum_config = model_configuration.get(\"continuum\", False)\n        if continuum_config is not False:\n            if not isinstance(continuum_config, dict):\n                raise TypeError(\"incorrect continuum type\")\n            for name in set(self.channel_names).intersection(continuum_config):\n                degree = continuum_config[name]\n                if degree is False:\n                    continue\n\n                # Note: N_coefficients = degree + 1\n                # Example: degree = 3: a^3 + b^2 + c^1 + d \n                parameters.extend([\"continuum_{0}_{1}\".format(name, n) \\\n                    for n in range(degree + 1)])\n\n        # Redshift\n        parameters.extend(channel_parameters(\"z\", self.channel_names,\n            model_configuration.get(\"redshift\", False)))\n\n        # Spectral resolution\n        resolution_parameters = channel_parameters(\n            \"resolution\", self.channel_names,\n            model_configuration.get(\"spectral_resolution\", False))\n        parameters.extend(resolution_parameters)\n\n        # Underestimated variance\n        parameters.extend(channel_parameters(\n            \"ln_f\", self.channel_names,\n            model_configuration.get(\"underestimated_variance\", False)))\n\n        # Outlier pixels\n        if model_configuration.get(\"outlier_pixels\", False):\n            parameters.extend([\"Po\", \"Vo\"])\n\n        assert len(parameters) == len(set(parameters)), \"Duplicate parameters!\"\n\n        self._resolution_parameters = resolution_parameters\n        self._parameters = tuple(parameters)\n\n        return self._parameters", "response": "Return the model parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _overlapping_channels(self, wavelengths):\n\n        sizes = self.meta[\"channel_sizes\"]\n        min_a, max_a = wavelengths.min(), wavelengths.max()\n\n        matched_channel_names = []\n        for i, (name, size) in enumerate(zip(self.channel_names, sizes)):\n            si = sum(sizes[:i])\n            min_b, max_b = self.wavelengths[[si, si + size - 1]]\n            if max_a > min_b and min_a < max_b:\n                matched_channel_names.append(name)\n\n        return matched_channel_names", "response": "Return the channels that overlap the given wavelength array."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats the data into a list of spectra that have exactly non - finite fluxes.", "response": "def _format_data(self, data):\n        \"\"\"\n        Sort the data in blue wavelengths to red, and ignore any spectra that\n        have entirely non-finite or negative fluxes.\n        \"\"\"\n        return [spectrum for spectrum in \\\n            sorted(data if isinstance(data, (list, tuple)) else [data],\n                key=lambda x: x.disp[0]) if np.any(np.isfinite(spectrum.flux))]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying pre - defined masks to the data.", "response": "def _apply_data_mask(self, data):\n        \"\"\"\n        Apply pre-defined masks to the data.\n        \"\"\"\n\n        data = self._format_data(data)\n\n        masked_data, pixels_affected = [], 0\n        data_mask = self._configuration.get(\"masks\", {}).get(\"data\", [])\n        for spectrum in data:\n            masked_spectrum = spectrum.copy()\n            for start, end in data_mask:\n                idx = np.clip(\n                    masked_spectrum.disp.searchsorted([start, end]) + [0, 1],\n                    0, masked_spectrum.disp.size)\n                masked_spectrum.flux[idx[0]:idx[1]] = np.nan\n                pixels_affected += np.clip(np.ptp(idx) - 1, 0, None)\n            masked_data.append(masked_spectrum)\n        \n        logger.debug(\"{0} observed pixels were masked according to the data \"\n            \"mask: {1}\".format(pixels_affected, data_mask))\n\n        return (masked_data, pixels_affected)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _model_mask(self, wavelengths=None):\n\n        if wavelengths is None:\n            wavelengths = self.wavelengths\n        wavelengths = np.array(wavelengths)\n\n        mask = np.ones_like(wavelengths, dtype=bool)\n        model_mask = self._configuration.get(\"masks\", {}).get(\"model\", [])\n        logger.debug(\"Applying model mask: {0}\".format(model_mask))\n        for start, end in model_mask:\n            idx = np.clip(wavelengths.searchsorted([start, end]) + [0, 1], 0,\n                wavelengths.size)\n            mask[idx[0]:idx[1]] = False\n        return mask", "response": "Returns a mask of the model of the current calendar."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmatches observed data to a channel and return possibly superfluous modelCOOKIE parameters.", "response": "def _match_channels_to_data(self, data):\n        \"\"\"\n        Match observed data to a channel, and return possibly superfluous model\n        parameters.\n        \"\"\"\n\n        data = self._format_data(data)\n\n        matched_channels = []\n        for spectrum in data:\n            match = self._overlapping_channels(spectrum.disp)\n            if not match:\n                # TODO: make this warning only appear once.\n                logger.warn(\"No model spectra found matching data channel from \"\n                    \"{0:.0f}-{1:.0f} Angstroms. These data will be ignored.\"\\\n                    .format(spectrum.disp[0], spectrum.disp[-1]))\n\n            if len(match) > 1:\n                raise ValueError(\"cannot match multiple channels for one spec\")\n\n            if len(match) == 0:\n                match = [None]\n\n            matched_channels.append(match[0])\n\n        missing_channels = set(self.channel_names).difference(matched_channels)\n\n        # Now which parameters should be ignored?\n        ignore_parameters = []\n        if missing_channels:\n            for channel in missing_channels:\n                ignore_parameters.extend(\n                    set(self.parameters).intersection([_.format(channel) \\\n                        for _ in (\"resolution_{}\", \"f_{}\", \"z_{}\")]))\n                \n                ignore_parameters.extend([\"continuum_{0}_{1}\".format(channel, i)\\\n                    for i in range(self._configuration[\"model\"].get(\"continuum\",\n                        {}).get(channel, -1) + 1)])\n\n        if ignore_parameters:\n            logger.warn(\"Ignoring the following model parameters because there \"\n                \"are no data for that channel: {}\".format(\", \".join(\n                    ignore_parameters)))\n\n        return (matched_channels, missing_channels, ignore_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating an initial proposal distribution around the point theta.", "response": "def _initial_proposal_distribution(self, parameters, theta, size,\n        default_std=1e-4):\n        \"\"\"\n        Generate an initial proposal distribution around the point theta.\n        \"\"\"\n\n        missing_parameters = set(parameters).difference(theta)\n        if missing_parameters:\n            raise ValueError(\"cannot create initial proposal distribution \"\\\n                \"because the following parameters are missing: {}\".format(\n                    \", \".join(missing_parameters)))\n\n        std = np.ones(len(parameters), dtype=float)\n        \n        initial_proposal_stds \\\n            = self._configuration.get(\"initial_proposal_stds\", {})\n\n        p0 = np.array([theta[p] for p in parameters])\n        std = np.array(map(float, [initial_proposal_stds.get(p, default_std) \\\n            for p in parameters]))\n\n        return np.vstack([p0 + std * np.random.normal(size=len(p0)) \\\n            for i in range(size)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cast(self, new_model_name, new_channels, output_dir=None, clobber=False,\n        **kwargs):\n        \"\"\"\n        Cast a new model from this model. The new model might have a restricted\n        wavelength range, different channels, larger sampling/binning, and/or a\n        lower spectral resolution.\n        \"\"\"\n\n        output_dir = output_dir if output_dir is not None else os.getcwd()\n        output_prefix = os.path.join(output_dir, new_model_name)\n\n        # Validation.\n        if not isinstance(new_channels, dict):\n            raise TypeError(\"channels must be a dictionary object\")\n\n        for name, descr in new_channels.iteritems():\n            if not isinstance(descr, (tuple, list, np.ndarray)) \\\n            or len(descr) != 2:\n                raise TypeError(\"channel dictionary values must be a \"\\\n                    \"(wavelength_array, spectral_resolution)\")\n\n            new_wavelengths, spectral_resolution = descr\n            if not isinstance(new_wavelengths, (list, np.ndarray)):\n                raise TypeError(\"wavelengths for the new channel {} must be an \"\n                    \"array\".format(name))\n            if 2 > len(new_wavelengths):\n                raise ValueError(\"wavelength array for the new channel {0} only\"\n                    \" contains {1} points\".format(name, len(new_wavelengths)))\n            if 0 > spectral_resolution:\n                raise ValueError(\"spectral resolution for the new channel {} \"\n                    \"must be a positive value\".format(name))\n\n        # Clobber.\n        if not clobber:\n            # Check to make sure the output files won't exist already.\n            output_suffixes = (\".yaml\", \".pkl\", \"-wavelengths.memmap\",\n                \"-intensities.memmap\")\n            for path in [output_prefix + suffix for suffix in output_suffixes]:\n                if os.path.exists(path):\n                    raise IOError(\"output filename {} already exists\"\\\n                        .format(path))\n\n        # Sort the proposed channel names from blue to red wavelengths.\n        channel_names = []\n        min_wavelengths = []\n        for name, (wavelengths, resolution) in new_channels.iteritems():\n            channel_names.append(name)\n            min_wavelengths.append(np.min(wavelengths))\n\n        channel_names = np.array(channel_names)[np.argsort(min_wavelengths)]\n\n        # Get the wavelengths.\n        channel_wavelengths = []\n        wavelength_range = [self.wavelengths.min(), self.wavelengths.max()]\n        for name in channel_names:\n\n            new_wavelength = np.sort(new_channels[name][0])\n            i = np.searchsorted(new_wavelength, wavelength_range)\n            channel_wavelengths.append(new_wavelength[i[0]:i[1]])\n\n            if i[0] != 0 or i[1] != len(new_wavelength):\n                logger.warn(\"Clipping requested wavelength range in channel {0}\"\n                    \" from {1:.0f}-{2:.0f} A to {3:.0f}-{4:.0f} A because the \"\n                    \"region requested was not covered by the original model.\"\\\n                    .format(name, new_wavelength[0], new_wavelength[-1],\n                        new_wavelength[i[0]], new_wavelength[i[1]]))\n\n        channel_wavelengths = [new_channels[n][0] for n in channel_names]\n        channel_sizes = [len(_) for _ in channel_wavelengths]\n        num_pixels = sum(channel_sizes)\n\n        # Find out which of the new channels overlap with the existing channels.\n        channel_matches = {}\n        for name, wavelengths in zip(channel_names, channel_wavelengths):\n\n            overlapping_old_channels = self._overlapping_channels(wavelengths)\n\n            # if there are no overlaps, do we have a problem?\n            if len(overlapping_old_channels) == 0:\n                raise ValueError(\"no channels overlapping\")\n\n            elif len(overlapping_old_channels) > 1:\n                raise ValueError(\"too many channels overlapping!\")\n\n            channel_matches[name] = overlapping_old_channels[0]\n\n        # Create the memory-mapped wavelength file.\n        wavelengths_memmap = np.memmap(output_prefix + \"-wavelengths.memmap\",\n            dtype=\"float32\", mode=\"w+\", shape=(num_pixels, ))\n        wavelengths_memmap[:] = np.hstack(channel_wavelengths)\n        wavelengths_memmap.flush()\n        del wavelengths_memmap\n\n        # Write the new configuration to file.\n        with open(output_prefix + \".yaml\", \"w\") as fp:\n            header = \"\\n\".join([\n                \"# Model created on {0} from previous model with hash {1}\"\\\n                    .format(strftime(\"%Y-%m-%d %H:%M:%S\"), self.hash),\n                \"# Grid parameters: {0}\".format(\n                    \", \".join(self.grid_points.dtype.names)),\n                \"# Channel names: {0}\".format(\n                    \", \".join(channel_names))\n                ])\n            configuration = self._configuration.copy()\n            configuration.update({\n                \"model_grid\": {\n                    \"grid_points\": output_prefix + \".pkl\",\n                    \"wavelengths\": output_prefix + \"-wavelengths.memmap\",\n                    \"intensities\": output_prefix + \"-intensities.memmap\"\n                }\n            })\n            fp.write(header + \"\\n\" + yaml.safe_dump(configuration, stream=None, \n                allow_unicode=True, default_flow_style=False))\n\n        # Create the pickled model file, with meta data.\n        meta = self.meta.copy()\n        meta.update({\n            \"channel_names\": channel_names,\n            \"channel_sizes\": channel_sizes,\n            \"channel_resolutions\": [new_channels[n][1] for n in channel_names]\n        })\n        with open(output_prefix + \".pkl\", \"wb\") as fp:\n            pickle.dump((self.grid_points, meta), fp, -1)\n            \n        # Create the rebinning matrices.\n        convolutions = []\n        wavelength_indices = []\n        fast_binning \\\n            = self._configuration.get(\"settings\", {}).get(\"fast_binning\", False)\n        for name in channel_names:\n            new_wavelengths, spectral_resolution = new_channels[name]\n\n            indices = np.clip(self.wavelengths.searchsorted(\n                [new_wavelengths.min(), new_wavelengths.max()]) + [0, 1],\n                0, self.wavelengths.size - 1)\n            wavelength_indices.append(indices)\n            old_wavelengths = self.wavelengths[indices[0]:indices[1]]\n            logger.debug(\"Casting {0} channel from [{1:.0f}, {2:.0f}] to \"\\\n                \"[{3:.0f}, {4:.0f}]\".format(name,\n                    old_wavelengths[0], old_wavelengths[-1],\n                    new_wavelengths[0], new_wavelengths[-1]))\n\n            if fast_binning:\n                if spectral_resolution is None \\\n                or not np.isfinite(spectral_resolution):\n                    convolutions.append(lambda nw, ow, of: \\\n                        np.interp(nw, ow, of, left=np.nan, right=np.nan))\n\n                else:\n                    print(\"OK\")\n                    logger.debug(\"Using fast binning with spectral resolution\")\n                    R_scale = 2.3548200450309493 * new_wavelengths.mean()**2/ np.diff(new_wavelengths).mean()\n                    convolutions.append(lambda nw, ow, of: \\\n                        np.interp(nw, ow,\n                            gaussian_filter1d(of, R_scale/spectral_resolution**2),\n                            left=np.nan, right=np.nan))\n\n            else:\n                if spectral_resolution is None \\\n                or not np.isfinite(spectral_resolution):\n                    convolutions.append(lambda *_: _[2] * specutils.sample.resample(\n                        old_wavelengths, new_wavelengths))\n                else:\n                    convolutions.append(lambda *_: _[2] * \\\n                        specutils.sample.resample_and_convolve(old_wavelengths,\n                            new_wavelengths, new_resolution=spectral_resolution))\n            \n        # Load the intensities.\n        intensities = np.memmap(\n            self._configuration[\"model_grid\"][\"intensities\"],\n            shape=(self.grid_points.size, self.wavelengths.size),\n            mode=\"r\", dtype=\"float32\")\n\n        # Create a new intensities grid.\n        cast_intensities = np.memmap(\n            output_prefix + \"-intensities.memmap\",\n            shape=(self.grid_points.size, num_pixels),\n            mode=\"w+\", dtype=\"float32\")\n\n        n = self.grid_points.size\n        increment = int(n / 100)\n        progressbar = kwargs.pop(\"__progressbar\", False)\n        if progressbar:\n            print(\"Casting {} model:\".format(new_model_name))\n\n        for i in xrange(n):\n            if progressbar:\n                if (i % increment == 0):\n                    sys.stdout.write(\"\\r[{done}{not_done}] \"\n                        \"{percent:3.0f}%\".format(done=\"=\" * int(i / increment),\n                        not_done=\" \" * int((n - i)/ increment),\n                        percent=100. * i/n))\n                    sys.stdout.flush()\n            else:\n                logger.debug(\"Recasting point {0}/{1}\".format(i, n))\n\n            for j, (size, convolution, indices) \\\n            in enumerate(zip(channel_sizes, convolutions, wavelength_indices)):\n\n                new_wavelengths, _ = new_channels[channel_names[j]]\n                old_wl_idxs = np.clip(self.wavelengths.searchsorted(\n                    [new_wavelengths.min(), new_wavelengths.max()]) + [0, 1],\n                    0, self.wavelengths.size - 1)\n                old_wavelengths = self.wavelengths[old_wl_idxs[0]:old_wl_idxs[1]]\n\n                old_fluxes = np.copy(intensities[i, indices[0]:indices[1]])\n\n                idx = sum(channel_sizes[:j])\n                cast_intensities[i, idx:idx + size] = convolution(new_wavelengths, old_wavelengths, old_fluxes)\n\n        \"\"\"\n        for j, (size, matrix, indices) \\\n        in enumerate(zip(channel_sizes, convolutions, wavelength_indices)):\n            idx = sum(channel_sizes[:j])\n            cast_intensities[:, idx:idx + size] = \\\n                intensities[:, indices[0]:indices[1]] * matrix\n        \"\"\"\n\n        cast_intensities.flush()\n        del cast_intensities\n        if progressbar:\n            print(\"\\r\")\n\n        return True", "response": "Cast a new model from this model to a new model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mockdata_url(service_name, implementation_name,\n                     url, headers):\n    \"\"\"\n    :param service_name:\n        possible \"sws\", \"pws\", \"book\", \"hfs\", etc.\n    :param implementation_name:\n        possible values: \"file\", etc.\n    \"\"\"\n\n    RESOURCE_ROOT = _mockdata_path_root(service_name, implementation_name)\n    file_path = None\n    success = False\n    start_time = time.time()\n\n    mockdata_delay = getattr(settings, \"RESTCLIENTS_MOCKDATA_DELAY\", 0.0)\n    time.sleep(mockdata_delay)\n\n    for resource_dir in app_resource_dirs:\n        logger.debug(\"Check url %s, service_name: %s, in resource_dir: %s\" %\n                     (url, service_name, resource_dir))\n\n        response = _load_resource_from_path(resource_dir, service_name,\n                                            implementation_name, url, headers)\n\n        if response:\n            request_time = time.time() - start_time\n            rest_request.send(sender='restclients',\n                              url=url,\n                              request_time=request_time,\n                              hostname=socket.gethostname(),\n                              service_name=service_name)\n            rest_request_passfail.send(sender='restclients',\n                                       url=url,\n                                       success=True,\n                                       hostname=socket.gethostname(),\n                                       service_name=service_name)\n            return response\n\n    # If no response has been found in any installed app, return a 404\n    logger.info(\"404 for url %s, path: %s\" %\n                (url, \"resources/%s/%s/%s\" %\n                 (service_name,\n                  implementation_name,\n                  convert_to_platform_safe(url))))\n    rest_request_passfail.send(sender='restclients',\n                               url=url,\n                               success=False,\n                               hostname=socket.gethostname(),\n                               service_name=service_name)\n    response = MockHTTP()\n    response.status = 404\n    response.reason = \"Not Found\"\n    return response", "response": "Get a mockdata url for a given service and implementation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_mockdata_url(service_name, implementation_name,\n                        url, headers,\n                        dir_base=dirname(__file__)):\n    \"\"\"\n    :param service_name:\n        possible \"sws\", \"pws\", \"book\", \"hfs\", etc.\n    :param implementation_name:\n        possible values: \"file\", etc.\n    \"\"\"\n    # Http response code 204 No Content:\n    # The server has fulfilled the request but does not need to\n    # return an entity-body\n    response = MockHTTP()\n    response.status = 204\n    return response", "response": "Delete the mockdata url."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the response body and header if exist.", "response": "def read_resp_data(service_name, implementation_name, url, response):\n    \"\"\"\n    Read the (DELETE, PATCH, POST, PUT) response body and header if exist.\n    \"\"\"\n    RR = _mockdata_path_root(service_name, implementation_name)\n    for resource_dir in app_resource_dirs:\n        path = os.path.join(resource_dir['path'],\n                            service_name,\n                            implementation_name)\n        found_header = _read_resp_header(path, url, response)\n        found_body = _read_resp_body(path, url, response)\n        if found_body or found_header:\n            return response\n    response.status = 404\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the MD5 of a file.", "response": "def file_md5(f, size=8192):\n    \"Calculates the MD5 of a file.\"\n    md5 = hashlib.md5()\n    while True:\n        data = f.read(size)\n        if not data:\n            break\n        md5.update(data)\n    return md5.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvoke pip in a subprocess, with semantics very similar to `pip.main()` Why use check_call instead of check_output? It's behavior is slightly closer to the older `pip.main()` behavior, printing output information directly to stdout. check_call was added in py2.5 and is supported through py3.x , so it's more compatible than some alternatives like subprocess.run (added in py3.5)", "response": "def main(*args):\n    \"\"\"\n    Invoke pip in a subprocess, with semantics very similar to `pip.main()`\n\n    Why use check_call instead of check_output?\n    It's behavior is slightly closer to the older `pip.main()` behavior,\n    printing output information directly to stdout.\n\n    check_call was added in py2.5 and is supported through py3.x , so it's more\n    compatible than some alternatives like subprocess.run (added in py3.5)\n    \"\"\"\n    try:\n        subprocess.check_call([sys.executable, '-m', 'pip'] + list(args))\n        return 0\n    except subprocess.CalledProcessError as err:\n        return err.returncode"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a file or create it.", "response": "def open_fd(cls, name):\n        \"\"\"Open a file or create it.\"\"\"\n        # Try to create it, if can't, try to open.\n        try:\n            return os.open(name, os.O_CREAT | os.O_RDWR | os.O_EXCL)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n            return os.open(name, os.O_RDWR | os.O_EXCL)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new_game(self):\n        self.game = self.game_class(self, self.screen)\n        self.save()", "response": "Creates a new game of 2048."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the best score from file.", "response": "def _load_score(self):\n        \"\"\"Load the best score from file.\"\"\"\n        score = int(self.score_file.read())\n        self.score_file.seek(0, os.SEEK_SET)\n        return score"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef got_score(self, score):\n        if score > self._score:\n            delta = score - self._score\n            self._score = score\n            self._score_changed = True\n            self.save()\n            return delta\n        return 0", "response": "Update the best score if the new score is higher return the change."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef require_backup_exists(func):\n    def new_func(*args, **kwargs):\n        backup_file = kwargs['backup_file']\n        if not os.path.exists(backup_file):\n            raise RestoreError(\"Could not find file '{0}'\".format(backup_file))\n        return func(*args, **kwargs)\n    return new_func", "response": "Decorator that ensures that the backup file exists in the file system before running the decorated function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_mysql_args(db_config):\n    db = db_config['NAME']\n\n    mapping = [('--user={0}', db_config.get('USER')),\n               ('--password={0}', db_config.get('PASSWORD')),\n               ('--host={0}', db_config.get('HOST')),\n               ('--port={0}', db_config.get('PORT'))]\n    args = apply_arg_values(mapping)\n    args.append(db)\n\n    return args", "response": "Returns an array of argument values that will be passed to a mysqldump process when it is started based on the given database\n    configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an array of argument values that will be passed to a PostgreSQL dump process when it is started based on the given database configuration.", "response": "def get_postgresql_args(db_config, extra_args=None):\n    \"\"\"\n    Returns an array of argument values that will be passed to a `psql` or\n    `pg_dump` process when it is started based on the given database\n    configuration.\n    \"\"\"\n    db = db_config['NAME']\n\n    mapping = [('--username={0}', db_config.get('USER')),\n               ('--host={0}', db_config.get('HOST')),\n               ('--port={0}', db_config.get('PORT'))]\n    args = apply_arg_values(mapping)\n\n    if extra_args is not None:\n        args.extend(shlex.split(extra_args))\n    args.append(db)\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for a project by id.", "response": "def project(self, term, **kwargs):\n        \"\"\"Search for a project by id.\n\n        Args:\n          term (str): Term to search for.\n          kwargs (dict): additional keywords passed into\n            requests.session.get params keyword.\n        \"\"\"\n        params = kwargs\n        baseuri = self._BASE_URI + 'projects/' + term\n        res = self.session.get(baseuri, params=params)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for projects. Defaults to project_title. Other fields are project_reference project_abstract", "response": "def projects(self, term, field=None, **kwargs):\n        \"\"\"Search for projects. Defaults to project_title. Other fields\n        are:\n            project_reference\n            project_abstract\n\n        Args:\n          term (str): Term to search for.\n          kwargs (dict): additional keywords passed into\n            requests.session.get params keyword.\n        \"\"\"\n        params = kwargs\n        params['q'] = term\n        if field:\n            params['f'] = self._FIELD_MAP[field]\n        else:\n            params['f'] = 'pro.t'\n        baseuri = self._BASE_URI + 'projects'\n        res = self.session.get(baseuri, params=params)\n        self.handle_http_error(res)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that value is a dict that every key is a valid MongoDB key and that every value is a valid MongoDB value and that every value is a valid MongoDB value.", "response": "def validate_unwrap(self, value):\n        ''' Checks that value is a ``dict``, that every key is a valid MongoDB\n            key, and that every value validates based on DictField.value_type\n        '''\n        if not isinstance(value, dict):\n            self._fail_validation_type(value, dict)\n        for k, v in value.items():\n            self._validate_key_unwrap(k)\n            try:\n                self.value_type.validate_unwrap(v)\n            except BadValueException as bve:\n                self._fail_validation(value, 'Bad value for key %s' % k, cause=bve)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_wrap(self, value):\n        ''' Checks that value is a ``dict``, that every key is a valid MongoDB\n            key, and that every value validates based on DictField.value_type\n        '''\n        if not isinstance(value, dict):\n            self._fail_validation_type(value, dict)\n        for k, v in value.items():\n            self._validate_key_wrap(k)\n            try:\n                self.value_type.validate_wrap(v)\n            except BadValueException as bve:\n                self._fail_validation(value, 'Bad value for key %s' % k, cause=bve)", "response": "Checks that value is a dict that every key is a valid MongoDB\n            key and that every value is a valid MongoDB\n            value and that every value is a valid MongoDB\n            value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate and then returns a dictionary with each key in value mapped to its value wrapped with self. value_type.", "response": "def wrap(self, value):\n        ''' Validates ``value`` and then returns a dictionary with each key in\n            ``value`` mapped to its value wrapped with ``DictField.value_type``\n        '''\n        self.validate_wrap(value)\n        ret = {}\n        for k, v in value.items():\n            ret[k] = self.value_type.wrap(v)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unwrap(self, value, session=None):\n        ''' Validates ``value`` and then returns a dictionary with each key in\n            ``value`` mapped to its value unwrapped using ``DictField.value_type``\n        '''\n        self.validate_unwrap(value)\n        ret = {}\n        for k, v in value.items():\n            ret[k] = self.value_type.unwrap(v, session=session)\n        return ret", "response": "Validates and returns a dictionary with each key in\n            value mapped to its value unwrapped using self. value_type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping the keys and values of the key_type and value_type fields in a list of dictionaries.", "response": "def wrap(self, value):\n        ''' Expects a dictionary with the keys being instances of ``KVField.key_type``\n            and the values being instances of ``KVField.value_type``.  After validation,\n            the dictionary is transformed into a list of dictionaries with ``k`` and ``v``\n            fields set to the keys and values from the original dictionary.\n        '''\n        self.validate_wrap(value)\n        ret = []\n        for k, v in value.items():\n            k = self.key_type.wrap(k)\n            v = self.value_type.wrap(v)\n            ret.append( { 'k' : k, 'v' : v })\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unwrap(self, value, session=None):\n        ''' Expects a list of dictionaries with ``k`` and ``v`` set to the\n            keys and values that will be unwrapped into the output python\n            dictionary should have.  Validates the input and then constructs the\n            dictionary from the list.\n        '''\n        self.validate_unwrap(value)\n        ret = {}\n        for value_dict in value:\n            k = value_dict['k']\n            v = value_dict['v']\n            ret[self.key_type.unwrap(k, session=session)] = self.value_type.unwrap(v, session=session)\n        return ret", "response": "Unwraps the keys and values of the object into the corresponding python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies all QueryFilters to the query.", "response": "def apply_filters(query, args):\n    \"\"\"\n    Apply all QueryFilters, validating the querystring in the process.\n    \"\"\"\n    pre_joins = []\n    for querystring_key, filter_value in args.items(multi=True):\n        if querystring_key in filter_registry:\n            cls_inst = filter_registry[querystring_key]\n            query = cls_inst.apply_filter(query, args, pre_joins)\n        elif querystring_key in PaginationKeys._value_list:\n            pass\n        else:\n            raise InvalidQueryString(querystring_key, filter_value)\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a message of 32 bytes and a private key Returns a recoverable signature of length 64", "response": "def _ecdsa_sign_recoverable(msg32, seckey):\n    \"\"\"\n        Takes a message of 32 bytes and a private key\n        Returns a recoverable signature of length 64\n    \"\"\"\n    assert isinstance(msg32, bytes)\n    assert isinstance(seckey, bytes)\n    assert len(msg32) == len(seckey) == 32\n    if not _verify_seckey(seckey):\n        raise InvalidPrivateKeyError()\n\n    # Make a recoverable signature of 65 bytes\n    sig64 = ffi.new(\"secp256k1_ecdsa_recoverable_signature *\")\n\n    lib.secp256k1_ecdsa_sign_recoverable(\n        ctx,\n        sig64,\n        msg32,\n        seckey,\n        ffi.addressof(lib, \"secp256k1_nonce_function_default\"),\n        ndata,\n    )\n    return sig64"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a recoverable signature and return a parsed recoverable signature.", "response": "def _parse_to_recoverable_signature(sig):\n    \"\"\"\n        Returns a parsed recoverable signature of length 65 bytes\n    \"\"\"\n    # Buffer for getting values of signature object\n    assert isinstance(sig, bytes)\n    assert len(sig) == 65\n\n    # Make a recoverable signature of 65 bytes\n    rec_sig = ffi.new(\"secp256k1_ecdsa_recoverable_signature *\")\n    # Retrieving the recid from the last byte of the signed key\n    recid = ord(sig[64:65])\n\n    # Parse a revoverable signature\n    parsable_sig = lib.secp256k1_ecdsa_recoverable_signature_parse_compact(\n        ctx,\n        rec_sig,\n        sig,\n        recid\n    )\n    # Verify that the signature is parsable\n    if not parsable_sig:\n        raise InvalidSignatureError()\n\n    return rec_sig"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake the same message and seckey as _ecdsa_sign_recoverable Returns an unsigned char array of length 65 containing the signed message", "response": "def ecdsa_sign_compact(msg32, seckey):\n    \"\"\"\n        Takes the same message and seckey as _ecdsa_sign_recoverable\n        Returns an unsigned char array of length 65 containing the signed message\n    \"\"\"\n    # Assign 65 bytes to output\n    output64 = ffi.new(\"unsigned char[65]\")\n    # ffi definition of recid\n    recid = ffi.new(\"int *\")\n\n    lib.secp256k1_ecdsa_recoverable_signature_serialize_compact(\n        ctx,\n        output64,\n        recid,\n        _ecdsa_sign_recoverable(msg32, seckey)\n    )\n\n    # Assign recid to the last byte in the output array\n    r = ffi.buffer(output64)[:64] + struct.pack(\"B\", recid[0])\n    assert len(r) == 65, len(r)\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ecdsa_recover_compact(msg32, sig):\n    assert isinstance(msg32, bytes)\n    assert len(msg32) == 32\n    _check_signature(sig)\n    # Check that recid is of valid value\n    recid = ord(sig[64:65])\n\n    if not (recid >= 0 and recid <= 3):\n        raise InvalidSignatureError()\n\n    # Setting the pubkey array\n    pubkey = ffi.new(\"secp256k1_pubkey *\")\n\n    lib.secp256k1_ecdsa_recover(\n        ctx,\n        pubkey,\n        _parse_to_recoverable_signature(sig),\n        msg32\n    )\n\n    serialized_pubkey = _serialize_pubkey(pubkey)\n\n    buf = ffi.buffer(serialized_pubkey, 65)\n    r = buf[:]\n    assert isinstance(r, bytes)\n    assert len(r) == 65, len(r)\n    return r", "response": "Takes the message and a parsed recoverable signature\n    Returns the serialized public key in the sign function\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ecdsa_verify_compact(msg32, sig, pub):\n    assert isinstance(msg32, bytes)\n    assert len(msg32) == 32\n    # Check if pubkey has been bin_electrum encoded.\n    # If so, append \\04 to the front of the key, to make sure the length is 65\n    if len(pub) == 64:\n        pub = b'\\04'+pub\n    assert len(pub) == 65\n    _check_signature(sig)\n\n    # Setting the pubkey array\n    c_sig = ffi.new(\"secp256k1_ecdsa_signature *\")\n\n    # converts the recoverable signature to a signature\n    lib.secp256k1_ecdsa_recoverable_signature_convert(\n        ctx,\n        c_sig,\n        _parse_to_recoverable_signature(sig)\n    )\n\n    is_valid = lib.secp256k1_ecdsa_verify(\n        ctx,\n        c_sig,  # const secp256k1_ecdsa_signature\n        msg32,  # const unsigned char\n        _deserialize_pubkey(pub)  # const secp256k1_pubkey\n    )\n    return is_valid == 1", "response": "Verify a message with a signature and a public key. Returns True if the signature is valid False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ecdsa_recover_raw(rawhash, vrs):\n    assert len(vrs) == 3\n    assert len(rawhash) == 32\n    return ecdsa_recover_compact(rawhash, _encode_sig(*vrs))", "response": "Takes a rawhash message of length 32 bytes and a tuple containing a v r s tuple containing the public key used in the sign function\n    Returns a public key for the private key used in the sign function\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nverify a message with a public key Returns 1 if signature is valid with given pubkey", "response": "def ecdsa_verify_raw(msg32, vrs, pub):\n    \"\"\"\n        Takes a message, the signature being verified and a pubkey\n        Returns 1 if signature is valid with given pubkey\n    \"\"\"\n    # assert len(vrs) == 3\n    if len(vrs) == 3:\n        return ecdsa_verify_compact(msg32, _encode_sig(*vrs), pub)\n    else:\n        return ecdsa_verify_compact(msg32, vrs, pub)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef minimise(objective_function, p0, **kwargs):\n\n    p0 = np.array(p0)\n\n    op_kwargs = kwargs.copy()\n\n    # Which optimisation algorithm?\n    available_methods = (\"BFGS\", \"Nelder-Mead\", \"Powell\", \"CG\", \"TNC\")\n    method = op_kwargs.pop(\"method\", available_methods[0])\n    logger.debug(\"Optimising with {0} algorithm\".format(method))\n\n    op_kwargs.update({ \"callback\": None, \"full_output\": True, \"retall\": False })\n\n    def _drop_forbidden_keywords(op_kwds, allowed):\n        for keyword in set(op_kwds).difference(allowed):\n            logger.debug(\"Dropping optimisation keyword {0}: {1}\".format(\n                keyword, op_kwds.pop(keyword)))\n\n    t_init = time()\n    if method == \"Nelder-Mead\":\n        # Need to force some arguments.\n        # Optional arguments:\n        # xtol, ftol, maxiter, maxfun\n        _drop_forbidden_keywords(op_kwargs, (\"xtol\", \"ftol\", \"maxiter\", \n            \"maxfun\", \"full_output\", \"retall\", \"callback\", \"disp\"))\n\n        # Set defaults.\n        op_kwargs.setdefault(\"disp\", False)\n\n        x_opt, f_opt, num_iter, num_funcalls, warnflag \\\n            = op.fmin(objective_function, p0, **op_kwargs)\n\n        logger.debug(\"Number of iterations: {0}, number of function calls: {1}\"\\\n            .format(num_iter, num_funcalls))\n\n        if warnflag == 0:\n            logger.debug(\"Optimisation converged after {0:.1f} seconds.\".format(\n                time() - t_init))\n        else:\n            logger.warn(\"Optimisation failed: {0}\".format([\n                \"Maximum number of function evaluations.\",\n                \"Maximum number of iterations.\"][warnflag - 1]))\n\n    elif method == \"Powell\":\n        # Optional arguments: xtol, ftol, maxiter, maxfun\n        _drop_forbidden_keywords(op_kwargs, (\"xtol\", \"ftol\", \"maxiter\", \n            \"maxfun\", \"retall\", \"callback\", \"full_output\", \"disp\"))\n        \n        # Set defaults.\n        op_kwargs.setdefault(\"disp\", False)\n\n        x_opt, f_opt, direc, num_iter, num_funcalls, warnflag \\\n            = op.fmin_powell(objective_function, p0, **op_kwargs)\n\n        logger.debug(\"Number of iterations: {0}, number of function calls: {1}\"\\\n            .format(num_iter, num_funcalls))\n\n        if warnflag == 0:\n            logger.debug(\"Optimisation converged after {0:.1f} seconds.\".format(\n                time() - t_init))\n        else:\n            logger.warn(\"Optimisation failed: {0}\".format([\n                \"Maximum number of function evaluations.\",\n                \"Maximum number of iterations.\"][warnflag - 1]))\n\n    elif method == \"CG\":\n        # Optional arguments: gtol, norm, epsilon, maxiter.\n        _drop_forbidden_keywords(op_kwargs, (\"gtol\", \"norm\", \"epsilon\", \n            \"maxiter\", \"retall\", \"callback\", \"full_output\"))\n\n        x_opt, f_opt, num_funcalls, num_gradcalls, warnflag \\\n            = op.fmin_cg(objective_function, p0, **op_kwargs)\n\n        logger.debug(\"Number of function calls: {0}, gradient calls: {1}\"\\\n            .format(num_funcalls, num_gradcalls))\n\n        if warnflag == 0:\n            logger.debug(\"Optimisation converged after {0:.1f} seconds.\".format(\n                time() - t_init))\n        else:\n            logger.debug(\"Optimisation failed: {0}\".format([\n                \"Maximum number of iterations exceeded\",\n                \"Gradient and/or function calls were not changing.\"\n                ][warnflag - 1]))\n\n    elif method == \"BFGS\":\n        # Since we have at least some boundaries, this will actually call\n        # the L-BFGS-B algorithm.\n        # Optional arguments: m, factr, pgtol, epsilon, maxfun, maxiter\n\n        _drop_forbidden_keywords(op_kwargs, (\"m\", \"factr\", \"pgtol\", \n            \"approx_grad\", \"epsilon\", \"disp\", \"iprint\", \"maxfun\", \"maxiter\"))\n\n        # Default/required:\n        op_kwargs.setdefault(\"factr\", 10.0)\n        op_kwargs[\"approx_grad\"] = True\n        \n        # Because the parameters will vary by orders of magnitude, here we\n        # scale everything to the initial value so that the epsilon keyword\n        # makes some sense.\n\n        scale = p0.copy()\n        \n        def scaled_objective_function(theta):\n            return objective_function(theta.copy() * scale)\n\n        x_opt, f_opt, info_dict = op.fmin_l_bfgs_b(scaled_objective_function,\n            np.ones(p0.size, dtype=float), **op_kwargs)\n\n        # Rescale.\n        x_opt *= scale\n\n        g_opt = info_dict[\"grad\"]\n        num_iter = info_dict[\"nit\"]\n        num_funcalls = info_dict[\"funcalls\"]\n        warnflag = info_dict[\"warnflag\"]\n\n        logger.debug(\"Number of iterations: {0}, function calls: {1}\".format(\n            num_iter, num_funcalls))\n        if warnflag == 0:\n            logger.debug(\"Optimisation converged after {0:.1f} seconds.\".format(\n                time() - t_init))\n        else:\n            logger.warn(\"Optimisation failed: {0}\".format([\n                \"Too many function evaluations or iterations!\",\n                \"{0}\".format(info_dict.get(\"task\", None))][warnflag - 1]))\n    \n    elif method == \"TNC\":\n        # Optional arguments:   bounds, epsilon, scale, offset, messages, \n        #                       maxCGit, maxfun, eta, stepmx, accuracy, \n        #                       fmin, ftol, xtol, pgtol, rescale\n\n        _drop_forbidden_keywords(op_kwargs, (\"approx_grad\", \"bounds\", \"epsilon\",\n            \"scale\", \"offset\", \"messages\", \"maxCGit\", \"maxfun\", \"eta\", \"stepmx\",\n            \"accuracy\", \"fmin\", \"ftol\", \"xtol\", \"pgtol\", \"rescale\", \"disp\"))\n\n        # Required:\n        op_kwargs[\"approx_grad\"] = True\n\n        x_opt, num_funcalls, rc = op.fmin_tnc(objective_function, p0, \n            **op_kwargs)\n        \n        rcstring = {\n            -1: \"Infeasible (lower bound > upper bound)\",\n            0: \"Local minimum reached (|pg| ~= 0)\",\n            1: \"Converged (|f_n-f_(n-1)| ~= 0)\",\n            2: \"Converged (|x_n-x_(n-1)| ~= 0)\",\n            3: \"Max. number of function evaluations reached\",\n            4: \"Linear search failed\",\n            5: \"All lower bounds are equal to the upper bounds\",\n            6: \"Unable to progress\",\n            7: \"User requested end of minimization\"\n        }[rc]\n\n        logger.debug(\"Number of function calls: {0}, result: {1}\".format(\n            num_funcalls, rcstring))\n        if rc in (1, 2):\n            logger.debug(\"Optimisation converged after {0:.1f} seconds: {1}\"\\\n                .format(time() - t_init, rcstring))\n        else:\n            logger.warn(\"Optimisation failed: {0}\".format(rcstring))\n\n    else:\n        raise ValueError(\"optimisation algorithm {0} is not available \"\\\n            \"(available methods are {1})\".format(\n                method, \", \".join(available_methods)))\n\n\n    return x_opt", "response": "A safe minimisation function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning bootstrap. py with a different python executable", "response": "def _run_with_different_python(executable):\n    \"\"\" Run bootstrap.py with a different python executable \"\"\"\n    args = [arg for arg in sys.argv if arg != VIRTUALENV_OPTION]\n    args.insert(0, executable)\n    print(\"Running bootstrap.py with {0}\".format(executable))\n    exit(subprocess.call(args))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_modules(pkg_name, module_filter = None):\r\n    path = app_path(pkg_name)\r\n    #py_filter = lambda f: all((fnmatch(f, \"*.py\"), not f.startswith(\"__\"), module_filter and module_filter(f) or True))\r\n    py_filter = lambda f: all((fnmatch(f, \"*.pyc\") or fnmatch(f, \"*.py\"), not f.startswith(\"__\"), module_filter and module_filter(f) or True))\r\n    names = [splitext(n)[0] for n in os.listdir(path) if py_filter(n)]\r\n    return [__import__(\"{0}.{1}\".format(pkg_name, n)).__dict__[n] for n in names]", "response": "Returns a list of modules in a given package."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of all the members of a package.", "response": "def get_members(pkg_name, module_filter = None, member_filter = None):\r\n    \"\"\"\r\n        \u8fd4\u56de\u5305\u4e2d\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u6a21\u5757\u6210\u5458\u3002\r\n\r\n        \u53c2\u6570:\r\n            pkg_name        \u5305\u540d\u79f0\r\n            module_filter   \u6a21\u5757\u540d\u8fc7\u6ee4\u5668 def (module_name)\r\n            member_filter   \u6210\u5458\u8fc7\u6ee4\u5668 def member_filter(module_member_object)\r\n    \"\"\"\r\n    modules = get_modules(pkg_name, module_filter)\r\n\r\n    ret = {}\r\n    for m in modules:\r\n        members = dict((\"{0}.{1}\".format(v.__module__, k), v) for k, v in getmembers(m, member_filter))\r\n        ret.update(members)\r\n\r\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef args_range(min_value, max_value, *args):\r\n    not_null(*args)\r\n\r\n    if not all(map(lambda v: min_value <= v <= max_value, args)):\r\n        raise ValueError(\"Argument must be between {0} and {1}!\".format(min_value, max_value))", "response": "Ensure that the given arguments are within the given range."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef args_length(min_len, max_len, *args):\r\n    not_null(*args)\r\n\r\n    if not all(map(lambda v: min_len <= len(v) <= max_len, args)):\r\n        raise ValueError(\"Argument length must be between {0} and {1}!\".format(min_len, max_len))", "response": "Check that the length of the arguments is between min_len and max_len."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_collection(self, request, **resources):\n        if self._meta.queryset is None:\n            return []\n\n        # Filter collection\n        filters = self.get_filters(request, **resources)\n        filters.update(self.get_default_filters(**resources))\n        qs = self._meta.queryset\n        for key, (value, exclude) in filters.items():\n            try:\n                if exclude:\n                    qs = qs.exclude(**{key: value})\n\n                else:\n                    qs = qs.filter(**{key: value})\n            except FieldError, e:\n                logger.warning(e)\n\n        sorting = self.get_sorting(request, **resources)\n        if sorting:\n            qs = qs.order_by(*sorting)\n\n        return qs", "response": "Get filters and return filtered result."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn default filters by a model fields.", "response": "def get_default_filters(self, **resources):\n        \"\"\" Return default filters by a model fields.\n\n        :return dict: name, field\n\n        \"\"\"\n        return dict((k, (v, False)) for k, v in resources.items()\n                    if k in self._meta.fields)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_filters(self, request, **resources):\n        filters = dict()\n\n        if not self._meta.fields:\n            return filters\n\n        for field in request.GET.iterkeys():\n            tokens = field.split(LOOKUP_SEP)\n            field_name = tokens[0]\n\n            if field_name not in self._meta.fields:\n                continue\n\n            exclude = False\n            if tokens[-1] == 'not':\n                exclude = True\n                tokens.pop()\n\n            value = request.GET.getlist(field)\n            if len(tokens) == 1:\n                value = map(self._meta.model._meta.get_field(field_name).to_python, value)\n\n            if len(value) > 1:\n                tokens.append('in')\n            else:\n                value = value.pop()\n\n            filters[LOOKUP_SEP.join(tokens)] = (value, exclude)\n\n        return filters", "response": "Make filters from GET variables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget sorting options. :return list: sorting order", "response": "def get_sorting(self, request, **resources):\n        \"\"\" Get sorting options.\n\n        :return list: sorting order\n\n        \"\"\"\n        sorting = []\n\n        if not request.GET:\n            return sorting\n\n        prefix = self._meta.dyn_prefix + 'sort'\n        return request.GET.getlist(prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paginate(self, request, collection):\n        p = Paginator(request, self, collection)\n        return p.paginator and p or UpdatedList(collection)", "response": "Paginate collection.\n\n        :return object: Collection or paginator"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef type_assert(\n    obj,\n    cls,\n    allow_none=False,\n    cast_from=None,\n    cast_to=None,\n    dynamic=None,\n    choices=None,\n    ctor=None,\n):\n    \"\"\" Assert that @obj is an instance of @cls\n\n        Note that you cannot use this to unmarshal JSON if @cls\n        is a tuple of types, it can only be a single type.\n\n        Will also unmarshal JSON objects to Python objects if @obj\n        is an instance of dict and @cls is not dict\n\n        Args:\n            obj:        object instance, The object to type assert\n            cls:        type,  The class type to assert\n            allow_none: bool, True to allow '@obj is None', otherwise False\n            cast_from:  type-or-tuple-of-types, If @obj is an instance\n                        of this type(s), cast it to @cast_to\n            cast_to:    type, The type to cast @obj to if it's an instance\n                        of @cast_from, or None to cast to @cls.\n                        If you need more than type(x), use a lambda or\n                        factory function.\n            dynamic:    @cls, A dynamic default value if @obj is None,\n                        and @dynamic is not None.  @allow_none should be False\n                        Valid uses:\n                            datetime.datetime.now()\n                            int(time.time())\n                            # Or, to avoid the Python singleton bug when\n                            # using arg=[], for example:\n                            [], {}, set()\n            choices:    iterable-or-None, If not None, @obj must\n                        be in @choices\n            ctor:       None-or-static-method: Use this method as the\n                        constructor instead of __init__\n        Returns:\n            @obj\n        Raises:\n            TypeError: if @obj is not an instance of @cls\n    \"\"\"\n    _check_choices(obj, choices)\n\n    return _check(\n        obj,\n        cls,\n        allow_none,\n        cast_from,\n        cast_to,\n        dynamic=dynamic,\n        ctor=ctor,\n    )", "response": "Checks that the object is an instance of the class cls with the specified type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef type_assert_iter(\n    iterable,\n    cls,\n    cast_from=None,\n    cast_to=None,\n    dynamic=None,\n    objcls=None,\n    choices=None,\n    ctor=None,\n    allow_none=False,\n):\n    \"\"\" Checks that every object in @iterable is an instance of @cls\n\n        Will also unmarshal JSON objects to Python objects if items in\n        @iterable are an instance of dict\n\n        Args:\n            iterable:   Any iterable to check.  Note that it would not\n                        make sense to pass a generator to this function\n            cls:        type, The class type to assert each member\n                        of @iterable is\n            cast_from:  type-or-tuple-of-types, If @obj is an instance\n                        of this type(s), cast it to @cast_to\n            cast_to:    type, The type to cast @obj to if it's an instance\n                        of @cast_from, or None to cast to @cls.\n                        If you need more than type(x), use a lambda or\n                        factory function.\n            dynamic:    @cls, A dynamic default value if @iterable is None,\n                        and @dynamic is not None.\n            objcls:     None-or-type, a type to assert @iterable is,\n                        ie:  list, set, etc...\n            choices:    iterable-or-None, If not None, each object in\n                        @iterable must be in @choices\n            ctor:       None-or-static-method: Use this method as the\n                        constructor instead of __init__\n            allow_none: bool, True to allow @iterable to be None,\n                        otherwise False\n        Returns:\n            @iterable, note that @iterable will be recreated, which\n            may be a performance concern if @iterable has many items\n        Raises:\n            TypeError: if @obj is not an instance of @cls\n    \"\"\"\n    if (\n        allow_none\n        and\n        iterable is None\n    ):\n        return iterable\n\n    _check_dstruct(iterable, objcls)\n\n    if choices is not None:\n        for obj in iterable:\n            _check_choices(obj, choices)\n\n    if (\n        iterable is None\n        and\n        dynamic is not None\n    ):\n        iterable = dynamic\n    t = type(iterable)\n    return t(\n        _check(\n            obj,\n            cls,\n            False,\n            cast_from,\n            cast_to,\n            ctor=ctor,\n        ) for obj in iterable\n    )", "response": "Checks that every object in iterable is an instance of cls\n            and if it is not an instance of cls\n            and if it is not an instance of cls\n            and if it is not an instance of cls\n            returns the object that is in the dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef type_assert_dict(\n    d,\n    kcls=None,\n    vcls=None,\n    allow_none=False,\n    cast_from=None,\n    cast_to=None,\n    dynamic=None,\n    objcls=None,\n    ctor=None,\n):\n    \"\"\" Checks that every key/value in @d is an instance of @kcls: @vcls\n\n        Will also unmarshal JSON objects to Python objects if\n        the value is an instance of dict and @vcls is a class type\n\n        Args:\n            d:          The dict to type assert\n            kcls:       The class to type assert for keys.\n                        NOTE: JSON only allows str keys\n            vcls:       The class to type assert for values\n            allow_none: Allow a None value for the values.\n                        This would not make sense for the keys.\n            cast_from:  type-or-tuple-of-types, If @obj is an instance\n                        of this type(s), cast it to @cast_to\n            cast_to:    type, The type to cast @obj to if it's an instance\n                        of @cast_from, or None to cast to @cls.\n                        If you need more than type(x), use a lambda or\n                        factory function.\n            dynamic:    @cls, A dynamic default value if @d is None,\n                        and @dynamic is not None.\n            objcls:     None-or-type, a type to assert @d is,\n                        ie:  dict, etc...\n                        Note that isinstance considers\n                        collections.OrderedDict to be of type dict\n            ctor:       None-or-static-method: Use this method as the\n                        constructor instead of __init__\n        Returns:\n            @d, note that @d will be recreated, which\n            may be a performance concern if @d has many items\n        Raises:\n            TypeError: if a key is not an instance of @kcls or\n                       a value is not an instance of @vcls\n    \"\"\"\n    _check_dstruct(d, objcls)\n\n    if (\n        d is None\n        and\n        dynamic is not None\n    ):\n        d = dynamic\n    t = type(d)\n    return t(\n        (\n            _check(k, kcls) if kcls else k,\n            _check(\n                v,\n                vcls,\n                allow_none,\n                cast_from,\n                cast_to,\n                ctor=ctor,\n            ) if vcls else v,\n        )\n        for k, v in d.items()\n    )", "response": "Checks that every key value in d is of type kcls and vcls."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef auto_zip_open(filepath, mode):\n    if filepath.endswith('.gz'):\n        outfile = gzip.open(filepath, mode)\n    elif filepath.endswith('.bz2'):\n        outfile = bz2.BZ2File(filepath, mode)\n    else:\n        outfile = open(filepath, mode)\n    return outfile", "response": "Convenience function for opening potentially - compressed files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_full_position(data, header, var_only=False):\n    feature_type = data[header['varType']]\n    # Skip unmatchable, uncovered, or pseudoautosomal-in-X\n    if (feature_type == 'no-ref' or feature_type.startswith('PAR-called-in-X')):\n        return None\n    if var_only and feature_type in ['no-call', 'ref']:\n        return None\n\n    filters = []\n    if feature_type == 'no-call':\n        filters.append('NOCALL')\n    if 'varQuality' in header:\n        if 'VQLOW' in data[header['varQuality']]:\n            filters.append('VQLOW')\n    else:\n        var_filter = data[header['varFilter']]\n        if var_filter and not var_filter == \"PASS\":\n            filters = filters + var_filter.split(';')\n\n    chrom = data[header['chromosome']]\n    start = data[header['begin']]\n    ref_allele = data[header['reference']]\n    alleles = [data[header['alleleSeq']]]\n    dbsnp_data = []\n    dbsnp_data = data[header['xRef']].split(';')\n    assert data[header['ploidy']] in ['1', '2']\n    if feature_type == 'ref' or feature_type == 'no-call':\n        return [{'chrom': chrom,\n                 'start': start,\n                 'dbsnp_data': dbsnp_data,\n                 'ref_seq': ref_allele,\n                 'alleles': alleles,\n                 'allele_count': data[header['ploidy']],\n                 'filters': filters,\n                 'end': data[header['end']]}]\n    else:\n        return [{'chrom': chrom,\n                 'start': start,\n                 'dbsnp_data': dbsnp_data,\n                 'ref_seq': ref_allele,\n                 'alleles': alleles,\n                 'allele_count': data[header['ploidy']],\n                 'filters': filters}]", "response": "Process the full position of the genetic data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncombine data from multiple lines refering to a single allele into a single object.", "response": "def process_allele(allele_data, dbsnp_data, header, reference):\n    \"\"\"Combine data from multiple lines refering to a single allele.\n\n    Returns three items in this order:\n        (string) concatenated variant sequence (ie allele the genome has)\n        (string) concatenated reference sequence\n        (string) start position (1-based)\n    \"\"\"\n    # One-based start to match VCF coordinates\n    start = str(int(allele_data[0][header['begin']]))\n    var_allele = ''\n    ref_allele = ''\n    filters = []\n    for data in allele_data:\n        if 'varQuality' in header:\n            if 'VQLOW' in data[header['varQuality']]:\n                filters.append('VQLOW')\n        else:\n            var_filter = data[header['varFilter']]\n            if var_filter and not var_filter == \"PASS\":\n                filters = filters + var_filter.split(';')\n        if data[header['varType']] == 'no-call':\n            filters = ['NOCALL']\n            ref_allele = ref_allele + data[header['reference']]\n            continue\n        var_allele = var_allele + data[header['alleleSeq']]\n        ref_allele = ref_allele + data[header['reference']]\n        if data[header['xRef']]:\n            for dbsnp_item in data[header['xRef']].split(';'):\n                dbsnp_data.append(dbsnp_item.split(':')[1])\n    # It's theoretically possible to break up a partial no-call allele into\n    # separated gVCF lines, but it's hard. Treat the whole allele as no-call.\n    if 'NOCALL' in filters:\n        filters = ['NOCALL']\n        var_allele = '?'\n    return var_allele, ref_allele, start, filters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_split_pos_lines(data, cgi_input, header):\n    s1_data = [data]\n    s2_data = []\n    next_data = cgi_input.readline().decode('utf-8').rstrip('\\n').split(\"\\t\")\n    while next_data[header['allele']] == \"1\":\n        s1_data.append(next_data)\n        next_data = cgi_input.readline().decode('utf-8').rstrip('\\n').split(\"\\t\")\n    while next_data[header['allele']] == \"2\":\n        s2_data.append(next_data)\n        next_data = cgi_input.readline().decode('utf-8').rstrip('\\n').split(\"\\t\")\n    return s1_data, s2_data, next_data", "response": "Advance across split alleles and return data from each."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess split position report.", "response": "def process_split_position(data, cgi_input, header, reference, var_only=False):\n    \"\"\"Process CGI var where alleles are reported separately.\n\n    Split positions report each allele with one or more lines. To ensure that\n    we've read through all lines, we end up reading one line beyond.\n\n    This function returns data for this position, then handles the remainder\n    line by calling itself or process_full_position (as appropriate).\n\n    Returns an array containing tuples with five items each:\n        (string) chromosome\n        (string) start position (1-based)\n        (array of strings) matching dbSNP entries\n        (string) reference allele sequence\n        (array of strings) the genome's allele sequences\n    \"\"\"\n    assert data[2] == \"1\"\n    chrom = data[header['chromosome']]\n\n    # Get all lines for each allele. Note that this means we'll end up with\n    # data from one line ahead stored in 'next_data'; it will be handled at\n    # the end.\n    s1_data, s2_data, next_data = get_split_pos_lines(\n        data=data, cgi_input=cgi_input, header=header)\n\n    # Process all the lines to get concatenated sequences and other data.\n    dbsnp_data = []\n    a1_seq, ref_seq, start, a1_filters = process_allele(\n        allele_data=s1_data, dbsnp_data=dbsnp_data,\n        header=header, reference=reference)\n    a2_seq, r2_seq, a2_start, a2_filters = process_allele(\n        allele_data=s2_data, dbsnp_data=dbsnp_data,\n        header=header, reference=reference)\n    # clean dbsnp data\n    dbsnp_data = [x for x in dbsnp_data if x]\n    if (a1_seq or ref_seq) and (a2_seq or r2_seq):\n        # Check that reference sequence and positions match.\n        assert ref_seq == r2_seq\n        assert start == a2_start\n        if (a1_seq != '?') or (a2_seq != '?'):\n            yield {'chrom': chrom,\n                   'start': start,\n                   'dbsnp_data': dbsnp_data,\n                   'ref_seq': ref_seq,\n                   'alleles': [a1_seq, a2_seq],\n                   'allele_count': '2',\n                   'filters': list(set(a1_filters + a2_filters))}\n        else:\n            # Handle edge case: because we create full no-calls from partial\n            # no-call alleles, we may end up with a full no-call region.\n            end = str(int(start) + len(ref_seq))\n            yield {'chrom': chrom,\n                    'start': start,\n                    'dbsnp_data': [],\n                    'ref_seq': '=',\n                    'alleles': ['?'],\n                    'allele_count': '2',\n                    'filters': ['NOCALL'],\n                    'end': end}\n\n    # Handle the remaining line. Could recursively call this function if it's\n    # the start of a new split position - very unlikely, though.\n    if next_data[2] == \"all\" or next_data[1] == \"1\":\n        out = process_full_position(\n            data=next_data, header=header, var_only=var_only)\n    else:\n        out = process_split_position(\n            data=next_data, cgi_input=cgi_input, header=header,\n            reference=reference, var_only=var_only)\n    if out:\n        for entry in out:\n            yield entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vcf_line(input_data, reference):\n    vcf_data = VCF_DATA_TEMPLATE.copy()\n    start = int(input_data['start'])\n    dbsnp_data = input_data['dbsnp_data']\n    ref_allele = input_data['ref_seq']\n    genome_alleles = input_data['alleles']\n\n    # Get dbSNP IDs.\n    dbsnp_cleaned = []\n    for dbsnp in dbsnp_data:\n        if dbsnp not in dbsnp_cleaned:\n            dbsnp_cleaned.append(dbsnp)\n    if dbsnp_cleaned:\n        id_field = ';'.join(dbsnp_cleaned)\n        if id_field == '':\n            id_field = '.'\n    else:\n        id_field = '.'\n\n    # Is this a matching reference line? Handle per gVCF spec.\n    if input_data['ref_seq'] == '=':\n        ref_allele = reference[input_data['chrom']][start].upper()\n        vcf_data['CHROM'] = input_data['chrom']\n\n        # Position notes: Complete Genomics uses 0-based start and 1-based end.\n        # Reference seq retrieval is 0-based start, but VCF is 1-based start.\n        vcf_data['POS'] = str(start + 1)\n        vcf_data['ID'] = id_field\n        vcf_data['REF'] = ref_allele\n        vcf_data['ALT'] = '.'\n        vcf_data['FORMAT'] = 'GT'\n        assert input_data['allele_count'] in ['1', '2']\n        if '?' in input_data['alleles']:\n            if 'NOCALL' not in input_data['filters']:\n                input_data['filters'].append('NOCALL')\n            if input_data['allele_count'] == '2':\n                vcf_data['SAMPLE'] = './.'\n            else:\n                vcf_data['SAMPLE'] = '.'\n        elif input_data['allele_count'] == '2':\n            vcf_data['SAMPLE'] = '0/0'\n        else:\n            vcf_data['SAMPLE'] = '0'\n\n        if input_data['filters']:\n            vcf_data['FILTER'] = ';'.join(input_data['filters'])\n        else:\n            vcf_data['FILTER'] = 'PASS'\n        vcf_data['INFO'] = 'END={}'.format(input_data['end'])\n\n        return formatted_vcf_line(vcf_data)\n\n    # VCF doesn't allow zero-length sequences. If we have this situation,\n    # move the start backwards by one position, get that reference base,\n    # and prepend this base to all sequences.\n    if len(ref_allele) == 0 or 0 in [len(v) for v in genome_alleles]:\n        start = start - 1\n        prepend = reference[input_data['chrom']][start].upper()\n        ref_allele = prepend + ref_allele\n        genome_alleles = [prepend + v if v != '?' else v for v in\n                          genome_alleles]\n\n    # Figure out what our alternate alleles are.\n    alt_alleles = []\n    for allele in genome_alleles:\n        if allele not in [ref_allele] + alt_alleles and allele != '?':\n            alt_alleles.append(allele)\n\n    # Combine ref and alt for the full set of alleles, used for indexing.\n    alleles = [ref_allele] + alt_alleles\n\n    # Get the indexed genotype.\n    allele_indexes = [str(alleles.index(x)) for x in genome_alleles if\n                      x != '?']\n    [allele_indexes.append('.') for x in genome_alleles if x == '?']\n    genotype = '/'.join(allele_indexes)\n\n    vcf_data['CHROM'] = input_data['chrom']\n    vcf_data['POS'] = str(start + 1)\n    vcf_data['ID'] = id_field\n    vcf_data['REF'] = ref_allele\n    vcf_data['ALT'] = ','.join(alt_alleles) if alt_alleles else '.'\n    vcf_data['FORMAT'] = 'GT'\n    vcf_data['SAMPLE'] = genotype\n\n    if input_data['filters']:\n        vcf_data['FILTER'] = ';'.join(sorted(input_data['filters']))\n    else:\n        vcf_data['FILTER'] = 'PASS'\n\n    return formatted_vcf_line(vcf_data)", "response": "Convert the var files information into a VCF line."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining appropriate processing to get data, then convert it to VCF There are two types of lines in the var file: - \"full position\": single allele (hemizygous) or all-allele line All alleles at this position are represented in this line. This is handled with \"process_full_position\". - \"split position\": each of two alleles is reported separately. There will be at least two lines, one for each allele (but potentially more). This is handled with \"process_split_position\". Because the number of lines used for separately reported alleles is unknown, process_split_position will always read ahead to the next \"full position\" and return that as well. So the returned line formats are consistent, process_next_position returns an array, even if there's only one line.", "response": "def process_next_position(data, cgi_input, header, reference, var_only):\n    \"\"\"\n    Determine appropriate processing to get data, then convert it to VCF\n\n    There are two types of lines in the var file:\n    - \"full position\": single allele (hemizygous) or all-allele line\n        All alleles at this position are represented in this line.\n        This is handled with \"process_full_position\".\n    - \"split position\": each of two alleles is reported separately. There will\n        be at least two lines, one for each allele (but potentially more).\n        This is handled with \"process_split_position\".\n\n    Because the number of lines used for separately reported alleles is\n    unknown, process_split_position will always read ahead to the next\n    \"full position\" and return that as well.\n\n    So the returned line formats are consistent, process_next_position\n    returns an array, even if there's only one line.\n    \"\"\"\n    if data[2] == \"all\" or data[1] == \"1\":\n        # The output from process_full_position is an array, so it can be\n        # treated in the same manner as process_split_position output.\n        out = process_full_position(data=data, header=header, var_only=var_only)\n    else:\n        assert data[2] == \"1\"\n        # The output from process_split_position is a generator, and may end\n        # up calling itself recursively.\n        out = process_split_position(\n            data=data, cgi_input=cgi_input, header=header, reference=reference, var_only=var_only)\n    if out:\n\n        # ChrM is skipped because Complete Genomics is using a different\n        # reference than UCSC's reference. Their documentation states:\n        #   The version we use, \"build 37,\" consists of the assembled nuclear\n        #   chromosomes from GRCh37 (not unplaced or alternate loci), plus the\n        #   Cambridge Reference Sequence for the mitochondrion (NC_012920.1).\n        #   This assembly (though with an alternate mitochondrial sequence) is\n        #   also known as UCSC hg19.\n        vcf_lines = [vcf_line(input_data=l, reference=reference) for l in out\n                     if l['chrom'] != 'chrM']\n        return [vl for vl in vcf_lines if not\n               (var_only and vl.rstrip().endswith('./.'))]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_to_file(cgi_input, output_file, twobit_ref, twobit_name, var_only=False):\n\n    if isinstance(output_file, str):\n        output_file = auto_zip_open(output_file, 'w')\n\n    conversion = convert(cgi_input=cgi_input, twobit_ref=twobit_ref, twobit_name=twobit_name, var_only=var_only)\n    for line in conversion:\n        output_file.write(line + \"\\n\")\n    output_file.close()", "response": "Convert a CGI var file and output VCF - formatted data to file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_reference_genome_file(refseqdir, build):\n    if not os.path.exists(refseqdir) or not os.path.isdir(refseqdir):\n        raise ValueError(\"No directory at {}\".format(refseqdir))\n    twobit_name = ''\n    if build in ['b37', 'build 37', 'build37', '37', 'hg19']:\n        twobit_name = 'hg19.2bit'\n        build = 'build37'\n    if not twobit_name:\n        raise ValueError('Genome bulid \"{}\" not supported.'.format(build))\n    twobit_path = os.path.join(refseqdir, twobit_name)\n    if not os.path.exists(twobit_path):\n        twobitdownload.save_genome('hg19', destdir=refseqdir)\n    return twobit_path, twobit_name", "response": "Helper function to get reference genome file from target dir and download if needed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_command_line():\n    # Parse options\n    parser = argparse.ArgumentParser(\n        description='Convert Complete Genomics var files to gVCF format.')\n    parser.add_argument(\n        '-d', '--refseqdir', metavar='REFSEQDIR', required=True,\n        dest='refseqdir',\n        help='Directory twobit reference genomes files are stored.')\n    parser.add_argument(\n        '-i', '--input', metavar='INPUTVARFILE',\n        dest='cgivarfile',\n        help='Path to Complete Genomics var file to convert. If omitted, data '\n        ' also be piped in as standard input.')\n    parser.add_argument(\n        '-o', '--output', metavar='OUTPUTVCFFILE',\n        dest='vcfoutfile',\n        help='Path to where to save output VCF file.')\n    parser.add_argument(\n        '-D', '--download', action='store_true', dest='downloadrefseq',\n        help='Download the 2bit file from UCSC to REFSEQDIR, if needed.')\n    parser.add_argument(\n        '-v', '--var-only', action='store_true', dest='varonly',\n        help='Only report variant lines (i.e. VCF, but not gVCF)')\n    args = parser.parse_args()\n\n    # Get local twobit file from its directory. Download and store if needed.\n    twobit_path, twobit_name = get_reference_genome_file(\n        args.refseqdir, build='b37')\n    # Handle input\n    if sys.stdin.isatty():  # false if data is piped in\n        var_input = args.cgivarfile\n    else:\n        var_input = sys.stdin\n    # Handle output\n    if args.vcfoutfile:\n        convert_to_file(var_input,\n                        args.vcfoutfile,\n                        twobit_path,\n                        twobit_name,\n                        args.varonly)\n    else:\n        for line in convert(\n                cgi_input=var_input,\n                twobit_ref=twobit_path,\n                twobit_name=twobit_name,\n                var_only=args.varonly):\n            print(line)", "response": "Run CGI var to gVCF conversion from the command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef job(func_or_queue=None, connection=None, *args, **kwargs):\n    if callable(func_or_queue):\n        func = func_or_queue\n        queue = 'default'\n    else:\n        func = None\n        queue = func_or_queue or 'default'\n\n    if not isinstance(queue, basestring):\n        queue = unicode(queue)\n\n    try:\n        queue = get_queue(queue)\n        if connection is None:\n            connection = queue.connection\n    except KeyError:\n        pass\n\n    decorator = _job(queue, connection=connection, *args, **kwargs)\n    if func:\n        return decorator(func)\n    return decorator", "response": "A function decorator that returns a function that will be called when a job is executed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npublishing to the channel which notifies all connected handlers.", "response": "def publish(self, **kwargs):\n        \"Publishes to the channel which notifies all connected handlers.\"\n        log.debug('Publish to {0}'.format(self))\n        self.signal.send(sender=self.name, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubscribe an external handler to this channel.", "response": "def subscribe(self, receiver):\n        \"Subscribes an external handler to this channel.\"\n        log.debug('{0}.{1} subscribe to {2}'\n                  .format(receiver.__module__, receiver.__name__, self))\n        self.signal.connect(receiver)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_rpc(cls, scheme=None):\n        scheme = scheme or cls._meta.scheme\n\n        if not scheme:\n            return\n\n        if isinstance(scheme, basestring):\n            scheme = importlib.import_module(scheme)\n\n        cls.scheme_name = scheme.__name__\n\n        methods = getattr(scheme, '__all__', None) \\\n            or [m for m in dir(scheme) if not m.startswith('_')]\n\n        for mname in methods:\n            method = getattr(scheme, mname)\n            if hasattr(method, '__call__'):\n                cls.methods[\"{0}.{1}\".format(\n                    cls.scheme_name, method.__name__)] = method", "response": "Configure the rpc methods for the given class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_request(self, request, **resources):\n\n        if request.method == 'OPTIONS':\n            return super(RPCResource, self).handle_request(\n                request, **resources)\n\n        payload = request.data\n\n        try:\n\n            if request.method == 'GET':\n                payload = request.GET.get('payload')\n                try:\n                    payload = js.loads(payload)\n                except TypeError:\n                    raise AssertionError(\"Invalid RPC Call.\")\n\n            if 'method' not in payload:\n                raise AssertionError(\"Invalid RPC Call.\")\n            return self.rpc_call(request, **payload)\n\n        except Exception as e: # noqa (any error)\n            return SerializedHttpResponse(dict(error=dict(message=str(e))), error=True)", "response": "Call RPC method.\n\n        :return object: call's result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall a RPC method. return object : a result", "response": "def rpc_call(self, request, method=None, params=None, **kwargs):\n        \"\"\" Call a RPC method.\n\n        return object: a result\n\n        \"\"\"\n        args = []\n        kwargs = dict()\n        if isinstance(params, dict):\n            kwargs.update(params)\n        else:\n            args = list(as_tuple(params))\n\n        method_key = \"{0}.{1}\".format(self.scheme_name, method)\n        if method_key not in self.methods:\n            raise AssertionError(\"Unknown method: {0}\".format(method))\n        method = self.methods[method_key]\n\n        if hasattr(method, 'request'):\n            args.insert(0, request)\n\n        return method(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls REST API with RPC force.", "response": "def rpc_call(self, request, method=None, **payload):\n        \"\"\" Call REST API with RPC force.\n\n        return object: a result\n\n        \"\"\"\n        if not method or self.separator not in method:\n            raise AssertionError(\"Wrong method name: {0}\".format(method))\n\n        resource_name, method = method.split(self.separator, 1)\n        if resource_name not in self.api.resources:\n            raise AssertionError(\"Unknown method \" + method)\n\n        data = QueryDict('', mutable=True)\n        data.update(payload.get('data', dict()))\n        data['callback'] = payload.get('callback') or request.GET.get(\n            'callback') or request.GET.get('jsonp') or 'callback'\n        for h, v in payload.get('headers', dict()).iteritems():\n            request.META[\"HTTP_%s\" % h.upper().replace('-', '_')] = v\n\n        request.POST = request.PUT = request.GET = data\n        delattr(request, '_request')\n        request.method = method.upper()\n        request.META['CONTENT_TYPE'] = 'application/x-www-form-urlencoded'\n        params = payload.pop('params', dict())\n        response = self.api.call(resource_name, request, **params)\n\n        if not isinstance(response, SerializedHttpResponse):\n            return response\n\n        if response['Content-type'] in self._meta.emitters_dict:\n            return HttpResponse(response.content, status=response.status_code)\n\n        if response.status_code == 200:\n            return response.response\n\n        raise AssertionError(response.response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef browserstacker_command(func):\n    pass_decorator = click.make_pass_decorator(APIWrapper)\n    return cli.command()(pass_decorator(func))", "response": "Shortcut to define command for BrowserStacker.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step_worker(step, pipe, max_entities):\n    state = None\n    while True:\n        message, input = pipe.recv()\n        if message == 'run':\n            state = step.run(input, max_entities)\n        elif message == 'finalise':\n            state = step.finalise(max_entities)\n        elif message == 'next':\n            try:\n                data = state.next()\n                sys.stderr.write('  {}\\n'.format(step.name))\n                sys.stderr.write('  * {}\\n'.format(', '.join(key.name for key in data)))\n                sys.stderr.write('  *  {}\\n'.format(', '.join(str(value) for value in data.values())))\n                pipe.send(('data', {'step': step, 'data': data}))\n            except StopIteration:\n                pipe.send(('stop', {'step': step}))\n                state = None\n        elif message == 'stop':\n            break", "response": "This function is a worker function that processes the input and outputs the next valid messages from the next valid message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        # Note: Don't use \"from appname.models import ModelName\".\n        # Use orm.ModelName to refer to models in this application,\n        # and orm['appname.ModelName'] for models in other applications.\n        other = orm['assessments.AssessmentCategory'].objects.get(id=7)\n        for assessment in orm['assessments.Assessment'].objects.filter(\n                assessment_category__isnull=True):\n            assessment.assessment_category = other\n            assessment.save()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qdc(self):\n        '''Return the qdc tag for the term\n        '''\n        start_tag = ''.join(('<', self.get_term_display().lower(), ' q=\"',\n            self.qualifier, '\">',)) if self.qualifier else ''.join(('<', self.get_term_display().lower(), '>', ))\n        qdc = ''.join((start_tag, saxutils.escape(self.content), '</', self.get_term_display().lower(), '>',))\n        return mark_safe(qdc)", "response": "Return the qdc tag for the term\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the terms representation for our objset interface.", "response": "def objset_data(self):\n        '''Return the terms representation for our objset interface.\n        If there is no qualifier, return just the string content value.\n        If there is a qualifier, return a dict of {q:qualifier, v:content}\n        '''\n        if not self.qualifier:\n            return unicode(self.content)\n        else:\n            return dict(q=unicode(self.qualifier), v=unicode(self.content))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, *args, **kwargs):\n        '''Make sure that the term is valid.\n        If changed, create a QualifiedDublinCoreElementHistory object and save it.\n        '''\n        if not self.term in self.DCELEMENT_CODE_MAP:\n            raise ValueError('Extended Dublin Core Terms such as '+self.DCTERM_CODE_MAP[self.term]+' are not allowed. Please use only Dublin Core Elements')\n        #HOW TO TELL IF OBJECT CHANGED? RETRIEVE FROM DB and COMPARE\n        changed = False\n        if self.pk:# existing object\n            db_self = QualifiedDublinCoreElement.objects.get(pk=self.pk)\n            #compare values, if changed set changed!\n            if self.term != db_self.term:\n                raise ValueError('Can not change DC element')\n            if self.content != db_self.content:\n                changed = True\n            if self.qualifier != db_self.qualifier:\n                changed = True\n            if changed:\n                hist = QualifiedDublinCoreElementHistory()\n                hist.qdce = self\n                hist.object_id = db_self.object_id\n                hist.content_type = db_self.content_type\n                hist.term = db_self.term\n                hist.qualifier = db_self.qualifier\n                hist.content  = db_self.content\n                hist.save()\n        super(QualifiedDublinCoreElement, self).save(*args, **kwargs)\n        obj = self.content_object\n        if hasattr(obj, '_save_dc_xml_file'):\n            obj._save_dc_xml_file()", "response": "Save this QualifiedDublinCoreElement to the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch subtitles from subscene. com", "response": "def search(self, release_name, lang):\n        \"\"\"search subtitles from subscene.com\"\"\"\n        subtitles = []\n        language = babelfish.Language.fromalpha2(lang).name\n        payload = {'q': release_name, 'r': 'true'}\n        url = 'http://subscene.com/subtitles/release'\n        response = requests.get(url, params=payload, headers=self.headers).text\n        soup = BS(response, \"lxml\")\n        positive = soup.find_all(class_='l r positive-icon')\n        neutral = soup.find_all(class_='l r neutral-icon')\n        for node in chain(positive, neutral):\n            suburl = node.parent['href']\n            quality = node['class'][2].split('-')[0]\n            name = node.parent.findChildren()[1].text.strip()\n            if language.lower() in suburl and 'trailer' not in name.lower():\n                subtitle = {}\n                subtitle['release'] = name\n                subtitle['link'] = urljoin(self.base_url, suburl)\n                subtitle['lang'] = lang\n                subtitle['movie'] = name+quality\n                subtitle['date'] = '10/10/2010'\n                subtitles.append(subtitle)\n        return subtitles"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download(self, sub_url):\n        response = requests.get(sub_url, headers=self.headers).text\n        soup = BS(response, 'lxml')\n        downlink = self.base_url+soup.select('.download a')[0]['href']\n        data = requests.get(downlink, headers=self.headers)\n        z = zipfile.ZipFile(cStringIO.StringIO(data.content))\n        srt_files = [f.filename for f in z.filelist\n                     if f.filename.rsplit('.')[-1].lower() in ['srt', 'ass']]\n        z.extract(srt_files[0], '/tmp/')\n        return srt_files[0]", "response": "download and unzip subtitle archive to a temp location"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef marshal_json(\n    obj,\n    types=JSON_TYPES,\n    fields=None,\n):\n    \"\"\" Recursively marshal a Python object to a JSON-compatible dict\n        that can be passed to json.{dump,dumps}, a web client,\n        or a web server, etc...\n\n    Args:\n        obj:    object, It's members can be nested Python\n                objects which will be converted to dictionaries\n        types:  tuple-of-types, The JSON primitive types, typically\n                you would not change this\n        fields: None-list-of-str, Explicitly marshal only these fields\n    Returns:\n        dict\n    \"\"\"\n    return marshal_dict(\n        obj,\n        types,\n        fields=fields,\n    )", "response": "Recursively marshal a Python object to a JSON - compatible dict\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unmarshal_json(\n    obj,\n    cls,\n    allow_extra_keys=True,\n    ctor=None,\n):\n    \"\"\" Unmarshal @obj into @cls\n\n    Args:\n        obj:              dict, A JSON object\n        cls:              type, The class to unmarshal into\n        allow_extra_keys: bool, False to raise an exception when extra\n                          keys are present, True to ignore\n        ctor:             None-or-static-method: Use this method as the\n                          constructor instead of __init__\n    Returns:\n        instance of @cls\n    Raises:\n        ExtraKeysError: If allow_extra_keys == False, and extra keys\n                        are present in @obj and not in @cls.__init__\n        ValueError:     If @cls.__init__ does not contain a self argument\n    \"\"\"\n    return unmarshal_dict(\n        obj,\n        cls,\n        allow_extra_keys,\n        ctor=ctor,\n    )", "response": "Unmarshalls a JSON object into a new object of the specified class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_app(self, app, conf_key=None):\n        conf_key = conf_key or self.conf_key or 'PYMEMCACHE'\n        self.conf_key = conf_key\n        conf = app.config[conf_key]\n        if not isinstance(conf, dict):\n            raise TypeError(\"Flask-PyMemcache conf should be dict\")\n\n        close_on_teardown = conf.pop('close_on_teardown', False)\n\n        if isinstance(conf['server'], list):\n            conf['servers'] = conf.pop('server')\n            client = pymemcache.client.hash.HashClient(**conf)\n        elif isinstance(conf['server'], tuple):\n            client = pymemcache.client.Client(**conf)\n        else:\n            raise TypeError(\"Flask-PyMemcache conf['server'] should be tuple or list of tuples\")\n\n        app.extensions.setdefault('pymemcache', {})\n        app.extensions['pymemcache'][self] = client\n\n        if close_on_teardown:\n            @app.teardown_appcontext\n            def close_connection(exc=None):\n                client.close()", "response": "Initializes the pymemcache extension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef excursion(directory):\n    old_dir = os.getcwd()\n    try:\n        os.chdir(directory)\n        yield\n    finally:\n        os.chdir(old_dir)", "response": "Context - manager that temporarily changes to a new working directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef input(self, _in, out, **kw):\n        # create a temp file\n        tmp = NamedTemporaryFile(suffix='.js', delete=False)\n        tmp.close()  # close it so windows can read it\n\n        # write to a temp file\n        elm_make = self.binary or 'elm-make'\n        change_directory = bool(self.change_directory or False)\n        source = kw['source_path']\n        source_dir = os.path.dirname(source)\n        exec_dir = source_dir if change_directory else os.getcwd()\n        write_args = [elm_make, source, '--output', tmp.name, '--yes']\n        with excursion(exec_dir), TemporaryFile(mode='w') as fake_write_obj:\n            self.subprocess(write_args, fake_write_obj)\n\n        # read the temp file\n        cat_or_type = 'type' if platform == 'win32' else 'cat'\n        read_args = [cat_or_type, tmp.name]\n        self.subprocess(read_args, out)\n        os.remove(tmp.name)", "response": "This method is called by the Elm module when it is being run."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a clone of the current query and all settings.", "response": "def clone(self):\n        ''' Creates a clone of the current query and all settings.  Further\n            updates to the cloned object or the original object will not\n            affect each other\n        '''\n        qclone = Query(self.type, self.session)\n        qclone.__query = deepcopy(self.__query)\n        qclone._sort = deepcopy(self._sort)\n        qclone._fields = deepcopy(self._fields)\n        qclone._hints = deepcopy(self.hints)\n        qclone._limit = deepcopy(self._limit)\n        qclone._skip = deepcopy(self._skip)\n        qclone._raw_output = deepcopy(self._raw_output)\n        return qclone"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef one(self):\n        ''' Execute the query and return one result.  If more than one result\n            is returned, raises a ``BadResultException``\n        '''\n        count = -1\n        for count, result in enumerate(self):\n            if count > 0:\n                raise BadResultException('Too many results for .one()')\n        if count == -1:\n            raise BadResultException('Too few results for .one()')\n        return result", "response": "Execute the query and return one result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter(self, *query_expressions):\n        ''' Apply the given query expressions to this query object\n\n            **Example**: ``s.query(SomeObj).filter(SomeObj.age > 10, SomeObj.blood_type == 'O')``\n\n            :param query_expressions: Instances of :class:`ommongo.query_expression.QueryExpression`\n\n            .. seealso:: :class:`~ommongo.query_expression.QueryExpression` class\n        '''\n        for qe in query_expressions:\n            if isinstance(qe, dict):\n                self._apply_dict(qe)\n            else:\n                self._apply(qe)\n        return self", "response": "Apply the given query expressions to this query object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter_by(self, **filters):\n        ''' Filter for the names in ``filters`` being equal to the associated\n            values.  Cannot be used for sub-objects since keys must be strings'''\n        for name, value in filters.items():\n            self.filter(resolve_name(self.type, name) == value)\n        return self", "response": "Filter for the names in filters being equal to the associated\n            values."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a count on the number of results this query would return.", "response": "def count(self, with_limit_and_skip=False):\n        ''' Execute a count on the number of results this query would return.\n\n            :param with_limit_and_skip: Include ``.limit()`` and ``.skip()`` arguments in the count?\n        '''\n        return self.__get_query_result().cursor.count(with_limit_and_skip=with_limit_and_skip)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a query expression to the query object", "response": "def _apply_dict(self, qe_dict):\n        ''' Apply a query expression, updating the query object '''\n        for k, v in qe_dict.items():\n            k = resolve_name(self.type, k)\n            if not k in self.__query:\n                self.__query[k] = v\n                continue\n            if not isinstance(self.__query[k], dict) or not isinstance(v, dict):\n                raise BadQueryException('Multiple assignments to a field must all be dicts.')\n            self.__query[k].update(**v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a $not expression to the query", "response": "def not_(self, *query_expressions):\n        ''' Add a $not expression to the query, negating the query expressions\n            given.\n\n            **Examples**: ``query.not_(SomeDocClass.age <= 18)`` becomes ``{'age' : { '$not' : { '$gt' : 18 } }}``\n\n            :param query_expressions: Instances of :class:`ommongo.query_expression.QueryExpression`\n            '''\n        for qe in query_expressions:\n            self.filter(qe.not_())\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a $or expression to the query", "response": "def or_(self, first_qe, *qes):\n        ''' Add a $not expression to the query, negating the query expressions\n            given.  The ``| operator`` on query expressions does the same thing\n\n            **Examples**: ``query.or_(SomeDocClass.age == 18, SomeDocClass.age == 17)`` becomes ``{'$or' : [{ 'age' : 18 }, { 'age' : 17 }]}``\n\n            :param query_expressions: Instances of :class:`ommongo.query_expression.QueryExpression`\n        '''\n        res = first_qe\n        for qe in qes:\n            res = (res | qe)\n        self.filter(res)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck to see if the value of qfield is one of values", "response": "def in_(self, qfield, *values):\n        ''' Check to see that the value of ``qfield`` is one of ``values``\n\n            :param qfield: Instances of :class:`ommongo.query_expression.QueryExpression`\n            :param values: Values should be python values which ``qfield`` \\\n                understands\n        '''\n        # TODO: make sure that this field represents a list\n        qfield = resolve_name(self.type, qfield)\n        self.filter(QueryExpression({ qfield : { '$in' : [qfield.wrap_value(value) for value in values]}}))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(self, value, createIndex=None):\n        ''' Full-text support, make sure that text index already exist on collection. Raise IndexNotFound if text index not exist.\n            \n            **Examples**: ``query.search('pecel lele', createIndex=['FullName', 'Username'])``\n        '''\n        if createIndex:\n            self._createIndex = createIndex\n\n        self._search = True\n        self.filter(QueryExpression({'$text' : {'$search': value}}))\n        return self", "response": "Full - text support make sure that text index already exist on collection. Raise IndexNotFound if index not exist. Raise IndexNotFound if createIndex is not None."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query_bypass(self, query, raw_output=True):\n        ''' Bypass query meaning that field check and validation is skipped, then query object directly executed by pymongo.\n        \n            :param raw_output: Skip OmMongo ORM layer (default: True)\n        '''\n        if not isinstance(query, dict):\n            raise BadQueryException('Query must be dict.')\n\n        self.__query = query\n        if raw_output:\n            self._raw_output = True\n            return self.__get_query_result().cursor\n        else:\n            return self", "response": "Query for the set of items in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering the set using a dictionary of filters.", "response": "def filter_like(self, **filters):\n        ''' Filter query using re.compile().\n\n            **Examples**: ``query.filter_like(Name=\"andi\")``\n        '''\n        Query = {}\n        for name, value in filters.items():\n            name = resolve_name(self.type, name)\n            Query[name] = re_compile(value, IGNORECASE)\n        self.filter(QueryExpression(Query))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiltering for dict fields.", "response": "def filter_dict(self, query, **kwargs):\n        ''' Filter for :func:`~ommongo.fields.mapping.DictField`.\n\n            **Examples**: ``query.filter_dict({\"User.Fullname\": \"Oji\"})``\n        '''\n        for name, value in query.items():\n            field = name.split(\".\")[0]\n            try:\n                getattr(self.type, field)\n            except AttributeError:\n                raise FieldNotFoundException(\"Field not found %s\" % (field))\n        self.query_bypass(query, raw_output=False, **kwargs)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_and_modify(self, new=False, remove=False):\n        ''' The mongo \"find and modify\" command.  Behaves like an update expression\n            in that \"execute\" must be called to do the update and return the\n            results.\n\n            :param new: Whether to return the new object or old (default: False)\n            :param remove: Whether to remove the object before returning it\n        '''\n        return FindAndModifyExpression(self, new=new, remove=remove)", "response": "The mongo find and modify command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_safe(self, is_safe, **kwargs):\n        ''' Set this remove to be safe.  It will call getLastError after the\n            remove to make sure it was successful.  ``**kwargs`` are parameters to\n            MongoDB's getLastError command (as in pymongo's remove).\n        '''\n        self.safe = is_safe\n        self.get_last_args.update(**kwargs)\n        return self", "response": "Set this remove to be safe."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef or_(self, first_qe, *qes):\n        ''' Works the same as the query expression method ``or_``\n        '''\n        self.__query_obj.or_(first_qe, *qes)\n        return self", "response": "Or the given set of entries in the current set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef in_(self, qfield, *values):\n        ''' Works the same as the query expression method ``in_``\n        '''\n\n        self.__query_obj.in_(qfield, *values)\n        return self", "response": "Returns a new object with the values in the specified field."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndoes the same as the query expression method nin_.", "response": "def nin(self, qfield, *values):\n        ''' Works the same as the query expression method ``nin_``\n        '''\n        self.__query_obj.nin(qfield, *values)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef action_handler_adapter(handler_cls: type, action_name: str) -> Callable:\n\n    if not hasattr(handler_cls(), action_name):\n        message = \"{0} does'nt have attr:{1}\".format(handler_cls, action_name)\n        raise ValueError(message)\n\n    def wsgiapp(environ, start_response):\n        \"\"\" inner app \"\"\"\n        handler = handler_cls()\n        return getattr(handler, action_name)(environ, start_response)\n    return wsgiapp", "response": "returns a function that wraps class to wsgi application dispathing action"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when valid view is not found", "response": "def on_view_not_found(\n            self, _,\n            start_response: Callable[[str, List[Tuple[str, str]]], None],\n    ) -> Iterable[bytes]:\n        \"\"\" called when valid view is not found \"\"\"\n\n        start_response(\n            \"405 Method Not Allowed\",\n            [('Content-type', 'text/plain')])\n        return [b\"Method Not Allowed\"]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister class as action handler", "response": "def register_actionhandler(self, action_handler: type) -> None:\n        \"\"\" register class as action handler \"\"\"\n        for k in action_handler.__dict__:\n            if k.startswith('_'):\n                continue\n            app = action_handler_adapter(action_handler, k)\n            self.register_app(k, app)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detect_view_name(self, environ: Dict[str, Any]) -> str:\n        urlvars = environ.get('wsgiorg.routing_args', [(), {}])[1]\n        return urlvars.get(self.action_var_name)", "response": "detect view name from routing args"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when action is not found", "response": "def on_view_not_found(\n            self, environ: Dict[str, Any],\n            start_response: Callable[[str, List[Tuple[str, str]]], None],\n    ) -> Iterable[bytes]:\n        \"\"\" called when action is not found \"\"\"\n        start_response(\n            \"404 Not Found\",\n            [('Content-type', 'text/plain')])\n        return [b\"Not Found \", application_uri(environ).encode('utf-8')]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _show_info(app):\r\n    print (\"Server start on port {0} (processes: {1}) ...\".format(app.port, app.processes))\r\n    print (\"Start time: {0}\".format(datetime.now().isoformat(\" \")))\r\n\r\n    print\r\n\r\n    print (\"Parameters:\")\r\n    for k in sorted(dir(__conf__)):\r\n        if k.startswith(\"__\"): continue\r\n        print (\"  {0:<20} : {1}\".format(k, getattr(__conf__, k)))\r\n\r\n    print\r\n\r\n    print (\"Handlers:\")\r\n    handlers = sorted(app.handlers, key = lambda h: h[0])\r\n    pprint(handlers)\r\n\r\n    print", "response": "Prints info about the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef form_adverb_from_adjective(adjective):\n\n    # If the adjective ends in -able, -ible, or -le, replace the -e with -y\n    if adjective.endswith(\"able\") or adjective.endswith(\"ible\") or adjective.endswith(\"le\"):\n        return adjective[:-1] + \"y\"\n\n    # If the adjective ends in -y, replace the y with i and add -ly\n    elif adjective.endswith(\"y\"):\n        return adjective[:-1] + \"ily\"\n\n    # If the adjective ends in -ic, add -ally\n    elif adjective.endswith(\"ic\"):\n        return adjective[:-2] + \"ally\"\n\n    # In most cases, an adverb is formed by adding -ly to an adjective\n    return adjective + \"ly\"", "response": "Form an adverb from the input adjective."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading session from cookies.", "response": "async def load(self, request):\n        \"\"\"Load session from cookies.\"\"\"\n        if SESSION_KEY not in request:\n            session = Session(self.cfg.secret, key=self.cfg.session_cookie,\n                              max_age=self.cfg.max_age, domain=self.cfg.domain)\n            session.load(request.cookies)\n            self.app.logger.debug('Session loaded: %s', session)\n            request[SESSION_KEY] = request.session = session\n        return request[SESSION_KEY]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave session to response cookies.", "response": "async def save(self, request, response):\n        \"\"\"Save session to response cookies.\"\"\"\n        if isinstance(response, Response) and SESSION_KEY in request and not response.prepared:\n            session = request[SESSION_KEY]\n            if session.save(response.set_cookie):\n                self.app.logger.debug('Session saved: %s', session)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def load_user(self, request):\n        if USER_KEY not in request:\n            session = await self.load(request)\n            if 'id' not in session:\n                return None\n\n            request[USER_KEY] = request.user = await self._user_loader(session['id'])\n\n        return request[USER_KEY]", "response": "Load user from request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def check_user(self, request, func=None, location=None, **kwargs):\n        user = await self.load_user(request)\n        func = func or self.cfg.default_user_checker\n        if not func(user):\n            location = location or self.cfg.login_url\n            while callable(location):\n                location = location(request)\n                while asyncio.iscoroutine(location):\n                    location = await location\n            raise HTTPFound(location, **kwargs)\n        return user", "response": "Checks if user is logged and passes the given func."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef user_pass(self, func=None, location=None, **rkwargs):\n        def wrapper(view):\n            view = to_coroutine(view)\n\n            @functools.wraps(view)\n            async def handler(request, *args, **kwargs):\n                await self.check_user(request, func, location, **rkwargs)\n                return await view(request, *args, **kwargs)\n            return handler\n\n        return wrapper", "response": "Decorator ensures that the user pass the given func."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlogging-in an user by ID.", "response": "async def login(self, request, id_):\n        \"\"\"Login an user by ID.\"\"\"\n        session = await self.load(request)\n        session['id'] = id_"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the session to the cookie.", "response": "def save(self, set_cookie, **params):\n        \"\"\"Update cookies if the session has been changed.\"\"\"\n        if set(self.store.items()) ^ set(self.items()):\n            value = dict(self.items())\n            value = json.dumps(value)\n            value = self.encrypt(value)\n            if not isinstance(value, str):\n                value = value.encode(self.encoding)\n            set_cookie(self.key, value, **self.params)\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads session from cookies.", "response": "def load(self, cookies, **kwargs):\n        \"\"\"Load session from cookies.\"\"\"\n        value = cookies.get(self.key, None)\n        if value is None:\n            return False\n\n        value = self.decrypt(value)\n        if not value:\n            return False\n\n        data = json.loads(value)\n        if not isinstance(data, dict):\n            return False\n\n        self.store = data\n        self.update(self.store)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the named step. Also control the multiplicity of input and output entities", "response": "def execute_step(self, step):\n        \"\"\"\n        Execute the named step. Also control the multiplicity of input and output entities\n\n        :param step: step to prepare input for\n        :param kwargs: input to be prepared\n        :return: dict of output by entity type\n        \"\"\"\n        inputs = self.get_inputs(step.ins)\n        outputs = defaultdict(list)\n        for output in step.run(inputs):\n            for k, v in output.items():\n                outputs[k].extend(v)\n        for output in step.finalise():\n            for k, v in output.items():\n                outputs[k].extend(v)\n        self.unresolved_steps.remove(step)\n        return outputs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the command from the given command line arguments.", "response": "def run_from_argv(self, argv):\n        \"\"\"\n        Set up any environment changes requested (e.g., Python path and Django\n        settings), then run this command.\n        \"\"\"\n        if (len(argv) > 2 and not argv[2].startswith('-') and\n                argv[2] in self.subcommands.keys()):\n            subcommand = argv[2]\n            klass = self.get_subcommand(subcommand)\n            parser = OptionParser(\n                prog=argv[0],\n                usage=klass.usage('{0} {1}'.format(argv[1], subcommand)),\n                version=klass.get_version(), option_list=klass.option_list)\n            options, args = parser.parse_args(argv[3:])\n            args = [subcommand] + args\n        else:\n            parser = self.create_parser(argv[0], argv[1])\n            options, args = parser.parse_args(argv[2:])\n\n        handle_default_options(options)\n        self.execute(*args, **options.__dict__)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trac_tickets(self):\n        '''\n        Looks for any of the following trac ticket formats in the description field:\n\n            t12345, t 12345, T12345, T 12345, #12345, # 12345, ticket 12345, TICKET 12345\n        '''\n        # ticket_numbers = re.findall(re.compile(\"([t#]\\s?[0-9]{2,})|([t#][0-9]{2,})\", re.IGNORECASE), self.description)\n        ticket_numbers = re.findall(r\"^[tT#]\\s?[0-9]+\", self.description)\n        ticket_numbers += re.findall(r\"[tT#][0-9]+\", self.description)\n        ticket_numbers += re.findall(re.compile(\"ticket\\s?[0-9]+\", re.IGNORECASE), self.description)\n\n        # Remove Duplicates\n        ticket_numbers = [re.sub('[^0-9]','', t) for t in ticket_numbers]\n        return list(set(ticket_numbers))", "response": "Returns a list of all trac ticket numbers in the description field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of pull request numbers in the description field.", "response": "def pull_requests(self):\n        '''\n        Looks for any of the following pull request formats in the description field:\n\n            pr12345, pr 2345, PR2345, PR 2345\n        '''\n        pr_numbers = re.findall(r\"[pP][rR]\\s?[0-9]+\", self.description)\n        pr_numbers += re.findall(re.compile(\"pull\\s?request\\s?[0-9]+\", re.IGNORECASE), self.description)\n\n        # Remove Duplicates\n        pr_numbers = [re.sub('[^0-9]','', p) for p in pr_numbers]\n        return pr_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_prep_value(self, value):\n        value = super(NullBooleanPGPPublicKeyField, self).get_prep_value(value)\n        if value is None:\n            return None\n        return \"%s\" % bool(value)", "response": "Before encryption need to prepare values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd OpenMP to the environment variable that is set when the current thread is used.", "response": "def add_openmp(self):\n\t\t\"\"\"\n\t\tIndicates that this wrapper should use OpenMP by setting the\n\t\t$OMP_NUM_THREADS environment variable equal to the number of threads\n\t\tspecified in the BioLite configuration file.\n\t\t\"\"\"\n\t\tthreads = min(int(config.get_resource('threads')), self.max_concurrency)\n\t\tself.env['OMP_NUM_THREADS'] = str(threads)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef version(self, flag=None, cmd=None, path=None):\n\n\t\t# Setup the command to run.\n\t\tif not cmd:\n\t\t\tcmd = list(self.cmd)\n\t\tif flag:\n\t\t\tcmd.append(flag)\n\n\t\t# Run the command.\n\t\ttry:\n\t\t\tvstring = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n\t\texcept subprocess.CalledProcessError as e:\n\t\t\tvstring = e.output\n\t\texcept OSError as e:\n\t\t\tutils.failed_executable(cmd[0], e)\n\n\t\tif not path:\n\t\t\tpath = cmd[0]\n\n\t\t# Generate a hash.\n\t\tvhash = diagnostics.log_program_version(self.name, vstring, path)\n\t\tif vhash:\n\t\t\tdiagnostics.prefix.append(self.name)\n\t\t\tdiagnostics.log('version', vhash)\n\t\t\tdiagnostics.prefix.pop()", "response": "Generates and logs a hash to distinguish this particular installation of the program."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef version_jar(self):\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "response": "Special case of version() when the executable is a JAR file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling this function at the end of your class's `__init__` function.", "response": "def run(self, cmd=None):\n\t\t\"\"\"\n\t\tCall this function at the end of your class's `__init__` function.\n\t\t\"\"\"\n\t\tdiagnostics.prefix.append(self.name)\n\n\t\tif not cmd:\n\t\t\tcmd = self.cmd\n\n\t\tstderr = os.path.abspath(self.name + '.log')\n\t\tself.args.append('2>>'+stderr)\n\n\t\tif self.pipe:\n\t\t\tself.args += ('|', self.pipe, '2>>'+stderr)\n\n\t\t# Write to a stdout file if it was set by the derived class.\n\t\t# Otherwise, stdout and stderr will be combined into the log file.\n\t\tif self.stdout:\n\t\t\tstdout = os.path.abspath(self.stdout)\n\t\t\tself.args.append('1>'+stdout)\n\t\t\tdiagnostics.log('stdout', stdout)\n\t\telif self.stdout_append:\n\t\t\tstdout = os.path.abspath(self.stdout_append)\n\t\t\tself.args.append('1>>'+stdout)\n\t\t\tdiagnostics.log('stdout', stdout)\n\t\telse:\n\t\t\tself.args.append('1>>'+stderr)\n\n\t\t# Print timestamp to log\n\t\topen(stderr, 'a').write(\"[biolite] timestamp=%s\\n\" % utils.timestamp())\n\t\tdiagnostics.log('log', stderr)\n\n\t\tcmd = ' '.join(chain(cmd, map(str, self.args)))\n\t\tdiagnostics.log('command', cmd)\n\n\t\tstart = time.time()\n\t\tsave_cwd = os.getcwd()\n\t\ttry:\n\t\t\tos.chdir(self.cwd)\n\t\t\tspawn_pid = os.spawnle(os.P_NOWAIT, self.shell, self.shell, '-c', cmd, self.env)\n\t\t\twait_pid, retcode, rusage = os.wait4(spawn_pid, 0)\n\t\t\tif wait_pid != spawn_pid:\n\t\t\t\tutils.die(\"could not wait for process %d: got %d\" % (spawn_pid, wait_pid))\n\t\t\tos.chdir(save_cwd)\n\t\texcept OSError as e:\n\t\t\tutils.info(e)\n\t\t\tutils.die(\"could not run wrapper for command:\\n%s\" % cmd)\n\t\t\t#utils.failed_executable(exe, e)\n\n\t\telapsed = time.time() - start\n\t\tretcode = os.WEXITSTATUS(retcode)\n\n\t\tif (self.return_ok is not None) and (self.return_ok != retcode):\n\t\t\t# Give some context to the non-zero return.\n\t\t\tif os.path.isfile(stderr):\n\t\t\t\tsubprocess.call(['tail', '-3', stderr])\n\t\t\tutils.die(\"non-zero return (%d) from command:\\n%s\" % (retcode, cmd))\n\n\t\t# Log profile.\n\t\tdiagnostics.prefix.append('profile')\n\t\tdiagnostics.log('name', self.name)\n\t\tdiagnostics.log('return', retcode)\n\t\tdiagnostics.log('walltime', elapsed)\n\t\tdiagnostics.log('usertime', rusage.ru_utime)\n\t\tdiagnostics.log('systime', rusage.ru_stime)\n\t\tif config.uname == 'Darwin':\n\t\t\tdiagnostics.log('maxrss', rusage.ru_maxrss / 1024)\n\t\telse:\n\t\t\tdiagnostics.log('maxrss', rusage.ru_maxrss)\n\t\tdiagnostics.prefix.pop()\n\n\t\t# Reverse any output patterns, since they will be matched against\n\t\t# program output from the last line backward.\n\t\tif self.output_patterns:\n\t\t\tself.output_patterns.reverse()\n\n\t\tdiagnostics.log_program_output(stderr, self.output_patterns)\n\t\tdiagnostics.prefix.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build(template_directories):\n    template = load_template(template_directories[0])\n    for directory in template_directories[1:]:\n        template.update(load_template(directory))\n    return template", "response": "Build a template from the source template directories."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef batch_stream(buff, stream, size=DEFAULT_BATCH_SIZE):\n    buff.truncate(0)\n    for _ in xrange(size):\n        if hasattr(stream, 'readline'):\n            line = stream.readline()\n        else:\n            try:\n                line = next(stream)\n            except StopIteration:\n                line = ''\n\n        # No more lines, return the tmp\n        if line == '':\n            buff.seek(0)\n            return True\n        buff.write(line)\n    buff.seek(0)\n    return False", "response": "Writes a batch of size lines to buff. Returns a boolean of whether the stream has been exhausted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npack the notification to binary form and return it as string.", "response": "def to_binary_string(self):\n        \"\"\"Pack the notification to binary form and return it as string.\"\"\"\n        if self.priority not in self.PRIORITIES:\n            raise NotificationInvalidPriorityError()\n\n        try:\n            token = binascii.unhexlify(self.token)\n        except TypeError as error:\n            raise NotificationTokenUnhexlifyError(error)\n\n        try:\n            payload = json.dumps(self.payload)\n        except TypeError:\n            raise NotificationPayloadNotSerializableError()\n\n        fmt = \">BIBH{0}sBH{1}sBHIBHIBHB\".format(len(token), len(payload))\n\n        expire = (0 if self.expire == self.EXPIRE_IMMEDIATELY else\n                  datetime_to_timestamp(self.expire))\n\n        # |COMMAND|FRAME-LEN|{token}|{payload}|{id:4}|{expire:4}|{priority:1}\n        # 5 items, each 3 bytes prefix, then each item length\n        length = 3*5 + len(token) + len(payload) + 4 + 4 + 1\n        message = struct.pack(fmt, self.COMMAND, length,\n                              self.TOKEN, len(token), token,\n                              self.PAYLOAD, len(payload), payload,\n                              self.NOTIFICATION_ID, 4, self.iden,\n                              self.EXPIRE, 4, expire,\n                              self.PRIORITY, 1, self.priority)\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunpacking the notification from binary string.", "response": "def from_binary_string(self, notification):\n        \"\"\"Unpack the notification from binary string.\"\"\"\n        command = struct.unpack('>B', notification[0])[0]\n\n        if command != self.COMMAND:\n            raise NotificationInvalidCommandError()\n\n        length = struct.unpack('>I', notification[1:5])[0]\n        notification = notification[5:]\n        offset = 0\n\n        def next_item(offset):\n            iden, length = struct.unpack('>BH', notification[offset:offset+3])\n            offset += 3\n            payload = notification[offset:offset+length]\n            offset += length\n\n            if iden == self.PAYLOAD:\n                payload = struct.unpack('>{0}s'.format(length), payload)[0]\n                self.payload = json.loads(payload)\n            elif iden == self.TOKEN:\n                payload = struct.unpack('>{0}s'.format(length), payload)[0]\n                self.token = binascii.hexlify(payload)\n            elif iden == self.PRIORITY:\n                self.priority = struct.unpack('>B', payload)[0]\n            elif iden == self.NOTIFICATION_ID:\n                self.iden = struct.unpack('>I', payload)[0]\n            elif iden == self.EXPIRE:\n                payload = struct.unpack('>I', payload)[0]\n                self.expire = (self.EXPIRE_IMMEDIATELY if payload == 0 else\n                               datetime.fromtimestamp(payload))\n            else:\n                raise NotificationInvalidIdError()\n\n            return offset\n\n        while offset < length:\n            offset = next_item(offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a restclients. models. uwnetid. Subscription objects on the given uwnetid", "response": "def get_kerberos_subs(netid):\n    \"\"\"\n    Return a restclients.models.uwnetid.Subscription objects\n    on the given uwnetid\n    \"\"\"\n    subs = get_netid_subscriptions(netid, Subscription.SUBS_CODE_KERBEROS)\n    if subs is not None:\n        for subscription in subs:\n            if subscription.subscription_code == Subscription.SUBS_CODE_KERBEROS:\n                return subscription\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens a SOAP WSDL and return the content as a file - like object.", "response": "def open(self, request):\n        \"\"\"\n        Open a SOAP WSDL\n\n        :param request: :class:`suds.transport.Request <suds.transport.Request>` object\n        :return: WSDL Content as a file-like object\n        :rtype: io.BytesIO\n        \"\"\"\n        url = request.url\n        logger.debug('Opening WSDL: %s ' % url)\n        statsd.incr('soap.open')\n        with statsd.timer('soap.open'):\n            if url.startswith('file://'):\n                content = urllib.request.urlopen(url)\n            else:\n                resp = requests.get(url,\n                    proxies=self.proxies(url),\n                    timeout=self.open_timeout)\n                resp.raise_for_status()\n                content = io.BytesIO(resp.content)\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(self, request):\n        url = request.url\n        msg = request.message\n        headers = request.headers\n        logger.debug('Sending SOAP request: %s' % url)\n        statsd.incr('soap.send')\n        with statsd.timer('soap.send'):\n            resp = requests.post(url,\n                proxies=self.proxies(url),\n                timeout=self.send_timeout,\n                data=msg,\n                headers=headers)\n        resp.raise_for_status()\n        reply = Reply(requests.codes.OK, resp.headers, resp.content)\n        return reply", "response": "Send a SOAP request to the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the transport proxy configuration dictionary.", "response": "def proxies(self, url):\n        \"\"\"\n        Get the transport proxy configuration\n\n        :param url: string\n        :return: Proxy configuration dictionary\n        :rtype: Dictionary\n        \"\"\"\n        netloc = urllib.parse.urlparse(url).netloc\n        proxies = {}\n        if settings.PROXIES and settings.PROXIES.get(netloc):\n            proxies[\"http\"] = settings.PROXIES[netloc]\n            proxies[\"https\"] = settings.PROXIES[netloc]\n        elif settings.PROXY_URL:\n            proxies[\"http\"] = settings.PROXY_URL\n            proxies[\"https\"] = settings.PROXY_URL\n        return proxies"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_flags(element):\n    visible = True if element.get('visible') else False\n    user = element.get('user')\n    timestamp = element.get('timestamp')\n    if timestamp:\n        timestamp = utils.Timestamp.parse_isoformat(timestamp)\n    tags = {}\n    try:\n        for tag in element['tag']:\n            key = tag.get('k')\n            value = tag.get('v')\n            tags[key] = value\n    except AttributeError:\n        pass\n\n    return visible, user, timestamp, tags", "response": "Parse OSM XML element for generic data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates element independent flags output.", "response": "def _get_flags(osm_obj):\n    \"\"\"Create element independent flags output.\n\n    Args:\n        osm_obj (Node): Object with OSM-style metadata\n\n    Returns:\n        list: Human readable flags output\n    \"\"\"\n    flags = []\n    if osm_obj.visible:\n        flags.append('visible')\n    if osm_obj.user:\n        flags.append('user: %s' % osm_obj.user)\n    if osm_obj.timestamp:\n        flags.append('timestamp: %s' % osm_obj.timestamp.isoformat())\n    if osm_obj.tags:\n        flags.append(', '.join('%s: %s' % (k, v)\n                               for k, v in sorted(osm_obj.tags.items())))\n    return flags"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_area_url(location, distance):\n    locations = [location.destination(i, distance) for i in range(0, 360, 90)]\n    latitudes = list(map(attrgetter('latitude'), locations))\n    longitudes = list(map(attrgetter('longitude'), locations))\n\n    bounds = (min(longitudes), min(latitudes), max(longitudes), max(latitudes))\n\n    return ('http://api.openstreetmap.org/api/0.5/map?bbox='\n            + ','.join(map(str, bounds)))", "response": "Generate URL for downloading OSM data within a region."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an OSM node element subtree.", "response": "def toosm(self):\n        \"\"\"Generate a OSM node element subtree.\n\n        Returns:\n            etree.Element: OSM node element\n        \"\"\"\n        node = create_elem('node', {'id': str(self.ident),\n                                    'lat': str(self.latitude),\n                                    'lon': str(self.longitude)})\n        node.set('visible', 'true' if self.visible else 'false')\n        if self.user:\n            node.set('user', self.user)\n        if self.timestamp:\n            node.set('timestamp', self.timestamp.isoformat())\n        if self.tags:\n            for key, value in sorted(self.tags.items()):\n                node.append(create_elem('tag', {'k': key, 'v': value}))\n\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses an OSM node XML element.", "response": "def parse_elem(element):\n        \"\"\"Parse a OSM node XML element.\n\n        Args:\n            element (etree.Element): XML Element to parse\n\n        Returns:\n            Node: Object representing parsed element\n        \"\"\"\n        ident = int(element.get('id'))\n        latitude = element.get('lat')\n        longitude = element.get('lon')\n\n        flags = _parse_flags(element)\n\n        return Node(ident, latitude, longitude, *flags)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_locations(self, osm_file):\n        self._osm_file = osm_file\n        data = utils.prepare_xml_read(osm_file, objectify=True)\n\n        # This would be a lot simpler if OSM exports defined a namespace\n        if not data.tag == 'osm':\n            raise ValueError(\"Root element %r is not `osm'\" % data.tag)\n        self.version = data.get('version')\n        if not self.version:\n            raise ValueError('No specified OSM version')\n        elif not self.version == '0.5':\n            raise ValueError('Unsupported OSM version %r' % data)\n\n        self.generator = data.get('generator')\n\n        for elem in data.getchildren():\n            if elem.tag == 'node':\n                self.append(Node.parse_elem(elem))\n            elif elem.tag == 'way':\n                self.append(Way.parse_elem(elem))", "response": "Imports the locations of the OSM data files and returns a list of Osm objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_osm_file(self):\n        osm = create_elem('osm', {'generator': self.generator,\n                                  'version': self.version})\n        osm.extend(obj.toosm() for obj in self)\n\n        return etree.ElementTree(osm)", "response": "Generate OpenStreetMap element tree from Osm."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadvances resolve_url which can includes GET - parameters and anchor.", "response": "def resolve_url_ext(to, params_=None, anchor_=None, args=None, kwargs=None):\n    \"\"\"\n    Advanced resolve_url which can includes GET-parameters and anchor.\n    \"\"\"\n    url = resolve_url(to, *(args or ()), **(kwargs or {}))\n    if params_:\n        url += '?' + urllib.urlencode(encode_url_query_params(params_))\n    if anchor_:\n        url += '#' + anchor_\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef redirect_ext(to, params_=None, anchor_=None, permanent_=False, args=None, kwargs=None):\n    if permanent_:\n        redirect_class = HttpResponsePermanentRedirect\n    else:\n        redirect_class = HttpResponseRedirect\n    return redirect_class(resolve_url_ext(to, params_, anchor_, args, kwargs))", "response": "Advanced redirect which can include GET - parameters and anchor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_url_query_params(url, params):\n    url_parts = list(urlparse.urlparse(url))\n    query = dict(urlparse.parse_qsl(url_parts[4]))\n    query.update(params)\n    url_parts[4] = urllib.urlencode(encode_url_query_params(query))\n    return urlparse.urlunparse(url_parts)", "response": "Change GET - parameters of a URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_response_headers(h):\n    def headers_wrapper(fun):\n        def wrapped_function(*args, **kwargs):\n            response = fun(*args, **kwargs)\n            for k, v in h.iteritems():\n                response[k] = v\n            return response\n        return wrapped_function\n    return headers_wrapper", "response": "Decorator to add HTTP - headers to response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listen(self, *, host, port, override=False, forever=False, **kwargs):\n        if override:\n            argv = dict(enumerate(sys.argv))\n            host = argv.get(1, host)\n            port = int(argv.get(2, port))\n        server = self.loop.create_server(\n            self.__handler.fork, host, port, **kwargs)\n        server = self.loop.run_until_complete(server)\n        self.log('info',\n            'Start listening host=\"{host}\" port=\"{port}\"'.\n            format(host=host, port=port))\n        if forever:\n            try:\n                self.loop.run_forever()\n            except KeyboardInterrupt:\n                pass\n        return server", "response": "Listen on TCP or IP socket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match(self, request, *, root=None, path=None, methods=None):\n        return self.__router.match(\n            request, root=root, path=path, methods=methods)", "response": "Return match or None for the request / constraints pair."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs an url for the given parameters.", "response": "def url(self, name, *, base=None, query=None, **match):\n        \"\"\"Construct an url for the given parameters.\n\n        .. seealso:: Proxy:\n            :meth:`.Router.url`\n        \"\"\"\n        return self.__router.url(name, base=base, query=query, **match)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs something. .. seealso:: Proxy: :class:`.Logger`.level", "response": "def log(self, level, *args, **kwargs):\n        \"\"\"Log something.\n\n        .. seealso:: Proxy:\n            :class:`.Logger`.level\n        \"\"\"\n        target = getattr(self.__logger, level)\n        target(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        from django.contrib.auth.models import Group\n\n        projects = orm['samples.Project'].objects.all()\n\n        # Create group for each project\n        for project in projects:\n            name = PROJECT_GROUP_TEMPLATE.format(project.name)\n            Group.objects.get_or_create(name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite your backwards methods here.", "response": "def backwards(self, orm):\n        \"Write your backwards methods here.\"\n        from django.contrib.auth.models import Group\n\n        projects = orm['samples.Project'].objects.all()\n        names = [PROJECT_GROUP_TEMPLATE.format(p.name) for p in projects]\n\n        # Remove groups named after these teams\n        Group.objects.filter(name__in=names).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute_api_request(self):\n        if not self.auth.check_auth():\n            raise Exception('Authentification needed or API not available with your type of connection')\n        if self.auth.is_authentified():\n            id_cookie = {BboxConstant.COOKIE_BBOX_ID: self.auth.get_cookie_id()}\n            if self.parameters is None:\n                resp = self.call_method(self.api_url.get_url(), cookies=id_cookie)\n            else:\n                resp = self.call_method(self.api_url.get_url(),\n                                        data=self.parameters, cookies=id_cookie)\n        else:\n            if self.parameters is None:\n                resp = self.call_method(self.api_url.get_url())\n            else:\n                resp = self.call_method(self.api_url.get_url(),\n                                        data=self.parameters)\n        if resp.status_code != 200:\n            # This means something went wrong.\n            raise Exception('Error {} with request {}'.format(\n                resp.status_code, self.api_url.get_url()))\n\n        return resp", "response": "Execute the API request and return json data as a dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess json data into a list of GradLeave objects.", "response": "def _process_json(data):\n    \"\"\"\n    return a list of GradLeave objects.\n    \"\"\"\n    requests = []\n    for item in data:\n        leave = GradLeave()\n        leave.reason = item.get('leaveReason')\n        leave.submit_date = datetime_from_string(item.get('submitDate'))\n        if item.get('status') is not None and len(item.get('status')) > 0:\n            leave.status = item.get('status').lower()\n\n        for quarter in item.get('quarters'):\n            term = GradTerm()\n            term.quarter = quarter.get('quarter').lower()\n            term.year = quarter.get('year')\n            leave.terms.append(term)\n        requests.append(leave)\n    return requests"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating URL prefix for API calls based on type of repo.", "response": "def create_basic_url(self):\n        \"\"\" Create URL prefix for API calls based on type of repo.\n\n        Repo may be forked and may be in namespace. That makes total 4\n        different types of URL.\n\n        :return:\n        \"\"\"\n        if self.username is None:\n            if self.namespace is None:\n                request_url = \"{}/api/0/{}/\".format(\n                    self.instance, self.repo)\n            else:\n                request_url = \"{}/api/0/{}/{}/\".format(\n                    self.instance, self.namespace, self.repo)\n        else:\n            if self.namespace is None:\n                request_url = \"{}/api/0/fork/{}/{}/\".format(\n                    self.instance, self.username, self.repo)\n            else:\n                request_url = \"{}/api/0/fork/{}/{}/{}/\".format(\n                    self.instance, self.username, self.namespace, self.repo)\n        return request_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets Pagure API version.", "response": "def api_version(self):\n        \"\"\"\n        Get Pagure API version.\n        :return:\n        \"\"\"\n        request_url = \"{}/api/0/version\".format(self.instance)\n        return_value = self._call_api(request_url)\n        return return_value['version']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_users(self, pattern=None):\n        request_url = \"{}/api/0/users\".format(self.instance)\n        params = None\n        if pattern:\n            params = {'pattern': pattern}\n        return_value = self._call_api(request_url, params=params)\n        return return_value['users']", "response": "List all users registered on this Pagure instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_tags(self, pattern=None):\n        request_url = \"{}tags\".format(self.create_basic_url())\n\n        params = None\n        if pattern:\n            params = {'pattern': pattern}\n\n        return_value = self._call_api(request_url, params=params)\n        return return_value['tags']", "response": "List all tags made on this project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef error_codes(self):\n        request_url = \"{}/api/0/error_codes\".format(self.instance)\n        return_value = self._call_api(request_url)\n        return return_value", "response": "Get a dictionary of all error codes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_requests(self, status=None, assignee=None, author=None):\n        request_url = \"{}pull-requests\".format(self.create_basic_url())\n\n        payload = {}\n        if status is not None:\n            payload['status'] = status\n        if assignee is not None:\n            payload['assignee'] = assignee\n        if author is not None:\n            payload['author'] = author\n\n        return_value = self._call_api(request_url, params=payload)\n        return return_value['requests']", "response": "Get all pull requests of a project."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget information about a single pull request.", "response": "def request_info(self, request_id):\n        \"\"\"\n        Get information of a single pull request.\n        :param request_id: the id of the request\n        :return:\n        \"\"\"\n        request_url = \"{}pull-request/{}\".format(self.create_basic_url(),\n                                                 request_id)\n\n        return_value = self._call_api(request_url)\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_request(self, request_id):\n        request_url = \"{}pull-request/{}/merge\".format(self.create_basic_url(),\n                                                       request_id)\n\n        return_value = self._call_api(request_url, method='POST')\n\n        LOG.debug(return_value)", "response": "Merge a pull request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a comment on the request. :param request_id: the id of the request :param body: the comment body :param commit: which commit to comment on :param filename: which file to comment on :param row: which line of code to comment on :return:", "response": "def comment_request(self, request_id, body, commit=None,\n                        filename=None, row=None):\n        \"\"\"\n        Create a comment on the request.\n        :param request_id: the id of the request\n        :param body: the comment body\n        :param commit: which commit to comment on\n        :param filename: which file to comment on\n        :param row: which line of code to comment on\n        :return:\n        \"\"\"\n        request_url = (\"{}pull-request/{}/comment\"\n                       .format(self.create_basic_url(), request_id))\n\n        payload = {'comment': body}\n        if commit is not None:\n            payload['commit'] = commit\n        if filename is not None:\n            payload['filename'] = filename\n        if row is not None:\n            payload['row'] = row\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds or edit a flag of the request. :param request_id: the id of the request :param username: the name of the application to be displayed :param percent: the percentage of completion to be displayed :param comment: a short message summarizing the flag :param url: a relevant URL :param uid: a unique id used to identify the flag. If not provided, pagure will generate one :param commit: which commit to flag on :return:", "response": "def flag_request(self, request_id, username, percent, comment, url,\n                     uid=None, commit=None):\n        \"\"\"\n        Add or edit a flag of the request.\n        :param request_id: the id of the request\n        :param username: the name of the application to be displayed\n        :param percent: the percentage of completion to be displayed\n        :param comment: a short message summarizing the flag\n        :param url: a relevant URL\n        :param uid: a unique id used to identify the flag.\n            If not provided, pagure will generate one\n        :param commit: which commit to flag on\n        :return:\n        \"\"\"\n        request_url = \"{}pull-request/{}/flag\".format(self.create_basic_url(),\n                                                      request_id)\n\n        payload = {'username': username, 'percent': percent,\n                   'comment': comment, 'url': url}\n        if commit is not None:\n            payload['commit'] = commit\n        if uid is not None:\n            payload['uid'] = uid\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new issue.", "response": "def create_issue(self, title, content, priority=None,\n                     milestone=None, tags=None, assignee=None,\n                     private=None):\n        \"\"\"\n        Create a new issue.\n        :param title: the title of the issue\n        :param content: the description of the issue\n        :param priority: the priority of the ticket\n        :param milestone: the milestone of the ticket\n        :param tags: comma sperated list of tag for the ticket\n        :param assignee: the assignee of the ticket\n        :param private: whether create this issue as private\n        :return:\n        \"\"\"\n        request_url = \"{}new_issue\".format(self.create_basic_url())\n\n        payload = {'title': title, 'issue_content': content}\n\n        if priority is not None:\n            payload['priority'] = priority\n        if milestone is not None:\n            payload['milestone'] = milestone\n        if tags is not None:\n            payload['tag'] = tags\n        if assignee is not None:\n            payload['assignee'] = assignee\n        if private is not None:\n            payload['private'] = private\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_issues(\n            self, status=None, tags=None, assignee=None, author=None,\n            milestones=None, priority=None, no_stones=None, since=None,\n            order=None\n    ):\n        \"\"\"\n        List all issues of a project.\n        :param status: filters the status of the issues\n        :param tags: filers the tags of the issues\n        :param assignee: filters the assignee of the issues\n        :param author: filters the author of the issues\n        :param milestones: filters the milestones of the issues (list of\n            strings)\n        :param priority: filters the priority of the issues\n        :param no_stones: If True returns only the issues having no milestone,\n            if False returns only the issues having a milestone\n        :param since: Filters the issues updated after this date.\n            The date can either be provided as an unix date or in the format\n            Y-M-D\n        :param order: Set the ordering of the issues. This can be asc or desc.\n            Default: desc\n        :return:\n        \"\"\"\n        request_url = \"{}issues\".format(self.create_basic_url())\n\n        payload = {}\n        if status is not None:\n            payload['status'] = status\n        if tags is not None:\n            payload['tags'] = tags\n        if assignee is not None:\n            payload['assignee'] = assignee\n        if author is not None:\n            payload['author'] = author\n        if milestones is not None:\n            payload['milestones'] = milestones\n        if priority is not None:\n            payload['priority'] = priority\n        if no_stones is not None:\n            payload['no_stones'] = no_stones\n        if since is not None:\n            payload['since'] = since\n        if order is not None:\n            payload['order'] = order\n\n        return_value = self._call_api(request_url, params=payload)\n\n        return return_value['issues']", "response": "Returns a list of all issues in a project."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef issue_info(self, issue_id):\n        request_url = \"{}issue/{}\".format(self.create_basic_url(), issue_id)\n\n        return_value = self._call_api(request_url)\n\n        return return_value", "response": "Get info about a single issue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a specific comment of an issue.", "response": "def get_list_comment(self, issue_id, comment_id):\n        \"\"\"\n        Get a specific comment of an issue.\n        :param issue_id: the id of the issue\n        :param comment_id: the id of the comment\n        :return:\n        \"\"\"\n        request_url = \"{}issue/{}/comment/{}\".format(self.create_basic_url(),\n                                                     issue_id, comment_id)\n\n        return_value = self._call_api(request_url)\n\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_issue_status(self, issue_id, new_status, close_status=None):\n        request_url = \"{}issue/{}/status\".format(self.create_basic_url(),\n                                                 issue_id)\n\n        payload = {'status': new_status}\n        if close_status is not None:\n            payload['close_status'] = close_status\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)", "response": "Change the status of an issue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_issue_milestone(self, issue_id, milestone):\n        request_url = \"{}issue/{}/milestone\".format(self.create_basic_url(),\n                                                    issue_id)\n\n        payload = {} if milestone is None else {'milestone': milestone}\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)", "response": "Change the issue s current issue s current issue s current milestone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncomment to an issue.", "response": "def comment_issue(self, issue_id, body):\n        \"\"\"\n        Comment to an issue.\n        :param issue_id: the id of the comment\n        :param body: the comment body\n        :return:\n        \"\"\"\n        request_url = \"{}issue/{}/comment\".format(self.create_basic_url(),\n                                                  issue_id)\n\n        payload = {'comment': body}\n\n        return_value = self._call_api(request_url,\n                                      method='POST', data=payload)\n\n        LOG.debug(return_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists all git tags made to the project.", "response": "def project_tags(self):\n        \"\"\"\n        List all git tags made to the project.\n        :return:\n        \"\"\"\n        request_url = \"{}git/tags\".format(self.create_basic_url())\n\n        return_value = self._call_api(request_url)\n\n        return return_value['tags']"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets info about a specific user.", "response": "def user_info(self, username):\n        \"\"\"\n        Get info of a specific user.\n        :param username: the username of the user to get info about\n        :return:\n        \"\"\"\n        request_url = \"{}/api/0/user/{}\".format(self.instance, username)\n\n        return_value = self._call_api(request_url)\n\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef user_activity_stats(self, username, format=None):\n        request_url = \"{}/api/0/user/{}/activity/stats\".format(self.instance, username)\n\n        payload = {}\n        if username is not None:\n            payload['username'] = username\n        if format is not None:\n            payload['format'] = format\n\n        return_value = self._call_api(request_url, params=payload)\n\n        return return_value", "response": "This method returns the activity stats for a specific user over the last year of the Pagure instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve activity information about a specific user on the specified date. Params: username (string): filters the username of the user whose activity you are interested in. date (string): filters by the date of interest, best provided in ISO format: YYYY-MM-DD grouped (boolean): filters whether or not to group the commits Returns: list: A list of activities done by a given user on some particular date for all the projects for given Pagure instance.", "response": "def user_activity_stats_by_date(self, username, date, grouped=None):\n        \"\"\"\n         Retrieve activity information about a specific user on the specified date.\n\n        Params:\n            username (string): filters the username of the user whose activity you are interested in.\n            date (string): filters by the date of interest, best provided in ISO format: YYYY-MM-DD\n            grouped (boolean): filters whether or not to group the commits\n\n        Returns:\n            list: A list of activities done by a given user on some particular\n                  date for all the projects for given Pagure instance.\n        \"\"\"\n        request_url = \"{}/api/0/user/{}/activity/{}\".format(self.instance, username, date)\n\n        payload = {}\n        if username is not None:\n            payload['username'] = username\n        if date is not None:\n            payload['date'] = date\n        if grouped is not None:\n            payload['grouped'] = grouped\n\n        return_value = self._call_api(request_url, params=payload)\n\n        return return_value['activities']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting pull-requests filed by user. Params: username (string): filters the username of the user whose activity you are interested in. page (integer): the page requested. Defaults to 1. status (string): filter the status of pull requests. Default: Open, can be Closed, Merged, All. Returns: list: A list of Pull-Requests filed by a given user for all the projects for given Pagure instance.", "response": "def list_pull_requests(self, username, page, status=None):\n        \"\"\"\n        List pull-requests filed by user.\n\n        Params:\n            username (string): filters the username of the user whose activity you are interested in.\n            page (integer): the page requested. Defaults to 1.\n            status (string): filter the status of pull requests. Default: Open,\n                             can be Closed, Merged, All.\n\n        Returns:\n            list: A list of Pull-Requests filed by a given user for all the\n                  projects for given Pagure instance.\n        \"\"\"\n        request_url = \"{}/api/0/user/{}/requests/filed\".format(self.instance, username)\n\n        payload = {}\n        if username is not None:\n            payload['username'] = username\n        if page is not None:\n            payload['page'] = page\n        if status is not None:\n            payload['status'] = status\n\n        return_value = self._call_api(request_url, params=payload)\n\n        return return_value['requests']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_project(self, name, description, namespace=None, url=None,\n                    avatar_email=None, create_readme=False, private=False):\n        \"\"\"\n        Create a new project on the pagure instance\n        :param name: the name of the new project.\n        :param description: A short description of the new project.\n        :param namespace: The namespace of the project to fork\n        :param url: A url providing more information about the project.\n        :param avatar_email: An email address for the avatar of the project.\n        :param create_readme: Boolean to specify if there should be a\n            readme added to the project on creation.\n        :param private: boolean to specify if the project is private\n        :return:\n        \"\"\"\n        request_url = \"{}/api/0/new\".format(self.instance)\n\n        payload = {'name': name, 'description': description}\n        if namespace is not None:\n            payload['namespace'] = namespace\n        if url is not None:\n            payload['url'] = url\n        if avatar_email is not None:\n            payload['avatar_email'] = avatar_email\n        payload['create_readme'] = create_readme\n        payload['private'] = private\n\n        return_value = self._call_api(request_url, data=payload,\n                                      method='POST')\n\n        return return_value['message']", "response": "Create a new project on the pagure instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all branches associated with a repository.", "response": "def project_branches(self):\n        \"\"\"\n        List all branches associated with a repository.\n        :return:\n        \"\"\"\n        request_url = \"{}git/branches\".format(self.create_basic_url())\n\n        return_value = self._call_api(request_url)\n\n        return return_value['branches']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        orm['avocado.DataField'].objects.filter(app_name='samples', model_name='cohort',\n            field_name__in=['investigator', 'notes']).delete()", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef determine_pool_size(job_vector):\n\n    available_threads = cpu_count()\n    total_jobs = len(job_vector)\n    threads_to_pass = total_jobs\n    if total_jobs >= available_threads:\n        threads_to_pass = available_threads\n    if threads_to_pass > 90:\n        threads_to_pass = 90\n    print(\"There are {} threads available.\\nThere are {} jobs:\\nMaking a pool with {} threads\".format(\n        available_threads, total_jobs, threads_to_pass), file = sys.stderr)\n    return threads_to_pass", "response": "This function determines how large a pool to make based on the system resources available and how many jobs there are available."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets this code from here: http://stackoverflow.com/questions/6116978/python-replace-multiple-strings This method takes a set of strings, A, and removes all whole elements of set A from string B. Input: text string to strip based on instance attribute self.censor Output: a stripped (censored) text string", "response": "def str_ripper(self, text):\n        \"\"\"Got this code from here:\n        http://stackoverflow.com/questions/6116978/python-replace-multiple-strings\n\n        This method takes a set of strings, A, and removes all whole\n        elements of set A from string B.\n\n        Input: text string to strip based on instance attribute self.censor\n        Output: a stripped (censored) text string\n        \"\"\"\n        return self.pattern.sub(lambda m: self.rep[re.escape(m.group(0))], text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending data to socket.", "response": "def send(self, data):\r\n        \"\"\"Send data to socket.\"\"\"\r\n        # send message\r\n        _LOGGER.debug(\"send: \" + data)\r\n        self.socket.send(data.encode('ascii'))\r\n        # sleep needed to prevent flooding the GC100 with sends\r\n        sleep(.01)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef receive(self):\r\n        while True:\r\n            try:\r\n                # read data from the buffer\r\n                data = self.socket.recv(self._socket_recv)\r\n            except socket.timeout as e:\r\n                _LOGGER.debug(e)\r\n                sleep(1)\r\n                return\r\n            except socket.error as e:\r\n                # Something else happened\r\n                _LOGGER.error(e)\r\n                return\r\n\r\n            else:\r\n                if len(data) == 0:\r\n                    # no more data being transmitted\r\n                    _LOGGER.info('orderly shutdown on server end')\r\n                    return\r\n\r\n                # remove trailing carriage return, then split\r\n                # on carriage return (for multi-line replies)\r\n                results = data.decode('ascii').rstrip('\\r').split('\\r')\r\n                if len(results) > 1:\r\n                    _LOGGER.debug(\"multi-line reply\")\r\n                for result in results:\r\n                    _LOGGER.debug(\"receive thread: \" + result)\r\n                    self.queue.put(result)", "response": "Receive data from socket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef quit(self):\r\n        # stop all threads and close the socket\r\n        self.receive_thread.stopped = True\r\n        # self.receive_thread._Thread__stop()\r\n\r\n        self.message_thread.stopped = True\r\n        # self.message_thread._Thread__stop()\r\n\r\n        # self.ping_thread.stopped = True\r\n        # self.ping_thread._Thread__stop()\r\n\r\n        self.receive_thread.join()\r\n        _LOGGER.info('receive_thread exited')\r\n        self.message_thread.join()\r\n        _LOGGER.info('message_thread exited')\r\n\r\n        self.socket.close()", "response": "Close threads and socket."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_config(self, path, environments, fill_with_defaults=False):\n        yaml.add_implicit_resolver(\"!environ\", self.__environ_pattern)\n        yaml.add_constructor('!environ', self.__get_from_environment)\n        yaml.add_implicit_resolver(\"!vault\", self.__vault_pattern)\n        yaml.add_constructor('!vault', self.__get_from_vault)\n\n        if not path.endswith('/'):\n            path += '/'\n\n        if type(environments) != list:\n            environments = [environments]\n\n        config = {}\n        try:\n            for env in environments:\n                with open(path + env + '.yaml', 'r') as configFile:\n                    env_config = yaml.load(configFile.read()) or {}\n                config.update(env_config)\n            if fill_with_defaults:\n                if 'defaults' in config:\n                    defaults = config['defaults']\n                    for target in defaults:\n                        for index, item in enumerate(config[target]):\n                            tmp = defaults[target].copy()\n                            tmp.update(config[target][index])\n                            config[target][index] = tmp\n            return config\n        except exceptions.VaultError as error:\n            raise ConfigLoaderError(\"Could not read vault secrets [\" + error.__class__.__name__ + \"]\")\n        except yaml.YAMLError as error:\n            raise ConfigLoaderError(\"Configuration files malformed [\" + error.__class__.__name__ + \"]\")\n        except json.decoder.JSONDecodeError as error:\n            raise ConfigLoaderError(\"Vault response was not json [\" + error.__class__.__name__ + \"]\")\n        except Exception as error:\n            raise ConfigLoaderError(\"WTF? [\" + error.__class__.__name__ + \"]\")", "response": "Loads the config file at given path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a callback for the given events and times.", "response": "def on(self, events, callback, times=None):\n        \"\"\"\n        Registers the given *callback* with the given *events* (string or list\n        of strings) that will get called whenever the given *event* is triggered\n        (using :meth:`self.trigger`).\n\n        If *times* is given the *callback* will only be fired that many times\n        before it is automatically removed from :attr:`self._on_off_events`.\n        \"\"\"\n        # Make sure our _on_off_events dict is present (if first invokation)\n        if not hasattr(self, '_on_off_events'):\n            self._on_off_events = {}\n        if isinstance(events, (str, unicode)):\n            events = [events]\n        callback_obj = {\n            'callback': callback,\n            'times': times,\n            'calls': 0\n        }\n        for event in events:\n            if event not in self._on_off_events:\n                self._on_off_events.update({event: [callback_obj.copy()]})\n            else:\n                self._on_off_events[event].append(callback_obj.copy())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef off(self, events, callback):\n        if isinstance(events, (str, unicode)):\n            events = [events]\n        for event in events:\n            for callback_obj in self._on_off_events[event]:\n                if callback_obj['callback'] == callback:\n                    try:\n                        del self._on_off_events[event]\n                    except KeyError:\n                        pass", "response": "Removes the given callback from the given events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef trigger(self, events, *args, **kwargs):\n        # Make sure our _on_off_events dict is present (if first invokation)\n        if not hasattr(self, '_on_off_events'):\n            self._on_off_events = {}\n        if not hasattr(self, 'exc_info'):\n            self.exc_info = None\n        logging.debug(\"OnOffMixin triggering event(s): %s\" % events)\n        if isinstance(events, (str, unicode)):\n            events = [events]\n        for event in events:\n            if event in self._on_off_events:\n                for callback_obj in self._on_off_events[event]:\n                    callback_obj['callback'](*args, **kwargs)\n                    callback_obj['calls'] += 1\n                    if callback_obj['calls'] == callback_obj['times']:\n                        self.off(event, callback_obj['callback'])", "response": "Trigger the given events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_sample_for_autocreated_cohorts(instance, created, **kwargs):\n    \"Manages adding/removing samples from autocreated cohorts.\"\n\n    # World\n    lookup = {'batch': None, 'project': None, 'autocreated': True,\n              'name': 'World'}\n    try:\n        world_cohort = Cohort.objects.get(**lookup)\n    except Cohort.DoesNotExist:\n        if getattr(settings, 'VARIFY_AUTO_CREATE_COHORT', True):\n            world_cohort = Cohort(**lookup)\n            world_cohort.save()\n        else:\n            log.info(\"World cohort was not found and was not created because \"\n                     \"VARIFY_AUTO_CREATE_COHORT setting is False.\")\n            return\n\n    project = instance.project\n\n    # Project\n    lookup = {'batch': None, 'project': project, 'autocreated': True}\n    try:\n        project_cohort = Cohort.objects.get(**lookup)\n    except Cohort.DoesNotExist:\n        project_cohort = Cohort(name=unicode(project), **lookup)\n        project_cohort.save()\n\n    if instance.published:\n        world_cohort.add(instance, added=False)\n        project_cohort.add(instance, added=False)\n    else:\n        world_cohort.remove(instance, delete=True)\n        project_cohort.remove(instance, delete=True)", "response": "Manages adding / removing samples from autocreated cohorts."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes and auto - created cohort named after the instance.", "response": "def auto_delete_cohort(instance, **kwargs):\n    \"Deletes and auto-created cohort named after the instance.\"\n    cohorts = Cohort.objects.filter(autocreated=True)\n\n    if isinstance(instance, Project):\n        cohorts = cohorts.filter(project=instance)\n    elif isinstance(instance, Batch):\n        cohorts = cohorts.filter(batch=instance)\n    else:\n        return\n\n    count = cohorts.count()\n    cohorts.delete()\n    log.info('Delete {0} autocreated cohorts for {1}'.format(count, instance))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_batch_count(instance, **kwargs):\n    batch = instance.batch\n    count = batch.samples.filter(published=True).count()\n\n    if count != batch.count:\n        batch.count = count\n        if AUTO_PUBLISH_BATCH:\n            batch.published = bool(count)\n        batch.save()", "response": "Sample post - save handler to update the sample s batch count."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ratings(data):\n    episodes = data['episodes']\n    ratings = {}\n    for season in episodes:\n        ratings[season] = collapse(episodes[season])\n    return co.OrderedDict(sorted(ratings.items()))", "response": "Returns a dictionary of the ratings of all the seasons"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef luhn(base, num_only=False, allow_lower_case=False):\n    if num_only:\n        alphabet = _ALPHABET[:10]\n    else:\n        alphabet = _ALPHABET\n    if allow_lower_case:\n        base = base.upper()\n    try:\n        pre_calc = (_PRE_CALC[alphabet.index(c)] for c in reversed(base))\n        cum = 0\n        parity = 1\n        for elem in pre_calc:\n            val, parity = elem[parity]\n            cum += val\n    except ValueError:\n        pass    # fall through\n    else:\n        return 10 - cum % 10\n    # unallowed character detected\n    if num_only:\n        msg = 'The string given must only contain digits.'\n    elif allow_lower_case:\n        msg = 'The string given must only contain digits and ascii letters.'\n    else:\n        msg = 'The string given must only contain digits and upper case ' \\\n              'ascii letters.'\n    raise ValueError(msg)", "response": "Calculates the Luhn check digit for the given string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a DB engine return a DB session bound to that engine", "response": "def get_db_session(engine):\n    \"Given a DB engine return a DB session bound to that engine\"\n\n    db = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))\n    db.configure(bind=engine)\n    db.autoflush = True\n\n    return db"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collapseuser(path):\n    home = os.path.join(os.path.expanduser(\"~\"), \"\")\n    if path.startswith(home):\n        path = os.path.join(\"~\", path[len(home):])\n    return path", "response": "Collapse user home directory into a single user path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn either a weakref. proxy for the object or itself", "response": "def weakref_proxy(obj):\n    \"\"\"returns either a weakref.proxy for the object, or if object is already a proxy,\n    returns itself.\"\"\"\n    if type(obj) in weakref.ProxyTypes:\n        return obj\n    else:\n        return weakref.proxy(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the dictionary representation of the object.", "response": "def _get_dict(obj):\n    \"\"\" Hack to work around the lack of __dict__ when __slots__ is used\n\n    \"\"\"\n    has_slots = hasattr(obj, '__slots__')\n    if has_slots:\n        d = {k:getattr(obj, k) for k in obj.__slots__}\n    else:\n        d = obj.__dict__\n    return has_slots, d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unmarshal_dict(\n    obj,\n    cls,\n    allow_extra_keys=True,\n    ctor=None,\n):\n    \"\"\" Unmarshal @obj into @cls\n\n    Args:\n        obj:              dict, The dict to unmarshal into @cls\n        cls:              type, The class to unmarshal into\n        allow_extra_keys: bool, False to raise an exception when extra\n                          keys are present, True to ignore\n    Returns:\n        instance of @cls\n    Raises:\n        ExtraKeysError: If allow_extra_keys == False, and extra keys\n                        are present in @obj and not in @cls.__init__\n        ValueError:     If @cls.__init__ does not contain a self argument\n    \"\"\"\n    if not ctor:\n        ctor = cls\n    args = init_args(ctor)\n    obj = key_swap(obj, cls, False)\n    kwargs = {k: v for k, v in obj.items() if k in args}\n\n    # If either is set to False, do not allow extra keys\n    # to be present in obj but not in cls.__init__\n    allow_extra_keys = (\n        getattr(cls, '_unmarshal_allow_extra_keys', True)\n        and\n        allow_extra_keys\n    )\n\n    if not allow_extra_keys and len(obj) > len(kwargs):\n        diff = {k: v for k, v in obj.items() if k not in args}\n        raise ExtraKeysError(cls, diff)\n\n    try:\n        return ctor(**kwargs)\n    except ExtraKeysError as ex:\n        raise ex\n    except Exception as ex:\n        raise InitArgsError(\n            cls,\n            args,\n            kwargs,\n            ex,\n        )", "response": "Unmarshals a dictionary into a new object of the same class."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a byte buffer to the underlying output file.", "response": "def write(self, byte):\n        \"\"\"\n        Writes a byte buffer to the underlying output file.\n        Raise exception when file is already closed.\n        \"\"\"\n        if self.is_closed_flag:\n            raise Exception(\"Unable to write - already closed!\")\n        self.written += len(byte)\n        self.file.write(byte)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_bool(self, flag):\n        if flag:\n            self.write(b\"\\x01\")\n        else:\n            self.write(b\"\\x00\")", "response": "Writes a boolean to the underlying output file as a 1 - byte value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_short(self, number):\n        buf = pack(self.byte_order + \"h\", number)\n        self.write(buf)", "response": "Writes a 2 - byte value to the underlying output file as a 2 - byte value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_int(self, number):\n        buf = pack(self.byte_order + \"i\", number)\n        self.write(buf)", "response": "Writes an integer to the underlying output file as a 4 - byte value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a long integer to the underlying output file as a 8 - byte value.", "response": "def write_long(self, number):\n        \"\"\" Writes a long integer to the underlying output file as a 8-byte value. \"\"\"\n        buf = pack(self.byte_order + \"q\", number)\n        self.write(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a string to the underlying output file as a buffer of chars with UTF - 8 encoding.", "response": "def write_string(self, string):\n        \"\"\" Writes a string to the underlying output file as a buffer of chars with UTF-8 encoding. \"\"\"\n        buf = bytes(string, 'UTF-8')\n        length = len(buf)\n        self.write_int(length)\n        self.write(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_float(self, number):\n        buf = pack(self.byte_order + \"f\", number)\n        self.write(buf)", "response": "Writes a float to the underlying output file as a 4 - byte value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a double to the underlying output file as a 8 - byte value.", "response": "def write_double(self, number):\n        \"\"\" Writes a double to the underlying output file as a 8-byte value. \"\"\"\n        buf = pack(self.byte_order + \"d\", number)\n        self.write(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ivorn_present(session, ivorn):\n    return bool(\n        session.query(Voevent.id).filter(Voevent.ivorn == ivorn).count())", "response": "Predicate returns whether the IVORN is present in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npredicates returns whether there is an entry in the database with matching ivorn_prefix.", "response": "def ivorn_prefix_present(session, ivorn_prefix):\n    \"\"\"\n    Predicate, returns whether there is an entry in the database with matching\n    IVORN prefix.\n    \"\"\"\n    n_matches = session.query(Voevent.ivorn).filter(\n            Voevent.ivorn.like('{}%'.format(ivorn_prefix))).count()\n    return bool(n_matches)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef safe_insert_voevent(session, etree):\n    new_row = Voevent.from_etree(etree)\n    if not ivorn_present(session, new_row.ivorn):\n        session.add(new_row)\n    else:\n        old_xml = session.query(Voevent.xml).filter(\n            Voevent.ivorn == new_row.ivorn).scalar()\n        if old_xml != new_row.xml:\n            raise ValueError('Tried to load a VOEvent with duplicate IVORN,'\n                             'but XML contents differ - not clear what to do.')\n        else:\n            logger.warning('Skipping insert for packet with duplicate IVORN, '\n                        'XML matches OK.')", "response": "Insert a VOEvent into the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd(binary, subcommand, *args, **kwargs):\n    ret = [binary, subcommand]\n    for key, value in kwargs.items():\n        key = '--' + key.replace('_', '-')\n        ret.extend(_keyword_arguments(value, key))\n    ret.extend(args)\n    return ret", "response": "Construct a command line for a modern UNIX command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _FormatTypeCheck(type_):\n  if isinstance(type_, tuple):\n    items = [_FormatTypeCheck(t) for t in type_]\n    return \"(%s)\" % \", \".join(items)\n  elif hasattr(type_, \"__name__\"):\n    return type_.__name__\n  else:\n    return repr(type_)", "response": "Pretty format of type check."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ValidateValue(value, type_check):\n  if inspect.isclass(type_check):\n    return isinstance(value, type_check)\n  if isinstance(type_check, tuple):\n    return _ValidateTuple(value, type_check)\n  elif callable(type_check):\n    return type_check(value)\n  else:\n    raise TypeError(\"Invalid type check '%s'\" % repr(type_check))", "response": "Validate a single value with type_check."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a string version of a type_check into a python instance.", "response": "def _ParseTypeCheckString(type_check_string, stack_location, self_name):\n  \"\"\"Convert string version of a type_check into a python instance.\n\n  Type checks can be either defined directly in python code or in a string.\n  The syntax is exactly the same since we use eval to parse the string.\n\n  :param int stack_location: For eval to get the right globals() scope,\n    we require a stack_location to tell us the index in inspect.stack to\n    where the string was defined.\n  :param str self_name: Optional name of the class itself, which can be used\n    to type check for an instance of a class you are currently defining, and\n    thus would not be available in the globals namespace. If none, it will\n    be quessed from the stack.\n  \"\"\"\n  target_frame = inspect.stack()[stack_location][0]\n  self_name = self_name or inspect.stack()[stack_location][3]\n  eval_globals = target_frame.f_globals\n  eval_locals = {self_name: Typename[self_name]}\n\n  try:\n    return eval(type_check_string, eval_globals, eval_locals)\n  except:\n    print \"Exception while parsing\", type_check_string\n    raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the functions docstring into a dictionary of type checks.", "response": "def _ParseDocstring(function):\n  \"\"\"Parses the functions docstring into a dictionary of type checks.\"\"\"\n  if not function.__doc__:\n    return {}\n\n  type_check_dict = {}\n  for match in param_regexp.finditer(function.__doc__):\n    param_str = match.group(1).strip()\n    param_splitted = param_str.split(\" \")\n    if len(param_splitted) >= 2:\n      type_str = \" \".join(param_splitted[:-1])\n      name = param_splitted[-1]\n      type_check_dict[name] = type_str\n\n  for match in returns_regexp.finditer(function.__doc__):\n    type_check_dict[\"returns\"] = match.group(1)\n\n  for match in type_regexp.finditer(function.__doc__):\n    name = match.group(1)\n    type_str = match.group(2)\n    type_check_dict[name] = type_str\n  for match in rtype_regexp.finditer(function.__doc__):\n    type_check_dict[\"returns\"] = match.group(1)\n  return type_check_dict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmerge positional and keyword arguments into a single dict.", "response": "def _CollectArguments(function, args, kwargs):\n  \"\"\"Merges positional and keyword arguments into a single dict.\"\"\"\n  all_args = dict(kwargs)\n  arg_names = inspect.getargspec(function)[0]\n  for position, arg in enumerate(args):\n    if position < len(arg_names):\n      all_args[arg_names[position]] = arg\n  return all_args"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _CollectTypeChecks(function, parent_type_check_dict, stack_location,\n                      self_name):\n  \"\"\"Collect all type checks for this function.\"\"\"\n  type_check_dict = dict(parent_type_check_dict)\n  type_check_dict.update(_ParseDocstring(function))\n\n  # Convert any potential string based checks into python instances.\n  for key, value in type_check_dict.items():\n    if isinstance(value, str):\n      type_check_dict[key] = _ParseTypeCheckString(value, stack_location + 1,\n                                                  self_name)\n\n  return type_check_dict", "response": "Collect all type checks for this function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate dictionary of arguments and return list of errors messages.", "response": "def _ValidateArguments(arg_dict, type_check_dict):\n  \"\"\"Validate dictionary of arguments and return list of errors messages.\"\"\"\n  messages = []\n  for arg_name, arg_value in arg_dict.items():\n    if arg_name in type_check_dict:\n      type_check = type_check_dict[arg_name]\n      res = _ValidateValue(arg_value, type_check)\n      if not res:\n        message = (\"Invalid value '%s' for argument %s. Expected %s\" %\n                   (arg_value, arg_name, _FormatTypeCheck(type_check)))\n        messages.append(message)\n  return messages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ValidateReturnValue(return_value, type_check_dict):\n  return_check = type_check_dict.get(\"returns\", None)\n  if not return_check:\n    return []\n\n  messages = []\n  if not _ValidateValue(return_value, return_check):\n    message = (\"Invalid return value '%s'. Expected %s\" %\n               (return_value, _FormatTypeCheck(return_check)))\n    messages.append(message)\n  return messages", "response": "Validate return value and return list of errors messages."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _TypecheckFunction(function, parent_type_check_dict, stack_location,\n                      self_name):\n  \"\"\"Decorator function to collect and execute type checks.\"\"\"\n  type_check_dict = _CollectTypeChecks(function, parent_type_check_dict,\n                                      stack_location + 1, self_name)\n  if not type_check_dict:\n    return function\n\n  def TypecheckWrapper(*args, **kwargs):\n    arg_dict = _CollectArguments(function, args, kwargs)\n    errors = _ValidateArguments(arg_dict, type_check_dict)\n    if errors:\n      raise TypeError(\"\\n\".join(errors))\n\n    return_value = function(*args, **kwargs)\n\n    errors = _ValidateReturnValue(return_value, type_check_dict)\n    if errors:\n      raise TypeError(\"\\n\".join(errors))\n    return return_value\n\n  TypecheckWrapper.__doc__ = function.__doc__\n  TypecheckWrapper.__name__ = function.__name__\n  TypecheckWrapper.type_check_dict = type_check_dict\n  TypecheckWrapper.wrapped_function = function\n\n  return TypecheckWrapper", "response": "Decorator function to collect and execute type checks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _TypecheckDecorator(subject=None, **kwargs):\n  if subject is None:\n    return _TypecheckDecoratorFactory(kwargs)\n  elif inspect.isfunction(subject) or inspect.ismethod(subject):\n    return _TypecheckFunction(subject, {}, 2, None)\n  else:\n    raise TypeError()", "response": "Dispatches type checks based on what the subject is."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndecorate a member with typecheck. Inherit checks from parent member.", "response": "def Decorate(cls, class_name, member, parent_member):\n    \"\"\"Decorates a member with @typecheck. Inherit checks from parent member.\"\"\"\n    if isinstance(member, property):\n      fget = cls.DecorateMethod(class_name, member.fget, parent_member)\n      fset = None\n      if member.fset:\n        fset = cls.DecorateMethod(class_name, member.fset, parent_member)\n      fdel = None\n      if member.fdel:\n        fdel = cls.DecorateMethod(class_name, member.fdel, parent_member)\n      return property(fget, fset, fdel, member.__doc__)\n    else:\n      return cls.DecorateMethod(class_name, member, parent_member)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind parent class that uses this metaclass.", "response": "def FindTypecheckParent(cls, parents):\n    \"\"\"Find parent class that uses this metaclass.\"\"\"\n    for parent in parents:\n      if hasattr(parent, \"__metaclass__\") and parent.__metaclass__ == cls:\n        return parent\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds a member by name from parent class.", "response": "def FindParentMember(cls, typecheck_parent, name):\n    \"\"\"Returns member by name from parent class if it exists.\"\"\"\n    if typecheck_parent and hasattr(typecheck_parent, name):\n      return getattr(typecheck_parent, name)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef submit_results(job_id, errors, log_file, results_uri, results_data=None):\n    results_path = urlparse(results_uri).path\n    job = CrawlerJob.get_by_job(job_id)\n    job.logs = log_file\n    job.results = results_uri\n\n    if errors:\n        job.status = JobStatus.ERROR\n        job.save()\n        db.session.commit()\n        raise CrawlerJobError(str(errors))\n\n    if results_data is None:\n        results_data = _extract_results_data(results_path)\n\n    for crawl_result in results_data:\n        crawl_result = copy.deepcopy(crawl_result)\n        try:\n            _check_crawl_result_format(crawl_result)\n        except KeyError as e:\n            crawl_result = _crawl_result_from_exception(e, crawl_result)\n\n        record = crawl_result.pop('record')\n        crawl_errors = crawl_result['errors']\n\n        current_app.logger.debug('Parsing record: {}'.format(record))\n        engine = WorkflowEngine.with_name(job.workflow)\n        engine.save()\n        obj = workflow_object_class.create(data=record)\n        obj.id_workflow = str(engine.uuid)\n        if crawl_errors:\n            obj.status = ObjectStatus.ERROR\n            obj.extra_data['crawl_errors'] = crawl_result\n\n        else:\n            extra_data = {\n                'crawler_job_id': job_id,\n                'crawler_results_path': results_path,\n            }\n            record_extra = record.pop('extra_data', {})\n            if record_extra:\n                extra_data['record_extra'] = record_extra\n\n            obj.extra_data['source_data'] = {\n                'data': copy.deepcopy(record),\n                'extra_data': copy.deepcopy(extra_data),\n            }\n            obj.extra_data.update(extra_data)\n\n        obj.data_type = current_app.config['CRAWLER_DATA_TYPE']\n        obj.save()\n        db.session.commit()\n\n        crawler_object = CrawlerWorkflowObject(\n            job_id=job_id, object_id=obj.id\n        )\n        db.session.add(crawler_object)\n        queue = current_app.config['CRAWLER_CELERY_QUEUE']\n\n        if not crawl_errors:\n            start.apply_async(\n                kwargs={\n                    'workflow_name': job.workflow,\n                    'object_id': obj.id,\n                },\n                queue=queue,\n            )\n\n    current_app.logger.info('Parsed {} records.'.format(len(results_data)))\n\n    job.status = JobStatus.FINISHED\n    job.save()\n    db.session.commit()", "response": "This function takes the submission of the results of a crawl job and spawns the appropriate workflow according to whichever workflow is defined."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef schedule_crawl(spider, workflow, **kwargs):\n    from inspire_crawler.utils import get_crawler_instance\n\n    crawler = get_crawler_instance()\n    crawler_settings = current_app.config.get('CRAWLER_SETTINGS')\n    crawler_settings.update(kwargs.get(\"crawler_settings\", {}))\n\n    crawler_arguments = kwargs\n    crawler_arguments.update(\n        current_app.config.get('CRAWLER_SPIDER_ARGUMENTS', {}).get(spider, {})\n    )\n    job_id = crawler.schedule(\n        project=current_app.config.get('CRAWLER_PROJECT'),\n        spider=spider,\n        settings=crawler_settings,\n        **crawler_arguments\n    )\n    if job_id:\n        crawler_job = CrawlerJob.create(\n            job_id=job_id,\n            spider=spider,\n            workflow=workflow,\n        )\n        db.session.commit()\n        current_app.logger.info(\n            \"Scheduled scrapyd job with id: {0}\".format(job_id)\n        )\n        current_app.logger.info(\n            \"Created crawler job with id:{0}\".format(crawler_job.id)\n        )\n    else:\n        raise CrawlerScheduleError(\n            \"Could not schedule '{0}' spider for project '{1}'\".format(\n                spider, current_app.config.get('CRAWLER_PROJECT')\n            )\n        )\n\n    return str(crawler_job.job_id)", "response": "Schedule a crawl using the given workflow."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        db_table = orm['samples.CohortVariant']._meta.db_table\n        db.execute('TRUNCATE TABLE \"{0}\"'.format(db_table))\n        db.execute('ALTER SEQUENCE \"{0}_id_seq\" RESTART 1'.format(db_table))\n        cohorts = list(orm['samples.Cohort'].objects.all())\n\n        for c in cohorts:\n            # Calculate frequencies for all variants associated with all\n            # samples in this cohort\n            db.execute('''\n                INSERT INTO cohort_variant (cohort_id, variant_id, af) (\n                    SELECT c.id, r.variant_id, COUNT(r.id) / c.\"count\"::float\n                    FROM sample_result r\n                        INNER JOIN sample s ON (r.sample_id = s.id)\n                        INNER JOIN cohort_sample cs ON (cs.sample_id = s.id)\n                        INNER JOIN cohort c ON (cs.cohort_id = c.id)\n                    WHERE c.id = %s\n                    GROUP BY c.id, r.variant_id, c.\"count\"\n                )\n            ''', [c.pk])", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_link(self, path, method, callback, view):\n        fields = self.get_path_fields(path, method, callback, view)\n        fields += self.get_serializer_fields(path, method, callback, view)\n        fields += self.get_pagination_fields(path, method, callback, view)\n        fields += self.get_filter_fields(path, method, callback, view)\n\n        if fields and any([field.location in ('form', 'body')\n                           for field in fields]):\n            encoding = self.get_encoding(path, method, callback, view)\n        else:\n            encoding = None\n\n        description = self.get_description(path, method, callback, view)\n\n        link = coreapi.Link(\n            url=urlparse.urljoin(self.url, path),\n            action=method.lower(),\n            encoding=encoding,\n            description=description,\n            fields=fields,\n            transform=None,  # Not handled, but here for future reference\n        )\n        link._responses = self.get_responses(path, method, callback, view)\n        link._produces = self.get_produces(path, method, callback, view)\n\n        return link", "response": "Get a coreapi. Link instance for the given path method and view."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tokml(self):\n        placemark = create_elem('Placemark')\n        if self.name:\n            placemark.set('id', self.name)\n            placemark.name = create_elem('name', text=self.name)\n        if self.description:\n            placemark.description = create_elem('description',\n                                                text=self.description)\n        placemark.Point = create_elem('Point')\n\n        data = [str(self.longitude), str(self.latitude)]\n        if self.altitude:\n            if int(self.altitude) == self.altitude:\n                data.append('%i' % self.altitude)\n            else:\n                data.append(str(self.altitude))\n        placemark.Point.coordinates = create_elem('coordinates',\n                                                  text=','.join(data))\n\n        return placemark", "response": "Generate a KML Placemark element subtree."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimporting KML data files into a dictionary.", "response": "def import_locations(self, kml_file):\n        \"\"\"Import KML data files.\n\n        ``import_locations()`` returns a dictionary with keys containing the\n        section title, and values consisting of :class:`Placemark` objects.\n\n        It expects data files in KML format, as specified in `KML Reference`_,\n        which is XML such as::\n\n            <?xml version=\"1.0\" encoding=\"utf-8\"?>\n            <kml xmlns=\"http://earth.google.com/kml/2.1\">\n                <Document>\n                    <Placemark id=\"Home\">\n                        <name>Home</name>\n                        <Point>\n                            <coordinates>-0.221,52.015,60</coordinates>\n                        </Point>\n                    </Placemark>\n                    <Placemark id=\"Cambridge\">\n                        <name>Cambridge</name>\n                        <Point>\n                            <coordinates>0.390,52.167</coordinates>\n                        </Point>\n                    </Placemark>\n                </Document>\n            </kml>\n\n        The reader uses the :mod:`ElementTree` module, so should be very fast\n        when importing data.  The above file processed by\n        ``import_locations()`` will return the following ``dict`` object::\n\n            {\"Home\": Placemark(52.015, -0.221, 60),\n             \"Cambridge\": Placemark(52.167, 0.390, None)}\n\n        Args:\n            kml_file (iter): KML data to read\n\n        Returns:\n            dict: Named locations with optional comments\n\n        .. _KML Reference:\n           http://code.google.com/apis/kml/documentation/kmlreference.html\n        \"\"\"\n        self._kml_file = kml_file\n        data = utils.prepare_xml_read(kml_file, objectify=True)\n\n        for place in data.Document.Placemark:\n            name = place.name.text\n            coords = place.Point.coordinates.text\n            if coords is None:\n                logging.info('No coordinates found for %r entry' % name)\n                continue\n            coords = coords.split(',')\n            if len(coords) == 2:\n                longitude, latitude = coords\n                altitude = None\n            elif len(coords) == 3:\n                longitude, latitude, altitude = coords\n            else:\n                raise ValueError('Unable to handle coordinates value %r'\n                                 % coords)\n            try:\n                description = place.description\n            except AttributeError:\n                description = None\n            self[name] = Placemark(latitude, longitude, altitude, name,\n                                   description)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_kml_file(self):\n        kml = create_elem('kml')\n        kml.Document = create_elem('Document')\n        for place in sorted(self.values(), key=lambda x: x.name):\n            kml.Document.append(place.tokml())\n\n        return etree.ElementTree(kml)", "response": "Generate KML element tree from Placemarks."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _format_output(account, data):\n    data['account'] = account\n    output = (\"\"\"Ebox data for account: {d[account]}\n\nBalance\n=======\nBalance:      {d[balance]:.2f} $\n\nUsage\n=====\nUsage:      {d[usage]:.2f} %\n\nBefore offpeak\n==============\nDownload: {d[before_offpeak_download]:.2f} Gb\nUpload:   {d[before_offpeak_upload]:.2f} Gb\nTotal:    {d[before_offpeak_total]:.2f} Gb\n\nOffpeak\n=======\nDownload: {d[offpeak_download]:.2f} Gb\nUpload:   {d[offpeak_upload]:.2f} Gb\nTotal:    {d[offpeak_total]:.2f} Gb\n\nTotal\n=====\nDownload: {d[download]:.2f} Gb\nUpload:   {d[upload]:.2f} Gb\nTotal:    {d[total]:.2f} Gb\nLimit:    {d[limit]:.2f} Gb\n\"\"\")\n    print(output.format(d=data))", "response": "Format data to get a readable output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_simple(self, serializer=None):\n        return dict(\n            count=self.paginator.count,\n            page=self.page_number,\n            num_pages=self.paginator.num_pages,\n            next=self.next_page,\n            prev=self.previous_page,\n            resources=self.resources,\n        )", "response": "Prepare to serialization.\n\n        :return dict: paginator params"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting current page. :return int: page number", "response": "def page(self):\n        \"\"\" Get current page.\n\n        :return int: page number\n\n        \"\"\"\n        if not self._page:\n            try:\n                self._page = self.paginator.page(\n                    self.query_dict.get('page', 1))\n            except InvalidPage:\n                raise HttpError(\"Invalid page\", status=HTTP_400_BAD_REQUEST)\n        return self._page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning URL for next page.", "response": "def next_page(self):\n        \"\"\" Return URL for next page.\n\n        :return str:\n\n        \"\"\"\n        if self.page.has_next():\n            self.query_dict['page'] = self.page.next_page_number()\n            return \"%s?%s\" % (self.path, urlencode(self.query_dict))\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning URL for previous page.", "response": "def previous_page(self):\n        \"\"\" Return URL for previous page.\n\n        :return str:\n\n        \"\"\"\n        if self.page.has_previous():\n            previous = self.page.previous_page_number()\n            if previous == 1:\n                if 'page' in self.query_dict:\n                    del self.query_dict['page']\n            else:\n                self.query_dict['page'] = previous\n            return \"%s?%s\" % (self.path, urlencode(self.query_dict))\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the value of a key in a record.", "response": "def get_value(record, key, default=None):\n    \"\"\"Return item as `dict.__getitem__` but using 'smart queries'.\n\n    .. note::\n\n        Accessing one value in a normal way, meaning d['a'], is almost as\n        fast as accessing a regular dictionary. But using the special\n        name convention is a bit slower than using the regular access:\n        .. code-block:: python\n            >>> %timeit x = dd['a[0].b']\n            100000 loops, best of 3: 3.94 us per loop\n            >>> %timeit x = dd['a'][0]['b']\n            1000000 loops, best of 3: 598 ns per loop\n    \"\"\"\n    def getitem(k, v, default):\n        if isinstance(v, string_types):\n            raise KeyError\n        elif isinstance(v, dict):\n            return v[k]\n        elif ']' in k:\n            k = k[:-1].replace('n', '-1')\n            # Work around for list indexes and slices\n            try:\n                return v[int(k)]\n            except IndexError:\n                return default\n            except ValueError:\n                return v[slice(*map(\n                    lambda x: int(x.strip()) if x.strip() else None,\n                    k.split(':')\n                ))]\n        else:\n            tmp = []\n            for inner_v in v:\n                try:\n                    tmp.append(getitem(k, inner_v, default))\n                except KeyError:\n                    continue\n            return tmp\n\n    # Wrap a top-level list in a dict\n    if isinstance(record, list):\n        record = {'record': record}\n        key = '.'.join(['record', key])\n\n    # Check if we are using python regular keys\n    try:\n        return record[key]\n    except KeyError:\n        pass\n\n    keys = SPLIT_KEY_PATTERN.split(key)\n    value = record\n    for k in keys:\n        try:\n            value = getitem(k, value, default)\n        except KeyError:\n            return default\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes sure the request has a valid authorization jwt before calling the wrapped function. It does this by checking the timestamp of the last jwt and if > 10 minutes have elapsed, it refreshes it's existing jwt from the server. Args: f: Function to wrap Returns: Function, f", "response": "def _auth(f):\n        \"\"\"\n        Makes sure the request has a valid authorization jwt before calling the wrapped function.\n        It does this by checking the timestamp of the last jwt and if > 10 minutes have elapsed,\n        it refreshes it's existing jwt from the server.\n        Args:\n            f: Function to wrap\n\n        Returns:\n            Function, f\n        \"\"\"\n        @wraps(f)\n        def method(self, *args, **kwargs):\n            if not self._auth_token or datetime.utcnow() >= self._last_auth + timedelta(minutes=10):\n                # Need to get new jwt\n                self.auth_refresh()\n\n            return f(self, *args, **kwargs)\n        return method"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_response(response, expected):\n\n        response_code = response.status_code\n        if expected == response_code:\n            return\n\n        if response_code < 400:\n            raise ex.UnexpectedResponseCodeException(response.text)\n\n        elif response_code == 401:\n            raise ex.UnauthorizedException(response.text)\n\n        elif response_code == 400:\n            raise ex.BadRequestException(response.text)\n\n        elif response_code == 403:\n            raise ex.ForbiddenException(response.text)\n\n        elif response_code == 404:\n            raise ex.NotFoundException(response.text)\n\n        elif response_code == 429:\n            raise ex.RateLimitedException(response.text)\n\n        else:\n            raise ex.InternalServerErrorException(response.text)", "response": "Checks if the expected response code matches the actual response code. Raises an appropriate exception if they are not."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrenewing the authentication token manually.", "response": "def auth_refresh(self, apikey=None, secret=None, email=None, password=None):\n        \"\"\"\n        Renew authentication token manually.  Uses POST to /auth interface\n\n        :param apikey: Unique identifier for authorized use of the API\n        :type apikey: str or None\n        :param secret: The secret password corresponding to the API key.\n        :type secret: str or None\n        :param email: Email to use for authentication\n        :type apikey: str or None\n        :param apikey: Password corresponding to email\n        :type apikey: str or None\n        :Returns: None\n        \"\"\"\n        jwt = self.auth_token(apikey=apikey, secret=secret, email=email, password=password)\n        self._headers[\"Authorization\"] = \"Bearer %s\" % jwt\n\n        self._auth_token = jwt\n        self._last_auth = datetime.utcnow()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets authentication token. Uses POST to / auth interface.", "response": "def auth_token(self, apikey=None, secret=None, email=None, password=None):\n        \"\"\"\n        Get authentication token.  Uses POST to /auth interface.\n\n        :Returns: (str) Authentication JWT\n        \"\"\"\n        if (apikey and secret) or (self._apikey and self._secret):\n            body = {\n                \"key_id\": apikey or self._apikey,\n                \"secret\": secret or self._secret\n            }\n        elif (email and password) or (self._email and self._password):\n            body = {\n                \"user\" : email or self._email,\n                \"password\" : password or self._password\n            }\n        else:\n            raise Value(\"No authentication provided.\")\n        response = self._post(url.auth, body=body)\n\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"jwt\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auth_grant(self, client, role=None, mode=None):\n\n        body = {\n            \"name\": client\n        }\n        if role:\n            body[\"role\"] = role\n        if mode:\n            body[\"mode\"] = mode\n        response = self._post(url.auth_grant, body=body)\n\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Used to get a grant token for a given client."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new client.", "response": "def client_create(self, name, password):\n        \"\"\"\n        Create a new client.  Uses the POST to /clients interface.\n\n        :Args:\n          * *name*: (str) Name of client\n          * *password*: (str) Password of client\n        :Returns: (str) ID of the newly created client.\n        \"\"\"\n        body = {\n            \"name\": name,\n            \"password\": password\n        }\n        response = self._post(url.clients, body=body)\n        self._check_response(response, 201)\n        return self._create_response(response).get(\"client_id\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef client_count(self):\n        response = self._head(url.clients)\n        self._check_response(response, 200)\n        return int(response.headers.get(\"x-client-count\", -1))", "response": "Get number of clients. Uses HEAD to / clients interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets list of clients. Uses GET to / clients interface.", "response": "def client_list(self, name=None, name_only=None, all_enrolled=None):\n        \"\"\"\n        Get list of clients.  Uses GET to /clients interface.\n\n        :Kwargs:\n          * *name*: (str) If specified, returns the client information for this client only.\n          * *name_only*: (bool) If true, returns only the names of the clients requested\n          * *all_enrolled*: (bool) If true, will return all enrolled clients\n\n        :Returns:  (list) List of dictionaries with the client information as requested.\n        \"\"\"\n        params = {}\n\n        if name:                    # When specific name value is provided\n            params[\"name\"] = name\n        if name_only:               # (Boolean) \"True\": only keyword \"name\" is provided\n            params[\"name\"] = \"\"\n        if all_enrolled:            # (Boolean) \"True\": returns all enrolled clients\n            params[\"all_enrolled\"] = all_enrolled\n\n        response = self._get(url.clients, params=params)\n\n        self._check_response(response, 200)\n        if name:\n            return response.json()\n        return self._create_response(response).get(\"clients\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef client_id(self, client):\n\n        params = {\n            \"name\": client\n        }\n\n        response = self._get(url.clients, params=params)\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"client_id\")", "response": "Get a client s ID. Uses GET to / clients?name=<client > interface."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef client_info(self, client):\n        client = self._client_id(client)\n        response = self._get(url.clients_id.format(id=client))\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get client info. Uses GET to / clients/<client > interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef client_validate_password(self, client, password):\n\n        client = self._client_id(client)\n        body = {\n            \"action\": \"validate_password\",\n            \"auth_password\": password\n        }\n\n        response = self._put(url.clients_id.format(id=client), body=body)\n        self._check_response(response, 200)", "response": "Validate client s password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate client s PIN.", "response": "def client_validate_pin(self, client, pin):\n        \"\"\"\n        Validate client's PIN.  Uses PUT to /clients/<client> interface.\n\n        :Args:\n            * *client*: (str) Client's ID\n            * *pin*: (str) Client's PIN\n        \"\"\"\n\n        client = self._client_id(client)\n        body = {\n            \"action\": \"validate_pin\",\n            \"current_pin\": pin\n        }\n\n        response = self._put(url.clients_id.format(id=client), body=body)\n        self._check_response(response, 200)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates client info Uses PUT to /clients/<client> interface :Args: * *client*: (str) Client's ID :Kwargs: * *reason*: (str) The reason for changing the client's settings * *pin*: (str) The new PIN to set * *current_pin*: (str) The current PIN of the user. Only required if role is not admin and the Account Reset Mode (System Configuration) requires PIN. * *verification_speed*: (int) The speed at which the verification should appear for the client. Allowed values: 0, 25, 50, 75, 100. * *row_doubling*: (str) Row doubling is an AudioPIN only option that puts two rows of words in each pinpad digit. Allowed values: \"OFF\", \"TRAIN\", \"ON\" * *password*: (str) New client password * *bypass_expiration*: (int) Used to enable/disable a client's bypass. The time, in minutes, from when the request was received until the bypass expires. 0 removes the bypass, while -1 sets a bypass that doesn't expire. * *bypass_limit*: (int) The number of times a user may bypass. Set to 0 for no limit. If set without either an existing valid bypass_expiration, or providing one in the request, the client's bypass_expiration will be set to 10 mins. Default value: 0. Size range: >=0 * *bypass_spacing_minutes*: (int) Specifies the time, in minutes, the user must wait between using each bypass. Set to 0 for no bypass rate limiting. If set without either an existing valid bypass_expiration, or providing one in the request, the client's bypass_expiration will be set to 10 mins. * *bypass_code*: (str) The code that the client must enter to bypass. * *is_disabled*: (bool) If true, the client cannot do verifications (will automatically bypass). * *verification_lock*: (bool) Unlocks the given client if the client verified incorrectly too many times. * *password_lock*: (bool) Set to false to unlock a client who enter thier password incorrectly too many times. * *enroll_deadline_extension_minutes*: (int) Amount of time, in minutes, to extend an enrollment deadline by. * *enroll_deadline_enable*: (bool) When true, enables the enrollment deadline for a certain client, when false disables an enrollment deadline. * *windows_profile*: (str) Assigns a Windows Profile to the user using the Windows Profile ID. To remove a profile, send null. * *role_rationale*: (str) Update the client rationale for a role * *role*: (str) Update the client role. Note: Google users cannot have their role updated. Allowed values: \"admin\", \"manager\", \"support\", \"user\". :More information: Can be found `here <https://cloud.knuverse.com/docs/api/#api-Clients-Update_client_information>`_.", "response": "def client_update(self,\n                           client,\n                           reason=None,\n                           pin=None,\n                           current_pin=None,\n                           verification_speed=None,\n                           row_doubling=None,\n                           password=None,\n                           bypass_expiration=None,\n                           bypass_limit=None,\n                           bypass_spacing_minutes=None,\n                           bypass_code=None,\n                           is_disabled=None,\n                           verification_lock=None,\n                           password_lock=None,\n                           enroll_deadline_extension_minutes=None,\n                           enroll_deadline_enable=None,\n                           windows_profile=None,\n                           role_rationale=None,\n                           role=None,\n                           ):\n        \"\"\"\n        Update client info\n        Uses PUT to /clients/<client> interface\n\n        :Args:\n            * *client*: (str) Client's ID\n\n        :Kwargs:\n            * *reason*: (str) The reason for changing the client's settings\n            * *pin*: (str) The new PIN to set\n            * *current_pin*: (str) The current PIN of the user. Only required if role is not admin and the Account Reset Mode (System Configuration) requires PIN.\n            * *verification_speed*: (int) The speed at which the verification should appear for the client.  Allowed values: 0, 25, 50, 75, 100.\n            * *row_doubling*: (str) Row doubling is an AudioPIN only option that puts two rows of words in each pinpad digit.  Allowed values: \"OFF\", \"TRAIN\", \"ON\"\n            * *password*: (str) New client password\n            * *bypass_expiration*: (int) Used to enable/disable a client's bypass. The time, in minutes, from when the request was received until the bypass expires. 0 removes the bypass, while -1 sets a bypass that doesn't expire.\n            * *bypass_limit*: (int) The number of times a user may bypass. Set to 0 for no limit. If set without either an existing valid bypass_expiration, or providing one in the request, the client's bypass_expiration will be set to 10 mins.  Default value: 0.  Size range: >=0\n            * *bypass_spacing_minutes*: (int) Specifies the time, in minutes, the user must wait between using each bypass. Set to 0 for no bypass rate limiting. If set without either an existing valid bypass_expiration, or providing one in the request, the client's bypass_expiration will be set to 10 mins.\n            * *bypass_code*: (str) The code that the client must enter to bypass.\n            * *is_disabled*: (bool) If true, the client cannot do verifications (will automatically bypass).\n            * *verification_lock*: (bool) Unlocks the given client if the client verified incorrectly too many times.\n            * *password_lock*: (bool) Set to false to unlock a client who enter thier password incorrectly too many times.\n            * *enroll_deadline_extension_minutes*: (int) Amount of time, in minutes, to extend an enrollment deadline by.\n            * *enroll_deadline_enable*: (bool) When true, enables the enrollment deadline for a certain client, when false disables an enrollment deadline.\n            * *windows_profile*: (str) Assigns a Windows Profile to the user using the Windows Profile ID. To remove a profile, send null.\n            * *role_rationale*: (str) Update the client rationale for a role\n            * *role*: (str) Update the client role. Note: Google users cannot have their role updated.  Allowed values: \"admin\", \"manager\", \"support\", \"user\".\n\n        :More information: Can be found `here <https://cloud.knuverse.com/docs/api/#api-Clients-Update_client_information>`_.\n\n        \"\"\"\n        client = self._client_id(client)\n\n        body = {}\n        if reason is not None:\n            body[\"reason\"] = reason\n        if pin is not None:\n            body[\"pin\"] = pin\n        if current_pin is not None:\n            body[\"current_pin\"] = current_pin\n        if verification_speed is not None:\n            body[\"verification_speed\"] = verification_speed\n        if row_doubling is not None:\n            body[\"row_doubling\"] = row_doubling\n        if password is not None:\n            body[\"auth_password\"] = self._password\n            body[\"password\"] = password\n        if bypass_expiration is not None:\n            body[\"bypass_expiration\"] = bypass_expiration\n        if bypass_limit is not None:\n            body[\"bypass_limit\"] = bypass_limit\n        if bypass_spacing_minutes is not None:\n            body[\"bypass_spacing_minutes\"] = bypass_spacing_minutes\n        if bypass_code is not None:\n            body[\"bypass_code\"] = bypass_code\n        if is_disabled is not None:\n            body[\"is_disabled\"] = is_disabled\n        if verification_lock is not None:\n            body[\"verification_lock\"] = verification_lock\n        if password_lock is not None:\n            body[\"password_lock\"] = password_lock\n        if enroll_deadline_extension_minutes is not None:\n            body[\"enroll_deadline_extension_minutes\"] = enroll_deadline_extension_minutes\n        if enroll_deadline_enable is not None:\n            body[\"enroll_deadline_enable\"] = enroll_deadline_enable\n        if windows_profile is not None:\n            body[\"windows_profile\"] = windows_profile\n        if role is not None:\n            body[\"auth_password\"] = self._password\n            body[\"role\"] = role\n        if role_rationale is not None:\n            body[\"role_rationale\"] = role_rationale\n\n        response = self._put(url.clients_id.format(id=client), body=body)\n        self._check_response(response, 200)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef client_unenroll(self, client):\n        client = self._client_id(client)\n        response = self._delete(url.clients_id.format(id=client))\n        self._check_response(response, 204)", "response": "Unenrolls a specific entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting Client Enrollment Data. Uses GET to / enrollment.", "response": "def enrollment_resource(self, client, audio=False):\n        \"\"\"\n        Get Client Enrollment Data.  Uses GET to /enrollments/<client> interface.\n\n        :Args:\n            * *client*: (str) Client's ID\n            * *audio*: (boolean) If True then the enrollment audio is returned.\n        :Returns: (dictionary) Look `here <https://cloud.knuverse.com/docs/api/#api-Enrollments-Get_enrollment_info>`_ for information on keys and values.\n        \"\"\"\n        client = self._client_id(client)\n        params = {}\n        if audio:\n            params[\"audio\"] = True\n\n        response = self._get(url.enrollments_id.format(id=client), params=params)\n        self._check_response(response, 200)\n        return self._create_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enrollment_start(\n            self,\n            name,\n            mode=None,\n            pin=None,\n            phone_number=None\n    ):\n        \"\"\"\n        Start Client Enrollment.  Uses the POST to /enrollments interface.\n\n        :Args:\n            * *client*: (str) Client's Name\n            * *mode*: (str) DEPRECATED. Presence of PIN is used to determine mode (AudioPass vs AudioPIN)\n            * *pin*: (str) Client's PIN. 4 digit string\n            * *phone_number*: (str) Phone number to call.\n\n        :Returns: (dict) Enrollment record with prompts as described `here <https://cloud.knuverse.com/docs/api/#api-Enrollments-Start_enrollment>`_.\n        \"\"\"\n        data = {\n            \"name\": name,\n        }\n\n        if mode:\n            warning_msg = 'WARNING: The \"mode\" parameter for enrollment_start is DEPRECATED and will be ignored. ' \\\n                          'To avoid incompatibility with a future release please stop providing it.'\n            print(warning_msg, file=sys.stderr)\n        if pin:\n            data[\"pin\"] = pin\n        if phone_number:\n            data[\"phone_number\"] = phone_number\n\n        response = self._post(url.enrollments, body=data)\n        self._check_response(response, 201)\n        return self._create_response(response)", "response": "Start Client Enrollment.  Uses the POST to /enrollments interface.\n\n        :Args:\n            * *client*: (str) Client's Name\n            * *mode*: (str) DEPRECATED. Presence of PIN is used to determine mode (AudioPass vs AudioPIN)\n            * *pin*: (str) Client's PIN. 4 digit string\n            * *phone_number*: (str) Phone number to call.\n\n        :Returns: (dict) Enrollment record with prompts as described `here <https://cloud.knuverse.com/docs/api/#api-Enrollments-Start_enrollment>`_."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload the audio file of the recorded words to the enrollments table.", "response": "def enrollment_upload(\n        self,\n        enrollment_id,\n        audio_file,\n    ):\n        \"\"\"\n        Upload Enrollment Data.  Uses PUT to /enrollments/<enrollment_id> interface.\n\n        :Args:\n            * *enrollment_id*: (str) Enrollment's ID\n            * *audio_file*: (str) Path to the audio file of the recorded words. Not required for phone enrollments.\n\n        \"\"\"\n        files = {\n            \"file\": os.path.basename(audio_file),\n            os.path.basename(audio_file): open(audio_file, 'rb')\n        }\n\n        response = self._put(url.enrollments_id.format(id=enrollment_id), files=files)\n        self._check_response(response, 202)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a client s events. Uses GET to events_clients_id interface.", "response": "def events_client(self, client):\n        \"\"\"\n        Get a client's events.  Uses GET to /events/clients/<client> interface.\n\n        :Args:\n          * *client*: (str) Client's ID\n\n        :Returns: (list) Events\n        \"\"\"\n        # TODO Add paging to this\n        client = self._client_id(client)\n        response = self._get(url.events_clients_id.format(id=client))\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"events\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef events_clients(self):\n        # TODO Add paging to this\n        response = self._get(url.events_clients)\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"events\")", "response": "Get all client events. Uses GET to events_clients interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef events_login(self):\n        # TODO Add paging to this\n        response = self._get(url.events_logins)\n        return self._create_response(response).get(\"events\")", "response": "Get all login events. Uses GET to / events / login interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef events_system(self):\n        # TODO Add paging to this\n        response = self._get(url.events_system)\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"events\")", "response": "Get all system events. Uses GET to events_system interface."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget server info. Uses GET to / about interface.", "response": "def about(self):\n        \"\"\"\n        Get server info.  Uses GET to /about interface\n\n        :returns: dict - Server information\n        \"\"\"\n        response = self._get(url.about)\n        self._check_response(response, 200)\n        return self._create_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef status(self):\n        response = self._get(url.status)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get server status. Uses GET to / status interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef warnings(self):\n        response = self._get(url.status_warnings)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get server system warnings. Uses GET to status_warnings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef module_settings(self):\n        response = self._get(url.settings_modules)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get the module settings. Uses GET to / settings. modules interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the settings of the specified module.", "response": "def settings_module_update(self,\n                            mode_audiopin_enable=None,\n                            mode_audiopass_enable=None,\n                            mode_default=None):\n        \"\"\"\n        Set Module settings.  Uses PUT to /settings/modules interface.\n\n        :Args:\n          * *mode_audiopin_enable*: (bool) Turn on and off the AudioPIN feature\n          * *mode_audiopass_enable*: (bool) Turn on and off the AudioPass feature\n          * *mode_default*: (str)  Set the default verification mode.  Either 'audiopin' or 'audiopass'.\n\n        :Returns: None\n        \"\"\"\n        body = {\n            \"auth_password\": self._password\n        }\n        if mode_audiopin_enable:\n            body[\"mode_audiopin_enable\"] = mode_audiopin_enable\n        if mode_audiopass_enable:\n            body[\"mode_audiopass_enable\"] = mode_audiopass_enable\n        if mode_default:\n            body[\"mode_default\"] = mode_default\n\n        response = self._put(url.settings_modules, body=body)\n        self._check_response(response, 200)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreset the module settings back to default.", "response": "def settings_module_reset(self):\n        \"\"\"\n        Resets the module settings back to default.  Uses DELETE to /settings/modules interface.\n        \"\"\"\n        data = {\n            \"auth_password\": self._password\n        }\n\n        response = self._delete(url.settings_modules, body=data)\n        self._check_response(response, 204)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a report for all events in the input range.", "response": "def report_events(self, start_date, end_date, type=\"system\"):\n        \"\"\"\n        Create a report for all client events or all system events.\n        Uses GET to /reports/events/{clients,system} interface\n\n        :Args:\n          * *start_date*: (datetime) Start time for report generation\n          * *end_date*: (datetime) End time for report generation\n        :Kwargs:\n          * *type*: (str) Type of event report to create. \"system\" or \"clients\"\n\n        :Returns: (list) List of events in the input range\n\n        \"\"\"\n\n\n        start_str, end_str = self._format_input_dates(start_date, end_date)\n        params = {\n            \"start_date\": start_str,\n            \"end_date\": end_str\n        }\n        endpoint = url.reports_events_clients if type == \"clients\" else url.reports_events_system\n        response = self._get(endpoint, params=params)\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"events\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef report_verifications(self, start_date, end_date):\n        start_str, end_str = self._format_input_dates(start_date, end_date)\n        params = {\n            \"start_date\": start_str,\n            \"end_date\": end_str\n        }\n        response = self._get(url.reports_verifications, params=params)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Creates a report for all verifications."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef settings_system(self):\n        response = self._get(url.settings_system)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get system settings. Uses GET to / settings / system interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the system settings.", "response": "def settings_system_update(self, data):\n        \"\"\"\n        Set system settings.  Uses PUT to /settings/system interface\n\n        :Args:\n            * *data*: (dict) Settings dictionary as specified `here <https://cloud.knuverse.com/docs/api/#api-System_Settings-Set_System_Settings>`_.\n\n        :Returns: None\n        \"\"\"\n        data[\"auth_password\"] = self._password\n\n        response = self._put(url.settings_system, body=data)\n        self._check_response(response, 200)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the system settings back to default.", "response": "def settings_system_reset(self):\n        \"\"\"\n        Resets the system settings back to default.  Uses DELETE to /settings/system interface.\n        \"\"\"\n        data = {\n            \"auth_password\": self._password\n        }\n\n        response = self._delete(url.settings_system, body=data)\n        self._check_response(response, 204)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts a verification for the specified client.", "response": "def verification_start(\n        self,\n        client,\n        mode=None,\n        verification_speed=None,\n        row_doubling=\"off\",\n        phone_number=None,\n    ):\n        \"\"\"\n        Start a verification.  Uses POST to /verifications interface.\n\n        :Args:\n            * *client*: (str) Client's Name\n            * *mode*: (str) Verification Mode. Allowed values: \"audiopin\", \"audiopass\"\n            * *verification_speed*: (int) Allowed values: 0, 25, 50, 75, 100\n            * *row_doubling*: (str) Allowed values: \"off\", \"train\", \"on\"\n            * *phone_number*: (str) Phone number to call.\n\n        :Returns: (dict) Verification record with animation as discussed `here <https://cloud.knuverse.com/docs/api/#api-Verifications-Start_verification>`_.\n        \"\"\"\n\n        data = {\n            \"name\": client,\n            \"user_agent\": \"knuverse-sdk-python-v%s\" % self.version\n        }\n        if mode:\n            data[\"mode\"] = mode\n\n        if phone_number:\n            data[\"phone_number\"] = phone_number\n\n        if verification_speed:\n            data[\"verification_speed\"] = verification_speed\n\n        if row_doubling:\n            data[\"row_doubling\"] = row_doubling\n\n        response = self._post(url.verifications, body=data)\n        self._check_response(response, 201)\n        return self._create_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuploads verification data to the specified resource.", "response": "def verification_upload(\n            self,\n            verification_id,\n            audio_file=None,\n            bypass=False,\n            bypass_pin=None,\n            bypass_code=None,\n            ):\n        \"\"\"\n        Upload verification data.  Uses PUT to /verfications/<verification_id> interface\n\n        :Args:\n            * *verification_id*: (str) Verification ID\n            * *audio_file*: (str) Path to the audio file of the recorded words. Not required for phone verifications.\n            * *bypass*: (boolean) True if using a bypass code or pin to verify\n            * *bypass_pin*: (str) Client's PIN if this is a bypass\n            * *bypass_code*: (str) Client's bypass code if this is a bypass\n        \"\"\"\n        files = {}\n        if audio_file:\n            files[os.path.basename(audio_file)] = open(audio_file, 'rb')\n            files[\"file\"] = os.path.basename(audio_file)\n        elif bypass:\n            files[\"bypass\"] = True\n            files[\"bypass_code\"] = bypass_code\n            files[\"pin\"] = bypass_pin\n        response = self._put(url.verifications_id.format(id=verification_id), files=files)\n        self._check_response(response, 202)\n        return self._create_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncancels a started verification.", "response": "def verification_cancel(self, verification_id, reason=None):\n        \"\"\"\n        Cancels a started verification.  Uses PUT to /verifications/<verification_id> interface\n\n        :Args:\n          * *verification_id*: (str) Verification ID\n        :Kwargs:\n          * *reason*: (str) Reason for cancelling the verification\n\n        :Returns: None\n        \"\"\"\n\n        data = {\n            \"cancel\": True,\n            \"cancel_reason\": reason\n        }\n\n        response = self._put(url.verifications_id.format(id=verification_id), body=data)\n        self._check_response(response, 202)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a verification from the resource store.", "response": "def verification_delete(self, verification_id):\n        \"\"\"\n        Remove verification.  Uses DELETE to /verifications/<verification_id> interface.\n\n        :Args:\n            * *verification_id*: (str) Verification ID\n        \"\"\"\n        response = self._delete(url.verifications_id.format(id=verification_id))\n        self._check_response(response, 204)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget Verification Count. Uses HEAD to get the number of verifications.", "response": "def verification_count(self):\n        \"\"\"\n        Get Verification Count.  Uses HEAD to /verifications interface.\n\n        :Returns: (int) Number of verifications\n        \"\"\"\n        response = self._head(url.verifications)\n        self._check_response(response, 200)\n        return int(response.headers.get('x-verification-count', -1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef verification_list(self, limit=10):\n\n        # TODO add arguments for paging and stuff\n        params = {}\n        params[\"limit\"] = limit\n\n        response = self._get(url.verifications, params=params)\n        self._check_response(response, 200)\n        return self._create_response(response).get(\"verifications\")", "response": "Get list of verifications for a given set of keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget Verification Resource. Uses GET to / verifications.", "response": "def verification_resource(self, verification_id, audio=False):\n        \"\"\"\n        Get Verification Resource.  Uses GET to /verifications/<verification_id> interface.\n\n        :Args:\n            * *verification_id*: (str) Verification ID\n            * *audio*: (boolean) If True, audio data associated with verification will be returned.\n        :Returns: (dict) Verification data as shown `here <https://cloud.knuverse.com/docs/api/#api-Verifications-Get_verification_info>`_.\n        \"\"\"\n        params = {}\n        if audio:\n            params[\"audio\"] = True\n\n        response = self._get(url.verifications_id.format(id=verification_id), params=params)\n        self._check_response(response, 200)\n        return self._create_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verification_resource_secure(self, verification_id, jwt, name):\n        params = {\n            \"jwt\": jwt,\n            \"name\": name\n        }\n\n        response = self._get(url.verifications_id.format(id=verification_id), params=params)\n        self._check_response(response, 200)\n        return self._create_response(response)", "response": "Get the verification resource for a given verification ID and JWT."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef monkey_patch():\n    reset()\n    time_mod.time = time\n    time_mod.sleep = sleep\n    time_mod.gmtime = gmtime\n    time_mod.localtime = localtime\n    time_mod.ctime = ctime\n    time_mod.asctime = asctime\n    time_mod.strftime = strftime", "response": "monkey patch time module to use out versions"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef monkey_restore():\n    for k, v in originals.items():\n        setattr(time_mod, k, v)\n    \n    global epoch\n    epoch = None", "response": "restore real versions. Inverse of monkey_patch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngrabs the first element at xpath if present else returns None.", "response": "def _grab_xpath(root, xpath, converter=lambda x: x):\n    \"\"\"\n    XML convenience - grabs the first element at xpath if present, else returns None.\n    \"\"\"\n    elements = root.xpath(xpath)\n    if elements:\n        return converter(str(elements[0]))\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npredicate function encapsulating data clean up filter code.", "response": "def _has_bad_coords(root, stream):\n    \"\"\"\n    Predicate function encapsulating 'data clean up' filter code.\n\n    Currently minimal, but these sort of functions tend to grow over time.\n\n    Problem 1:\n        Some of the GCN packets have an RA /Dec equal to (0,0) in the WhereWhen,\n        and a flag in the What signifying that those are actually dummy co-ords.\n        (This is used for time-stamping an event which is not localised).\n        So, we don't load those positions, to avoid muddying the database\n        corpus.\n    Problem 2:\n        com.dc3/dc3.broker#BrokerTest packets have dummy RA/Dec values,\n        with no units specified.\n        (They're also marked role=test, so it's not such a big deal,\n        but it generates a lot of debug-log churn.)\n    \"\"\"\n    if stream == \"com.dc3/dc3.broker\":\n        return True\n    if not stream.split('/')[0] == 'nasa.gsfc.gcn':\n        return False\n    toplevel_params = vp.get_toplevel_params(root)\n    if \"Coords_String\" in toplevel_params:\n        if (toplevel_params[\"Coords_String\"]['value'] ==\n                \"unavailable/inappropriate\"):\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an OrderedDict representation of the SQLalchemy table row.", "response": "def to_odict(self, exclude=None):\n        \"\"\"\n        Returns an OrderedDict representation of the SQLalchemy table row.\n        \"\"\"\n        if exclude is None:\n            exclude = tuple()\n        colnames = [c.name for c in self.__table__.columns\n                    if c.name not in exclude]\n        return OrderedDict(((col, getattr(self, col)) for col in colnames))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_etree(root):\n        cite_list = []\n        citations = root.xpath('Citations/EventIVORN')\n        if citations:\n            description = root.xpath('Citations/Description')\n            if description:\n                description_text = description[0].text\n            else:\n                description_text = None\n            for entry in root.Citations.EventIVORN:\n                if entry.text:\n                    cite_list.append(\n                        Cite(ref_ivorn=entry.text,\n                             cite_type=entry.attrib['cite'],\n                             description=description_text)\n                    )\n                else:\n                    logger.info(\n                        'Ignoring empty citation in {}'.format(\n                            root.attrib['ivorn']))\n        return cite_list", "response": "Load up the citations and description from the XML root element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_etree(root):\n\n        acceptable_coord_systems = (\n            vp.definitions.sky_coord_system.utc_fk5_geo,\n            vp.definitions.sky_coord_system.utc_fk5_topo,\n            vp.definitions.sky_coord_system.utc_icrs_geo,\n            vp.definitions.sky_coord_system.utc_icrs_topo,\n            vp.definitions.sky_coord_system.tdb_fk5_bary,\n            vp.definitions.sky_coord_system.tdb_icrs_bary,\n        )\n\n        position_list = []\n        astrocoords = root.xpath(\n            'WhereWhen/ObsDataLocation/ObservationLocation/AstroCoords'\n        )\n        if astrocoords:\n            for idx, entry in enumerate(astrocoords):\n                posn = vp.get_event_position(root,idx)\n                if posn.system not in acceptable_coord_systems:\n                    raise NotImplementedError(\n                        \"Loading position from coord-sys \"\n                        \"is not yet implemented: {} \".format(\n                            posn.system\n                        )\n                    )\n                if posn.units != vp.definitions.units.degrees:\n                    raise NotImplementedError(\n                        \"Loading positions in formats other than degrees \"\n                        \"is not yet implemented.\"\n                    )\n                try:\n                    isotime = vp.get_event_time_as_utc(root,idx)\n                except:\n                    logger.warning(\n                        \"Error pulling event time for ivorn {}, \"\n                        \"setting to NULL\".format(root.attrib['ivorn'])\n                    )\n                    isotime = None\n\n                position_list.append(\n                    Coord(ra = posn.ra,\n                          dec = posn.dec,\n                          error = posn.err,\n                          time = isotime)\n                )\n        return position_list", "response": "Load up the coordinates of the co - ordinates of the given Voevent."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of fields for multilanguage fields of model.", "response": "def mt_fields(fields, nomaster=False, onlydefaultlang=False):\n    \"\"\"\n    Returns list of fields for multilanguage fields of model.\n    Examples:\n        print(mt_fields('name', 'desc'))\n        ['name', 'name_en', 'name_uk', 'desc', 'desc_en', 'desc_uk']\n\n        MyModel.objects.only(*mt_fields('name', 'desc', 'content'))\n\n    If nomaster then master field will not be append.\n    F.e.: ['name_en', 'name_uk'] -- without master 'name'.\n\n    If onlydefaultlang then wiil be search only default language:\n    F.e.: ['name', 'name_en'] -- without additional 'name_uk'.\n\n    If nomaster and onlydefaultlang then will be use both rulses.\n    F.e.: ['name_en'] -- without master 'name' and additional 'name_uk'.\n    \"\"\"\n    assert isinstance(fields, (list, tuple))\n    fl = []\n    for field in fields:\n        if not nomaster:\n            fl.append(field)\n        if onlydefaultlang:\n            fl.append('{}_{}'.format(field, DEFAULT_LANGUAGE))\n        else:\n            for lang in AVAILABLE_LANGUAGES:\n                fl.append('{}_{}'.format(field, lang))\n    return fl"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mt_modelform_field_restore_original_label(field, make_capfirst=False):\n    field.label = field.label._proxy____args[0]._proxy____args[0]\n    if make_capfirst:\n        field.label = capfirst(field.label)", "response": "Restore original label of the field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mt_modelform_register_clean_method(form_self, field_name, func, nomaster=False):\n    args_list = [('{}_{}'.format(field_name, lang), lang) for lang in AVAILABLE_LANGUAGES]\n    if not nomaster:\n        args_list.append((field_name, None))\n\n    def _get_mt_clean_method(args):\n        def _mt_clean_method():\n            return func(*args)\n        return _mt_clean_method\n\n    for item_args in args_list:\n        method_name = 'clean_{}'.format(item_args[0])\n        setattr(form_self, method_name, _get_mt_clean_method(item_args))", "response": "Register a method to be called when a new item is deleted."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_url(self, name: str, **kwargs) -> str:\n        return self.urlmapper.generate(name, **kwargs)", "response": "generate url with urlgenerator used by urldispatch"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfloors a datetime by a resolution.", "response": "def floor(start, resolution):\n    \"\"\"Floor a datetime by a resolution.\n\n    >>> now = datetime(2012, 7, 6, 20, 33, 16, 573225)\n    >>> floor(now, STEP_1_HOUR)\n    datetime.datetime(2012, 7, 6, 20, 0)\n    \"\"\"\n    if resolution == STEP_10_SEC:\n        return datetime(start.year, start.month, start.day, start.hour,\n                        start.minute, start.second - (start.second % 10))\n    elif resolution == STEP_1_MIN:\n        return datetime(start.year, start.month, start.day, start.hour,\n                        start.minute)\n    elif resolution == STEP_5_MIN:\n        return datetime(start.year, start.month, start.day, start.hour,\n                        start.minute - (start.minute % 5))\n    elif resolution == STEP_1_HOUR:\n        return datetime(start.year, start.month, start.day, start.hour)\n    elif resolution == STEP_1_DAY:\n        return datetime(start.year, start.month, start.day)\n\n    raise ValueError(\"{resolution} is not a valid resolution. Valid choices \"\n                     \"are {choices}\".format(resolution=resolution,\n                                            choices=STEP_CHOICES))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert internal string like 1M 3W 4h2s... to seconds.", "response": "def _interval_string_to_seconds(interval_string):\n    \"\"\"Convert internal string like 1M, 1Y3M, 3W to seconds.\n\n    :type interval_string: str\n    :param interval_string: Interval string like 1M, 1W, 1M3W4h2s...\n        (s => seconds, m => minutes, h => hours, D => days,\n         W => weeks, M => months, Y => Years).\n\n    :rtype: int\n    :return: The conversion in seconds of interval_string.\n\n    \"\"\"\n    interval_exc = \"Bad interval format for {0}\".format(interval_string)\n    interval_dict = {\"s\": 1, \"m\": 60, \"h\": 3600, \"D\": 86400,\n                     \"W\": 7*86400, \"M\": 30*86400, \"Y\": 365*86400}\n\n    interval_regex = re.compile(\"^(?P<num>[0-9]+)(?P<ext>[smhDWMY])\")\n    seconds = 0\n\n    while interval_string:\n        match = interval_regex.match(interval_string)\n        if match:\n            num, ext = int(match.group(\"num\")), match.group(\"ext\")\n            if num > 0 and ext in interval_dict:\n                seconds += num * interval_dict[ext]\n                interval_string = interval_string[match.end():]\n            else:\n                raise Exception(interval_exc)\n        else:\n            raise Exception(interval_exc)\n    return seconds"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_dict(self):\n        result = {}\n        stack = collections.deque()\n        stack.append(\n            (\n                result,\n                {_to_camel_case(k): v for k, v in self.__dict__.iteritems()},\n            )\n        )\n        while stack:\n            dest, source = stack.pop()\n            if isinstance(dest, dict):\n                self._process_dict(dest, source, stack)\n            else:\n                self._process_list(dest, source, stack)\n        return result", "response": "Return the schema as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend an ADREST API error mail about the current operation.", "response": "def adrest_errors_mail(response, request):\n    \"\"\" Send a mail about ADRest errors.\n\n    :return bool: status of operation\n\n    \"\"\"\n\n    if not response.status_code in ADREST_MAIL_ERRORS:\n        return False\n\n    subject = 'ADREST API Error (%s): %s' % (\n        response.status_code, request.path)\n    stack_trace = '\\n'.join(traceback.format_exception(*sys.exc_info()))\n    message = \"\"\"\nStacktrace:\n===========\n%s\n\nHandler data:\n=============\n%s\n\nRequest information:\n====================\n%s\n\n\"\"\" % (stack_trace, repr(getattr(request, 'data', None)), repr(request))\n    return mail_admins(subject, message, fail_silently=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of GradCommittee objects.", "response": "def _process_json(data):\n    \"\"\"\n    return a list of GradCommittee objects.\n    \"\"\"\n    requests = []\n    for item in data:\n        committee = GradCommittee()\n        committee.status = item.get('status')\n        committee.committee_type = item.get('committeeType')\n        committee.dept = item.get('dept')\n        committee.degree_title = item.get('degreeTitle')\n        committee.degree_type = item.get('degreeType')\n        committee.major_full_name = item.get('majorFullName')\n        committee.start_date = datetime_from_string(item.get('startDate'))\n        committee.end_date = datetime_from_string(item.get('endDate'))\n        for member in item.get('members'):\n            if member.get('status') == \"inactive\":\n                continue\n\n            com_mem = GradCommitteeMember()\n            com_mem.first_name = member.get('nameFirst')\n            com_mem.last_name = member.get('nameLast')\n\n            if member.get('memberType') is not None and\\\n                    len(member.get('memberType')) > 0:\n                com_mem.member_type = member.get('memberType').lower()\n\n            if member.get('readingType') is not None and\\\n                    len(member.get('readingType')) > 0:\n                com_mem.reading_type = member.get('readingType').lower()\n\n            com_mem.dept = member.get('dept')\n            com_mem.email = member.get('email')\n            com_mem.status = member.get('status')\n            committee.members.append(com_mem)\n\n        requests.append(committee)\n    return requests"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cross_correlate(observed, template_dispersion, template_fluxes,\n    rebin=\"template\", wavelength_range=None, continuum_degree=-1,\n    apodize=0.10, rescale=False, z_limits=None, full_output=False):\n    \"\"\"\n    Cross-correlate the observed spectrum against template fluxes.\n    \"\"\"\n\n    template_fluxes = np.atleast_2d(template_fluxes)\n    template_dispersion = np.array(template_dispersion)\n    if template_dispersion.shape[0] != template_fluxes.shape[1]:\n        raise ValueError(\"template dispersion must have size (N_pixels,) and \"\\\n            \"template fluxes must have size (N_models, N_pixels)\")\n\n    try:\n        continuum_degree = int(continuum_degree)\n    except (TypeError, ValueError):\n        raise TypeError(\"continuum order must be an integer-like object\")\n\n    if not (1 > apodize >= 0):\n        raise ValueError(\"apodize fraction must be between 0 and 1\")\n\n    if rebin.lower() == \"template\":\n        # Put the template fluxes onto the observed dispersion map.\n        dispersion = observed.disp\n        template_flux = template_fluxes \\\n            * resample(template_dispersion, observed.disp)\n        observed_flux = observed.flux.copy()\n        observed_ivar = observed.ivariance.copy()\n\n    elif rebin.lower() == \"observed\":\n        # Put the observed fluxes onto the template dispersion map.\n        dispersion = template_dispersion\n        template_flux = template_fluxes\n        mat = resample(observed.disp, template_dispersion)\n        observed_flux = observed.flux.copy() * mat\n        observed_ivar = observed.ivariance.copy() * mat\n        \n    else:\n        raise ValueError(\"rebin must be either `template` or `observed`\")\n\n    if wavelength_range is not None:\n        if not isinstance(wavelength_range, (tuple, list, np.ndarray)) \\\n        or len(wavelength_range) != 2:\n            raise TypeError(\"wavelength range must be a two length tuple\")\n\n        indices = np.clip(\n            template_dispersion.searchsorted(wavelength_range) + [0, 1],\n            0, template_dispersion.size)\n        template_dispersion = template_dispersion[indices[0]:indices[1]]\n        template_flux = template_flux[indices[0]:indices[1]]\n        observed_flux = observed_flux[indices[0]:indices[1]]\n\n    N_templates = template_fluxes.shape[0]\n\n    # Clip out the non-finite edges, if they exist.\n    _ = np.where(np.isfinite(template_flux[0] * observed_flux))[0]\n    l_idx, u_idx = _[0], _[-1]\n\n    dispersion = dispersion[l_idx:u_idx]\n    observed_flux = observed_flux[l_idx:u_idx]\n    observed_ivar = observed_ivar[l_idx:u_idx]\n    template_flux = template_flux[:, l_idx:u_idx]\n\n    # Ensure an even number of points.\n    N = u_idx - l_idx\n    N = N - 1 if N % 2 > 0 else N\n    dispersion = dispersion[:N]\n    observed_flux = observed_flux[:N]\n    observed_ivar = observed_ivar[:N]\n    template_flux = template_flux[:, :N]\n\n    finite = np.isfinite(observed_flux * observed_ivar) * (observed_flux > 1e-3)\n    \n    # Continuum.\n    if continuum_degree >= 0:\n        coefficients = np.polyfit(dispersion[finite], observed_flux[finite],\n            continuum_degree)\n        observed_flux /= np.polyval(coefficients, dispersion)\n\n    # Interpolate over non-finite pixels.\n    observed_flux[~finite] = np.interp(dispersion[~finite], dispersion[finite],\n        observed_flux[finite], left=1, right=1)\n\n    # Scale the flux level to that the template intensities\n    if rescale:\n        observed_flux = (observed_flux * template_flux.ptp()) \\\n            + template_flux.min()\n\n    # Apodize edges.\n    edge_buffer = apodize * (dispersion[-1] - dispersion[0])\n    low_w_indices = np.nonzero(dispersion < dispersion[0] + edge_buffer)[0]\n    high_w_indices = np.nonzero(dispersion > dispersion[-1] - edge_buffer)[0]\n\n    apod_curve = np.ones(N, dtype='d')\n    apod_curve[low_w_indices] = (1.0 + np.cos(np.pi*(\n        1.0 - (dispersion[low_w_indices] - dispersion[0])/edge_buffer)))/2.\n    apod_curve[high_w_indices] = (1.0 + np.cos(np.pi*(\n        1.0 - (dispersion[-1] - dispersion[high_w_indices])/edge_buffer)))/2.\n\n    apod_observed_flux = observed_flux * apod_curve\n    apod_template_flux = template_flux * apod_curve\n\n    fft_observed_flux = np.fft.fft(apod_observed_flux)\n    fft_template_flux = np.fft.fft(apod_template_flux)\n    template_flux_corr = (fft_observed_flux * fft_template_flux.conjugate())\n    template_flux_corr /= np.sqrt(\n        np.inner(apod_observed_flux, apod_observed_flux))\n\n    z_array = np.array(dispersion.copy())/dispersion[N/2] - 1.0\n\n    z = np.ones(N_templates) * np.nan\n    z_err = np.ones(N_templates) * np.nan\n    R = np.ones(N_templates) * np.nan\n    for i in range(N_templates):\n\n        denominator = np.sqrt(\n            np.inner(apod_template_flux[i, :], apod_template_flux[i, :]))\n        flux_correlation = template_flux_corr[i, :] / denominator \n        correlation = np.fft.ifft(flux_correlation).real\n\n        # Reflect about zero\n        ccf = np.zeros(N)\n        ccf[:N/2] = correlation[N/2:]\n        ccf[N/2:] = correlation[:N/2]\n\n        # Get height and redshift of best peak\n        h = ccf.max()\n\n        # Scale the CCF\n        #ccf -= ccf.min()\n        #ccf *= (h/ccf.max())\n        \n        R[i] = h\n        z[i] = z_array[ccf.argmax()]\n        try:\n            z_err[i] = (np.ptp(z_array[np.where(ccf >= 0.5*h)])/2.35482)**2\n        except ValueError:\n            continue\n\n    # Limits:\n    if z_limits is not None:\n        R[~((z_limits[1] >= z) * (z >= z_limits[0]))] = np.nan\n\n    # Re-measure the velocity at the best peak.\n    index = np.nanargmax(R)\n\n    denominator = np.sqrt(\n        np.inner(apod_template_flux[index, :], apod_template_flux[index, :]))\n\n    flux_correlation = template_flux_corr[index, :] / denominator\n    correlation = np.fft.ifft(flux_correlation).real\n\n    # FReflect about zero.\n    ccf = np.zeros(N)\n    ccf[:N/2] = correlation[N/2:]\n    ccf[N/2:] = correlation[:N/2]\n\n    h = ccf.max()\n    ccf -= ccf.min()\n    ccf *= h/ccf.max()\n\n    # Fit +/- 5 pixels\n    idx = np.argmax(ccf) - 3, np.argmax(ccf) + 3\n\n    coeffs = np.polyfit(z_array[idx[0]:idx[1]], ccf[idx[0]:idx[1]], 2)\n    x_i = np.linspace(z_array[idx[0]], z_array[idx[1]], 1000)\n    y_i = np.polyval(coeffs, x_i)\n\n    # Update the value\n    z[index] = x_i[y_i.argmax()]\n\n    \"\"\"\n    # Fit the profile peak.\n    fwhm = np.ptp(z_array[np.where(ccf >= 0.5)])\n    p0 = np.array([z[index], fwhm/2.355, 1.0]) # mu, sigma, peak.\n    use = (z_array > (p0[0] - 3 * p0[1])) * ((p0[0] + 3*p0[1]) > z_array)\n    x, y = z_array[use], ccf[use]\n\n    # Fit profile:\n    f = lambda x, mu, sigma, peak: peak * np.exp(-(mu - x)**2/(2*sigma**2)) \n    \n    import matplotlib.pyplot as plt\n    plt.plot(z_array, ccf, c='k')\n    plt.plot(x, y, c='b')\n    plt.plot(x, f(x, *p0), c='r')\n\n    p1 = curve_fit(f, x, y, p0=p0)\n    plt.plot(x, f(x, *p1[0]), c='m')\n\n    plt.gca().set_ylim(0,1)\n    raise a\n\n    p1 = curve_fit(f, x, y, p0=p0)\n    \"\"\"\n\n    return (z * c, z_err * c, R)", "response": "Cross - correlate the observed spectrum against the observed spectrum."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flatten(x):\n\n    result = []\n    for el in x:\n        # if isinstance(el, (list, tuple)):\n        if hasattr(el, \"__iter__\") and not isinstance(el, six.string_types):\n            result.extend(flatten(el))\n        else:\n            result.append(el)\n    return list(result)", "response": "Flatten a single - element list into a single - element list containing all elements retrieved\n    from the sequence and all recursively contained sub - sequences\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a humanized string representation of a number of bytes.", "response": "def humanize_bytes(bytes, raw=False, precision=1):\n    \"\"\"Return a humanized string representation of a number of bytes.\n\n    >>> humanize_bytes(1)\n    '1 byte'\n    >>> humanize_bytes(2)\n    '2.0 bytes'\n    >>> humanize_bytes(1024)\n    '1.0 kB'\n    >>> humanize_bytes(1024*123)\n    '123.0 kB'\n    >>> humanize_bytes(1024*12342)\n    '12.1 MB'\n    >>> humanize_bytes(1024*12342, precision=2)\n    '12.05 MB'\n    >>> humanize_bytes(1024*1234, precision=2)\n    '1.21 MB'\n    >>> humanize_bytes(1024*1234*1111, precision=2)\n    '1.31 GB'\n    >>> humanize_bytes(1024*1234*1111)\n    '1.3 GB'\n    >>> humanize_bytes(1024, True)\n    1024\n    \"\"\"\n    if raw:\n        return bytes\n    abbrevs = (\n        (1 << 50, \"PB\"),\n        (1 << 40, \"TB\"),\n        (1 << 30, \"GB\"),\n        (1 << 20, \"MB\"),\n        (1 << 10, \"kB\"),\n        (1, \"bytes\")\n    )\n    if bytes == 1:\n        return \"1 byte\"\n    for factor, suffix in abbrevs:  # pragma: no cover\n        if bytes >= factor:\n            break\n    return \"%.*f %s\" % (precision, bytes / factor, suffix)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting network information from a list of families.", "response": "def get_network(families=[socket.AF_INET]):\n    \"\"\"\n    # >>> from psutil._common import snic\n    >>> import mock\n    >>> from collections import namedtuple\n    >>> snic = namedtuple('snic', ['family', 'address', 'netmask', 'broadcast', 'ptp'])\n    >>> MOCK = {\n    ... \"awdl0\": [snic(family=30, address=\"fe80::3854:80ff:fe54:7bf8%awdl0\", netmask=\"ffff:ffff:ffff:ffff::\", broadcast=None, ptp=None)],\n    ... \"en0\":   [snic(family=2, address=\"192.168.10.200\", netmask=\"255.255.255.0\", broadcast=\"192.168.10.255\", ptp=None),\n    ...           snic(family=30, address=\"fe80::6e40:8ff:feac:4f94%en0\", netmask=\"ffff:ffff:ffff:ffff::\", broadcast=None, ptp=None)],\n    ... \"bridge0\": [snic(family=18, address=\"6e:40:08:ca:60:00\", netmask=None, broadcast=None, ptp=None)],\n    ... \"lo0\": [snic(family=2, address=\"127.0.0.1\", netmask=\"255.0.0.0\", broadcast=None, ptp=None),\n    ...         snic(family=30, address=\"fe80::1%lo0\", netmask=\"ffff:ffff:ffff:ffff::\", broadcast=None, ptp=None)]}\n\n    >>> with mock.patch(\"psutil.net_if_addrs\", side_effect=lambda: MOCK):\n    ...     data_inet = get_network([socket.AF_INET])\n    ...     sorted(data_inet.keys())\n    ['en0', 'lo0']\n\n    >>> with mock.patch(\"psutil.net_if_addrs\", side_effect=lambda: MOCK):\n    ...     sorted(data_inet.values())\n    [[u'127.0.0.1/255.0.0.0'], [u'192.168.10.200/255.255.255.0']]\n\n    >>> with mock.patch(\"psutil.net_if_addrs\", side_effect=lambda: MOCK):\n    ...     data_inet6 = get_network([socket.AF_INET6])\n    ...     sorted(flatten(data_inet6.values()))\n    ['fe80::1%lo0/ffff:ffff:ffff:ffff::', 'fe80::3854:80ff:fe54:7bf8%awdl0/ffff:ffff:ffff:ffff::', 'fe80::6e40:8ff:feac:4f94%en0/ffff:ffff:ffff:ffff::']\n    \"\"\"\n    nic = psutil.net_if_addrs()\n\n    ips = defaultdict(list)\n    # return nic\n    for card, addresses in nic.items():\n        for address in addresses:\n            if address.family in families:\n                ips[card].append(\"{0.address}/{0.netmask}\".format(address))\n    return dict(ips)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_package_version(application_name, app=None):  # noqa\n\n    parts = application_name.split('.')\n    module_name = parts[0]\n    try:\n        return pkg_resources.get_distribution(module_name).version\n    except Exception:\n        pass\n    # if app is None:\n    #     app = __import__(module_name)\n    if hasattr(app, 'get_version'):\n        version = app.get_version\n    elif hasattr(app, '__version__'):\n        version = app.__version__\n    elif hasattr(app, 'VERSION'):\n        version = app.VERSION\n    elif hasattr(app, 'version'):\n        version = app.version\n    else:\n        version = None\n\n    if callable(version):\n        try:\n            version = version()\n        except Exception:\n            return None\n\n    if not isinstance(version, six.string_types + (list, tuple)):\n        version = None\n\n    if version is None:\n        return None\n\n    if isinstance(version, (list, tuple)):\n        version = '.'.join(map(six.text_type, version))\n\n    return six.text_type(version)", "response": "Get the version of the package."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of tuples ordered by similarity.", "response": "def results(self):\n        \"\"\"\n        Returns a list of tuple, ordered by similarity.\n        \"\"\"\n        d = dict()\n        words = [word.strip() for word in self.haystack]\n\n        if not words:\n            raise NoResultException('No similar word found.')\n\n        for w in words:\n            d[w] = Levenshtein.ratio(self.needle, w)\n\n        return sorted(d.items(), key=operator.itemgetter(1), reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_url_request(self):\n        # Check if the ip is LAN or WAN\n        if net.IPAddress(self.ip).is_private():\n            url = \"http://{}\".format(self.ip)\n            self.authentication_type = BboxConstant.AUTHENTICATION_TYPE_LOCAL\n        else:\n            url = \"https://{}:{}\".format(self.ip,\n                                         BboxConstant.DEFAULT_REMOTE_PORT)\n            self.authentication_type = BboxConstant.AUTHENTICATION_TYPE_REMOTE\n\n        if self.api_class is None:\n            url = \"{}/{}\".format(url, self.API_PREFIX)\n        else:\n            url = \"{}/{}/{}\".format(url, self.API_PREFIX, self.api_class)\n\n        if self.api_method is None:\n            self.url = url\n        else:\n            self.url = \"{}/{}\".format(url, self.api_method)", "response": "Builds the url to use for making a call to the Bbox API\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts simple JSON to CSV", "response": "def json_to_csv(json_input):\n    '''\n    Convert simple JSON to CSV\n    Accepts a JSON string or JSON object\n    '''\n    try:\n        json_input = json.loads(json_input)\n    except:\n        pass # If loads fails, it's probably already parsed\n    headers = set()\n    for json_row in json_input:\n        headers.update(json_row.keys())\n\n    csv_io = StringIO.StringIO()\n    csv_out = csv.DictWriter(csv_io,headers)\n    csv_out.writeheader()\n    for json_row in json_input:\n        csv_out.writerow(json_row)\n    csv_io.seek(0)\n    return csv_io.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    parser = argparse.ArgumentParser(description='Do something awesome')\n    parser.add_argument('input_file', nargs=1,\n                        type=argparse.FileType('r'))\n    parser.add_argument('-o', '--outfile', nargs='?',\n                        type=argparse.FileType('w'), default=sys.stdout)\n    args = parser.parse_args()\n\n    print(json_to_csv(args.input_file[0].read()), file=args.outfile)", "response": "This main function implements the CLI"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_tarball(voevents, filepath):\n    tuple_gen = ( (v.ivorn, v.xml) for v in voevents)\n    return write_tarball_from_ivorn_xml_tuples(tuple_gen,\n                                               filepath)", "response": "Write a tarball from a list of Voevent models and xml attributes to a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over a series of ivorn / xml bstring tuples and write to bz'd tarball. Args: ivorn_xml_tuples (iterable): [(ivorn,xml)] An iterable (e.g. list) of tuples containing two entries - an ivorn string and an xml bytestring. filepath (string): Path to the new tarball to create. Typically of form '/path/to/foo.tar.bz2' Returns packet_count (int): Number of packets written to tarball", "response": "def write_tarball_from_ivorn_xml_tuples(ivorn_xml_tuples, filepath):\n    \"\"\"\n    Iterate over a series of ivorn / xml bstring tuples and write to bz'd tarball.\n\n    Args:\n        ivorn_xml_tuples (iterable): [(ivorn,xml)]\n            An iterable (e.g. list) of tuples containing two entries -\n            an ivorn string and an xml bytestring.\n        filepath (string): Path to the new tarball to create. Typically of form\n            '/path/to/foo.tar.bz2'\n    Returns\n        packet_count (int): Number of packets written to tarball\n    \"\"\"\n    out = tarfile.open(filepath, mode='w:bz2')\n    logger.info(\"Writing packets to tarball at \" + filepath)\n    packet_count = 0\n    try:\n        for (ivorn, xml) in ivorn_xml_tuples:\n            out.addfile(*bytestring_to_tar_tuple(\n                filename_from_ivorn(ivorn),\n                xml\n            ))\n            packet_count += 1\n    finally:\n        out.close()\n    return packet_count"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_email_forwarding(netid):\n    subscriptions = get_netid_subscriptions(netid, Subscription.SUBS_CODE_U_FORWARDING)\n    for subscription in subscriptions:\n        if subscription.subscription_code == Subscription.SUBS_CODE_U_FORWARDING:\n            return_obj = UwEmailForwarding()\n            if subscription.data_value:\n                return_obj.fwd = subscription.data_value\n            return_obj.permitted = subscription.permitted\n            return_obj.status = subscription.status_name\n            return return_obj\n\n    return None", "response": "Returns a restclients. models. uwnetid. UwEmailForwarding object on the given uwnetid"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the subscription for the given netid and subscription_code", "response": "def update_subscription(netid, action, subscription_code, data_field=None):\n    \"\"\"\n    Post a subscription action for the given netid and subscription_code\n    \"\"\"\n    url = '/nws/v1/subscription.json'\n    action = {\n        'uwNetID': netid,\n        'action': action,\n        'subscriptionCode': str(subscription_code)\n    }\n\n    if isinstance(data_field, tuple) and len(data_field) == 2:\n        action[data_field[0]] = str(data_field[1])\n\n    body = {'actionList': [action]}\n    response = post_resource(url, json.dumps(body))\n    return _json_to_subscriptions(response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n\n        projects = orm['samples.Project'].objects.exclude(name=DEFAULT_PROJECT_NAME)\n        for project in projects:\n            cohort = orm['samples.Cohort'](name=project.label, autocreated=True)\n            cohort.project = project\n            cohort.save()\n            cohort_bulk_add(orm, cohort, orm['samples.Sample'].objects.filter(project=project).distinct())\n\n        batches = orm['samples.Batch'].objects.select_related('project')\n        for batch in batches:\n            cohort = orm['samples.Cohort'](name=batch.label, autocreated=True)\n            cohort.project = batch.project\n            cohort.save()\n            cohort_bulk_add(orm, cohort, orm['samples.Sample'].objects.filter(batch=batch).distinct())\n\n        # Populate the default cohort with all samples\n        default_cohort = orm['samples.Cohort'].objects.get(name=DEFAULT_COHORT_NAME)\n        cohort_bulk_add(orm, default_cohort, orm['samples.Sample'].objects.all())", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting your backwards methods here.", "response": "def backwards(self, orm):\n        \"Write your backwards methods here.\"\n        orm['samples.CohortSample'].objects.all().delete()\n        orm['samples.Cohort'].objects.exclude(name=DEFAULT_COHORT_NAME).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef import_locations(self, marker_file):\n        self._marker_file = marker_file\n        data = utils.prepare_read(marker_file)\n\n        for line in data:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            chunk = line.split('#')\n            data = chunk[0]\n            comment = chunk[1].strip() if len(chunk) == 2 else None\n            # Need maximum split of 2, because name may contain whitespace\n            latitude, longitude, name = data.split(None, 2)\n            name = name.strip()\n            # Find matching start and end quote, and keep only the contents\n            name = name[1:name.find(name[0], 1)]\n            self[name.strip()] = Xearth(latitude, longitude, comment)", "response": "Parse the locations of the named locations in the xearth marker file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, uri, params={}):\n        '''A generic method to make GET requests'''\n        logging.debug(\"Requesting URL: \"+str(urlparse.urljoin(self.BASE_URL, uri)))\n        return requests.get(urlparse.urljoin(self.BASE_URL, uri),\n            params=params, verify=False,\n            auth=self.auth)", "response": "A generic method to make GET requests"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_tuple(obj):\n    \" Given obj return a tuple \"\n\n    if not obj:\n        return tuple()\n\n    if isinstance(obj, (tuple, set, list)):\n        return tuple(obj)\n\n    if hasattr(obj, '__iter__') and not isinstance(obj, dict):\n        return obj\n\n    return obj,", "response": "Given obj return a tuple"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gen_url_regex(resource):\n    \" URL regex for resource class generator. \"\n\n    if resource._meta.parent:\n        yield resource._meta.parent._meta.url_regex.rstrip('/$').lstrip('^')\n\n    for p in resource._meta.url_params:\n        yield '%(name)s/(?P<%(name)s>[^/]+)' % dict(name=p)\n\n    if resource._meta.prefix:\n        yield resource._meta.prefix\n\n    yield '%(name)s/(?P<%(name)s>[^/]+)?' % dict(name=resource._meta.name)", "response": "URL regex for resource class generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef postURL(self, url, headers, body):\n        new_url = url\n        if body is not None:\n            new_url = FileSea.convert_body(url, body)\n        return self.getURL(new_url, headers)", "response": "Implement a post using a get call"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the body of a resource into a URL query string", "response": "def convert_body(url, body):\n        \"\"\"\n        :return: the url string with extra data in the body\n        Extract the data in the body and convert to URL query string\n        \"\"\"\n        new_url = \"%s.Post\" % url\n        params = json.loads(body)\n        for key in params:\n            new_url = \"%s&%s=%s\" % (new_url, key,\n                                    re.sub(' ', '%20',\n                                           str(params[key])))\n        return new_url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a decrypted field proxy to the model.", "response": "def contribute_to_class(self, cls, name, **kwargs):\n        \"\"\"\n        Add a decrypted field proxy to the model.\n\n        Add to the field model an `EncryptedProxyField` to get the decrypted\n        values of the field.\n\n        The decrypted value can be accessed using the field's name attribute on\n        the model instance.\n        \"\"\"\n        super(PGPMixin, self).contribute_to_class(cls, name, **kwargs)\n        setattr(cls, self.name, self.descriptor_class(field=self))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _exec_appcommand_post(self, command, param):\n        xml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <harman>\n            <avr>\n                <common>\n                    <control>\n                        <name>\"\"\" + command + \"\"\"</name>\n                        <zone>\"\"\" + self._zone + \"\"\"</zone>\n                        <para>\"\"\" + param + \"\"\"</para>\n                    </control>\n                </common>\n            </avr>\n        </harman>\"\"\"\n        command = \"\"\"POST AVR HTTP/1.1\\r\\nHost: :\"\"\" + str(self._port) \\\n                  + \"\"\"\\r\\nUser-Agent: Harman Kardon AVR Remote \"\"\"\\\n                  + \"\"\"Controller /2.0\"\"\" \\\n                  + \"\"\"\\r\\nContent-Length: \"\"\" + str(xml.__len__()) \\\n                  + \"\"\"\\r\\n\\r\\n\"\"\" + xml\n\n        if self._socket is None:\n            self._socket = self._get_new_socket()\n        if self._socket is None:\n            _LOGGER.warning(\"Cannot connect to AVR\")\n            return\n        try:\n            resp = self._socket.sendto(command.encode(),\n                                       (self._host, self._port))\n            if resp == 0:\n                self._socket.close()\n                self._socket = None\n                _LOGGER.warning(\"Send fail, disconnecting from AVR\")\n        except (BrokenPipeError, ConnectionError) as connect_error:\n            _LOGGER.warning(\"Connection error, retrying. %s\", connect_error)\n            self._socket = None\n            self._socket = self._get_new_socket()\n            if self._socket is not None:\n                # retrying after broken pipe error\n                self._socket.sendto(command.encode(), (self._host, self._port))", "response": "Execute an appcommand post to AVR."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef power_on(self):\n        try:\n            self.send_command(\"POWER_ON\")\n            self._power = POWER_ON\n            self._state = STATE_ON\n            return True\n        except requests.exceptions.RequestException:\n            _LOGGER.error(\"Connection error: power on command not sent.\")\n            return False", "response": "Turn on receiver via command."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sleep(self):\n        try:\n            self.send_command(\"SLEEP\")\n            return True\n        except requests.exceptions.RequestException:\n            _LOGGER.error(\"Connection error: sleep command not sent.\")\n            return False", "response": "Send a SLEEP command to get the current time."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_position(self, dt):\n        return self.sx + self.dx * dt, self.sy + self.dy * dt", "response": "Given dt in [ 0 1 ) return the current position of the tile."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an icon to use for the game.", "response": "def icon(cls, size):\n        \"\"\"Returns an icon to use for the game.\"\"\"\n        tile = pygame.Surface((size, size))\n        tile.fill((237, 194, 46))\n        label = load_font(cls.BOLD_NAME, int(size / 3.2)).render(cls.NAME, True, (249, 246, 242))\n        width, height = label.get_size()\n        tile.blit(label, ((size - width) / 2, (size - height) / 2))\n        return tile"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender a tile according to its value and background and foreground colours.", "response": "def _make_tile(self, value, background, text):\n        \"\"\"Renders a tile, according to its value, and background and foreground colours.\"\"\"\n        tile = pygame.Surface((self.cell_width, self.cell_height), pygame.SRCALPHA)\n        pygame.draw.rect(tile, background, (0, 0, self.cell_width, self.cell_height))\n        # The \"zero\" tile doesn't have anything inside.\n        if value:\n            label = load_font(self.BOLD_NAME, 50 if value < 1000 else\n                              (40 if value < 10000 else 30)).render(str(value), True, text)\n            width, height = label.get_size()\n            tile.blit(label, ((self.cell_width - width) / 2, (self.cell_height - height) / 2))\n        return tile"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating all default tiles as defined above.", "response": "def _create_default_tiles(self):\n        \"\"\"Create all default tiles, as defined above.\"\"\"\n        for value, background, text in self.DEFAULT_TILES:\n            self.tiles[value] = self._make_tile(value, background, text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws a button on the won and lost overlays and return its hitbox.", "response": "def _draw_button(self, overlay, text, location):\n        \"\"\"Draws a button on the won and lost overlays, and return its hitbox.\"\"\"\n        label = self.button_font.render(text, True, (119, 110, 101))\n        w, h = label.get_size()\n        # Let the callback calculate the location based on\n        # the width and height of the text.\n        x, y = location(w, h)\n        # Draw a box with some border space.\n        pygame.draw.rect(overlay, (238, 228, 218), (x - 5, y - 5, w + 10, h + 10))\n        overlay.blit(label, (x, y))\n        # Convert hitbox from surface coordinates to screen coordinates.\n        x += self.origin[0] - 5\n        y += self.origin[1] - 5\n        # Return the hitbox.\n        return x - 5, y - 5, x + w + 10, y + h + 10"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_in_keep_going(self, x, y):\n        x1, y1, x2, y2 = self._keep_going\n        return self.won == 1 and x1 <= x < x2 and y1 <= y < y2", "response": "Checks if the mouse is in the keep going button and if the won overlay is shown."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_in_try_again(self, x, y):\n        if self.won == 1:\n            # Checks if in try button on won screen.\n            x1, y1, x2, y2 = self._won_try_again\n            return x1 <= x < x2 and y1 <= y < y2\n        elif self.lost:\n            # Checks if in try button on lost screen.\n            x1, y1, x2, y2 = self._lost_try_again\n            return x1 <= x < x2 and y1 <= y < y2\n        # Otherwise just no.\n        return False", "response": "Checks if the game is to be restarted."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the game is to be restarted by request.", "response": "def _is_in_restart(self, x, y):\n        \"\"\"Checks if the game is to be restarted by request.\"\"\"\n        x1, y1, x2, y2 = self._new_game\n        return x1 <= x < x2 and y1 <= y < y2"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _make_title(self):\n        # Draw the game title.\n        title = pygame.Surface((self.game_width, self.origin[1]), pygame.SRCALPHA)\n        title.fill((0, 0, 0, 0))\n        label = self.font.render(self.NAME, True, (119, 110, 101))\n        title.blit(label, (self.BORDER, (90 - label.get_height()) / 2))\n        # Draw the label for the objective.\n        label = load_font(self.FONT_NAME, 18).render(\n            'Join the numbers and get to the %d tile!' % self.WIN_TILE, True, (119, 110, 101))\n        title.blit(label, (self.BORDER, self.origin[1] - label.get_height() - self.BORDER))\n\n        # Draw the new game button and calculate its hitbox.\n        x1, y1 = self.WIDTH - self.BORDER - 100, self.origin[1] - self.BORDER - 28\n        w, h = 100, 30\n        pygame.draw.rect(title, (238, 228, 218), (x1, y1, w, h))\n        label = load_font(self.FONT_NAME, 18).render('New Game', True, (119, 110, 101))\n        w1, h1 = label.get_size()\n        title.blit(label, (x1 + (w - w1) / 2, y1 + (h - h1) / 2))\n\n        # Return the title section and its hitbox.\n        return title, (x1, y1, x1 + w, y1 + h)", "response": "Draw the header section and the game title."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of empty cells.", "response": "def free_cells(self):\n        \"\"\"Returns a list of empty cells.\"\"\"\n        return [(x, y)\n                for x in range(self.COUNT_X)\n                for y in range(self.COUNT_Y)\n                if not self.grid[y][x]]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a cell can be merged", "response": "def _can_cell_be_merged(self, x, y):\n        \"\"\"Checks if a cell can be merged, when the \"\"\"\n        value = self.grid[y][x]\n        if y > 0 and self.grid[y - 1][x] == value:  # Cell above\n            return True\n        if y < self.COUNT_Y - 1 and self.grid[y + 1][x] == value:  # Cell below\n            return True\n        if x > 0 and self.grid[y][x - 1] == value:  # Left\n            return True\n        if x < self.COUNT_X - 1 and self.grid[y][x + 1] == value:  # Right\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning whether a move is possible when there are no free cells.", "response": "def has_free_moves(self):\n        \"\"\"Returns whether a move is possible, when there are no free cells.\"\"\"\n        return any(self._can_cell_be_merged(x, y)\n                   for x in range(self.COUNT_X)\n                   for y in range(self.COUNT_Y))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tile_location(self, x, y):\n        x1, y1 = self.origin\n        x1 += self.BORDER + (self.BORDER + self.cell_width) * x\n        y1 += self.BORDER + (self.BORDER + self.cell_height) * y\n        return x1, y1", "response": "Get the screen coordinate for the top - left corner of a tile."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_grid(self):\n        self.screen.fill((0xbb, 0xad, 0xa0), self.origin + (self.game_width, self.game_height))\n        for y, row in enumerate(self.grid):\n            for x, cell in enumerate(row):\n                self.screen.blit(self.tiles[cell], self.get_tile_location(x, y))", "response": "Draws the grid and tiles."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw a score box.", "response": "def _draw_score_box(self, label, score, position, size):\n        x1, y1 = position\n        width, height = size\n\n        \"\"\"Draw a score box, whether current or best.\"\"\"\n        pygame.draw.rect(self.screen, (187, 173, 160), (x1, y1, width, height))\n        w, h = label.get_size()\n        self.screen.blit(label, (x1 + (width - w) / 2, y1 + 8))\n        score = self.score_font.render(str(score), True, (255, 255, 255))\n        w, h = score.get_size()\n        self.screen.blit(score, (x1 + (width - w) / 2, y1 + (height + label.get_height() - h) / 2))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndraw the current and best score for the current log entry.", "response": "def draw_scores(self):\n        \"\"\"Draw the current and best score\"\"\"\n        x1, y1 = self.WIDTH - self.BORDER - 200 - 2 * self.BORDER, self.BORDER\n        width, height = 100, 60\n        self.screen.fill((255, 255, 255), (x1, 0, self.WIDTH - x1, height + y1))\n        self._draw_score_box(self.score_label, self.score, (x1, y1), (width, height))\n        x2 = x1 + width + self.BORDER\n        self._draw_score_box(self.best_label, self.manager.score, (x2, y1), (width, height))\n        return (x1, y1), (x2, y1), width, height"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _scale_tile(self, value, width, height):\n        try:\n            return self._scale_cache[value, width, height]\n        except KeyError:\n            tile = pygame.transform.smoothscale(self.tiles[value], (width, height))\n            self._scale_cache[value, width, height] = tile\n            return tile", "response": "Return the prescaled tile if already exists otherwise scale and store it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the center of a tile given the top - left corner and the size of the image.", "response": "def _center_tile(self, position, size):\n        x, y = position\n        w, h = size\n        \"\"\"Calculate the centre of a tile given the top-left corner and the size of the image.\"\"\"\n        return x + (self.cell_width - w) / 2, y + (self.cell_height - h) / 2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _spawn_new(self, count=1):\n        free = self.free_cells()\n        for x, y in random.sample(free, min(count, len(free))):\n            self.grid[y][x] = random.randint(0, 10) and 2 or 4", "response": "Spawn some new tiles."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _shift_cells(self, get_cells, get_deltas):\n        # Don't do anything when there is an overlay.\n        if self.lost or self.won == 1:\n            return\n\n        # A dictionary to store the movement of tiles, and new values if it merges.\n        tile_moved = {}\n        for y, row in enumerate(self.grid):\n            for x, cell in enumerate(row):\n                if cell:\n                    tile_moved[x, y] = (None, None)\n\n        # Store the old grid and score.\n        old_grid = [row[:] for row in self.grid]\n        old_score = self.score\n        self.old.append((old_grid, self.score))\n        if len(self.old) > 10:\n            self.old.pop(0)\n\n        moved = 0\n        for row, column in get_cells():\n            for dr, dc in get_deltas(row, column):\n                # If the current tile is blank, but the candidate has value:\n                if not self.grid[row][column] and self.grid[dr][dc]:\n                    # Move the candidate to the current tile.\n                    self.grid[row][column], self.grid[dr][dc] = self.grid[dr][dc], 0\n                    moved += 1\n                    tile_moved[dc, dr] = (column, row), None\n                if self.grid[dr][dc]:\n                    # If the candidate can merge with the current tile:\n                    if self.grid[row][column] == self.grid[dr][dc]:\n                        self.grid[row][column] *= 2\n                        self.grid[dr][dc] = 0\n                        self.score += self.grid[row][column]\n                        self.won += self.grid[row][column] == self.WIN_TILE\n                        tile_moved[dc, dr] = (column, row), self.grid[row][column]\n                        moved += 1\n                    # When hitting a tile we stop trying.\n                    break\n\n        # Submit the high score and get the change.\n        delta = self.manager.got_score(self.score)\n        free = self.free_cells()\n        new_tiles = set()\n\n        if moved:\n            # Spawn new tiles if there are holes.\n            if free:\n                x, y = random.choice(free)\n                value = self.grid[y][x] = random.randint(0, 10) and 2 or 4\n                new_tiles.add((x, y, value))\n            animation = []\n            static = {}\n            # Check all tiles and potential movement:\n            for (x, y), (new, value) in tile_moved.items():\n                # If not moved, store as static.\n                if new is None:\n                    static[x, y] = old_grid[y][x]\n                else:\n                    # Store the moving tile.\n                    animation.append(AnimatedTile(self, (x, y), new, old_grid[y][x]))\n                    if value is not None:\n                        new_tiles.add(new + (value,))\n            self.animate(animation, static, self.score - old_score, delta, new_tiles)\n        else:\n            self.old.pop()\n\n        if not self.has_free_cells() and not self.has_free_moves():\n            self.lost = True", "response": "Shifts cells in the grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pattern_to_regex(pattern: str) -> str:\n    if pattern and pattern[-1] == \"*\":\n        pattern = pattern[:-1]\n        end = \"\"\n    else:\n        end = \"$\"\n    for metac in META_CHARS:\n        pattern = pattern.replace(metac, \"\\\\\" + metac)\n\n    return \"^\" + VARS_PT.sub(regex_replacer, pattern) + end", "response": "convert url patten to regex"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetect pairs of varname and converter from pattern", "response": "def detect_converters(pattern: str,\n                      converter_dict: Dict[str, Callable],\n                      default: Callable = str):\n    \"\"\" detect pairs of varname and converter from pattern\"\"\"\n    converters = {}\n    for matched in VARS_PT.finditer(pattern):\n        matchdict = matched.groupdict()\n        varname = matchdict['varname']\n        converter = matchdict['converter']\n        converters[varname] = converter_dict.get(converter, default)\n    return converters"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates new named args updating current name args", "response": "def new_named_args(self, cur_named_args: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\" create new named args updating current name args\"\"\"\n        named_args = cur_named_args.copy()\n        named_args.update(self.matchdict)\n        return named_args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_path_info(self, path_info: str) -> Tuple[str, str]:\n        return path_info[:self.matchlength], path_info[self.matchlength:]", "response": "split path_info to new script_name and new path_info"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef match(self, path_info: str) -> MatchResult:\n        matched = self.regex.match(path_info)\n        if matched is None:\n            return None\n        matchlength = len(matched.group(0))\n        matchdict = matched.groupdict()\n\n        try:\n            matchdict = self.convert_values(matchdict)\n        except ValueError:\n            return None\n\n        return MatchResult(matchdict,\n                           matchlength)", "response": "parse path_info and detect urlvars of url pattern return MatchResult"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting values of matchdict to object with converter this object has.", "response": "def convert_values(self, matchdict: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\" convert values of ``matchdict``\n        with converter this object has.\"\"\"\n\n        converted = {}\n        for varname, value in matchdict.items():\n            converter = self.converters[varname]\n            converted[varname] = converter(value)\n        return converted"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef substitute(self, values: Dict[str, Any]) -> str:\n        return self.template.substitute(values)", "response": "generate url with url template"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        # Note: Remember to use orm['appname.ModelName'] rather than \"from appname.models...\"\n        for c in orm[\"contenttypes.contenttype\"].objects.all():\n            if c.app_label == \"DublinCore\":\n                c.app_label = \"dublincore\"\n                c.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef backwards(self, orm):\n        \"Write your backwards methods here.\"\n        for c in orm[\"contenttypes.contenttype\"].objects.all():\n            if c.app_label == \"dublincore\":\n                c.app_label = \"DublinCore\"\n                c.save()", "response": "Write your backwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge two sets of attributes.", "response": "def merge(cls, first, second):\n        \"\"\"\n        Return an AttributeList that is the result of merging first with second.\n        \"\"\"\n        merged = AttributeList([], None)\n\n        assert (isinstance(first, AttributeList))\n        assert (isinstance(second, AttributeList))\n        merged._contents = first._contents[:]\n        merged._contents += second._contents[:]\n\n        return merged"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the attribute that matches the reference. Raise an error if there is more than one match.", "response": "def get_attribute(self, reference):\n        \"\"\"\n        Return the attribute that matches the reference. Raise an error if\n        the attribute cannot be found, or if there is more then one match.\n        \"\"\"\n        prefix, _, name = reference.rpartition('.')\n\n        match = None\n        for attribute in self._contents:\n            if name == attribute.name and \\\n                    (not prefix or prefix == attribute.prefix):\n                if match:\n                    raise AttributeReferenceError(\n                        'Ambiguous attribute reference: {}.'.format(\n                            attribute.name))\n                else:\n                    match = attribute\n\n        if match:\n            return match\n        raise AttributeReferenceError(\n            'Attribute does not exist: {}'.format(reference))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend(self, attributes, prefix):\n\n        self._contents += [Attribute(attr, prefix) for attr in attributes]", "response": "Extend the list of attributes with the specified prefix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef trim(self, restriction_list):\n        replacement = []\n        for reference in restriction_list:\n            replacement.append(self.get_attribute(reference))\n\n        if self.has_duplicates(replacement):\n            raise AttributeReferenceError('Duplicate attribute reference.')\n        self._contents = replacement", "response": "Trim and reorder the attributes to the specifications in a restriction_list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrenaming the Attributes names and prefixes or both.", "response": "def rename(self, names, prefix):\n        \"\"\"\n        Rename the Attributes' names, prefixes, or both. If names or prefix\n        evaluates to None, the old version is used.\n        Resulting names must be unambiguous.\n        :param names: A list of new names for each attribute or an empty list.\n        :param prefix: A new prefix for the name or None\n        \"\"\"\n        if names:\n            if len(names) != len(self._contents):\n                raise InputError('Attribute count mismatch.')\n            if self.has_duplicates(names):\n                raise InputError('Attributes are ambiguous.')\n        else:\n            # If the attributes are not renamed, but the relation / prefix is,\n            # there is a risk of creating two or more attributes with the\n            # same name and prefix.\n            if prefix and self.has_duplicates(self.names):\n                raise AttributeReferenceError('Attributes are ambiguous.')\n\n        replacement = []\n        for old, name in itertools.zip_longest(self._contents, names):\n            new_name = name or old.name\n            new_prefix = prefix or old.prefix\n            replacement.append(Attribute(new_name, new_prefix))\n        self._contents = replacement"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps the dispatch method to add session support.", "response": "def dispatch(self):\n    \"\"\"Wraps the dispatch method to add session support.\"\"\"\n    try:\n      webapp2.RequestHandler.dispatch(self)\n    finally:\n      self.session_store.save_sessions(self.response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_app(self, name: str, app: Callable = None) -> Callable:\n        if app is None:\n            def dec(app):\n                \"\"\" inner decorator for register app \"\"\"\n                assert app is not None\n                self.register_app(name, app)\n                return app\n            return dec\n        self.applications[name] = app\n        return None", "response": "register dispatchable wsgi application"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when view is not found", "response": "def on_view_not_found(\n            self,\n            environ: Dict[str, Any],\n            start_response: Callable) -> Iterable[bytes]:  # pragma: nocover\n        \"\"\" called when view is not found\"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_definition(self, definition):\n        type = definition[0]\n        alias = None\n        attributes = {}\n        for part in definition[1:]:\n            if '=' in part:\n                key, value = part.split('=', 1)\n                attributes[key] = set(value.split(','))\n            elif alias is None:\n                alias = part\n            else:\n                raise ValueError('entity name already defined: {}'.format(part))\n        return type, alias, attributes", "response": "Parse the basic structure of both provided and requested entities\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef receive_oaiharvest_job(request, records, name, **kwargs):\n    spider = kwargs.get('spider')\n    workflow = kwargs.get('workflow')\n    if not spider or not workflow:\n        return\n\n    files_created, _ = write_to_dir(\n        records,\n        output_dir=current_app.config['CRAWLER_OAIHARVEST_OUTPUT_DIRECTORY']\n    )\n\n    for source_file in files_created:\n        # URI is required by scrapy.\n        file_uri = pathlib2.Path(source_file).as_uri()\n        schedule_crawl(spider, workflow, source_file=file_uri)", "response": "Receive a list of harvested OAI - PMH records and schedule crawls."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parent(self):\n        if not self._meta.parent:\n            return None\n\n        if not self.__parent__:\n            self.__parent__ = self._meta.parent()\n\n        return self.__parent__", "response": "Cache a instance of self. Meta. parent class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_database_size(db_user, db_name, localhost=False):\n    localhost_part = ''\n    if localhost:\n        localhost_part = '-h localhost '\n    cmd = 'psql {0}-U {1} -c \"select pg_database_size(\\'{2}\\');\"'.format(\n        localhost_part, db_user, db_name)\n    total = getoutput(cmd).split()[2]\n    return int(total)", "response": "Returns the total size for the given database role and name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef people_per_project(self, project_id, company_id):\n        path = '/projects/%u/contacts/people/%u' % (project_id, company_id)\n        return self._request(path)", "response": "This will return all of the people in the given company that can be accessed by the given project."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef message(self, message_ids):\n        if isinstance(message_ids, list):\n            message_ids = ','.join([int(id) for id in message_ids])\n        path = '/msg/get/%s' % message_ids\n        return self._request(path)", "response": "This will return information about the specified messages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef message_archive(self, project_id, category_id=None):\n        path = '/projects/%u/msg/archive' % project_id\n        req = ET.Element('request')\n        ET.SubElement(req, 'project-id').text = str(int(project_id))\n        if category_id is not None:\n            ET.SubElement(req, 'category-id').text = str(int(category_id))\n        return self._request(path, req)", "response": "This will return a summary record for each message in a project. If category_id is not None the summary record for each message in that category will be returned."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new message in the specified category.", "response": "def create_message(self, project_id, category_id, title, body,\n        extended_body, use_textile=False, private=False, notify=None,\n        attachments=None):\n        \"\"\"\n        Creates a new message, optionally sending notifications to a selected\n        list of people. Note that you can also upload files using this\n        function, but you need to upload the files first and then attach them.\n        See the description at the top of this document for more information.\n        \"\"\"\n        path = '/projects/%u/msg/create' % project_id\n        req = ET.Element('request')\n        req.append(self._create_message_post_elem(category_id, title, body,\n            extended_body, use_textile=False, private=False))\n        if notify is not None:\n            for person_id in notify:\n                ET.SubElement(req, 'notify').text = str(int(person_id))\n        # TODO: Implement attachments.\n        if attachments is not None:\n            raise NotSupportedErr('Attachments are currently not implemented.')\n        ##for attachment in attachments:\n        ##    attms = ET.SubElement(req, 'attachments')\n        ##    if attachment['name']:\n        ##        ET.SubElement(attms, 'name').text = str(attachment['name'])\n        ##    file_ = ET.SubElement(attms, 'file')\n        ##    ET.SubElement(file_, 'file').text = str(attachment['temp_id'])\n        ##    ET.SubElement(file_, 'content-type').text \\\n        ##        = str(attachment['content_type'])\n        ##    ET.SubElement(file_, 'original-filename').text \\\n        ##        = str(attachment['original_filename'])\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an existing message with the given id.", "response": "def update_message(self, message_id, category_id, title, body,\n        extended_body, use_textile=False, private=False, notify=None):\n        \"\"\"\n        Updates an existing message, optionally sending notifications to a\n        selected list of people. Note that you can also upload files using\n        this function, but you have to format the request as\n        multipart/form-data. (See the ruby Basecamp API wrapper for an example\n        of how to do this.)\n        \"\"\"\n        path = '/msg/update/%u' % message_id\n        req = ET.Element('request')\n        req.append(self._create_message_post_elem(category_id, title, body,\n            extended_body, use_textile=False, private=False))\n        if notify is not None:\n            for person_id in notify:\n                ET.SubElement(req, 'notify').text = str(int(person_id))\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef comments(self, message_id):\n        path = '/msg/comments/%u' % message_id\n        req = ET.Element('request')\n        return self._request(path, req)", "response": "Return the list of comments associated with the specified message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_comment(self, post_id, body):\n        path = '/msg/create_comment'\n        req = ET.Element('request')\n        comment = ET.SubElement(req, 'comment')\n        ET.SubElement(comment, 'post-id').text = str(int(post_id))\n        ET.SubElement(comment, 'body').text = str(body)\n        return self._request(path, req)", "response": "Create a new comment for a specific post."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating a specific comment.", "response": "def update_comment(self, comment_id, body):\n        \"\"\"\n        Update a specific comment. This can be used to edit the content of an\n        existing comment.\n        \"\"\"\n        path = '/msg/update_comment'\n        req = ET.Element('request')\n        ET.SubElement(req, 'comment_id').text = str(int(comment_id))\n        comment = ET.SubElement(req, 'comment')\n        ET.SubElement(comment, 'body').text = str(body)\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef todo_lists(self, project_id, complete=None):\n        path = '/projects/%u/todos/lists' % project_id\n        req = ET.Element('request')\n        if complete is not None:\n            ET.SubElement(req, 'complete').text = str(bool(complete)).lower()\n        return self._request(path, req)", "response": "This will return the metadata for all of the lists in a given project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_todo_list(self, list_id, name, description, milestone_id=None,\n        private=None, tracked=None):\n        \"\"\"\n        With this call you can alter the metadata for a list.\n        \"\"\"\n        path = '/todos/update_list/%u' % list_id\n        req = ET.Element('request')\n        list_ = ET.SubElement('list')\n        ET.SubElement(list_, 'name').text = str(name)\n        ET.SubElement(list_, 'description').text = str(description)\n        if milestone_id is not None:\n            ET.SubElement(list_, 'milestone_id').text = str(int(milestone_id))\n        if private is not None:\n            ET.SubElement(list_, 'private').text = str(bool(private)).lower()\n        if tracked is not None:\n            ET.SubElement(list_, 'tracked').text = str(bool(tracked)).lower()\n        return self._request(path, req)", "response": "This method updates the metadata for a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves a todo list to another todo list.", "response": "def move_todo_list(self, list_id, to):\n        \"\"\"\n        This allows you to reposition a list relative to the other lists in\n        the project. A list with position 1 will show up at the top of the\n        page. Moving lists around lets you prioritize. Moving a list to a\n        position less than 1, or more than the number of lists in a project,\n        will force the position to be between 1 and the number of lists\n        (inclusive).\n        \"\"\"\n        path = '/todos/move_list/%u' % list_id\n        req = ET.Element('request')\n        ET.SubElement(req, 'to').text = str(int(to))\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_todo_item(self, list_id, content, party_id=None, notify=False):\n        path = '/todos/create_item/%u' % list_id\n        req = ET.Element('request')\n        ET.SubElement(req, 'content').text = str(content)\n        if party_id is not None:\n            ET.SubElement(req, 'responsible-party').text = str(party_id)\n            ET.SubElement(req, 'notify').text = str(bool(notify)).lower()\n        return self._request(path, req)", "response": "This method lets you add an item to an existing list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_todo_item(self, item_id, content, party_id=None, notify=False):\n        path = '/todos/update_item/%u' % item_id\n        req = ET.Element('request')\n        item = ET.Element('request')\n        ET.SubElement(item, 'content').text = str(content)\n        if party_id is not None:\n            ET.SubElement(req, 'responsible-party').text = str(party_id)\n            ET.SubElement(req, 'notify').text = str(bool(notify)).lower()\n        return self._request(path, req)", "response": "Update an existing item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_todo_item(self, item_id, to):\n        path = '/todos/move_item/%u' % item_id\n        req = ET.Element('request')\n        ET.SubElement(req, 'to').text = str(int(to))\n        return self._request(path, req)", "response": "Moves an item from one level to another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new milestone.", "response": "def create_milestone(self, project_id, title, deadline, party_id, notify):\n        \"\"\"\n        Creates a single milestone. To create multiple milestones in a single\n        call, see the \"create (batch)\" function. To make a company responsible\n        for the milestone, prefix the company id with a \"c\".\n        \"\"\"\n        path = '/projects/%u/milestones/create' % project_id\n        req = ET.Element('request')\n        req.append(\n            self._create_milestone_elem(title, deadline, party_id, notify))\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating a single milestone.", "response": "def update_milestone(self, milestone_id, title, deadline, party_id, notify,\n        move_upcoming_milestones=None,\n        move_upcoming_milestones_off_weekends=None):\n        \"\"\"\n        Modifies a single milestone. You can use this to shift the deadline of\n        a single milestone, and optionally shift the deadlines of subsequent\n        milestones as well.\n        \"\"\"\n        path = '/milestones/update/%u' % milestone_id\n        req = ET.Element('request')\n        req.append(\n            self._create_milestone_elem(title, deadline, party_id, notify))\n        if move_upcoming_milestones is not None:\n            ET.SubElement(req, 'move-upcoming-milestones').text \\\n                = str(bool()).lower()\n        if move_upcoming_milestones_off_weekends is not None:\n            ET.SubElement(req, 'move-upcoming-milestones-off-weekends').text \\\n                = str(bool()).lower()\n        return self._request(path, req)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclassify the tweet into one of three classes based on the sentiment value of the tweet and the thresholds specified in the classifier_options.", "response": "def classify(self, tweet):\n        \"\"\"\n        Classifies the tweet into one of three classes (negative, neutral or positive) depending on the sentiment value\n        of the tweet and the thresholds specified in the classifier_options\n\n        :param tweet: String tweet to classify\n        :return: Sentiment classification (negative, neutral or positive)\n        \"\"\"\n        sentiment_value = self.calculate_sentiment(tweet)\n\n        return Classification.classify_from_thresholds(sentiment_value,\n                                                       classifier_options.get_variable(\n                                                           classifier_options.Variable.CLASSIFICATION_THRESHOLD_LOWER),\n                                                       classifier_options.get_variable(\n                                                           classifier_options.Variable.CLASSIFICATION_THRESHOLD_HIGHER))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef key_swap(\n    d,\n    cls,\n    marshal\n):\n    \"\"\" Swap the keys in a dictionary\n\n        Args:\n            d:       dict, The dict to swap keys in\n            cls:     class, If the class has a staticly defined\n                     _marshal_key_swap and/or _unmarshal_key_swap dict,\n                     the keys will be swapped.\n                     Otherwise @d is returned\n            marshal: bool, True if marshalling class to JSON,\n                     False if unmarshalling JSON to class\n        Returns:\n            dict\n    \"\"\"\n    dname = '_{}marshal_key_swap'.format(\"\" if marshal else \"un\")\n    if hasattr(cls, dname):\n        key_swap = getattr(cls, dname)\n        return {\n            key_swap[k] if k in key_swap else k: v\n            for k, v in d.items()\n        }\n    else:\n        return d", "response": "Swap the keys in a dictionary in a class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlog debug event. Compatible with logging. debug signature.", "response": "def debug(self, message, *args, **kwargs):\n        \"\"\"Log debug event.\n\n        Compatible with logging.debug signature.\n        \"\"\"\n        self.system.debug(message, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging info event. Compatible with logging. info signature.", "response": "def info(self, message, *args, **kwargs):\n        \"\"\"Log info event.\n\n        Compatible with logging.info signature.\n        \"\"\"\n        self.system.info(message, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs a warning event. Compatible with logging. warning signature.", "response": "def warning(self, message, *args, **kwargs):\n        \"\"\"Log warning event.\n\n        Compatible with logging.warning signature.\n        \"\"\"\n        self.system.warning(message, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error(self, message, *args, **kwargs):\n        self.system.error(message, *args, **kwargs)", "response": "Log an error event. Compatible with logging. error signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exception(self, message, *args, **kwargs):\n        self.system.exception(message, *args, **kwargs)", "response": "Log exception event. Compatible with logging. exception signature."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog a critical event. Compatible with logging. critical signature.", "response": "def critical(self, message, *args, **kwargs):\n        \"\"\"Log critical event.\n\n        Compatible with logging.critical signature.\n        \"\"\"\n        self.system.critical(message, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sign_out(self, redirect_url=None):\n    config = config_lib.get_config()\n    key = self.handler.app.config['webapp2_extras.sessions']['secret_key']\n    if redirect_url is None:\n      redirect_url = self.handler.request.url\n    user_id = self.handler.me.user_id()\n    token = xsrfutil.generate_token(key, user_id, action_id=redirect_url)\n    return '{}/signout?{}'.format(config['airlock_path'], urllib.urlencode({\n        'redirect': redirect_url,\n        'token': token,\n    }))", "response": "Returns a signed URL to disassociate the ouath2 user from the session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dirty_ops(self, instance):\n        ''' Returns a dict of the operations needed to update this object.\n            See :func:`Document.get_dirty_ops` for more details.'''\n        obj_value = instance._values[self._name]\n        if not obj_value.set:\n            return {}\n\n        if not obj_value.dirty and self.__type.config_extra_fields != 'ignore':\n            return {}\n\n        ops = obj_value.value.get_dirty_ops()\n\n        ret = {}\n        for op, values in ops.items():\n            ret[op] = {}\n            for key, value in values.items():\n                name = '%s.%s' % (self._name, key)\n                ret[op][name] = value\n        return ret", "response": "Returns a dict of the operations needed to update this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates and then use the document s class to wrap the value", "response": "def wrap(self, value):\n        ''' Validate ``value`` and then use the document's class to wrap the\n            value'''\n        self.validate_wrap(value)\n        return self.type.wrap(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unwrap(self, value, fields=None, session=None):\n        ''' Validate ``value`` and then use the document's class to unwrap the\n            value'''\n        self.validate_unwrap(value, fields=fields, session=session)\n        return self.type.unwrap(value, fields=fields, session=session)", "response": "Validate value and then use the document s class to unwrap the\n            value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_wrap(self, value):\n        ''' Checks that ``value`` is an instance of ``DocumentField.type``.\n            if it is, then validation on its fields has already been done and\n            no further validation is needed.\n        '''\n        if not isinstance(value, self.type):\n            self._fail_validation_type(value, self.type)", "response": "Checks that value is an instance of self. type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_re_pattern_from_intervals(intervals: IntervalListType) -> BuiltInReType:\n\n    inner = [f'{chr(lb)}-{chr(ub)}' for lb, ub in intervals]\n    joined_inner = ''.join(inner)\n    pattern = f'[{joined_inner}]+'\n\n    return re.compile(pattern, re.UNICODE)", "response": "Convert intervals to regular expression pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef applyPolicies(self, request):\n        '''\n        Apply relevant header policies to request.  Call me where\n        appropriate in your render_* methods.\n        '''\n        for policy in self._actingPolicies[request.method]:\n            request = policy.apply(request)\n        return request", "response": "Applies relevant header policies to request."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the matching score of two lists of authors.", "response": "def compute_author_match_score(x_authors, y_authors):\n    \"\"\"Return the matching score of 2 given lists of authors.\n\n    Args:\n        x_authors (list(dict)): first schema-compliant list of authors.\n        y_authors (list(dict)): second schema-compliant list of authors.\n\n    Returns:\n        float: matching score of authors.\n\n    \"\"\"\n    if not x_authors or not y_authors:\n        return 0.0\n\n    matches = get_number_of_author_matches(x_authors, y_authors)\n    max_length = max(len(x_authors), len(y_authors))\n\n    return matches / float(max_length)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compute_jaccard_index(x_set, y_set):\n    if not x_set or not y_set:\n        return 0.0\n\n    intersection_cardinal = len(x_set & y_set)\n    union_cardinal = len(x_set | y_set)\n\n    return intersection_cardinal / float(union_cardinal)", "response": "Compute the Jaccard similarity coefficient of two sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef info(*messages):\n    sys.stderr.write(\"%s.%s: \" % get_caller_info())\n    sys.stderr.write(' '.join(map(str, messages)))\n    sys.stderr.write('\\n')", "response": "Prints the current GloTK module and a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a directory recursively.", "response": "def safe_mkdir(path):\n    \"\"\"\n    Creates the directory, including any missing parent directories, at the\n    specified `path`.\n\n    Aborts if the path points to an existing regular file.\n\n    Returns the absolute path of the directory.\n    \"\"\"\n    if os.path.isfile(path):\n        die(\"'{0}' is a regular file: can't overwrite\" % path)\n    elif os.path.isdir(path):\n        info(\"directory '%s' already exists\" % path)\n    else:\n        info(\"creating directory '%s'\" % path)\n        try:\n            os.makedirs(path)\n        except OSError as e:\n            die(\"\"\"failed to recursively create the directory\n%s\n%s\n  Do you have write permision to that path?\n  Or does part of that path already exist as a regular file?\"\"\" % (path, e))\n    return os.path.abspath(path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that the current directory is a glotk project folder", "response": "def dir_is_glotk(path):\n    \"\"\"check that the current directory is a glotk project folder\"\"\"\n    test_set = set([\"gloTK_info\", \"gloTK_assemblies\",\n                    \"gloTK_configs\", \"gloTK_reads\",\n                    \"gloTK_fastqc\", \"gloTK_kmer\",\n                    \"gloTK_reports\"])\n    #http://stackoverflow.com/questions/11968976/\n    files = set([f for f in os.listdir('.') if os.path.isdir(f)])\n    intersection = test_set.intersection(files)\n    if len(intersection) > 0:\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_caller_info(depth=2, trace=False):\n    try:\n        frame = inspect.stack()[depth]\n    except:\n        die(\"could not access the caller's frame at stack index %d\" % depth)\n    if trace:\n        print_stack(frame[0].f_back)\n    func = frame[3]\n    module = inspect.getmodule(frame[0])\n    if module:\n        return (module.__name__, func)\n    else:\n        return ('<unknown>', func)", "response": "Returns a 2 - tuple with the module name and the function name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef die(*messages):\n    sys.stderr.write(\"%s.%s: \" % get_caller_info(trace=True))\n    sys.stderr.write(' '.join(map(str, messages)))\n    sys.stderr.write('\\n')\n    sys.exit(1)", "response": "Prints the current BioLite module and an error message then aborts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fastq_info(path):\n    numBases = 0\n    numReads = 0\n    readLengths = Counter()\n    GCTot = 0\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        handle = gzip.open(path, \"rt\")\n        for record in SeqIO.parse(handle, \"fastq\"):\n            numBases += len(record)\n            numReads += 1\n            readLengths[len(record)] += 1\n            GCTot += sum(record.seq.count(x) for x in ['G', 'C', 'g', 'c', 'S', 's'])\n        handle.close()\n    GCPer = (GCTot/numBases)\n    avgReadLen = (sum(value*count for value,count in readLengths.items())/numReads)\n    return {\"numBases\": numBases,\n            \"numReads\": numReads,\n            \"numGCBases\": GCTot,\n            \"portionGC\": GCPer,\n            \"avgReadLen\": avgReadLen}", "response": "Return a dict of information about the code blocks in a FASTQ file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes the Flask application.", "response": "def init_app(self, app):\n        \"\"\"Flask application initialization.\"\"\"\n        self.init_config(app)\n        app.extensions['inspire-crawler'] = self\n        app.cli.add_command(crawler_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef result(self, input_sequence: str, config: Optional[BasicConfig] = None) -> Any:\n        # Step 1.\n        sequential_labelers = [\n                sl_cls(input_sequence, config) for sl_cls in self.sequential_labeler_classes\n        ]\n        index_labels_generator = ((index, {\n                type(labeler): labeler.label(index) for labeler in sequential_labelers\n        }) for index in range(len(input_sequence)))\n\n        # Step 2.\n        label_processor = self.label_processor_class(input_sequence, index_labels_generator, config)\n        label_processor_result = label_processor.result()\n\n        # Step 3.\n        output_generator = self.output_generator_class(input_sequence, label_processor_result,\n                                                       config)\n        return output_generator.result()", "response": "Execute the workflow.\n\n        :param input_sequence: The input sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates a NMEA 0183 checksum for the given sentence.", "response": "def calc_checksum(sentence):\n    \"\"\"Calculate a NMEA 0183 checksum for the given sentence.\n\n    NMEA checksums are a simple XOR of all the characters in the sentence\n    between the leading \"$\" symbol, and the \"*\" checksum separator.\n\n    Args:\n        sentence (str): NMEA 0183 formatted sentence\n    \"\"\"\n    if sentence.startswith('$'):\n        sentence = sentence[1:]\n    sentence = sentence.split('*')[0]\n    return reduce(xor, map(ord, sentence))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_latitude(latitude, hemisphere):\n    latitude = int(latitude[:2]) + float(latitude[2:]) / 60\n    if hemisphere == 'S':\n        latitude = -latitude\n    elif not hemisphere == 'N':\n        raise ValueError('Incorrect North/South value %r' % hemisphere)\n    return latitude", "response": "Parse a NMEA - formatted latitude pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_longitude(longitude, hemisphere):\n    longitude = int(longitude[:3]) + float(longitude[3:]) / 60\n    if hemisphere == 'W':\n        longitude = -longitude\n    elif not hemisphere == 'E':\n        raise ValueError('Incorrect North/South value %r' % hemisphere)\n    return longitude", "response": "Parse a NMEA - formatted longitude pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_elements(elements):\n        if not len(elements) in (6, 7):\n            raise ValueError('Invalid GLL position data')\n        # Latitude and longitude are checked for validity during Fix\n        # instantiation\n        latitude = parse_latitude(elements[0], elements[1])\n        longitude = parse_longitude(elements[2], elements[3])\n        hour, minute, second = [int(elements[4][i:i + 2])\n                                for i in range(0, 6, 2)]\n        usecond = int(elements[4][6:8]) * 10000\n        time = datetime.time(hour, minute, second, usecond)\n        active = True if elements[5] == 'A' else False\n        mode = elements[6] if len(elements) == 7 else None\n        return LoranPosition(latitude, longitude, time, active, mode)", "response": "Parse GLL position data elements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the position data elements.", "response": "def parse_elements(elements):\n        \"\"\"Parse position data elements.\n\n        Args:\n            elements (list): Data values for position\n\n        Returns:\n            Position: Position object representing data\n        \"\"\"\n        if not len(elements) in (11, 12):\n            raise ValueError('Invalid RMC position data')\n        time = datetime.time(*[int(elements[0][i:i + 2])\n                               for i in range(0, 6, 2)])\n        active = True if elements[1] == 'A' else False\n        # Latitude and longitude are checked for validity during Fix\n        # instantiation\n        latitude = parse_latitude(elements[2], elements[3])\n        longitude = parse_longitude(elements[4], elements[5])\n        speed = float(elements[6])\n        track = float(elements[7])\n        date = datetime.date(2000 + int(elements[8][4:6]),\n                             int(elements[8][2:4]), int(elements[8][:2]))\n        variation = float(elements[9]) if not elements[9] == '' else None\n        if elements[10] == 'W':\n            variation = -variation\n        elif variation and not elements[10] == 'E':\n            raise ValueError('Incorrect variation value %r'\n                             % elements[10])\n        mode = elements[11] if len(elements) == 12 else None\n        return Position(time, active, latitude, longitude, speed, track, date,\n                        variation, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing essential fix s data elements.", "response": "def parse_elements(elements):\n        \"\"\"Parse essential fix's data elements.\n\n        Args:\n            elements (list): Data values for fix\n\n        Returns:\n            Fix: Fix object representing data\n        \"\"\"\n        if not len(elements) in (14, 15):\n            raise ValueError('Invalid GGA fix data')\n        time = datetime.time(*[int(elements[0][i:i + 2])\n                               for i in range(0, 6, 2)])\n        # Latitude and longitude are checked for validity during Fix\n        # instantiation\n        latitude = parse_latitude(elements[1], elements[2])\n        longitude = parse_longitude(elements[3], elements[4])\n        quality = int(elements[5])\n        if not 0 <= quality <= 9:\n            raise ValueError('Invalid quality value %r' % quality)\n        satellites = int(elements[6])\n        if not 0 <= satellites <= 12:\n            raise ValueError('Invalid number of satellites %r'\n                             % satellites)\n        dilution = float(elements[7])\n        altitude = float(elements[8])\n        if elements[9] == 'F':\n            altitude = altitude * 3.2808399\n        elif not elements[9] == 'M':\n            raise ValueError('Unknown altitude unit %r' % elements[9])\n        if elements[10] in ('-', ''):\n            geoid_delta = False\n            logging.warning('Altitude data could be incorrect, as the geoid '\n                            'difference has not been provided')\n        else:\n            geoid_delta = float(elements[10])\n        if elements[11] == 'F':\n            geoid_delta = geoid_delta * 3.2808399\n        elif geoid_delta and not elements[11] == 'M':\n            raise ValueError('Unknown geoid delta unit %r' % elements[11])\n        dgps_delta = float(elements[12]) if elements[12] else None\n        dgps_station = int(elements[13]) if elements[13] else None\n        mode = elements[14] if len(elements) == 15 else None\n        return Fix(time, latitude, longitude, quality, satellites, dilution,\n                   altitude, geoid_delta, dgps_delta, dgps_station, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses waypoint data elements.", "response": "def parse_elements(elements):\n        \"\"\"Parse waypoint data elements.\n\n        Args:\n            elements (list): Data values for fix\n\n        Returns:\n            nmea.Waypoint: Object representing data\n        \"\"\"\n        if not len(elements) == 5:\n            raise ValueError('Invalid WPL waypoint data')\n        # Latitude and longitude are checked for validity during Fix\n        # instantiation\n        latitude = parse_latitude(elements[0], elements[1])\n        longitude = parse_longitude(elements[2], elements[3])\n        name = elements[4]\n        return Waypoint(latitude, longitude, name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_locations(self, gpsdata_file, checksum=True):\n        self._gpsdata_file = gpsdata_file\n        data = utils.prepare_read(gpsdata_file)\n\n        parsers = {\n            'GPGGA': Fix,\n            'GPRMC': Position,\n            'GPWPL': Waypoint,\n            'GPGLL': LoranPosition,\n            'LCGLL': LoranPosition,\n        }\n\n        if not checksum:\n            logging.warning('Disabling the checksum tests should only be used'\n                            'when the device is incapable of emitting the '\n                            'correct values!')\n        for line in data:\n            # The standard tells us lines should end in \\r\\n even though some\n            # devices break this, but Python's standard file object solves this\n            # for us anyway.  However, be careful if you implement your own\n            # opener.\n            if not line[1:6] in parsers:\n                continue\n            if checksum:\n                values, checksum = line[1:].split('*')\n                if not calc_checksum(values) == int(checksum, 16):\n                    raise ValueError('Sentence has invalid checksum')\n            else:\n                values = line[1:].split('*')[0]\n            elements = values.split(',')\n            parser = getattr(parsers[elements[0]], 'parse_elements')\n            self.append(parser(elements[1:]))", "response": "Import the GPS data files and return a list of Fix objects representing the locations found in the GPS data files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_platform():\n\t# Detect\n\tplatform_str = platform.system()\n\tprint 'Platform detected: {}'.format(platform_str)\n\t# Instantiate\n\tif platform_str == 'Windows':\n\t\treturn WindowsPlatform()\n\telif platform_str == 'Linux':\n\t\treturn LinuxPlatform()\n\telse:\n\t\traise NotImplementedError('This platform is not yet supported')", "response": "Detect and instantiate an instance of the underlying platform"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef length(self):\n        span = self._stop - self._start\n        length, modulo = divmod(span, self._step)\n        if length < 0:\n            return 0\n        if modulo != 0:\n            return length + 1\n        return length", "response": "The number of elements changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _notify_add(self, slice_):\n        change = AddChange(self, slice_)\n        self.notify_observers(change)", "response": "Notify about an AddChange."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnotify about an AddChange at a caertain index and length.", "response": "def _notify_add_at(self, index, length=1):\n        \"\"\"Notify about an AddChange at a caertain index and length.\"\"\"\n        slice_ = self._slice_at(index, length)\n        self._notify_add(slice_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _notify_remove_at(self, index, length=1):\n        slice_ = self._slice_at(index, length)\n        self._notify_remove(slice_)", "response": "Notify about a RemoveChange at a caertain index and length."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnotify about a RemoveChange.", "response": "def _notify_remove(self, slice_):\n        \"\"\"Notify about a RemoveChange.\"\"\"\n        change = RemoveChange(self, slice_)\n        self.notify_observers(change)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a slice for index and length.", "response": "def _slice_at(self, index, length=1):\n        \"\"\"Create a slice for index and length.\"\"\"\n        length_ = len(self)\n        if -length <= index < 0:\n            index += length_\n        return slice(index, index + length)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending an element to the end of the list.", "response": "def append(self, element):\n        \"\"\"See list.append.\"\"\"\n        super(ObservableList, self).append(element)\n        self._notify_add_at(len(self) - 1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nappend elements from other to self.", "response": "def extend(self, other):\n        \"\"\"See list.extend.\"\"\"\n        index = len(self)\n        length = 0\n        for length, element in enumerate(other, 1):\n            super(ObservableList, self).append(element)\n        if length:\n            self._notify_add_at(index, length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnotifies about a deletion at an index_or_slice.", "response": "def _notify_delete(self, index_or_slice):\n        \"\"\"Notify about a deletion at an index_or_slice.\n\n        :return: a function that notifies about an add at the same place.\n        \"\"\"\n        if isinstance(index_or_slice, int):\n            length = len(self)\n            if -length <= index_or_slice < length:\n                self._notify_remove_at(index_or_slice)\n                return lambda: self._notify_add_at(index_or_slice)\n        elif isinstance(index_or_slice, slice):\n            slice_ = slice(*index_or_slice.indices(len(self)))\n            self._notify_remove(slice_)\n            return lambda: self._notify_add(index_or_slice)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a filter string into a key - value pair", "response": "def _parse_filter_string(filter_string):\n    \"\"\" parse a filter string into a key-value pair \"\"\"\n    assert \"=\" in filter_string, \"filter string requires an '=', got {0}\".format(filter_string)\n    split_values = filter_string.split('=')\n    assert len(split_values) == 2, \"more than one equals found in filter string {0}!\".format(filter_string)\n    return split_values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_stdout_logger():\n    log = logging.getLogger(__name__)\n    out_hdlr = logging.StreamHandler(sys.stdout)\n    out_hdlr.setFormatter(logging.Formatter('%(message)s'))\n    out_hdlr.setLevel(logging.INFO)\n    log.addHandler(out_hdlr)\n    log.setLevel(logging.INFO)", "response": "create a logger to stdout"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting dictionary to JSON formatted string with typeToken", "response": "def to_json(data, pretty):\n    \"\"\"\n    Converts object to JSON formatted string with typeToken adapter\n    :param data: A dictionary to convert to JSON string\n    :param pretty: A boolean deciding whether or not to pretty format the JSON string\n    :return: The JSON string\n    \"\"\"\n    if pretty:\n        return json.dumps(data, sort_keys=True, indent=4, separators=(',', ': '))\n    return json.dumps(data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_json_file(file, data, pretty):\n    json_string = to_json(data, pretty)\n    file_utils.write_to_file(file, json_string)", "response": "Writes object instance in JSON formatted String to file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef github_auth_middleware(*, github_id, github_secret, github_org,\n                           whitelist_handlers=None, api_unauthorized=False):\n    \"\"\" Middleware for github authentication\n    :param github_id: github client id\n    :param github_secret: github secret\n    :param github_org: github organization for which people are authorized\n    :param whitelist_handlers: a list of handler methods\n        which do not need authorization\n    :param api_unauthorized: if set to True, any call without authorization\n        made at a path of /api/* will return a 401 instead of\n        redirecting to github login\n\n    :return: middleware_factory\n    \"\"\"\n    global gh_id, gh_secret, gh_org\n    gh_id = github_id\n    gh_secret = github_secret\n    gh_org = github_org\n    whitelist_handlers = whitelist_handlers or []\n\n    async def middleware_factory(app, handler):\n\n        async def auth_handler(request):\n            session = await get_session(request)\n            params = urllib.parse.parse_qs(request.query_string)\n            user = session.get('User')\n            if user:  # Already authenticated\n                request['user'] = user\n            elif handler in whitelist_handlers:  # We don't need authentication\n                pass\n            elif handler == handle_github_callback and \\\n                    session.get('github_state'):\n                # Attempting to authenticate - let them pass through\n                        pass\n\n            elif api_unauthorized and request.path.startswith('/api/'):\n                return web.HTTPUnauthorized()\n            else:\n                gh = GithubClient(\n                    client_id=gh_id,\n                    client_secret=gh_secret\n                )\n                state = os.urandom(30).hex()\n                authorize_url = gh.get_authorize_url(\n                    scope='user:email read:org',\n                    state=state)\n                session['github_state'] = state\n                session['desired_location'] = request.path\n                return web.HTTPFound(authorize_url)\n\n            return await handler(request)\n\n        return auth_handler\n\n    return middleware_factory", "response": "Returns a middleware for github authentication."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simple_round_factory(tol):\n    def simple_round(*args, **kwds):\n        argstype = type(args)\n        _args = list(args)\n        _kwds = kwds.copy()\n        for i,j in enumerate(args): # args[0] is the class.\n            if isinstance(j, float): _args[i] = round(j, tol[i - 1] \\\n                if isinstance(tol, (list, tuple)) else tol) # don't round int\n        for k, (i,j) in enumerate(kwds.items()):\n            if isinstance(j, float): _kwds[i] = round(j, tol[k] \\\n                if isinstance(tol, (list, tuple)) else tol)\n        return argstype(_args), _kwds\n    return simple_round", "response": "a factory function for simple_round"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef simple_round(tol=0):\n    def dec(f):\n        def func(*args, **kwds):\n            if tol is None:\n                _args,_kwds = args,kwds\n            else:\n                _simple_round = simple_round_factory(tol)\n                _args,_kwds = _simple_round(*args, **kwds)\n            return f(*_args, **_kwds)\n        return func\n    return dec", "response": "decorator for rounding a function s input argument and keywords to the\n    given precision *tol."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef push(self, item, *, index=None):\n        if index is None:\n            self.__list.append(item)\n        else:\n            self.__list.insert(index, item)\n        name = getattr(item, 'name', None)\n        if name is not None:\n            self.__dict[name] = item", "response": "Push an item to the chain."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pull(self, *, index=None):\n        item = self.__list.pop(index)\n        name = getattr(item, 'name', None)\n        if name is not None:\n            del self.__dict[name]\n        return item", "response": "Pull an item from the chain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the total CPU usage for all available processes and processes for the given user.", "response": "def get_cpu_usage(user=None, ignore_self=True):\n    \"\"\"\n    Returns the total CPU usage for all available cores.\n\n    :param user: If given, returns only the total CPU usage of all processes\n      for the given user.\n    :param ignore_self: If ``True`` the process that runs this script will\n      be ignored.\n\n    \"\"\"\n    pid = os.getpid()\n    cmd = \"ps aux\"\n    output = getoutput(cmd)\n    total = 0\n    largest_process = 0\n    largest_process_name = None\n    for row in output.split('\\n')[1:]:\n        row = row.split()\n        if row[1] == str(pid) and ignore_self:\n            continue\n        if user is None or user == row[0]:\n            cpu = decimal.Decimal(row[2])\n            if cpu > total:\n                largest_process = cpu\n                largest_process_name = ' '.join(row[10:len(row)])\n            total += decimal.Decimal(row[2])\n    return total, largest_process, largest_process_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending an event to the cluster.", "response": "def event(self, name, payload=None, coalesce=True):\n        \"\"\"\n        Send an event to the cluster. Can take an optional payload as well,\n        which will be sent in the form that it's provided.\n        \"\"\"\n        return self.connection.call(\n            'event',\n            {'Name': name, 'Payload': payload, 'Coalesce': coalesce},\n            expect_body=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of Serf members.", "response": "def members(self, name=None, status=None, tags=None):\n        \"\"\"\n        Lists members of a Serf cluster, optionally filtered by one or more\n        filters:\n\n        `name` is a string, supporting regex matching on node names.\n        `status` is a string, supporting regex matching on node status.\n        `tags` is a dict of tag names and values, supporting regex matching\n        on values.\n        \"\"\"\n        filters = {}\n\n        if name is not None:\n            filters['Name'] = name\n\n        if status is not None:\n            filters['Status'] = status\n\n        if tags is not None:\n            filters['Tags'] = tags\n\n        if len(filters) == 0:\n            return self.connection.call('members')\n        else:\n            return self.connection.call('members-filtered', filters)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\njoin another cluster by provided a list of ip : port locations.", "response": "def join(self, location):\n        \"\"\"\n        Join another cluster by provided a list of ip:port locations.\n        \"\"\"\n        if not isinstance(location, (list, tuple)):\n            location = [location]\n        return self.connection.call(\n            'join',\n            {\"Existing\": location, \"Replay\": False})"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_wrap(self, value):\n        ''' Validates the type and length of ``value`` '''\n        if not isinstance(value, basestring):\n            self._fail_validation_type(value, basestring)\n        if self.max is not None and len(value) > self.max:\n            self._fail_validation(value, 'Value too long (%d)' % len(value))\n        if self.min is not None and len(value) < self.min:\n            self._fail_validation(value, 'Value too short (%d)' % len(value))", "response": "Validates the type and length of value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_wrap(self, value):\n        ''' Validates the type and length of ``value`` '''\n        if not isinstance(value, basestring):\n            self._fail_validation_type(value, basestring)\n        if self.regex.match(value) is None:\n            self._fail_validation(value, 'Value does not match regular expression')", "response": "Validates the type and length of value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_wrap(self, value, *types):\n        ''' Validates the type and value of ``value`` '''\n        for type in types:\n            if isinstance(value, type):\n                break\n        else:\n            self._fail_validation_type(value, *types)\n\n        if self.min is not None and value < self.min:\n            self._fail_validation(value, 'Value too small')\n        if self.max is not None and value > self.max:\n            self._fail_validation(value, 'Value too large')", "response": "Validates the type and value of the resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates the value is in the valid date range and returns the valid .", "response": "def validate_wrap(self, value):\n        ''' Validates the value's type as well as it being in the valid\n            date range'''\n        if not isinstance(value, datetime):\n            self._fail_validation_type(value, datetime)\n\n        if self.use_tz and value.tzinfo is None:\n            self._fail_validation(value, '''datetime is not timezone aware and use_tz is on.  make sure timezone is set on the session''')\n\n        # if using timezone support it isn't clear how min and max should work,\n        # so the problem is being punted on for now.\n        if self.use_tz:\n            return\n\n        # min/max\n        if self.min is not None and value < self.min:\n            self._fail_validation(value, 'DateTime too old')\n        if self.max is not None and value > self.max:\n            self._fail_validation(value, 'DateTime too new')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that the correct number of elements are in value and that each element validates agains the associated Field class", "response": "def validate_wrap(self, value):\n        ''' Checks that the correct number of elements are in ``value`` and that\n            each element validates agains the associated Field class\n        '''\n        if not isinstance(value, list) and not isinstance(value, tuple):\n            self._fail_validation_type(value, tuple, list)\n\n        for field, value in izip(self.types, list(value)):\n            field.validate_wrap(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap(self, value):\n        ''' Validate and then wrap ``value`` for insertion.\n\n            :param value: the tuple (or list) to wrap\n        '''\n        self.validate_wrap(value)\n        ret = []\n        for field, value in izip(self.types, value):\n            ret.append(field.wrap(value))\n        return ret", "response": "Validate and then wrap value for insertion."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate and then unwrap value for object creation.", "response": "def unwrap(self, value, session=None):\n        ''' Validate and then unwrap ``value`` for object creation.\n\n            :param value: list returned from the database.\n        '''\n        self.validate_unwrap(value)\n        ret = []\n        for field, value in izip(self.types, value):\n            ret.append(field.unwrap(value, session=session))\n        return tuple(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck that value is valid for EnumField. item_type and that value is one of the values specified when the EnumField was constructed.", "response": "def validate_wrap(self, value):\n        ''' Checks that value is valid for `EnumField.item_type` and that\n            value is one of the values specified when the EnumField was\n            constructed '''\n        self.item_type.validate_wrap(value)\n\n        if value not in self.values:\n            self._fail_validation(value, 'Value was not in the enum values')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wrap(self, value):\n        ''' Validate and wrap value using the wrapping function from\n            ``EnumField.item_type``\n        '''\n        self.validate_wrap(value)\n        return self.item_type.wrap(value)", "response": "Validate and wrap value using the wrapping function from\n           . item_type"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unwrap(self, value, session=None):\n        ''' Unwrap value using the unwrap function from ``EnumField.item_type``.\n            Since unwrap validation could not happen in is_valid_wrap, it\n            happens in this function.'''\n        self.validate_unwrap(value)\n        value = self.item_type.unwrap(value, session=session)\n        for val in self.values:\n            if val == value:\n                return val\n        self._fail_validation(value, 'Value was not in the enum values')", "response": "Unwrap value using the unwrap function from EnumField. item_type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_wrap(self, value):\n        ''' Checks that ``value`` is a pymongo ``ObjectId`` or a string\n            representation of one'''\n        if (not isinstance(value, ObjectId)\n                and not isinstance(value, basestring)\n                and not isinstance(value, bytes)\n            ):\n            self._fail_validation_type(value, ObjectId)\n        if isinstance(value, ObjectId):\n            return\n        #: bytes\n        if len(value) == 12:\n            return\n        # hex\n        if len(value) != 24:\n            self._fail_validation(value, 'hex object ID is the wrong length')", "response": "Checks that value is a pymongo ObjectId or a string\n            representation of one"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate that value is an ObjectId or hex representation of one and returns it", "response": "def wrap(self, value, session=None):\n        ''' Validates that ``value`` is an ObjectId (or hex representation\n            of one), then returns it '''\n        self.validate_wrap(value)\n        if isinstance(value, bytes) or isinstance(value, basestring):\n            return ObjectId(value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate that value is valid for unwrapping with ComputedField. computed_type.", "response": "def validate_wrap(self, value):\n        ''' Check that ``value`` is valid for unwrapping with ``ComputedField.computed_type``'''\n        try:\n            self.computed_type.validate_wrap(value)\n        except BadValueException as bve:\n            self._fail_validation(value, 'Bad value for computed field', cause=bve)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_unwrap(self, value):\n        ''' Check that ``value`` is valid for unwrapping with ``ComputedField.computed_type``'''\n        try:\n            self.computed_type.validate_unwrap(value)\n        except BadValueException as bve:\n            self._fail_validation(value, 'Bad value for computed field', cause=bve)", "response": "Validate that value is valid for unwrapping with ComputedField. computed_type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wrap(self, value):\n        ''' Validates ``value`` and wraps it with ``ComputedField.computed_type``'''\n        self.validate_wrap(value)\n        return self.computed_type.wrap(value)", "response": "Validates value and wraps it with self. computed_type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate value and unwraps it with ComputedField. computed_type.", "response": "def unwrap(self, value, session=None):\n        ''' Validates ``value`` and unwraps it with ``ComputedField.computed_type``'''\n        self.validate_unwrap(value)\n        return self.computed_type.unwrap(value, session=session)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndispatches the request and return the response.", "response": "def dispatch(self, request, **resources):\n        \"\"\" Try to dispatch the request.\n\n        :return object: result\n\n        \"\"\"\n\n        # Fix PUT and PATH methods in Django request\n        request = fix_request(request)\n\n        # Set self identifier\n        self.identifier = request.META.get('REMOTE_ADDR', 'anonymous')\n\n        # Send ADREST started signal\n        api_request_started.send(self, request=request)\n\n        # Send current api started signal\n        if self.api:\n            self.api.request_started.send(self, request=request)\n\n        try:\n\n            # Check request method\n            self.check_method_allowed(request)\n\n            # Authentificate\n            self.authenticate(request)\n\n            # Throttle check\n            self.throttle_check()\n\n            if request.method != 'OPTIONS' or not ADREST_ALLOW_OPTIONS:\n\n                # Parse content\n                request.data = self.parse(request)\n\n                # Get required resources\n                resources = self.get_resources(\n                    request, **resources)\n\n                # Check owners\n                self.check_owners(request, **resources)\n\n                # Check rights for resources with this method\n                self.check_rights(resources, request=request)\n\n            response = self.handle_request(request, **resources)\n\n            # Serialize response\n            response = self.emit(response, request=request)\n\n        except Exception as e:\n            response = self.handle_exception(e, request=request)\n\n        response[\"Allow\"] = ', '.join(self._meta.allowed_methods)\n        response[\"Vary\"] = 'Authenticate, Accept'\n\n        # Send errors on mail\n        adrest_errors_mail(response, request)\n\n        # Send finished signal\n        api_request_finished.send(\n            self, request=request, response=response, **resources)\n\n        # Send finished signal in API context\n        if self.api:\n            self.api.request_finished.send(\n                self, request=request, response=response, **resources)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_owners(self, request, **resources):\n\n        if self._meta.allow_public_access or not self._meta.parent:\n            return True\n\n        self.parent.check_owners(request, **resources)\n\n        objects = resources.get(self._meta.name)\n        if self._meta.model and self._meta.parent._meta.model and objects:\n            pr = resources.get(self._meta.parent._meta.name)\n            check = all(\n                pr.pk == getattr(\n                    o, \"%s_id\" % self._meta.parent._meta.name, None)\n                for o in as_tuple(objects))\n\n            if not pr or not check:\n                # 403 Error if there is error in parent-children relationship\n                raise HttpError(\n                    \"Access forbidden.\", status=status.HTTP_403_FORBIDDEN)\n\n        return True", "response": "Check parents of current resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_exception(self, e, request=None):\n        if isinstance(e, HttpError):\n            response = SerializedHttpResponse(e.content, status=e.status)\n            return self.emit(\n                response, request=request, emitter=e.emitter)\n\n        if isinstance(e, (AssertionError, ValidationError)):\n\n            content = unicode(e)\n\n            if isinstance(e, FormError):\n                content = e.form.errors\n\n            response = SerializedHttpResponse(\n                content, status=status.HTTP_400_BAD_REQUEST)\n\n            return self.emit(response, request=request)\n\n        if ADREST_DEBUG:\n            raise\n\n        logger.exception('\\nADREST API Error: %s', request.path)\n\n        return HttpResponse(str(e), status=500)", "response": "Handle code exception.\n\n        :return response: Http response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate url for resource.", "response": "def as_url(cls, api=None, name_prefix='', url_prefix=''):\n        \"\"\" Generate url for resource.\n\n        :return RegexURLPattern: Django URL\n\n        \"\"\"\n        url_prefix = url_prefix and \"%s/\" % url_prefix\n        name_prefix = name_prefix and \"%s-\" % name_prefix\n\n        url_regex = '^%s%s/?$' % (\n            url_prefix, cls._meta.url_regex.lstrip('^').rstrip('/$'))\n        url_regex = url_regex.replace('//', '/')\n        url_name = '%s%s' % (name_prefix, cls._meta.url_name)\n\n        return url(url_regex, cls.as_view(api=api), name=url_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_locations(self, marker_file):\n        self._marker_file = marker_file\n        field_names = ('tag', 'identity', 'latitude', 'longitude', 'altitude',\n                       'name')\n        pos_parse = lambda x, s: float(s[1:]) if s[0] == x else 0 - float(s[1:])\n        latitude_parse = partial(pos_parse, 'N')\n        longitude_parse = partial(pos_parse, 'E')\n        # A value of 8888.0 denotes unavailable data\n        altitude_parse = lambda s: None if s.strip() == '8888.0' else float(s)\n        field_parsers = (str, int, latitude_parse, longitude_parse,\n                         altitude_parse, str)\n\n        data = utils.prepare_csv_read(marker_file, field_names)\n\n        for row in (x for x in data if x['tag'] == 'W'):\n            for name, parser in zip(field_names, field_parsers):\n                row[name] = parser(row[name])\n            del row['tag']\n            try:\n                self[row['identity']] = Trigpoint(**row)\n            except TypeError:\n                # Workaround formatting error in 506514 entry that contains\n                # spurious comma\n                del row[None]\n                self[row['identity']] = Trigpoint(**row)", "response": "Imports all locations from a trigpoint marker file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_request(self, request, **resources):\n        if not request.method in self._meta.callmap.keys():\n            raise HttpError(\n                'Unknown or unsupported method \\'%s\\'' % request.method,\n                status=status.HTTP_501_NOT_IMPLEMENTED)\n\n        # Get the appropriate create/read/update/delete function\n        view = getattr(self, self._meta.callmap[request.method])\n\n        # Get function data\n        return view(request, **resources)", "response": "Handle a request and execute it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, request, **resources):\n\n        instance = resources.get(self._meta.name)\n        if not instance is None:\n            return instance\n\n        return self.paginate(\n            request, self.get_collection(request, **resources))", "response": "Default GET method. Return instance or collection from self. model\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndefaults POST method. Uses the handler s form. method. Returns the saved instance or raises FormError.", "response": "def post(self, request, **resources):\n        \"\"\" Default POST method. Uses the handler's form.\n\n        :return object: saved instance or raise form's error\n\n        \"\"\"\n        if not self._meta.form:\n            return None\n\n        form = self._meta.form(request.data, **resources)\n        if form.is_valid():\n            return form.save()\n\n        raise FormError(form)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put(self, request, **resources):\n        if not self._meta.form:\n            return None\n\n        if not self._meta.name in resources or not resources[self._meta.name]:\n            raise HttpError(\n                \"Resource not found.\", status=status.HTTP_404_NOT_FOUND)\n        resource = resources.pop(self._meta.name)\n\n        updated = UpdatedList()\n        for o in as_tuple(resource):\n            form = self._meta.form(data=request.data, instance=o, **resources)\n\n            if not form.is_valid():\n                raise FormError(form)\n\n            updated.append(form.save())\n\n        return updated if len(updated) > 1 else updated[-1]", "response": "Default PUT method. Uses self. form method. Returns object if successful or raise form s error."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, request, **resources):\n\n        resource = resources.get(self._meta.name)\n        if not resource:\n            raise HttpError(\"Bad request\", status=status.HTTP_404_NOT_FOUND)\n\n        for o in as_tuple(resource):\n            o.delete()\n\n        return HttpResponse(\"\")", "response": "Default DELETE method. Allow bulk delete."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_method_allowed(cls, request):\n        if not request.method in cls._meta.allowed_methods:\n            raise HttpError(\n                'Method \\'%s\\' not allowed on this resource.' % request.method,\n                status=status.HTTP_405_METHOD_NOT_ALLOWED)", "response": "Ensure the request HTTP method is allowed on this resource. Raises a ResourceException if it is not."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_resources(self, request, **resources):\n\n        if self.parent:\n            resources = self.parent.get_resources(request, **resources)\n\n        pks = (\n            resources.get(self._meta.name) or\n            request.REQUEST.getlist(self._meta.name) or\n            getattr(request, 'data', None) and request.data.get(\n                self._meta.name))\n\n        if not pks or self._meta.queryset is None:\n            return resources\n\n        pks = as_tuple(pks)\n\n        try:\n            if len(pks) == 1:\n                resources[self._meta.name] = self._meta.queryset.get(pk=pks[0])\n\n            else:\n                resources[self._meta.name] = self._meta.queryset.filter(\n                    pk__in=pks)\n\n        except (ObjectDoesNotExist, ValueError, AssertionError):\n            raise HttpError(\"Resource not found.\",\n                            status=status.HTTP_404_NOT_FOUND)\n\n        except MultipleObjectsReturned:\n            raise HttpError(\"Resources conflict.\",\n                            status=status.HTTP_409_CONFLICT)\n\n        return resources", "response": "Parse resource objects from URL and request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_contact(self, email=None, first_name=None, last_name=None, phone_number=None):\n        result = {}\n        if email:\n            result['email'] = email\n        if first_name is not None:\n            result['first_name'] = first_name\n        if last_name is not None:\n            result['last_name'] = last_name\n        if phone_number is not None:\n            result['phone_number'] = phone_number\n        return result if len(result) > 0 else None", "response": "Create a contant which is later passed to payment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a single payment for a specific order.", "response": "def create_single_payment(self, order_number, order_description, order_items, amount, return_url, contact=None, currency=None, lang=None, additional_params=None):\n        \"\"\"\n        Create a single payment.\n\n        Args:\n            contact: JSON describing a payer (see PaymentManager#create_contact)\n            order_number: your identifier to the order which the payment is for\n            order_description: desription of the order which is show to the\n                user\n            order_items: items in order which are shown to the other\n                (item name -> amount)\n            amount: total amount of money which will be paid\n            returl_url: url for rediraction after payment is processed\n            currency: default is set in settings (GOPAY_CURRENCY)\n            lang: default is set in settings (GOPAY_LANG)\n        Returns:\n            dict: payment status\n        \"\"\"\n        return self.create_payment(contact, {\n            'amount': amount,\n            'currency': currency if currency is not None else settings.GOPAY_CURRENCY,\n            'lang': lang if lang is not None else settings.GOPAY_LANG,\n            'additional_params': [] if additional_params is None else [{'name': key, 'value': str(value)} for key, value in additional_params.items()],\n            'order_number': str(order_number),\n            'order_description': order_description,\n            'items': [{'name': key, 'amount': value} for key, value in order_items.items()],\n            'callback': {\n                'return_url': return_url,\n                'notification_url': '{}{}'.format(settings.GOPAY_DOMAIN, reverse('gopay_notify')),\n            },\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary of data for a given schedule.", "response": "def get_books_for_schedule(self, schedule):\n        \"\"\"\n        Returns a dictionary of data.  SLNs are the keys, an array of Book\n        objects are the values.\n        \"\"\"\n        slns = self._get_slns(schedule)\n\n        books = {}\n\n        for sln in slns:\n            try:\n                section_books = self.get_books_by_quarter_sln(\n                    schedule.term.quarter, sln\n                )\n                books[sln] = section_books\n            except DataFailureException:\n                # do nothing if bookstore doesn't have sln\n                pass\n        return books"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a verbba link to the resource with the given schedule.", "response": "def get_verba_link_for_schedule(self, schedule):\n        \"\"\"\n        Returns a link to verba.  The link varies by campus and schedule.\n        Multiple calls to this with the same schedule may result in\n        different urls.\n        \"\"\"\n        dao = Book_DAO()\n\n        url = self.get_verba_url(schedule)\n\n        response = dao.getURL(url, {\"Accept\": \"application/json\"})\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n\n        for key in data:\n            if re.match(r'^[A-Z]{2}[0-9]{5}$', key):\n                return \"%s%s&quarter=%s\" % (BOOK_PREFIX,\n                                            key,\n                                            schedule.term.quarter)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngoing to the login page.", "response": "async def _get_login_page(self):\n        \"\"\"Go to the login page.\"\"\"\n        try:\n            async with async_timeout.timeout(10):\n                raw_res = await self._session.get(HOME_URL,\n                                                  allow_redirects=False,\n                                                  timeout=self._timeout)\n        except OSError:\n            raise PyEboxError(\"Can not connect to login page\")\n        # Get token\n        content = await raw_res.text()\n        soup = BeautifulSoup(content, 'html.parser')\n        token_node = soup.find('input', {'name': '_csrf_security_token'})\n        if token_node is None:\n            raise PyEboxError(\"No token input found\")\n        token = token_node.attrs.get('value')\n        if token is None:\n            raise PyEboxError(\"No token found\")\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs-in to EBox website.", "response": "async def _post_login_page(self, token):\n        \"\"\"Login to EBox website.\"\"\"\n        data = {\"usrname\": self.username,\n                \"pwd\": self.password,\n                \"_csrf_security_token\": token}\n\n        try:\n            async with async_timeout.timeout(10):\n                raw_res = await self._session.post(LOGIN_URL,\n                                                   data=data,\n                                                   allow_redirects=False,\n                                                   timeout=self._timeout)\n        except OSError:\n            raise PyEboxError(\"Can not submit login form\")\n        if raw_res.status != 302:\n            raise PyEboxError(\"Bad HTTP status code\")\n        # search for errors\n        re_results = re.search(r\"err=[^&]*&\", raw_res.headers.get('Location'))\n        if re_results:\n            await self._handle_login_error(raw_res.headers.get('Location'))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the latest data from EBox.", "response": "async def fetch_data(self):\n        \"\"\"Get the latest data from EBox.\"\"\"\n        # Get http session\n        await self._get_httpsession()\n        # Get login page\n        token = await self._get_login_page()\n        # Post login page\n        await self._post_login_page(token)\n        # Get home data\n        home_data = await self._get_home_data()\n        # Get usage data\n        usage_data = await self._get_usage_data()\n        # Merge data\n        self._data.update(home_data)\n        self._data.update(usage_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites your backwards methods here.", "response": "def backwards(self, orm):\n        \"Write your backwards methods here.\"\n        orm['avocado.DataField'].objects.filter(Q(model_name='thousandg', field_name='af') |\n            Q(model_name='evs', field_name='all_maf'),\n            app_name='variants').update(translator=None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef event_before_read_docs(app, env, _):\n    client_id = app.config['imgur_client_id']\n    if not client_id:\n        raise ExtensionError('imgur_client_id config value must be set for Imgur API calls.')\n    if not RE_CLIENT_ID.match(client_id):\n        raise ExtensionError('imgur_client_id config value must be 5-30 lower case hexadecimal characters only.')\n\n    imgur_album_cache = getattr(env, 'imgur_album_cache', None)\n    imgur_image_cache = getattr(env, 'imgur_image_cache', None)\n    env.imgur_album_cache, env.imgur_image_cache = initialize(imgur_album_cache, imgur_image_cache, (), ())\n    prune_cache(env.imgur_album_cache, env.imgur_image_cache, app)", "response": "Called by Sphinx before phase 1."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef event_doctree_read(app, doctree):\n    albums, images = set(), set()\n    for node in (n for c in (ImgurTextNode, ImgurImageNode) for n in doctree.traverse(c)):\n        if node.album:\n            albums.add(node.imgur_id)\n        else:\n            images.add(node.imgur_id)\n    initialize(app.builder.env.imgur_album_cache, app.builder.env.imgur_image_cache, albums, images)", "response": "Called by Sphinx during phase 1 ( reading."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef event_env_merge_info(app, env, _, other):\n    other_album_cache = getattr(other, 'imgur_album_cache', None)\n    other_image_cache = getattr(other, 'imgur_image_cache', None)\n    if not other_album_cache and not other_image_cache:\n        return\n    album_cache = app.builder.env.imgur_album_cache\n    image_cache = app.builder.env.imgur_image_cache\n    assert env  # Linting.\n\n    # Merge items.\n    album_cache.update(other_album_cache)\n    image_cache.update(other_image_cache)", "response": "Called by Sphinx during phase 3 ( resolving."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls by Sphinx when the build environment has been updated.", "response": "def event_env_updated(app, env):\n    \"\"\"Called by Sphinx during phase 3 (resolving).\n\n    * Find Imgur IDs that need to be queried.\n    * Query the Imgur API for new/outdated albums/images.\n\n    :param sphinx.application.Sphinx app: Sphinx application object.\n    :param sphinx.environment.BuildEnvironment env: Sphinx build environment.\n    \"\"\"\n    client_id = app.config['imgur_client_id']\n    ttl = app.config['imgur_api_cache_ttl']\n    album_cache = app.builder.env.imgur_album_cache\n    image_cache = app.builder.env.imgur_image_cache\n    album_whitelist = {v.imgur_id for v in album_cache.values() if v.mod_time == 0}\n    image_whitelist = {v.imgur_id for v in image_cache.values() if v.mod_time == 0}\n\n    # Build whitelist of Imgur IDs in just new/updated docs.\n    for doctree in (env.get_doctree(n) for n in app.builder.get_outdated_docs()):\n        for node in (n for c in (ImgurTextNode, ImgurImageNode) for n in doctree.traverse(c)):\n            if node.album:\n                album_whitelist.add(node.imgur_id)\n            else:\n                image_whitelist.add(node.imgur_id)\n\n    # Update the cache only if an added/changed doc has an Imgur album/image.\n    if album_whitelist or image_whitelist:\n        update_cache(album_cache, image_cache, app, client_id, ttl, album_whitelist, image_whitelist)\n        prune_cache(album_cache, image_cache, app)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling by Sphinx after phase 3.", "response": "def event_doctree_resolved(app, doctree, _):\n    \"\"\"Called by Sphinx after phase 3 (resolving).\n\n    * Replace Imgur text nodes with data from the Sphinx cache.\n    * Call finalizer for ImgurImageNode nodes.\n\n    :param sphinx.application.Sphinx app: Sphinx application object.\n    :param docutils.nodes.document doctree: Tree of docutils nodes.\n    :param _: Not used.\n    \"\"\"\n    album_cache = app.builder.env.imgur_album_cache\n    image_cache = app.builder.env.imgur_image_cache\n\n    for node in doctree.traverse(ImgurTextNode):\n        cache = album_cache if node.album else image_cache\n        if node.name == 'imgur-description':\n            text = cache[node.imgur_id].description\n        else:\n            text = cache[node.imgur_id].title\n        node.replace_self([docutils.nodes.Text(text)])\n\n    for node in doctree.traverse(ImgurImageNode):\n        if node.album and not album_cache[node.imgur_id].cover_id:\n            app.warn('Album cover Imgur ID for {} not available in local cache.'.format(node.imgur_id))\n            node.replace_self([docutils.nodes.Text('')])\n        else:\n            node.finalize(album_cache, image_cache, lambda m: app.builder.env.warn_node(m, node))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls by Sphinx during phase 0 (initialization). :param sphinx.application.Sphinx app: Sphinx application object. :param str version: Version of sphinxcontrib-imgur. :returns: Extension metadata. :rtype: dict", "response": "def setup(app, version):\n    \"\"\"Called by Sphinx during phase 0 (initialization).\n\n    :param sphinx.application.Sphinx app: Sphinx application object.\n    :param str version: Version of sphinxcontrib-imgur.\n\n    :returns: Extension metadata.\n    :rtype: dict\n    \"\"\"\n    app.add_config_value('imgur_api_cache_ttl', 172800, False)\n    app.add_config_value('imgur_client_id', None, False)\n    app.add_config_value('imgur_hide_post_details', False, True)\n    app.add_config_value('imgur_target_default_gallery', False, True)\n    app.add_config_value('imgur_target_default_largest', False, True)\n    app.add_config_value('imgur_target_default_page', False, True)\n\n    app.add_directive('imgur-embed', ImgurEmbedDirective)\n    app.add_directive('imgur-image', ImgurImageDirective)\n    app.add_node(ImgurEmbedNode, html=(ImgurEmbedNode.visit, ImgurEmbedNode.depart))\n    app.add_node(ImgurImageNode, html=(ImgurImageNode.visit, ImgurImageNode.depart))\n    app.add_node(ImgurJavaScriptNode, html=(ImgurJavaScriptNode.visit, ImgurJavaScriptNode.depart))\n    app.add_role('imgur-description', imgur_role)\n    app.add_role('imgur-title', imgur_role)\n\n    app.connect('env-before-read-docs', event_before_read_docs)\n    app.connect('doctree-read', event_doctree_read)\n    app.connect('env-merge-info', event_env_merge_info)\n    app.connect('env-updated', event_env_updated)\n    app.connect('doctree-resolved', event_doctree_resolved)\n\n    return dict(parallel_read_safe=True, version=version)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        orm['avocado.DataField'].objects.get_or_create(\n            app_name='variants',\n            model_name='variantphenotype',\n            field_name='hgmd_id',\n            defaults={\n                'name': 'HGMD',\n                'published': True\n            })", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put(self, event_type, event_data={}, **kwargs):\n        event = dict(type=event_type, data=event_data)\n\n        event[\"time\"] = kwargs.get(\"time\", datetime.utcnow().isoformat())\n\n        if kwargs.get(\"id\"):\n            event[\"id\"] = kwargs.get(\"id\")\n\n        data = json.dumps([event])\n\n        r = requests.post(self.collector_url + 'event/put',\n                          data=data,\n                          headers={'content-type': 'application/json'})\n        r.raise_for_status()\n\n        return [event]", "response": "Create or update an event."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms a query on the evaluator endpoint", "response": "def make_query(self, query_type, expression, **kwargs):\n        \"\"\"\n        Actually perform the query,\n        try to convert datetime to isoformat on the fly\n        \"\"\"\n        data = dict(expression=str(expression),\n                    stop=kwargs.get('stop', datetime.utcnow()))\n        data.update(kwargs)\n\n        for k in ['start', 'stop']:\n            if k in data:\n                try:\n                    data[k] = data[k].isoformat()\n                except AttributeError:\n                    pass\n\n        r = requests.get(self.evaluator_url + query_type, params=data)\n        r.raise_for_status()\n\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of the known event types", "response": "def types(self):\n        \"\"\"\n        List of the known event types\n        \"\"\"\n        r = requests.get(self.evaluator_url + 'types')\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sorted_chain(*ranges: Iterable[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return sorted(itertools.chain(*ranges))", "response": "Chain & sort ranges."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute a validation score for the possible match.", "response": "def authors_titles_validator(record, result):\n    \"\"\"Compute a validation score for the possible match.\n\n    The score is based on a similarity score of the authors sets and the maximum Jaccard index found between 2 titles:\n    one from the record and one from the result title sets.\n\n    If the computed score is higher than 0.5, then the match is valid, otherwise it is not.\n\n    Args:\n        record (dict): the given record we are trying to match with similar ones in INSPIRE.\n        result (dict): possible match returned by the ES query that needs to be validated.\n\n    Returns:\n        bool: validation decision.\n\n    \"\"\"\n    record_authors = get_value(record, 'authors', [])\n    result_authors = get_value(result, '_source.authors', [])\n\n    author_score = compute_author_match_score(record_authors, result_authors)\n\n    title_max_score = 0.0\n    record_titles = get_value(record, 'titles.title', [])\n    result_titles = get_value(result, '_source.titles.title', [])\n\n    for cartesian_pair in product(record_titles, result_titles):\n        record_title_tokens = get_tokenized_title(cartesian_pair[0])\n        result_title_tokens = get_tokenized_title(cartesian_pair[1])\n        current_title_jaccard = compute_jaccard_index(record_title_tokens, result_title_tokens)\n\n        if current_title_jaccard > title_max_score and current_title_jaccard >= 0.5:\n            title_max_score = current_title_jaccard\n\n    return (author_score + title_max_score) / 2 > 0.5"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cds_identifier_validator(record, result):\n\n    record_external_identifiers = get_value(record, 'external_system_identifiers', [])\n    result_external_identifiers = get_value(result, '_source.external_system_identifiers', [])\n\n    record_external_identifiers = {external_id[\"value\"] for external_id in record_external_identifiers if external_id[\"schema\"] == 'CDS'}\n    result_external_identifiers = {external_id[\"value\"] for external_id in result_external_identifiers if external_id[\"schema\"] == 'CDS'}\n\n    return bool(record_external_identifiers & result_external_identifiers)", "response": "Validates that two records have the same CDS identifier."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a QLabel contaning text to the given menu", "response": "def addMenuLabel(menu, text):\n    \"\"\"Adds a QLabel contaning text to the given menu\"\"\"\n    qaw = QWidgetAction(menu)\n    lab = QLabel(text, menu)\n    qaw.setDefaultWidget(lab)\n    lab.setAlignment(Qt.AlignCenter)\n    lab.setFrameShape(QFrame.StyledPanel)\n    lab.setFrameShadow(QFrame.Sunken)\n    menu.addAction(qaw)\n    return lab"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iterator(self, *args):\n        if len(args) > 1:\n            return ClickableTreeWidget.Iterator(*args)\n        else:\n            return ClickableTreeWidget.Iterator(self, *args)", "response": "Returns an iterator for the tree widget itself and the item itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iter_pest(self, seq, molwts):\n        ltkdhi = dict(zip('ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n                           [63, 10, 70, 10, 10, 72, 41, 13, 90, 0, 6, 82, 64, 10, 0, 29, 10,\n                            0, 36, 38, 0, 87, 36, 45, 58, 10]))\n        for fr, to in self.iter_candidates(seq):\n            cnt = Counter(islice(seq, fr, to))  # islice to prevent copying\n            if self.is_valid_pest(cnt):\n                molwt = sum(molwts[seq[i]][self.mono] for i in range(fr, to))\n                pstsum = sum(cnt[k] * molwts[k][self.mono] for k in 'DEPST')\n                pstsum -= sum(molwts[k][self.mono] for k in 'EPT')\n                pstpct = pstsum / molwt\n                hydind = sum(v * molwts[k][self.mono] * ltkdhi[k] / molwt for k, v in cnt.items())\n                pstscr = 0.55 * pstpct - 0.5 * hydind\n                yield pstscr, (fr, to)", "response": "Iterate over the candidate pest and other pest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the Party Prefix Country Code Party Suffix and Branch Code as a tuple.", "response": "def elements(self):\n        \"\"\"Return the BIC's Party Prefix, Country Code, Party Suffix and\n        Branch Code as a tuple.\"\"\"\n        return (self.party_prefix, self.country_code, self.party_suffix,\n                self.branch_code)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the IBAN s Bank Identifier.", "response": "def bank_identifier(self):\n        \"\"\"Return the IBAN's Bank Identifier.\"\"\"\n        end = get_iban_spec(self.country_code).bban_split_pos + 4\n        return self._id[4:end]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the IBAN s Bank Account Number.", "response": "def bank_account_number(self):\n        \"\"\"Return the IBAN's Bank Account Number.\"\"\"\n        start = get_iban_spec(self.country_code).bban_split_pos + 4\n        return self._id[start:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef elements(self):\n        return (self.country_code, self.check_digits, self.bank_identifier,\n                self.bank_account_number)", "response": "Return the IBAN s Country Code check digits Bank Identifier and Bank Account Number as tuple."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, filename):\n        self.filename = filename\n        with open(filename) as CFG:\n            self.data = yaml.load(CFG.read())\n\n        return self", "response": "read configdata from file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscheduling or reschedule the next heartbeat.", "response": "def schedule(self):\n        \"\"\"Schedule or reschedule the next heartbeat.\"\"\"\n        if self.stopped:\n            raise RuntimeError(\"Can't schedule stopped heartbeat\")\n\n        if self.pendingHeartbeat is None:\n            self._createHeartbeatCall()\n        else:\n            self.pendingHeartbeat.reset(self.period)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stop(self):\n        if not self.stopped:\n            self.stopped = True\n            if self.pendingHeartbeat is not None:\n                self.pendingHeartbeat.cancel()\n                self.pendingHeartbeat = None", "response": "Permanently stop sending heartbeats."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef withHeartbeater(cls, heartbeater):\n        instance = cls(heartbeater)\n        heartbeater.writeHeartbeat = instance.heartbeat\n        return instance", "response": "Connect a SockJSProtocolMachine to its heartbeater."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _connectionEstablished(self, transport):\n        '''Store a reference to our transport and write an open frame.'''\n        self.transport = transport\n        self.transport.writeOpen()\n        self.heartbeater.schedule()", "response": "Store a reference to our transport and write an open frame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _writeToTransport(self, data):\n        '''Frame the array-like thing and write it.'''\n        self.transport.writeData(data)\n        self.heartbeater.schedule()", "response": "Frame the array - like thing and write it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting a close frame with the given reason and schedule this connection close.", "response": "def _writeCloseFrame(self, reason=DISCONNECT.GO_AWAY):\n        '''Write a close frame with the given reason and schedule this\n        connection close.\n\n        '''\n        self.transport.writeClose(reason)\n        self.transport.loseConnection()\n        self.transport = None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _stopHeartbeatWithReason(self, reason=DISCONNECT.GO_AWAY):\n        '''We lost our connection - stop our heartbeat.  This runs when the\n        protocol wants a disconnection.\n\n        This redundant output ensures that the heartbeater stops\n        immediately after the connection is lost.  Twisted will call\n        connectionLost after loseConnection, but between the two the\n        heartbeat-writing callback may run, after the transport's been\n        lost.  Relying on connectionLost to cancel our\n        callback thus creates a race condition.\n\n        '''\n        self.heartbeater.stop()\n        self.heartbeater = None", "response": "We lost our connection - stop our heartbeat.  This runs when the\n        protocol wants a disconnection.\n\n        This redundant output ensures that the heartbeater stops\n        immediately after the connection is lost.  Twisted will call\n        connectionLost after loseConnection, but between the two the\n        heartbeat-writing callback may run, after the transport's been\n        lost.  Relying on connectionLost to cancel our\n        callback thus creates a race condition."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _flushBuffer(self, request):\n        '''Flush any pending data from the buffer to the request'''\n        assert request is self.requestSession.request\n        self.requestSession.writeData(self.buffer)\n        self.buffer = []", "response": "Flush any pending data from the buffer to the request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_priority(ratios=None, **kwargs):\n    \"Calculates a priority score based on a number of attributes.\"\n    if not ratios:\n        ratios = PRIORITY_FEATURE_WEIGHTS\n    scores = [DEFAULT_PRIORITY_SCORE]\n    for key, value in kwargs.items():\n        if key not in PRIORITY_FEATURE_WEIGHTS:\n            raise KeyError('The following keyword arguments are supported: '\n                           '{keys}'.format(keys=PRIORITY_FEATURES))\n        if value is True:\n            scores.append(PRIORITY_FEATURE_WEIGHTS[key])\n    return float(sum(scores)) / len(scores)", "response": "Calculates a priority score based on a number of attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef adrest_include(parser, token):\n    bits = token.split_contents()[1:]\n    args, kwargs = parse_bits(\n        parser, bits, ['content'], 'args', 'kwargs', tuple(),\n        False, 'adrest_include')\n    return AdrestInclusionNode(False, args, kwargs)", "response": "Include adrest_template for any objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef adrest_jsonify(content, **options):\n    from adrest.utils.serializer import JSONSerializer\n    worker = JSONSerializer(**options)\n    return worker.serialize(content)", "response": "Serialize any object to JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, context):\n        try:\n            args, ctx = self.get_resolved_arguments(context)\n            target = args[0]\n            if not target:\n                return ''\n            ctx['content'] = target\n        except VariableDoesNotExist:\n            return ''\n\n        emitter = context.get('emitter')\n        t_name = emitter.get_template_path(target)\n        t = get_template(t_name)\n        context.dicts.append(ctx)\n        response = t.nodelist.render(context)\n        context.pop()\n        return response", "response": "Render node.\n\n        :return str: Rendered string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of the named arguments on the current object.", "response": "def set(self, *args, **kwargs):\n        ''' Usage is either:\n\n            set(self, qfield, value): Atomically set ``qfield`` to ``value``\n\n            OR\n\n            set(key1=value1, key2=value2): Atomically set the named arguments\n            on the current object to the values given.  This form cannot\n            update a sub-document\n            '''\n        if len(args) == 2:\n            qfield, value = args\n            return self._atomic_op('$set', qfield, value)\n        elif len(kwargs) != 0:\n            ret = self\n            for key, value in kwargs.items():\n                ret = ret._atomic_op('$set', key, value)\n            return ret\n        else:\n            raise UpdateException('Invalid arguments for set.  Requires either two positional arguments or at least one keyword argument')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inc(self, *args, **kwargs):\n        ''' Atomically increment ``qfield`` by ``value`` '''\n        pairs = []\n        if len(args) == 1:\n            pairs.append((args[0], 1))\n        elif len(args) == 2:\n            pairs.append(args)\n        elif len(kwargs) != 0:\n            pairs.extend([(k, v) for k, v in kwargs.items()])\n        else:\n            raise UpdateException('Invalid arguments for set.  Requires either two positional arguments or at least one keyword argument')\n\n        ret = self\n        for qfield, value in pairs:\n            ret = self._atomic_op('$inc', qfield, value)\n        return ret", "response": "Atomically increment the value of the current entry in the current entry set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, qfield, value):\n        ''' Atomically remove ``value`` from ``qfield``'''\n        if isinstance(value, QueryExpression):\n            return self._atomic_expression_op('$pull', qfield, value)\n        return self._atomic_list_op('$pull', qfield, value)", "response": "Atomically remove value from qfield"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        # Project labels\n        names = list(orm['samples.Project'].objects.values_list('label', flat=True))\n        orm['samples.Cohort'].objects.filter(name__in=names).update(published=True)\n\n        # World cohort\n        orm['samples.Cohort'].objects.filter(name=DEFAULT_COHORT_NAME).update(published=True)", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds interface to Quartus TCL by specified name or dict of subinterfaces.", "response": "def _asQuartusTcl(self, buff: List[str], version: str, intfName: str,\n                      component: \"Component\", packager: \"IpPackager\",\n                      thisIf: 'Interface', intfMapOrName: Dict[str, Union[Dict, str]]):\n        \"\"\"\n        Add interface to Quartus tcl by specified name map\n\n        :param buff: line buffer for output\n        :param version: Quartus version\n        :param intfName: name of top interface\n        :param component: component object from ipcore generator\n        :param packager: instance of IpPackager which is packagin current design\n        :param thisIf: interface to add into Quartus TCL\n        :param intfMapOrName: Quartus name string for this interface\n            or dictionary to map subinterfaces\n        \"\"\"\n\n        if isinstance(intfMapOrName, str):\n            self.quartus_add_interface_port(\n                buff, intfName, thisIf, intfMapOrName, packager)\n        else:\n            for thisIf_ in thisIf._interfaces:\n                v = intfMapOrName[thisIf_._name]\n                self._asQuartusTcl(buff, version, intfName, component,\n                                   packager, thisIf_, v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef asQuartusTcl(self, buff: List[str], version: str, component: \"Component\",\n                     packager: \"IpPackager\", thisIf: 'Interface'):\n        \"\"\"\n        Add interface to Quartus tcl\n\n        :param buff: line buffer for output\n        :param version: Quartus version\n        :param intfName: name of top interface\n        :param component: component object from ipcore generator\n        :param packager: instance of IpPackager which is packagin current design\n        :param allInterfaces: list of all interfaces of top unit\n        :param thisIf: interface to add into Quartus TCL\n        \"\"\"\n        name = packager.getInterfaceLogicalName(thisIf)\n        self.quartus_tcl_add_interface(buff, thisIf, packager)\n        clk = thisIf._getAssociatedClk()\n        if clk is not None:\n            self.quartus_prop(buff, name, \"associatedClock\",\n                              clk._sigInside.name, escapeStr=False)\n        rst = thisIf._getAssociatedRst()\n        if rst is not None:\n            self.quartus_prop(buff, name, \"associatedReset\",\n                              rst._sigInside.name, escapeStr=False)\n\n        m = self.get_quartus_map()\n        if m:\n            intfMapOrName = m\n        else:\n            intfMapOrName = thisIf.name\n        self._asQuartusTcl(buff, version, name, component,\n                           packager, thisIf, intfMapOrName)", "response": "This function adds an interface to Quartus TCL and returns the Quartus TCL entry in the output list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef quartus_tcl_add_interface(self, buff, thisIntf, packager):\n        if packager.getInterfaceDirection(thisIntf) == INTF_DIRECTION.MASTER:\n            dir_ = \"start\"\n        else:\n            dir_ = \"end\"\n\n        name = packager.getInterfaceLogicalName(thisIntf)\n        buff.extend([\"add_interface %s %s %s\" % \n                     (name, self.get_quartus_name(), dir_)])\n\n        self.quartus_prop(buff, name, \"ENABLED\", True)\n        self.quartus_prop(buff, name, \"EXPORT_OF\", \"\")\n        self.quartus_prop(buff, name, \"PORT_NAME_MAP\", \"\")\n        self.quartus_prop(buff, name, \"CMSIS_SVD_VARIABLES\", \"\")\n        self.quartus_prop(buff, name, \"SVD_ADDRESS_GROUP\", \"\")", "response": "Create interface in Quartus TCL"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting property on Quartus TCL object", "response": "def quartus_prop(self, buff: List[str], intfName: str, name: str, value,\n                     escapeStr=True):\n        \"\"\"\n        Set property on interface in Quartus TCL\n\n        :param buff: line buffer for output\n        :param intfName: name of interface to set property on\n        :param name: property name\n        :param value: property value\n        :param escapeStr: flag, if True put string properties to extra \"\"\n        \"\"\"\n        if escapeStr and isinstance(value, str):\n            value = '\"%s\"' % value\n        elif isinstance(value, bool):\n            value = str(value).lower()\n        else:\n            value = str(value)\n\n        buff.append(\"set_interface_property %s %s %s\" % \n                    (intfName, name, value))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef quartus_add_interface_port(self, buff: List[str], intfName: str, signal,\n                                   logicName: str, packager: \"IpCorePackager\"):\n        \"\"\"\n        Add subinterface to Quartus interface\n\n        :param buff: line buffer for output\n        :param intfName: name of top interface\n        :param signal: subinterface to create port for\n        :param logicName: name of port in Quartus\n        \"\"\"\n        d = signal._direction\n        if d == INTF_DIRECTION.MASTER:\n            dir_ = \"Output\"\n        elif d == INTF_DIRECTION.SLAVE:\n            dir_ = \"Input\"\n        else:\n            raise ValueError(d)\n\n        _, width, _ = packager.getTypeWidth(packager.getInterfaceType(signal), do_eval=True)\n\n        buff.append(\"add_interface_port %s %s %s %s %s\" % (\n            intfName,\n            packager.getInterfacePhysicalName(signal),\n            logicName,\n            dir_,\n            width\n        ))", "response": "Add subinterface to Quartus interface\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a record is valid for processing.", "response": "def record_is_valid(record):\n    \"Checks if a record is valid for processing.\"\n\n    # No random contigs\n    if record.CHROM.startswith('GL'):\n        return False\n\n    # Skip results with a read depth < 5. If no read depth is specified then\n    # we have no choice but to consider this record as being valid.\n    if 'DP' in record.INFO and record.INFO['DP'] < 5:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a copy of the current environment with the values present in extra_env.", "response": "def extend_env(extra_env):\n    \"\"\"\n    Copies and extends the current environment with the values present in\n    `extra_env`.\n    \"\"\"\n    env = os.environ.copy()\n    env.update(extra_env)\n    return env"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a string representation of a dict as though it contained environment variable values.", "response": "def get_env_str(env):\n    \"\"\"\n    Gets a string representation of a dict as though it contained environment\n    variable values.\n    \"\"\"\n    return ' '.join(\"{0}='{1}'\".format(k, v) for k, v in env.items())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pipe_commands(cmds, extra_env=None, show_stderr=False, show_last_stdout=False):\n    env = extend_env(extra_env) if extra_env else None\n    env_str = (get_env_str(extra_env) + ' ') if extra_env else ''\n    cmd_strs = [env_str + ' '.join(cmd) for cmd in cmds]\n\n    logger.info('Running `{0}`'.format(' | '.join(cmd_strs)))\n\n    with open('/dev/null', 'w') as NULL:\n        # Start processes\n        processes = []\n        last_i = len(cmds) - 1\n        for i, (cmd_str, cmd) in enumerate(zip(cmd_strs, cmds)):\n            if i == last_i:\n                p_stdout = None if show_last_stdout else NULL\n            else:\n                p_stdout = PIPE\n            p_stdin = processes[-1][1].stdout if processes else None\n            p_stderr = None if show_stderr else NULL\n\n            p = Popen(cmd, env=env, stdout=p_stdout, stdin=p_stdin, stderr=p_stderr)\n            processes.append((cmd_str, p))\n\n        # Close processes\n        error = False\n        for cmd_str, p in processes:\n            if p.stdout:\n                p.stdout.close()\n            if p.wait() != 0:\n                error = True\n        if error:\n            raise CalledProcessError(cmd=cmd_str, returncode=p.returncode)", "response": "Executes a list of commands piping each one into the next."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting a list of commands and writes the stdout of the last process into a file at the given path.", "response": "def pipe_commands_to_file(cmds, path, extra_env=None, show_stderr=False):\n    \"\"\"\n    Executes the list of commands piping each one into the next and writing\n    stdout of the last process into a file at the given path.\n    \"\"\"\n    env = extend_env(extra_env) if extra_env else None\n    env_str = (get_env_str(extra_env) + ' ') if extra_env else ''\n    cmd_strs = [env_str + ' '.join(cmd) for cmd in cmds]\n\n    logger.info('Saving output of `{0}`'.format(' | '.join(cmd_strs)))\n\n    with open('/dev/null', 'w') as NULL:\n        # Start processes\n        processes = []\n        for cmd_str, cmd in zip(cmd_strs, cmds):\n            p_stdin = processes[-1][1].stdout if processes else None\n            p_stderr = None if show_stderr else NULL\n\n            p = Popen(cmd, env=env, stdout=PIPE, stdin=p_stdin, stderr=p_stderr)\n            processes.append((cmd_str, p))\n\n        p_last = processes[-1][1]\n\n        with open(path, 'wb') as f:\n            shutil.copyfileobj(p_last.stdout, f)\n\n            # Close processes\n            error = False\n            for cmd_str, p in processes:\n                p.stdout.close()\n                if p.wait() != 0:\n                    error = True\n            if error:\n                raise CalledProcessError(cmd=cmd_str, returncode=p.returncode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a closure which takes a property and tests it against arbitrary set of instances of generators.", "response": "def for_all(*generators):\n    \"\"\"\n    Takes a list of generators and returns a closure which takes a property,\n    then tests the property against arbitrary instances of the generators.\n    \"\"\"\n    # Pass in n as an argument\n    n = 100\n\n    def test_property(property_function):\n        \"\"\"\n        A closure which takes a property and tests it against arbitrary\n        instances of the generators in the closure.\n        \"\"\"\n        for generator in generators:\n            assert (issubclass(generator, ArbitraryInterface)\n                    or generator in arbitrary)\n\n        def test_once():\n            \"\"\"\n            Tests the property against a single set of instances of the\n            generators.\n            \"\"\"\n            instances = [arbitrary(generator) for generator in generators]\n            try:\n                assert property_function(*instances)\n            except AssertionError:\n                generator_names = ', '.join(\n                    generator.__name__ for generator in generators)\n                stringed_instances = ', '.join(\n                    str(instance) for instance in instances)\n                error_message = ' '.join([\n                    'Instances <', stringed_instances, '> of <',\n                    generator_names, '> do not satisfy a property.'\n                ])\n                raise AssertionError(error_message)\n\n        for _ in range(n):\n            test_once()\n\n    return test_property"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate either an arbitrary value of the specified generator or None. This is a class factory, it makes a class which is a closure around the specified generator.", "response": "def maybe_a(generator):\n    \"\"\"\n    Generates either an arbitrary value of the specified generator or None.\n    This is a class factory, it makes a class which is a closure around the\n    specified generator.\n    \"\"\"\n\n    class MaybeAGenerator(ArbitraryInterface):\n        \"\"\"\n        A closure class around the generator specified above, which generates\n        either that generator or None.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate either the enclosed generator or None.\n            \"\"\"\n            return arbitrary(one_of(None, generator))\n\n    MaybeAGenerator.__name__ = ''.join(['maybe_a(', generator.__name__, ')'])\n    return MaybeAGenerator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef one_of(*generators):\n\n    class OneOfGenerators(ArbitraryInterface):\n        \"\"\"\n        A closure class around the generators specified above, which\n        generates one of the generators.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate one of the enclosed generators.\n            \"\"\"\n            return arbitrary(random.choice(generators))\n\n    OneOfGenerators.__name__ = ''.join([\n        'one_of(', ', '.join(generator.__name__ for generator in generators),\n        ')'\n    ])\n    return OneOfGenerators", "response": "Generates an arbitrary value of one of the specified generators."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tuple_of(*generators):\n\n    class TupleOfGenerators(ArbitraryInterface):\n        \"\"\"\n        A closure class around the generators specified above, which\n        generates a tuple of the generators.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate a tuple of the enclosed generators.\n            \"\"\"\n            return tuple([\n                arbitrary(generator) for generator in generators\n                if generator is not tuple\n            ])\n\n    TupleOfGenerators.__name__ = ''.join([\n        'tuple_of(', ', '.join(generator.__name__ for generator in generators),\n        ')'\n    ])\n    return TupleOfGenerators", "response": "A class factory for generating a tuple of generators."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a set consisting solely of the specified generators. This is a class factory, it makes a class which is a closure around the specified generators.", "response": "def set_of(*generators):\n    \"\"\"\n    Generates a set consisting solely of the specified generators.\n    This is a class factory, it makes a class which is a closure around the\n    specified generators.\n    \"\"\"\n\n    class SetOfGenerators(ArbitraryInterface):\n        \"\"\"\n        A closure class around the generators specified above, which\n        generates a set of the generators.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate a set of the enclosed generators.\n            \"\"\"\n            arbitrary_set = set()\n            for generator in generators:\n                arbitrary_set |= {\n                    arbitrary(generator)\n                    # max_size / len(generators):\n                    for _ in range(arbitrary(int) % 100)\n                }\n            return arbitrary_set\n\n    SetOfGenerators.__name__ = ''.join([\n        'set_of(', ', '.join(generator.__name__ for generator in generators),\n        ')'\n    ])\n    return SetOfGenerators"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a list consisting solely of the specified generators. This is a class factory, it makes a class which is a closure around the specified generators.", "response": "def list_of(*generators):\n    \"\"\"\n    Generates a list consisting solely of the specified generators.\n    This is a class factory, it makes a class which is a closure around the\n    specified generators.\n    \"\"\"\n\n    class ListOfGenerators(ArbitraryInterface):\n        \"\"\"\n        A closure class around the generators specified above, which\n        generates a list of the generators.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate a list of the enclosed generators.\n            \"\"\"\n            arbitrary_list = []\n            for generator in generators:\n                arbitrary_list += [\n                    arbitrary(generator)\n                    # max_length / len(generators):\n                    for _ in range(arbitrary(int) % 100)\n                ]\n            return arbitrary_list\n\n    ListOfGenerators.__name__ = ''.join([\n        'list_of(', ', '.join(generator.__name__ for generator in generators),\n        ')'\n    ])\n    return ListOfGenerators"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a homogeneous dict of the specified generators using kwargs. You can generate non-homogeneous dicts using `dict`. This is a class factory, it makes a class which is a closure around the specified keys and generators.", "response": "def dict_of(**kwargs):\n    \"\"\"\n    Generates a homogeneous dict of the specified generators using kwargs.\n    You can generate non-homogeneous dicts using `dict`.\n    This is a class factory, it makes a class which is a closure around the\n    specified keys and generators.\n    \"\"\"\n\n    class DictOfKeyGenerators(ArbitraryInterface):\n        \"\"\"\n        A closure class around the keys and generators specified above, which\n        generates a dict of the keys and generators.\n        \"\"\"\n\n        @classmethod\n        def arbitrary(cls):\n            \"\"\"\n            Generate a dict of the enclosed keys and generators.\n            \"\"\"\n            return {\n                key: arbitrary(generator)\n                for key, generator in kwargs.iteritems()\n            }\n\n    DictOfKeyGenerators.__name__ = ''.join([\n        'dict_of(', ', '.join([\n            key + '=' + generator.__name__\n            for key, generator in kwargs.iteritems()\n        ]), ')'\n    ])\n    return DictOfKeyGenerators"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __make_skeleton(self, path):\n        \n        self.path = path\n        if os.path.exists(os.path.join(self.path, \"output\", self.name)):\n            shutil.rmtree(os.path.join(self.path, \"output\", self.name))\n        \n        self.path_folders = os.path.join(self.path, \"output\", self.name, \"site\", \"static\")\n        os.makedirs(self.path_folders)\n        \n        self.path_folders = os.path.join(self.path, \"output\", self.name, \"site\", \"static\", \"css\")\n        os.makedirs(self.path_folders)\n        \n        self.path_folders = os.path.join(self.path, \"output\", self.name, \"site\", \"static\", \"js\")\n        os.makedirs(self.path_folders)\n        \n        for key in self.sections:\n            self.path_folders = os.path.join(self.path, \"output\", self.name, \"site\", key)\n            os.makedirs(self.path_folders)", "response": "This method creates the folder tree which will contain the website."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __save_plots_of_the_current_page(self, section, page, output_path):\n        \n        for key in self.sections[section].pages[page].elements.keys():\n            print(section, page, key) # debug print\n            \n            buf_temp = self.sections[section].pages[page].elements[key].plot_object\n            if buf_temp is not None :\n\n                plot_path = os.path.join(output_path, \"output\", self.name, \"site\", section, key + \".svg\")\n                \n                \n                try :\n                    my_file = open(plot_path, \"wb\")\n                    my_file.write(buf_temp)\n                    my_file.close()\n                except Exception as e:\n                    print (e)\n                    print (\"In {section} and {page}, an element exists without a valid plot object.\".format(section = section, page = page))", "response": "This method saves plots in the appropriate section folder."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __get_plots_of_the_current_page(self, section, page):\n        \n        plots = []\n        structure = [len(x) for x in self.sections[section].pages[page].layout]\n        for key in self.sections[section].pages[page].elements.keys():\n            if self.sections[section].pages[page].elements[key].plot_object is None:\n                plots.append(None)\n            else:\n                plots.append(self.sections[section].pages[page].elements[key].name)\n\n\n        plots_sub = []\n        for idx, i in enumerate(list(accumulate(structure))):\n            if idx == 0:\n                plots_sub.append(plots[0:i])\n            else :\n                plots_sub.append(plots[list(accumulate(structure))[idx - 1]:i])\n\n        return plots_sub", "response": "This method returns a list of all plots that are in the current page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __create_template_vars(self, section, page):\n        \n        template_vars = {}\n        template_vars[\"index\"] = False\n        \n        template_vars[\"name\"] = self.name\n        template_vars[\"title\"] = self.title\n        template_vars[\"main_display\"] = self.display\n        template_vars[\"display_message\"] = self.display_message\n        \n        template_vars[\"home_page_name\"] = self.HomeName\n        template_vars[\"current_section\"] = section\n        \n        template_vars[\"index_address\"] = \"../../index.html\"\n        template_vars[\"address_prefix\"] = \"..\"\n        template_vars[\"nav_bar_right_side\"] = self.nav_bar_right_side\n        # Get the number of rows and how elements are organised\n        template_vars[\"layout\"] = self.__get_layout_of_the_current_page(section, page)\n        template_vars[\"headings\"] = self.__get_headings_of_the_current_page(section, page)\n        \n        # Plots, comments and table :\n        template_vars[\"plots\"] = self.__get_plots_of_the_current_page(section, page)\n        template_vars[\"comments_below\"] = self.__get_below_comment_of_the_current_page(section, page)\n        template_vars[\"comments_above\"] = self.__get_above_comment_of_the_current_page(section, page)\n        template_vars[\"tables\"] = self.__get_table_of_the_current_page(section, page)\n\n        # Sections\n        template_vars[\"sections\"], template_vars[\"pages\"], template_vars[\"pages_len\"] = self.__create_lists_for_nav_bar()\n\n        # footer\n        template_vars[\"footer\"] = self.footer\n\n        #Css and JS\n        template_vars[\"bootstrap_min_css\"] = \"../static/css/bootstrap.min.css\"\n        template_vars[\"jumbotron_css\"] = \"../static/css/jumbotron.css\"\n        template_vars[\"bootstrap_js\"] = \"../static/js/bootstrap.min.js\"\n        \n        return template_vars", "response": "This method creates the template_vars dictionary for the current page and creates the page_name and page_name_prefix"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_table(self, dataframe, isStyled = False):\n\n        if isStyled :\n            table_string = dataframe.render()\n        else :\n            table_string = dataframe.style.render()\n            \n        table_string = table_string.replace(\"\\n\", \"\").replace(\"<table\", \"\"\"<table class = \"table table-sm table-hover\" \"\"\").replace(\"<thead>\", \"\"\"<thead class=\"thead-inverse\">\"\"\")\n        self.table = table_string", "response": "This method stores plain html string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cache_invalidate_by_tags(tags, cache=None):\n    if isinstance(tags, basestring):\n        tags = [tags]\n    tag_keys = [CACHE_TAG_KEY % tag for tag in tags if tag]\n    if not tag_keys:\n        raise ValueError('Attr tags invalid')\n    if cache is None:\n        cache = default_cache\n    tag_keys_for_delete = []\n    if cache.__class__.__name__ == 'RedisCache':\n        from django_redis.exceptions import ConnectionInterrupted\n        try:\n            redis_client = cache.client.get_client()\n            for tag_key in tag_keys:\n                keys = redis_client.smembers(tag_key)\n                if keys:\n                    cache.delete_many(keys)\n                    tag_keys_for_delete.append(tag_key)\n        except ConnectionInterrupted:\n            pass  # todo add logging\n    else:\n        for tag_key in tag_keys:\n            keys = cache.get(tag_key)\n            if keys:\n                cache.delete_many(keys)\n                tag_keys_for_delete.append(tag_key)\n    if tag_keys_for_delete:\n        cache.delete_many(tag_keys_for_delete)", "response": "Clear cache by tags."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the ASCII art from the image.", "response": "def display_output(arguments):\n    '''Display the ASCII art from the image.'''\n    global _ASCII\n    if arguments['--alt-chars']:\n        _ASCII=_ASCII_2\n    try:\n        im = Image.open(arguments['FILE'])\n    except:\n        raise IOError('Unable to open the file.')\n    im = im.convert(\"RGBA\")\n    aspect_ratio    = float(im.size[0])/im.size[1]\n    scaled_height   = _WIDTH / aspect_ratio\n    scaled_width    = _HEIGHT * aspect_ratio*2\n\n    if scaled_width > _WIDTH:\n        width = int(_WIDTH)\n        height = int(scaled_height/2)\n\n    elif scaled_height > _HEIGHT:\n        width = int(scaled_width)\n        height = int(_HEIGHT)\n\n    if arguments['--width']:\n        width = int(arguments['--width'])\n        height = int(width / aspect_ratio / 2)\n\n    elif arguments['--height']:\n        height = int(arguments['--height'])\n        width = int(height * aspect_ratio * 2)\n\n    if arguments['--width'] and arguments['--height']:\n        height = int(arguments['--height'])\n        width = int(arguments['--width'])\n\n    im = im.resize((width,height),resample=Image.ANTIALIAS)\n\n    enhancer = ImageEnhance.Contrast(im)\n    im = enhancer.enhance(float(arguments['--contrast']))\n    img = im.getdata()\n    im = im.convert('L') #Grayscale\n\n    if not arguments['--invert']:\n        _ASCII = _ASCII[::-1]\n\n    bg=None;\n    if arguments['--bg']=='BLACK':\n        bg=rgb(0,0,0)\n        fg=rgb(5,5,5)\n    elif arguments['--bg']=='WHITE':\n        bg=rgb(5,5,5)\n        fg=rgb(0,0,0)\n\n    row_len=0\n    if arguments['--bold']:\n        bold=True\n    else:\n        bold=False\n    for count,i in enumerate(im.getdata()):\n        ascii_char = _ASCII[int(((i/255.0))*(len((_ASCII))-1))]\n        try:\n            if not arguments['--colors']:\n                raise Exception\n            color = rgb(int((img[count][0]/255.0)*5),int((img[count][1]/255.0)*5),int((img[count][2]/255.0)*5))\n            print_color(ascii_char, end='', fg=color, bg=bg, bold=bold)\n        except:\n            if bg and bold:\n                print_color(ascii_char, end='', fg=fg, bg=bg, bold=bold)\n            elif bold:\n                print_color(ascii_char, end='', bold=bold)\n            elif bg:\n                print_color(ascii_char, end='', fg=fg, bg=bg)\n            else:\n                print(ascii_char, end='')\n        row_len+=1\n        if row_len==width:\n            row_len=0\n            print('')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking an iterable for duplicates and returns a new list of the unique ones.", "response": "def check_dups(\n    iterable,\n    debug_limit=1000,\n):\n    \"\"\" Checks an iterable for duplicates\n\n        Note that it does not make sense to call this on a set()\n\n        If calling on a collection without a .count method,\n        set @debug_limit to -1.\n\n        For custom equality comparisons, create a custom\n        __eq__ and __hash__ method in the class contained in @iterable\n\n    Args:\n        iterable:    An iterable to check for duplicates\n        debug_limit: Don't generate a list of duplicates for the\n                     Exception message if the length of @iterable\n                     is >= this value.  This exists because generating\n                     the list does not scale efficiently.\n    Raises:\n        ValueError: If @iterable contains duplicates\n    \"\"\"\n    if not iterable:\n        return\n    unique = set(iterable)\n    if len(unique) != len(iterable):\n        if len(iterable) < debug_limit:\n            dups = [x for x in unique if iterable.count(x) > 1]\n            msg = \"Duplicate values: {}\".format(dups)\n        else:\n            msg = (\n                \"Duplicate values, not generating list because \"\n                \"len(iterable)={} is greater than debug_limit={}\"\n            ).format(\n                len(iterable),\n                debug_limit,\n            )\n        raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare nameparser Constants. Remove nameparser's titles and use our own and add as suffixes the roman numerals. Configuration is the same for all names (i.e. instances).", "response": "def _prepare_nameparser_constants():\n    \"\"\"Prepare nameparser Constants.\n\n    Remove nameparser's titles and use our own and add as suffixes the roman numerals.\n    Configuration is the same for all names (i.e. instances).\n    \"\"\"\n    constants = Constants()\n    roman_numeral_suffixes = [u'v', u'vi', u'vii', u'viii', u'ix', u'x',\n                              u'xii', u'xiii', u'xiv', u'xv']\n    titles = [u'Dr', u'Prof', u'Professor', u'Sir', u'Editor', u'Ed', u'Mr',\n              u'Mrs', u'Ms', u'Chair', u'Co-Chair', u'Chairs', u'co-Chairs']\n    constants.titles.remove(*constants.titles).add(*titles)\n    constants.suffix_not_acronyms.add(*roman_numeral_suffixes)\n    return constants"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generate_non_lastnames_variations(non_lastnames):\n    if not non_lastnames:\n        return []\n\n    # Generate name transformations in place for all non lastnames. Transformations include:\n    # 1. Drop non last name, 2. use initial, 3. use full non lastname\n    for idx, non_lastname in enumerate(non_lastnames):\n        non_lastnames[idx] = (u'', non_lastname[0], non_lastname)\n\n    # Generate the cartesian product of the transformed non lastnames and flatten them.\n    return [\n        (u' '.join(var_elem for var_elem in variation if var_elem)).strip()\n        for variation in product(*non_lastnames)\n    ]", "response": "Generate variations for all non - lastnames."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_lastnames_variations(lastnames):\n    if not lastnames:\n        return []\n\n    split_lastnames = [split_lastname for lastname in lastnames for split_lastname in lastname.split('-')]\n\n    lastnames_variations = split_lastnames\n    if len(split_lastnames) > 1:\n        # Generate lastnames concatenation if there are more than one lastname after split.\n        lastnames_variations.append(u' '.join([lastname for lastname in split_lastnames]))\n\n    return lastnames_variations", "response": "Generate variations for lastnames."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the name variations for a given name.", "response": "def generate_name_variations(name):\n    \"\"\"Generate name variations for a given name.\n\n    Args:\n        name (six.text_type): The name whose variations are to be generated.\n\n    Returns:\n        list: All the name variations for the given name.\n\n    Notes:\n        Uses `unidecode` for doing unicode characters transliteration to ASCII ones. This was chosen so that we can map\n        both full names of authors in HEP records and user's input to the same space and thus make exact queries work.\n    \"\"\"\n    def _update_name_variations_with_product(set_a, set_b):\n        name_variations.update([\n            unidecode((names_variation[0] +\n                       separator +\n                       names_variation[1]).strip(''.join(_LASTNAME_NON_LASTNAME_SEPARATORS))).lower()\n            for names_variation\n            in product(set_a, set_b)\n            for separator\n            in _LASTNAME_NON_LASTNAME_SEPARATORS\n        ])\n\n    parsed_name = ParsedName.loads(name)\n\n    # Handle rare-case of single-name\n    if len(parsed_name) == 1:\n        return [parsed_name.dumps().lower()]\n\n    name_variations = set()\n\n    # We need to filter out empty entries, since HumanName for this name `Perelstein,, Maxim` returns a first_list with\n    # an empty string element.\n    non_lastnames = [\n        non_lastname\n        for non_lastname\n        in parsed_name.first_list + parsed_name.suffix_list\n        if non_lastname\n    ]\n\n    # This is needed because due to erroneous data (e.g. having many authors in a single authors field) ends up\n    # requiring a lot of memory (due to combinatorial expansion of all non lastnames).\n    # The policy is to use the input as a name variation, since this data will have to be curated.\n    if len(non_lastnames) > _NAMES_MAX_NUMBER_THRESHOLD or len(parsed_name.last_list) > _NAMES_MAX_NUMBER_THRESHOLD:\n        LOGGER.error('Skipping name variations generation - too many names in: \"%s\"', name)\n        return [name]\n\n    non_lastnames_variations = \\\n        _generate_non_lastnames_variations(non_lastnames)\n    lastnames_variations = _generate_lastnames_variations(parsed_name.last_list)\n\n    # Create variations where lastnames comes first and is separated from non lastnames either by space or comma.\n    _update_name_variations_with_product(lastnames_variations, non_lastnames_variations)\n\n    # Second part of transformations - having the lastnames in the end.\n    _update_name_variations_with_product(non_lastnames_variations, lastnames_variations)\n\n    return list(name_variations)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef loads(cls, name):\n        if not isinstance(name, six.string_types):\n            raise TypeError(u'arguments to {classname} must be of type {string_types}'.format(\n                classname=cls.__name__, string_types=repr(six.string_types)\n            ))\n        if not name or name.isspace():\n            raise ValueError('name must not be empty')\n\n        return cls(name)", "response": "Load a parsed name from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dumps(self):\n        def _is_initial(author_name):\n            return len(author_name) == 1 or u'.' in author_name\n\n        def _ensure_dotted_initials(author_name):\n            if _is_initial(author_name) \\\n                    and u'.' not in author_name:\n                seq = (author_name, u'.')\n                author_name = u''.join(seq)\n            return author_name\n\n        def _ensure_dotted_suffixes(author_suffix):\n            if u'.' not in author_suffix:\n                seq = (author_suffix, u'.')\n                author_suffix = u''.join(seq)\n            return author_suffix\n\n        def _is_roman_numeral(suffix):\n            \"\"\"Controls that the user's input only contains valid roman numerals\"\"\"\n            valid_roman_numerals = [u'M', u'D', u'C', u'L', u'X',\n                                    u'V', u'I', u'(', u')']\n            return all(letters in valid_roman_numerals\n                       for letters in suffix.upper())\n\n        first_and_middle_names = iter(_ensure_dotted_initials(name) for name in self.first_list)\n        try:\n            prev = next(first_and_middle_names)\n        except StopIteration:\n            LOGGER.warning(u\"Cannot process %s properly\",\n                           self._parsed_name.original)\n            prev = self._parsed_name.original\n        names_with_spaces = [prev]\n\n        for name in first_and_middle_names:\n            if not _is_initial(name) or not _is_initial(prev):\n                names_with_spaces.append(' ')\n            prev = name\n            names_with_spaces.append(prev)\n\n        normalized_names = u''.join(names_with_spaces)\n\n        if _is_roman_numeral(self.suffix):\n            suffix = self.suffix.upper()\n        else:\n            suffix = _ensure_dotted_suffixes(self.suffix)\n\n        final_name = u', '.join(\n            part for part in (self.last, normalized_names.strip(), suffix)\n            if part)\n\n        # Replace unicode curly apostrophe to normal apostrophe.\n        final_name = final_name.replace(u'\u2019', '\\'')\n\n        return final_name", "response": "Dump the name to string after normalizing it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pprint(self, initials_only=False):\n        last_name = self.last\n        suffixes = ', ' + self.suffix if self.suffix else ''\n\n        if initials_only and last_name != u'':\n            first_names = self.first_initials\n        else:\n            first_names = self.first\n\n        return u'{} {}{}'.format(first_names, last_name, suffixes).strip()", "response": "Pretty print the name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search_evaluations(campus, **kwargs):\n    url = \"%s?%s\" % (IAS_PREFIX, urlencode(kwargs))\n\n    data = get_resource_by_campus(url, campus)\n    evaluations = _json_to_evaluation(data)\n\n    return evaluations", "response": "Search for evaluations by campus."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting JSON data to an Evaluation object.", "response": "def _json_to_evaluation(data):\n    \"\"\"\n    Only keep the data for online evaluations.\n    Two scenarios for multiple instructors:\n    1) all of the co-instructors may be evaluated online as a group,\n       sharing the eval URL.\n    2) each co-instructor may be evaluated individually,\n       with separate eval URLs.\n    \"\"\"\n    collection_items = data.get('collection').get('items')\n    if collection_items is None:\n        return None\n    evaluations = []\n    for item in collection_items:\n        item_meta = item.get('meta')\n        type = _get_item_type(item_meta)\n        if type == \"evaluation\":\n            delivery_data = item.get('data')\n            if get_is_online(delivery_data):\n                evaluation = Evaluation()\n                evaluation.eval_status = \\\n                    get_value_by_name(delivery_data, 'status')\n                evaluation.eval_open_date = get_open_date(delivery_data)\n                evaluation.eval_close_date = get_close_date(delivery_data)\n                evaluation.eval_url = get_eval_url(item.get('links'))\n                section, instructors, completion =\\\n                    _get_child_items(_get_child_ids(item_meta),\n                                     collection_items)\n                evaluation.section_sln = get_section_sln(section)\n                evaluation.instructor_ids = instructors\n                evaluation.is_completed = get_is_complete(completion)\n                evaluations.append(evaluation)\n    return evaluations"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of tuples that are partitioned from start to stop based on annotations.", "response": "def partition_range(stop, annotations=None):\n    \"\"\"\n    Partition the range from 0 to `stop` based on annotations.\n\n        >>> partition_range(50, annotations=[[(0, 21), (30, 35)],\n        ...                                  [(15, 32), (40, 46)]])\n        [(0, 15, {0}),\n         (15, 21, {0, 1}),\n         (21, 30, {1}),\n         (30, 32, {0, 1}),\n         (32, 35, {0}),\n         (35, 40, set()),\n         (40, 46, {1}),\n         (46, 50, set())]\n\n    :arg stop: End point (not included) of the range (similar to the `stop`\n        argument of the built-in :func:`range` function).\n    :type stop: int\n    :arg annotations: For each annotation level, a list of (`start`, `stop`)\n        pairs defining an annotated region.\n    :type annotations: list\n\n    :return: Partitioning of the range as (`start`, `stop`, `levels`) tuples\n        defining a region with a set of annotation levels.\n    :rtype: list\n\n    All regions (`start`, `stop`) are defined as in slicing notation, so\n    zero-based and `stop` is not included.\n\n    The `annotations` argument is a list of annotations. An annotation is a\n    list of regions as (`start`, `stop`) tuples. The level of each annotation\n    is its index in `annotations`.\n\n    Annotation regions can overlap (overlap within one level is ignored) and\n    do not need to be sorted.\n    \"\"\"\n    annotations = annotations or []\n\n    partitioning = []\n    part_start, part_levels = 0, None\n\n    # We loop over the range, only touching positions where levels potentially\n    # change.\n    for p in sorted(set(itertools.chain([0, stop],\n                                        *itertools.chain(*annotations)))):\n        if p == stop:\n            partitioning.append( (part_start, p, part_levels) )\n            break\n\n        # Annotation levels for position p.\n        levels = {level for level, regions in enumerate(annotations)\n                  if any(x <= p < y for x, y in regions)}\n\n        if p == 0:\n            part_levels = levels\n            continue\n\n        if levels != part_levels:\n            partitioning.append( (part_start, p, part_levels) )\n            part_start, part_levels = p, levels\n\n    return partitioning"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pprint_sequence(sequence, annotations=None, block_length=10,\n                    blocks_per_line=6, format=PlaintextFormat):\n    \"\"\"\n    Pretty-print sequence for use with a monospace font.\n\n        >>> sequence = 'MIMANQPLWLDSEVEMNHYQQSHIKSKSPYFPEDKHICWIKIFKAFGT' * 4\n        >>> print pprint_sequence(sequence, format=PlaintextFormat)\n          1  MIMANQPLWL DSEVEMNHYQ QSHIKSKSPY FPEDKHICWI KIFKAFGTMI MANQPLWLDS\n         61  EVEMNHYQQS HIKSKSPYFP EDKHICWIKI FKAFGTMIMA NQPLWLDSEV EMNHYQQSHI\n        121  KSKSPYFPED KHICWIKIFK AFGTMIMANQ PLWLDSEVEM NHYQQSHIKS KSPYFPEDKH\n        181  ICWIKIFKAF GT\n\n    :arg sequence: Sequence to pretty-print.\n    :type sequence: str or any sliceable yielding slices representable as\n        strings.\n    :arg annotations: For each annotation level, a list of (`start`, `stop`)\n        pairs defining an annotated region.\n    :type annotations: list\n    :arg block_length: Length of space-separated blocks.\n    :type block_length: int\n    :arg blocks_per_line: Number of blocks per line.\n    :type blocks_per_line: int\n    :arg format: Output format to use for pretty-printing. Some formats are\n        pre-defined as :data:`HtmlFormat`, :data:`AnsiFormat`, and\n        :data:`PlaintextFormat`.\n    :type format: :class:`Format`\n\n    :return: Pretty-printed version of `sequence`.\n    :rtype: str\n\n    All regions (`start`, `stop`) are defined as in slicing notation, so\n    zero-based and `stop` is not included.\n\n    The `annotations` argument is a list of annotations. An annotation is a\n    list of regions as (`start`, `stop`) tuples. The level of each annotation\n    is its index in `annotations`.\n\n    Annotation regions can overlap (overlap within one level is ignored) and\n    do not need to be sorted.\n\n    The number of annotation levels supported depends on `format`.\n    :data:`HtmlFormat` supports 10 levels, :data:`AnsiFormat` supports 3\n    levels and annotations are ignored completely with\n    :data:`PlaintextFormat`.\n    \"\"\"\n    annotations = annotations or []\n\n    partitioning = partition_range(len(sequence), annotations)\n\n    # The maximum length for positions is the 10_log of the length of the\n    # sequence.\n    margin = int(math.floor(math.log(max(len(sequence), 1), 10))\n                 + 1) + len(format.margin[0])\n    result = (format.margin[0] + '1').rjust(margin) + format.margin[1] + ' '\n\n    for p in range(0, len(sequence), block_length):\n        # Partitioning of the block starting at position p.\n        block = [(max(start, p), min(stop, p + block_length), levels)\n                 for start, stop, levels in partitioning\n                 if start < p + block_length and stop > p]\n\n        result += ' '\n        for start, stop, levels in block:\n            delimiters = [(left, right) for level, (left, right)\n                          in enumerate(format.annotations) if level in levels]\n            result += (''.join(left for left, right in reversed(delimiters)) +\n                       str(sequence[start:stop]) +\n                       ''.join(right for left, right in delimiters))\n\n        if (not (p + block_length) % (block_length * blocks_per_line) and\n            p + block_length < len(sequence)):\n            result += ('\\n' + (format.margin[0] +\n                               str(p + block_length + 1)).rjust(margin) +\n                       format.margin[1] + ' ')\n\n    return result", "response": "Pretty - print a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bind(cls, param=None, **kwargs):\n        def stick(function, **binding):\n            if not asyncio.iscoroutine(function):\n                function = asyncio.coroutine(function)\n            bindings = getattr(function, STICKER, [])\n            bindings.append(binding)\n            setattr(function, STICKER, bindings)\n            return function\n        if isinstance(param, str):\n            return partial(stick, prefix=param, **kwargs)\n        return stick(param, **kwargs)", "response": "Bind middleware s method as endpoint. isAliased function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_campus_calendars(campus_code):\n    if is_bot(campus_code):\n        return get_bot_calendars()\n    elif is_sea(campus_code):\n        return get_sea_calendars()\n    elif is_tac(campus_code):\n        return get_tac_calendars()\n    else:\n        logger.warn(\n            \"Calling get_campus_calendars with invalid campus code: %s\"\n            % campus_code)\n        return None", "response": "Returns a dictionary of calendars corresponding to the given campus code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of sorted trumba. Permission objects corresponding to the given campus calendar.", "response": "def get_campus_permissions(calendar_id, campus_code):\n    \"\"\"\n    :return: a list of sorted trumba.Permission objects\n             corresponding to the given campus calendar.\n             None if error, [] if not exists\n    raise DataFailureException if the request failed.\n    \"\"\"\n    if is_bot(campus_code):\n        return get_bot_permissions(calendar_id)\n    elif is_sea(campus_code):\n        return get_sea_permissions(calendar_id)\n    elif is_tac(campus_code):\n        return get_tac_permissions(calendar_id)\n    else:\n        logger.warn(\n            \"Calling get_campus_permissions with invalid campus code: %s\"\n            % campus_code)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bot_permissions(calendar_id):\n    return _process_get_perm_resp(\n        get_permissions_url,\n        post_bot_resource(get_permissions_url,\n                          _create_get_perm_body(calendar_id)),\n        TrumbaCalendar.BOT_CAMPUS_CODE,\n        calendar_id)", "response": "Get bot permissions for a given campus calendar."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the user permissions of a given Seattle calendar.", "response": "def get_sea_permissions(calendar_id):\n    \"\"\"\n    Return a list of Permission objects representing\n    the user permissions of a given Seattle calendar.\n    :return: a list sorted of trumba.Permission objects\n             corresponding to the given campus calendar.\n             None if error, [] if not exists\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    return _process_get_perm_resp(\n        get_permissions_url,\n        post_sea_resource(get_permissions_url,\n                          _create_get_perm_body(calendar_id)),\n        TrumbaCalendar.SEA_CAMPUS_CODE,\n        calendar_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the list of sorted Permission objects representing the user permissions of a given campus calendar.", "response": "def get_tac_permissions(calendar_id):\n    \"\"\"\n    Return a list of sorted Permission objects representing\n    the user permissions of a given Tacoma calendar.\n    :return: a list of trumba.Permission objects\n             corresponding to the given campus calendar.\n             None if error, [] if not exists\n    raise DataFailureException or a corresponding TrumbaException\n    if the request failed or an error code has been returned.\n    \"\"\"\n    return _process_get_perm_resp(\n        get_permissions_url,\n        post_tac_resource(get_permissions_url,\n                          _create_get_perm_body(calendar_id)),\n        TrumbaCalendar.TAC_CAMPUS_CODE,\n        calendar_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process_get_cal_resp(url, post_response, campus):\n    request_id = \"%s %s\" % (campus, url)\n    calendar_dict = {}\n    data = _load_json(request_id, post_response)\n    if data['d']['Calendars'] is not None and len(data['d']['Calendars']) > 0:\n        _load_calendar(campus, data['d']['Calendars'],\n                       calendar_dict, None)\n    return calendar_dict", "response": "Process the response from the get_cal_request function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_get_perm_resp(url, post_response, campus, calendarid):\n    request_id = \"%s %s CalendarID:%s\" % (campus, url, calendarid)\n    data = _load_json(request_id, post_response)\n    permission_list = []\n    if data['d']['Users'] is not None and len(data['d']['Users']) > 0:\n        _load_permissions(campus, calendarid,\n                          data['d']['Users'],\n                          permission_list)\n    return sorted(permission_list)", "response": "Process the response from get_perm and return a list of trumba. Permission objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the response contains an error code and raise an exception.", "response": "def _check_err(data):\n    \"\"\"\n    :param data: response json data object (must be not None).\n    Check possible error code returned in the response body\n    raise the coresponding exceptions\n    \"\"\"\n    if data['d'] is None:\n        raise NoDataReturned()\n    if data['d']['Messages'] is None:\n        return\n\n    msg = data['d']['Messages']\n    if len(msg) == 0 or msg[0]['Code'] is None:\n        raise UnknownError()\n\n    code = int(msg[0]['Code'])\n    if code == 3006:\n        raise CalendarNotExist()\n    elif code == 3007:\n        raise CalendarOwnByDiffAccount()\n    else:\n        logger.warn(\n            \"Unexpected Error Code: %s %s\" % (\n                code, msg[0]['Description']))\n        raise UnexpectedError()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmoves to new input file position.", "response": "def seek(self, pos):\n        \"\"\" Move to new input file position. If position is negative or out of file, raise Exception. \"\"\"\n        if (pos > self.file_size) or (pos < 0):\n            raise Exception(\"Unable to seek - position out of file!\")\n        self.file.seek(pos)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a byte string from the input file.", "response": "def read(self, size=1):\n        \"\"\"\n        Read byte buffer with specified size from input file.\n        Raise exception in two cases:\n            - File already closed.\n            - Not enough data to read.\n\n        Keyword arguments:\n        size -- size of buffer to read (default 1)\n        \"\"\"\n        if self.is_closed_flag:\n            raise Exception(\"Unable to read - already closed!\")\n        if self.get_remaining_size() < size:\n            raise Exception(\"Unable to read byte buffer - too short remaining data size!\")\n        self.read_count += size\n        return self.file.read(size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_string(self):\n        length = self.read_int()\n        return str(self.read(length).decode(\"UTF-8\"))", "response": "Read a string from the input file with UTF - 8 encoding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a ConnectionPool instance of given host", "response": "def get_con_pool(host,\n                 key_file=None,\n                 cert_file=None,\n                 socket_timeout=15.0,\n                 max_pool_size=3,\n                 verify_https=True):\n    \"\"\"\n    Return a ConnectionPool instance of given host\n    :param socket_timeout:\n        socket timeout for each connection in seconds\n    \"\"\"\n    kwargs = {\n        \"timeout\": socket_timeout,\n        \"maxsize\": max_pool_size,\n        \"block\": True,\n        }\n\n    if key_file is not None and cert_file is not None:\n        kwargs[\"key_file\"] = key_file\n        kwargs[\"cert_file\"] = cert_file\n\n    if urlparse(host).scheme == \"https\":\n        kwargs[\"ssl_version\"] = ssl.PROTOCOL_TLSv1\n        if verify_https:\n            kwargs[\"cert_reqs\"] = \"CERT_REQUIRED\"\n            kwargs[\"ca_certs\"] = getattr(settings, \"RESTCLIENTS_CA_BUNDLE\",\n                                         \"/etc/ssl/certs/ca-bundle.crt\")\n\n    return connection_from_url(host, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_live_url(con_pool,\n                 method,\n                 host,\n                 url,\n                 headers,\n                 retries=1,\n                 redirect=True,\n                 body=None,\n                 service_name=None):\n    \"\"\"\n    Return a connection from the pool and perform an HTTP request.\n    :param con_pool:\n        is the http connection pool associated with the service\n    :param method:\n        HTTP request method (such as GET, POST, PUT, etc.)\n    :param host:\n        the url of the server host.\n    :param headers:\n        headers to include with the request\n    :param body:\n        the POST, PUT, PATCH body of the request\n    \"\"\"\n\n    timeout = con_pool.timeout.read_timeout\n    start_time = time.time()\n\n    response = con_pool.urlopen(method, url, body=body,\n                                headers=headers, redirect=redirect,\n                                retries=retries, timeout=timeout)\n    request_time = time.time() - start_time\n    rest_request.send(sender='restclients',\n                      url=url,\n                      request_time=request_time,\n                      hostname=socket.gethostname(),\n                      service_name=service_name)\n    rest_request_passfail.send(sender='restclients',\n                               url=url,\n                               success=True,\n                               hostname=socket.gethostname(),\n                               service_name=service_name)\n\n    return response", "response": "Get a live URL from the pool and perform an HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the result of the replacement function.", "response": "def _result(self) -> ResultLazyType:\n        \"\"\"\n        ``self.config.replacer_function``(``Callable[[str], str]``) must exists.\n        \"\"\"\n        config = cast(IntervalsCollectionBasedReplacerConfig, self.config)\n\n        diff_acc = 0\n        for interval, aggregated_mark in self.continuous_intervals():\n            start, end = interval\n            processed_start = start + diff_acc\n            processed_end = end + diff_acc\n\n            segment = self.input_sequence[start:end]\n\n            if aggregated_mark is not None:\n                processed_segment = config.labeler2repl[cast(Type[workflow.IntervalLabeler],\n                                                             aggregated_mark)](segment)\n\n                if not processed_segment:\n                    # segment is removed.\n                    processed_end = processed_start\n                else:\n                    processed_end = processed_start + len(processed_segment)\n\n                diff_acc += len(processed_segment) - len(segment)\n                segment = processed_segment\n\n            yield segment, (interval, (processed_start, processed_end), aggregated_mark is not None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emit(self, content, request=None, emitter=None):\n        # Get emitter for request\n        emitter = emitter or self.determine_emitter(request)\n        emitter = emitter(self, request=request, response=content)\n\n        # Serialize the response content\n        response = emitter.emit()\n\n        if not isinstance(response, HttpResponse):\n            raise AssertionError(\"Emitter must return HttpResponse\")\n\n        # Append pagination headers\n        if isinstance(content, Paginator):\n            linked_resources = []\n            if content.next_page:\n                linked_resources.append('<{0}>; rel=\"next\"'.format(\n                    content.next_page))\n            if content.previous_page:\n                linked_resources.append(\n                    '<{0}>; rel=\"previous\"'.format(content.previous_page))\n            response[\"Link\"] = \", \".join(linked_resources)\n\n        return response", "response": "Serialize response.\n\n        :return response: Instance of django.http.Response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef determine_emitter(cls, request):\n        default_emitter = cls._meta.emitters[0]\n        if not request:\n            return default_emitter\n\n        if request.method == 'OPTIONS':\n            return JSONEmitter\n\n        accept = request.META.get('HTTP_ACCEPT', '*/*')\n        if accept == '*/*':\n            return default_emitter\n\n        base_format = mimeparse.best_match(cls._meta.emitters_dict.keys(),\n                                           accept)\n        return cls._meta.emitters_dict.get(\n            base_format,\n            default_emitter)", "response": "Determine emitter for the given request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows info about the existing crawler jobs.", "response": "def list_jobs(tail):\n    \"\"\"Show info about the existing crawler jobs.\"\"\"\n    query = (\n        db.session.query(models.CrawlerJob)\n        .order_by(models.CrawlerJob.id.desc())\n    )\n    if tail != 0:\n        query = query.limit(tail)\n\n    results = query.yield_per(10).all()\n    _show_table(results=results)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the crawl logs from the job.", "response": "def get_job_logs(id):\n    \"\"\"Get the crawl logs from the job.\"\"\"\n    crawler_job = models.CrawlerJob.query.filter_by(id=id).one_or_none()\n    if crawler_job is None:\n        click.secho(\n            (\n                \"CrawlJob %s was not found, maybe it's not a crawl job?\" %\n                id\n            ),\n            fg='yellow',\n        )\n        sys.exit(1)\n\n    if crawler_job.logs is None:\n        click.secho(\n            (\n                \"CrawlJob %s has no log, it might be that it has not run \"\n                \"yet, you can try again later.\" %\n                id\n            ),\n            fg='yellow',\n        )\n        sys.exit(1)\n\n    _show_file(\n        file_path=crawler_job.logs,\n        header_name='Log',\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the crawl results from the job.", "response": "def get_job_results(id):\n    \"\"\"Get the crawl results from the job.\"\"\"\n    crawler_job = models.CrawlerJob.query.filter_by(id=id).one()\n    _show_file(\n        file_path=crawler_job.results,\n        header_name='Results',\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_crawler_workflows(tail):\n    query = (\n        models.CrawlerWorkflowObject.query\n        .order_by(models.CrawlerWorkflowObject.object_id.desc())\n    )\n    if tail != 0:\n        query = query.limit(tail)\n\n    workflows = query.yield_per(10).all()\n    _show_table(results=workflows)", "response": "Show info about the existing crawler workflows."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the crawl logs from the workflow id.", "response": "def get_job_logs_from_workflow(workflow_id):\n    \"\"\"Retrieve the crawl logs from the workflow id.\"\"\"\n    query_result = (\n        db.session.query(\n            models.CrawlerJob.logs,\n        )\n        .join(\n            models.CrawlerWorkflowObject,\n            models.CrawlerJob.job_id == models.CrawlerWorkflowObject.job_id,\n        )\n        .filter(models.CrawlerWorkflowObject.object_id == workflow_id)\n        .one_or_none()\n    )\n\n    if query_result is None:\n        click.secho(\n            (\n                \"Workflow %s was not found, maybe it's not a crawl workflow?\" %\n                workflow_id\n            ),\n            fg='yellow',\n        )\n        sys.exit(1)\n\n    _show_file(\n        file_path=query_result[0],\n        header_name='Log',\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef schedule_crawl_cli(spider_name, workflow_name, dont_force_crawl, kwarg):\n    extra_kwargs = {}\n    for extra_kwarg in kwarg:\n        if '=' not in extra_kwarg:\n            raise TypeError(\n                'Bad formatted kwarg (%s), it should be in the form:\\n'\n                '    --kwarg key=value' % extra_kwarg\n            )\n        key, value = extra_kwarg.split('=', 1)\n\n        extra_kwargs[key] = value\n\n    settings = {'CRAWL_ONCE_ENABLED': False}\n    if dont_force_crawl:\n        settings = {}\n\n    try:\n        crawler_job_uid = schedule_crawl(\n            spider=spider_name,\n            workflow=workflow_name,\n            crawler_settings=settings,\n            **extra_kwargs\n        )\n    except ScrapydResponseError as error:\n        message = str(error)\n        if 'spider' in message and 'not found' in message:\n            click.echo('%s' % error)\n            click.echo('\\n Available spiders:')\n            spiders = list_spiders()\n            click.echo('\\n'.join(spiders))\n            raise click.Abort()\n        else:\n            raise\n\n    crawler_job = models.CrawlerJob.query.filter_by(\n        job_id=crawler_job_uid\n    ).one()\n\n    click.echo(\n        'Once the job is started, you can see the logs of the job with the '\n        'command:\\n'\n        '    inspirehep crawler job list\\n'\n        '    inspirehep crawler job logs %s\\n'\n        '\\n'\n        'and for the associated workflow (it\\'s job_id should be %s):\\n'\n        '    inspirehep crawler workflow list\\n'\n        % (crawler_job.id, crawler_job_uid)\n    )", "response": "Schedule a new crawl."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_memory_usage(user=None):\n    total = 0\n    largest_process = 0\n    largest_process_name = None\n    for p in psutil.process_iter():\n        p_user = p.username()\n        if user is None or p_user == user:\n            try:\n                process_memory = p.memory_info()[0]\n            except psutil.AccessDenied:\n                continue\n            total += process_memory\n            if process_memory > largest_process:\n                largest_process = process_memory\n                largest_process_name = p.name()\n    return total, largest_process, largest_process_name", "response": "Returns a three - tupel with memory usage for the given user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ClassHopperMutant(initial_object, class_returning_callable, copy=True):\n\n    from copy import copy as _copy\n\n    def class_mutator(obj):\n        obj.__class__ = class_returning_callable(obj)\n        return obj\n\n    if copy:\n        initial_object = _copy(initial_object)\n\n    return OnAccessMutant(initial_object, class_mutator)", "response": "ClassHopper decorator that returns a function that evaluates the class of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrain the model in a Cannon - like fashion using the grid points as labels and the intensities as normalised rest - frame fluxes.", "response": "def train_global(self, label_vector_description=None, N=None, limits=None,\n        pivot=True, **kwargs):\n        \"\"\"\n        Train the model in a Cannon-like fashion using the grid points as labels\n        and the intensities as normalised rest-frame fluxes.\n        \"\"\"\n\n        lv = self._cannon_label_vector if label_vector_description is None else\\\n            self._interpret_label_vector(label_vector_description)\n        lv_array, grid_indices, offsets = _build_label_vector_array(\n            self.grid_points, lv, N, limits, pivot=pivot)\n        return self._train(lv_array, grid_indices, offsets, lv, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntraining the local Cannon model for the local entry.", "response": "def train_local(self, closest_point, label_vector_description=None, N=None,\n        pivot=True, **kwargs):\n        \"\"\"\n        Train the model in a Cannon-like fashion using the grid points as labels\n        and the intensities as normalsied rest-frame fluxes within some local\n        regime.\n        \"\"\"\n\n        lv = self._cannon_label_vector if label_vector_description is None else\\\n            self._interpret_label_vector(label_vector_description)\n\n        # By default we will train to the nearest 10% of the grid.\n        # If grid subset is a fraction, scale it to real numbers.\n        if N is None:\n            N = self._configuration.get(\"settings\", {}).get(\"grid_subset\",\n                0.10)\n            if 1 >= N > 0:\n                N = int(np.round(N * self.grid_points.size))\n\n        logger.debug(\"Using {} nearest points for local Cannon model\".format(N))\n\n        # Use closest N points.\n        dtype = [(name, '<f8') for name in self.grid_points.dtype.names]\n        grid_points \\\n            = self.grid_points.astype(dtype).view(float).reshape(-1, len(dtype))\n\n        distance = np.sum(np.abs(grid_points - np.array(closest_point))/\n            np.ptp(grid_points, axis=0), axis=1)\n        grid_indices = np.argsort(distance)[:N]\n        \n        lv_array, _, offsets = _build_label_vector_array(\n            self.grid_points[grid_indices], lv, pivot=pivot)\n        return self._train(lv_array, grid_indices, offsets, lv, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef train_and_save(self, model_filename, cannon_data_filename, \n        clobber=False, **kwargs):\n        \"\"\"\n        Train the Cannon coefficients.\n        \"\"\"\n\n        if any(map(os.path.exists,\n            (model_filename, cannon_data_filename))) and not clobber:\n            raise IOError(\"output file already exists\")\n\n        trained = self.train_global(**kwargs)\n        with open(cannon_data_filename, \"wb\") as fp:\n            pickle.dump(trained, fp, -1)\n\n        self._configuration[\"model_grid\"][\"cannon_data\"] = cannon_data_filename\n        logger.info(\"Cannon coefficients pickled to {}\".format(\n            cannon_data_filename))\n\n        self.save(model_filename, clobber)\n\n        return True", "response": "Train the Cannon coefficients and save the model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef optimise(self, data, initial_theta=None, full_output=False, **kwargs):\n\n        data = self._format_data(data)\n\n        if initial_theta is None:\n            initial_theta = self.estimate(data)\n\n        # Which parameters will be optimised, and which will be fixed?\n        matched_channels, missing_channels, ignore_parameters \\\n            = self._match_channels_to_data(data)\n\n        # For the Cannon model, the normalised fluxes are a multiplicative\n        # operation, so we don't actually need to optimise the astrophysical\n        # parameters, we only need to optimise the other ones. At each set of\n        # non-astrophysical parameters we can determine the optimal\n        # astrophysical parameters by a matrix inversion.\n        parameters = [p for p in self.parameters if p not in ignore_parameters \\\n            and p not in self.grid_points.dtype.names]\n\n        # What model wavelength ranges will be required?\n        wavelengths_required = []\n        for channel, spectrum in zip(matched_channels, data):\n            if channel is None: continue\n            z = initial_theta.get(\"z\", initial_theta.get(\"z_{}\".format(channel),\n                0))\n            wavelengths_required.append(\n                [spectrum.disp[0] * (1 - z), spectrum.disp[-1] * (1 - z)])\n\n        # (If necessary,..) train the Cannon model around the closest point.\n        subset_bounds = self._initialise_approximator(closest_point=\\\n            [initial_theta[p] for p in self.grid_points.dtype.names], \n            wavelengths_required=wavelengths_required, **kwargs)\n        \n        # Get the optimisation keyword arguments.\n        op_kwargs = self._configuration.get(\"optimise\", {}).copy()\n        op_kwargs.update(kwargs)\n\n        # Get fixed keywords.\n        fixed = op_kwargs.pop(\"fixed\", {})\n        if fixed is None: fixed = {}\n        if fixed:\n            # Remove non-parameters from the 'fixed' keywords.\n            keys = set(fixed).intersection(self.parameters)\n            ignored_keys = set(fixed).difference(parameters)\n            if ignored_keys:\n                logger.warn(\"Ignoring optimise.fixed keys because they are not\"\n                    \" model parameters: {0}\".format(\", \".join(ignored_keys)))\n            # If the 'fixed' value is provided, use that. Otherwise if it is\n            # None then use the initial_theta value.\n            fixed = dict(zip(keys, \n                [(fixed[k], initial_theta.get(k, None))[fixed[k] is None] \\\n                    for k in keys]))\n\n            logger.info(\"Fixing keyword arguments (these will not be optimised)\"\n                \": {}\".format(fixed))\n\n        # Remove fixed parameters from the parameters to be optimised\n        #parameters = list(set(parameters).difference(fixed))\n        parameters = [p for p in parameters if p not in fixed]\n\n        # Translate input bounds.\n        nbs = (None, None) # No boundaries.\n        input_bounds = op_kwargs.pop(\"bounds\", {})\n        # Because astrophysical parameters are not being 'optimised', we may not\n        # actually need the subset_bounds.get call, but there may be fringe\n        # cases that I cannot immediately think of.\n        op_kwargs[\"bounds\"] = [input_bounds.get(p, subset_bounds.get(p, nbs)) \\\n            for p in parameters]\n\n        # Apply data masks now so we don't have to do it on the fly.\n        masked_data, pixels_affected = self._apply_data_mask(data)\n\n        # Prepare the convolution functions.\n        self._create_convolution_functions(matched_channels, data, parameters)\n\n        logger.info(\"Optimising parameters: {0}\".format(\", \".join(parameters)))\n        logger.info(\"Optimisation keywords: {0}\".format(op_kwargs))\n\n        # Create the objective function. The objective function needs to\n        # continuum-normalise the observed spectra, put it at rest, then solve\n        # for the best astrophysical parameters, then *generate* that spectrum.\n        debug = kwargs.get(\"debug\", False)\n        def nlp(t, return_labels=False):\n            # Apply fixed keywords.\n            theta = dict(zip(parameters, t))\n            theta.update(fixed)\n\n            observed_variances = []\n            observed_intensities = []\n            for channel, spectrum in zip(matched_channels, data):\n\n                # For each channel:\n                # 1) Put the observed spectrum at rest.\n                z = theta.get(\"z\", theta.get(\"z_{}\".format(channel), 0))\n                rest_observed_disp = spectrum.disp * (1 - z)\n\n                # 2) Correct for continuum.\n                j, coeffs = 0, []\n                while theta.get(\"continuum_{0}_{1}\".format(channel, j), None):\n                    coeffs.append(theta[\"continuum_{0}_{1}\".format(channel, j)])\n                    j += 1\n\n                # Remember: model.__call__ calculates continuum based on the\n                # *observed* wavelength points, so here we do the same (e.g.,\n                # not those that have potentially been corrected for redshift)\n                if not coeffs: continuum = 1.0\n                else:\n                    continuum = np.polyval(coeffs[::-1], spectrum.disp) \n                \n                # 3) Put the observed data onto the self.wavelengths scale.\n                # [TODO] do the resampling correctly.\n                rebinned_observed_intensities = np.interp(self.wavelengths,\n                    rest_observed_disp, spectrum.flux / continuum,\n                    left=np.nan, right=np.nan)\n\n                rebinned_observed_variances = np.interp(self.wavelengths,\n                    rest_observed_disp, spectrum.variance / continuum,\n                    left=np.nan, right=np.nan)\n\n                observed_variances.append(rebinned_observed_variances)\n                observed_intensities.append(rebinned_observed_intensities)\n\n            # [TODO] This may be the wrong thing to do.\n            observed_variances \\\n                = np.nanmean(np.vstack(observed_variances), axis=0)\n            observed_intensities \\\n                = np.nanmean(np.vstack(observed_intensities), axis=0)\n\n            # Solve for the astrophysical parameters.\n            try:\n                labels = self._solve_labels(observed_intensities,\n                    observed_variances)\n\n            except:\n                logger.exception(\"Could not determine labels:\")\n                if debug: raise\n                return np.inf\n\n            if return_labels:\n                return labels\n\n            # Put the optimal astrophysical parameters into our theta.\n            theta.update(labels)\n\n            # Make the log-probability call.\n            # Note: The inference._ln_probability call takes a dictionary.\n            return -inference._ln_probability(theta, self, data, debug,\n                matched_channels=matched_channels)\n\n        # Do the optimisation.\n        p0 = np.array([initial_theta[p] for p in parameters])\n        x_opt = optimise.minimise(nlp, p0, **op_kwargs)\n\n        # Put the result into a usable form.\n        result = dict(zip(parameters, x_opt))\n        result.update(nlp(x_opt, return_labels=True))\n        result.update(fixed)\n        \n        result = OrderedDict([(k, result[k]) \\\n            for k in self.parameters if k in result])\n\n        if full_output:\n            # Create model fluxes and calculate some metric.\n            chi_sq, dof, model_fluxes = self._chi_sq(result, data)\n            result = (result, chi_sq, dof, model_fluxes)\n\n        # Remove any prepared convolution functions.\n        self._destroy_convolution_functions()\n\n        return result", "response": "Optimise the model parameters given the data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _repr_label_vector(self, label_vector):\n\n        string = [\"1\"]\n        for cross_terms in label_vector:\n            sub_string = []\n            for index, order in cross_terms:\n                _ = self.grid_points.dtype.names[index]\n                if order > 1:\n                    sub_string.append(\"{0}^{1}\".format(_, order))\n                else:\n                    sub_string.append(_)\n            string.append(\" * \".join(sub_string))\n        return \" + \".join(string)", "response": "Return a human - readable representation of the Cannon label vector."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_condition(filter_map, using=CONDITIONS):\n    if not filter_map:\n        return\n\n    filters = {}\n    dynamizer = Dynamizer()\n\n    for field_and_op, value in filter_map.items():\n        field_bits = field_and_op.split('__')\n        fieldname = '__'.join(field_bits[:-1])\n\n        try:\n            op = using[field_bits[-1]]\n        except KeyError:\n            raise ConditionNotRecognizedException(\n                \"Operator '%s' from '%s' is not recognized.\" % (\n                    field_bits[-1],\n                    field_and_op\n                )\n            )\n\n        lookup = {\n            'AttributeValueList': [],\n            'ComparisonOperator': op,\n        }\n\n        # Special-case the ``NULL/NOT_NULL`` case.\n        if field_bits[-1] == 'null':\n            del lookup['AttributeValueList']\n\n            if value is False:\n                lookup['ComparisonOperator'] = 'NOT_NULL'\n            else:\n                lookup['ComparisonOperator'] = 'NULL'\n        # Special-case the ``BETWEEN`` case.\n        elif field_bits[-1] == 'between':\n            if len(value) == 2 and isinstance(value, (list, tuple)):\n                lookup['AttributeValueList'].append(\n                    dynamizer.encode(value[0])\n                )\n                lookup['AttributeValueList'].append(\n                    dynamizer.encode(value[1])\n                )\n        # Special-case the ``IN`` case\n        elif field_bits[-1] == 'in':\n            for val in value:\n                lookup['AttributeValueList'].append(dynamizer.encode(val))\n        else:\n            # Fix up the value for encoding, because it was built to only work\n            # with ``set``s.\n            if isinstance(value, (list, tuple)):\n                value = set(value)\n            lookup['AttributeValueList'].append(\n                dynamizer.encode(value)\n            )\n\n        # Finally, insert it into the filters.\n        filters[fieldname] = lookup\n    return filters", "response": "Builds a condition from a filter map."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_object(obj, marks, presumption=DELETE):\n    '''Filter down obj based on marks, presuming keys should be kept/deleted.\n\n    Args:\n        obj: The object to be filtered. Filtering is done in-place.\n        marks: An object mapping id(obj) --> {DELETE,KEEP}\n               These values apply to the entire subtree, unless inverted.\n        presumption: The default action to take on all keys.\n    '''\n    if isinstance(obj, list):\n        keys = reversed(range(0, len(obj)))\n    else:\n        keys = obj.keys()\n\n    for k in keys:\n        v = obj[k]\n        m = marks.get(id(v), UNSPECIFIED)\n        if m == DELETE:\n            del obj[k]  # an explicit deletion is irreversible.\n        elif m == KEEP or presumption==KEEP:\n            # keep descending, in case there are nodes we should delete.\n            if isinstance(v, list) or isinstance(v, dict):\n                filter_object(v, marks, presumption=KEEP)\n        elif m == UNSPECIFIED:\n            # ... and presumption == DELETE\n            if isinstance(v, list) or isinstance(v, dict):\n                filter_object(v, marks, presumption=DELETE)\n                if len(v) == 0:\n                    del obj[k]\n            else:\n                del obj[k]", "response": "Filter down obj based on marks and presuming keys should be kept or deleted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dereference(self, session, ref, allow_none=False):\n        ref = DBRef(id=ref, collection=self.type.type.get_collection_name(),\n                    database=self.db)\n        ref.type = self.type.type\n        return session.dereference(ref, allow_none=allow_none)", "response": "Dereference an ObjectID to this field s underlying type"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate and return a DBRef object.", "response": "def unwrap(self, value, fields=None, session=None):\n        ''' If ``autoload`` is False, return a DBRef object.  Otherwise load\n            the object.\n        '''\n        self.validate_unwrap(value)\n        value.type = self.type\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_unwrap(self, value, session=None):\n        ''' Validates that the DBRef is valid as well as can be done without\n            retrieving it.\n        '''\n        if not isinstance(value, DBRef):\n            self._fail_validation_type(value, DBRef)\n        if self.type:\n            expected = self.type.type.get_collection_name()\n            got = value.collection\n            if expected != got:\n                self._fail_validation(value, '''Wrong collection for reference: '''\n                                      '''got \"%s\" instead of \"%s\" ''' % (got, expected))\n        if self.db_required and not value.database:\n            self._fail_validation(value, 'db_required=True, but not database specified')\n        if self.db and value.database and self.db != value.database:\n            self._fail_validation(value, '''Wrong database for reference: '''\n                                  ''' got \"%s\" instead of \"%s\" ''' % (value.database, self.db) )", "response": "Validates that the DBRef is valid and that the DBRef is not already in use."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(self, resource=None, **meta):\n        if resource is None:\n            def wrapper(resource):\n                return self.register(resource, **meta)\n            return wrapper\n\n        # Must be instance of ResourceView\n        if not issubclass(resource, ResourceView):\n            raise AssertionError(\"%s not subclass of ResourceView\" % resource)\n\n        # Cannot be abstract\n        if resource._meta.abstract:\n            raise AssertionError(\"Attempt register of abstract resource: %s.\"\n                                 % resource)\n\n        # Fabric of resources\n        meta = dict(self.meta, **meta)\n        meta['name'] = meta.get('name', resource._meta.name)\n        options = type('Meta', tuple(), meta)\n\n        params = dict(api=self, Meta=options, **meta)\n\n        params['__module__'] = '%s.%s' % (\n            self.prefix, self.str_version.replace('.', '_'))\n\n        params['__doc__'] = resource.__doc__\n\n        new_resource = type(\n            '%s%s' % (resource.__name__, len(self.resources)),\n            (resource,), params)\n\n        if self.resources.get(new_resource._meta.url_name):\n            logger.warning(\n                \"A resource '%r' is replacing the existing record for '%s'\",\n                new_resource, self.resources.get(new_resource._meta.url_name))\n\n        self.resources[new_resource._meta.url_name] = new_resource\n\n        return resource", "response": "Add a resource to the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef urls(self):\n        urls = []\n\n        for url_name in sorted(self.resources.keys()):\n\n            resource = self.resources[url_name]\n            urls.append(resource.as_url(\n                api=self,\n                name_prefix='-'.join(\n                    (self.prefix, self.str_version)).strip('-'),\n                url_prefix=self.str_version\n            ))\n\n        return patterns(self.prefix, *urls)", "response": "Provide URLconf details for the Api."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls the resource by name.", "response": "def call(self, name, request=None, **params):\n        \"\"\" Call resource by ``Api`` name.\n\n        :param name: The resource's name (short form)\n        :param request: django.http.Request instance\n        :param **params: Params for a resource's call\n\n        :return object: Result of resource's execution\n\n        \"\"\"\n        if name not in self.resources:\n            raise exceptions.HttpError(\n                'Unknown method \\'%s\\'' % name,\n                status=status.HTTP_501_NOT_IMPLEMENTED)\n        request = request or HttpRequest()\n        resource = self.resources[name]\n        view = resource.as_view(api=self)\n        return view(request, **params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the allocated disk space for the given path in bytes.", "response": "def get_disk_usage(path):\n    \"\"\"\n    Returns the allocated disk space for the given path in bytes.\n\n    :param path: String representing the path as it would be given to the `du`\n      command. Best to give an absolute path here.\n\n    \"\"\"\n    cmd = 'du -sh --block-size=1 {0}'.format(path)\n    total = getoutput(cmd).split()[0]\n    return int(total)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_course_list_name(curriculum_abbr, course_number, section_id,\n                         quarter, year):\n    \"\"\"\n    Return the list address of UW course email list\n    \"\"\"\n    return \"%s%s%s_%s%s\" % (\n        _get_list_name_curr_abbr(curriculum_abbr),\n        course_number,\n        section_id.lower(),\n        quarter.lower()[:2],\n        str(year)[-2:]\n        )", "response": "Return the list name of UW course email list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list name of UW course section email list", "response": "def get_section_list_name(section):\n    \"\"\"\n    Return the list address of UW course section email list\n    \"\"\"\n    return get_course_list_name(section.curriculum_abbr,\n                                section.course_number,\n                                section.section_id,\n                                section.term.quarter,\n                                section.term.year)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exists_secondary_combined_list(curriculum_abbr,\n                                   course_number,\n                                   primary_section_id,\n                                   quarter,\n                                   year):\n    \"\"\"\n    Return True if a combined mailman list exists for all\n    the secondary course sections in the given quarter and year\n    \"\"\"\n    return exists(get_secondary_combined_list_name(curriculum_abbr,\n                                                   course_number,\n                                                   primary_section_id,\n                                                   quarter,\n                                                   year))", "response": "Returns True if a combined mailman list exists for the secondary course sections in the given quarter and year."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parser(input_args=None):\n\n    parser = argparse.ArgumentParser(\n        description=\"sick, the spectroscopic inference crank\", epilog=\"Use \"\n            \"'sick-model COMMAND -h' for information on a specific command.\"\n            \" Documentation and examples available at \"\n            \"https://github.com/andycasey/sick\")\n\n    # Create a parent subparser.\n    parent_parser = argparse.ArgumentParser(add_help=False)\n    parent_parser.add_argument(\n        \"-v\", \"--verbose\", dest=\"verbose\", action=\"store_true\", default=False,\n        help=\"Vebose logging mode.\")\n    parent_parser.add_argument(\n        \"--clobber\", dest=\"clobber\", action=\"store_true\", default=False, \n        help=\"Overwrite existing files if they already exist.\")\n    parent_parser.add_argument(\n        \"--debug\", dest=\"debug\", action=\"store_true\", default=False,\n        help=\"Enable debug mode. Any suppressed exception will be re-raised.\")\n    parent_parser.add_argument(\n        \"-o\", \"--output_dir\", dest=\"output_dir\", nargs=\"?\", type=str,\n        help=\"Directory for the files that will be created. If not given, this\"\n        \" defaults to the current working directory.\", default=os.getcwd())\n\n    # Create subparsers.\n    subparsers = parser.add_subparsers(title=\"command\", dest=\"command\",\n        description=\"Specify the action to perform.\")\n\n    # Create parser for the aggregate command\n    aggregate_parser = subparsers.add_parser(\n        \"aggregate\", parents=[parent_parser],\n        help=\"Aggregate many result files into a single tabular FITS file.\")\n    aggregate_parser.add_argument(\"output_filename\", type=str, nargs=1,\n        help=\"Output filename to aggregate results into.\")\n    aggregate_parser.add_argument(\"result_filenames\", nargs=\"+\",\n        help=\"The YAML result filenames to combine.\")\n    aggregate_parser.set_defaults(func=aggregate)\n\n    # Create parser for the estimate command\n    estimate_parser = subparsers.add_parser(\n        \"estimate\", parents=[parent_parser],\n        help=\"Compute a point estimate of the model parameters given the data.\")\n    estimate_parser.add_argument(\n        \"model\", type=str,\n        help=\"The model filename in YAML-style formatting.\")\n    estimate_parser.add_argument(\n        \"spectrum_filenames\", nargs=\"+\",\n        help=\"Filenames of (observed) spectroscopic data.\")\n    estimate_parser.add_argument(\n        \"--filename-prefix\", \"-p\", dest=\"filename_prefix\",\n        type=str, help=\"The filename prefix to use for the output files.\")\n    estimate_parser.add_argument(\n        \"--no-plots\", dest=\"plotting\", action=\"store_false\", default=True,\n        help=\"Disable plotting.\")\n    estimate_parser.add_argument(\n        \"--plot-format\", \"-pf\", dest=\"plot_format\", action=\"store\", type=str, \n        default=\"png\", help=\"Format for output plots (default: %(default)s)\")\n    estimate_parser.add_argument(\n        \"-r\", dest=\"read_from_filename\", action=\"store\", type=bool,\n        default=False, help=\"Read spectrum paths from a filename.\")\n    estimate_parser.set_defaults(func=estimate)\n\n    # Create parser for the optimise command\n    optimise_parser = subparsers.add_parser(\n        \"optimise\", parents=[parent_parser],\n        help=\"Optimise the model parameters, given the data.\")\n    optimise_parser.add_argument(\n        \"model\", type=str,\n        help=\"The model filename in YAML-style formatting.\")\n    optimise_parser.add_argument(\n        \"spectrum_filenames\", nargs=\"+\",\n        help=\"Filenames of (observed) spectroscopic data.\")\n    optimise_parser.add_argument(\n        \"--filename-prefix\", \"-p\", dest=\"filename_prefix\", type=str,\n        help=\"The filename prefix to use for the output files.\")\n    optimise_parser.add_argument(\n        \"--no-plots\", dest=\"plotting\", action=\"store_false\", default=True,\n        help=\"Disable plotting.\")\n    optimise_parser.add_argument(\n        \"--plot-format\", \"-pf\", dest=\"plot_format\", action=\"store\", type=str,\n        default=\"png\", help=\"Format for output plots (default: %(default)s)\")\n    optimise_parser.add_argument(\n        \"-r\", dest=\"read_from_filename\", action=\"store\", type=bool,\n        default=False, help=\"Read spectrum paths from a filename.\")\n    optimise_parser.set_defaults(func=optimise)\n\n    # Create parser for the infer command\n    infer_parser = subparsers.add_parser(\n        \"infer\", parents=[parent_parser],\n        help=\"Infer the model parameters, given the data.\")\n    infer_parser.add_argument(\n        \"model\", type=str,\n        help=\"The model filename in YAML-style formatting.\")\n    infer_parser.add_argument(\n        \"spectrum_filenames\", nargs=\"+\",\n        help=\"Filenames of (observed) spectroscopic data.\")\n    infer_parser.add_argument(\n        \"--filename-prefix\", \"-p\", dest=\"filename_prefix\", type=str,\n        help=\"The filename prefix to use for the output files.\")\n    infer_parser.add_argument(\n        \"--no-chains\", dest=\"save_chain_files\", action=\"store_false\",\n        default=True, help=\"Do not save the chains to disk.\", )\n    infer_parser.add_argument(\n        \"--no-plots\", dest=\"plotting\", action=\"store_false\", default=True,\n        help=\"Disable plotting.\")\n    infer_parser.add_argument(\n        \"--plot-format\", \"-pf\", dest=\"plot_format\", action=\"store\", type=str,\n        default=\"png\", help=\"Format for output plots (default: %(default)s)\")\n    infer_parser.add_argument(\n        \"-r\", dest=\"read_from_filename\", action=\"store\", type=bool,\n        default=False, help=\"Read spectrum paths from a filename.\")\n    infer_parser.set_defaults(func=infer)\n\n    args = parser.parse_args(input_args)\n    logger.setLevel(logging.DEBUG if args.verbose else logging.INFO)\n\n    # Check plot formats.\n    if args.command.lower() in (\"estimate\", \"optimise\", \"infer\") \\\n    and args.plotting:\n\n        import matplotlib.pyplot as plt\n        fig = plt.figure()\n        available = fig.canvas.get_supported_filetypes().keys()\n        plt.close(fig)\n\n        if args.plot_format.lower() not in available:\n            raise ValueError(\"plotting format {0} is unavailable: Options are:\"\\\n                \" {1}\".format(args.plot_format.lower(), \", \".join(available)))\n\n    # Create a default filename prefix based on the input filename arguments\n    if args.command.lower() in (\"estimate\", \"optimise\", \"infer\") \\\n    and args.filename_prefix is None \\\n    and not args.read_from_filename:\n        args.filename_prefix = _default_output_prefix(args.spectrum_filenames)\n\n        handler = logging.FileHandler(\"{}.log\".format(\n            os.path.join(args.output_dir, args.filename_prefix)))\n        formatter = logging.Formatter(\"%(asctime)s [%(levelname)s] %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    else:\n        args.filename_prefix = \"\"\n\n    return args", "response": "Returns a command line parser for the sick."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _announce_theta(theta):\n\n    c = 299792.458 # km/s\n    is_a_redshift = lambda p: p == \"z\" or p[:2] == \"z_\"\n\n    for parameter, value in theta.items():\n        try:\n            value[0]\n        except (IndexError, TypeError):\n            message = \"\\t{0}: {1:.3f}\".format(parameter, value)\n            if is_a_redshift(parameter):\n                message += \" [{0:.1f} km/s]\".format(value * c)\n        else:\n            # (MAP, u_pos, u_neg)\n            message = \"\\t{0}: {1:.3f} ({2:+.3f}, {3:+.3f})\".format(parameter,\n                value[0], value[1], value[2])\n            if is_a_redshift(parameter):\n                message += \" [{0:.1f} ({1:+.1f}, {2:+.1f}) km/s]\".format(\n                    value[0] * c, value[1] * c, value[2] * c)\n        logger.info(message)", "response": "Announce the theta values to the log."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a default filename prefix for output files based on the input files.", "response": "def _default_output_prefix(filenames):\n    \"\"\"\n    Return a default filename prefix for output files based on the input files.\n\n    :param filenames:\n        The input filename(s):\n\n    :type filenames:\n        str or list of str\n\n    :returns:\n        The extensionless common prefix of the input filenames:\n\n    :rtype:\n        str\n    \"\"\"\n\n    if isinstance(filenames, (str, )):\n        filenames = [filenames]\n    common_prefix, ext = os.path.splitext(os.path.commonprefix(\n        map(os.path.basename, filenames)))\n    common_prefix = common_prefix.rstrip(\"_-\")\n    return common_prefix if len(common_prefix) > 0 else \"sick\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef estimate(args, **kwargs):\n\n    expected_output_files = kwargs.pop(\"expected_output_files\", None)\n    if not expected_output_files:\n        expected_output_files = [\"estimate.pkl\"]\n        if args.plotting:\n            expected_output_files.extend(\n                [\"projection-estimate.{}\".format(args.plot_format)])\n        \n    model, data, metadata = _pre_solving(args, expected_output_files)\n\n    try:\n        theta, chisq, dof, model_fluxes = model.estimate(data, full_output=True,\n            debug=args.debug)\n\n    except:\n        logger.exception(\"Failed to estimate model parameters\")\n        raise\n\n    logger.info(\"Estimated model parameters are:\")\n    _announce_theta(theta)\n    logger.info(\"With a chi-sq value of {0:.1f} (reduced {1:.1f}; DOF {2:.1f})\"\\\n        .format(chisq, chisq/dof, dof))\n\n    metadata[\"estimated\"] = {\n        \"theta\": theta,\n        \"chi_sq\": chisq,\n        \"dof\": dof,\n        \"r_chi_sq\": chisq/dof\n    }\n\n    if args.plotting:\n        fig = sick.plot.spectrum(data, model_flux=model_fluxes)\n        filename = _prefix(args, \"projection-estimate.{}\".format(\n            args.plot_format))\n        fig.savefig(filename)\n        logger.info(\"Created figure {}\".format(filename))\n\n    if kwargs.pop(\"__return_result\", False):\n        return (model, data, metadata, theta)\n\n    # Write the result to file.\n    _write_output(_prefix(args, \"estimate.pkl\"), metadata)\n    return None", "response": "Return a point estimate of the model parameters theta given the data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noptimise the model parameters.", "response": "def optimise(args, **kwargs):\n    \"\"\"\n    Optimise the model parameters.\n    \"\"\"\n\n    expected_output_files = kwargs.pop(\"expected_output_files\", None)\n    if not expected_output_files:\n        expected_output_files = [\"optimised.pkl\"]\n        if args.plotting:\n            expected_output_files.extend([\n                \"projection-estimate.{}\".format(args.plot_format),\n                \"projection-optimised.{}\".format(args.plot_format)\n            ])\n        \n    # Estimate the model parameters, unless they are already specified.\n    model = sick.models.Model(args.model)\n    initial_theta = model._configuration.get(\"initial_theta\", {})\n    if len(set(model.parameters).difference(initial_theta)) == 0:\n        model, data, metadata = _pre_solving(args, expected_output_files)\n\n    else:\n        model, data, metadata, initial_theta = estimate(args, \n            expected_output_files=expected_output_files, __return_result=True)\n\n    try:\n        theta, chisq, dof, model_fluxes = model.optimise(data, \n            initial_theta=initial_theta, full_output=True, debug=args.debug)\n\n    except:\n        logger.exception(\"Failed to optimise model parameters\")\n        raise\n\n    metadata[\"optimised\"] = {\n        \"theta\": theta,\n        \"chi_sq\": chisq,\n        \"dof\": dof,\n        \"r_chi_sq\": chisq/dof\n    }\n\n    logger.info(\"Optimised model parameters are:\")\n    _announce_theta(theta)\n    logger.info(\"With a chi-sq value of {0:.1f} (reduced {1:.1f}; DOF {2:.1f})\"\\\n        .format(chisq, chisq/dof, dof))\n\n    if args.plotting:\n        fig = sick.plot.spectrum(data, model_flux=model_fluxes)\n        filename = _prefix(args, \"projection-optimised.{}\".format(\n            args.plot_format))\n        fig.savefig(filename)\n        logger.info(\"Created figure {}\".format(filename))\n\n    if kwargs.pop(\"__return_result\", False):\n        return (model, data, metadata, theta)\n\n    # Write the results to file.\n    _write_output(_prefix(args, \"optimised.pkl\"), metadata)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninferring the model parameters.", "response": "def infer(args):\n    \"\"\"\n    Infer the model parameters.\n    \"\"\"\n\n    expected_output_files = [\"inferred.pkl\"]\n    if args.plotting:\n        expected_output_files.extend([each.format(args.plot_format) \\\n            for each in \"chain.{}\", \"corner.{}\", \"acceptance-fractions.{}\",\n            \"autocorrelation.{}\"])\n\n    # Optimise them first.\n    model, data, metadata, optimised_theta = optimise(args,\n        expected_output_files=expected_output_files, __return_result=True)\n\n    # Get the inference parameters from the model configuration.\n    kwargs = model._configuration.get(\"infer\", {})\n    [kwargs.pop(k, None) \\\n        for k in (\"debug\", \"full_output\", \"initial_proposal\", \"data\")]\n\n    try:\n        theta, chains, lnprobability, acceptance_fractions, sampler, info_dict \\\n            = model.infer(data, initial_proposal=optimised_theta, \n                full_output=True, debug=args.debug, \n                __keep_convolution_functions=True,\n                __show_progress_bar=True, **kwargs)\n\n    except:\n        logger.exception(\"Failed to infer model parameters\")\n        raise\n\n    metadata[\"inferred\"] = {\n        \"theta\": theta,\n        \"chi_sq\": info_dict[\"chi_sq\"],\n        \"dof\": info_dict[\"dof\"],\n        \"r_chi_sq\": info_dict[\"chi_sq\"]/info_dict[\"dof\"]\n    }\n\n    logger.info(\"Inferred parameters are:\")\n    _announce_theta(theta)\n    \n    # Write the results to file.\n    _write_output(_prefix(args, \"inferred.pkl\"), metadata)\n\n    # Write the chains, etc to disk.\n    if args.save_chain_files:\n        filename = _prefix(args, \"chains.pkl\")\n        with open(filename, \"wb\") as f:\n            pickle.dump(\n                (chains, lnprobability, acceptance_fractions, info_dict), f, -1)\n        logger.info(\"Saved chains to {}\".format(filename))\n\n    # Make plots.\n    if args.plotting:\n        burn = info_dict[\"burn\"]\n\n        # Any truth values to plot?\n        truths = model._configuration.get(\"truths\", None)\n        if truths:\n            truths = [truths.get(p, np.nan) for p in model.parameters]\n\n        # Labels?\n        labels = model._configuration.get(\"labels\", {})\n        labels = [labels.get(p, p) for p in info_dict[\"parameters\"]]\n        \n        # Acceptance fractions.\n        fig = sick.plot.acceptance_fractions(acceptance_fractions,\n            burn=burn)\n        _ = _prefix(args, \"acceptance-fractions.{}\".format(args.plot_format))\n        fig.savefig(_)\n        logger.info(\"Saved acceptance fractions figure to {}\".format(_))\n\n        # Autocorrelation.\n        fig = sick.plot.normalised_autocorrelation_function(chains, burn=burn)\n        _ = _prefix(args, \"auto-correlation.{}\".format(args.plot_format))\n        fig.savefig(_)\n        logger.info(\"Saved auto-correlation figure to {}\".format(_))\n\n        # Chains.\n        fig = sick.plot.chains(chains, labels=labels, burn=burn,\n            truths=truths)\n        _ = _prefix(args, \"chains.{}\".format(args.plot_format))\n        fig.savefig(_)\n        logger.info(\"Saved chains figure to {}\".format(_))\n\n        # Corner plots (astrophysical + all).\n        N = len(model.grid_points.dtype.names)\n        fig = sick.plot.corner(chains[:, burn:, :N].reshape(-1, N),\n            labels=labels, truths=truths[:N] if truths else None)\n        _ = _prefix(args, \"corner.{}\".format(args.plot_format))\n        fig.savefig(_)\n        logger.info(\"Saved corner plot (astrophysical parameters) to {}\"\\\n            .format(_))\n\n        if len(model.parameters) > N:\n            fig = sick.plot.corner(chains[:, burn:, :].reshape(-1, len(theta)),\n                labels=labels, truths=truths)\n            _ = _prefix(args, \"corner-all.{}\".format(args.plot_format))\n            fig.savefig(_)\n            logger.info(\"Saved corner plot (all parameters) to {}\".format(_))\n\n        # Projections.\n        # Note here we need to scale the chains back to redshift so the data\n        # are generated properly.\n        fig = sick.plot.projection(data, model, \n            chains=chains[:, burn:, :]/info_dict[\"scales\"],\n            parameters=theta.keys())\n        _ = _prefix(args, \"projection.{}\".format(args.plot_format))\n        fig.savefig(_)\n        logger.info(\"Saved projection plot to {}\".format(_))\n\n    model._destroy_convolution_functions()\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aggregate(args):\n\n    _ok_to_clobber(args, [args.output_filename[0]], \"\")\n    logger.debug(\"Aggregating to {}\".format(args.output_filename[0]))\n\n    from astropy.table import Table\n\n    # What header keys should be passed to the final table?\n    header_keys = [\"RA\", \"DEC\", \"NAME\", \"OBJECT\", \"MAGNITUDE\",\n        \"UTSTART\", \"UTEND\", \"UTDATE\", \"V_HELIO\", \"V_BARY\"]\n\n    def load_result_file(filename, debug):\n        \n        loader = yaml.load if filename.lower().endswith(\".yaml\") else pickle.load\n        with open(filename, \"r\") as fp:\n            try:\n                result = loader(fp)\n            \n            except:\n                logger.exception(\"Could not read results filename: {}\".format(\n                    filename))\n                if debug: raise\n\n            else:\n                logger.debug(\"Successfully loaded results from {}\".format(\n                    filename))\n        return result\n\n    # Dows the first result actually exist, or is it a wildname mask?\n    if not os.path.exists(args.result_filenames[0]):\n        args.result_filenames = glob(args.result_filenames[0])\n\n    # Load the first set of results to get the parameter names.\n    first_results = load_result_file(args.result_filenames[0], True)\n    parameters = set(first_results[\"estimated\"][\"theta\"].keys() \\\n        + first_results.get(\"optimised\", {}).get(\"theta\", {}).keys() \\\n        + first_results.get(\"inferred\", {}).get(\"theta\", {}).keys())\n\n    # Grab headers that exist.\n    header_keys = [k for k in header_keys if k in first_results[\"headers\"]]\n\n    def default_values(stage):\n        keys = \"chi_sq dof r_chi_sq\".split()\n        default = dict(zip([\"{0}_{1}\".format(stage, key) for key in keys],\n            [np.nan] * len(keys)))\n        default[\"theta\"] = dict(zip(\n            [\"{0}_{1}\".format(stage, parameter) for parameter in parameters],\n            [np.nan] * len(parameters)))\n        return default\n\n    def extract_values(result, stage, parameter_prefixes=None):\n        _ = {\n            \"{}_chi_sq\".format(stage): result.get(\"chi_sq\", np.nan),\n            \"{}_dof\".format(stage): result.get(\"dof\", np.nan),\n            \"{}_r_chi_sq\".format(stage): result.get(\"r_chi_sq\", np.nan)\n        }\n        _.update(dict(zip(\n            [\"{0}_{1}\".format(stage, parameter) for parameter in parameters],\n            [result[\"theta\"].get(param, np.nan) for param in parameters])))\n\n        if parameter_prefixes is not None:\n            for prefix in parameter_prefixes:\n                _.update(dict(zip(\n                    [\"_\".join([stage, prefix, parameter]) \\\n                        for parameter in parameters],\n                    [result.get(\"{0}_{1}\".format(prefix, parameter), np.nan) \\\n                        for parameter in parameters])))\n        return _\n\n    rows = []\n    columns = [] + header_keys + [\"SNR\", \"model\", \"sick_version\", \"results_filename\"]\n    for i, filename in enumerate(args.result_filenames):\n\n        result = load_result_file(filename, debug=args.debug)\n        logger.debug(\"Loaded results from {}\".format(filename))\n\n        # Header information.\n        row = dict(zip(header_keys,\n            [result[\"headers\"].get(k, None) for k in header_keys]))\n        row.update({\n            \"model\": result[\"model\"],\n            \"sick_version\": result[\"sick_version\"],\n            \"results_filename\": filename,\n            \"SNR\": result[\"SNR\"]\n        })\n        \n        # Include estimated values (which should always be present)\n        estimated = extract_values(result[\"estimated\"], \"estimated\")\n        row.update(estimated)\n        \n        # Include optimised values, if they exist.\n        optimised = extract_values(\n            result.get(\"optimised\", default_values(\"optimised\")), \"optimised\")\n        row.update(optimised)\n\n        # Include inferred values, if they exist.\n        inferred = extract_values(\n            result.get(\"inferred\", default_values(\"inferred\")), \"inferred\",\n            parameter_prefixes=[\"u_pos\", \"u_neg\", \"n_eff\"])\n        row.update(inferred)\n        rows.append(row)\n\n    for each in (estimated, optimised, inferred):\n        columns += sorted(each.keys())\n\n    table = Table(rows=rows, names=columns)\n    try:\n        table.write(args.output_filename[0], overwrite=args.clobber)\n    except TypeError:\n        table.write(args.output_filename[0])\n        logger.info(\"Results from {0} files aggregated and saved to {1}\".format(\n            len(args.result_filenames), args.output_filename[0]))", "response": "Aggregate the results from multiple analyses into a single file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_file_or_directory(path):\n    assert os.path.exists(path), \"{0} does not exist!\".format(path)\n    absolute_path = os.path.abspath(path)\n    if not os.path.isdir(path):\n        yield absolute_path\n    else:\n        for root, dirs, file_paths in os.walk(path):\n            for file_path in file_paths:\n                yield os.path.join(root, file_path)", "response": "Given a path determine if the path is a file or directory and yield a list of absolute file paths that are available to the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef retrieve_data(file_paths):\n\n    \"\"\"\n    passed an iterable list of file_paths, loop through all of them and\n    generate a dictionary containing all the context\n    \"\"\"\n    data_dict = {}\n    for file_path in file_paths:\n        with open(file_path) as fh:\n            try:\n                content = yaml.load(fh.read())\n            except yaml.YAMLError as e:\n                raise MiuraException(\n                    \"Unable to parse yaml at {0}: \\n {1}\".format(\n                        file_path,\n                        str(e)\n                    ))\n            if not isinstance(content, dict):\n                raise MiuraException(\n                    \"{0} is does not translate to a dictionary!\".format(file_path)\n                )\n            data_dict.update(content)\n    return data_dict", "response": "Given a list of file paths loop through all of them and generate a dictionary containing all the context\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter a data dictionary for values only matching the filter", "response": "def filter_data(data, filter_dict):\n    \"\"\" filter a data dictionary for values only matching the filter \"\"\"\n    for key, match_string in filter_dict.items():\n        if key not in data:\n            logger.warning(\"{0} doesn't match a top level key\".format(key))\n            continue\n        values = data[key]\n        matcher = re.compile(match_string)\n        if isinstance(values, list):\n            values = [v for v in values if matcher.search(v)]\n        elif isinstance(values, dict):\n            values = dict((k, v) for k, v in values.items() if matcher.search(k))\n        else:\n            raise MiuraException(\"cannot filter a {0}\".format(type(values)))\n        data[key] = values"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_sql(self, instring, schema, use_bag_semantics=False):\n        root_list = self.to_syntax_tree(instring, schema)\n        return sql_translator.translate(root_list, use_bag_semantics)", "response": "Translate a relational algebra string into a SQL string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntranslating a relational algebra string into a list of SQL strings generated by a post - order traversal of the parse tree.", "response": "def to_sql_sequence(self, instring, schema, use_bag_semantics=False):\n        \"\"\"\n        Translate a relational algebra string into a list of SQL strings generated\n        by a post-order traversal of the parse tree for the input string.\n\n        :param instring: a relational algebra string to translate\n        :param schema: a mapping of relation names to their attributes\n        :param use_bag_semantics: flag for using relational algebra bag semantics\n        :return: a list of SQL translation strings\n        \"\"\"\n        root_list = self.to_syntax_tree(instring, schema)\n        return [\n            sql_translator.translate(root.post_order(), use_bag_semantics)\n            for root in root_list\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_qtree(self, instring, schema):\n        root_list = self.to_syntax_tree(instring, schema)\n        return qtree_translator.translate(root_list)", "response": "Translate a relational algebra string into a string representing a latex tree"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate a select node into a latex qtree subtree rooted at the node.", "response": "def select(self, node):\n        \"\"\"\n        Translate a select node into a latex qtree node.\n        :param node: a treebrd node\n        :return: a qtree subtree rooted at the node\n        \"\"\"\n        child = self.translate(node.child)\n        return '[.${op}_{{{conditions}}}$ {child} ]'\\\n            .format(op=latex_operator[node.operator],\n                    conditions=node.conditions, child=child)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef project(self, node):\n        child = self.translate(node.child)\n        return '[.${op}_{{{attributes}}}$ {child} ]'\\\n            .format(op=latex_operator[node.operator],\n                    attributes=', '.join(node.attributes.names),\n                    child=child)", "response": "Translate a project node into latex qtree node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntranslating a rename node into latex qtree node.", "response": "def rename(self, node):\n        \"\"\"\n        Translate a rename node into latex qtree node.\n        :param node: a treebrd node\n        :return: a qtree subtree rooted at the node\n        \"\"\"\n        child = self.translate(node.child)\n        attributes = ''\n        if node.attributes:\n            attributes = '({})'.format(', '.join(node.attributes.names))\n        return '[.${op}_{{{name}{attributes}}}$ {child} ]'\\\n            .format(op=latex_operator[node.operator], name=node.name,\n                    attributes=attributes,\n                    child=child)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef assign(self, node):\n        child = self.translate(node.child)\n        attributes = ''\n        if node.attributes:\n            attributes = '({})'.format(','.join(node.attributes.names))\n        return '[.${name}{attributes}$ {child} ]'\\\n            .format(name=node.name, attributes=attributes, child=child)", "response": "Translate an assign node into latex qtree node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef theta_join(self, node):\n        return '[.${op}_{{{conditions}}}$ {left} {right} ]'\\\n            .format(op=latex_operator[node.operator],\n                    conditions=node.conditions,\n                    left=self.translate(node.left),\n                    right=self.translate(node.right))", "response": "Translate a join node into latex qtree node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntranslates a binary node into latex qtree node.", "response": "def _binary(self, node):\n        \"\"\"\n        Translate a binary node into latex qtree node.\n        :param node: a treebrd node\n        :return: a qtree subtree rooted at the node\n        \"\"\"\n        return '[.${op}$ {left} {right} ]'\\\n            .format(op=latex_operator[node.operator],\n                    left=self.translate(node.left),\n                    right=self.translate(node.right))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_attributes(self, name):\n        attributes = self._data.get(name, None)\n        if not attributes:\n            raise RelationReferenceError(\n                'Relation \\'{name}\\' does not exist.'.format(name=name))\n        return attributes[:]", "response": "Return the list of attributes associated with the specified relation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the relation to the schema.", "response": "def add(self, name, attributes):\n        \"\"\"\n        Add the relation to the Schema.\n        :param name: The name of a relation.\n        :param attributes: A list of attributes for the relation.\n        :raise RelationReferenceError: Raised if the name already exists.\n        \"\"\"\n        if name in self._data:\n            raise RelationReferenceError(\n                'Relation \\'{name}\\' already exists.'.format(name=name))\n        self._data[name] = attributes[:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntotals count of the matching items in the table. It sums up the count of partial results and returns the total count of matching items in the table.", "response": "def count(self):\n        \"\"\"Total count of the matching items.\n\n        It sums up the count of partial results, and returns the total count of\n        matching items in the table.\n        \"\"\"\n        count = 0\n        operation = self._get_operation()\n        kwargs = self.kwargs.copy()\n        kwargs['select'] = 'COUNT'\n        limit = kwargs.get('limit', None)\n        while True:\n            result = operation(self.model.get_table_name(), **kwargs)\n            count += result['Count']\n            if limit is not None:\n                limit -= result['Count']\n\n            last_evaluated_key = result.get('LastEvaluatedKey', None)\n            if not self._prepare_next_fetch(kwargs, last_evaluated_key, limit):\n                break\n        return count"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve_out(self, ins):\n        values = set()\n        for value in ins.values():\n            values.update(value)\n        if len(values) > 1:\n            msg = 'Unable to resolve sync stream. Consider adding a custom resolver to {}.'\n            raise ValueError(msg.format(self.step.name))\n        return {key: values for key in self.step.outs}", "response": "Resolves the output of the current step."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mdct(x, L):\n    x = np.asarray(x, dtype=np.float)\n\n    N = x.size\n\n    # Number of frequency channels\n    K = L // 2\n\n    # Test length\n    if N % K != 0:\n        raise RuntimeError('Input length must be a multiple of the half of '\n                           'the window size')\n\n    # Pad edges with zeros\n    xx = np.zeros(L // 4 + N + L // 4)\n    xx[L // 4:-L // 4] = x\n    x = xx\n    del xx\n\n    # Number of frames\n    P = N // K\n    if P < 2:\n        raise ValueError('Signal too short')\n\n    # Framing\n    x = _framing(x, L)\n\n    # Windowing\n    aL = np.arange(L, dtype=np.float)\n    w_long = np.sin((np.pi / L) * (aL + 0.5))\n    w_edge_L = w_long.copy()\n    w_edge_L[:L // 4] = 0.\n    w_edge_L[L // 4:L // 2] = 1.\n    w_edge_R = w_long.copy()\n    w_edge_R[L // 2:L // 2 + L // 4] = 1.\n    w_edge_R[L // 2 + L // 4:] = 0.\n    x[:, 0] *= w_edge_L\n    x[:, 1:-1] *= w_long[:, None]\n    x[:, -1] *= w_edge_R\n\n    # Pre-twiddle\n    x = x.astype(np.complex)\n    x *= np.exp((-1j * np.pi / L) * aL)[:, None]\n\n    # FFT\n    y = fft(x, axis=0)\n\n    # Post-twiddle\n    y = y[:L // 2, :]\n    y *= np.exp((-1j * np.pi * (L // 2 + 1.) / L)\n                * (0.5 + aL[:L // 2]))[:, None]\n\n    # Real part and scaling\n    y = math.sqrt(2. / K) * np.real(y)\n    return y", "response": "Modified Discrete Cosine Transform ( MDCT )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninverses Modified Discrete Cosine Transform is the inverse of the MDCT transform.", "response": "def imdct(y, L):\n    \"\"\"Inverse Modified Discrete Cosine Transform (MDCT)\n\n    Returns the Inverse Modified Discrete Cosine Transform\n    with fixed window size L of the vector of coefficients y.\n\n    The window is based on a sine window.\n\n    Parameters\n    ----------\n    y : ndarray, shape (L/2, 2 * N / L)\n        The MDCT coefficients\n    L : int\n        The window length\n\n    Returns\n    -------\n    x : ndarray, shape (N,)\n        The reconstructed signal\n\n    See also\n    --------\n    mdct\n    \"\"\"\n    # Signal length\n    N = y.size\n\n    # Number of frequency channels\n    K = L // 2\n\n    # Test length\n    if N % K != 0:\n        raise ValueError('Input length must be a multiple of the half of '\n                         'the window size')\n\n    # Number of frames\n    P = N // K\n    if P < 2:\n        raise ValueError('Signal too short')\n\n    # Reshape\n    temp = y\n    y = np.zeros((L, P), dtype=np.float)\n    y[:K, :] = temp\n    del temp\n\n    # Pre-twiddle\n    aL = np.arange(L, dtype=np.float)\n    y = y * np.exp((1j * np.pi * (L / 2. + 1.) / L) * aL)[:, None]\n\n    # IFFT\n    x = ifft(y, axis=0)\n\n    # Post-twiddle\n    x *= np.exp((1j * np.pi / L) * (aL + (L / 2. + 1.) / 2.))[:, None]\n\n    # Windowing\n    w_long = np.sin((np.pi / L) * (aL + 0.5))\n    w_edge_L = w_long.copy()\n    w_edge_L[:L // 4] = 0.\n    w_edge_L[L // 4:L // 2] = 1.\n    w_edge_R = w_long.copy()\n    w_edge_R[L // 2:L // 2 + L // 4] = 1.\n    w_edge_R[L // 2 + L // 4:L] = 0.\n    x[:, 0] *= w_edge_L\n    x[:, 1:-1] *= w_long[:, None]\n    x[:, -1] *= w_edge_R\n\n    # Real part and scaling\n    x = math.sqrt(2. / K) * L * np.real(x)\n\n    # Overlap and add\n    def overlap_add(y, x):\n        z = np.concatenate((y, np.zeros((K,))))\n        z[-2 * K:] += x\n        return z\n\n    x = six.moves.reduce(overlap_add, [x[:, i] for i in range(x.shape[1])])\n\n    # Cut edges\n    x = x[K // 2:-K // 2].copy()\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_surrogate_id(self):\n        surrogate_id = \"%s,%s,%s,%s,%s\" % (self.year,\n                                           self.quarter,\n                                           self.curriculum_abbr.lower(),\n                                           self.course_number,\n                                           self.section_id.lower())\n\n        return surrogate_id", "response": "This method returns the surrogate id of the current locale"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _verify(self):\n        if not self.keyid:\n            raise ValueError('No GPG key specified for signing, did you mean to use --no-sign?')\n        sign = self.gpg.sign('', keyid=self.keyid)\n        if 'secret key not available' in sign.stderr:\n            raise ValueError('Key not found')\n        elif 'NEED_PASSPHRASE' in sign.stderr:\n            self.passphrase = getpass.getpass('Passphrase for GPG key: ')", "response": "Some sanity checks on GPG."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsolves the current script type.", "response": "def solve(self, **kwargs):\n    \"\"\"\n    The kwargs required depend upon the script type.\n    hash160_lookup:\n        dict-like structure that returns a secret exponent for a hash160\n    existing_script:\n        existing solution to improve upon (optional)\n    sign_value:\n        the integer value to sign (derived from the transaction hash)\n    signature_type:\n        usually SIGHASH_ALL (1)\n    \"\"\"\n    # we need a hash160 => secret_exponent lookup\n    db = kwargs.get(\"hash160_lookup\")\n    if db is None:\n        raise SolvingError(\"missing hash160_lookup parameter\")\n\n    sign_value = kwargs.get(\"sign_value\")\n    signature_type = kwargs.get(\"signature_type\")\n\n    secs_solved = set()\n    existing_signatures = []\n    existing_script = kwargs.get(\"existing_script\")\n    if existing_script:\n        pc = 0\n        opcode, data, pc = tools.get_opcode(existing_script, pc)\n        # ignore the first opcode\n        while pc < len(existing_script):\n            opcode, data, pc = tools.get_opcode(existing_script, pc)\n            sig_pair, actual_signature_type = parse_signature_blob(data)\n            for sec_key in self.sec_keys:\n                try:\n                    public_pair = encoding.sec_to_public_pair(sec_key)\n                    sig_pair, signature_type = parse_signature_blob(data)\n                    v = ecdsa.verify(ecdsa.generator_secp256k1, public_pair, sign_value, sig_pair)\n                    if v:\n                        existing_signatures.append(data)\n                        secs_solved.add(sec_key)\n                        break\n                except encoding.EncodingError:\n                    # if public_pair is invalid, we just ignore it\n                    pass\n\n    for sec_key in self.sec_keys:\n        if sec_key in secs_solved:\n            continue\n        if len(existing_signatures) >= self.n:\n            break\n        hash160 = encoding.hash160(sec_key)\n        result = db.get(hash160)\n        if result is None:\n            continue\n        secret_exponent, public_pair, compressed = result\n        binary_signature = self._create_script_signature(secret_exponent, sign_value, signature_type)\n        existing_signatures.append(b2h(binary_signature))\n    DUMMY_SIGNATURE = \"OP_0\"\n    while len(existing_signatures) < self.n:\n        existing_signatures.append(DUMMY_SIGNATURE)\n\n    script = \"OP_0 %s\" % \" \".join(s for s in existing_signatures)\n    solution = tools.compile(script)\n    return solution"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, wallet_id, passcode, address, amount, message='', fee=None, fan_unspend=10):\n        MINIMAL_FEE = 20000\n        MINIMAL_SPLIT = 10000000\n\n        wallet = self.get_wallet(wallet_id)\n\n        if not wallet['spendingAccount']:\n            raise NotSpendableWallet()\n\n        if not wallet['isActive']:\n            raise NotActiveWallet()\n\n        if amount < 10000:\n            raise Exception('amount to small')\n\n        if wallet['confirmedBalance'] < amount:\n            raise NotEnoughFunds('Not enough funds: balance %s amount %s' %\n                                 (wallet['confirmedBalance'], amount)\n            )\n\n        change_address = self.create_address(wallet_id, chain=1)\n        usableKeychain = False\n        spendables = []\n        chain_paths = []\n        p2sh = []\n        payables = [(address, amount)]\n        keychain_path = \"\"\n\n        for keychain in wallet['private']['keychains']:\n            keychain_path = keychain['path'][1:]\n            keychain = self.get_keychain(keychain['xpub'])\n            if 'encryptedXprv' not in keychain:\n                continue\n            usableKeychain = True\n            break\n\n        if not usableKeychain:\n            raise BitGoError(\"didn't found a spendable keychain\")\n\n        data = json.loads(keychain['encryptedXprv'])\n        #add base64 paddings\n        for k in ['iv', 'salt', 'ct']:\n            data[k] = data[k] + \"==\"\n        cipher = sjcl.SJCL()\n        xprv = cipher.decrypt(data, passcode)\n\n        unspents = self.get_unspents(wallet_id)\n        unspents = filter(lambda u: u['confirmations'] > 0, unspents['unspents'][::-1])\n\n        total_value = 0\n        for d in unspents:\n            path = keychain_path + d['chainPath']\n            chain_paths.append(path)\n            p2sh.append(h2b(d[\"redeemScript\"]))\n            spendables.append(Spendable(d[\"value\"],\n                                  h2b(d[\"script\"]),\n                                  h2b_rev(d[\"tx_hash\"]),\n                                  d[\"tx_output_n\"]))\n\n            total_value += d['value']\n            if total_value > amount:\n                break\n\n        # make many outputs?\n        if len(unspents) < 5 and (total_value > (amount + MINIMAL_SPLIT)) and fan_unspend > 0:\n            fee = self.calculate_fee(len(spendables), fan_unspend)\n            value = (total_value - amount - fee) / fan_unspend\n            for i in range(fan_unspend):\n                payables.append((change_address, value))\n        elif total_value > (amount + MINIMAL_FEE):\n            # add a change address\n            if fee is None:\n                fee = self.calculate_fee(len(spendables), 2)\n            value = total_value - amount - fee\n            if value > 10000: #avoid dust\n                payables.append((change_address, value))\n\n        p2sh_lookup = build_p2sh_lookup(p2sh)\n\n        spendable_keys = []\n\n        priv_key = BIP32Node.from_hwif(xprv)\n\n        spendable_keys = [priv_key.subkey_for_path(path) for path in chain_paths]\n\n        hash160_lookup = build_hash160_lookup([key.secret_exponent() for key in spendable_keys])\n\n        tx = create_tx(spendables, payables)\n\n        tx.sign(hash160_lookup=hash160_lookup, p2sh_lookup=p2sh_lookup)\n\n        r = requests.post(self.url + '/tx/send', {\n                'tx': tx.as_hex(),\n                'message': message\n            }, headers={\n                'Authorization': 'Bearer %s' % self.access_token,\n            })\n\n        return r.json()", "response": "Send bitcoins to address"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index_normalize(index_val):\n    index_val = index_val.lower().strip()\n    index_val = re.sub(r'^\\W*','',index_val)\n    index_val = re.sub(r'\\W*$','',index_val)\n    index_val = re.sub(r'\\W+','_',index_val)\n    index_val = re.sub('_+','_',index_val)\n    return index_val", "response": "Normalizes the input string to a dictionary calculated key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_frequent_n_grams(self, input_reader, n, min_frequency, min_pmi, filters):\n        line_counter = 0\n        TweetNGramsPMI.tweet_reader = input_reader\n        TweetNGramsPMI.n_gram_tree = self.NGramTree()\n\n        # Todo: Parallelize\n        for tweet in self.tweet_reader:\n            line_counter += 1\n            if line_counter % 200000 == 0:\n                TweetNGramsPMI.n_gram_tree.prune_infrequent(math.ceil(min_frequency * line_counter / 2.))\n\n            tweet = filters.apply(tweet)\n            for sentence in RegexFilters.SENTENCE_END_PUNCTUATION.split(tweet):\n                tokens = RegexFilters.WHITESPACE.split(sentence.strip())\n                if len(tokens) == 1:\n                    continue\n\n                for i in range(len(tokens)):\n                    self.n_gram_tree.increment_n_gram(tokens[i:min(i + n, len(tokens))])\n\n        return self.n_gram_tree.get_n_grams(int(min_frequency * line_counter), min_pmi)", "response": "This method finds all frequent n - grams in a file and returns a map of n - grams as key and number of occurrences as value\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the type of value is correct and that the length of value is correct and that the elements of value are valid.", "response": "def validate_wrap(self, value):\n        ''' Checks that the type of ``value`` is correct as well as validating\n            the elements of value'''\n        self._validate_wrap_type(value)\n        self._length_valid(value)\n        for v in value:\n            self._validate_child_wrap(v)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that the type of value is correct and that the length of value is correct and that the elements of value are valid.", "response": "def validate_unwrap(self, value, session=None):\n        ''' Checks that the type of ``value`` is correct as well as validating\n            the elements of value'''\n        self._validate_unwrap_type(value)\n        self._length_valid(value)\n        for v in value:\n            if self.has_autoload:\n                self._validate_child_unwrap(v, session=session)\n            else:\n                self._validate_child_unwrap(v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unwrap(self, value, session=None):\n        ''' Unwraps the elements of ``value`` using ``ListField.item_type`` and\n            returns them in a list'''\n        kwargs = {}\n        if self.has_autoload:\n            kwargs['session'] = session\n        self.validate_unwrap(value, **kwargs)\n        return [ self.item_type.unwrap(v, **kwargs) for v in value]", "response": "Unwraps the elements of value using self. item_type and\n            returns them in a list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunwrapping the elements of value using self. item_type and returns them in a set.", "response": "def unwrap(self, value, session=None):\n        ''' Unwraps the elements of ``value`` using ``SetField.item_type`` and\n            returns them in a set'''\n        self.validate_unwrap(value)\n        return set([self.item_type.unwrap(v, session=session) for v in value])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch an AST for a function with the given name.", "response": "def find_function(root, function_name):\n    \"\"\"Search an AST for a function with the given name.\n\n    A KeyError is raised if the function is not found.\n\n    root: an AST node\n\n    function_name: function to search for (string)\n    \"\"\"\n    finder = _FindFunctionVisitor(function_name)\n    finder.visit(root)\n\n    if finder.function is None:\n        raise KeyError('function not found', function_name)\n    return finder.function"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the current version from version. py as a string.", "response": "def load_version_as_string():\n    \"\"\"Get the current version from version.py as a string.\"\"\"\n    with open(VERSION_PATH, 'r') as rfile:\n        contents = rfile.read().strip()\n\n    _, version = contents.split('=')\n    version = version.strip()\n\n    # Remove quotes\n    return version.strip('\"\\'')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_from_tarfile(session, tarfile_path, check_for_duplicates,\n                      pkts_per_commit=1000):\n    \"\"\"\n    Iterate through xml files in a tarball and attempt to load into database.\n\n    .. warning::\n        Very slow with duplicate checking enabled.\n\n    Returns:\n        tuple: (n_parsed, n_loaded) - Total number of packets parsed from\n            tarbar, and number successfully loaded.\n\n    \"\"\"\n    tf_stream = tarfile_xml_generator(tarfile_path)\n    logger.info(\"Loading: \" + tarfile_path)\n    n_parsed = 0\n    n_loaded = 0\n    for tarinf in tf_stream:\n        try:\n            v = vp.loads(tarinf.xml, check_version=False)\n            if v.attrib['version'] != '2.0':\n                logger.debug(\n                    'Packet: {} is not VO-schema version 2.0.'.format(\n                        tarinf.name))\n            n_parsed += 1\n        except:\n            logger.exception('Error loading file {}, skipping'.format(\n                tarinf.name))\n            continue\n        try:\n            new_row = Voevent.from_etree(v)\n            if check_for_duplicates:\n                if ivorn_present(session, new_row.ivorn):\n                    logger.debug(\n                        \"Ignoring duplicate ivorn: {} in file {}\".format(\n                            new_row.ivorn, tarinf.name))\n                    continue\n            session.add(new_row)\n            n_loaded += 1\n        except:\n            logger.exception(\n                'Error converting file {} to database row, skipping'.\n                    format(tarinf.name))\n            continue\n\n        if n_loaded % pkts_per_commit == 0:\n            session.commit()\n    session.commit()\n    logger.info(\"Successfully parsed {} packets, of which loaded {}.\".format(n_parsed, n_loaded))\n    return n_parsed, n_loaded", "response": "Load a single object from a tarball file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview to preview Entry. content in HTML", "response": "def content_preview(self, request):\n        \"\"\"\n        Admin view to preview Entry.content in HTML,\n        useful when using markups to write entries.\n        \"\"\"\n        data = request.POST.get('data', '')\n        entry = self.model(content=data)\n        return TemplateResponse(\n            request, 'admin/zinnia/entry/preview.html',\n            {'preview': entry.html_content})"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\noverloads the admin s urls for Entry Admin MarkItUp.", "response": "def get_urls(self):\n        \"\"\"\n        Overload the admin's urls for MarkItUp.\n        \"\"\"\n        entry_admin_urls = super(EntryAdminMarkItUpMixin, self).get_urls()\n        urls = [\n            url(r'^markitup/$',\n                self.admin_site.admin_view(self.markitup),\n                name='zinnia_entry_markitup'),\n            url(r'^markitup/preview/$',\n                self.admin_site.admin_view(self.content_preview),\n                name='zinnia_entry_markitup_preview')\n        ]\n        return urls + entry_admin_urls"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _media(self):\n        def static_url(url):\n            return staticfiles_storage.url('zinnia_markitup/%s' % url)\n\n        media = super(EntryAdminMarkItUpMixin, self).media\n\n        media += Media(\n            js=(static_url('js/jquery.min.js'),\n                static_url('js/markitup/jquery.markitup.js'),\n                static_url('js/markitup/sets/%s/set.js' % (\n                    settings.MARKUP_LANGUAGE)),\n                reverse('admin:zinnia_entry_markitup')),\n            css={'all': (\n                static_url('js/markitup/skins/django/style.css'),\n                static_url('js/markitup/sets/%s/style.css' % (\n                    settings.MARKUP_LANGUAGE)))}\n        )\n        return media", "response": "A media that provides the admin page for the entry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncommand line parser for dealing with sick models.", "response": "def parser(input_args=None):\n    \"\"\"\n    Command line parser for dealing with *sick* models.\n    \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description=\"sick, the spectroscopic inference crank\", epilog=\"Use \"\n            \"'sick-model COMMAND -h' for information on a specific command.\"\n            \" Documentation and examples available at \"\n            \"https://github.com/andycasey/sick\")\n\n    # Create a parent subparser.\n    parent_parser = argparse.ArgumentParser(add_help=False)\n    parent_parser.add_argument(\n        \"-v\", \"--verbose\", dest=\"verbose\", action=\"store_true\", default=False,\n        help=\"Vebose logging mode.\")\n    parent_parser.add_argument(\n        \"--clobber\", dest=\"clobber\", action=\"store_true\", default=False, \n        help=\"Overwrite existing files if they already exist.\")\n    parent_parser.add_argument(\n        \"--debug\", dest=\"debug\", action=\"store_true\", default=False,\n        help=\"Enable debug mode. Any suppressed exception will be re-raised.\")\n    parent_parser.add_argument(\n        \"-o\", \"--output_dir\", dest=\"output_dir\", nargs=\"?\", type=str,\n        help=\"Directory for the files that will be created. If not given, this\"\n        \" defaults to the current working directory.\", default=os.getcwd())\n\n    # Create subparsers.\n    subparsers = parser.add_subparsers(title=\"command\", dest=\"command\",\n        description=\"Specify the action to perform.\")\n\n    # Sub-parser for the create model command.\n    # create <MODEL_NAME> <GRID_POINTS_FILENAME> <DISPERSION_FILENAME*>\n    creator = subparsers.add_parser(\"create\", parents=[parent_parser],\n        help=\"Create a model from existing wavelength and flux files.\")\n    creator.add_argument(\"model_name\", type=str,\n        help=\"Name for the model to be created. This will form the prefix of \"\n        \"filenames for the model.\")\n    creator.add_argument(\"grid_points_filename\", type=str,\n        help=\"Filename containing a header with parameter and channel names, \"\n        \"and a list of grid points and associated flux filenames.\")\n    creator.add_argument(\"wavelength_filenames\", type=str, nargs=\"+\",\n        help=\"Filenames containing the wavelengths for the channels referred \"\n        \"to in the header of `grid_points_filename`.\")\n    creator.set_defaults(func=create)\n\n    # Sub-parser for the recast model command.\n    # recast <MODEL_NAME> <ORIGINAL_MODEL_NAME> <CHANNEL_DESCRIPTION_FILENAME>\n    recaster = subparsers.add_parser(\"recast\", parents=[parent_parser],\n        help=\"Take an existing model and create a new model with different \"\n            \"wavelength ranges, binning, and/or resolving powers.\")\n    recaster.add_argument(\"model_name\", type=str,\n        help=\"Name for the model to be created. This will form the prefix of \"\n        \"filenames for the model.\")\n    recaster.add_argument(\"original_model_filename\", type=str,\n        help=\"Path of the YAML-formatted model filename to use as a template.\")\n    recaster.add_argument(\"channel_description_filename\", type=str,\n        help=\"Path to a filename containing a description of the channels to \"\n        \"be cast.\")\n    recaster.set_defaults(func=recast)\n\n    # Sub-parser for the download model command.\n    # download <MODEL_NAME>\n    download_parser = subparsers.add_parser(\"download\", parents=[parent_parser],\n        help=\"Download a model from an online repository.\")\n    download_parser.add_argument(\"model_name\", nargs=\"?\",\n        help=\"The name of the pre-cached model grid to download, or 'list' \"\n            \"(default) to see what models are available.\", default=\"list\")\n    download_parser.set_defaults(func=download)\n\n    args = parser.parse_args(input_args)\n    \n    # Setup logging, bro.\n    logger.setLevel(logging.DEBUG if args.verbose else logging.INFO)\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef recast(args):\n\n    import yaml\n    from numpy import arange\n    from sick.models import Model\n    \n    # Load in the original model.\n    model = Model(args.original_model_filename)\n\n    # Load in the channel information\n    with open(args.channel_description_filename, \"r\") as fp:\n        channel_description = yaml.load(fp)\n\n    # Put the channel description into the format we need.\n    channels = {}\n    required_keys = (\"wavelength_start\", \"wavelength_end\", \"wavelength_step\")\n    for name, descr in channel_description.iteritems():\n        # Description must have:\n        # wavelength_start, wavelength_end, wavelength_step,\n        # optional: resolution.\n        missing_keys = set(required_keys).difference(descr)\n        if missing_keys:\n            raise KeyError(\"channel {0} is missing the following key(s): {1}\"\\\n                .format(name, \", \".join(missing_keys)))\n\n        if descr[\"wavelength_start\"] >= descr[\"wavelength_end\"]:\n            raise ValueError(\"wavelength start value for channel {0} is greater\"\n                \" than or equal to the end value ({1} >= {2})\".format(\n                    name, descr[\"wavelength_start\"], descr[\"wavelength_end\"]))\n        if 0 >= descr[\"wavelength_step\"]:\n            raise ValueError(\"wavelength step for channel {} must be a positive\"\n                \" value\".format(name))\n\n        wavelengths = arange(descr[\"wavelength_start\"], descr[\"wavelength_end\"],\n            descr[\"wavelength_step\"])\n\n        if 2 > wavelengths.size:\n            raise ValueError(\"number of wavelength points requested for channel\"\n                \"{} is less than two\".format(name))\n\n        resolution = descr.get(\"resolution\", float(\"inf\"))\n        channels[name] = (wavelengths, resolution)\n\n    return model.cast(args.model_name, channels, output_dir=args.output_dir,\n        clobber=args.clobber, __progressbar=True)", "response": "Create a new model by recasting an existing model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a single model from wavelength and flux files.", "response": "def create(args):\n    \"\"\" Create a model from wavelength and flux files. \"\"\"\n\n    from sick.models.create import create \n    return create(os.path.join(args.output_dir, args.model_name),\n        args.grid_points_filename, args.wavelength_filenames,\n        clobber=args.clobber)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rareness2(self, password, min_word_fragment_length=3, commonness_of_non_word=50000):\n        from time import time\n\n        def get_min_commonness_value(commonness_list):\n            nonlocal commonness_value\n\n            value = sum(commonness_list)/len(commonness_list)\n            if value < commonness_value:\n                commonness_value = value\n\n        def recurse(previous):\n            nonlocal separators, depth, used_separators\n            depth += 1\n\n            for current in range(previous + min_word_fragment_length, len(password) - min_word_fragment_length + 1):\n                try:\n                    separators[depth] = current\n                except IndexError:\n                    separators.append(current)\n\n                if depth < number_of_separators - 1:\n                    recurse(current)\n                else:\n                    used_separators.add(tuple(separators))\n\n            depth -= 1\n\n        start = time()\n        subword_commonness = dict()\n        for i_front in range(0, len(password) - min_word_fragment_length + 1):\n            for i_back in range(i_front + min_word_fragment_length, len(password) + 1):\n                subword_commonness[(i_front, i_back)] \\\n                    = self.common_words.get(password[i_front:i_back], commonness_of_non_word)/commonness_of_non_word\n        print('subword complete', time()-start)\n\n        start = time()\n        commonness_value = 1\n        used_separators = set()\n        for number_of_separators in range(len(password)//min_word_fragment_length):\n            if number_of_separators == 0:\n                get_min_commonness_value\\\n                    ({self.common_words.get(password, commonness_of_non_word)/commonness_of_non_word})\n            else:\n                separators = list()\n                depth = -1\n                recurse(0)\n        print('tuple listing complete', time()-start)\n\n        start = time()\n        for sep in used_separators:\n            commonness_list = set()\n            commonness_list.add(subword_commonness[(0, sep[0])])\n            for i in range(len(sep)-1):\n                commonness_list.add(subword_commonness[(sep[i], sep[i + 1])])\n            commonness_list.add(subword_commonness[(sep[-1], len(password))])\n            get_min_commonness_value(commonness_list)\n        print('get min complete', time()-start)\n\n        return commonness_value", "response": "Calculates the rareness of a password."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the number of entropy in a given password.", "response": "def consecutiveness(password, consecutive_length=3):\n        \"\"\"\n        Consecutiveness is the enemy of entropy, but makes it easier to remember.\n        :param str password:\n        :param int consecutive_length: length of the segment to be uniform to consider loss of entropy\n        :param int base_length: usual length of the password\n        :return int: in range 0-1\n        >>> Complexity.consecutiveness('password')\n        1.0\n        >>> Complexity.consecutiveness('PaSsWoRd')\n        0.0\n        >>> Complexity.consecutiveness('yio')\n        0\n        \"\"\"\n        consec = 0\n        for i in range(len(password) - consecutive_length):\n            if all([char.islower() for char in password[i:i+consecutive_length]]):\n                consec += 1\n            elif all([char.islower() for char in password[i:i+consecutive_length]]):\n                consec += 1\n\n        try:\n            return consec / (len(password) - consecutive_length)\n        except ZeroDivisionError:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef earliest_date(dates, full_date=False):\n    min_date = min(PartialDate.loads(date) for date in dates)\n    if not min_date.month and full_date:\n        min_date.month = 1\n    if not min_date.day and full_date:\n        min_date.day = 1\n    return min_date.dumps()", "response": "Return the earliest date among the schema - compliant dates."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        db.execute('DELETE FROM cohort_variant')\n        db.execute('DELETE FROM cohort_sample')\n        db.execute('DELETE FROM cohort')\n\n        samples = orm['samples.Sample'].objects.filter(published=True)\n        count = samples.count()\n        cohort = orm['samples.Cohort'](name='World', autocreated=True,\n            published=bool(count), count=count)\n        cohort.save()\n\n        cohort_samples = []\n        for sample in samples:\n            cohort_samples.append(orm['samples.CohortSample'](object_set=cohort, set_object=sample))\n\n        orm['samples.CohortSample'].objects.bulk_create(cohort_samples)\n\n        for project in orm['samples.Project'].objects.all():\n            samples = orm['samples.Sample'].objects.filter(published=True, project=project)\n            count = samples.count()\n            cohort = orm['samples.Cohort'](project=project, name=project.label,\n                autocreated=True, published=bool(count), count=count)\n            cohort.save()\n\n            cohort_samples = []\n            for sample in samples:\n                cohort_samples.append(orm['samples.CohortSample'](object_set=cohort, set_object=sample))\n\n            orm['samples.CohortSample'].objects.bulk_create(cohort_samples)\n\n        for batch in orm['samples.Batch'].objects.select_related():\n            samples = orm['samples.Sample'].objects.filter(published=True, batch=batch)\n            count = samples.count()\n            cohort = orm['samples.Cohort'](batch=batch, project=batch.project,\n                name='{0}: {1}'.format(batch.project.label, batch.label), autocreated=True,\n                published=bool(count), count=count)\n            cohort.save()\n\n            cohort_samples = []\n            for sample in samples:\n                cohort_samples.append(orm['samples.CohortSample'](object_set=cohort, set_object=sample))\n\n            orm['samples.CohortSample'].objects.bulk_create(cohort_samples)", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a scheme to a url if not present.", "response": "def ensure_scheme(url, default_scheme='http'):\n    \"\"\"Adds a scheme to a url if not present.\n\n    Args:\n        url (string): a url, assumed to start with netloc\n        default_scheme (string): a scheme to be added\n\n    Returns:\n        string: URL with a scheme\n    \"\"\"\n    parsed = urlsplit(url, scheme=default_scheme)\n    if not parsed.netloc:\n        parsed = SplitResult(\n            scheme=parsed.scheme,\n            netloc=parsed.path,\n            path='',\n            query=parsed.query,\n            fragment=parsed.fragment\n        )\n\n    return urlunsplit(parsed)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        orm['avocado.DataField'].objects.get_or_create(app_name='samples', model_name='batch', field_name='id',\n                defaults=dict(published=True, name='Batch', name_plural='Batches'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef backwards(self, orm):\n        \"Write your backwards methods here.\"\n        orm['avocado.DataField'].objects.filter(app_name='samples', model_name='batch',\n            field_name='id').delete()", "response": "Write your backwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving Images Albums and Images from the cache if they are no longer used.", "response": "def prune_cache(album_cache, image_cache, app, doctree_album_ids=None, doctree_image_ids=None):\n    \"\"\"Remove Images and Albums from the cache if they are no longer used.\n\n    :param dict album_cache: Cache of Imgur albums to update. Keys are Imgur IDs, values are Album instances.\n    :param dict image_cache: Cache of Imgur images to update. Keys are Imgur IDs, values are Image instances.\n    :param sphinx.application.Sphinx app: Sphinx application object.\n    :param iter doctree_album_ids: Imgur album IDs used in all Sphinx docs.\n    :param iter doctree_image_ids: Imgur image IDs used in all Sphinx docs.\n    \"\"\"\n    # Prune invalid types.\n    for kind, cache in (('Album', album_cache), ('Image', image_cache)):\n        for key in [k for k, v in cache.items() if not hasattr(v, 'KIND') or not hasattr(v, 'imgur_id')]:\n            app.debug(\"removing %s from Imgur cache since value isn't %s instance.\", key, kind)\n            cache.pop(key)\n\n    # Prune key mismatches.\n    for cache in (album_cache, image_cache):\n        for key in [k for k, v in cache.items() if v.imgur_id != k]:\n            app.debug(\"removing %s from Imgur cache since imgur_id doesn't match.\", key)\n            cache.pop(key)\n\n    if doctree_album_ids is None or doctree_image_ids is None:\n        return\n\n    # Now prune albums.\n    for album_id in [i for i in album_cache if i not in doctree_album_ids]:\n        app.debug(\"removing %s from Imgur album cache since it's not in the doctree.\", album_id)\n        album_cache.pop(album_id)\n\n    # Finally prune images not in doctree and not in any album.\n    used_ids = list(doctree_image_ids) + [i for v in album_cache.values() for i in v.image_ids]\n    for image_id in [i for i in image_cache if i not in used_ids]:\n        app.debug(\"removing %s from Imgur image cache since it's not in the doctree nor any album.\", image_id)\n        image_cache.pop(image_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the cache with expired TTLs.", "response": "def update_cache(album_cache, image_cache, app, client_id, ttl, album_whitelist, image_whitelist):\n    \"\"\"Update cache items with expired TTLs.\n\n    :param dict album_cache: Cache of Imgur albums to update. Keys are Imgur IDs, values are Album instances.\n    :param dict image_cache: Cache of Imgur images to update. Keys are Imgur IDs, values are Image instances.\n    :param sphinx.application.Sphinx app: Sphinx application object.\n    :param str client_id: Imgur API client ID to use. https://api.imgur.com/oauth2\n    :param int ttl: Number of seconds before this is considered out of date.\n    :param iter album_whitelist: Only update these Imgur album IDs.\n    :param iter image_whitelist: Only update these Imgur image IDs.\n    \"\"\"\n    if not album_whitelist and not image_whitelist:\n        album_whitelist = list(album_cache)\n        image_whitelist = list(image_cache)\n    needs_update_album = {k: v for k, v in album_cache.items() if k in album_whitelist and not v.seconds_remaining(ttl)}\n    needs_update_image = {k: v for k, v in image_cache.items() if k in image_whitelist and not v.seconds_remaining(ttl)}\n    if not needs_update_album and not needs_update_image:\n        return\n\n    # If an image in an album needs to be updated, update entire album (includes all images in that album).\n    albums_up_to_date = [v for k, v in album_cache.items() if k not in needs_update_album]\n    for image_id in needs_update_image:\n        for album in albums_up_to_date:\n            if image_id in album:\n                needs_update_album[album.imgur_id] = album\n\n    # Update all albums.\n    for album in needs_update_album.values():\n        try:\n            images = album.refresh(app, client_id, 0)\n        except APIError:\n            continue\n        image_cache.update((i.imgur_id, i) for i in images)  # New Image instances.\n\n    # Possible new Image instances, redefining needs_update. Only caring about images now.\n    needs_update_image = {k: v for k, v in image_cache.items() if k in image_whitelist and not v.seconds_remaining(ttl)}\n\n    # Update all images.\n    for image in needs_update_image.values():\n        try:\n            image.refresh(app, client_id, ttl)\n        except APIError:\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a SOAP Client object for the given WSDL.", "response": "def get_client(wsdl, log_prefix, plugins=[], **kwargs):\n    \"\"\"\n    Get a SOAP Client object for the given WSDL. Client objects are cached in :attr:`soap.clients <soap.clients>`\n    and keyed by the WSDL URL.\n\n    :param wsdl: String URL of a SOAP WSDL\n    :param log_prefix: String prefix to prepend to log lines (when logging XML traffic in DEBUG mode)\n    :param plugins: List of additional plugins :class:`suds.plugin.Plugin <suds.plugin.Plugin>` to pass on to the\n        :class:`suds.client.Client <suds.client.Client>` object.\n    :param kwargs: Optional keyword arguments to pass on to the :class:`suds.client.Client <suds.client.Client>` object\n    :return: :class:`suds.client.Client <suds.client.Client>` object\n    :rtype: suds.client.Client\n    \"\"\"\n    if wsdl in settings.WSDL_INTERCEPTS:\n        wsdl = settings.WSDL_INTERCEPTS[wsdl]\n\n    if wsdl not in clients:\n        if settings.DEBUG:\n            plugins.append( LogPlugin(log_prefix) )\n\n        try:\n            clients[wsdl] = Client(wsdl, plugins=plugins, transport=get_transport(), **kwargs)\n        except Exception as e:\n            statsd.incr('soap.wsdl-creation-error')\n            logger.fatal('Failed to create SOAP client with WSDL at %s' % wsdl)\n            raise e\n    return clients[wsdl]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_args(cls):\n    # This looks insanely goofy, but seems to literally be the\n    # only thing that actually works.  Your obvious ways to\n    # accomplish this task do not apply here.\n    try:\n        # Assume it's a factory function, static method, or other callable\n        argspec = getargspec(cls)\n    except TypeError:\n        # assume it's a class\n        argspec = getargspec(cls.__init__)\n    args = argspec.args\n\n    # Note:  There is a special place in hell for people who don't\n    #        call the first method argument 'self'.\n    if args[0] == 'self':\n        args.remove('self')\n\n    return args", "response": "Return the arguments of the __init__ method for the base class cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rename(self):\n        params = self.relation_name ^ (Optional(self.relation_name) +\n                                       self.parenthesize(self.attribute_list))\n        return self.parametrize(self.syntax.rename_op, params)", "response": "Return a copy of the current object with the new name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef assignment(self):\n        lhs = Group(self.relation_name +\n                    Optional(self.parenthesize(self.attribute_list)))\n        return Group(lhs + Keyword(self.syntax.assign_op) + self.expression)", "response": "assignment ::= relation_name assign expression |\n            relation_name param_start attribute_list param_stop\n            assign expression"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef statement(self):\n        return (self.assignment ^ self.expression) + Suppress(\n            self.syntax.terminator)", "response": "A terminated relational algebra statement."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a parser the parses parameters.", "response": "def parameter(self, parser):\n        \"\"\"\n        Return a parser the parses parameters.\n        \"\"\"\n        return (Suppress(self.syntax.params_start).leaveWhitespace() +\n                Group(parser) + Suppress(self.syntax.params_stop))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parametrize(self, operator, params):\n        return (CaselessKeyword(operator, identChars=alphanums) +\n                self.parameter(params))", "response": "Return a parser that parses an operator with parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    parser = argparse.ArgumentParser(description='Do something awesome')\n    parser.add_argument('input_list', nargs='+',\n                        type=str, default=sys.stdin)\n    parser.add_argument('-o', '--outfile', nargs='?',\n                        type=argparse.FileType('w'), default=sys.stdout)\n    args = parser.parse_args()\n\n    input_list = args.input_list\n    print '\\n'.join(get_ips_from_cidr_subnets(input_list))", "response": "This main function implements the CLI"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a script directly from the scripts directory", "response": "def download_script(script_file_name):\n    '''Send a script directly from the scripts directory'''\n    return \"Sorry! Temporarily disabled.\"\n    if script_file_name[:-3] in registered_modules:\n        loaded_module = registered_modules[script_file_name[:-3]]\n        package_path = os.sep.join(loaded_module.__package__.split('.')[1:])\n        return send_from_directory(directory=os.path.join(\n                                      app.config['SCRIPTS_DIR'],\n                                      package_path),\n                                   filename=script_file_name)\n    else:\n        return \"ERROR\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_file(file_id, file_name):\n    '''Download a file from UPLOAD_FOLDER'''\n    extracted_out_dir = os.path.join(app.config['UPLOAD_FOLDER'], file_id)\n    return send_file(os.path.join(extracted_out_dir, file_name))", "response": "Download a file from UPLOAD_FOLDER"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef script_input(module_name):\n    '''Render a module's input page. Forms are created based on objects in\n    the module's WebAPI class.'''\n    if module_name not in registered_modules:\n        return page_not_found(module_name)\n    form = registered_modules[module_name].WebAPI()\n    return render_template('script_index.html',\n                           form=form,\n                           scripts=registered_modules,\n                           module_name=module_name)", "response": "Render a module s input page. Forms are created based on objects in\n    the module s WebAPI class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_script_api(module_name):\n    '''API handler. Take script input (from script_input above), run the run()\n    function, and return the results'''\n    filename = ''\n    file_stream = ''\n    #form = {k : try_json(v) for k,v in request.values.items()}\n    form = request.values.to_dict(flat=False)\n    if request.json:\n        form.update(request.json)\n    for x in form:\n        if type(form[x]) == list and len(form[x]) == 1:\n            form[x] = form[x][0]\n    for x in form:\n        form[x] = try_json(form[x])\n\n    if len(request.files) > 0:\n        # Get the name of the uploaded file\n        f = request.files['file_upload']\n\n        # Make the filename safe, remove unsupported chars\n        filename = secure_filename(f.filename)\n        file_stream = f.stream\n\n    form['HTTP_AUTHORIZATION'] = get_authorization()\n    form['filename'] = filename\n    form['file_stream'] = file_stream\n    try:\n        result = registered_modules[module_name].WebAPI().run(form)\n    except:\n        raise\n        #return jsonify({'error' : str(traceback.format_exc())})\n\n    if result['output_type'] == 'file':\n        return Response(result['output'],\n                        mimetype='application/octet-stream',\n                        headers={'Content-Disposition':\n                                 'attachment;filename='+result['filename']})\n    else:\n        return jsonify(result)", "response": "API handler. Take script input from script_input above run the run()\n    function and return the results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_script(module_name):\n    '''Take script input (from script_input above), run the run() function, and\n    render the results in the appropriate template'''\n    filename = ''\n    file_stream = ''\n    if len(request.files) > 0:\n        # Get the name of the uploaded file\n        f = request.files['file_upload']\n\n        # Make the filename safe, remove unsupported chars\n        filename = secure_filename(f.filename)\n        file_stream = f.stream\n    try:\n        form = werkzeug.datastructures.MultiDict(request.form)\n        form['HTTP_AUTHORIZATION'] = get_authorization()\n        form['filename'] = filename\n        form['file_stream'] = file_stream\n        result = registered_modules[module_name].WebAPI().run(form)\n    except Exception:\n        if app.config['LOCAL_DEV'] == True:\n            raise # pass along to be caught by Flask's debugger\n        return render_template('error.html',\n                               scripts=registered_modules,\n                               module_name=module_name,\n                               error_message=traceback.format_exc())\n    output = result['output']\n    if 'output_type' in result:\n        output_type = result['output_type']\n    else:\n        if isinstance(output, basestring):\n            output_type = 'simple'\n        else:\n            output_type = 'table'\n    if result['output_type'] == 'custom':\n        return render_template('result_custom.html',\n                               custom_output=Markup(result['output']),\n                               scripts=registered_modules,\n                               module_name=module_name)\n    elif result['output_type'] == 'simple':\n        return render_template('result.html',\n                               output=result['output'],\n                               scripts=registered_modules,\n                               module_name=module_name)\n    elif result['output_type'] == 'file':\n        return Response(result['output'],\n                        mimetype='application/octet-stream',\n                        headers={'Content-Disposition':\n                                 'attachment;filename='+result['filename']})\n    elif result['output_type'] == 'table':\n        return render_template('result_table.html',\n                               output=result['output'],\n                               scripts=registered_modules,\n                               module_name=module_name,\n                               headers=result['headers'])", "response": "Take script input and run the run function and render the results in the appropriate template"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a list of dicts to a list or OrderedDicts ordered by headers", "response": "def order_by_header(table, headers):\n    '''Convert a list of dicts to a list or OrderedDicts ordered by headers'''\n    ordered_table = []\n    for row in table:\n        # Tricky list comprehension got tricky when needing special handling\n        # Lets do this the simplest way we can:\n        row = {k:v for k,v in row.items() if k in headers}\n        for h in headers:\n            if h not in row:\n                row[h] = ''\n        ordered_row = OrderedDict(sorted(row.items(),\n                                         key=lambda x:headers.index(x[0])))\n        ordered_table.append(ordered_row)\n    return ordered_table"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nimports all of the modules named in REGISTERED_SCRIPTS", "response": "def load_scripts():\n    '''Import all of the modules named in REGISTERED_SCRIPTS'''\n    # Add scrypture package package to the path before importing\n    # so everything can import everything else regardless of package\n    scrypture_dir = os.path.realpath(\n                         os.path.abspath(\n                           os.path.split(\n                             inspect.getfile( inspect.currentframe() ))[0]))\n\n    if scrypture_dir not in sys.path:\n        sys.path.insert(0, scrypture_dir)\n\n    # Load list of registered scripts\n    registered_scripts = app.config['REGISTERED_SCRIPTS']\n\n    for script in registered_scripts:\n        try:\n            s = import_module('.'+script,\n                package=os.path.split(app.config['SCRIPTS_DIR'])[-1])\n            s.package = s.__name__.split('.')[1]\n            #remove package from script name:\n            script_name = script.split('.')[-1]\n            registered_modules[script_name] = s\n        except Exception as e:\n            logging.warning('Could not import ' + \\\n                            str(script)+': '+str(e.message))\n            logging.debug(str(traceback.format_exc()))\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntranslate a node into some output format.", "response": "def translate(self, node):\n        \"\"\"\n        Translate a node into some output format.\n        :param node: a treebrd node\n        :return: a node's translation to some format\n        \"\"\"\n        _translate = self._translate_functions.get(node.operator)\n        return _translate(node)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a file object for the object.", "response": "def file(cls, uri_or_path):\n        \"\"\"\n        Given either a URI like s3://bucket/path.txt or a path like /path.txt,\n        return a file object for it.\n        \"\"\"\n        uri = urlparse(uri_or_path)\n        if not uri.scheme:\n            # Just a normal path\n            return open(uri_or_path, 'rb')\n        else:\n            it = cls(uri_or_path).download_iter(uri.path.lstrip('/'), skip_hash=True)\n            if not it:\n                raise ValueError('{0} not found'.format(uri_or_path))\n            tmp = tempfile.TemporaryFile()\n            for chunk in it:\n                tmp.write(chunk)\n            tmp.seek(0, 0)\n            return tmp"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a libcloud storage object for a given URI.", "response": "def _get_storage(cls, uri):\n        \"\"\"\n        Given a URI like local:///srv/repo or s3://key:secret@apt.example.com,\n        return a libcloud storage or container object.\n        \"\"\"\n        driver = cls._get_driver(uri.scheme)\n        key = uri.username\n        secret = uri.password\n        container = uri.netloc\n        driver_kwargs = {}\n        if uri.scheme.startswith('s3'):\n            if not key:\n                key = os.environ.get('AWS_ACCESS_KEY_ID')\n            if not secret:\n                secret = os.environ.get('AWS_SECRET_ACCESS_KEY')\n            if not (key and secret and container):\n                raise ValueError('For S3 you must provide an access key ID, secret access key, and bucket name')\n            # No way to store this in the URI, what about a CLI option too?\n            if 'AWS_TOKEN' in os.environ:\n                driver_kwargs['token'] = os.environ['AWS_TOKEN']\n        elif uri.scheme == 'local':\n            parts = []\n            if uri.netloc:\n                parts.append(uri.netloc)\n            if uri.path:\n                parts.append(uri.path)\n            if not parts:\n                parts.append('.')\n            base_path = os.path.abspath(''.join(parts))\n            key = os.path.dirname(base_path)\n            container = os.path.basename(base_path)\n        storage = driver(key, secret, **driver_kwargs)\n        try:\n            return storage.get_container(container)\n        except ContainerDoesNotExistError:\n            return storage.create_container(container)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef saveHdlFiles(self, srcDir):\n        path = os.path.join(srcDir, self.name)\n        try:\n            os.makedirs(path)\n        except OSError:\n            # wipe if exists\n            shutil.rmtree(path)\n            os.makedirs(path)\n\n        files = self.hdlFiles\n        self.hdlFiles = self.toHdlConversion(self.top, self.name, path)\n        for srcF in files:\n            dst = os.path.join(path,\n                               os.path.relpath(srcF, srcDir).replace('../', '')\n                               )\n            os.makedirs(os.path.dirname(dst), exist_ok=True)\n            shutil.copy(srcF, dst)\n            self.hdlFiles.append(dst)", "response": "Saves all HDL files in the source directory to the destination directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mkAutoGui(self):\n        gui = GuiBuilder()\n        p0 = gui.page(\"Main\")\n        handlers = []\n        for p in self.iterParams(self.top):\n            name = self.getParamPhysicalName(p)\n            p0.param(name)\n            for fn in paramManipulatorFns(name):\n                handlers.append(fn)\n\n        with open(self.guiFile, \"w\") as f:\n            f.write(gui.asTcl())\n            for h in handlers:\n                f.write('\\n\\n')\n                f.write(str(h))", "response": "automatically generate simple TCL - specific GUI in TCL\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new package for the current version of the current IP - Core", "response": "def createPackage(self, repoDir, vendor: str=\"hwt\", library: str=\"mylib\",\n                      description: Optional[str]=None):\n        '''\n        :param repoDir: directory where IP-Core should be stored\n        :param vendor: vendor name of IP-Core\n        :param library: library name of IP-Core\n        :param description: description of IP-Core\n\n        :summary:  synthetise hdl if needed\n            copy hdl files\n            create gui file\n            create component.xml, component_hw.tcl\n        '''\n        ip_dir = os.path.join(repoDir, self.name + \"/\")\n        if os.path.exists(ip_dir):\n            shutil.rmtree(ip_dir)\n\n        ip_srcPath = os.path.join(ip_dir, \"src\")\n        tclPath = os.path.join(ip_dir, \"xgui\")\n        guiFile = os.path.join(tclPath, \"gui.tcl\")\n        for d in [ip_dir, ip_srcPath, tclPath]:\n            os.makedirs(d)\n        self.saveHdlFiles(ip_srcPath)\n\n        self.guiFile = guiFile\n        self.mkAutoGui()\n\n        c = Component(self)\n        c._files = [relpath(p, ip_dir) for p in sorted(self.hdlFiles)] + \\\n                   [relpath(guiFile, ip_dir)]\n\n        c.vendor = vendor\n        c.library = library\n        if description is None:\n            c.description = self.name + \"_v\" + c.version\n        else:\n            c.description = description\n\n        c.asignTopUnit(self.top, self.name)\n\n        xml_str = prettify(c.ip_xact())\n        with open(ip_dir + \"component.xml\", \"w\") as f:\n            f.write(xml_str)\n\n        quartus_tcl_str = c.quartus_tcl()\n        with open(ip_dir + \"component_hw.tcl\", \"w\") as f:\n            f.write(quartus_tcl_str)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toHdlConversion(self, top, topName: str, saveTo: str) -> List[str]:\n        raise NotImplementedError(\n            \"Implement this function for your type of your top module\")", "response": "This function will convert the designater object to the HDL format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the current value of width and flag which specifies if width of signal is locked or not", "response": "def getTypeWidth(self, dtype: \"HdlType\", do_eval=False) -> Tuple[int, str, bool]:\n        \"\"\"\n        :return: tuple (current value of width,\n            string of value (can be ID or int),\n            Flag which specifies if width of signal is locked\n            or can be changed by parameter)\n        \"\"\"\n        raise NotImplementedError(\n            \"Implement this method in your HdlType classes\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialzeValueToTCL(self, val, do_eval=False) -> Tuple[str, str, bool]:\n        return str(val), str(val), True", "response": "Serialize value to TCL"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_higher_permission(level1, level2):\n    return (is_publish_permission(level1) and\n            not is_publish_permission(level2) or\n            (is_edit_permission(level1) and\n             not is_publish_permission(level2) and\n             not is_edit_permission(level2)) or\n            (is_showon_permission(level1) and\n             is_view_permission(level2)))", "response": "Return True if the level1 is higher than level2."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _extract_mock_name(in_mock):\n    _name_list = [in_mock._mock_new_name]\n    _parent = in_mock._mock_new_parent\n    last = in_mock\n\n    dot = '.'\n    if _name_list == ['()']:\n        dot = ''\n    seen = set()\n    while _parent is not None:\n        last = _parent\n\n        _name_list.append(_parent._mock_new_name + dot)\n        dot = '.'\n        if _parent._mock_new_name == '()':\n            dot = ''\n\n        _parent = _parent._mock_new_parent\n\n        # use ids here so as not to call __hash__ on the mocks\n        if id(_parent) in seen:\n            break\n        seen.add(id(_parent))\n\n    _name_list = list(reversed(_name_list))\n    _first = last._mock_name or 'mock'\n    if len(_name_list) > 1:\n        if _name_list[1] not in ('()', '().'):\n            _first += '.'\n    _name_list[0] = _first\n    return ''.join(_name_list)", "response": "Prints the mock access path and the whole access chain since the root mock\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_child_mock(mock, **kw):\n    attribute = \".\" + kw[\"name\"] if \"name\" in kw else \"()\"\n    mock_name = _extract_mock_name(mock) + attribute\n    raise AttributeError(mock_name)", "response": "Intercepts call to generate new mocks and raises instead"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef seal(mock):\n    _frankeinstainize(mock)\n    for attr in dir(mock):\n        try:\n            m = getattr(mock, attr)\n        except AttributeError:\n            continue\n        if not isinstance(m, NonCallableMock):\n            continue\n        if m._mock_new_parent is mock:\n            seal(m)", "response": "Disable automatic generation of submocks"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef request(self, *args, **kwargs):\n        r = self.session.request(*args, **kwargs)\n        if r.status_code != requests.codes.ok:\n            error = ET.fromstring(r.content)\n            message = error.findtext('message')\n            code = error.attrib['key']\n            raise CleanwebError('%s (%s)' % (message, code))\n        return r", "response": "Request to get a specific object from Cleanweb."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck the spelling of a user.", "response": "def check_spam(self, ip=None, email=None, name=None, login=None, realname=None,\n                   subject=None, body=None, subject_type='plain', body_type='plain'):\n        \"\"\" http://api.yandex.ru/cleanweb/doc/dg/concepts/check-spam.xml\n            subject_type = plain|html|bbcode\n            body_type = plain|html|bbcode\n        \"\"\"\n        data = {'ip': ip, 'email': email, 'name': name, 'login': login, 'realname': realname,\n                'body-%s' % body_type: body, 'subject-%s' % subject_type: subject}\n        r = self.request('post', 'http://cleanweb-api.yandex.ru/1.0/check-spam', data=data)\n        root = ET.fromstring(r.content)\n        return {\n            'id': root.findtext('id'),\n            'spam_flag': yesnobool(root.find('text').attrib['spam-flag']),\n            'links': [(link.attrib['href'], yesnobool(link.attrib['spam-flag'])) for link in root.findall('./links/link')]\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_captcha(self, id=None):\n        payload = {'id': id}\n        r = self.request('get', 'http://cleanweb-api.yandex.ru/1.0/get-captcha', params=payload)\n        return dict((item.tag, item.text) for item in ET.fromstring(r.content))", "response": "Get a dictionary of captcha tags and text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if a captcha is valid.", "response": "def check_captcha(self, captcha, value, id=None):\n        \"\"\" http://api.yandex.ru/cleanweb/doc/dg/concepts/check-captcha.xml\"\"\"\n        payload = {'captcha': captcha,\n                   'value': value,\n                   'id': id}\n        r = self.request('get', 'http://cleanweb-api.yandex.ru/1.0/check-captcha', params=payload)\n        root = ET.fromstring(r.content)\n        if root.findall('ok'):\n            return True\n        if root.findall('failed'):\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a constraint that applies to one or more variables.", "response": "def add_constraint(self, func, variables, default_values=None):\n        \"\"\"Adds a constraint that applies to one or more variables.\n\n        The function must return true or false to indicate which combinations\n        of variable values are valid.\n        \"\"\"\n        self._constraints.append((func, variables, default_values or ()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntransforming point in viewport space to screen space.", "response": "def viewport_to_screen_space(framebuffer_size: vec2, point: vec4) -> vec2:\n    \"\"\"Transform point in viewport space to screen space.\"\"\"\n    return (framebuffer_size * point.xy) / point.w"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all the fields that are for the given fields.", "response": "def each_fields(for_fields, fields):\n    \"\"\"\n    select_related(\n        'field__related_field1__text1', 'field__related_field1__text2',\n        'field__related_field2__text1', 'field__related_field2__text2',\n    )\n    select_related(*each_fields(['field__related_field1', 'field__related_field2'], ['text1', 'text2']))\n    each_fields('field__related_field1', ['text1', 'text2'])\n    \"\"\"\n    if isinstance(for_fields, basestring):\n        for_fields = (for_fields,)\n    r = set()\n    for ff in for_fields:\n        for f in fields:\n            r.add(ff + '__' + f)\n    return list(r)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the incoming query value from params and returns the query value.", "response": "def parse_incoming_query(factory, static_conditions=None,\n                         include_value=[], model_aggregations=dict()):\n    '''\n    Effect factory parsing the query value from params and merging in\n    the static_conditions specified.\n\n    @param factory: IQueryView\n    @param static_conditions: effect to be called to build up static\n                               conditions of the query\n    @param include_value: list of fields which should be always included\n    @param model_aggregations: dict() of name -> (IValueInfo, name, field)\n    '''\n\n    def build_query(value, context, *args, **kwargs):\n\n        def merge_conditions(static_conditions, q):\n            subquery = factory(*static_conditions)\n            return factory(q, query.Operator.AND, subquery, include_value=[])\n\n        def merge_query_options(query, kwargs):\n            if kwargs.get('include_value'):\n                query.include_value.extend(kwargs['include_value'])\n                # reset call below is to get rid of cached query plan\n                # if it has been already calculated\n                query.reset()\n            if kwargs.get('aggregate'):\n                aggregate = list()\n                for name in kwargs['aggregate']:\n                    definition = model_aggregations[name]\n                    aggregate.append((definition[1], definition[2]))\n                query.aggregate = aggregate\n            return query\n\n        def store_in_context(query):\n            context['query'] = query\n            return query\n\n        if static_conditions:\n            d = defer.succeed(None)\n            d.addCallback(static_conditions, context)\n            d.addCallback(merge_conditions, kwargs['query'])\n        else:\n            d = defer.succeed(kwargs['query'])\n        d.addCallback(merge_query_options, kwargs)\n        d.addCallback(store_in_context)\n        return d\n\n    return build_query"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrotates a coordinate around point x y and degree.", "response": "def rotate(x, y, degree):\n    \"\"\"Rotate a coordinate around point (0,0).\n    - x and y specify the coordinate.\n    - degree is a number from 0 to 360.\n    Returns a new coordinate.\n    \"\"\"\n    radian = float(degree) * 2 * math.pi / 360.0\n    newx = math.cos(radian) * x - math.sin(radian) * y\n    newy = math.sin(radian) * x + math.cos(radian) * y\n    return (newx, newy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_keys(transform, field, evaluator, value):\n    '''\n    Generates the query keys for the default structure of the query index.\n    The structure of the key: [field_name, value].\n    It supports custom sorting, in which case the value is substituted\n    bu the result of transform(value).\n\n    @param transform: callable of 1 argument\n    @param field: C{str} field name\n    @param evaluator: C{Evaluator}\n    @param value: value\n    @rtype: dict\n    @returns: keys to use to query the view\n    '''\n\n    if evaluator == Evaluator.equals:\n        return dict(key=(field, transform(value)))\n    if evaluator == Evaluator.le:\n        return dict(startkey=(field, ), endkey=(field, transform(value)))\n    if evaluator == Evaluator.ge:\n        return dict(startkey=(field, transform(value)), endkey=(field, {}))\n    if evaluator == Evaluator.between:\n        return dict(startkey=(field, transform(value[0])),\n                    endkey=(field, transform(value[1])))\n    if evaluator == Evaluator.inside:\n        return dict(keys=[(field, transform(x)) for x in value])\n    if evaluator == Evaluator.none:\n        return dict(startkey=(field, ), endkey=(field, {}))", "response": "Generates the query keys for the default structure of the query index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_circle(ctx, x, y, radius, cairo_color):\n    ctx.new_path()\n    ctx.set_source_rgb(cairo_color.red, cairo_color.green, cairo_color.blue)\n    ctx.arc(x, y, radius, 0, 2 * pi)\n    ctx.fill()", "response": "Draw a circle.\n    :param radius: radius in pixels\n    :param cairo_color: normalized rgb color"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw a cloud with the given width height and color.", "response": "def draw_cloud(width=140, height=60, color=rgb(255, 255, 255)):\n    \"\"\" Draw a cloud with the given width, height, and color. \"\"\"\n\n    cairo_color = color / rgb(255, 255, 255)\n\n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n    ctx = cairo.Context(surface)\n\n    # A cloud consists of 4 circles\n    draw_circle(ctx, width / 3, height / 2, height / 3, cairo_color)\n    draw_circle(ctx, 2 * width / 3, height / 2, height / 3, cairo_color)\n    draw_circle(ctx, width / 2, height / 3, height / 3, cairo_color)\n    draw_circle(ctx, width / 2, 2 * height / 3, height / 3, cairo_color)\n\n    surface.write_to_png('cloud.png')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef depends_on(options, **kwargs):\n    include_graph = options['include_graph']\n\n    include_graph.render('full_graph')\n\n    result = None\n\n    if 'graph' in kwargs:\n        name = kwargs['graph']\n        del kwargs['graph']\n\n        result = _Result(kwargs)\n\n        dep_graph = build_dependency_graph(include_graph, **kwargs)\n\n        dep_graph.render(name)\n\n        result.add_result(\"Rendered dep graph at {}\".format(name))\n\n    else:\n        result = _Result(kwargs)\n\n        dep_graph = build_dependency_graph(include_graph, **kwargs)\n\n        for node, edges in dep_graph:\n            if node not in kwargs:\n                result.add_result(node)\n\n    return result", "response": "Get list of files that depend on given configs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef invert_graph(include_graph):\n\n    file_index = include_graph.file_index\n    dep_extractor = include_graph.dep_extractor\n\n    inverted_graph = IncludeGraph(file_index, dep_extractor)\n    inverted_graph.active = True\n\n    for node, edges in include_graph:\n        inverted_graph.add_node(node)\n\n        for edge in edges:\n            inverted_graph.add_edge(edge.to, node, edge.settings['type'])\n\n    return inverted_graph", "response": "Invert include_graph by adding nodes and edges to the graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the contents of the LCAF message from the given byte stream.", "response": "def from_bytes(cls, bitstream, prefix_len=None):\n        '''\n        Look at the type of the message, instantiate the correct class and\n        let it parse the message.\n        '''\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Skip the reserved bits\n        rsvd1 = bitstream.read(8)\n\n        # Read the flags (and ignore them, no flags are defined yet)\n        flags = bitstream.readlist('8*bool')\n\n        # Read the type\n        type_nr = bitstream.read('uint:8')\n\n        # Skip the reserved bits\n        rsvd2 = bitstream.read(8)\n\n        # Read the length\n        length = bitstream.read('uint:16')\n\n        # Read the data\n        data = bitstream.read(length * 8)\n\n        # Look for the right class\n        from pylisp.utils.lcaf import type_registry\n        type_class = type_registry.get_type_class(type_nr)\n        if not type_class:\n            raise ValueError(\"Can't handle LCAF type {0}\".format(type_nr))\n\n        # Let the specific class handle it from now on\n        return type_class._from_data_bytes(data, prefix_len,\n                                           rsvd1, flags, rsvd2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating bytes from properties", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Check properties\n        self.sanitize()\n\n        # Start with reserved bits\n        bitstream = self._to_rsvd1()\n\n        # Add zeroes for the flags\n        bitstream += self._to_flags()\n\n        # Add the type\n        bitstream += BitArray('uint:8=%d' % self.lcaf_type)\n\n        # Some more reserved bits\n        bitstream += self._to_rsvd2()\n\n        # Construct the data\n        data = self._to_data_bytes()\n\n        # Add the length\n        data_length = data.len / 8\n        bitstream += BitArray('uint:16=%d' % data_length)\n\n        return (bitstream + data).bytes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exception_handler(exceptionObj):\n    try:\n        if isinstance(exceptionObj, Exception) and hasattr(exceptionObj, 'args'):\n            if not (hasattr(exceptionObj, 'message' or hasattr(exceptionObj, 'msg'))):\n                if len(exceptionObj.args) >= 1:\n                    if type(exceptionObj.args[0]) == type(b''):\n                        ob = json.loads(exceptionObj.args[0].decode('utf-8'))\n                        if type(ob) == type({}) and ob['message']:\n                            return ob['message']\n                    else:\n\n                        try:\n                            if type(exceptionObj.args[0]) == type('') and exceptionObj.args[0][0] == 'b':\n                                ob = json.loads(exceptionObj.args[0][2:-1])\n                            else:\n                                ob = json.loads(exceptionObj.args[0])\n                            if type(ob) == type({}) and ob['message']:\n                                try:\n                                    return exception_handler(ob['message'])\n                                except Exception as e:\n                                    return ob['message']\n                            elif type(ob) == type({}) and ob['msg']:\n                                try:\n                                    return exception_handler(ob['message'])\n                                except Exception as e:\n                                    return ob['msg']\n                            return str(json.loads(exceptionObj.args[0]))\n                        except Exception as e:\n                            return str(exceptionObj.args[0])\n            elif hasattr(exceptionObj, 'msg'):\n                return exceptionObj.msg\n            elif hasattr(exceptionObj, 'message'):\n                return exceptionObj.message\n        elif type(exceptionObj) == type(''):\n            try:\n                ob = json.loads(exceptionObj)\n                if type(ob) == type({}):\n                    if ob['message']:\n                        return ob['message']\n                    elif ob['msg']:\n                        return ob['msg']\n                    else:\n                        return ob\n            except Exception as e:\n                return exceptionObj\n\n    except Exception as e:\n        return e", "response": "Function that takes an exception Object and returns the error message<str >"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _convert_metadata(data):\n    def compose(val, arguments=None):\n        \"\"\"\n        If not val, return None.\n\n        If not arguments, return just val.\n\n        Otherwise, map val into `arguments` dict under the ``#text`` key.\n\n        This is format required by xmltodict.\n        \"\"\"\n        if val is None:\n            return None\n\n        if not arguments:\n            return val\n\n        arguments[\"#text\"] = val\n        return arguments\n\n    conspect = data.get(\"conspect\", {})\n    author_name = data.get(\"author\", {}).get(\"name\")\n    author_code = data.get(\"author\", {}).get(\"code\")\n\n    metadata = odict[\n        \"dc:title\": data.get(\"title\"),\n        \"dcterms:alternative\": data.get(\"subtitle\"),\n        \"dc:creator\": compose(author_name, {\"@id\": author_code}),\n        \"dc:publisher\": data.get(\"publisher\"),\n        \"dc:description\": data.get(\"annotation\"),\n        \"dc:coverage\": compose(data.get(\"place\"), {\"@xml:lang\": \"cze\"}),\n        \"dc:language\": compose(data.get(\"language\"), {\"@schema\": \"ISO 639-2\"}),\n        \"dcterms:created\": data.get(\"from_year\"),\n        \"dcterms:accrualperiodicity\": compose(\n            data.get(\"periodicity\"),\n            {\"@xml:lang\": \"cze\"}\n        ),\n        \"dc:identifier\": [\n            {\"@rdf:resource\": data[\"url\"]},\n            compose(data.get(\"issn\"), {\"@xsi:type\": \"ISSN\"}),\n            compose(conspect.get(\"mdt\"), {\"@xsi:type\": \"MDT\"}),\n            compose(conspect.get(\"ddc\"), {\"@xsi:type\": \"DDC\"}),\n        ],\n        \"dc:subject\": [\n            compose(conspect.get(\"mdt\"), {\"@xsi:type\": \"dcterms:UDC\"}),\n            compose(conspect.get(\"ddc\"), {\"@xsi:type\": \"dcterms:DDC\"}),\n        ],\n    ]\n\n    def pick_keywords(data, source):\n        \"\"\"\n        Convert::\n\n            \"en_keywords\": [\n                {\n                    \"zahlavi\": \"keyboard (musical instrument)\",\n                    \"zdroj\": \"eczenas\"\n                }, {\n                    \"zahlavi\": \"ANCA-associated vasculitis\",\n                    \"zdroj\": \"eczenas\"\n                }\n            ]\n\n        To::\n            [\"keyboard (musical instrument)\", \"ANCA-associated vasculitis\"]\n        \"\"\"\n        return [\n            x[\"zahlavi\"]\n            for x in data.get(source, [])\n            if x.get(\"zahlavi\")\n        ]\n\n    # parse and add keywords (keywords are in dicts with other data, I want\n    # just the free-text descriptions)\n    cz_keywords = pick_keywords(data, \"cz_keywords\")\n    en_keywords = pick_keywords(data, \"en_keywords\")\n\n    if cz_keywords:\n        metadata[\"dc:subject\"].append({\n            \"@xml:lang\": \"cz\",\n            \"#text\": \", \".join(cz_keywords)\n        })\n    if en_keywords:\n        metadata[\"dc:subject\"].append({\n            \"@xml:lang\": \"en\",\n            \"#text\": \", \".join(en_keywords)\n        })\n\n    # filter unset identifiers - TODO: rewrite to recursive alg.\n    metadata[\"dc:identifier\"] = [x for x in metadata[\"dc:identifier\"] if x]\n    metadata[\"dc:subject\"] = [x for x in metadata[\"dc:subject\"] if x]\n\n    return metadata", "response": "Convert metadata from WA - KAT to Dublin core dictionary like structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _remove_none(data):\n    if isinstance(data, list) or isinstance(data, tuple):\n        return [x for x in data if x is not None]\n\n    out = OrderedDict()\n    for key, val in data.iteritems():\n        if val is not None:\n            out[key] = val\n\n    return out", "response": "Remove None values from dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting nested WA - KAT data to Dublin core XML.", "response": "def to_dc(data):\n    \"\"\"\n    Convert WA-KAT `data` to Dublin core XML.\n\n    Args:\n        data (dict): Nested WA-KAT data. See tests for example.\n\n    Returns:\n        unicode: XML with dublin core.\n    \"\"\"\n    root = odict[\n        \"metadata\": odict[\n            \"@xmlns:xsi\": \"http://www.w3.org/2001/XMLSchema-instance\",\n            \"@xmlns:dc\": \"http://purl.org/dc/elements/1.1/\",\n            \"@xmlns:dcterms\": \"http://purl.org/dc/terms/\",\n            \"@xmlns:rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n        ]\n    ]\n\n    # map metadata to the root element, skip None values\n    for key, val in _convert_metadata(_remove_none(data)).iteritems():\n        if val is None:\n            continue\n\n        if isinstance(val, basestring) and not val.strip():\n            continue\n\n        if isinstance(val, str):\n            val = val.decode(\"utf-8\")\n\n        root[\"metadata\"][key] = val\n\n    return unparse(root, pretty=True, indent=\"    \")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports the keys with the given key IDs from a HKP keyserver. :param keyserver: Keyserver name. The format of the name is a URI: ``scheme:[//]keyservername[:port]``. The scheme is the type of keyserver:\"hkp\" for the HTTP (or compatible) keyservers, \"ldap\" for the NAI LDAP keyserver, or \"mailto\" for the Graff email keyserver. Note that your particular installation of GnuPG may have other keyserver types available as well. Keyserver schemes are case-insensitive. :param keys: Single key ID or list of mutiple IDs :rtype: ImportResult", "response": "def recv_keys(self, keyserver, keys):\n        '''\n        Import the keys with the given key IDs from a HKP keyserver.\n\n        :param keyserver: Keyserver name. The format of the name is a URI: ``scheme:[//]keyservername[:port]``.\n            The scheme is the type of keyserver:\"hkp\" for the HTTP (or compatible) keyservers, \"ldap\" for the\n            NAI LDAP keyserver, or \"mailto\" for the Graff email keyserver. Note that your particular installation\n            of GnuPG may have other keyserver types available as well. Keyserver schemes are case-insensitive.\n        :param keys: Single key ID or list of mutiple IDs\n        :rtype: ImportResult\n        '''\n        return self.execute(\n            ImportResult(),\n            ['--keyserver', keyserver, '--recv-keys'] + list(make_list(keys))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef export_keys(self, keys=None, secret=False, passphrase=None, binary=False):\n        '''\n        Export keys\n\n        :param keys: Single key ID or list of mutiple IDs. If None export all of the keys.\n        :param secret: Export secret keys\n        :param passphrase: Secret key password, you need this if secret=true\n        :param binary: If false, create ASCII armored output\n        :rtype: ExportResult\n        '''\n        args = [] if binary else ['--armor']\n        if secret:\n            args += ('--batch', '--export-secret-keys')\n        else:\n            args.append('--export')\n        if keys:\n            args += make_list(keys)\n        return self.execute(ExportResult(), args, passphrase or '' if secret else None)", "response": "Export a set of mutiple keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving keys from the public or secret keyrings.", "response": "def delete_keys(self, keys, secret=False):\n        '''\n        Remove keys from the public or secret keyrings.\n\n        :param keys: Single key ID or list of mutiple IDs\n        :param secret: Delete secret keys\n        :rtype: DeleteResult\n        '''\n        return self.execute(\n            DeleteResult(),\n            ['--batch', '--yes', '--delete-secret-key' if secret else '--delete-key'] + list(make_list(keys))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if given key exists.", "response": "def key_exists(self, key, secret=False):\n        '''\n        Check is given key exists.\n\n        :param key: Key ID\n        :param secret: Check secret key\n        :rtype: bool\n        '''\n        if len(key) < 8:\n            return False\n        key = key.upper()\n        res = self.list_keys(secret)\n        for fingerprint in res.keys:\n            if fingerprint.endswith(key):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate -- gen - key input per gpg doc / DETAILS.", "response": "def gen_key_input(self, key_params={}):\n        '''\n        Generate --gen-key input per gpg doc/DETAILS.\n\n        :param key_params: Key parameters\n        :rtype: str\n        :return: Control input for :func:`regnupg.gen_key`\n        '''\n        params = self.default_key_params.copy()\n        params.update(key_params)\n        result = ['Key-Type: %s' % params.pop('Key-Type')]\n        result += ('%s: %s' % (param, value) for param, value in params.items())\n        result.append('%commit\\n')\n        return '\\n'.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsigning a file with a key.", "response": "def sign_file(self, message_file, key_id=None, passphrase=None,\n                  clearsign=True, detach=False, binary=False):\n        '''\n        Make a signature.\n\n        :param message_file: File-like object for sign\n        :param key_id: Key for signing, default will be used if null\n        :param passphrase: Key password\n        :param clearsign: Make a clear text signature\n        :param detach: Make a detached signature\n        :param binary: If false, create ASCII armored output\n        :rtype: SignResult\n        '''\n        args = ['-s' if binary else '-sa']\n        if detach:\n            args.append('--detach-sign')\n        if clearsign:\n            args.append('--clearsign')\n        if key_id:\n            #args += ('--default-key', key_id)\n            args += ('--local-user', key_id)\n        return self.execute(SignResult(), args, passphrase, message_file, True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a signature. :param message: Message to sign :param key_id: Key for signing, default will be used if null :param passphrase: Key password :param clearsign: Make a clear text signature :param detach: Make a detached signature :param binary: If false, create ASCII armored output :rtype: SignResult", "response": "def sign(self, message, *args, **kwargs):\n        '''\n        Make a signature.\n\n        :param message: Message to sign\n        :param key_id: Key for signing, default will be used if null\n        :param passphrase: Key password\n        :param clearsign: Make a clear text signature\n        :param detach: Make a detached signature\n        :param binary: If false, create ASCII armored output\n        :rtype: SignResult\n        '''\n        return self.sign_file(self.create_stream(message), *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify_file(self, sign_file, data_filename=None):\n        '''\n        Verify given signature\n\n        :param sign_file: File-like object containing sign\n        :param data_filename: Assume signature is detached when not null\n        :rtype: VerifyResult\n        '''\n        if data_filename is None:\n            return self.execute(VerifyResult(), ('--verify',), None, sign_file)\n        # \u041f\u043e\u0434\u043f\u0438\u0441\u044c \u0434\u043b\u044f detached \u043f\u0438\u0448\u0435\u043c \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0444\u0430\u0439\u043b\n        sign_filename, sign_fd = tempfile.mkstemp(prefix=__name__)\n        os.write(sign_fd, sign_file.read())\n        os.close(sign_fd)\n        try:\n            result = self.execute(\n                VerifyResult(), ('--verify', sign_filename, data_filename))\n        finally:\n            os.remove(sign_filename)\n        return result", "response": "Verify given signature and return verify result."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies given signature and return verify result.", "response": "def verify(self, sign, *args, **kwargs):\n        '''\n        Verify given signature\n\n        :param sign: Sign data\n        :param data_filename: Assume signature is detached when not null\n        :rtype: VerifyResult\n        '''\n        return self.verify_file(self.create_stream(sign), *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encrypt_file(self, data_file, recipients, sign_key=None, passphrase=None,\n                     always_trust=False, output_filename=None, binary=False, symmetric=False):\n        '''\n        Sign/Encrypt file\n\n        :param data_file: File-like object containing data\n        :param recipients: Single key ID or list of mutiple IDs. Will be ignored if symmetric\n        :param sign_key: Key for signing data before encryption. No sign will be made when not given\n        :param passphrase: Password for key or symmetric cipher\n        :param always_trust: Skip key validation and assume that used keys are always fully trusted\n        :param output_filename: Encrypted data will be written to file when not None\n        :param binary: If false, create ASCII armored output\n        :param symmetric: Encrypt with symmetric cipher only\n        :rtype: EncryptResult\n        '''\n        if symmetric:\n            args = ['--symmetric']\n        else:\n            args = ['--encrypt']\n            for recipient in make_list(recipients):\n                args += ('--recipient', recipient)\n        if not binary:\n            args.append('--armor')\n        if output_filename:\n            if os.path.exists(output_filename):\n                # to avoid overwrite confirmation message\n                os.remove(output_filename)\n            args += ('--output', output_filename)\n        if sign_key:\n            args += ('--sign', '--local-user', sign_key)\n        if always_trust:\n            #args.append ('--always-trust')\n            args += ('--trust-model', 'always')\n        return self.execute(EncryptResult(), args, passphrase if passphrase is not None else '', data_file, True)", "response": "Signs data with a key and encrypts it with a key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encrypt(self, data, *args, **kwargs):\n        '''\n        Sign/Encrypt\n\n        :param data: Data to encrypt\n        :param recipients: Single key ID or list of mutiple IDs. Will be ignored if symmetric\n        :param sign_key: Key for signing data before encryption. No sign will be made when not given\n        :param passphrase: Password for key or symmetric cipher\n        :param always_trust: Skip key validation and assume that used keys are always fully trusted\n        :param output_filename: Encrypted data will be written to this file when not None\n        :param binary: If false, create ASCII armored output\n        :param symmetric: Encrypt with symmetric cipher only\n        :rtype: EncryptResult\n        '''\n        return self.encrypt_file(self.create_stream(data), *args, **kwargs)", "response": "Encrypt data with key - based encryption"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decrypt(self, encrypted_data, *args, **kwargs):\n        '''\n        Decrypt/verify\n\n        :param encrypted_data: Encrypted data\n        :param passphrase: Passphrase\n        :param signer_key: Signer key ID. Sign will not be verifyed when None\n        :param always_trust: Skip key validation and assume that used keys are always fully trusted\n        :param output_filename: Decrypted data will be written to this file when not None\n        :rtype: EncryptResult\n        '''\n        return self.decrypt_file(self.create_stream(encrypted_data), *args, **kwargs)", "response": "Decrypt the data with the passphrase and return the decrypted data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef safeInt(n, warn_only=False):\n    if str(n).startswith('0'):\n        if not warn_only:\n            raise TypeError(\"Unsafe Int: \" + str(n))\n        print \"Unsafe Int: %s\" % n\n        return int(n)\n    try:\n        return int(n)\n    except ValueError:\n        return n", "response": "Returns an int from the given number if it is not a number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        # We override the MapRegisterMessage sa\n        super(InfoMessage, self).sanitize()\n\n        # R: R bit indicates this is a reply to an Info-Request (Info-\n        # Reply).  R bit is set to 0 in an Info-Request.  When R bit is set\n        # to 0, the AFI field (following the EID-prefix field) must be set\n        # to 0.  When R bit is set to 1, the packet contents follow the\n        # format for an Info-Reply as described below.\n        if not isinstance(self.is_reply, bool):\n            raise ValueError('Is-reply flag must be a boolean')\n\n        # Nonce: An 8-byte random value created by the sender of the Info-\n        # Request.  This nonce will be returned in the Info-Reply.  The\n        # nonce SHOULD be generated by a properly seeded pseudo-random (or\n        # strong random) source.\n        if len(bytes(self.nonce)) != 8:\n            raise ValueError('Invalid nonce')\n\n        # Key ID:  A configured ID to find the configured Message\n        # Authentication Code (MAC) algorithm and key value used for the\n        # authentication function.  See Section 14.4 for codepoint\n        # assignments.\n        if self.key_id not in (KEY_ID_NONE, KEY_ID_HMAC_SHA_1_96,\n                               KEY_ID_HMAC_SHA_256_128):\n            raise ValueError('Invalid Key ID')\n\n        # Authentication Data:  The message digest used from the output of the\n        # Message Authentication Code (MAC) algorithm.  The entire Map-\n        # Register payload is authenticated with this field preset to 0.\n        # After the MAC is computed, it is placed in this field.\n        # Implementations of this specification MUST include support for\n        # HMAC-SHA-1-96 [RFC2404] and support for HMAC-SHA-256-128 [RFC6234]\n        # is RECOMMENDED.\n        if not isinstance(self.authentication_data, bytes):\n            raise ValueError('Invalid authentication data')\n\n        # TTL: The time in minutes the recipient of the Info-Reply will\n        # store the RTR Information.\n        if not isinstance(self.ttl, numbers.Integral) \\\n        or self.ttl < 0 or self.ttl > 0xffffffff:\n            raise ValueError('Invalid TTL')\n\n        # EID-prefix:  4 octets if an IPv4 address-family, 16 octets if an IPv6\n        # address-family.\n        if not isinstance(self.eid_prefix, (IPv4Network, IPv6Network)):\n            raise ValueError('EID prefix must be IPv4 or IPv6')\n\n        # When a Map-Server receives an Info-Request message, it responds with\n        # an Info-Reply message.  The Info-Reply message source port is 4342,\n        # and destination port is taken from the source port of the triggering\n        # Info-Request.  Map-Server fills the NAT LCAF (LCAF Type = 7) fields\n        # according to their description.  The Map-Server uses AFI=0 for the\n        # Private ETR RLOC Address field in the NAT LCAF.\n        if self.is_reply:\n            if not isinstance(self.reply, LCAFNATTraversalAddress):\n                raise ValueError(\"An InfoMessage which is an Info-Reply must contain an LCAFNATTraversalAddress\")\n        else:\n            if self.reply is not None:\n                raise ValueError(\"An InfoMessage which is an Info-Request can not contain a reply\")", "response": "Sanitize the current settings and return a new value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the authentication data based on the current key - id and the given key.", "response": "def calculate_authentication_data(self, key):\n        '''\n        Calculate the authentication data based on the current key-id and the\n        given key.\n        '''\n        # This one is easy\n        if self.key_id == KEY_ID_NONE:\n            return ''\n\n        # Determine the digestmod and how long the authentication data will be\n        if self.key_id == KEY_ID_HMAC_SHA_1_96:\n            digestmod = hashlib.sha1\n            data_length = 20\n        elif self.key_id == KEY_ID_HMAC_SHA_256_128:\n            digestmod = hashlib.sha256\n            data_length = 32\n        else:\n            raise ValueError('Unknown Key ID')\n\n        # Fill the authentication data with the right number of zeroes\n        # after storing the original first so we can restore it later\n        current_authentication_data = self.authentication_data\n        self.authentication_data = '\\x00' * data_length\n\n        # Build the packet\n        msg = self.to_bytes()\n\n        # Restore the authentication data\n        self.authentication_data = current_authentication_data\n\n        # Return the authentication data based on the generated packet\n        # and the given key\n        return hmac.new(key, msg, digestmod).digest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nverifies the current authentication data based on the current key - id and the given key - id.", "response": "def verify_authentication_data(self, key):\n        '''\n        Verify the current authentication data based on the current key-id and\n        the given key.\n        '''\n        correct_authentication_data = self.calculate_authentication_data(key)\n        return self.authentication_data == correct_authentication_data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert_authentication_data(self, key):\n        '''\n        Insert authentication data based on the current key-id and the given\n        key.\n        '''\n        correct_authentication_data = self.calculate_authentication_data(key)\n        self.authentication_data = correct_authentication_data", "response": "Insert authentication data based on the current key - id and the given key - id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_bytes(cls, bitstream):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the type\n        type_nr = bitstream.read('uint:4')\n        if type_nr != packet.message_type:\n            msg = 'Invalid bitstream for a {0} packet'\n            class_name = packet.__class__.__name__\n            raise ValueError(msg.format(class_name))\n\n        # Read if this is a reply\n        packet.is_reply = bitstream.read('bool')\n\n        # Skip reserved bits\n        packet._reserved1 = bitstream.read(27)\n\n        # Read the nonce\n        packet.nonce = bitstream.read('bytes:8')\n\n        # Read the key id\n        packet.key_id = bitstream.read('uint:16')\n\n        # Read the authentication data\n        data_length = bitstream.read('uint:16')\n        packet.authentication_data = bitstream.read('bytes:%d' % data_length)\n\n        # Read the TTL\n        packet.ttl = bitstream.read('uint:32')\n\n        # Skip reserved bits\n        packet._reserved2 = bitstream.read(8)\n\n        # Store the EID prefix mask length until we need it\n        eid_prefix_len = bitstream.read('uint:8')\n\n        # Read the EID prefix\n        packet.eid_prefix = read_afi_address_from_bitstream(bitstream, eid_prefix_len)\n\n        # Read the reply\n        packet.reply = read_afi_address_from_bitstream(bitstream)\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "Parse the given packet and update properties accordingly\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the type\n        bitstream = BitArray('uint:4=%d' % self.message_type)\n\n        # Add the flags\n        bitstream += BitArray('bool=%d' % self.is_reply)\n\n        # Add reserved bits\n        bitstream += self._reserved1\n\n        # Add the nonce\n        bitstream += BitArray(bytes=self.nonce)\n\n        # Add the key-id and authentication data\n        bitstream += BitArray('uint:16=%d, uint:16=%d, hex=%s'\n                              % (self.key_id,\n                                 len(self.authentication_data),\n                                 self.authentication_data.encode('hex')))\n\n        # Add the TTL\n        bitstream += BitArray('uint:32=%d' % self.ttl)\n\n        # Add reserved bits\n        bitstream += self._reserved2\n\n        # Add the EID prefix mask length\n        bitstream += BitArray('uint:8=%d' % self.eid_prefix.prefixlen)\n\n        # Add the EID prefix\n        bitstream += get_bitstream_for_afi_address(self.eid_prefix)\n\n        # Add the reply\n        bitstream += get_bitstream_for_afi_address(self.reply)\n\n        return bitstream.bytes", "response": "Create bytes from properties and return them as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef track_model(model):\n    '''\n    Perform designated transformations on model, when it saves.\n\n    Calls :py:func:`~simpleimages.utils.perform_transformation`\n    on every model saves using\n    :py:data:`django.db.models.signals.post_save`.\n\n    It uses the ``update_fields`` kwarg to tell what fields it should\n    transform.\n    '''\n    @receiver(post_save, sender=model, weak=False, dispatch_uid='simpleimages')\n    def transform_signal(sender, **kwargs):\n        simpleimages.utils.perform_transformation(\n            kwargs['instance'],\n            kwargs['update_fields']\n        )\n\n    def disconnect():\n        post_save.disconnect(sender=model, dispatch_uid='simpleimages')\n    return disconnect", "response": "Track the model as a new object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _inner_product(y,yr,psd):\n    fmin = 40.\n    fmax = 2000.\n    fs = 16384.\n    # fourier transform y and yr\n    #y = sp.fft(y,n=None)\n    #yr = sp.fft(yr,n=None)\n    # compute product\n    y = (1./fs)*y\n    yr = (1./fs)*yr\n    p = np.multiply(y,np.conjugate(yr))/psd\n    product = max(abs(fs*sp.ifft(np.multiply(y,np.conjugate(yr))/psd)))\n    return product", "response": "Compute inner product between two time domain waveforms weighted by noisecurve."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the noise weighted inner product of yyr and psd", "response": "def _overlap(y,yr,psd):\n    \"\"\" returns the detector noise weighted inner product \"\"\"\n    yyr  = _inner_product(y,yr,psd)\n    yy   = _inner_product(y,y,psd)\n    yryr = _inner_product(yr,yr,psd)\n    olap = yyr/np.sqrt(yy*yryr)\n    return olap"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _run_arguement_object_fits(self):\n        # run fits\n        # fit catalog object\n        Y_dict = self._catalog_object.get_transformed_Y()\n        # fit designmatrix object\n        X = self._designmatrix_object.get_matrix()\n        Xcol_names = self._designmatrix_object.get_columnnames()\n        row_names = self._designmatrix_object.get_rownames()\n        # make sure waveforms are matched\n        # loop through Xrow_names, use as key for Y_dict, populate Y_matrix\n        Y = np.empty((len(row_names),len(Y_dict[Y_dict.keys()[0]])))\n\n        # check if waveforms are complex valued.  if so, instantiate Y as complex type\n        if sum(np.iscomplex(Y_dict[Y_dict.keys()[0]])):\n            # then it is complex\n            Y = np.empty((len(row_names),len(Y_dict[Y_dict.keys()[0]]))).astype(np.complex)\n\n        for i in np.arange(0,len(row_names)):\n            Y[i,:] = Y_dict[row_names[i]]\n        # fit basis object\n        A = self._basis_object.fit_transform(Y)\n        return Y, X, A, Xcol_names, row_names", "response": "This function fits objects passed to Multivar guarantees wave ordering of objects in the object and DesignMatrix object matches up\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit(self):\n        # solve for estimator of B\n        n,p          = np.shape(self._X)\n        self._df     = float(n - p)\n        self._Cx     = np.linalg.pinv(np.dot(self._X.T,self._X))\n        self._Bhat   = np.dot(np.dot(self._Cx, self._X.T), self._A)\n        self._Y_rec  = self._compute_prediction(self._X)", "response": "fit waveforms in any domain"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef summary(self):\n        transform = self._catalog_object._transform\n        if   transform == 'time':\n            self._hotellings_time()\n        elif transform == 'fourier':\n            self._hotellings_fourier()\n        elif transform == 'spectrogram':\n            self._hotellings_spectrogram()\n        elif transform == 'amplitude':\n            self._hotellings_amplitude()\n        elif transform == 'phase':\n            self._hotellings_phase()\n        else:\n            raise ValueError(\"Unknown catalog transformation\")\n        # print out to terminal\n        self._make_summary_tables()", "response": "prints results of hotellings T2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing T2 tests for time domain waveforms", "response": "def _hotellings_time(self):\n        \"\"\" hotelling's T2 tests for time domain waveforms\"\"\"\n        # get residuals\n        df = self._df\n        R = self._A - np.dot(self._X, self._Bhat)\n        Sigma_Z = np.dot(R.T,R)*(1./df)\n        # compute p-values\n        T_2_list = []\n        p_value_list = []\n        for i in np.arange(0,self._Bhat.shape[0]):\n            Bstar       = self._Bhat[i,np.arange(0,np.shape(self._A)[1])]\n            lstar       = float(np.shape(Bstar)[0])\n            cx          = self._Cx[i,i]\n            Einv        = np.linalg.pinv(Sigma_Z)\n            Zs          = Bstar/np.sqrt(cx)\n            T_2         = ((df - lstar + 1.)/(df*lstar)*np.dot(np.dot(Zs,Einv),Zs.T))\n            p_value     = 1. - stats.f.cdf(T_2, lstar, df - lstar + 1.)\n\n            p_value_list.append(p_value)\n            T_2_list.append(T_2)\n        # save pvalue results in a table\n        self._results = [['Comparison','Hotellings T^2', \"p-value\"]]\n        for i in np.arange(0,len(self._col_names)):\n            self._results.append([self._col_names[i], T_2_list[i], p_value_list[i]])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint the summary of the regression. It shows the waveform metadata, diagnostics of the fit, and results of the hypothesis tests for each comparison encoded in the design matrix", "response": "def _make_summary_tables(self):\n        \"\"\"\n        prints the summary of the regression.  It shows\n        the waveform metadata, diagnostics of the fit, and results of the\n        hypothesis tests for each comparison encoded in the design matrix\n        \"\"\"\n        try:\n            self._Bhat\n        except:\n            raise Exception(\"Regression hasn't been fit yet.  run .fit()\")\n        else:\n            # check degrees of freedom\n            num_pcs = self._basis_object.get_params()['num_components']\n            total_dof = self._X.shape[0] - self._X.shape[1] - num_pcs\n            if total_dof <= 0.0:\n                raise ValueError(\"degrees of freedom <= 0, Hotellings T2 not defined\")\n\n            # print catalog and basis info\n            cat_table = self._catalog_object.get_params().items()\n            bas_table = self._basis_object.get_params().items()\n            print tabulate(cat_table+bas_table,tablefmt='plain')\n\n            # then print pvalues\n            # make T^2 & pvalue table\n            headers = self._results[0]\n            table   = self._results[1:]\n            print tabulate(table, headers, tablefmt=\"rst\")\n            print \"Formula Used: %s\" % self._designmatrix_object._formula\n            print \"Degrees of Freedom (n - p - k): %s\" % str(total_dof)\n            print \"Condition Number of X^T*X: %.2f\" % np.linalg.cond(np.dot(self._X.T, self._X))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef overlap_summary(self):\n        olaps = self.compute_overlaps()\n\n        # compute min, 25% 50% (median), mean, 75%, max\n        table =  [[\"5%: \",np.percentile(olaps,5)],\n                 [\"25%: \",np.percentile(olaps,25)],\n                 [\"50%: \",np.percentile(olaps,50)],\n                 [\"75%: \",np.percentile(olaps,75)],\n                 [\"95%: \",np.percentile(olaps,95)],\n                 [\"  \" , \"  \"],\n                 [\"Min: \",np.min(olaps)],\n                 [\"Mean: \",np.mean(olaps)],\n                 [\"Max: \",np.max(olaps)]]\n\n        header = [\"Percentile\",\"Overlap\"]\n        print tabulate(table,header,tablefmt=\"rst\")", "response": "print summary of reconstruction overlaps"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_prediction(self,X):\n        A_pred = np.dot(X,self._Bhat)\n        Y_pred = self._basis_object.inverse_transform(A_pred)\n        return Y_pred", "response": "compute predictions given a new X"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npredicting new waveforms using multivar fit", "response": "def predict(self,param_dict):\n        \"\"\" predict new waveforms using multivar fit \"\"\"\n        encoder_dict = self._designmatrix_object.encoder\n        X, col_names = self._designmatrix_object.run_encoder(param_dict, encoder_dict)\n        # compute predictions\n        Y_pred = self._compute_prediction(X)\n        return Y_pred"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nputs info about coverage into the env so that subprocesses can activate coverage.", "response": "def set_env(self):\n        \"\"\"Put info about coverage into the env so that subprocesses can activate coverage.\"\"\"\n\n        if self.cov_source is None:\n            os.environ['COV_CORE_SOURCE'] = ''\n        else:\n            os.environ['COV_CORE_SOURCE'] = UNIQUE_SEP.join(self.cov_source)\n        os.environ['COV_CORE_DATA_FILE'] = self.cov_data_file\n        os.environ['COV_CORE_CONFIG'] = self.cov_config"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves coverage info from env.", "response": "def unset_env():\n        \"\"\"Remove coverage info from env.\"\"\"\n        os.environ.pop('COV_CORE_SOURCE', None)\n        os.environ.pop('COV_CORE_DATA_FILE', None)\n        os.environ.pop('COV_CORE_CONFIG', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nproduces coverage report and output it to the given stream.", "response": "def summary(self, stream):\n        \"\"\"Produce coverage reports.\"\"\"\n\n        # Output coverage section header.\n        if len(self.node_descs) == 1:\n            self.sep(stream, '-', 'coverage: %s' % ''.join(self.node_descs))\n        else:\n            self.sep(stream, '-', 'coverage')\n            for node_desc in sorted(self.node_descs):\n                self.sep(stream, ' ', '%s' % node_desc)\n\n        # Produce terminal report if wanted.\n        if 'term' in self.cov_report or 'term-missing' in self.cov_report:\n            show_missing = 'term-missing' in self.cov_report\n            self.cov.report(show_missing=show_missing, ignore_errors=True, file=stream)\n\n        # Produce annotated source code report if wanted.\n        if 'annotate' in self.cov_report:\n            self.cov.annotate(ignore_errors=True)\n            stream.write('Coverage annotated source written next to source\\n')\n\n        # Produce html report if wanted.\n        if 'html' in self.cov_report:\n            self.cov.html_report(ignore_errors=True)\n            stream.write('Coverage HTML written to dir %s\\n' % self.cov.config.html_dir)\n\n        # Produce xml report if wanted.\n        if 'xml' in self.cov_report:\n            self.cov.xml_report(ignore_errors=True)\n            stream.write('Coverage XML written to file %s\\n' % self.cov.config.xml_output)\n\n        # Report on any failed slaves.\n        if self.failed_slaves:\n            self.sep(stream, '-', 'coverage: failed slaves')\n            stream.write('The following slaves failed to return coverage data, '\n                         'ensure that pytest-cov is installed on these slaves.\\n')\n            for node in self.failed_slaves:\n                stream.write('%s\\n' % node.gateway.id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping coverage save data to file and set the list of coverage objects to report on.", "response": "def finish(self):\n        \"\"\"Stop coverage, save data to file and set the list of coverage objects to report on.\"\"\"\n\n        self.unset_env()\n        self.cov.stop()\n        self.cov.combine()\n        self.cov.save()\n        node_desc = self.get_node_desc(sys.platform, sys.version_info)\n        self.node_descs.add(node_desc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(self):\n\n        if self.cov_config and os.path.exists(self.cov_config):\n            self.config.option.rsyncdir.append(self.cov_config)\n\n        self.cov = coverage.coverage(source=self.cov_source,\n                                     data_file=self.cov_data_file,\n                                     config_file=self.cov_config)\n        self.cov.erase()\n        self.cov.start()\n        self.cov.config.paths['source'] = [self.topdir]", "response": "Start coverage rc file if appropriate."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconfigures node to know if they are collocated and what files have moved.", "response": "def configure_node(self, node):\n        \"\"\"Slaves need to know if they are collocated and what files have moved.\"\"\"\n\n        node.slaveinput['cov_master_host'] = socket.gethostname()\n        node.slaveinput['cov_master_topdir'] = self.topdir\n        node.slaveinput['cov_master_rsync_roots'] = [str(root) for root in node.nodemanager.roots]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef finish(self):\n\n        # Combine all the suffix files into the data file.\n        self.cov.stop()\n        self.cov.combine()\n        self.cov.save()", "response": "Combines coverage data and sets the list of coverage objects to report on."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self):\n\n        # Determine whether we are collocated with master.\n        self.is_collocated = bool(socket.gethostname() == self.config.slaveinput['cov_master_host'] and\n                                  self.topdir == self.config.slaveinput['cov_master_topdir'])\n\n        # If we are not collocated then rewrite master paths to slave paths.\n        if not self.is_collocated:\n            master_topdir = self.config.slaveinput['cov_master_topdir']\n            slave_topdir = self.topdir\n            self.cov_source = [source.replace(master_topdir, slave_topdir) for source in self.cov_source]\n            self.cov_data_file = self.cov_data_file.replace(master_topdir, slave_topdir)\n            self.cov_config = self.cov_config.replace(master_topdir, slave_topdir)\n\n        # Our slave node id makes us unique from all other slaves so\n        # adjust the data file that we contribute to and the master\n        # will combine our data with other slaves later.\n        self.cov_data_file += '.%s' % self.nodeid\n\n        # Erase any previous data and start coverage.\n        self.cov = coverage.coverage(source=self.cov_source,\n                                     data_file=self.cov_data_file,\n                                     config_file=self.cov_config)\n        self.cov.erase()\n        self.cov.start()\n        self.set_env()", "response": "Start coverage for the current master and master node."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops coverage and send relevant info back to the master.", "response": "def finish(self):\n        \"\"\"Stop coverage and send relevant info back to the master.\"\"\"\n\n        self.unset_env()\n        self.cov.stop()\n        self.cov.combine()\n        self.cov.save()\n\n        if self.is_collocated:\n            # If we are collocated then just inform the master of our\n            # data file to indicate that we have finished.\n            self.config.slaveoutput['cov_slave_node_id'] = self.nodeid\n        else:\n            # If we are not collocated then add the current path\n            # and coverage data to the output so we can combine\n            # it on the master node.\n\n            # Send all the data to the master over the channel.\n            self.config.slaveoutput['cov_slave_path'] = self.topdir\n            self.config.slaveoutput['cov_slave_node_id'] = self.nodeid\n            self.config.slaveoutput['cov_slave_lines'] = self.cov.data.lines\n            self.config.slaveoutput['cov_slave_arcs'] = self.cov.data.arcs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter_req_paths(paths, func):\n    if not isinstance(paths, list):\n        raise ValueError(\"Paths must be a list of paths.\")\n\n    libs = set()\n    junk = set(['\\n'])\n    for p in paths:\n        with p.open(mode='r') as reqs:\n            lines = set([line for line in reqs if func(line)])\n            libs.update(lines)\n\n    return list(libs - junk)", "response": "Return list of filtered libs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting the response object.", "response": "def extract_response(raw_response):\n    \"\"\"Extract requests response object.\n\n    only extract those status_code in [200, 300).\n\n    :param raw_response: a requests.Resposne object.\n    :return: content of response.\n    \"\"\"\n    data = urlread(raw_response)\n\n    if is_success_response(raw_response):\n        return data\n    elif is_failure_response(raw_response):\n        raise RemoteExecuteError(data)\n    elif is_invalid_response(raw_response):\n        raise InvalidResponseError(data)\n    else:\n        raise UnknownStatusError(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndispatching a HTTP request to a specific URL.", "response": "def dispatch_webhook_request(url=None, method='GET', params=None,\n                             json=None, data=None, headers=None, timeout=5):\n    \"\"\"Task dispatching to an URL.\n\n    :param url: The URL location of the HTTP callback task.\n    :param method: Method to use when dispatching the callback. Usually\n        `GET` or `POST`.\n    :param params: Keyword arguments to pass on to the HTTP callback.\n    :param json: JSON as body to pass on to the POST HTTP callback.\n    :param headers: HTTP headers applied to callback.\n    \"\"\"\n    if method == 'GET':\n        resp = urlopen(url, method, params=params, headers=headers)\n    elif method in ('POST', 'DELETE', 'PUT'):\n        resp = urlopen(url, method, json=json, data=data, headers=headers)\n    else:\n        raise NotImplementedError\n\n    return extract_response(resp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Admin URL for the current view.", "response": "def get_staff_url(self):\n        \"\"\"\n        Return the Admin URL for the current view.\n        By default, it uses the :func:`get_staff_object` function to base the URL on.\n        \"\"\"\n        object = self.get_staff_object()\n        if object is not None:\n            # View is likely using SingleObjectMixin\n            return reverse(admin_urlname(object._meta, 'change'), args=(object.pk,))\n\n        model = _get_view_model(self)\n        if model is not None:\n            # View is likely using MultipleObjectMixin (e.g. ListView)\n            return reverse(admin_urlname(object._meta, 'changelist'))\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_by_id(self, id, change_notes=False):\n        graph = uri_to_graph('%s/%s.rdf' % (self.url, id), session=self.session)\n        if graph is False:\n            log.debug('Failed to retrieve data for %s/%s.rdf' % (self.url, id))\n            return False\n        # get the concept\n        things = things_from_graph(graph, self.subclasses, self.concept_scheme)\n        if len(things) == 0:\n            return False\n        c = things[0]\n        return c", "response": "Get a Concept or SkyOSS. SkosCollection object by id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a : class : skosprovider. skos. Concept or skosprovider. skos. Collection object by uri.", "response": "def get_by_uri(self, uri, change_notes=False):\n        \"\"\" Get a :class:`skosprovider.skos.Concept` or :class:`skosprovider.skos.Collection` by uri\n\n        :param (str) uri: string uri of the :class:`skosprovider.skos.Concept` or :class:`skosprovider.skos.Concept`\n        :return: corresponding :class:`skosprovider.skos.Concept` or :class:`skosprovider.skos.Concept`.\n            Returns None if non-existing id\n        \"\"\"\n\n        id = uri_to_id(uri)\n\n        return self.get_by_id(id, change_notes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find(self, query, **kwargs):\n        '''Find concepts that match a certain query.\n\n        Currently query is expected to be a dict, so that complex queries can\n        be passed. You can use this dict to search for concepts or collections\n        with a certain label, with a certain type and for concepts that belong\n        to a certain collection.\n\n        .. code-block:: python\n\n            # Find anything that has a label of church.\n            provider.find({'label': 'church'}\n\n            # Find all concepts that are a part of collection 5.\n            provider.find({'type': 'concept', 'collection': {'id': 5})\n\n            # Find all concepts, collections or children of these\n            # that belong to collection 5.\n            provider.find({'collection': {'id': 5, 'depth': 'all'})\n\n        :param query: A dict that can be used to express a query. The following\n            keys are permitted:\n\n            * `label`: Search for something with this label value. An empty \\\n                label is equal to searching for all concepts.\n            * `type`: Limit the search to certain SKOS elements. If not \\\n                present `all` is assumed:\n\n                * `concept`: Only return :class:`skosprovider.skos.Concept` \\\n                    instances.\n                * `collection`: Only return \\\n                    :class:`skosprovider.skos.Collection` instances.\n                * `all`: Return both :class:`skosprovider.skos.Concept` and \\\n                    :class:`skosprovider.skos.Collection` instances.\n            * `collection`: Search only for concepts belonging to a certain \\\n                collection. This argument should be a dict with two keys:\n\n                * `id`: The id of a collection. Required.\n                * `depth`: Can be `members` or `all`. Optional. If not \\\n                    present, `members` is assumed, meaning only concepts or \\\n                    collections that are a direct member of the collection \\\n                    should be considered. When set to `all`, this method \\\n                    should return concepts and collections that are a member \\\n                    of the collection or are a narrower concept of a member \\\n                    of the collection.\n\n        :returns: A :class:`lst` of concepts and collections. Each of these\n            is a dict with the following keys:\n\n            * id: id within the conceptscheme\n            * uri: :term:`uri` of the concept or collection\n            * type: concept or collection\n            * label: A label to represent the concept or collection. It is \\\n                determined by looking at the `**kwargs` parameter, the default \\\n                language of the provider and finally falls back to `en`.\n        '''\n        # #  interprete and validate query parameters (label, type and collection)\n        # Label\n        label = None\n        if 'label' in query:\n            label = query['label']\n        # Type: 'collection','concept' or 'all'\n        type_c = 'all'\n        if 'type' in query:\n            type_c = query['type']\n        if type_c not in ('all', 'concept', 'collection'):\n            raise ValueError(\"type: only the following values are allowed: 'all', 'concept', 'collection'\")\n        #Collection to search in (optional)\n        coll_id = None\n        coll_depth = None\n        if 'collection' in query:\n            coll = query['collection']\n            if not 'id' in coll:\n                raise ValueError(\"collection: 'id' is required key if a collection-dictionary is given\")\n            coll_id = coll['id']\n            coll_depth = 'members'\n            if 'depth' in coll:\n                coll_depth = coll['depth']\n            if coll_depth not in ('members', 'all'):\n                raise ValueError(\n                    \"collection - 'depth': only the following values are allowed: 'members', 'all'\")\n\n        #build sparql query\n        coll_x = \"\"\n        if coll_id is not None and coll_depth == 'all':\n            coll_x = \"gvp:broaderExtended \" + self.vocab_id + \":\" + coll_id + \";\"\n        elif coll_id is not None and coll_depth == 'members':\n            coll_x = \"gvp:broader \" + self.vocab_id + \":\" + coll_id + \";\"\n\n\n        type_values = \"((?Type = skos:Concept) || (?Type = skos:Collection))\"\n        if type_c == 'concept':\n            type_values = \"(?Type = skos:Concept)\"\n        elif type_c == 'collection':\n            type_values = \"(?Type = skos:Collection)\"\n        query = \"\"\"\n            SELECT ?Subject ?Term ?Type ?Id (lang(?Term) as ?Lang) {\n            ?Subject rdf:type ?Type; dc:identifier ?Id; %s  skos:inScheme %s:; %s.\n                            OPTIONAL {\n                  {?Subject xl:prefLabel [skosxl:literalForm ?Term]}\n                          }\n            FILTER(%s)\n            }\"\"\" % (self._build_keywords(label), self.vocab_id, coll_x, type_values)\n        ret= self._get_answer(query, **kwargs)\n        language = self._get_language(**kwargs)\n        sort = self._get_sort(**kwargs)\n        sort_order = self._get_sort_order(**kwargs)\n        return self._sort(ret, sort, language, sort_order == 'desc')", "response": "Find concepts that match a certain query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_answer(self, query, **kwargs):\n        # send request to getty\n        \"\"\" Returns the results of the Sparql query to a :class:`lst` of concepts and collections.\n            The return :class:`lst`  can be empty.\n\n        :param query (str): Sparql query\n        :returns: A :class:`lst` of concepts and collections. Each of these\n            is a dict with the following keys:\n            * id: id within the conceptscheme\n            * uri: :term:`uri` of the concept or collection\n            * type: concept or collection\n            * label: A label to represent the concept or collection.\n        \"\"\"\n        request = self.base_url + \"sparql.json\"\n        try:\n            res = self.session.get(request, params={\"query\": query})\n        except ConnectionError as e:\n            raise ProviderUnavailableException(\"Request could not be executed - Request: %s - Params: %s\" % (request, query))\n        if res.status_code == 404:\n            raise ProviderUnavailableException(\"Service not found (status_code 404) - Request: %s - Params: %s\" % (request, query))\n        if not res.encoding:\n            res.encoding = 'utf-8'\n        r = res.json()\n        d = {}\n        for result in r[\"results\"][\"bindings\"]:\n            uri = result[\"Subject\"][\"value\"]\n            if \"Term\" in result:\n                label = result[\"Term\"][\"value\"]\n            else:\n                label = \"<not available>\"\n            item = {\n            'id': result[\"Id\"][\"value\"],\n            'uri': uri,\n            'type': result[\"Type\"][\"value\"].rsplit('#', 1)[1],\n            'label': label,\n            'lang': result[\"Lang\"][\"value\"]\n            }\n\n            if uri not in d:\n                d[uri] = item\n            if tags.tag(d[uri]['lang']).format == tags.tag(self._get_language(**kwargs)).format:\n                pass\n            elif tags.tag(item['lang']).format == tags.tag(self._get_language(**kwargs)).format:\n                d[uri] = item\n            elif tags.tag(item['lang']).language and (tags.tag(item['lang']).language.format == tags.tag(self._get_language()).language.format):\n                d[uri] = item\n            elif tags.tag(item['lang']).format == tags.tag('en').format:\n                d[uri] = item\n        return list(d.values())", "response": "Send a query to getty the set of concepts and collections."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_top(self, type='All', **kwargs):\n\n        if type == \"concepts\" :\n            type_values = \"(?Type = skos:Concept)\"\n        else:\n            type_values = \"((?Type = skos:Concept) || (?Type = skos:Collection))\"\n\n        query = \"\"\"SELECT ?Subject ?Id ?Type ?Term (lang(?Term) as ?Lang)\n                {\n                ?Subject a gvp:Facet; rdf:type ?Type;\n                 dc:identifier ?Id; skos:inScheme %s:;.\n                 OPTIONAL {\n                  {?Subject xl:prefLabel [skosxl:literalForm ?Term]}\n                          }\n                FILTER (%s)\n                }\"\"\" % (self.vocab_id, type_values)\n        ret= self._get_answer(query, **kwargs)\n        language = self._get_language(**kwargs)\n        sort = self._get_sort(**kwargs)\n        sort_order = self._get_sort_order(**kwargs)\n        return self._sort(ret, sort, language, sort_order == 'desc')", "response": "Returns all top - level facets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of concepts or collections that should be displayed under this concept or collection.", "response": "def get_children_display(self, id, **kwargs):\n        \"\"\" Return a list of concepts or collections that should be displayed under this concept or collection.\n\n        :param str id: A concept or collection id.\n        :returns: A :class:`lst` of concepts and collections.\n        \"\"\"\n        broader = 'broader'\n        type_values = \"((?Type = skos:Concept) || (?Type = skos:Collection))\"\n\n        query = \"\"\"SELECT ?Subject ?Id ?Type ?Term (lang(?Term) as ?Lang)\n                {\n                ?Subject rdf:type ?Type;\n                dc:identifier ?Id; skos:inScheme %s:; gvp:%s %s:%s;.\n                OPTIONAL {\n                  {?Subject xl:prefLabel [skosxl:literalForm ?Term]}\n                          }\n                FILTER(%s)\n                }\"\"\" % (self.vocab_id, broader, self.vocab_id, id, type_values)\n\n        ret= self._get_answer(query, **kwargs)\n        language = self._get_language(**kwargs)\n        sort = self._get_sort(**kwargs)\n        sort_order = self._get_sort_order(**kwargs)\n        return self._sort(ret, sort, language, sort_order == 'desc')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef expand(self, id):\n\n        query = \"\"\"SELECT DISTINCT ?Id{\n                {\n                ?Subject dc:identifier ?Id; skos:inScheme %s:; gvp:broaderExtended %s;.\n                }\n                UNION\n                {\n                VALUES ?Id {'%s'}\n                ?Subject dc:identifier ?Id; skos:inScheme %s:; rdf:type skos:Concept.\n                }\n                }\n                \"\"\" % (self.vocab_id, self.vocab_id + \":\" + id, id, self.vocab_id)\n\n        print (query)\n        res = self.session.get(self.base_url + \"sparql.json\", params={\"query\": query})\n        res.encoding = 'utf-8'\n        r = res.json()\n\n        result = [result['Id']['value'] for result in r['results']['bindings']]\n        if len(result) == 0 and self.get_by_id(id) is False:\n            return False\n        return result", "response": "Expand a concept or collection to all it s narrower concepts. Returns False if the id does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef state_attributes(self):\n\n        address_attributes = None\n        if (self.current_address is not None):\n            address_attributes = self.current_address.state_attributes()\n\n        return {\n            'id': self.identifier,\n            'make': self.make,\n            'model': self.model,\n            'license_plate': self.license_plate,\n            'active': self.active,\n            'odo': self.odo,\n            'latitude': self.latitude,\n            'longitude': self.longitude,\n            'altitude': self.altitude,\n            'speed': self.speed,\n            'last_seen': self.last_seen,\n            'friendly_name': self.license_plate,\n            'equipment_id': self.equipment_id,\n            'fuel_level': self.fuel_level,\n            'malfunction_light': self.malfunction_light,\n            'coolant_temperature': self.coolant_temperature,\n            'power_voltage': self.power_voltage,\n            'current_max_speed': self.current_maximum_speed,\n            'current_address': address_attributes\n        }", "response": "Return all state attributes of the vehicle."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets trips for this device between start and end.", "response": "def get_trips(self, authentication_info, start, end):\n        \"\"\"Get trips for this device between start and end.\"\"\"\n        import requests\n\n        if (authentication_info is None or\n            not authentication_info.is_valid()):\n            return []\n\n        data_url = \"https://api.ritassist.nl/api/trips/GetTrips\"\n        query = f\"?equipmentId={self.identifier}&from={start}&to={end}&extendedInfo=True\"\n        header = authentication_info.create_header()\n        response = requests.get(data_url + query, headers=header)\n        trips = response.json()\n\n        result = []\n        for trip_json in trips:\n            trip = Trip(trip_json)\n            result.append(trip)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_extra_vehicle_info(self, authentication_info):\n        import requests\n\n        base_url = \"https://secure.ritassist.nl/GenericServiceJSONP.ashx\"\n        query = \"?f=CheckExtraVehicleInfo\" \\\n                \"&token={token}\" \\\n                \"&equipmentId={identifier}\" \\\n                \"&lastHash=null&padding=false\"\n\n        parameters = {\n            'token': authentication_info.access_token,\n            'identifier': str(self.identifier)\n        }\n\n        response = requests.get(base_url + query.format(**parameters))\n        json = response.json()\n\n        self.malfunction_light = json['MalfunctionIndicatorLight']\n        self.fuel_level = json['FuelLevel']\n        self.coolant_temperature = json['EngineCoolantTemperature']\n        self.power_voltage = json['PowerVoltage']", "response": "Get extra data from the API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the attributes of this object based on API response.", "response": "def update_from_json(self, json_device):\n        \"\"\"Set all attributes based on API response.\"\"\"\n        self.identifier = json_device['Id']\n        self.license_plate = json_device['EquipmentHeader']['SerialNumber']\n        self.make = json_device['EquipmentHeader']['Make']\n        self.model = json_device['EquipmentHeader']['Model']\n        self.equipment_id = json_device['EquipmentHeader']['EquipmentID']\n        self.active = json_device['EngineRunning']\n        self.odo = json_device['Odometer']\n        self.latitude = json_device['Location']['Latitude']\n        self.longitude = json_device['Location']['Longitude']\n        self.altitude = json_device['Location']['Altitude']\n        self.speed = json_device['Speed']\n        self.last_seen = json_device['Location']['DateTime']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexits with a log message", "response": "def barf(msg, exit=None, f=sys.stderr):\n    '''Exit with a log message (usually a fatal error)'''\n    exit = const('FSQ_FAIL_TMP') if exit is None else exit\n    shout(msg, f)\n    sys.exit(exit)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef done_item(item, code):\n    '''Succeed or fail an item based on the return code of a program'''\n    try:\n        if const('FSQ_SUCCESS') == code:\n            success(item)\n            chirp('{0}: succeeded'.format(item.id))\n        elif const('FSQ_FAIL_TMP') == code:\n            fail_tmp(item)\n            shout('{0}: failed temporarily'.format(item.id))\n        else:\n            fail_perm(item)\n            shout('{0}: failed permanantly'.format(item.id))\n    except FSQEnqueueError, e:\n        shout(e.strerror.encode(_CHARSET))\n        return -1\n    except FSQError, e:\n        shout(e.strerror.encode(_CHARSET))\n    return 0", "response": "Succeed or fail an item based on the return code of a program"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setenv(item, timefmt):\n    '''Set environment, based on item.  Usually done in a baby fork'''\n    for env, att in (( 'FSQ_ITEM_PID', 'pid', ),\n                     ( 'FSQ_ITEM_ENTROPY', 'entropy', ),\n                     ( 'FSQ_ITEM_HOSTNAME', 'hostname', ),\n                     ( 'FSQ_ITEM_HOST', 'host', ),\n                     ( 'FSQ_ITEM_ID', 'id', ), ):\n        try:\n            os.putenv(env, getattr(item,\n                      att).encode(_CHARSET))\n        except UnicodeEncodeError:\n            shout('cannot coerce item {0};'\n                  ' charset={1}'.format(att, _CHARSET))\n            return -1\n        except AttributeError:\n            if att != 'host':\n                raise\n\n    # format tries and date to env\n    os.putenv('FSQ_ITEM_TRIES', str(item.tries))\n    try:\n        os.putenv('FSQ_ITEM_ENQUEUED_AT',\n                  item.enqueued_at.strftime(timefmt))\n    except ValueError:\n        shout('invalid timefmt: {0}'.format(timefmt))\n        return -1\n    return 0", "response": "Set environment based on item."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts RAW XML string to Python dict", "response": "def _xml_to_dict(xml_to_convert):\n    \"\"\"\n    Convert RAW XML string to Python dict\n    :param xml_to_convert: XML to convert (string/text)\n    :return: Python dict with all XML data\n    \"\"\"\n\n    logger.debug(\"Converting to Python dict this XML: \" + str(xml_to_convert))\n    return xmltodict.parse(xml_to_convert, attr_prefix='')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef response_body_to_dict(http_requests_response, content_type, xml_root_element_name=None, is_list=False):\n\n    logger.info(\"Converting response body from API (XML or JSON) to Python dict\")\n    if HEADER_REPRESENTATION_JSON == content_type:\n        try:\n            return http_requests_response.json()\n        except Exception, e:\n            logger.error(\"Error parsing the response to JSON. Exception:\" + str(e))\n            raise e\n    else:\n        assert xml_root_element_name is not None,\\\n            \"xml_root_element_name is a mandatory param when body is in XML\"\n\n        try:\n            response_body = _xml_to_dict(http_requests_response.content)[xml_root_element_name]\n        except Exception, e:\n            logger.error(\"Error parsing the response to XML. Exception: \" + str(e))\n            raise e\n\n        if is_list and response_body is not None:\n            response_body = response_body.popitem()[1]\n\n        return response_body", "response": "Convert a HTTP response body to a Python dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef model_to_request_body(body_model, content_type, body_model_root_element=None):\n\n    logger.info(\"Converting body request model (Python dict) to JSON or XML\")\n    if HEADER_REPRESENTATION_XML == content_type:\n        try:\n            return _dict_to_xml(body_model)\n        except Exception, e:\n            logger.error(\"Error parsing the body model to XML. Exception: \" + str(e))\n            raise e\n    else:\n        body_json = body_model[body_model_root_element] if body_model_root_element is not None else body_model\n        encoder = JSONEncoder()\n\n        try:\n            return encoder.encode(body_json)\n        except Exception, e:\n            logger.error(\"Error parsing the body model to JSON. Exception:\" + str(e))\n            raise e", "response": "Convert a Python dict to XML or JSON or XML."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_element_when_value_none(data_structure):\n    if isinstance(data_structure, list):\n        for element in data_structure:\n            delete_element_when_value_none(element)\n    elif isinstance(data_structure, dict):\n        for element in data_structure.keys():\n            if data_structure[element] is None:\n                del data_structure[element]\n            else:\n                delete_element_when_value_none(data_structure[element])\n                if len(data_structure[element]) == 0:\n                        del data_structure[element]", "response": "This method deletes all entries in a Python dict when its value is None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate API root URL without resources", "response": "def _generate_url_root(protocol, host, port):\n        \"\"\"\n        Generate API root URL without resources\n        :param protocol: Web protocol [HTTP | HTTPS] (string)\n        :param host: Hostname or IP (string)\n        :param port: Service port (string)\n        :return: ROOT url\n        \"\"\"\n        return URL_ROOT_PATTERN.format(protocol=protocol, host=host, port=port)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _call_api(self, uri_pattern, method, body=None, headers=None, parameters=None, **kwargs):\n\n        kwargs[API_ROOT_URL_ARG_NAME] = self.api_root_url\n        url = uri_pattern.format(**kwargs)\n        logger.info(\"Executing API request [%s %s]\", method, url)\n\n        log_print_request(logger, method, url, parameters, headers, body)\n\n        try:\n            response = requests.request(method=method, url=url, data=body, headers=headers, params=parameters,\n                                        verify=False)\n        except Exception, e:\n            logger.error(\"Request {} to {} crashed: {}\".format(method, url, str(e)))\n            raise e\n\n        log_print_response(logger, response)\n\n        return response", "response": "Launch HTTP request to the API with given arguments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef launch_request(self, uri_pattern, body, method, headers=None, parameters=None, **kwargs):\n        return self._call_api(uri_pattern, method, body, headers, parameters, **kwargs)", "response": "Launch HTTP request to the API with given arguments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, uri_pattern, headers=None, parameters=None, **kwargs):\n        print uri_pattern\n        print headers\n        return self._call_api(uri_pattern, HTTP_VERB_GET, headers=headers, parameters=parameters, **kwargs)", "response": "Launch HTTP GET request to the REST API with given arguments"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlaunch HTTP POST request to the REST API with given arguments", "response": "def post(self, uri_pattern, body, headers=None, parameters=None, **kwargs):\n        \"\"\"\n        Launch HTTP POST request to the API with given arguments\n        :param uri_pattern: string pattern of the full API url with keyword arguments (format string syntax)\n        :param body: Raw Body content (string) (Plain/XML/JSON to be sent)\n        :param headers: HTTP header (dict)\n        :param parameters: Query parameters. i.e. {'key1': 'value1', 'key2': 'value2'}\n        :param **kwargs: URL parameters (without url_root) to fill the patters\n        :returns: REST API response ('Requests' response)\n        \"\"\"\n        return self._call_api(uri_pattern, HTTP_VERB_POST, body, headers, parameters, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlaunching HTTP PUT request to the REST API with given arguments", "response": "def put(self, uri_pattern, body, headers=None, parameters=None, **kwargs):\n        \"\"\"\n        Launch HTTP PUT request to the API with given arguments\n        :param uri_pattern: string pattern of the full API url with keyword arguments (format string syntax)\n        :param body: Raw Body content (string) (Plain/XML/JSON to be sent)\n        :param headers: HTTP header (dict)\n        :param parameters: Query parameters. i.e. {'key1': 'value1', 'key2': 'value2'}\n        :param **kwargs: URL parameters (without url_root) to fill the patters\n        :returns: REST API response ('Requests' response)\n        \"\"\"\n        return self._call_api(uri_pattern, HTTP_VERB_PUT, body, headers, parameters, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, uri_pattern, headers=None, parameters=None, **kwargs):\n        return self._call_api(uri_pattern, HTTP_VERB_DELETE, headers=headers, parameters=parameters, **kwargs)", "response": "Launch HTTP DELETE request to the REST API with given arguments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_dirty_model_toc(app, doctree):\n    env = app.builder.env\n    crawled = {}\n\n    def crawl_toc(node):\n        crawled[node] = True\n        for j, subnode in enumerate(node):\n            try:\n                if 'remove-node' in subnode['classes']:\n                    subnode.replace_self(nodes.comment())\n            except Exception:\n                continue\n            if subnode not in crawled:\n                crawl_toc(subnode)\n\n    crawl_toc(doctree)", "response": "Insert items described in autosummary:: to the TOC tree but not generate the TOC tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the current configuration of the object into the global configuration.", "response": "def load(*,\n         aws_access_key_id=None,\n         aws_secret_access_key=None,\n         s3_bucket=AWS_S3_DEFAULT_BUCKET_NAME,\n         dry_run=False,\n         **kwargs):\n    \"\"\"\n    Load this driver\n\n    Note that if either aws_access_key_id or aws_secret_access_key are\n    not specified, they will not be taken into account and instead\n    authentication towards AWS will solely rely on boto config\n\n    :param aws_access_key_id(str, optional): Access key ID\n    :param aws_secret_access_key(str, optional): Secret access key\n    :param s3_bucket(str, optional): Name of the S3 bucket to be used to store the file\n    :param dry_run(bool, optional): Whether to activate dry run mode on this driver\n    :param \\*\\*kwargs: arbitrary keyword arguments\n    \"\"\"\n    global _dry_run, _has_init\n    global _aws_access_key_id, _aws_secret_access_key, _bucket_name, _boto_conn\n\n    # dry run\n    _dry_run = dry_run\n\n    # AWS parameters from kwargs\n    _aws_access_key_id = aws_access_key_id\n    _aws_secret_access_key = aws_secret_access_key\n    if _aws_access_key_id is not None and type(_aws_access_key_id) != str:\n        raise TypeError('aws_access_key_id must be str')\n    if _aws_secret_access_key is not None \\\n       and type(_aws_secret_access_key) != str:\n        raise TypeError('aws_secret_access_key must be str')\n\n    # Check the bucket name before doing anything\n    _bucket_name = s3_bucket\n    if type(_bucket_name) != str:\n        raise TypeError('s3_bucket must be str')\n    if not _bucket_name:\n        raise ValueError(\"s3_bucket cannot be empty\")\n\n    # Connect to S3 service\n    log.msg(\"Connecting to Amazon S3 Service\")\n    if not _aws_access_key_id or not _aws_secret_access_key:\n        log.msg_warn(\"No AWS credentials were given. \" +\n                     \"Authentication will be done via boto.config/IAM role\")\n        if not _dry_run:\n            _boto_conn = boto.connect_s3()\n    elif not _dry_run:\n        _boto_conn = boto.connect_s3(aws_access_key_id=_aws_access_key_id,\n                                     aws_secret_access_key=_aws_secret_access_key)\n    log.msg(\"Connected to AWS S3 service successfully!\")\n\n    # Indicate this driver has been properly initialised\n    _has_init = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef backup_file(*, file, host):\n\n    # This driver won't do a thing unless it has been properly initialised\n    # via load()\n    if not _has_init:\n        raise RuntimeError(\"This driver has not been properly initialised!\")\n\n    # If the destination bucket does not exist, create one\n    try:\n        if not _dry_run:\n            bucket = _boto_conn.get_bucket(_bucket_name)\n    except boto.exception.S3ResponseError:\n        log.msg_warn(\"Bucket '{bucket_name}' does not exist!, creating it...\"\n                     .format(bucket_name=_bucket_name))\n        if not _dry_run:\n            bucket = _boto_conn.create_bucket(_bucket_name)\n        log.msg(\"Created bucket '{bucket}'\".format(bucket=_bucket_name))\n\n    # The key is the name of the file itself who needs to be stripped\n    # from its full path\n    key_path = \"{key}/{file}\".format(key=host, file=ntpath.basename(file))\n\n    # Create a new bucket key\n    if not _dry_run:\n        k = boto.s3.key.Key(bucket)\n        k.key = key_path\n\n    # Upload the file to Amazon\n    log.msg(\"Uploading '{key_path}' to bucket '{bucket_name}' ...\"\n            .format(key_path=key_path, bucket_name=_bucket_name))\n\n    # It is important to encrypt the data on the server side\n    if not _dry_run:\n        k.set_contents_from_filename(file, encrypt_key=True)\n\n    # Log the thing\n    log.msg(\"The file '{key_path}' has been successfully uploaded to S3!\"\n            .format(key_path=key_path))", "response": "Backup a file on S3"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new dictproxy object from the C API.", "response": "def _get_from_c_api():\n    \"\"\"dictproxy does exist in previous versions, but the Python constructor\n    refuses to create new objects, so we must be underhanded and sneaky with\n    ctypes.\n    \"\"\"\n    from ctypes import pythonapi, py_object\n\n    PyDictProxy_New = pythonapi.PyDictProxy_New\n    PyDictProxy_New.argtypes = (py_object,)\n    PyDictProxy_New.restype = py_object\n\n    # To actually create new dictproxy instances, we need a class that calls\n    # the above C API functions, but a subclass would also bring with it some\n    # indirection baggage.  Let's skip all that and have the subclass's __new__\n    # return an object of the real dictproxy type.\n    # In other words, the `dictproxy` class being created here is never\n    # instantiated and never does anything.  It's a glorified function.\n    # (That's why it just inherits from `object`, too.)\n    class dictproxy(object):\n        \"\"\"Read-only proxy for a dict, using the same mechanism Python uses for\n        the __dict__ attribute on objects.\n\n        Create with dictproxy(some_dict).  The original dict is still\n        read/write, and changes to the original dict are reflected in real time\n        via the proxy, but the proxy cannot be edited in any way.\n        \"\"\"\n\n        def __new__(cls, d):\n            if not isinstance(d, dict):\n                # I suspect bad things would happen if this were not true.\n                raise TypeError(\"dictproxy can only proxy to a real dict\")\n\n            return PyDictProxy_New(d)\n\n    # Try this once to make sure it actually works.  Because PyPy has all the\n    # parts and then crashes when trying to actually use them.\n    # See also: https://bugs.pypy.org/issue1233\n    dictproxy(dict())\n\n    # And slap on a metaclass that fools isinstance() while we're at it.\n    return _add_isinstance_tomfoolery(dictproxy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the object with the given attributes.", "response": "def initialize(self, id=None, text=None):\n        self.id = none_or(id, int)\n        \"\"\"\n        Contributing user's identifier : int | None\n        \"\"\"\n\n        self.text = none_or(text, str)\n        \"\"\"\n        Username or IP address of the user at the time of the edit : str | None\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new CourseCatalog instance from an string containing xml.", "response": "def from_string(html_str, url=None):\n        \"Creates a new CourseCatalog instance from an string containing xml.\"\n        return CourseCatalog(BeautifulSoup(_remove_divs(html_str),\n            convertEntities=BeautifulSoup.HTML_ENTITIES\n        ), url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all the courses crosslisted with the given CRN.", "response": "def crosslisted_with(self, crn):\n        \"\"\"Returns all the CRN courses crosslisted with the given crn.\n        The returned crosslisting does not include the original CRN.\n        \"\"\"\n        raise NotImplemented\n        return tuple([c for c in self.crosslistings[crn].crns if c != crn])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_courses(self, partial):\n        partial = partial.lower()\n        keys = self.courses.keys()\n        keys = [k for k in keys if k.lower().find(partial) != -1]\n        courses = [self.courses[k] for k in keys]\n        return list(set(courses))", "response": "Finds all courses by a given substring. This is case - insensitive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching all courses by CRNs. Not particularly efficient. Returns None if not found.", "response": "def find_course_by_crn(self, crn):\n        \"\"\"Searches all courses by CRNs. Not particularly efficient.\n        Returns None if not found.\n        \"\"\"\n        for name, course in self.courses.iteritems():\n            if crn in course:\n                return course\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the given course and all other courses that are crosslisted with the given partial.", "response": "def find_course_and_crosslistings(self, partial):\n        \"\"\"Returns the given course and all other courses it is\n        crosslisted with.\n        \"\"\"\n        course = self.find_course(partial)\n        crosslisted = self.crosslisted_with(course.crn)\n        return (course,) + tuple(map(self.find_course_by_crn, crosslisted))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to hash an arbitrary object for caching.", "response": "def cache_hash(*a, **kw):\n    \"\"\" Try to hash an arbitrary object for caching. \"\"\"\n\n    def cache_str(o):\n        if isinstance(o, (types.FunctionType, types.BuiltinFunctionType,\n                          types.MethodType, types.BuiltinMethodType,\n                          types.UnboundMethodType)):\n            return getattr(o, 'func_name', 'func')\n        if isinstance(o, dict):\n            o = [k + ':' + cache_str(v) for k, v in o.items()]\n        if isinstance(o, (list, tuple, set)):\n            o = sorted(map(cache_str, o))\n            o = '|'.join(o)\n        if isinstance(o, basestring):\n            return o\n        if hasattr(o, 'updated_at'):\n            return cache_str((repr(o), o.updated_at))\n        return repr(o)\n\n    hash = cache_str((a, kw)).encode('utf-8')\n    return sha1(hash).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef python_mime(fn):\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "response": "Decorator which adds correct MIME type for python source to the bottle API function."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string that can be used to generate the Brython settings. py file.", "response": "def settings_api():\n    \"\"\"\n    Virtual ``settings.py`` with values transported from real\n    :mod:`settings.py`, so the Brython frontend may be configured same way as\n    backend.\n\n    Some of the critical values are intentionally left out.\n    \"\"\"\n    variables = [\n        \"%s = %s\" % (var, repr(getattr(settings, var)))\n        for var in sorted(dir(settings))\n        if (not var.startswith(\"_\") and var.upper() == var and\n            not var.startswith(\"SEEDER\"))  # hide the private tokens and url\n    ]\n\n    return PY_HEADER + \"\\n\\n\".join(variables)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_as_file(fn, data=None):\n    if data is None:\n        raise HTTPError(500, \"This service require POST `data` parameter.\")\n\n    response.set_header(\"Content-Type\", \"application/octet-stream\")\n    response.set_header(\n        \"Content-Disposition\",\n        'attachment; filename=\"%s\"' % fn\n    )\n\n    return StringIO(data)", "response": "Download given data as file fn. This service exists to allow frontend\n    present user with downloadable files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge_dicts(*dicts, **kwargs):\n    result = {}\n    for d in dicts:\n        result.update(d)\n    result.update(kwargs)\n    return result", "response": "Merges dicts and kwargs into one dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_qs(qs):\n    result = {}\n    qs = bstr(qs, 'latin1')\n    pairs = [s2 for s1 in qs.split(b'&') for s2 in s1.split(b';')]\n    uq = urlparse.unquote if PY2 else urlparse.unquote_to_bytes\n    for name_value in pairs:\n        if not name_value:\n            continue\n        nv = name_value.split(b'=', 1)\n        if len(nv) != 2:\n            nv.append(b'')\n\n        name = nv[0].replace(b'+', b' ')\n        name = uq(name)\n        if not PY2:  # pragma: no cover py2\n            name = ustr(name, 'latin1')\n        value = nv[1].replace(b'+', b' ')\n        value = uq(value)\n        result.setdefault(name, []).append(value)\n    return result", "response": "Helper func to parse a query string with py2 and py3 compatibility\n    Ensures that keys are native strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclones object with optionally overridden fields", "response": "def clone(src, **kwargs):\n    \"\"\"Clones object with optionally overridden fields\"\"\"\n    obj = object.__new__(type(src))\n    obj.__dict__.update(src.__dict__)\n    obj.__dict__.update(kwargs)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string of appropriate escape - codes for the given combination.", "response": "def codify(combination):\n\n\t\"\"\"\n\tGets escape-codes for flag combinations.\n\n\tArguments:\n\t\tcombination (int): Either a single integer-convertible flag\n\t\t\t\t\t\t   or an OR'd flag-combination.\n\tReturns:\n\t\tA semi-colon-delimited string of appropriate escape sequences.\n\n\tRaises:\n\t\terrors.FlagError if the combination is out-of-range.\n\t\"\"\"\n\n\tif (isinstance(combination, int) and\n\t\t(combination < 0 or combination >= LIMIT)):\n\t\traise errors.FlagError(\"Out-of-range flag-combination!\")\n\n\tcodes = []\n\n\tfor enum in (Style, Color, Fill):\n\t\tfor flag in enum:\n\t\t\tif combination & flag:\n\t\t\t\tcodes.append(str(flag))\n\n\treturn \";\".join(codes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_ints(version):\n\n        # Example strings: \"NSS_3_7_9_RTM\", \"NSS_3_6_BRANCH_20021026\", \"NSS_3_6_BETA2\",\n        #                  \"3.18 Basic ECC Beta\", \"3.16.5 Basic ECC\"\n\n        # normalize version strings\n        norm_version = version.replace('NSS_', '').replace('.', '_').replace(' ', '_').upper().split('_')\n\n        # Asserting minimumum length of 3 as in [major,minor,tag]\n        assert len(norm_version) >= 3\n\n        # Asserting the first two fields are numeric major and minor\n        assert norm_version[0].isdigit() and norm_version[1].isdigit()\n\n        # Asserting last field is always a non-numeric tag or a date tag\n        # CAVE: fails with obscure date dags like certdata.txt-NSS_3_4_20020403_2\n        assert not norm_version[-1].isdigit() or len(norm_version[-1]) > 2\n\n        # fill in missing point and pointpoint versions\n        if not (norm_version[2].isdigit() and len(norm_version[2]) < 4):  # <4 to distinguish from numeric date tags\n            norm_version.insert(2, \"0\")\n        if not (norm_version[3].isdigit() and len(norm_version[3]) < 4):\n            norm_version.insert(3, \"0\")\n\n        # Strictly ordering by RTM > RC > BETA > *\n        # CAVE: Order rule may result in bogus sorting of obscure tags (WITH_CBKI*, TPATCH*, BRANCHPOINT*, ...)\n        # Recent versions are tagged non-obscurely and consistently\n\n        tag_value = 0\n        for v in norm_version[4:]:\n            if v.startswith('BETA'):\n                tag_value = 100\n                if len(v[4:]) == 1 or len(v[4:]) == 2:\n                    try:\n                        tag_value += int(v[4:])\n                    except ValueError:\n                        pass\n        for v in norm_version[4:]:\n            if v.startswith('RC'):\n                tag_value = 200\n                if len(v[3:]) == 1 or len(v[3:]) == 2:\n                    try:\n                        tag_value += int(v[3:])\n                    except ValueError:\n                        pass\n        for v in norm_version[4:]:\n            if v == 'RTM':\n                tag_value = 300\n\n        # Special case: \"x.y.z Basic ECC\" is counted as RTM\n        # TODO: research the set of potential version string formats reported by libnss.\n        if norm_version[-2] == 'BASIC' and norm_version[-1] == 'ECC' and norm_version[-3].isdigit():\n            tag_value = 300\n\n        major, minor, point, pointpoint = (int(x) for x in norm_version[:4])\n\n        return [major, minor, point, pointpoint, tag_value]", "response": "Converts a NSS version string into a list of integers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef first_older_than_second(version_a, version_b):\n\n        a = nssversion.to_ints(version_a)\n        b = nssversion.to_ints(version_b)\n\n        # must be of equal length\n        assert len(a) == len(b)\n\n        # Compare each version component, bail out on difference\n        for i in xrange(len(a)):\n            if b[i] < a[i]:\n                return False\n            if b[i] > a[i]:\n                return True\n        return False", "response": "Test if the first NSS version string in the first parameter being less than the second."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef most_recent_among(versions):\n        latest = versions[0]\n        for v in versions[1:]:\n            if nssversion.first_older_than_second(latest, v):\n                latest = v\n        return latest", "response": "Returns the most recent version of a set of NSS versions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntests if NSS version is correct.", "response": "def run(cls, version=None):\n        \"\"\"\n        Test runner method; is called by parent class defined in suite.py.\n        :param version: B2G version string to test against\n        :return: bool PASS/FAIL status\n        \"\"\"\n\n        try:\n            dumper = certdump()\n            versions = dumper.nssversion_via_marionette()\n        except Exception as e:  # TODO: too broad exception\n            cls.log_status('FAIL', 'Failed to gather information from the device via Marionette: %s' % e)\n            return False\n\n        if version is None:\n            cls.log_status('FAIL', 'NSS version check requires a B2G version.\\nReported component versions:\\n%s' % (\n                '\\n'.join([\"%s: %s\" % (k, versions[k]) for k in versions])))\n            return False\n\n        reported_version = versions['NSS_Version']\n\n        if version not in nssversion.b2g_version_to_hginfo:\n            cls.log_status('FAIL', 'No version comparison data for B2G %s.\\nReported NSS component versions:\\n%s' % (\n                version, '\\n'.join([\"%s: %s\" % (k, versions[k]) for k in versions])))\n            return False\n\n        expected_version = nssversion.b2g_version_to_hginfo[version]['release_nss_version']\n\n        # Fail if reported version is a downgrade\n        if nssversion.first_older_than_second(reported_version, expected_version):\n            cls.log_status('FAIL', 'NSS downgrade detected. Expecting at least version %s.\\n'\n                           'Reported versions:\\n%s' % (\n                           expected_version, '\\n'.join([\"%s: %s\" % (k, versions[k]) for k in versions])))\n            return False\n\n        # Pass if NSS version was upgraded.\n        if nssversion.first_older_than_second(expected_version, reported_version):\n            cls.log_status('PASS', 'NSS more recent than release version %s. Reported component versions:\\n%s' % (\n                expected_version, '\\n'.join([\"%s: %s\" % (k, versions[k]) for k in versions])))\n            return True\n\n        # Else device has reported the expected version.\n        cls.log_status('PASS', 'NSS version reported as expected. Reported component versions:\\n%s' % (\n            '\\n'.join([\"%s: %s\" % (k, versions[k]) for k in versions])))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nraise an exception if a and b are not of the same type.", "response": "def assertSameType(a, b):\n    \"\"\"\n    Raises an exception if @b is not an instance of type(@a)\n    \"\"\"\n    if not isinstance(b, type(a)):\n        raise NotImplementedError(\"This operation is only supported for \" \\\n            \"elements of the same type. Instead found {} and {}\".\n                format(type(a), type(b)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assertType(var, *allowedTypes):\n    if not isinstance(var, *allowedTypes):\n        raise NotImplementedError(\"This operation is only supported for {}. \"\\\n            \"Instead found {}\".format(str(*allowedTypes), type(var)))", "response": "Assert that a variable is of a given type. Raises a TypeError if the assertion fails."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dp(**kwargs):\n    for label,value in kwargs.iteritems():\n            print \"{0}\\t{1}\".format(label, value)", "response": "Debugging print. Prints a list of labels and values each on their\n    own line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hmac(key, message, tag=None, alg=hashlib.sha256):\n    return HMAC.new(str(key), str(tag) + str(message), digestmod=alg).digest()", "response": "Generates a hashed message authentication code using a cryptographic key and a hashing algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef minmax(low, high):\n    def decorator(function):\n        \"\"\"Decorate a function with args.\"\"\"\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"Wrap the function.\"\"\"\n            series = function(*args, **kwargs)\n            lo_pass = low <= series\n            hi_pass = series <= high\n\n            return lo_pass & hi_pass\n\n        return wrapper\n\n    return decorator", "response": "Decorator that tests that the data items fall within range low and high."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests that the data items are members of the set `choices`.", "response": "def choice(choices):\n    \"\"\"Test that the data items are members of the set `choices`.\"\"\"\n    def decorator(function):\n        \"\"\"Decorate a function with args.\"\"\"\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"Wrap the function.\"\"\"\n            series = function(*args, **kwargs)\n            return series.isin(set(choices))\n\n        return wrapper\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bounded_length(low, high=None):\n    def decorator(function):\n        \"\"\"Decorate a function with args.\"\"\"\n        @functools.wraps(function)\n        def wrapper(*args, **kwargs):\n            \"\"\"Wrap the function.\"\"\"\n            series = function(*args, **kwargs)\n            if high is None:\n                return series.apply(lambda x: len(x) == low)\n            else:\n                lo_pass = series.apply(lambda x: low <= len(x))\n                hi_pass = series.apply(lambda x: len(x) <= high)\n\n                return lo_pass & hi_pass\n\n        return wrapper\n\n    return decorator", "response": "Decorator that returns a function that returns True if the length of the data items fall within range low < = x < high."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild view documentation. Return in markdown format.", "response": "def get_view_doc(view, html=True):\n    \"\"\"\n    Build view documentation. Return in html format.\n    If you want in markdown format, use html=False\n    \"\"\"\n    try:\n        description = view.__doc__ or ''\n        description = formatting.dedent(smart_text(description))\n\n        # include filters in description\n        filter_fields = get_filter_fields(view)\n        if filter_fields:\n            filter_doc = ['\\n\\n\\n## Filters', '']\n            for f in filter_fields:\n                filter_doc.append('- `%s`' % f)\n            description += '\\n'.join(filter_doc)\n\n        # replace {api_url} by current base url\n        api_url = \"/api\"\n        description = description.replace('{api_url}', api_url)\n        if html:\n            description = formatting.markup_description(description)\n        return description\n    except:\n        import traceback\n        traceback.print_exc()\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wrap_accordion(text_body_list):\n    html = ['<div class=\"accordion\" id=\"accordion2\">']\n\n    for i, item in enumerate(text_body_list):\n        params = {\n            'index': i,\n            'title': item[0],\n            'body': item[1]\n        }\n\n        html.append('''\n<div class=\"accordion-group\">\n    <div class=\"accordion-heading\">\n      <a class=\"accordion-toggle\" data-toggle=\"collapse\" data-parent=\"#accordion2\" href=\"#collapse%(index)d\">\n        %(title)s\n      </a>\n    </div>\n    <div id=\"collapse%(index)d\" class=\"accordion-body collapse\">\n      <div class=\"accordion-inner\">\n        %(body)s\n      </div>\n    </div>\n  </div>\n  <br/>\n''' % params)\n    return mark_safe('\\n'.join(html))", "response": "Wrap text_body_list in twitter bootstrap accordion."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a command in the", "response": "def run(cmd, *, args='', timeout=600):\n    \"\"\"\n    Execute a process\n\n    :param cmd(str): name of the executable\n    :param args(str, optional): arbitrary arguments\n    :param timeout(int, optional): Execution timeout\n    :raises OSError: if the execution of cmd fails\n    \"\"\"\n\n    # type checks\n    utils.chkstr(cmd, 'cmd')\n    utils.chkstr(args, 'args')\n\n    # execute the command\n    r = envoy.run(\"{cmd} {args}\".format(cmd=cmd, args=args), timeout=timeout)\n    # log stdout\n    log.msg_debug(\"{cmd} > {stdout}\".format(cmd=cmd, stdout=r.std_out.strip()))\n\n    # In this way, we will know what went wrong on execution\n    if r.status_code:\n        log.msg_err(\"{cmd} > {stderr}\".format(cmd=cmd,\n                                              stderr=r.std_err.strip()))\n        raise OSError(\"[{cmd}] execution failed!\".format(cmd=cmd))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef referenceable(method):\n\n    def wrapper(self, value, *args):\n        deref = self._prepare(value)\n        if deref is not None:\n            return deref\n        packer, data = method(self, value, *args)\n        return self._preserve(value, packer, data)\n\n    return wrapper", "response": "Decorator to make a value referenceable in a base - serializer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delayed_unpacking(self, container, fun, *args, **kwargs):\n        try:\n            self._delayed += 1\n            blob = self._begin()\n            try:\n                fun(*args, **kwargs)\n                self._commit(blob)\n                return container\n            except DelayPacking:\n                self._rollback(blob)\n                continuation = (fun, args, kwargs)\n                self._pending.append(continuation)\n                return container\n        finally:\n            self._delayed -= 1", "response": "Should be used when unpacking mutable values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack an unordered list of values taking DelayPacking exceptions into account to resolve circular references.", "response": "def unpack_unordered_values(self, values):\n        \"\"\"Unpack an unordered list of values taking DelayPacking\n        exceptions into account to resolve circular references .\n        Used to unpack set values when order is not guaranteed by\n        the serializer. See unpack_unordered_pairs().\"\"\"\n\n        values = list(values) # To support iterators\n        result = []\n\n        # Try to unpack values more than one time to resolve cross references\n        max_loop = 2\n        while values and max_loop:\n            next_values = []\n            for value_data in values:\n                blob = self._begin()\n                try:\n                    # try unpacking the value\n                    value = self.unpack_data(value_data)\n                    self._commit(blob)\n                except DelayPacking:\n                    self._rollback(blob)\n                    # If it is delayed keep it for later\n                    next_values.append(value_data)\n                    continue\n                result.append(value)\n            values = next_values\n            max_loop -= 1\n\n        if values:\n            # Not all items were resolved\n            raise DelayPacking()\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unpack_unordered_pairs(self, pairs):\n\n        items = [(False, k, v) for k, v in pairs]\n        result = []\n\n        # Try to unpack items more than one time to resolve cross references\n        max_loop = 2\n        while items and max_loop:\n            next_items = []\n            for key_unpacked, key_data, value_data in items:\n                if key_unpacked:\n                    key = key_data\n                else:\n                    blob = self._begin()\n                    try:\n                        # Try unpacking the key\n                        key = self.unpack_data(key_data)\n                        self._commit(blob)\n                    except DelayPacking:\n                        self._rollback(blob)\n                        # If it is delayed keep it for later\n                        next_items.append((False, key_data, value_data))\n                        continue\n\n                blob = self._begin()\n                try:\n                    # try unpacking the value\n                    value = self.unpack_data(value_data)\n                    self._commit(blob)\n                except DelayPacking:\n                    self._rollback(blob)\n                    # If it is delayed keep it for later\n                    next_items.append((True, key, value_data))\n                    continue\n\n                # Update the container with the unpacked value and key\n                result.append((key, value))\n            items = next_items\n            max_loop -= 1\n\n        if items:\n            # Not all items were resolved\n            raise DelayPacking()\n\n        return result", "response": "Unpack an unordered list of value pairs taking DelayPacking\nErrorCode exceptions into account to resolve circular references."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef NodeDriver_wait_until_running(self, node, wait_period=3, timeout=600,\n                                  ssh_interface='public_ips', force_ipv4=True):\n    \"\"\"\n    Block until node is fully booted and has an IP address assigned.\n\n    @keyword    node: Node instance.\n    @type       node: C{Node}\n\n    @keyword    wait_period: How many seconds to between each loop\n                             iteration (default is 3)\n    @type       wait_period: C{int}\n\n    @keyword    timeout: How many seconds to wait before timing out\n                         (default is 600)\n    @type       timeout: C{int}\n\n    @keyword    ssh_interface: The interface to wait for\n                               (default is 'public_ips')\n    @type       ssh_interface: C{str}\n\n    @keyword    force_ipv4: Ignore ipv6 IP addresses (default is True)\n    @type       force_ipv4: C{bool}\n\n    @return: C{(Node, ip_addresses)} tuple of Node instance and\n             list of ip_address on success.\n    \"\"\"\n    start = time.time()\n    end = start + timeout\n\n    def is_supported(address):\n        \"\"\"Return True for supported address\"\"\"\n        if force_ipv4 and not len(address.split('.')) == 4:\n            return False\n        return True\n\n    def filter_addresses(addresses):\n        \"\"\"Return list of supported addresses\"\"\"\n        return [a for a in addresses if is_supported(a)]\n\n    while time.time() < end:\n        nodes = [n for n in self.list_nodes() if n.uuid == node.uuid]\n\n        if len(nodes) > 1:\n            raise LibcloudError(value=('Booted single node[%s], ' % node\n                                + 'but multiple nodes have same UUID'),\n                                driver=self)\n        if len(nodes) == 1:\n            print nodes[0].state, getattr(nodes[0], ssh_interface)\n\n        if len(nodes) == 1 and filter_addresses(getattr(nodes[0], ssh_interface)) \\\n                and nodes[0].state == NodeState.RUNNING:\n            return nodes[0], filter_addresses(getattr(nodes[0], ssh_interface))\n        else:\n            time.sleep(wait_period)\n            continue\n\n    raise LibcloudError(value='Timed out after %s seconds' % (timeout),\n                        driver=self)", "response": "Block until node is fully booted and has an IP address assigned."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading the file to the server and returns the node object.", "response": "def run(self, node, client):\n        \"\"\"\n        Upload the file, retaining permissions\n\n        See also L{Deployment.run}\n        \"\"\"\n        perms = os.stat(self.source).st_mode\n        client.put(path=self.target, chmod=perms,\n                   contents=open(self.source, 'rb').read())\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(api_key, token, board_id):\n    trello_client = TrelloClient(\n        api_key=api_key,\n        token=token,\n    )\n    board = Board(client=trello_client, board_id=board_id)\n    print('Lists')\n    print('-----')\n    print('Name: Id')\n    for card_list in board.all_lists():\n        print('{card_list.name}: {card_list.id}'.format(card_list=card_list))", "response": "List out the board lists for our client"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attachedimage_form_factory(lang='en', debug=False):\n    ''' Returns ModelForm class to be used in admin.\n        'lang' is the language for GearsUploader (can be 'en' and 'ru' at the\n        moment).\n    '''\n    yui = '' if debug else '.yui'\n    class _AttachedImageAdminForm(forms.ModelForm):\n\n        caption = forms.CharField(label=_('Caption'), required=False)\n\n        class Media:\n            js = [\n                  'generic_images/js/mootools-1.2.4-core-yc.js',\n                  'generic_images/js/GearsUploader.%s%s.js' % (lang, yui,),\n                  'generic_images/js/AttachedImageInline.js',\n            ]\n\n        class Meta:\n            model = AttachedImage\n    return _AttachedImageAdminForm", "response": "Returns a factory for creating an attached image admin form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning InlineModelAdmin for attached images.", "response": "def attachedimages_inline_factory(lang='en', max_width='', debug=False):\n    '''  Returns InlineModelAdmin for attached images.\n        'lang' is the language for GearsUploader (can be 'en' and 'ru' at the\n        moment). 'max_width' is default resize width parameter to be set in\n        widget.\n    '''\n\n    class _AttachedImagesInline(GenericTabularInline):\n        model = AttachedImage\n        form = attachedimage_form_factory(lang, debug)\n        template = 'generic_images/attached_images_inline.html'\n        max_w = max_width\n\n    return _AttachedImagesInline"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a key s value s in a JSON file.", "response": "def update(self, data, key):\n        \"\"\"Update a key's value's in a JSON file.\"\"\"\n        og_data = self.read()\n        og_data[key] = data\n        self.write(og_data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate bytes from properties", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the next header type\n        bitstream = BitStream('uint:8=%d' % self.next_header)\n\n        # Write the header length\n        header_length_unpadded = len(self.options) + 2\n        header_length = math.ceil(header_length_unpadded / 8.0)\n        bitstream += BitStream('uint:8=%d' % (header_length - 1))\n\n        # Add the options\n        bitstream += BitStream(bytes=self.options)\n        padding_len = (8 - (header_length_unpadded % 8)) % 8\n        bitstream += BitStream(padding_len * 8)\n\n        return bitstream.bytes + bytes(self.payload)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef no_overlap(multienum):\n    duplicates = []\n    members = []\n\n    for member in multienum.__members__.values():\n        for prev_member in members:\n            intersection = set(member._value_) & set(prev_member._value_)\n            if intersection:\n                duplicates.append((member._name_, prev_member._name_, intersection))\n        members.append(member)\n\n    if duplicates:\n        alias_details = ', '.join([\"{} & {} -> {}\".format(alias, name, intersection)\n                                  for (alias, name, intersection) in duplicates])\n        raise ValueError('common element found in {!r}: {}'\n                         .format(multienum, alias_details))\n    return multienum", "response": "Class decorator for MultiValueEnum ensuring non overlapping elements\n    in member values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_results(self, results):\n        '''\n        results schema: {'sequence': 1, 'season': 2018, 'games': [{\n            \"home\": \"HOME\",\n            \"away\": \"AWAY\",\n            \"home_score\": 15,\n            \"away_score\": 10,\n            \"status\": \"Final\",\n            \"winner\": \"HOME\",\n        }]}\n        '''\n\n        if not results:\n            raise PickerResultException('Results unavailable')\n\n        if results['sequence'] != self.sequence or results['season'] != self.season:\n            raise PickerResultException('Results not updated, wrong season or week')\n\n        completed = {g['home']: g for g in results['games'] if g['status'].startswith('F')}\n        if not completed:\n            return (0, None)\n\n        count = 0\n        for game in self.games.incomplete(home__abbr__in=completed.keys()):\n            result = completed.get(game.home.abbr, None)\n            if result:\n                winner = result['winner']\n                game.winner = (\n                    game.home if game.home.abbr == winner\n                    else game.away if game.away.abbr == winner else None\n                )\n                count += 1\n\n        last_game = self.last_game\n        if not self.points and last_game.winner:\n            now = datetime_now()\n            if now > last_game.end_time:\n                result = completed.get(last_game.home.abbr, None)\n                if result:\n                    self.points = result['home_score'] + result['away_score']\n                    self.save()\n\n        if count:\n            self.update_pick_status()\n\n        return (count, self.points)", "response": "Update the results of a pick."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the picks of the pickset with the given games and points.", "response": "def update_picks(self, games=None, points=None):\n        '''\n        games can be dict of {game.id: winner_id} for all picked games to update\n        '''\n        if games:\n            game_dict = {g.id: g for g in self.gameset.games.filter(id__in=games)}\n            game_picks = {pick.game.id: pick for pick in self.gamepicks.filter(game__id__in=games)}\n            for key, winner in games.items():\n                game = game_dict[key]\n                if not game.has_started:\n                    pick = game_picks[key]\n                    pick.winner_id = winner\n                    pick.save()\n\n        if points is not None:\n            self.points = points\n            self.save()\n\n        if games or points:\n            self.updated_signal.send(sender=self.__class__, pickset=self, auto_pick=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets input parameters for pore surface binary from zeo ++ output.", "response": "def get_pore_surface_parameters(surface_area):\n    \"\"\" Get input parameters for pore surface binary.\n\n    Get input parameters for pore_surface binary from zeo++ output,\n    while keeping data provenance.\n    \"\"\"\n    PoreSurfaceParameters = DataFactory('phtools.surface')\n    d = {\n        'accessible_surface_area': surface_area.get_dict()['ASA_A^2'],\n        'target_volume': 40e3,\n        'sampling_method': 'random',\n    }\n    return PoreSurfaceParameters(dict=d)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a RequestInfo object from the database or create a new one if not.", "response": "def get_cached_or_new(url, new=False):\n    \"\"\"\n    Look into the database and return :class:`RequestInfo` if the `url` was\n    already analyzed, or create and return new instance, if not.\n\n    If the `new` is set to True, always create new instance.\n\n    Args:\n        url (str): URL of the analyzed resource.\n        new (bool, default False): Force new instance?\n\n    Returns:\n        obj: :class:`RequestInfo` instance.\n    \"\"\"\n    garbage_collection()\n\n    old_req = DATABASE.get(url)\n\n    if old_req and not new:\n        return old_req\n\n    if not (url.startswith(\"http://\") or url.startswith(\"https://\")):\n        raise ValueError(\"Invalid URL `%s`!\" % url)\n\n    req = RequestInfo(url=url)\n    DATABASE[url] = req\n\n    return req"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef garbage_collection(time_limit=YEAR/12.0):\n    expired_request_infos = (\n        ri for ri in DATABASE.values()\n        if ri.creation_ts + time_limit <= time.time()\n    )\n\n    for ri in expired_request_infos:\n        del DATABASE[ri.url]", "response": "Collect and remove all expired request infos older than\n           . time_limit is in seconds."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef store_property(url, property_name, value):\n    logger.debug(\n        \"store_property(): Received property_name=%s value=%s\" % (\n            property_name,\n            value,\n        ),\n        url=url,\n    )\n\n    ri = get_cached_or_new(url)\n    ri._set_property(property_name, json.loads(value))\n\n    logger.info(\n        \"store_property(): property_name=%s saved.\" % (\n            property_name,\n        ),\n        url=url,\n    )", "response": "Store a value under property_name under url."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a datetime. timedelta to an integral number of minutes.", "response": "def timedelta_total_minutes(td, strict=False):\n    \"\"\" Convert/round a :cls:`timedelta` to an integral number of minutes.\n\n    If ``strict`` is true than raises :exc:`ValueError` if the\n    :cls:`~datetime.timedelta` is not a integral multiple of 60 seconds.\n\n    \"\"\"\n    minutes, seconds = divmod(td.days * 24 * 3600 + td.seconds, 60)\n    if seconds or td.microseconds:\n        if strict:\n            raise ValueError(\n                \"%r is not an integral multiple of 60 seconds\", td)\n        if seconds > 30 or (seconds == 30 and td.microseconds > 0):\n            minutes += 1\n    return minutes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving file. This is like :func:`os.remove` (or :func:`os.unlink`), except that no error is raised if the file does not exist.", "response": "def remove_if_exists(filename):\n    \"\"\" Remove file.\n\n    This is like :func:`os.remove` (or :func:`os.unlink`), except that no\n    error is raised if the file does not exist.\n\n    \"\"\"\n    try:\n        os.unlink(filename)\n    except OSError as ex:\n        if ex.errno != errno.ENOENT:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding restrictive robots.txt to prevent sites under *.herokuapp.com from being indexed.", "response": "def herokuapp_robots_view(request):\n    \"\"\"\n    Add restrictive robots.txt to prevent sites under *.herokuapp.com from being indexed.\n    \"\"\"\n\n    response_text = \"\"\n    http_host = request.get_host()\n\n    if http_host and 'herokuapp' in http_host:\n        response_text = \"User-agent: *\\nDisallow: /\"\n\n    return HttpResponse(response_text, content_type=\"text/plain\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntranslate the Aleph keywords to locally used data.", "response": "def _handle_aleph_keyword_view(dataset):\n        \"\"\"\n        Translate the Aleph keywords to locally used data.\n        \"\"\"\n        # redirect the keywords to Aleph view\n        adder = ViewController.aleph_kw_handler.add_keyword\n        for keyword in dataset.get(\"keyword_tags\", []):\n            adder(keyword[\"val\"])\n\n        if \"keyword_tags\" in dataset:\n            del dataset[\"keyword_tags\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(cls, ev=None):\n        ViewController.log_view.add(\"Beginning AlephReader request..\")\n\n        ViewController.issnbox_error.reset()\n        issn = ViewController.issn.strip()\n\n        # make sure, that `issn` was filled\n        if not issn:\n            ViewController.issnbox_error.show(\"ISSN nebylo vypln\u011bno!\")\n            ViewController.log_view.add(\"No ISSN! Aborting.\")\n            return\n\n        ViewController.issnbox_error.hide()\n        ViewController.issn_progressbar.reset()\n        ViewController.issn_progressbar.show(50)\n        ViewController.log_view.add(\"For ISSN `%s`.\" % issn)\n\n        make_request(\n            url=join(settings.API_PATH, \"aleph/records_by_issn\"),\n            data={'issn': issn},\n            on_complete=cls.on_complete\n        )", "response": "Start the AlephReader request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_complete(cls, req):\n        # handle http errors\n        if not (req.status == 200 or req.status == 0):\n            ViewController.log_view.add(req.text)\n            alert(req.text)  # TODO: better handling\n            return\n\n        try:\n            resp = json.loads(req.text)\n        except ValueError:\n            resp = None\n\n        if not resp:\n            alert(\"Chyba p\u0159i konverzi!\")  # TODO: better\n            ViewController.log_view.add(\n                \"Error while generating MARC: %s\" % resp.text\n            )\n            return\n\n        OutputPicker.show(resp)", "response": "Callback called when the request to REST is done. Handles the errors\n            and displays the outputPicker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(cls, ev):\n        ev.preventDefault()\n        ev.stopPropagation()\n\n        ViewController.log_view.add(\"Beginning MARCGenerator request..\")\n\n        if not ViewController.validate():\n            ViewController.urlbox_error.show(\n                \"Vypl\u0148te pros\u00edm zv\u00fdrazn\u011bn\u00e9 hodnoty.\"\n            )\n            ViewController.log_view.add(\"Aborting. Not all required data set.\")\n            return\n\n        # make sure, that `url` was filled\n        url = ViewController.url.strip()\n        if not (url.startswith(\"http://\") or url.startswith(\"https://\")):\n            ViewController.urlbox_error.show(\n                \"`%s` nen\u00ed validn\u00ed URL! Zkuste p\u0159idat http:// | https://\" % url\n            )\n            return\n\n        properties = ViewController.get_all_properties()\n        properties[\"rules\"] = RulesViewController.get_dict()\n\n        # keep the url_id from hidden input\n        if \"url_id\" in document and document[\"url_id\"].value:\n            properties[\"url_id\"] = document[\"url_id\"].value\n\n        ViewController.log_view.add(\n            \"Sending following data: %s\" % repr(properties)\n        )\n\n        make_request(\n            url=join(settings.API_PATH, \"to_output\"),\n            data={\"data\": json.dumps(properties)},\n            on_complete=cls.on_complete\n        )", "response": "Read all data from Views and send them to the backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders a Python object to text using the repr function.", "response": "def make_repr_node(rawtext, app, prefixed_name, obj, parent, modname, options):\n    \"\"\"Render a Python object to text using the repr() function.\n\n    :param rawtext: Text being replaced with link node.\n    :param app: Sphinx application context\n    :param prefixed_name: The dotted Python name for obj.\n    :param obj: The Python object to be rendered to text.\n    :param parent: The parent Python object of obj.\n    :param module: The name of the module containing obj.\n    :param options: Options dictionary passed to role func.\n    \"\"\"\n    text = repr(obj)\n    node = nodes.Text(text, rawsource=rawtext)\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dsn():\n    configs = {'host': host,\n               'port': port,\n               'dbname': database,\n               'user': user,\n               'password': password}\n    return ' '.join(['{0}={1}'.format(_[0], _[1]) for _ in configs.items() if _[1] is not None and _[1] != ''])", "response": "Returns a libpq connection string using the variables defined in this file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the JSON library that should be used by specifying a module name or by providing a decode and encode functions.", "response": "def use(module=None, decode=None, encode=None):\n    \"\"\"Set the JSON library that should be used, either by specifying a known\n    module name, or by providing a decode and encode function.\n\n    The modules \"simplejson\", \"cjson\", and \"json\" are currently supported for\n    the ``module`` parameter.\n\n    If provided, the ``decode`` parameter must be a callable that accepts a\n    JSON string and returns a corresponding Python data structure. The\n    ``encode`` callable must accept a Python data structure and return the\n    corresponding JSON string. Exceptions raised by decoding and encoding\n    should be propagated up unaltered.\n\n    @param module: the name of the JSON library module to use, or the module\n                   object itself\n    @type module:  str or module\n    @param decode: a function for decoding JSON strings\n    @type decode:  callable\n    @param encode: a function for encoding objects as JSON strings\n    @type encode:  callable\n    \"\"\"\n    global _decode, _encode, _initialized, _using\n    if module is not None:\n        if not isinstance(module, basestring):\n            module = module.__name__\n        if module not in ('cjson', 'json', 'simplejson'):\n            raise ValueError('Unsupported JSON module %s' % module)\n        _using = module\n        _initialized = False\n    else:\n        assert decode is not None and encode is not None\n        _using = 'custom'\n        _decode = decode\n        _encode = encode\n        _initialized = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_source(model):\n    ignored_keys = {\"author_tags\", \"original_xml\", \"additional_info\"}\n\n    # convert all values to source strings\n    source = \"Aleph\"\n    for key, val in model.get_mapping().iteritems():\n        if key in ignored_keys:\n            continue\n\n        if type(val) in [list, tuple]:\n            ss_val = [\n                SourceString(item, source).to_dict()\n                for item in val\n            ]\n        else:\n            ss_val = [SourceString(val, source).to_dict()]\n\n        setattr(model, key, ss_val)\n\n    return model", "response": "Add source strings to the given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries aleph for records with given ISSN.", "response": "def by_issn(issn):\n    \"\"\"\n    Query aleph for records with given `issn`. The lookup is directed to the\n    NTK's Aleph.\n\n    Args:\n        issn (str): ISSN of the periodical.\n\n    Returns:\n        obj: :class:`Model` instances for each record.\n    \"\"\"\n    # monkeypatched to allow search in NTK's Aleph\n    old_url = aleph.ALEPH_URL\n    aleph.ALEPH_URL = NTK_ALEPH_URL\n    records = aleph.getISSNsXML(issn, base=\"STK02\")\n    aleph.ALEPH_URL = old_url\n\n    # process all records\n    for record in records:\n        marc = MARCXMLRecord(record)\n\n        # following values were requested by @bjackova in\n        # https://github.com/WebArchivCZ/WA-KAT/issues/66\n        additional_info = {\n            \"222\": marc.get(\"222\", None),\n            \"PER\": marc.get(\"PER\", None),\n            \"776\": marc.get(\"776\", None),\n            \"008\": marc.get(\"008\", None),\n            \"alt_end_date\": \"\"  # just reminder that it is filled later\n        }\n        additional_info = {\n            key: val\n            for key, val in additional_info.iteritems()\n            if val\n        }\n\n        # check whether there is alternative date in 008\n        alt_end_date = None\n        alt_creation_date = None\n        if additional_info[\"008\"]:\n            # 131114c20139999xr-q||p|s||||||---a0eng-c -> 2013\n            alt_creation_date = additional_info[\"008\"][7:11]\n\n            # 131114c20139999xr-q||p|s||||||---a0eng-c -> 9999\n            alt_end_date = additional_info[\"008\"][11:15]\n            if alt_end_date in [\"9999\", \"****\"]:\n                alt_creation_date += \"-\"  # library convention is xxxx-\n                alt_end_date = None\n\n            additional_info[\"alt_end_date\"] = alt_end_date\n\n        # parse author\n        author = Author.parse_author(marc)\n\n        model = Model(\n            url=_first_or_none(\n                marc.get(\"856u\")\n            ),\n            conspect=_first_or_none(\n                marc.get(\"072a\")\n            ),\n            annotation_tags=_first_or_none(\n                marc.get(\"520a\")\n            ),\n            periodicity=_first_or_none(\n                marc.get(\"310a\")\n            ),\n            title_tags=_first_or_none(\n                marc.get(\"222a\")\n            ),\n            subtitle_tags=_first_or_none(\n                marc.get(\"245b\")\n            ),\n            place_tags=remove_hairs(\n                _first_or_none(marc.get(\"260a\")) or \"\"\n            ),\n            author_tags=author._asdict() if author else None,\n            publisher_tags=remove_hairs(\n                (\n                    _first_or_none(marc.get(\"260b\")) or\n                    _first_or_none(marc.get(\"264b\")) or\n                    \"\",\n                ),\n                \", \"\n            ),\n            creation_dates=_first_or_none(\n                marc.get(\"260c\", [alt_creation_date])\n            ),\n            lang_tags=_first_or_none(\n                marc.get(\"040b\")\n            ),\n            keyword_tags=marc.get(\"650a07\"),\n            source_info=_first_or_none(\n                marc.get(\"500a\")\n            ),\n            original_xml=record,\n            additional_info=additional_info,\n        )\n\n        yield _add_source(model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses author from MARC XML data.", "response": "def parse_author(cls, marc):\n        \"\"\"\n        Parse author from `marc` data.\n\n        Args:\n            marc (obj): :class:`.MARCXMLRecord` instance. See module\n                :mod:`.marcxml_parser` for details.\n\n        Returns:\n            obj: :class:`Author`.\n        \"\"\"\n        name = None\n        code = None\n        linked_forms = None\n        is_corporation = None\n        record = None\n\n        # parse informations from the record\n        if marc[\"100a\"]:  # persons\n            name = _first_or_none(marc[\"100a\"])\n            code = _first_or_none(marc[\"1007\"])\n            is_corporation = False\n            record = marc.datafields[\"100\"][0]  # transport all fields\n        elif marc[\"110a\"]:  # corporations\n            name = _first_or_none(marc[\"110a\"])\n            code = _first_or_none(marc[\"1107\"])\n            linked_forms = marc[\"410a2 \"]\n            is_corporation = True\n            record = marc.datafields[\"110\"][0]  # transport all fields\n        else:\n            return None\n\n        # parse linked forms (alternative names)\n        linked_forms = marc[\"410a2 \"]\n\n        # put together alt_name\n        type_descriptor = [\"osoba\", \"organizace\"]\n        alt_name = \"%s [%s]\" % (name, type_descriptor[is_corporation])\n        if linked_forms:\n            alt_name += \" (\" + \", \".join(linked_forms) + \")\"\n\n        return cls(\n            name=name,\n            code=code,\n            linked_forms=linked_forms,\n            is_corporation=is_corporation,\n            record=record,\n            alt_name=alt_name,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for author in NK Aleph authority base by name.", "response": "def search_by_name(cls, name):\n        \"\"\"\n        Look for author in NK Aleph authority base by `name`.\n\n        Args:\n            name (str): Author's name.\n\n        Yields:\n            obj: :class:`Author` instances.\n        \"\"\"\n        records = aleph.downloadRecords(\n            aleph.searchInAleph(\"aut\", name, False, \"wau\")\n        )\n\n        for record in records:\n            marc = MARCXMLRecord(record)\n\n            author = cls.parse_author(marc)\n\n            if author:\n                yield author"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the object from the sensor and return the object in the CM.", "response": "def read(sensor):\n    \"\"\"\n    distance of object in front of sensor in CM.\n    \"\"\"\n    import time\n    import RPi.GPIO as GPIO\n    \n    # Disable any warning message such as GPIO pins in use\n    GPIO.setwarnings(False)\n    \n    # use the values of the GPIO pins, and not the actual pin number\n    # so if you connect to GPIO 25 which is on pin number 22, the \n    # reference in this code is 25, which is the number of the GPIO \n    # port and not the number of the physical pin\n    GPIO.setmode(GPIO.BCM)\n    \n    if sensor.gpio_in is 0:\n        raise RuntimeError('gpio_in, gpio_out attribute of Sensor object must be assigned before calling read')\n    else:\n        gpio_in = sensor.gpio_in\n        gpio_out = sensor.gpio_out\n\n        # point the software to the GPIO pins the sensor is using\n        # change these values to the pins you are using\n        # GPIO output = the pin that's connected to \"Trig\" on the sensor\n        # GPIO input = the pin that's connected to \"Echo\" on the sensor\n        GPIO.setup(gpio_out, GPIO.OUT)\n        GPIO.setup(gpio_in, GPIO.IN)\n        GPIO.output(gpio_out, GPIO.LOW)\n        \n        # found that the sensor can crash if there isn't a delay here\n        # no idea why. If you have odd crashing issues, increase delay\n        time.sleep(0.3)\n        \n        # sensor manual says a pulse ength of 10Us will trigger the \n        # sensor to transmit 8 cycles of ultrasonic burst at 40kHz and \n        # wait for the reflected ultrasonic burst to be received\n        \n        # to get a pulse length of 10Us we need to start the pulse, then\n        # wait for 10 microseconds, then stop the pulse. This will \n        # result in the pulse length being 10Us.\n        \n        # start the pulse on the GPIO pin \n        # change this value to the pin you are using\n        # GPIO output = the pin that's connected to \"Trig\" on the sensor\n        GPIO.output(gpio_out, True)\n        \n        # wait 10 micro seconds (this is 0.00001 seconds) so the pulse\n        # length is 10Us as the sensor expects\n        time.sleep(0.00001)\n        \n        # stop the pulse after the time above has passed\n        # change this value to the pin you are using\n        # GPIO output = the pin that's connected to \"Trig\" on the sensor\n        GPIO.output(gpio_out, False)\n\n        # listen to the input pin. 0 means nothing is happening. Once a\n        # signal is received the value will be 1 so the while loop\n        # stops and has the last recorded time the signal was 0\n        # change this value to the pin you are using\n        # GPIO input = the pin that's connected to \"Echo\" on the sensor\n        while GPIO.input(gpio_in) == 0:\n          signaloff = time.time()\n        \n        # listen to the input pin. Once a signal is received, record the\n        # time the signal came through\n        # change this value to the pin you are using\n        # GPIO input = the pin that's connected to \"Echo\" on the sensor\n        while GPIO.input(gpio_in) == 1:\n          signalon = time.time()\n        \n        # work out the difference in the two recorded times above to \n        # calculate the distance of an object in front of the sensor\n        timepassed = signalon - signaloff\n        \n        # we now have our distance but it's not in a useful unit of\n        # measurement. So now we convert this distance into centimetres\n        distance = timepassed * 17000\n\n        # we're no longer using the GPIO, so tell software we're done\n        GPIO.cleanup()\n\n        return distance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_data(files, folder):\n    if not os.path.exists(folder):\n        _log(\"Creating new folder %s\" % (folder))\n        os.makedirs(folder)\n\n    all_skip = True\n    for f in files:\n        url, md5 = files[f]\n        fullpath = pjoin(folder, f)\n        if os.path.exists(fullpath) and (_get_file_md5(fullpath) == md5):\n            continue\n        all_skip = False\n        _log('Downloading \"%s\" to %s' % (f, folder))\n        _get_file_data(fullpath, url)\n        if _get_file_md5(fullpath) != md5:\n            msg = \"\"\"The downloaded file, %s, does not have the expected md5\nchecksum of \"%s\". This could mean that that something is wrong with the file or\nthat the upstream file has been updated.\"\"\" % (fullpath, md5)\n            msg = textwrap.fill(msg)\n            raise FetcherError(msg)\n\n    if all_skip:\n        _log(\"All files already in %s.\" % (folder))\n    else:\n        _log(\"Files successfully downloaded to %s\" % (folder))", "response": "Downloads and saves the files to the specified folder and checks their md5 checksums."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the md5 checksum of a file", "response": "def _get_file_md5(filename):\n    \"\"\"Compute the md5 checksum of a file\"\"\"\n    md5_data = md5()\n    with open(filename, 'rb') as f:\n        for chunk in iter(lambda: f.read(128*md5_data.block_size), b''):\n            md5_data.update(chunk)\n    return md5_data.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_md5(filename, stored_md5):\n    computed_md5 = _get_file_md5(filename)\n    if stored_md5 != computed_md5:\n        print (\"MD5 checksum of filename\", filename,\n               \"failed. Expected MD5 was\", stored_md5,\n               \"but computed MD5 was\", computed_md5, '\\n',\n               \"Please check if the data has been downloaded correctly or if the upstream data has changed.\")", "response": "Checks if the md5 of a file matches the supplied md5."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch_from_sdr(folder=data_folder, data='test'):\n    url = \"https://stacks.stanford.edu/file/druid:fn662rv4961/\"\n\n    if data == 'test':\n        md5_dict = {'5182_1_1.nii.gz': '0656e59818538baa7d45311f2581bb4e',\n                '5182_15_1.nii.gz': 'a5a307b581620184baf868cd0df81f89',\n                'data.mat': 'a6275698f2220c65994354d412e6d82e',\n                'pure_gaba_P64024.nii.gz': 'f3e09ec0f00bd9a03910b19bfe731afb'}\n\n    elif data == 'example':\n        md5_dict = {'12_1_PROBE_MEGA_L_Occ.nii.gz':\n                    'a0571606c1caa16a9d9b00847771bc94',\n                     '5062_2_1.nii.gz':\n                    '6f77fb5134bc2841bdfc954390f0f4a4'}\n        \n    if not os.path.exists(folder):\n        print('Creating new directory %s' % folder)\n        os.makedirs(folder)\n        \n    for k, v in md5_dict.items():\n        fname = pjoin(folder, k)\n        if not os.path.exists(fname):\n            print('Downloading %s from SDR ...'%k)\n            _get_file_data(fname, url + k)\n            check_md5(fname, v)\n        else:\n            print('File %s is already in place. If you want to fetch it again, please first remove it from the folder %s ' % (fname, folder))\n\n    print('Done.')\n    print('Files copied in folder %s' % folder)", "response": "Download MRS data from SDR and store it in folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscanning a name string and output an object representing its structure.", "response": "def scan_author_string_for_phrases(s):\n    \"\"\"Scan a name string and output an object representing its structure.\n    Example:\n        Sample output for the name 'Jingleheimer Schmitt, John Jacob, XVI.' is::\n            {\n                'TOKEN_TAG_LIST' : ['lastnames', 'nonlastnames', 'titles', 'raw'],\n                'lastnames'      : ['Jingleheimer', 'Schmitt'],\n                'nonlastnames'   : ['John', 'Jacob'],\n                'titles'         : ['XVI.'],\n                'raw'            : 'Jingleheimer Schmitt, John Jacob, XVI.'\n            }\n    :param s: the input to be lexically tagged\n    :type s: string\n    :returns: dict of lexically tagged input items.\n    :rtype: dict\n    \"\"\"\n\n    if not isinstance(s, six.text_type):\n        s = s.decode('utf-8')\n\n    retval = {\n        'TOKEN_TAG_LIST': [\n            'lastnames',\n            'nonlastnames',\n            'titles',\n            'raw'],\n        'lastnames': [],\n        'nonlastnames': [],\n        'titles': [],\n        'raw': s}\n    l = s.split(',')  # noqa: E741\n    if len(l) < 2:\n        # No commas means a simple name\n        new = s.strip()\n        new = new.split(' ')\n        if len(new) == 1:\n            retval['lastnames'] = new        # rare single-name case\n        else:\n            retval['lastnames'] = new[-1:]\n            retval['nonlastnames'] = new[:-1]\n            for tag in ['lastnames', 'nonlastnames']:\n                retval[tag] = [x.strip() for x in retval[tag]]\n                retval[tag] = [re.split(split_on_re, x)\n                               for x in retval[tag]]\n                # flatten sublists\n                retval[tag] = [item for sublist in retval[tag]\n                               for item in sublist]\n                retval[tag] = [x for x in retval[tag] if x != '']\n    else:\n        # Handle lastname-first multiple-names case\n        retval['titles'] = l[2:]             # no titles? no problem\n        retval['nonlastnames'] = l[1]\n        retval['lastnames'] = l[0]\n        for tag in ['lastnames', 'nonlastnames']:\n            retval[tag] = retval[tag].strip()\n            retval[tag] = re.split(split_on_re, retval[tag])\n            # filter empty strings\n            retval[tag] = [x for x in retval[tag] if x != '']\n        retval['titles'] = [x.strip() for x in retval['titles'] if x != '']\n\n    return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter_conflicts(conflicts_list, fields):\n    for field in fields:\n        conflicts_list = filter_conflicts_by_path(conflicts_list, field)\n\n    return conflicts_list", "response": "This function will automatically filter out conflicts that are defined for the given rule."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_records(root, head, update, filters=()):\n    root, head, update = freeze(root), freeze(head), freeze(update)\n    for filter_ in filters:\n        root, head, update = filter_(root, head, update)\n\n    return thaw(root), thaw(head), thaw(update)", "response": "Apply the filters to the records."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to get a valid of true false or both from the field name in the query string raises a ValidationError for invalid values.", "response": "def get_true_false_both(query_params, field_name, default):\n    '''Tries to get and return a valid of true, false, or both from the field\n    name in the query string, raises a ValidationError for invalid values.'''\n    valid = ('true', 'false', 'both')\n    value = query_params.get(field_name, default).lower()\n    if value in valid:\n        return value\n    v = ', '.join(sorted(valid))\n    raise serializers.ValidationError({\n        field_name: ['Must be one of [%s]' % v],\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a queryset of the available entries.", "response": "def get_queryset(self):\n        '''We want to still be able to modify archived organizations, but they\n        shouldn't show up on list views.\n\n        We have an archived query param, where 'true' shows archived, 'false'\n        omits them, and 'both' shows both.'''\n        if self.action == 'list':\n            archived = get_true_false_both(\n                self.request.query_params, 'archived', 'false')\n            if archived == 'true':\n                return self.queryset.filter(archived=True)\n            if archived == 'false':\n                return self.queryset.filter(archived=False)\n        return self.queryset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a user to an organization.", "response": "def update(self, request, pk=None, parent_lookup_organization=None):\n        '''Add a user to an organization.'''\n        user = get_object_or_404(User, pk=pk)\n        org = get_object_or_404(\n            SeedOrganization, pk=parent_lookup_organization)\n        self.check_object_permissions(request, org)\n        org.users.add(user)\n        return Response(status=status.HTTP_204_NO_CONTENT)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a user from an organization.", "response": "def destroy(self, request, pk=None, parent_lookup_organization=None):\n        '''Remove a user from an organization.'''\n        user = get_object_or_404(User, pk=pk)\n        org = get_object_or_404(\n            SeedOrganization, pk=parent_lookup_organization)\n        self.check_object_permissions(request, org)\n        org.users.remove(user)\n        return Response(status=status.HTTP_204_NO_CONTENT)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a queryset of the objects that have the permission and object_id and namespace specified.", "response": "def get_queryset(self):\n        '''We want to still be able to modify archived organizations, but they\n        shouldn't show up on list views.\n\n        We have an archived query param, where 'true' shows archived, 'false'\n        omits them, and 'both' shows both.\n\n        We also have the query params permission_contains and object_id, which\n        allow users to filter the teams based on the permissions they\n        contain.'''\n        queryset = super(BaseTeamViewSet, self).get_queryset()\n        if self.action == 'list':\n            archived = get_true_false_both(\n                self.request.query_params, 'archived', 'false')\n            if archived == 'true':\n                queryset = queryset.filter(archived=True)\n            elif archived == 'false':\n                queryset = queryset.filter(archived=False)\n\n            permission = self.request.query_params.get(\n                'permission_contains', None)\n            if permission is not None:\n                queryset = queryset.filter(\n                    permissions__type__contains=permission).distinct()\n\n            object_id = self.request.query_params.get('object_id', None)\n            if object_id is not None:\n                queryset = queryset.filter(\n                    permissions__object_id=object_id).distinct()\n\n            namespace = self.request.query_params.get('namespace', None)\n            if namespace is not None:\n                queryset = queryset.filter(\n                    permissions__namespace=namespace).distinct()\n\n            permission = permissions.TeamPermission()\n            queryset = [\n                team for team in queryset if\n                permission.has_object_permission(self.request, self, team)]\n\n        return queryset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a permission to a team.", "response": "def create(\n            self, request, parent_lookup_seedteam=None,\n            parent_lookup_seedteam__organization=None):\n        '''Add a permission to a team.'''\n        team = self.check_team_permissions(\n            request, parent_lookup_seedteam,\n            parent_lookup_seedteam__organization)\n\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        permission = team.permissions.create(**serializer.validated_data)\n        serializer = self.get_serializer(instance=permission)\n        return Response(serializer.data, status=status.HTTP_201_CREATED)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove a permission from a team.", "response": "def destroy(\n            self, request, pk=None, parent_lookup_seedteam=None,\n            parent_lookup_seedteam__organization=None):\n        '''Remove a permission from a team.'''\n        self.check_team_permissions(\n            request, parent_lookup_seedteam,\n            parent_lookup_seedteam__organization)\n        return super(TeamPermissionViewSet, self).destroy(\n            request, pk, parent_lookup_seedteam,\n            parent_lookup_seedteam__organization)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a user to a team.", "response": "def update(\n            self, request, pk=None, parent_lookup_seedteam=None,\n            parent_lookup_seedteam__organization=None):\n        '''Add a user to a team.'''\n        user = get_object_or_404(User, pk=pk)\n        team = self.check_team_permissions(\n            request, parent_lookup_seedteam,\n            parent_lookup_seedteam__organization)\n        team.users.add(user)\n        return Response(status=status.HTTP_204_NO_CONTENT)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef destroy(\n            self, request, pk=None, parent_lookup_seedteam=None,\n            parent_lookup_seedteam__organization=None):\n        '''Remove a user from an organization.'''\n        user = self.get_object()\n        team = self.check_team_permissions(\n            request, parent_lookup_seedteam,\n            parent_lookup_seedteam__organization)\n        team.users.remove(user)\n        return Response(status=status.HTTP_204_NO_CONTENT)", "response": "Remove a user from an organization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_queryset(self):\n        '''We want to still be able to modify archived users, but they\n        shouldn't show up on list views.\n\n        We have an archived query param, where 'true' shows archived, 'false'\n        omits them, and 'both' shows both.'''\n        if self.action == 'list':\n            active = get_true_false_both(\n                self.request.query_params, 'active', 'true')\n            if active == 'true':\n                return self.queryset.filter(is_active=True)\n            if active == 'false':\n                return self.queryset.filter(is_active=False)\n        return self.queryset", "response": "Return a queryset of all the items that are in the archive list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef destroy(self, request, pk=None):\n        '''For DELETE actions, actually deactivate the user, don't delete.'''\n        user = self.get_object()\n        user.is_active = False\n        user.save()\n        return Response(status=status.HTTP_204_NO_CONTENT)", "response": "For DELETE actions actually deactivate the user don t delete."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef post(self, request):\n        '''Create a token, given an email and password. Removes all other\n        tokens for that user.'''\n        serializer = CreateTokenSerializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n\n        email = serializer.validated_data.get('email')\n        password = serializer.validated_data.get('password')\n        user = authenticate(username=email, password=password)\n        if not user:\n            return Response(status=status.HTTP_401_UNAUTHORIZED)\n\n        Token.objects.filter(user=user).delete()\n        token = Token.objects.create(user=user)\n\n        return Response(\n            status=status.HTTP_201_CREATED, data={'token': token.key})", "response": "Create a token given an email and password. Removes all other\n        tokens for that user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget user information with a list of permissions for that user.", "response": "def get(self, request):\n        '''Get user information, with a list of permissions for that user.'''\n        user = request.user\n        serializer = PermissionsUserSerializer(\n            instance=user, context={'request': request})\n        return Response(data=serializer.data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsanitizing the current settings and set the value of the current record ID field to the value of the current record ID.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(MapRegisterMessage, self).sanitize()\n\n        # P: This is the proxy-map-reply bit, when set to 1 an ETR sends a Map-\n        # Register message requesting for the Map-Server to proxy Map-Reply.\n        # The Map-Server will send non-authoritative Map-Replies on behalf\n        # of the ETR.  Details on this usage can be found in [LISP-MS].\n        if not isinstance(self.proxy_map_reply, bool):\n            raise ValueError('Proxy Map Reply flag must be a boolean')\n\n        # The third bit after the Type field in the Map-Register message is\n        # allocated as \"I\" bit.  I bit indicates that a 128 bit xTR-ID and a 64\n        # bit site-ID field is present at the end of the Map-Register message.\n        # If an xTR is configured with an xTR-ID or site-ID, it MUST set the I\n        # bit to 1 and include its xTR-ID and site-ID in the Map-Register\n        # messages it generates, if either the xTR-ID or site-ID is not\n        # configured an unspecified value is encoded for the ID not configured.\n        # If the R bit in the Map-Register is set to 1, the I bit must also be\n        # set to 1, and an xTR-ID must be included in the Map-Register message\n        # sent to an RTR.\n        #\n        # xTR-ID is a 128 bit field at the end of the Map-Register message,\n        # starting after the final Record in the message.  The xTR-ID is used\n        # to identify the intended recipient xTR for a Map-Notify message,\n        # especially in the case where a site has more than one xTR.  A value\n        # of all zeros indicate that an xTR-ID is not specified, though encoded\n        # in the message.  This is useful in the case where a site-ID is\n        # specified, but no xTR-ID is configured.  When a Map-Server receives a\n        # Map-Register with an xTR-ID specified (I bit set and xTR-ID has a\n        # non-zero value), it MUST copy the XTR-ID from the Map-Register to the\n        # associated Map-Notify message.  When a Map-Server is sending an\n        # unsolicited Map-Notify to an xTR to notify the xTR of a change in\n        # locators, the Map-Server must include the xTR-ID for the intended\n        # recipient xTR, if it has one stored locally.\n        if not isinstance(self.xtr_id, numbers.Integral) \\\n        or self.xtr_id < 0 or self.xtr_id >= 2 ** 128:\n            raise ValueError('Invalid xTR-ID')\n\n        # site-ID is a 64 bit field at the end of the Map-Register message,\n        # following the xTR-ID.  The site-ID is used by the Map-Server\n        # receiving the Map-Register message to identify which xTRs belong to\n        # the same site.  A value of 0 indicate that a site-ID is not\n        # specified, though encoded in the message.  When a Map-Server receives\n        # a Map-Regeter with a site-ID specified (I bit set and site-ID has\n        # non-zero value), it must copy the site-ID from the Map-Register to\n        # the associated Map-Notify message.  When a Map-Server is sending an\n        # unsolicited Map-Notify to an xTR to notify the xTR of a change in\n        # locators, the Map-Server must include the site-ID for the intended\n        # recipient xTR, if it has one stored locally.\n        if not isinstance(self.site_id, numbers.Integral) \\\n        or self.site_id < 0 or self.site_id >= 2 ** 64:\n            raise ValueError('Invalid site-ID')\n\n        # The fourth bit after the Type field in the Map-Register message is\n        # allocated as \"R\" bit.  R bit indicates that the Map-Register is built\n        # for an RTR.  R bit must be set in a Map-Register that a LISP device\n        # sends to an RTR.\n        if not isinstance(self.for_rtr, bool):\n            raise ValueError('For-RTR flag must be a boolean')\n\n        # M: This is the want-map-notify bit, when set to 1 an ETR is\n        # requesting for a Map-Notify message to be returned in response to\n        # sending a Map-Register message.  The Map-Notify message sent by a\n        # Map-Server is used to an acknowledge receipt of a Map-Register\n        # message.\n        if not isinstance(self.want_map_notify, bool):\n            raise ValueError('Want Map Notify flag must be a boolean')\n\n        # Nonce:  This 8-octet Nonce field is set to 0 in Map-Register\n        # messages.  Since the Map-Register message is authenticated, the\n        # nonce field is not currently used for any security function but\n        # may be in the future as part of an anti-replay solution.\n        if self.nonce != '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n            # Cisco devices seems to fill it in even if it should be 0\n            pass\n            # raise ValueError('Invalid nonce (must be 0 for Map-Register): {0}'.format(self.nonce.encode('hex')))\n\n        # Key ID:  A configured ID to find the configured Message\n        # Authentication Code (MAC) algorithm and key value used for the\n        # authentication function.  See Section 14.4 for codepoint\n        # assignments.\n        if self.key_id not in (KEY_ID_NONE, KEY_ID_HMAC_SHA_1_96,\n                               KEY_ID_HMAC_SHA_256_128):\n            raise ValueError('Invalid Key ID')\n\n        # Authentication Data:  The message digest used from the output of the\n        # Message Authentication Code (MAC) algorithm.  The entire Map-\n        # Register payload is authenticated with this field preset to 0.\n        # After the MAC is computed, it is placed in this field.\n        # Implementations of this specification MUST include support for\n        # HMAC-SHA-1-96 [RFC2404] and support for HMAC-SHA-256-128 [RFC6234]\n        # is RECOMMENDED.\n        if not isinstance(self.authentication_data, bytes):\n            raise ValueError('Invalid authentication data')\n\n        # Map-Reply Record:  When the M bit is set, this field is the size of a\n        # single \"Record\" in the Map-Reply format.  This Map-Reply record\n        # contains the EID-to-RLOC mapping entry associated with the Source\n        # EID.  This allows the ETR which will receive this Map-Request to\n        # cache the data if it chooses to do so.\n        for record in self.records:\n            if not isinstance(record, MapRegisterRecord):\n                raise ValueError('Invalid record')\n\n            record.sanitize()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a MapRegister packet and update properties accordingly.", "response": "def from_bytes(cls, bitstream):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the type\n        type_nr = bitstream.read('uint:4')\n        if type_nr != packet.message_type:\n            msg = 'Invalid bitstream for a {0} packet'\n            class_name = packet.__class__.__name__\n            raise ValueError(msg.format(class_name))\n\n        # Read the flags\n        packet.proxy_map_reply = bitstream.read('bool')\n\n        # Skip reserved bits\n        packet._reserved1 = bitstream.read(1)\n\n        # NATT bits\n        has_xtr_site_id = bitstream.read('bool')\n        packet.for_rtr = bitstream.read('bool')\n\n        # Skip reserved bits\n        packet._reserved2 = bitstream.read(15)\n\n        # Read the rest of the flags\n        packet.want_map_notify = bitstream.read('bool')\n\n        # Store the record count until we need it\n        record_count = bitstream.read('uint:8')\n\n        # Read the nonce\n        packet.nonce = bitstream.read('bytes:8')\n\n        # Read the key id\n        packet.key_id = bitstream.read('uint:16')\n\n        # Read the authentication data\n        data_length = bitstream.read('uint:16')\n        packet.authentication_data = bitstream.read('bytes:%d' % data_length)\n\n        # Read the records\n        for dummy in range(record_count):\n            record = MapRegisterRecord.from_bytes(bitstream)\n            packet.records.append(record)\n\n        # Read the xtr-id and site-id\n        if has_xtr_site_id:\n            packet.xtr_id = bitstream.read('uint:128')\n            packet.site_id = bitstream.read('uint:64')\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate bytes from properties and return them as a string.", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the type\n        bitstream = BitArray('uint:4=%d' % self.message_type)\n\n        # Add the flags\n        bitstream += BitArray('bool=%d' % self.proxy_map_reply)\n\n        # Add reserved bits\n        bitstream += self._reserved1\n\n        # Decide on the has_xtr_site_id value\n        has_xtr_site_id = bool(self.xtr_id or self.site_id or self.for_rtr)\n        bitstream += BitArray('bool=%d, bool=%d' % (has_xtr_site_id,\n                                                    self.for_rtr))\n\n        # Add reserved bits\n        bitstream += self._reserved2\n\n        # Add the rest of the flags\n        bitstream += BitArray('bool=%d' % self.want_map_notify)\n\n        # Add record count\n        bitstream += BitArray('uint:8=%d' % len(self.records))\n\n        # Add the nonce\n        bitstream += BitArray(bytes=self.nonce)\n\n        # Add the key-id and authentication data\n        bitstream += BitArray('uint:16=%d, uint:16=%d, hex=%s'\n                              % (self.key_id,\n                                 len(self.authentication_data),\n                                 self.authentication_data.encode('hex')))\n\n        # Add the map-reply records\n        for record in self.records:\n            bitstream += record.to_bitstream()\n\n        # Add xTR-ID and site-ID if we said we would\n        if has_xtr_site_id:\n            bitstream += BitArray('uint:128=%d, uint:64=%d' % (self.xtr_id,\n                                                               self.site_id))\n\n        return bitstream.bytes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iso_year_start(iso_year):\n    \"The gregorian calendar date of the first day of the given ISO year\"\n    fourth_jan = datetime.date(iso_year, 1, 4)\n    delta = datetime.timedelta(fourth_jan.isoweekday() - 1)\n    return fourth_jan - delta", "response": "The gregorian calendar date of the first day of the given ISO year"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef week_to_datetime(iso_year, iso_week):\n    \"datetime instance for the start of the given ISO year and week\"\n    gregorian = iso_to_gregorian(iso_year, iso_week, 0)\n    return datetime.datetime.combine(gregorian, datetime.time(0))", "response": "datetime instance for the start of the given ISO year and week"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init(name, *args, **kwargs):\n    if name in _TIMEFRAME_CATALOG:\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 2:\n            print(\"Initialize timeframe {0}: {1} {2}\".format(name, args, kwargs))\n        try:\n            return _TIMEFRAME_CATALOG[name](*args, **kwargs)\n        except ValueError as e:\n            print(\"Failed to initialize timeframe {0}: {1}!\".format(name, e), file=sys.stderr)\n    else:\n        print(\"Failed to initialize timeframe {0}: Not in catalog!\".format(name), file=sys.stderr)\n        sys.exit(1)", "response": "Instantiate a timeframe from the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a set of interfaces declared as implemented by class cls.", "response": "def get_implemented_interfaces(cls):\n    \"\"\"\n    Returns a set of :term:`interfaces <interface>` declared as implemented by\n    class `cls`.\n    \"\"\"\n    if hasattr(cls, '__interfaces__'):\n        return cls.__interfaces__\n    return six.moves.reduce(\n        lambda x, y: x.union(y),\n        map(\n            get_implemented_interfaces,\n            inspect.getmro(cls)[1:]\n        ),\n        set()\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the interfaces as implemented by class cls.", "response": "def set_implemented_interfaces(cls, interfaces):\n    \"\"\"\n    Declares :term:`interfaces <interface>` as implemented by class `cls`.\n    Those already declared are overriden.\n    \"\"\"\n    setattr(\n        cls,\n        '__interfaces__',\n        frozenset(\n            six.moves.reduce(\n                lambda x, y: x.union(y),\n                map(operator.attrgetter('implied'), interfaces),\n                set()\n            )\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_implemented_interfaces(cls, interfaces):\n    implemented = set(\n        six.moves.reduce(\n            lambda x, y: x.union(y),\n            map(operator.attrgetter('implied'), interfaces),\n            set()\n        )\n    )\n    implemented.update(*map(\n        get_implemented_interfaces,\n        inspect.getmro(cls)\n    ))\n    setattr(cls, '__interfaces__', frozenset(implemented))", "response": "Adds interfaces to the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if obj is a class implementing all of interfaces.", "response": "def isimplementation(obj, interfaces):\n    \"\"\"\n    Returns `True` if `obj` is a class implementing all of `interfaces` or an\n    instance of such class.\n\n    `interfaces` can be a single :term:`interface` class or an iterable of\n    interface classes.\n    \"\"\"\n    if not inspect.isclass(obj):\n        isimplementation(obj.__class__, interfaces)\n    if not isinstance(interfaces, collections.Iterable):\n        interfaces = [interfaces]\n    return frozenset(interfaces).issubset(\n        get_implemented_interfaces(obj)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_compliance(self, function):\n        argument_specification = _get_argument_specification(function)\n        if inspect.ismethod(function):\n            # Remove implied `self` argument from specification if function is\n            # a method.\n            argument_specification = argument_specification._replace(\n                args=argument_specification.args[1:]\n            )\n        if argument_specification != self.argument_specification:\n            raise MethodValidationError(\n                function,\n                self.argument_specification,\n                argument_specification\n            )", "response": "Checks if a given function complies with this specification."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mrc_to_marc(mrc):\n    # ignore blank lines\n    lines = [\n        line\n        for line in mrc.splitlines()\n        if line.strip()\n    ]\n\n    def split_to_parts(lines):\n        for line in lines:\n            first_part, second_part = line.split(\" L \", 1)\n\n            yield line, first_part, second_part.lstrip()\n\n    control_lines = []\n    data_lines = []\n    for line, first_part, second_part in split_to_parts(lines):\n        if second_part.startswith(\"$\"):\n            data_lines.append(line)\n        else:\n            control_lines.append(line)\n\n    # convert controlfield lines\n    record = MARCXMLRecord()\n    record.oai_marc = True\n    for line, descr, content in split_to_parts(control_lines):\n        record.controlfields[descr.strip()[:3]] = content\n\n    def get_subfield_dict(line):\n        fields = (\n            (field[0], field[1:])\n            for field in line.split(\"$$\")[1:]\n        )\n\n        fields_dict = defaultdict(list)\n        for key, val in fields:\n            fields_dict[key].append(val)\n\n        return fields_dict\n\n    # convert datafield lines\n    for line, descr, content_line in split_to_parts(data_lines):\n        name = descr[:3]\n        i1 = descr[3]\n        i2 = descr[4]\n\n        record.add_data_field(\n            name,\n            i1,\n            i2,\n            get_subfield_dict(content_line)\n        )\n\n    return record.to_XML()", "response": "Convert MRC data format to MARC XML."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dicts_to_mrc(code, dicts):\n    def _dict_to_mrc(code, d):\n        i1 = d.get(\"i1\", d.get(\"ind1\"))\n        i2 = d.get(\"i2\", d.get(\"ind2\"))\n\n        one_chars = [k for k in d.keys() if len(k) == 1]\n        out = \"%s%s%s L \" % (code, i1, i2)\n        for key in resorted(one_chars):\n            for item in d[key]:\n                out += \"$$%s%s\" % (key, item)\n\n        return out\n\n    return [\n        _dict_to_mrc(code, d)\n        for d in dicts\n    ]", "response": "Convert a list of dicts under code to MRC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert one single val to MRC.", "response": "def val_to_mrc(code, val):\n    \"\"\"\n    Convert one single `val` to MRC.\n\n    This function may be used for control fields in MARC records.\n\n    Args:,\n        code (str): Code of the field.\n        val (str): Value of the field.\n\n    Returns:\n        str: Correctly padded MRC line with field.\n    \"\"\"\n    code = str(code)\n    if len(code) < 3:\n        code += (3 - len(code)) * \" \"\n\n    return \"%s   L %s\" % (code, val)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting val to MRC whether it is dict or string.", "response": "def item_to_mrc(code, val):\n    \"\"\"\n    Convert `val` to MRC, whether it is dict or string.\n\n    Args:\n        code (str): Code of the field.\n        val (str or dict): Value of the field.\n\n    Returns:\n        list: MRC lines for output template.\n    \"\"\"\n    if isinstance(val, basestring):\n        return [val_to_mrc(code, val)]\n\n    if isinstance(val, dict):\n        val = [val]\n\n    return dicts_to_mrc(code, val)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitiate the resource retrieving all the asynchronous asynchronous information needed to support the IWebResource interface.", "response": "def initiate(self):\n        \"\"\"\n        Initiate the resource retrieving all the asynchronous\n        information needed to support the IWebResource interface.\n        \"\"\"\n\n        def deduce_methods(actions):\n            self._methods.add(http.Methods.GET)\n            for action in actions:\n                method = self.action_methods.get(action.name)\n                if method is not None:\n                    self._methods.add(method)\n\n        d = self.model.fetch_actions()\n        d.addCallback(deduce_methods)\n        d.addCallback(defer.override_result, self)\n        d.addErrback(self.filter_errors)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a SKOS Conceptscheme from a URI.", "response": "def conceptscheme_from_uri(conceptscheme_uri, **kwargs):\n    '''\n    Read a SKOS Conceptscheme from a :term:`URI`\n\n    :param string conceptscheme_uri: URI of the conceptscheme.\n    :rtype: skosprovider.skos.ConceptScheme\n    '''\n\n    # get the conceptscheme\n    # ensure it only ends in one slash\n    conceptscheme_uri = conceptscheme_uri.strip('/') + '/'\n    s = kwargs.get('session', requests.Session())\n    graph = uri_to_graph('%s.rdf' % (conceptscheme_uri), session=s)\n\n    notes = []\n    labels = []\n    if graph is not False:\n        for s, p, o in graph.triples((URIRef(conceptscheme_uri), RDFS.label, None)):\n            label = Label(o.toPython(), \"prefLabel\", 'en')\n            labels.append(label)\n\n    conceptscheme = ConceptScheme(\n        conceptscheme_uri,\n        labels=labels,\n        notes=notes\n    )\n    return conceptscheme"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uri_to_graph(uri, **kwargs):\n    '''\n    :param string uri: :term:`URI` where the RDF data can be found.\n    :rtype: rdflib.Graph or `False` if the URI does not exist\n    :raises skosprovider.exceptions.ProviderUnavailableException: if the\n        getty.edu services are down\n    '''\n    s = kwargs.get('session', requests.Session())\n    graph = rdflib.Graph()\n    try:\n        res = s.get(uri)\n    except requests.ConnectionError as e:\n        raise ProviderUnavailableException(\"URI not available: %s\" % uri)\n    if res.status_code == 404:\n        return False\n    graph.parse(data=res.content)\n    return graph", "response": "Converts a URI to a rdflib. Graph object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef private_dir_path(app_name):\n    _private_dir_path = os.path.expanduser(click.get_app_dir(\n        app_name,\n        force_posix=True,  # forces to ~/.tigerhost on Mac and Unix\n    ))\n    return _private_dir_path", "response": "Returns the private directory path for the given app name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the private directory exists and is a directory.", "response": "def ensure_private_dir_exists(app_name):\n    \"\"\"Ensures that the private directory exists and is a directory.\n\n    :param str app_name: the name of the app\n    \"\"\"\n    path = private_dir_path(app_name)\n    if not os.path.exists(path):\n        os.makedirs(path)\n    else:\n        if not os.path.isdir(path):\n            raise PrivateDirConflictError"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a message sending object\n        into this object.\n\n        '''\n        self._targets = []\n        for c in node.getElementsByTagNameNS(RTS_NS, 'targets'):\n            if c.getElementsByTagNameNS(RTS_NS, 'WaitTime'):\n                new_target = WaitTime()\n            elif c.getElementsByTagNameNS(RTS_NS, 'Preceding'):\n                new_target = Preceding()\n            else:\n                new_target = Condition()\n            new_target.parse_xml_node(c)\n            self._targets.append(new_target)\n        return self", "response": "Parse an xml. dom Node object representing a message sending object\n        into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_yaml(self, y):\n        '''Parse a YAML speficication of a message sending object into this\n        object.\n\n        '''\n        self._targets = []\n        if 'targets' in y:\n            for t in y['targets']:\n                if 'waitTime' in t['condition']:\n                    new_target = WaitTime()\n                elif 'preceding' in t['condition']:\n                    new_target = Preceding()\n                else:\n                    new_target = Condition()\n                new_target.parse_yaml(t)\n                self._targets.append(new_target)\n        return self", "response": "Parse a YAML speficication of a message sending object into this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving this message_sending object into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this message_sending object into an xml.dom.Element object.'''\n        for cond in self._targets:\n            new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'targets')\n            new_element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:condition_ext')\n            cond.save_xml(doc, new_element)\n            element.appendChild(new_element)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves this message sending object into a dictionary.", "response": "def to_dict(self):\n        '''Save this message sending object into a dictionary.'''\n        targets = []\n        for cond in self._targets:\n            targets.append(cond.to_dict())\n        if targets:\n            return {'targets': targets}\n        else:\n            return {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse an xml. dom Node object representing a condition into this object.", "response": "def parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a condition into this\n        object.\n\n        '''\n        self.sequence = int(node.getAttributeNS(RTS_NS, 'sequence'))\n        c = node.getElementsByTagNameNS(RTS_NS, 'TargetComponent')\n        if c.length != 1:\n            raise InvalidParticipantNodeError\n        self.target_component = TargetExecutionContext().parse_xml_node(c[0])\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a condition into this object.'''\n        self.sequence = int(y['sequence'])\n        self.target_component = \\\n                TargetExecutionContext().parse_yaml(y['targetComponent'])\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y.get(RTS_EXT_NS_YAML + 'properties'):\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self", "response": "Parse a YAML specification of a condition into this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves this condition into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this condition into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'sequence',\n                               str(self.sequence))\n        new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'TargetComponent')\n        self.target_component.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n        '''Save this condition into a dictionary.'''\n        d = {'sequence': self.sequence,\n                'targetComponent': self.target_component.to_dict()}\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d", "response": "Save this condition into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing an xml. dom Node object representing a preceding condition into this object.", "response": "def parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a preceding condition into\n        this object.\n\n        '''\n        super(Preceding, self).parse_xml_node(node)\n        p_nodes = node.getElementsByTagNameNS(RTS_NS, 'Preceding')\n        if p_nodes.length != 1:\n            raise InvalidParticipantNodeError\n        p_node = p_nodes[0]\n        if p_node.hasAttributeNS(RTS_NS, 'timeout'):\n            self.timeout = int(p_node.getAttributeNS(RTS_NS, 'timeout'))\n        else:\n            self.timeout = 0\n        if p_node.hasAttributeNS(RTS_NS, 'sendingTiming'):\n            self.sending_timing = p_node.getAttributeNS(RTS_NS, 'sendingTiming')\n        else:\n            self.sending_timing = 'ASYNC'\n        self._preceding_components = []\n        for c in p_node.getElementsByTagNameNS(RTS_NS, 'PrecedingComponents'):\n            self._preceding_components.append(TargetExecutionContext().parse_xml_node(c))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a preceding condition into this\n        object.\n\n        '''\n        super(Preceding, self).parse_yaml(y)\n        c = y['condition']['preceding']\n        if 'timeout' in c:\n            self.timeout = int(c['timeout'])\n        else:\n            self.timeout = 0\n        if 'sendingTiming' in c:\n            self.sending_timing = c['sendingTiming']\n        else:\n            self.sending_timing = 'ASYNC'\n        self._preceding_components = []\n        if 'precedingComponents' in c:\n            for p in c.get('precedingComponents'):\n                self._preceding_components.append(TargetExecutionContext().parse_yaml(p))\n        return self", "response": "Parse a YAML specification of a preceding condition into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving this preceding condition into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this preceding condition into an xml.dom.Element object.'''\n        super(Preceding, self).save_xml(doc, element)\n        pre_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'Preceding')\n        if self.timeout:\n            pre_element.setAttributeNS(RTS_NS, RTS_NS_S + 'timeout',\n                    str(self.timeout))\n        if self.sending_timing:\n            pre_element.setAttributeNS(RTS_NS, RTS_NS_S + 'sendingTiming',\n                                   self.sending_timing)\n        for pc in self._preceding_components:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'PrecedingComponents')\n            pc.save_xml(doc, new_element)\n            pre_element.appendChild(new_element)\n        element.appendChild(pre_element)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave this preceding condition into a dictionary.", "response": "def to_dict(self):\n        '''Save this preceding condition into a dictionary.'''\n        d = super(Preceding, self).to_dict()\n        e = {}\n        if self.timeout != 0:\n            e['timeout'] = self.timeout\n        if self.sending_timing:\n            e['sendingTiming'] = self.sending_timing\n        pcs = []\n        for pc in self._preceding_components:\n            pcs.append(pc.to_dict())\n        if pcs:\n            e['precedingComponents'] = pcs\n        d['condition'] = {'preceding': e}\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a wait_time condition into\n        this object.\n\n        '''\n        super(WaitTime, self).parse_xml_node(node)\n        wait_time_nodes = node.getElementsByTagNameNS(RTS_NS, 'WaitTime')\n        if wait_time_nodes.length != 1:\n            raise InvalidParticipantNodeError\n        self.wait_time = int(wait_time_nodes[0].getAttributeNS(RTS_NS,\n                'waitTime'))\n        return self", "response": "Parse an xml. dom Node object representing a wait_time condition into this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a YAML specification of a wait_time condition into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a wait_time condition into this\n        object.\n\n        '''\n        super(WaitTime, self).parse_yaml(y)\n        self.wait_time = int(y['condition']['waitTime']['waitTime'])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving this wait_time condition into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this wait_time condition into an xml.dom.Element object.'''\n        super(WaitTime, self).save_xml(doc, element)\n        new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'WaitTime')\n        new_element.setAttributeNS(RTS_NS, RTS_NS_S + 'waitTime',\n                str(self.wait_time))\n        element.appendChild(new_element)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self):\n        '''Save this wait_time condition into a dictionary.'''\n        d = super(WaitTime, self).to_dict()\n        d['condition'] = {'waitTime': {'waitTime': self.wait_time}}\n        return d", "response": "Save this wait_time condition into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse Android s ls - lR output.", "response": "def parse_ls(out):\n    \"\"\"\n    Parser for Android's ls -lR output.\n    Takes a string, returns parsed structure.\n    \"\"\"\n\n    # assumed ls -lR line format:\n    # -rw-r--r-- root     shell           0 2013-07-05 02:26 tasks\n    # drwxr-xr-x root     root              2013-07-05 02:26 log\n    # brw------- root     root     179,   0 2013-07-05 02:26 mmcblk0\n    # lrwxrwxrwx root     root              2013-07-05 02:34 subsystem -> ../class/bdi\n\n    # CAVE: format may change through versions.\n    # TODO: implement plausibility test.\n\n    mode = r'^(.)'\n    field = r'([^ ]+) +'\n    dev = r'(\\d+), +(\\d+) '\n    date = r'(\\d{4}\\-\\d{2}\\-\\d{2} \\d{2}:\\d{2}) '\n    name = r'(.+)$'\n    link = r'(.+) -> (.+)$'\n\n    logger = get_default_logger()\n\n    # adb returns newline as \\r\\n\n    # but mozdevice uses \\n\n    for dirstr in out[2:-2].split('\\r\\n\\r\\n'):\n        lines = dirstr.split('\\r\\n')\n        dirname = lines[0][:-1]\n        if len(lines) == 2 and lines[1].startswith(\"opendir failed\"):\n            continue\n        for filestr in lines[1:]:\n            if filestr.endswith(\": No such file or directory\"):\n                continue\n            if filestr.endswith(\": Permission denied\"):\n                continue\n            specs = None\n            if filestr[0] in 'dsp':  # directory, socket, pipe\n                regexp = mode + field * 3 + date + name\n                m = re.search(regexp, filestr)\n                specs = {\n                'mode': m.group(1),\n                'perm': m.group(2),\n                'uid': m.group(3),\n                'gid': m.group(4),\n                'date': m.group(5),\n                'name': m.group(6)\n                }\n            elif filestr[0] == 'l':  # symbolic link\n                regexp = mode + field * 3 + date + link\n                m = re.search(regexp, filestr)\n                specs = {\n                'mode': m.group(1),\n                'perm': m.group(2),\n                'uid': m.group(3),\n                'gid': m.group(4),\n                'date': m.group(5),\n                'name': m.group(6),\n                'link': m.group(7)\n                }\n            elif filestr[0] in 'cb':  # device\n                regexp = mode + field * 3 + dev + date + name\n                m = re.search(regexp, filestr)\n                specs = {\n                'mode': m.group(1),\n                'perm': m.group(2),\n                'uid': m.group(3),\n                'gid': m.group(4),\n                'major': m.group(5),\n                'minor': m.group(6),\n                'date': m.group(7),\n                'name': m.group(8)\n                }\n            else:  # rest\n                try:\n                    regexp = mode + field * 4 + date + name\n                    m = re.search(regexp, filestr)\n                    specs = {\n                    'mode': m.group(1),\n                    'perm': m.group(2),\n                    'uid': m.group(3),\n                    'gid': m.group(4),\n                    'size': m.group(5),\n                    'date': m.group(6),\n                    'name': m.group(7)\n                    }\n                except:\n                    logger.error(\"parse error on %s\" % filestr)\n\n            try:\n                specs['name'] = '/' + os.path.relpath(\"%s/%s\" % (dirname, specs['name']), '/')\n                if 'link' in specs.keys():\n                    specs['link'] = '/' + os.path.relpath(\"%s/%s\" % (dirname, specs['link']), '/')\n            except:\n                logger.warning(\"no name from %s\" % filestr)\n\n            yield specs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_windows(rlist, wlist, xlist, timeout, retry=True):\n    from ctypes import windll, byref, c_ulong, c_void_p, WinError, GetLastError\n    PIPE_ENDED = 109\n    read_ready = []\n    rlist = [item for item in rlist]\n    for i in range(2):\n        for fd in rlist:\n            bytes_available = c_ulong(0)\n            handle = _get_named_pipe_from_fileno(fd.fileno())\n            result = windll.kernel32.PeekNamedPipe(c_void_p(handle),        # _In_       HANDLE hNamedPipe,\n                                                   None,                    # _Out_opt_  LPVOID lpBuffer,\n                                                   c_ulong(0),              # _In_       DWORD nBufferSize,\n                                                   None,                    # _Out_opt_  LPDWORD lpBytesRead,\n                                                   byref(bytes_available),  # _Out_opt_  LPDWORD lpTotalBytesAvail,\n                                                   None)                    # _Out_opt_  LPDWORD lpBytesLeftThisMessage\n            if not result:\n                last_error = GetLastError()\n                if last_error != PIPE_ENDED:\n                    raise WinError(last_error)\n                continue\n            if bytes_available.value:\n                read_ready.append((fd, bytes_available.value, ))\n                rlist.remove(fd)\n        sleep(timeout)\n    return read_ready, wlist, xlist", "response": "This function is used to select files from a list of sockets. It will try to read all the files in the list and return a list of tuples that are returned by the select function."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles a readable file.", "response": "def _handle_readable(self, f):\n        \"\"\" because anonymous pipes in windows can be blocked, we need to pay attention\n        on how much we read\n        \"\"\"\n        count = -1\n        if isinstance(f, tuple):\n            f, count = f\n        handler = self._reads.pop(f, None)\n        if handler is not None:\n            handler(self, f, count=count)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the object with the given parameters.", "response": "def initialize(self, id=None, title=None, namespace=None, redirect=None,\n                   restrictions=None):\n        self.id = none_or(id, int)\n        \"\"\"\n        Page ID : `int`\n        \"\"\"\n\n        self.title = none_or(title, str)\n        \"\"\"\n        Page title (namespace excluded) : `str`\n        \"\"\"\n\n        self.namespace = none_or(namespace, int)\n        \"\"\"\n        Namespace ID : `int`\n        \"\"\"\n\n        self.redirect = none_or(redirect, str)\n        \"\"\"\n        Page name that the page redirects to : `str` | `None`\n        \"\"\"\n\n        self.restrictions = none_or(restrictions, list)\n        \"\"\"\n        A list of page editing restrictions : list( `str` ) | `None`\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select_with_main_images(self, limit=None, **kwargs):\n        ''' Select all objects with filters passed as kwargs.   \n            For each object it's main image instance is accessible as ``object.main_image``.\n            Results can be limited using ``limit`` parameter.\n            Selection is performed using only 2 or 3 sql queries.            \n        '''\n        objects = self.get_query_set().filter(**kwargs)[:limit]\n        self.image_model_class.injector.inject_to(objects,'main_image', is_main=True)\n        return objects", "response": "Select all objects with filters passed as kwargs.   \n            For each object it s main image instance is accessible as object. main_image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn main image for given model", "response": "def get_main_for(self, model):\n        '''\n        Returns main image for given model\n        '''        \n        try:\n            return self.for_model(model).get(is_main=True)\n        except models.ObjectDoesNotExist:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef skip_once(self, call_descriptor_hash):\n        if call_descriptor_hash not in self.__skip:\n            self.__skip[call_descriptor_hash] = 0\n        self.__skip[call_descriptor_hash] += 1", "response": "Sets the skip flag to 1 if the next encounter of a particular CallDescriptor hash should be ignored."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self):\n        s = load_stack(self)\n        if s:\n            self.hooks = s.hooks\n            self.calls = s.calls", "response": "Loads the state of a previously saved CallStack to this instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_caller(self, caller):\n        self.caller = caller.__name__\n        self.module = inspect.getmodule(caller).__name__\n        self.load()", "response": "Sets the caller after instantiation."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a CallDescriptor to the stack.", "response": "def add(self, call_descriptor):\n        \"\"\"\n        Adds a CallDescriptor hash to the stack. If there is a hook associated with this call it will be executed and passed an instance of the call descriptor.\n\n        :param caliendo.call_descriptor.CallDescriptor call_descriptor: The call descriptor to add to the stack.\n\n        \"\"\"\n        h = call_descriptor.hash\n        self.calls.append(h)\n        if h in self.__skip:\n            self.__skip[h] -= 1\n            if self.__skip[h] == 0:\n                del self.__skip[h]\n        else:\n            hook = self.hooks.get(h, False)\n            if hook:\n                hook.callback(call_descriptor)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_hook(self, hook):\n        h = hook.hash\n        self.hooks[h] = hook", "response": "Adds a hook to the CallStack."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nterminates all the slave agencies and shutdowns itself.", "response": "def full_shutdown(self, stop_process=False):\n        '''Terminate all the slave agencies and shutdowns itself.'''\n        return self._shutdown(full_shutdown=True, stop_process=stop_process,\n                              gentle=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shutdown(self, stop_process=False):\n        '''Shutdown the agency in gentel manner (terminate all the agents).'''\n        self.info(\"Agency.shutdown() called.\")\n        return self._shutdown(stop_process=stop_process, gentle=True)", "response": "Shutdown the agency in gentel manner ( terminate all the agents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef actually_start_agent(self, descriptor, **kwargs):\n        factory = IAgentFactory(\n            applications.lookup_agent(descriptor.type_name))\n        if factory.standalone:\n            return self.start_standalone_agent(descriptor, factory, **kwargs)\n        else:\n            return self.start_agent_locally(descriptor, **kwargs)", "response": "This method will be called when the master agency starts a new agent."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef locate_agent(self, recp):\n        '''locate_agent(recp): Return (host, port, should_redirect) tuple.\n        '''\n        if recipient.IRecipient.providedBy(recp):\n            agent_id = recp.key\n        else:\n            agent_id = recp\n        found = yield self.find_agent(agent_id)\n        if isinstance(found, agency.AgencyAgent):\n            host = self.get_hostname()\n            port = self.gateway_port\n            defer.returnValue((host, port, False, ))\n        elif isinstance(found, broker.AgentReference):\n            host = self.get_hostname()\n            port = yield found.reference.callRemote('get_gateway_port')\n            defer.returnValue((host, port, True, ))\n        else: # None\n            # lazy import not to load descriptor before feat is loaded\n            from feat.utils import locate\n            db = self._database.get_connection()\n            host = yield locate.locate(db, agent_id)\n            port = self.config.gateway.port\n            if host is None or (self._broker.is_master() and\n                                host == self.get_hostname()):\n                # Second condition reflects the situation when the agent\n                # has its descriptor in the database but is not running.\n                # It breaks the infinite redirect loop.\n                defer.returnValue(None)\n            else:\n                defer.returnValue((host, port, True, ))", "response": "Locate the agent in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reconfigure_messaging(self, msg_host, msg_port):\n        '''force messaging reconnector to the connect to the (host, port)'''\n        self._messaging.create_external_route(\n            'rabbitmq', host=msg_host, port=msg_port)", "response": "force messaging reconnector to the connect to the ( host port )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nforce database reconnector to connect to the ( host port name )", "response": "def reconfigure_database(self, host, port, name='feat'):\n        '''force database reconnector to connect to the (host, port, name)'''\n        self._database.reconfigure(host, port, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_slaves(self):\n        '''Print information about the slave agencies.'''\n        resp = []\n        for slave_id, slave in self._broker.slaves.iteritems():\n            resp += [\"#### Slave %s ####\" % slave_id]\n            table = yield slave.callRemote('list_agents')\n            resp += [table]\n            resp += []\n        defer.returnValue(\"\\n\".join(resp))", "response": "Print information about the slave agencies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef item_meta(item_name, name, value, scheme=None):\n    _annotate(\"item_meta\", item_name, name, value, scheme=scheme)", "response": "Add meta information to an already defined item\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attribute(name, value, getter=None, setter=None, deleter=None,\n              label=None, desc=None, meta=None):\n    \"\"\"\n    Annotates a model attribute.\n    @param name: attribute name, unique for a model.\n    @type name: str or unicode\n    @param value: attribute type information.\n    @type value: implementer of L{src.feat.models.interface.IValueInfo}\n    @param getter: an effect or None if the attribute is write-only;\n                   the retrieved value that will be validated;\n                   see feat.models.call for effect information.\n    @type getter: callable or None\n    @param setter: an effect or None if the attribute is read-only;\n                   the new value will be validated, possibly converted\n                   and returned;\n                   see feat.models.call for effect information.\n    @type setter: callable or None\n    @param deleter: an effect or None if the attribute cannot be deleted;\n    @type deleter: callable or None\n    @param label: the attribute label or None.\n    @type label: str or unicode or None\n    @param desc: the description of the attribute or None if not documented.\n    @type desc: str or unicode or None\n    @param meta: model item metadata atoms.\n    @type meta: list of tuple\n    \"\"\"\n    _annotate(\"attribute\", name, value, getter=getter, setter=setter,\n              deleter=deleter,\n              label=label, desc=desc, meta=meta)", "response": "Annotates a model item attribute."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef child(name, source=None, view=None, model=None,\n          enabled=None, fetch=None, browse=None,\n          label=None, desc=None, meta=None):\n    \"\"\"\n    Annotate a sub-model to the one being defined.\n    @param name: item name unique for the model being defined.\n    @type name: str or unicode\n    @param source: an effect to retrieve the sub-model source\n                   or None to use the same source;\n                   see feat.models.call for effect information.\n    @type source: callable or None\n    @param view: view value or an effect to retrieve it;\n                 see feat.models.call for effect information.\n    @type view: callable or object()\n    @param model: the model identity, model factory or effect to get it,\n                  or None to use IModel adapter.\n    @type model: str or unicode or callable or IModelFactory or None\n    @param enabled: an effect defining if the model is enabled\n    @type enabled: bool or callable\n    @param browse: an effect filtering the source when browsing to child.\n    @type browse: callable\n    @param fetch: an effect filtering the source when fetching child.\n    @type fetch: callable\n    @param label: the sub-model label or None.\n    @type label: str or unicode or None\n    @param desc: the description of the sub-model or None if not documented.\n    @type desc: str or unicode or None\n    @param meta: model item metadata atoms.\n    @type meta: list of tuple\n    \"\"\"\n    _annotate(\"child\", name, source=source, view=view, model=model,\n              enabled=enabled, fetch=fetch, browse=browse,\n              label=label, desc=desc, meta=meta)", "response": "Annotate a sub - model to the one being defined."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nannotates a non - idempotent create action to the model being defined.", "response": "def create(name, *effects, **kwargs):\n    \"\"\"\n    Annotate a non-idempotent create action to the model being defined.\n    Should really be::\n      create(name, *effects, value=None, params=None, label=None, desc=None)\n    but it is not supported by python < 3.\n\n    @param name: item name unique for the model being defined.\n    @type name: str or unicode\n    @param effects:\n    @type effects: str or unicode\n    @param value: input value information or None if not required.\n    @type value: IValuInfo or None\n    @param params: action paremeter or list of action parameters.\n    @type params: IActionPram or list of IActionParam\n    @param label: the action label or None.\n    @type label: str or unicode or None\n    @param desc: the action  description or None if not documented.\n    @type desc: str or unicode or None\n    \"\"\"\n    value_info = kwargs.pop(\"value\", None)\n    params = kwargs.pop(\"params\", None)\n    label = kwargs.pop(\"label\", None)\n    desc = kwargs.pop(\"desc\", None)\n    if kwargs:\n        raise TypeError(\"create() got an unexpected keyword '%s'\"\n                        % kwargs.keys()[0])\n    _annotate(\"create\", name, value_info=value_info, params=params,\n              effects=effects, label=label, desc=desc)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(name, *effects, **kwargs):\n    label = kwargs.pop(\"label\", None)\n    desc = kwargs.pop(\"desc\", None)\n    if kwargs:\n        raise TypeError(\"delete() got an unexpected keyword '%s'\"\n                        % kwargs.keys()[0])\n    _annotate(\"delete\", name, effects=effects, label=label, desc=desc)", "response": "Annotate a delete action to the model being defined."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef action(name, factory, label=None, desc=None):\n    _annotate(\"action\", name, factory,\n              label=label, desc=desc)", "response": "Annotate a model s action."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collection(name, child_names=None, child_source=None,\n               child_view=None, child_model=None, child_label=None,\n               child_desc=None, child_meta=None,\n               label=None, desc=None, meta=None, model_meta=None):\n    \"\"\"\n    Annotate a dynamic collection of sub-models.\n\n    @param name:         name of the collection model containing the sub-models\n    @type  name:         str or unicode\n    @param child_names:  an effect that retrieve all sub-models names or\n                         None if sub-models are not iterable.\n    @type  child_names:  callable\n    @param child_source: an effect that retrieve a sub-model source.\n    @type  child_source: callable\n    @param child_view:   an effect that retrieve a sub-model view.\n    @type  child_view:   callable\n    @param child_model:  the model identity, model factory or effect to get it,\n                         or None to use IModel adapter.\n    @type  child_model:  str or unicode or callable or IModelFactory or None\n    @param child_label:  the model items label or None.\n    @type  child_label:  str or unicode or None\n    @param child_desc:   the model items description or None.\n    @type  child_desc:   str or unicode or None\n    @param child_meta:   collection model's items metadata.\n    @type  child_meta:   list of tuple\n    @param label:        the collection label or None.\n    @type  label:        str or unicode or None\n    @param desc:         the collection description or None.\n    @type  desc:         str or unicode or None\n    @param meta:         item metadata.\n    @type  meta:         list of tuple\n    @param model_meta:   collection model metadata.\n    @type  model_meta:   list of tuple\n    \"\"\"\n    _annotate(\"collection\", name, child_names=child_names,\n              child_source=child_source, child_view=child_view,\n              child_model=child_model, child_label=child_label,\n              child_desc=child_desc, child_meta=child_meta,\n              label=label, desc=desc, meta=meta, model_meta=model_meta)", "response": "Annotate a dynamic collection of sub - models."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndoes not keep any reference to its parent this way it can be garbage - collected.", "response": "def initiate(self, aspect=None, view=None, parent=None, officer=None):\n        \"\"\"Do not keep any reference to its parent,\n        this way it can be garbage-collected.\"\"\"\n\n        def got_view(view):\n            if view is None:\n                return None\n            return init(view)\n\n        def init(view):\n            self.view = view\n            d = self.call_mro(\"init\")\n            d.addCallback(retrieve_reference)\n            d.addCallback(update_reference)\n            return d\n\n        def retrieve_reference(_param):\n            if callable(self._model_reference):\n                context = self.make_context()\n                return self._model_reference(self.source, context)\n            return self._model_reference\n\n        def update_reference(reference):\n            self.reference = reference\n            return self\n\n        if officer is not None:\n            self.officer = IOfficer(officer)\n        self.aspect = IAspect(aspect) if aspect is not None else None\n        if self._model_view is not None:\n            if callable(self._model_view):\n                context = self.make_context(view=view)\n                d = self._model_view(None, context)\n                return d.addCallback(got_view)\n            return init(self._model_view)\n        return init(view)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_model(self, view_getter=None, source_getters=None,\n                      model_factory=None, officer=None):\n        \"\"\"\n        Creates a model from the model factory after retrieving\n        the source and the view. The officer is the IOfficer\n        FOR THE MODEL TO BE CREATED and NO OFFICER CHECKS ARE PERFORMED.\n        \"\"\"\n\n        if view_getter is not None:\n            d = defer.succeed(view_getter)\n            d.addCallback(self._retrieve_view)\n            d.addCallback(self._check_view)\n        else:\n            # views are inherited\n            d = defer.succeed(self.model.view)\n\n        d.addCallback(self._retrieve_model, source_getters,\n                      model_factory, officer)\n\n        d.addErrback(self._filter_errors)\n        return d", "response": "Creates a Deferred that resolves with the model factory after retrieving the source and the view."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _transpose(cls, char):\n        try:\n            loc = ord(char) - 65\n            if loc < 0 or loc > 56:\n                return char\n            return cls.UNICODE_MAP[loc]\n        except UnicodeDecodeError:\n            return char", "response": "Convert unicode char to something similar to it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _MapVowels(cls, string, also_p=False):\n        return cls._PSUB_RE.sub(cls.Repl, string)", "response": "Map vowels in the string into Hebrew characters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_genres(self):\n    page = r.get(ITUNES_GENRES_URL)\n    tree = html.fromstring(page.content)\n    elements = tree.xpath(\"//a[@class='top-level-genre']\")\n    return [e.attrib['href'] for e in elements]", "response": "Get genre URLs from iTunes Podcast preview\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_urls_for_genre(self, genre_url):\n    letters = list(string.ascii_uppercase)\n    urls = []\n    for letter in letters:\n      base = '{}&letter={}'.format(genre_url, letter)\n      page = r.get(base)\n      tree = html.fromstring(page.content)\n      elements = tree.xpath(\"//ul[@class='list paginate']\")\n      if not elements:\n        urls.append(base)\n      else:\n        for i in xrange(1, self._find_num_pages(base)):\n          urls.append('{}&page={}#page'.format(base, i))\n    return urls", "response": "Generate URL s for a given genre"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the number of pages paginating a genre s letter URL Find the number of pages paginating a genre s letter URL", "response": "def _find_num_pages(self, url):\n    \"\"\"\n    Find the number of pages paginating a genre's letter URL\n    \"\"\"\n    def _new_url(i):\n      return '{}&page={}#page'.format(url, i)\n    i = 0\n    j = 2000\n    k = (i + j) / 2\n    crawler = SeriesCrawler(_new_url(k))\n    while i < j:\n      ids = crawler.get_ids()\n      # If we only find one (we've gone too far)\n      if len(ids) == 1:\n        # Don't decrement by 1 b/c this could be the last page\n        j = k\n        k = (i + j) / 2\n        crawler.set_url(_new_url(k))\n      else:\n        i = k + 1\n        k = (i + j) / 2\n        crawler.set_url(_new_url(k))\n    return i"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(cls, database, doc_id):\n        doc = database.get(doc_id)\n        if doc is None:\n            return None\n        return cls.wrap(doc)", "response": "Load a specific document from the given database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstore the document in the given database.", "response": "def store(self, database, validate=True, role=None):\n        \"\"\"Store the document in the given database.\n\n        :param database: the `Database` object source for storing the document.\n        :return: an updated instance of `Document` / self.\n        \"\"\"\n        if validate:\n            self.validate()\n        self._id, self._rev = database.save(self.to_primitive(role=role))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreload all instances of Document and Any related objects in the model.", "response": "def hydrate(self, database, recursive=True):\n        \"\"\"\n        By default, recursively reloads all instances of Document\n        in the model.  Recursion can be turned off.\n\n        :param database: the `Database` object source for rehydrating.\n        :return: an updated instance of `Document` / self.\n        \"\"\"\n        if isinstance(self, Document):\n            self.reload(database)\n        for field in self:\n            obj = getattr(self, field)\n            if isinstance(obj, Document):\n                obj.reload(database)\n                if recursive:\n                    obj.hydrate(database)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a CouchDB temporary view and map the result values back to objects of this mapping.", "response": "def query(cls, database, map_fun, reduce_fun,\n              language='javascript', **options):\n        \"\"\"Execute a CouchDB temporary view and map the result values back to\n        objects of this mapping.\n\n        Note that by default, any properties of the document that are not\n        included in the values of the view will be treated as if they were\n        missing from the document. If you want to load the full document for\n        every row, set the ``include_docs`` option to ``True``.\n        \"\"\"\n        return database.query(map_fun, reduce_fun=reduce_fun, language=language,\n                        wrapper=cls._wrap_row, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a CouchDB named view and map the result values back to objects of this mapping.", "response": "def view(cls, database, viewname, **options):\n        \"\"\"Execute a CouchDB named view and map the result values back to\n        objects of this mapping.\n\n        Note that by default, any properties of the document that are not\n        included in the values of the view will be treated as if they were\n        missing from the document. If you want to load the full document for\n        every row, set the ``include_docs`` option to ``True``.\n        \"\"\"\n        return database.view(viewname, wrapper=cls._wrap_row, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps ViewField or ViewDefinition Rows.", "response": "def _wrap_row(cls, row):\n        \"\"\"Wrap ViewField or ViewDefinition Rows.\"\"\"\n        doc = row.get('doc')\n        if doc is not None:\n            return cls.wrap(doc)\n        data = row['value']\n        data['_id'] = row['id']\n        return cls.wrap(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post(self, url, entity):\n\n        try:\n            if entity is None or entity == \"\":\n                jsonData = \"\"\n            else:\n                jsonData = entity.to_json()\n        except Exception as e:\n            jsonData = jsonpickle.pickler.encode(entity)\n        response = requests.post(\n            self.host + url,\n            jsonData,\n            headers={\n                \"Content-Type\": \"application/json\",\n                'Authorization': 'Bearer ' + self.token,\n                'x-falkonry-source':self.sourceHeader\n            },\n            verify=False\n        )\n        if response.status_code == 201:\n            try:\n                return json.loads(response._content.decode('utf-8'))\n            except Exception as e:\n                return json.loads(response.content)\n        elif response.status_code == 409:\n            try:\n                return json.loads(response._content.decode('utf-8'))\n            except Exception as e:\n                return json.loads(response.content)\n        elif response.status_code == 401:\n            raise Exception(json.dumps({'message':'Unauthorized Access'}))\n        else:\n            raise Exception(response.content)", "response": "This method makes a POST request to Falkonry API server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef put(self, url, entity):\n\n        response = requests.put(\n            self.host + url,\n            entity.to_json(),\n            headers={\n                \"Content-Type\": \"application/json\",\n                'Authorization': 'Bearer ' + self.token,\n                'x-falkonry-source':self.sourceHeader\n            },\n            verify=False\n        )\n        if response.status_code == 200:\n            try:\n                return json.loads(response._content.decode('utf-8'))\n            except Exception as e:\n                json.loads(response.content)\n        elif response.status_code == 401:\n            raise Exception(json.dumps({'message':'Unauthorized Access'}))\n        else:\n            raise Exception(response.content)", "response": "This method makes a PUT request to Falkonry API server and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, url):\n        response = requests.delete(\n            self.host + url,\n            headers={\n              'Authorization': 'Bearer ' + self.token,\n              'x-falkonry-source':self.sourceHeader\n            },\n            verify=False\n        )\n        if response.status_code == 204:\n            return None\n        elif response.status_code == 401:\n            raise Exception(json.dumps({'message':'Unauthorized Access'}))\n        else:\n            raise Exception(response.content)", "response": "This method is used to make a DELETE request to the Falkonry API server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses command line arguments.", "response": "def _parse_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description='Keylogger for Linux + X11')\n    arg = parser.add_argument\n    arg('-s', '--sleep-time', type=float, help='seconds between iterations')\n    arg('-t', '--transform', choices=['spanish', 'english_usa', 'pt_br'])\n    arg('-f', '--file')\n    arg('-l', '--line-buffering', action='store_true')\n    args = parser.parse_args()\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if modifiers pressed are only shifts", "response": "def _only_shifts(self, modifiers):\n        \"\"\"Check if modifiers pressed are only shifts\"\"\"\n        if not modifiers or len(modifiers) > 2:\n            return False\n        if len(modifiers) == 2:\n            return 'left shift' in modifiers and 'right shift' in modifiers\n        if len(modifiers) == 1:\n            return 'left shift' in modifiers or 'right shift' in modifiers"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies Spanish layout to the pressed keys", "response": "def transform(self, keys):\n        \"\"\"Apply Spanish layout to the pressed keys\"\"\"\n        key = keys['regular'][0]\n        modifiers = keys['modifiers']\n\n        try:\n            if not modifiers:\n                if key in self._letters or key in self._digits:\n                    res = key\n                elif key in self._command_keys:\n                    res = '<' + key + '>'\n                else:\n                    res = self._layout['no_mods'][key]\n            elif self._only_shifts(modifiers):\n                if key in self._letters:\n                    res = key.upper()\n                else:\n                    res = self._layout['shift'][key]\n            elif self._only_right_alt(modifiers):\n                res = self._layout['right_alt'][key]\n            else:\n                res = None\n        except KeyError:\n            res = None\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns X11 Keymap as a list of integers", "response": "def get_keymap(self):\n        \"\"\"Returns X11 Keymap as a list of integers\"\"\"\n        self._x11.XQueryKeymap(self._display, self._raw_keymap)\n\n        try:\n            keyboard = [ord(byte) for byte in self._raw_keymap]\n        except TypeError:\n            return None\n\n        return keyboard"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts keys pressed from transformed keymap", "response": "def get_keys(self, keymap):\n        \"\"\"Extract keys pressed from transformed keymap\"\"\"\n        keys = dict(modifiers=[], regular=[])\n\n        # loop on keymap bytes\n        for keymap_index, keymap_byte in enumerate(keymap):\n            try:\n                keymap_values = self._keymap_values_dict[keymap_index]\n            except KeyError:\n                continue\n\n            # loop on keymap_values for that keymap byte\n            for key, value in keymap_values.items():\n                if not keymap_byte & key:\n                    continue\n                elif value in self._modifiers:\n                    keys['modifiers'].append(value)\n                elif not keys['regular']:\n                    keys['regular'].append(value)\n\n        return keys"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n        while True:\n            keymap = self._okeymap.get_keymap()\n            if keymap == self._last_keymap or not keymap:\n                sleep(self._sleep_time)\n                continue\n\n            keys = self._okeymap.get_keys(keymap)\n            if (keys['regular']\n                    and keys['regular'] != self._last_keys['regular']):\n                if self._transformer:\n                    transformed_keys = self._transformer.transform(keys)\n                    if transformed_keys is not None:\n                        self._handler.handle(transformed_keys)\n                else:\n                    self._handler.handle(keys)\n\n            self._last_keymap = keymap\n            self._last_keys = keys\n\n            sleep(self._sleep_time)", "response": "Main loop for the key - related process."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a list of coordinates x y this procedure computes the smallest rectangle that covers all the points.", "response": "def _compute_bounding_box(points):\n    \"\"\"Given the list of coordinates (x,y), this procedure computes\n    the smallest rectangle that covers all the points.\"\"\"\n    (xmin, ymin, xmax, ymax) = (999999, 999999, -999999, -999999)\n    for p in points:\n        xmin = min(xmin, p[0])\n        xmax = max(xmax, p[0])\n        ymin = min(ymin, p[1])\n        ymax = max(ymax, p[1])\n    return (xmin, ymin, xmax, ymax)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        for i in range(0, len(active_canvases)):\n            if active_canvases[i] == self:\n                del active_canvases[i]\n                return", "response": "This method closes the canvas and writes the contents of the associated file to the associated file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening the output file FNAME. Returns tuple of fd NEED_CLOSE and a if the file is closed.", "response": "def open_output(self, fname):\n        \"\"\"Open the output file FNAME. Returns tuple (FD, NEED_CLOSE),\n        where FD is a file (or file-like) object, and NEED_CLOSE is a\n        boolean flag that tells whether FD.close() should be called\n        after finishing writing to the file.\n\n        FNAME can be one of the three things:\n        (1) None, in which case (sys.stdout, False) is returned.\n        (2) A file-like object, in which case (fname, False) is returned.\n        (3) A string, in which case this procedure opens the file and returns\n        (fd, True).\"\"\"\n\n        if not fname:\n            return (sys.stdout, False)\n        elif isinstance(fname, str):\n            return (file(fname, \"wb\"), True)\n        else:\n            if not hasattr(fname, \"write\"):\n                raise Exception(\"Expecting either a filename or a file-like object, but got %s\" % fname)\n            return (fname, False)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _path_polygon(self, points):\n        \"Low-level polygon-drawing routine.\"\n        (xmin, ymin, xmax, ymax) = _compute_bounding_box(points)\n        if invisible_p(xmax, ymax):\n            return\n        self.setbb(xmin, ymin)\n        self.setbb(xmax, ymax)\n\n        self.newpath()\n        self.moveto(xscale(points[0][0]), yscale(points[0][1]))\n        for point in points[1:]:\n            self.lineto(xscale(point[0]), yscale(point[1]))\n        self.closepath()", "response": "Low - level polygon - drawing routine."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws a polygon with EDGE_STYLE fill with PAT and the edges .", "response": "def polygon(self, edge_style, pat, points, shadow=None):\n        \"\"\"Draw a polygon with EDGE_STYLE, fill with PAT, and the edges\n        POINTS. POINTS is a sequence of coordinates, e.g., ((10,10), (15,5),\n        (20,8)). SHADOW is either None or a tuple (XDELTA, YDELTA,\n        fillstyle). If non-null, a shadow of FILLSTYLE is drawn beneath\n        the polygon at the offset of (XDELTA, YDELTA).\"\"\"\n\n        if pat:\n            self.comment(\"POLYGON points=[%s] pat=[%s]\"\n                         % (str(points), str(pat)))\n            (xmin, ymin, xmax, ymax) = _compute_bounding_box(points)\n\n            if shadow:\n                xoff, yoff, shadow_pat = shadow\n                self.gsave()\n                self._path_polygon(list(map(lambda p, xoff=xoff, yoff=yoff: (p[0] + xoff, p[1] + yoff), points)))\n                self.clip_sub()\n                self.fill_with_pattern(shadow_pat, xmin + xoff, ymin + yoff,\n                                       xmax + xoff, ymax + yoff)\n                self.grestore()\n\n            self.gsave()\n            self._path_polygon(points)\n            self.clip_sub()\n            self.fill_with_pattern(pat, xmin, ymin, xmax, ymax)\n            self.grestore()\n        if edge_style:\n            self.comment(\"POLYGON points=[%s] edge=[%s]\"\n                         % (str(points), str(edge_style)))\n            self.set_line_style(edge_style)\n            self._path_polygon(points)\n            self.stroke()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw a rectangle with EDGE_STYLE fill with PAT and the x1 y1 and x2 y2.", "response": "def rectangle(self, edge_style, pat, x1, y1, x2, y2, shadow=None):\n        \"\"\"Draw a rectangle with EDGE_STYLE, fill with PAT, and the\n        bounding box (X1, Y1, X2, Y2).  SHADOW is either None or a\n        tuple (XDELTA, YDELTA, fillstyle). If non-null, a shadow of\n        FILLSTYLE is drawn beneath the polygon at the offset of\n        (XDELTA, YDELTA).\"\"\"\n\n        self.polygon(edge_style, pat, [(x1, y1), (x1, y2), (x2, y2), (x2, y1)],\n                     shadow)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws an ellipsis with line_style and fill pattern.", "response": "def ellipsis(self, line_style, pattern, x, y, radius, ratio=1.0,\n                 start_angle=0, end_angle=360, shadow=None):\n        \"\"\"Draw an ellipsis with line_style and fill PATTERN. The center is \\\n        (X, Y), X radius is RADIUS, and Y radius is RADIUS*RATIO, whose \\\n        default value is 1.0. SHADOW is either None or a tuple (XDELTA,\n        YDELTA, fillstyle). If non-null, a shadow of FILLSTYLE is drawn\n        beneath the polygon at the offset of (XDELTA, YDELTA).\"\"\"\n\n        if invisible_p(x + radius, y + radius * ratio):\n            return\n\n        if pattern:\n            if shadow:\n                x_off, y_off, shadow_pat = shadow\n                self.gsave()\n                self.newpath()\n                self._path_ellipsis(x + x_off, y + y_off, radius, ratio,\n                                    start_angle, end_angle)\n                self.clip_sub()\n                self.fill_with_pattern(shadow_pat,\n                                       x - radius * 2 + x_off,\n                                       y - radius * ratio * 2 + y_off,\n                                       x + radius * 2 + x_off,\n                                       y + radius * ratio * 2 + y_off)\n                self.grestore()\n            self.gsave()\n            self.newpath()\n            self._path_ellipsis(x, y, radius, ratio, start_angle, end_angle)\n            self.clip_sub()\n            self.fill_with_pattern(pattern,\n                                   (x - radius * 2), (y - radius * ratio * 2),\n                                   (x + radius * 2), (y + radius * ratio * 2))\n            self.grestore()\n        if line_style:\n            self.set_line_style(line_style)\n            self.newpath()\n            self._path_ellipsis(x, y, radius, ratio, start_angle, end_angle)\n            self.stroke()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clip_ellipsis(self, x, y, radius, ratio=1.0):\n\n        self.gsave()\n        self.newpath()\n        self.moveto(xscale(x) + nscale(radius), yscale(y))\n        self.path_arc(xscale(x), yscale(y), nscale(radius), ratio, 0, 360)\n        self.closepath()\n        self.__clip_stack.append(self.__clip_box)\n        self.clip_sub()", "response": "Create an elliptical clip region."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a polygonal clip region.", "response": "def clip_polygon(self, points):\n        \"\"\"Create a polygonal clip region. You must call endclip() after\n        you completed drawing. See also the polygon method.\"\"\"\n        self.gsave()\n        self._path_polygon(points)\n        self.__clip_stack.append(self.__clip_box)\n        self.__clip_box = _intersect_box(self.__clip_box, _compute_bounding_box(points))\n        self.clip_sub()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clip(self, x1, y1, x2, y2):\n\n        self.__clip_stack.append(self.__clip_box)\n        self.__clip_box = _intersect_box(self.__clip_box, (x1, y1, x2, y2))\n        self.gsave()\n        self.newpath()\n        self.moveto(xscale(x1), yscale(y1))\n        self.lineto(xscale(x1), yscale(y2))\n        self.lineto(xscale(x2), yscale(y2))\n        self.lineto(xscale(x2), yscale(y1))\n        self.closepath()\n        self.clip_sub()", "response": "Activate a rectangular clip region."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nend the current clip region.", "response": "def endclip(self):\n        \"\"\"End the current clip region. When clip calls are nested, it\n        ends the most recently created crip region.\"\"\"\n        self.__clip_box = self.__clip_stack[-1]\n        del self.__clip_stack[-1]\n        self.grestore()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws a rectangle with rounded four corners. Parameter <radius > specifies the radius of each corner. Parameter fill specifies the fill color of the rectangle.", "response": "def round_rectangle(self, style, fill, x1, y1, x2, y2, radius, shadow=None):\n        \"\"\"Draw a rectangle with rounded four corners. Parameter <radius> specifies the radius of each corner.\"\"\"\n\n        if invisible_p(x2, y2):\n            return\n        self.setbb(x1, y1)\n        self.setbb(x2, y2)\n\n        if fill:\n            if shadow:\n                x_off, y_off, shadow_fill = shadow\n                self.gsave()\n                self.newpath()\n                self._path_round_rectangle(x1 + x_off, y1 + y_off, x2 + x_off, y2 + y_off,\n                                           radius)\n                self.closepath()\n                self.clip_sub()\n                self.fill_with_pattern(shadow_fill, x1 + x_off, y1 + y_off,\n                                       x2 + x_off, y2 + y_off)\n                self.grestore()\n\n            self.gsave()\n            self.newpath()\n            self._path_round_rectangle(x1, y1, x2, y2, radius)\n            self.closepath()\n            self.clip_sub()\n            self.fill_with_pattern(fill, x1, y1, x2, y2)\n            self.grestore()\n        if style:\n            self.set_line_style(style)\n            self.newpath()\n            self._path_round_rectangle(x1, y1, x2, y2, radius)\n            self.closepath()\n            self.stroke()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list(self, **filters):\n        LOG.debug(u'Querying %s by filters=%s', self.model_class.__name__, filters)\n        query = self.__queryset__()\n        perm = build_permission_name(self.model_class, 'view')\n        LOG.debug(u\"Checking if user %s has_perm %s\" % (self.user, perm))\n        query_with_permission = filter(lambda o: self.user.has_perm(perm, obj=o), query)\n        ids = map(lambda o: o.pk, query_with_permission)\n\n        # FIXME: Return to query again without use database\n        queryset = self.__queryset__().filter(pk__in=ids)\n        related = getattr(self, 'select_related', None)\n        if related:\n            queryset = queryset.select_related(*related)\n\n        return queryset", "response": "Returns a queryset filtering objects by user permission."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, pk=None, **filters):\n        LOG.debug(u'Querying (GET) %s by pk=%s and filters=%s', self.model_class.__name__, repr(pk), filters)\n        query = self.model_class.objects.filter(**filters)\n        if pk is None:\n            obj = query.get()\n        else:\n            if (isinstance(pk, basestring) and pk.isdigit()) or isinstance(pk, numbers.Number):\n                obj = query.get(pk=pk)\n            elif 'slug' in self.model_class._meta.get_all_field_names():\n                obj = query.get(slug=pk)\n            else:\n                # pk is not a number and model has no slug. So, object don't exists.\n                raise self.model_class.DoesNotExist()\n\n        perm = build_permission_name(self.model_class, 'view')\n        if not self.user.has_perm(perm, obj=obj):\n            raise PermissionDenied(u'User %s has no permission %s for object %s' % (self.user, perm, obj))\n        return obj", "response": "Retrieve an object instance by primary key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _positionalArgumentKeyValueList(self,\n                                        originalConstructorExpectedArgList,\n                                        syntheticMemberList,\n                                        argTuple):\n        \"\"\"Transforms args tuple to a dictionary mapping argument names to values using original constructor\npositional args specification, then it adds synthesized members at the end if they are not already present.\n    :type syntheticMemberList: list(SyntheticMember)\n    :type argTuple: tuple\n\"\"\"\n\n        # First, the list of expected arguments is set to original constructor's arg spec. \n        expectedArgList = copy.copy(originalConstructorExpectedArgList)\n\n        # ... then we append members that are not already present.\n        for syntheticMember in syntheticMemberList:\n            memberName = syntheticMember.memberName()\n            if memberName not in expectedArgList:\n                expectedArgList.append(memberName)\n\n        # Makes a list of tuples (argumentName, argumentValue) with each element of each list (expectedArgList, argTuple)\n        # until the shortest list's end is reached.\n        positionalArgumentKeyValueList = list(zip(expectedArgList, argTuple))\n\n        # Add remanining arguments (those that are not expected by the original constructor).\n        for argumentValue in argTuple[len(positionalArgumentKeyValueList):]:\n            positionalArgumentKeyValueList.append((None, argumentValue))\n\n        return positionalArgumentKeyValueList", "response": "Transforms args tuple to a dictionary mapping argument names to values using original constructor\npositional args specification."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _consumeArgument(self,\n                         memberName,\n                         positionalArgumentKeyValueList,\n                         kwargs,\n                         defaultValue):\n        \"\"\"Returns member's value from kwargs if found or from positionalArgumentKeyValueList if found\nor default value otherwise.\n    :type memberName: str\n    :type positionalArgumentKeyValueList: list(tuple)\n    :type kwargs: dict(string:*)\n\"\"\"\n        # Warning: we use this dict to simplify the usage of the key-value tuple list but be aware that this will\n        # merge superfluous arguments as they have the same key : None.\n        positionalArgumentDict = dict(positionalArgumentKeyValueList)\n\n        if memberName in kwargs:\n            return kwargs[memberName]\n\n        if memberName in positionalArgumentDict:\n            return positionalArgumentDict[memberName]\n\n        return defaultValue", "response": "Returns member s value from kwargs if found or from positionalArgumentKeyValueList if found or from defaultValue if not."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _filterArgsAndKwargs(\n            self,\n            originalConstructorExpectedArgList,\n            syntheticMemberList,\n            positionalArgumentKeyValueList,\n            keywordedArgDict):\n        \"\"\"Returns a tuple with variadic args and keyworded args after removing arguments that have been used to\nsynthesize members and that are not expected by the original constructor.\nIf original constructor accepts variadic args, all variadic args are forwarded.\nIf original constructor accepts keyworded args, all keyworded args are forwarded.\n    :type originalConstructorExpectedArgList: list(str)\n    :type syntheticMemberList: list(SyntheticMember)\n    :type positionalArgumentKeyValueList: list(tuple)\n    :type keywordedArgDict: dict(string:*)\n\"\"\"\n\n        # List is initialized with all variadic arguments.\n        positionalArgumentKeyValueList = copy.copy(positionalArgumentKeyValueList)\n\n        # Warning: we use this dict to simplify the usage of the key-value tuple list but be aware that this will\n        # merge superfluous arguments as they have the same key : None.\n        positionalArgumentDict = dict(positionalArgumentKeyValueList)\n\n        # Dict is initialized with all keyworded arguments.\n        keywordedArgDict = keywordedArgDict.copy()\n\n        for syntheticMember in syntheticMemberList:\n            argumentName = syntheticMember.memberName()\n\n            # Argument is expected by the original constructor.\n            if argumentName in originalConstructorExpectedArgList:\n                continue\n\n            # We filter args only if original constructor does not expected variadic args. \n            if argumentName in positionalArgumentDict:\n                positionalArgumentKeyValueList = list(filter(lambda pair: pair[0] != argumentName,\n                                                             positionalArgumentKeyValueList))\n\n            # We filter args only if original constructor does not expected keyworded args. \n            if argumentName in keywordedArgDict:\n                del keywordedArgDict[argumentName]\n\n        positionalArgumentTuple = tuple([value for _, value in positionalArgumentKeyValueList])\n        return positionalArgumentTuple, keywordedArgDict", "response": "Returns a tuple with variadic args and keyworded args after removing arguments that have not been used to\nsynthesize members and that are not expected by the original constructor."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging to file (usually stderr), with progname: <log>", "response": "def shout(msg, f=sys.stderr):\n    '''Log to file (usually stderr), with progname: <log>'''\n    print >> f, \"{0}: {1}\".format(_PROG, msg)\n    f.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nthreads that reloads the current process.", "response": "def reloader_thread(softexit=False):\n    \"\"\"If ``soft_exit`` is True, we use sys.exit(); otherwise ``os_exit``\n    will be used to end the process.\n    \"\"\"\n    while RUN_RELOADER:\n        if code_changed():\n            # force reload\n            if softexit:\n                sys.exit(3)\n            else:\n                os._exit(3)\n        time.sleep(1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef python_reloader(main_func, args, kwargs, check_in_thread=True):\n    if os.environ.get(\"RUN_MAIN\") == \"true\":\n        if check_in_thread:\n            thread.start_new_thread(reloader_thread, (), {'softexit': False})\n        else:\n            thread.start_new_thread(main_func, args, kwargs)\n\n        try:\n            if not check_in_thread:\n                reloader_thread(softexit=True)\n            else:\n                main_func(*args, **kwargs)\n        except KeyboardInterrupt:\n            pass\n    else:\n        try:\n            sys.exit(restart_with_reloader())\n        except KeyboardInterrupt:\n            pass", "response": "This function is used to run a python function in a separate thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndrops - in replacement for pycontracts. contract decorator except that it supports locally - visible types Insights.", "response": "def magic_contract(*args, **kwargs):\n    \"\"\"Drop-in replacement for ``pycontracts.contract`` decorator, except that it supports locally-visible types\n\n    :param args: Arguments to pass to the ``contract`` decorator\n    :param kwargs: Keyword arguments to pass to the ``contract`` decorator\n    :return: The contracted function\n    \"\"\"\n    def inner_decorator(f):\n        for name, val in f.__globals__.items():\n            if not name.startswith('_') and isinstance(val, type):\n                safe_new_contract(name, val)\n        return contract(*args, **kwargs)(f)\n\n    return inner_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a value in the HL7 dictionary.", "response": "def get(self, terser):\n        \"\"\"\n            Get a value in the HL7 dictionary. The terser can be fully qualified or not.\n            Fully qualified : OBR[1]-10-01\n            Simpliest form  : OBR-10-1 (in this case, 1 uniq segment OBR is present in the HL7 message)\n\n            :return : the value or a list of values. Otherwise None.\n        \"\"\"\n        key = terser\n        # if the expression in not found n the qualified names\n        # find the alias\n        if terser not in self.data and terser in self.aliasKeys:\n            key = self.aliasKeys[terser]\n\n        value = self.data.get(key, None)\n\n        # if the value is not found, it can be a partial terser\n        if value:\n            return value\n        else:\n            # find the values : simple startswith : should it be a regexp ? (more powerful, more slower)\n            values = list(filter(lambda k: k.startswith(key), self.aliasKeys))\n            if len(values) > 0:\n                return values\n            else:\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the different keys for 1 defined segment", "response": "def getSegmentKeys(self, segment):\n        \"\"\"\n            Get the different keys for 1 defined segment\n            :param segment: Segment to find. Ex : PV1, PID\n        \"\"\"\n        return list(filter(lambda x: x.startswith(segment), self.getAliasedKeys()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a printable view of the dictionary", "response": "def toString(self):\n        \"\"\"\n            Return a printable view of the dictionary\n        \"\"\"\n        result = []\n        k, v = self.optimalRepr()\n        longest = reduce(lambda x, y: x if x > len(y) else len(y), k, 0)\n        for ind in range(len(k)):\n            result.append(\"%s : %s\" % (k[ind].ljust(longest), v[ind]))\n        return \"\\n\".join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setSegmentsMap(self, segmentNameCount, lineMap):\n        self.segmentNameCount = segmentNameCount\n        self.lineMap = lineMap\n\n        #Build an alias map for simplicity in get\n        # PID is an alias of PID[1] if only 1 PID segment is present\n        for segName in segmentNameCount.keys():\n            if segmentNameCount[segName] == 1:\n                self.aliasSegmentName[segName] = segName+\"[1]\"\n                self.aliasSegmentName[segName+\"[1]\"] = segName", "response": "Set the segments map for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef name(value):\n    if value is None:\n        return 'any'\n    for (test, name) in TESTS:\n        if isinstance(value, test):\n            return name\n    return 'string'", "response": "Get the string title for a particular type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a specific key from the list of available classes.", "response": "def get(cls, key):\n        \"\"\"\n        str, int or Enum => Enum\n        \"\"\"\n        if isinstance(key, Enum) and not isinstance(key, cls):\n            raise TypeError(\"Cannot type cast between enums\")\n        if isinstance(key, int):\n            if not int(key) in cls._values:\n                raise KeyError(\"There is no enum with key %d\" % key)\n            return cls._values[key]\n        if isinstance(key, (str, unicode)):\n            if not key in cls._names:\n                raise KeyError(\"There is no enum with name %s\" % key)\n            return cls._names[key]\n        raise TypeError(\"Invalid enum key type: %s\"\n                         % (key.__class__.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compose_func(func, args_func=lambda req_info: [req_info.index]):\n    return FuncInfo(func=func, args_func=args_func)", "response": "Compose a function to be used in ZODB."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef analyzers_mapping(cls):\n        import analyzers\n        return cls(\n            title_tags=_compose_func(analyzers.get_title_tags),\n            place_tags=_compose_func(\n                analyzers.get_place_tags,\n                lambda req_info: (req_info.index, req_info.domain)\n            ),\n            lang_tags=_compose_func(analyzers.get_lang_tags),\n            keyword_tags=_compose_func(analyzers.get_keyword_tags),\n            # yep, authors of webpage are actually publishers\n            publisher_tags=_compose_func(analyzers.get_author_tags),\n            annotation_tags=_compose_func(analyzers.get_annotation_tags),\n            creation_dates=_compose_func(\n                analyzers.get_creation_date_tags,\n                lambda req_info: (req_info.url, req_info.domain)\n            ),\n        )", "response": "Returns an analyzers mapping all the properties of the current locale to the ones that are defined in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mapping(self):  # TODO: rename to _as_dict\n        return {\n            key: val\n            for key, val in self.__dict__.iteritems()\n            if val\n        }", "response": "Convert the class to dict.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timed_call(func, *args, log_level='DEBUG', **kwargs):\n    start = time()\n    r = func(*args, **kwargs)\n    t = time() - start\n    log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t))\n    return r", "response": "Logs a function s run time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tic(log_level='DEBUG', fmt=\"{file}:{line} - {message} - {diff:0.6f}s (total={total:0.1f}s)\", verbose=True):\n    first_time = last_time = time()\n\n    def toc(message=None):\n        \"\"\"A function that reports run times\n\n        :param message: The message to print with this particular runtime\n        :return: The time difference (in seconds) since the last tic or toc\n        \"\"\"\n        nonlocal last_time\n\n        now = time()\n        diff = now - last_time\n        total = now - first_time\n\n        if verbose:\n            file, line, func, code_text = traceback.extract_stack(limit=2)[0]\n            log(log_level, fmt.format(**locals()))\n\n        last_time = time()\n        return diff\n\n    return toc", "response": "A minimalistic printf - type timing utility."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef source_set(method_name):\n\n    def source_set(value, context, **_params):\n        method = getattr(context[\"model\"].source, method_name)\n        return _set(method, context[\"key\"], value, (), {})\n\n    return source_set", "response": "Creates a setter that will call the source method with the context s\n    key as first parameter and the value as second parameter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a setter that will set the specified source attribute to the current value.", "response": "def source_attr(attr_name):\n    \"\"\"\n    Creates a setter that will set the specified source attribute\n    to the current value.\n    @param attr_name: the name of an attribute belonging to the source.\n    @type attr_name: str\n    \"\"\"\n\n    def source_attr(value, context, **_params):\n        setattr(context[\"model\"].source, attr_name, value)\n        return _attr()\n\n    return source_attr"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a setter that will set the source attribute with context s key for name to the current value.", "response": "def source_setattr():\n    \"\"\"\n    Creates a setter that will set the source attribute with context's key\n    for name to the current value.\n    \"\"\"\n\n    def source_setattr(value, context, **_params):\n        setattr(context[\"model\"].source, context[\"key\"], value)\n        return _attr()\n\n    return source_setattr"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef model_set(method_name):\n\n    def model_set(value, context, **_params):\n        method = getattr(context[\"model\"], method_name)\n        return _set(method, context[\"key\"], value, (), {})\n\n    return model_set", "response": "Creates a setter that will call the model method with the context s\n    key as first parameter and the value as second parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef model_attr(attr_name):\n\n    def model_attr(value, context, **_params):\n        setattr(context[\"model\"], attr_name, value)\n        return _attr()\n\n    return model_attr", "response": "Creates a setter that will set the specified model attribute\n    to the current value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef model_setattr():\n\n    def model_setattr(value, context, **_params):\n        setattr(context[\"model\"], context[\"key\"], value)\n        return _attr()\n\n    return model_setattr", "response": "Creates a setter that will set the model attribute with context s key\n    for name to the current value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a setter that will call the action method with the context s key as first parameter and the value as second parameter.", "response": "def action_set(method_name):\n    \"\"\"\n    Creates a setter that will call the action method with the context's\n    key as first parameter and the value as second parameter.\n    @param method_name: the name of a method belonging to the action.\n    @type method_name: str\n    \"\"\"\n\n    def action_set(value, context, **_params):\n        method = getattr(context[\"action\"], method_name)\n        return _set(method, context[\"key\"], value, (), {})\n\n    return action_set"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a setter that will set the specified action attribute to the current value.", "response": "def action_attr(attr_name):\n    \"\"\"\n    Creates a setter that will set the specified action attribute\n    to the current value.\n    @param attr_name: the name of an attribute belonging to the action.\n    @type attr_name: str\n    \"\"\"\n\n    def action_attr(value, context, **_params):\n        setattr(context[\"action\"], attr_name, value)\n        return _attr()\n\n    return action_attr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef action_setattr():\n\n    def action_setattr(value, context, **_params):\n        setattr(context[\"action\"], context[\"key\"], value)\n        return _attr()\n\n    return action_setattr", "response": "Returns a setter that will set the action attribute with context s key\n    for name to the current value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a setter that will call the view method with the context s key as first parameter and the value as second parameter.", "response": "def view_set(method_name):\n    \"\"\"\n    Creates a setter that will call the view method with the context's\n    key as first parameter and the value as second parameter.\n    @param method_name: the name of a method belonging to the view.\n    @type method_name: str\n    \"\"\"\n\n    def view_set(value, context, **_params):\n        method = getattr(context[\"view\"], method_name)\n        return _set(method, context[\"key\"], value, (), {})\n\n    return view_set"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef view_attr(attr_name):\n\n    def view_attr(value, context, **_params):\n        setattr(context[\"view\"], attr_name, value)\n        return _attr()\n\n    return view_attr", "response": "Creates a setter that will set the specified view attribute to the current value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a setter that will set the view attribute with context s key for name to the current value.", "response": "def view_setattr():\n    \"\"\"\n    Creates a setter that will set the view attribute with context's key\n    for name to the current value.\n    \"\"\"\n\n    def view_setattr(value, context, **_params):\n        setattr(context[\"view\"], context[\"key\"], value)\n        return _attr()\n\n    return view_setattr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsanitize the current settings of a LISP mapping entry.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix where possible.\n        '''\n        # Priority:  each RLOC is assigned a unicast priority.  Lower values\n        # are more preferable.  When multiple RLOCs have the same priority,\n        # they MAY be used in a load-split fashion.  A value of 255 means\n        # the RLOC MUST NOT be used for unicast forwarding.\n        if not isinstance(self.priority, numbers.Integral) \\\n        or self.priority < 0 or self.priority > 255:\n            raise ValueError('Invalid priority')\n\n        # Weight:  when priorities are the same for multiple RLOCs, the weight\n        # indicates how to balance unicast traffic between them.  Weight is\n        # encoded as a relative weight of total unicast packets that match\n        # the mapping entry.  For example if there are 4 locators in a\n        # locator set, where the weights assigned are 30, 20, 20, and 10,\n        # the first locator will get 37.5% of the traffic, the 2nd and 3rd\n        # locators will get 25% of traffic and the 4th locator will get\n        # 12.5% of the traffic.  If all weights for a locator-set are equal,\n        # receiver of the Map-Reply will decide how to load-split traffic.\n        # See Section 6.5 for a suggested hash algorithm to distribute load\n        # across locators with same priority and equal weight values.\n        #\n        # WARNING: Cisco implementations limit the weight to the range 0-100\n        if not isinstance(self.weight, numbers.Integral) \\\n        or self.weight < 0 or self.weight > 255:\n            raise ValueError('Invalid weight')\n\n        # M Priority:  each RLOC is assigned a multicast priority used by an\n        # ETR in a receiver multicast site to select an ITR in a source\n        # multicast site for building multicast distribution trees.  A value\n        # of 255 means the RLOC MUST NOT be used for joining a multicast\n        # distribution tree.  For more details, see [MLISP].\n        if not isinstance(self.m_priority, numbers.Integral) \\\n        or self.m_priority < 0 or self.m_priority > 255:\n            raise ValueError('Invalid multicast priority')\n\n        # M Weight:  when priorities are the same for multiple RLOCs, the\n        # weight indicates how to balance building multicast distribution\n        # trees across multiple ITRs.  The weight is encoded as a relative\n        # weight (similar to the unicast Weights) of total number of trees\n        # built to the source site identified by the EID-prefix.  If all\n        # weights for a locator-set are equal, the receiver of the Map-Reply\n        # will decide how to distribute multicast state across ITRs.  For\n        # more details, see [MLISP].\n        if not isinstance(self.m_weight, numbers.Integral) \\\n        or self.m_weight < 0 or self.m_weight > 255:\n            raise ValueError('Invalid weight')\n\n        # L: when this bit is set, the locator is flagged as a local locator to\n        # the ETR that is sending the Map-Reply.  When a Map-Server is doing\n        # proxy Map-Replying [LISP-MS] for a LISP site, the L bit is set to\n        # 0 for all locators in this locator-set.\n        if not isinstance(self.local, bool):\n            raise ValueError('Local flag must be a boolean')\n\n        # p: when this bit is set, an ETR informs the RLOC-probing ITR that the\n        # locator address, for which this bit is set, is the one being RLOC-\n        # probed and MAY be different from the source address of the Map-\n        # Reply.  An ITR that RLOC-probes a particular locator, MUST use\n        # this locator for retrieving the data structure used to store the\n        # fact that the locator is reachable.  The \"p\" bit is set for a\n        # single locator in the same locator set.  If an implementation sets\n        # more than one \"p\" bit erroneously, the receiver of the Map-Reply\n        # MUST select the first locator.  The \"p\" bit MUST NOT be set for\n        # locator-set records sent in Map-Request and Map-Register messages.\n        if not isinstance(self.probed_locator, bool):\n            raise ValueError('Probed Locator flag must be a boolean')\n\n        # R: set when the sender of a Map-Reply has a route to the locator in\n        # the locator data record.  This receiver may find this useful to\n        # know if the locator is up but not necessarily reachable from the\n        # receiver's point of view.  See also Section 6.4 for another way\n        # the R-bit may be used.\n        if not isinstance(self.reachable, bool):\n            raise ValueError('Reachable flag must be a boolean')\n\n        # Locator:  an IPv4 or IPv6 address (as encoded by the 'Loc-AFI' field)\n        # assigned to an ETR.  Note that the destination RLOC address MAY be\n        # an anycast address.  A source RLOC can be an anycast address as\n        # well.  The source or destination RLOC MUST NOT be the broadcast\n        # address (255.255.255.255 or any subnet broadcast address known to\n        # the router), and MUST NOT be a link-local multicast address.  The\n        # source RLOC MUST NOT be a multicast address.  The destination RLOC\n        # SHOULD be a multicast address if it is being mapped from a\n        # multicast destination EID.\n\n        if isinstance(self.address, (IPv4Address, IPv6Address)):\n            addresses = [self.address]\n        elif isinstance(self.address, LCAFAddress):\n            addresses = self.address.get_addresses()\n        else:\n            raise ValueError('Locator must be an (LCAF) IPv4 or IPv6 address')\n\n        for address in addresses:\n            if isinstance(self.address, IPv4Address):\n                if address == IPv4Address(u'255.255.255.255'):\n                    raise ValueError('Locator must not be the broadcast '\n                                     'address')\n\n                if address in IPv4Network(u'224.0.0.0/24'):\n                    raise ValueError('Locator must not be a link-local '\n                                     'multicast address')\n\n            elif isinstance(self.address, IPv6Address):\n                if address in IPv6Network(u'ff02::/16') \\\n                or address in IPv6Network(u'ff12::/16'):\n                    raise ValueError('Locator must not be a link-local '\n                                     'multicast address')\n\n            else:\n                raise ValueError('Locator must be an IPv4 or IPv6 address')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_bytes(cls, bitstream):\n        '''\n        Parse the given record and update properties accordingly\n        '''\n        record = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the priorities and weights\n        (record.priority, record.weight, record.m_priority,\n         record.m_weight) = bitstream.readlist('4*uint:8')\n\n        # Read over unused flags\n        record._reserved1 = bitstream.read(13)\n\n        # Read the flags\n        (record.local,\n         record.probed_locator,\n         record.reachable) = bitstream.readlist('3*bool')\n\n        # Read the locator\n        record.address = read_afi_address_from_bitstream(bitstream)\n\n        # Verify that the properties make sense\n        record.sanitize()\n\n        return record", "response": "Parse the given record and update properties accordingly\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_bitstream(self):\n        '''\n        Create bitstream from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the priorities and weights\n        bitstream = BitArray('uint:8=%d, uint:8=%d, uint:8=%d, '\n                             'uint:8=%d' % (self.priority,\n                                            self.weight,\n                                            self.m_priority,\n                                            self.m_weight))\n\n        # Add padding\n        bitstream += self._reserved1\n\n        # Add the flags\n        bitstream += BitArray('bool=%d, bool=%d, bool=%d'\n                              % (self.local,\n                                 self.probed_locator,\n                                 self.reachable))\n\n        # Add the locator\n        bitstream += get_bitstream_for_afi_address(self.address)\n\n        return bitstream", "response": "Create bitstream from properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to return the PSD of the detector described by detectorName.", "response": "def GetDetectorPSD(detectorName, LIGO3FLAG=0):\n    \"\"\" GetDetectorPSD - function to return the PSD of the detector described by\n\tdetectorName.\n\n\tdetectorName - Name of required GW IFO.  Can be 'H1', 'L1', 'V1', 'I1',\n                       or 'K1'.\n\tLIGO3FLAG - Set to 1 to use LIGO3 PSD instead of aLIGO PSD for H1, L1\n        and I1 detectors.\n\n\tReturns PSD - the noise PSD for the detector described by detectorName.\n\n        Sarah Gossan 2012. Last updated 02/18/14. \"\"\"\n\n    # H1, L1 or I1 - use aLIGO ZERODET_HIGHP configuration (fLow = 9Hz)\n    # Noise curve is super complicated so just load in PSD file for now\n    if detectorName == 'H1' or detectorName == 'L1' or detectorName == 'I1':\n        if LIGO3FLAG:\n            # Read in PSD\n            PSD = np.loadtxt('LIGO3_PSD.txt')\n        else:\n            # Read in PSD\n            PSD = np.loadtxt('ZERO_DET_high_P_PSD.txt')\n\t# Only want second column of file\n        PSD = PSD[:,1]\n    # V1 - use analytical expression for AdVirgo (fLow = 10Hz)\n    elif detectorName == 'V1':\n        # Use analytical expression from arXiv:1202.4031v2\n\tx = np.linspace(0,N_fd-1,num=N_fd)*dF/300.\n        x[0] = x[1] # Not going to use f=0Hz component anyway, but this stops \n\t\t    # the log fn complaining\n\tx = np.log(x)\n\txSq = x*x\n     \tasd = 1.259e-24*(0.07*np.exp(-0.142 - 1.437*x + 0.407*xSq) + \\\n                         3.1*np.exp(-0.466 - 1.043*x - 0.548*xSq) + \\\n                         0.4*np.exp(-0.304 + 2.896*x - 0.293*xSq) + \\\n                         0.09*np.exp(1.466 + 3.722*x - 0.984*xSq))\n        PSD = asd**2 \n    # K1 - use analytical expression for KAGRA (fLow = 10Hz) \n    elif detectorName == 'K1':\n\t# Use analytical expression from arXiv:1202.4031v2\n\tx = np.linspace(0,N_fd-1,num=N_fd)*dF/300.\n        x[0] = x[1] # Not going to use f=0Hz component anyway, but this stops \n                    # the log fn complaining\n        x = np.log(x)\n        xSq = x*x\n\tasd = 6.499e-25*(9.72e-9*np.exp(-1.43 - 9.88*x - 0.23*xSq) + \\\n\t\t    \t 1.17*np.exp(0.14 - 3.10*x - 0.26*xSq) + \\\n\t\t\t 1.70*np.exp(0.14 + 1.09*x - 0.013*xSq) + \\\n\t\t\t 1.25*np.exp(0.071 + 2.83*x - 4.91*xSq))\n        PSD = asd**2\n          \n    return PSD"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GenerateGaussianNoise(PSD):\n\n    Noise = np.zeros((N_fd),complex)\n    # Generate noise from PSD \n    Real = np.random.randn(N_fd)*np.sqrt(PSD/(4.*dF))\n    Imag = np.random.randn(N_fd)*np.sqrt(PSD/(4.*dF))\n    Noise = Real + 1j*Imag\n\n    return Noise", "response": "Generates a complex Fourier domain Gaussian noise from a detector PSD."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ComputeAntennaResponse(theta, phi, psi, detRespTensor):\n\n    # Define axes of wave frame in terms of axes of Earth-centered axes and\n    # source angles\n    X = np.zeros(3)\n    Y = np.zeros(3)\n    X[0] = np.sin(phi)*np.cos(psi) - np.sin(psi)*np.cos(phi)*np.cos(theta)\n    X[1] = -np.cos(phi)*np.cos(psi) - np.sin(psi)*np.sin(phi)*np.cos(theta)\n    X[2] = np.sin(psi)*np.sin(theta)\n    Y[0] = -np.sin(phi)*np.sin(psi) - np.cos(psi)*np.cos(phi)*np.cos(theta)\n    Y[1] = np.cos(phi)*np.sin(psi) - np.cos(psi)*np.sin(phi)*np.cos(theta)\n    Y[2] = np.sin(theta)*np.cos(psi)\n    \n    # Construct polarisation vectors e+,x as\n    # e+ = (X \\outerprod X - Y \\outerprod Y)\n    # ex = (X \\outerprod Y + Y \\outerprod X)\n    ep = np.zeros((3,3),float)\n    ec = np.zeros((3,3),float)\n    \n    for i in range(0,3):\n        for j in range(0,3):\n\t    ep[i,j] = X[i]*X[j] - Y[i]*Y[j]\n\t    ec[i,j] = X[i]*Y[j] + Y[i]*X[j]\n\n    # Construct Fp,Fc as \n    # Fp = \\sum_ij(D_ij ep_ij) \n    # Fc = \\sum_ij(D_ij ec_ij)\n    Fp = 0.\n    Fc = 0.\n    for i in range(0,3):\n\tfor j in range(0,3):\n\t    Fp += detRespTensor[i,j]*ep[i,j]\n \t    Fc += detRespTensor[i,j]*ec[i,j]\n\n    return Fp,Fc", "response": "Compute the F + x of a detector at a given location."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the time difference between two detectors and a source at a given geocenter at a given time.", "response": "def ComputeArrivalTimeDifference(RA, Dec, GPSTime, Det1Pos, Det2Pos=([0,0,0])):\n    \"\"\" ComputeArrivalTimeDifference - function to compute the difference in\n\tarrival times in a GW signal from a source located at celestial coordinates\n\t(RA,Dec) that reaches the geocenter at GPSTime, between two detectors \n\tlocated at Det1Pos and Det2Pos.\n\n\tRA - Right ascension of source [radians].\n\tDec - Declination of source [radians].\n        GPSTime - GPS time that the GW signal from the source reached the\n\t\t  geocenter.\n\tDet1Pos - (3,) array. Position vector of detector 1.\n\n\t################ Optional inputs #####################\n\tDet2Pos - (3,) array. Position vector of detector 2 (default =\n\t          ([0,0,0]), the position vector of the geocenter.  In this\n\t\t  case, ComputeArrivalTimeDifference returns the time delay of \n\t\t  the source arrival time from the geocenter).\n\n\tReturns deltaT - the difference in arrival times between detectors\n\t\t\t located at Det1Pos and Det2Pos.  This is positive when\n\t\t\t the signal arrives at Det1Pos *after* Det2Pos, and negative \n\t\t\t when the signal arrives at Det1Pos before Det2Pos.\n\n        Sarah Gossan 2012.  Adapted from TimeDelay.c, written by Jolien Creighton, \n\tDavid Chin, Steven Fairhurst, Kipp Cannon, Alexander Dietz, Drew Keppel\n\t2007. Last updated 02/18/14. \"\"\"\n\n    # Compute GMST for GPSTime\n    GMST = ComputeGMST(GPSTime)\n\n    # Get Greenwich hour angle from RA and GMST\n    GHA = GMST - RA\n\n    # Compute unit vector pointing from geocenter to source\n    eHatSrc = np.zeros(3)\n    eHatSrc[0] = np.cos(Dec)*np.cos(GHA)\n    eHatSrc[1] = -np.cos(Dec)*np.sin(GHA)\n    eHatSrc[2] = np.sin(Dec)\n\n    # Get position of detector 2 with respect to detector 1\n    Det21Pos = Det2Pos - Det1Pos\n\n    # Dot source vector into relative detector position and divide by speed of\n    # light to get difference in arrival time\n    deltaT = np.dot(eHatSrc,Det21Pos)/c\n\n    return deltaT"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing light travel time between two detectors at positions Det1Pos and Det2Pos.", "response": "def ComputeLightTravelTime(Det1Pos, Det2Pos):\n    \"\"\" ComputeLightTravelTime - function to compute light travel time between\n\ttwo GW detectors at positions Det1Pos and Det2Pos.\n\n\tDet1Pos - (3,) array. Position vector of detector 1.\n\tDet2Pos - (3,) array. Position vector of detector 2.\n\n\tReturns travelTime - Light travel time between two GW detectors at\n\t\t\t     positions Det1Pos and Det2Pos [s].\n\n        Sarah Gossan 2012. Adapted from TimeDelay.c, written by Jolien\n\tCreighton, David Chin, Steven Fairhurst, Kipp Cannon, Alexander Dietz, \n\tDrew Keppel 2007.\"\"\"\n\n    # Get relative position vector\n    Det21Pos = Det2Pos - Det1Pos\n  \n    # Dot difference vector into itself to get magnitude of detector separation\n    dist = np.sqrt(np.dot(Det21Pos,Det21Pos))\n\n    # Normalise with speed of light\n    travelTime = dist/c\n\n    return travelTime"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an astronomical source to theta and phi in the geocentric fields.", "response": "def ConvertRADecToThetaPhi(RA, Dec, GPSTime): \n    \"\"\" ConvertRADecToThetaPhi - function to convert right ascension and \n        declination of an astronomical source to theta and phi in the geocentric \n        coordinate system. \n            \n        RA - Right ascension of source. \n        Dec - Declination of source. \n        GPSTime - GPS time that the GW signal from the source reached the\n\t\t  geocenter. \n                \n        Returns Theta - Polar angle of source's sky position in geocentric \n                        coordinates. \n                Phi - Azimuthal angle of source's sky position in geocentric \n                      coordinates. \n            \n        Sarah Gossan 2012. \"\"\" \n                \n    # Get Greenwich mean sidereal time corresponding to GPSTime \n    GMST = ComputeGMST(GPSTime) \n            \n    # RA -> Phi\n    Phi = RA - GMST\n            \n    # Dec -> Theta\n    Theta = np.pi/2. - Dec\n            \n    return Theta,Phi"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the Greenwich mean sidereal time from the GPS time.", "response": "def ComputeGMST(GPSTime):\n    \"\"\" ComputeGMST - function to compute the Greenwich mean sidereal time from\n                      the GPS time.\n\n        GPSTime - GPS time that the GW signal from the source reached the\n                  geocenter.\n\n        Returns GMST - the Greenwich mean sidereal time corresponding to\n                       GPSTime.\n\n        Sarah Gossan 2012. \"\"\"\n\n    # Difference in Julian Date between GPSTime and the J2000.0 epoch\n    # Subtract half a day as Julian Days start at noon\n    D = np.round((GPSTime - EpochJ2000_0_UTC)/secPerDay) - 0.5\n\n    # Number of Julian centuries since J2000.0 epoch\n    T = D/36525\n\n    # 1st approximation to GMST without corrections for leap seconds\n    GMST0 = 6.697374558 + 2400.051336*T + 0.000025862*T*T\n    # Keep within range [0,24]hrs\n    GMST0 = np.mod(GMST0,24)\n\n    # Corrections for leap seconds\n    UTCSec = GPSTime - EpochJ2000_0_UTC - secPerDay/2 - \\\n             LeapSeconds_2012_EpochJ2000\n    UTCHr = np.mod(UTCSec/3600,24)\n\n    # Add corrections and keep within [0,24]hr range\n    GMST = GMST0 + UTCHr*1.002737909\n    GMST = np.mod(GMST,24)\n\n    # Convert from hours to degrees to radians\n    GMST *= 15.*(np.pi/180.)\n\n    return GMST"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef LikelihoodFunction(Template, Data, PSD, detRespP, detGCDelay=0):\n\n    # Correct template for geocenter delay and antenna response function\n    if detGCDelay:\n        phaseGCDelay = -2.*np.pi*np.linspace(0,N_fd-1,num=N_fd)*dF*detGCDelay*1j \n\tTemplate *= phaseGCDelay\n    Template *= detRespP\n    # Calculate logL - simple Gaussian\n    logL = -2.*dF*np.sum(pow(abs(Data[lowBin:] - Template[lowBin:]),2.)/\\\n\t   PSD[lowBin:])\n\n    return logL", "response": "Returns the likelihood of livePoint given Data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lazy_import(module_name, to_import):\n    module = importlib.import_module(module_name)\n    import_mapping = {}\n    for name in to_import:\n        importing, _, binding = name.partition(' as ')\n        if not binding:\n            _, _, binding = importing.rpartition('.')\n        import_mapping[binding] = importing\n\n    def __getattr__(name):\n        if name not in import_mapping:\n            raise ModuleAttributeError(module_name, name)\n        importing = import_mapping[name]\n        # imortlib.import_module() implicitly sets submodules on this module as\n        # appropriate for direct imports.\n        imported = importlib.import_module(importing,\n                                           module.__spec__.parent)\n        setattr(module, name, imported)\n        return imported\n\n    return module, __getattr__", "response": "Returns the importing module and a callable for lazy importing."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a collection of attributes on a module.", "response": "def filtered_attrs(module, *, modules=False, private=False, dunder=False,\n                   common=False):\n    \"\"\"Return a collection of attributes on 'module'.\n\n    If 'modules' is false then module instances are excluded. If 'private' is\n    false then attributes starting with, but not ending in, '_' will be\n    excluded. With 'dunder' set to false then attributes starting and ending\n    with '_' are left out. The 'common' argument controls whether attributes\n    found in STANDARD_MODULE_ATTRS are returned.\n\n    \"\"\"\n    attr_names = set()\n    for name, value in module.__dict__.items():\n        if not common and name in STANDARD_MODULE_ATTRS:\n            continue\n        if name.startswith('_'):\n            if name.endswith('_'):\n                if not dunder:\n                    continue\n            elif not private:\n                continue\n        if not modules and isinstance(value, types.ModuleType):\n            continue\n        attr_names.add(name)\n    return frozenset(attr_names)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filtered_dir(module_name, *, additions={}, **kwargs):\n    module = importlib.import_module(module_name)\n\n    def __dir__():\n        attr_names = set(filtered_attrs(module, **kwargs))\n        attr_names.update(additions)\n        return sorted(attr_names)\n\n    return __dir__", "response": "Returns a callable appropriate for __dir__."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the type name of the key.", "response": "def get_type(self):\n        \"\"\"\n        Get the type name of key\n        \"\"\"\n        for typechar, typename in self.KEY_TYPE_CHOICES:\n            if typechar == self.key_type:\n                return typename"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_suitable(self, request):\n        if self.key_type:\n            validation = KEY_TYPE_VALIDATIONS.get( self.get_type() )\n            return validation( request ) if validation else None\n        return True", "response": "Checks if key is suitable for given request according to key type and request s user agent."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extend_expiration_date(self, days=KEY_EXPIRATION_DELTA):\n        delta = timedelta_days(days)\n        self.expiration_date = self.expiration_date + delta\n        self.save()", "response": "Extend expiration date a number of given years"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_token(self, pattern=KEY_PATTERN):\n        self.token = generate_token(pattern)\n        self.save()", "response": "Refresh the token of the current one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a consumer based on its ip address", "response": "def add_consumer(self, ip):\n        \"\"\"\n        Add consumer based on its ip address\n        \"\"\"\n        Consumer.objects.get_or_create(key=self, ip=ip)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a key has the given django s auth Permission", "response": "def has_perm(self, perm):\n        \"\"\"\n        Checks if key has the given django's auth Permission\n        \"\"\"\n        if '.' in perm:\n            app_label, codename = perm.split('.')\n            permissions = self.permissions.filter(\n                content_type__app_label = app_label, \n                codename = codename)\n            groups = self.groups.filter(\n                permissions__content_type__app_label = app_label,\n                permissions__codename = codename )\n        else:\n            permissions = self.permissions.filter(codename = perm)\n            groups = self.groups.filter(permissions__codename = perm)\n        return permissions.exists() or groups.exists()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getmessage(self) -> str:\n        image = {}\n        for key, default in vars(self.__class__).items():\n            if not key.startswith('_') and key !='' and (not key in vars(QueueMessage).items()):                                      \n                if isinstance(default, datetime.date):\n                    image[key] = safe_cast(getattr(self, key, default), str, dformat=self._dateformat)\n                if isinstance(default, datetime.datetime):\n                    image[key] = safe_cast(getattr(self, key, default), str, dformat=self._datetimeformat)\n                else:\n                    image[key] = getattr(self, key, default)                              \n        return str(image)", "response": "parse self into unicode string as message content"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mergemessage(self, message):\n        if isinstance(message, QueueMessage):\n            \"\"\" merge queue message vars \"\"\"\n            for key, value in vars(message).items():\n                if not value is None:\n                    setattr(self, key, value)\n                    if (key == 'content'):\n                        content = literal_eval(message.content)\n                        for metakey, metavalue in content.items():\n                            default = getattr(self, metakey, None)\n                            if not default is None:\n                                if isinstance(default, datetime.date):\n                                    setattr(self, metakey, safe_cast(metavalue, datetime.date, dformat=self._dateformat))\n                                if isinstance(default, datetime.datetime):\n                                    setattr(self, metakey, safe_cast(metavalue, datetime.date, dformat=self._datetimeformat))\n                                else:\n                                    setattr(self, metakey, metavalue)", "response": "merge a message into the current object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a new StorageQueueModel in the Azure Storage Account", "response": "def register_model(self, storagemodel:object, modeldefinition = None):\n        \"\"\" set up an Queueservice for an StorageQueueModel in your  Azure Storage Account\n            Will create the Queue if not exist!\n        \n            required Parameter is:\n            - storagemodel: StorageQueueModel(Object)\n        \"\"\"\n        if modeldefinition is None:\n            \n            \"\"\" test if queuename already exists \"\"\"\n            if [model for model in self._modeldefinitions if model['queuename'] == storagemodel._queuename]:\n                raise NameConventionError(storagemodel._queuename)\n\n            \"\"\" test if queuename fits to azure naming rules \"\"\"\n            if not test_azurestorage_nameconventions(storagemodel._queuename, 'StorageQueueModel'):\n                raise NameConventionError(storagemodel._queuename)\n             \n            \"\"\" now register model \"\"\"\n            modeldefinition = {\n                'modelname': storagemodel.__class__.__name__,\n                'queuename': storagemodel._queuename,\n                'encrypt': storagemodel._encrypt,\n                'queueservice': self._account.create_queue_service()\n                }    \n\n            \"\"\" encrypt queue service \"\"\"\n            if modeldefinition['encrypt']:\n\n                # Create the KEK used for encryption.\n                # KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.\n                kek = KeyWrapper(self._key_identifier, self._secret_key) #  Key identifier\n\n                # Create the key resolver used for decryption.\n                # KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.\n                key_resolver = KeyResolver()\n                key_resolver.put_key(kek)                           \n\n                # Set the require Encryption, KEK and key resolver on the service object.\n                modeldefinition['queueservice'].require_encryption = True\n                modeldefinition['queueservice'].key_encryption_key = kek\n                modeldefinition['queueservice'].key_resolver_funcion = key_resolver.resolve_key\n            \n            self.__create__(modeldefinition)\n                \n            self._modeldefinitions.append(modeldefinition)\n\n            log.info('model {} registered successfully. Models are {!s}.'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))\n        else:\n            log.info('model {} already registered. Models are {!s}.'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))\n\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears up an Queueservice for an StorageQueueModel in your Azure Storage Account Will delete the hole Queue if delete_queue Flag is True! required Parameter is: - storagemodel: StorageQueueModel(Object) Optional Parameter is: - delete_queue: bool", "response": "def unregister_model(self, storagemodel:object, modeldefinition = None,  delete_queue=False):\n        \"\"\" clear up an Queueservice for an StorageQueueModel in your  Azure Storage Account\n            Will delete the hole Queue if delete_queue Flag is True!\n        \n            required Parameter is:\n            - storagemodel: StorageQueueModel(Object)\n\n            Optional Parameter is:\n            - delete_queue: bool\n        \"\"\"\n        \n        \"\"\" remove from modeldefinitions \"\"\"\n        for i in range(len(self._modeldefinitions)):\n            if self._modeldefinitions[i]['modelname'] == modeldefinition['modelname']:\n                del self._modeldefinitions[i]\n                break\n\n        \"\"\" delete queue from storage if delete_queue == True \"\"\"        \n        if delete_queue:\n            self.__deletequeue__(modeldefinition)\n\n        log.info('model {} unregistered successfully. Models are {!s}'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))      \n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put(self, storagemodel:object, modeldefinition = None) -> StorageQueueModel:\n        try:\n            message = modeldefinition['queueservice'].put_message(storagemodel._queuename, storagemodel.getmessage())\n            storagemodel.mergemessage(message)\n\n        except Exception as e:\n            storagemodel = None\n            msg = 'can not save queue message:  queue {} with message {} because {!s}'.format(storagemodel._queuename, storagemodel.content, e)\n            raise AzureStorageWrapException(msg=msg)\n           \n        finally:\n            return storagemodel", "response": "insert a message into storage"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef peek(self, storagemodel:object, modeldefinition = None) -> StorageQueueModel:\n\n        try:\n            messages = modeldefinition['queueservice'].peek_messages(storagemodel._queuename, num_messages=1)\n\n            \"\"\" parse retrieved message \"\"\"\n            for message in messages:\n                storagemodel.mergemessage(message)\n\n            \"\"\" no message retrieved ?\"\"\"\n            if storagemodel.id is None:\n                storagemodel = None\n\n        except Exception as e:\n            storagemodel = None\n            msg = 'can not peek queue message:  queue {} with message {} because {!s}'.format(storagemodel._queuename, storagemodel.content, e)\n            raise AzureStorageWrapException(msg=msg)\n\n        finally:\n            return storagemodel", "response": "looks for next message in queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget next message in queue", "response": "def get(self, storagemodel:object, modeldefinition = None, hide = 0) -> StorageQueueModel:\n        \"\"\" get the next message in queue \"\"\"\n        try:\n            if hide > 0:\n                messages = modeldefinition['queueservice'].get_messages(storagemodel._queuename, num_messages=1, visibility_timeout = hide)\n            else:\n                messages = modeldefinition['queueservice'].get_messages(storagemodel._queuename, num_messages=1)\n                    \n            \"\"\" parse retrieved message \"\"\"\n            for message in messages:\n                storagemodel.mergemessage(message)\n\n            \"\"\" no message retrieved ?\"\"\"\n            if storagemodel.id is None:\n                storagemodel = None\n\n        except Exception as e:\n            storagemodel = None\n            msg = 'can not peek queue message:  queue {} with message {} because {!s}'.format(storagemodel._queuename, storagemodel.content, e)\n            raise AzureStorageWrapException(msg=msg)\n\n        finally:\n            return storagemodel"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, storagemodel:object, modeldefinition = None, hide = 0) -> StorageQueueModel:\n\n        if (storagemodel.id != '') and (storagemodel.pop_receipt != '') and (not storagemodel.id is None) and (not storagemodel.pop_receipt is None):\n            try:\n                content = storagemodel.getmessage()\n                message = modeldefinition['queueservice'].update_message(storagemodel._queuename, storagemodel.id, storagemodel.pop_receipt, visibility_timeout = hide, content=content)\n                storagemodel.content = content\n                storagemodel.pop_receipt = message.pop_receipt\n\n            except Exception as e:\n                msg = 'can not update queue message:  queue {} with message.id {!s} because {!s}'.format(storagemodel._queuename, storagemodel.id, e)\n                storagemodel = None\n                raise AzureStorageWrapException(msg=msg)\n        else:\n            msg = 'cant update queuemessage in {!s} due to missing id {!s} and/or pop_receipt {!s}'.format(storagemodel._queuename, storagemodel.id, storagemodel.pop_receipt)\n            storagemodel = None\n            raise AzureStorageWrapException(msg=msg)\n\n        return storagemodel", "response": "update the message in queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes the message in queue", "response": "def delete(self, storagemodel:object, modeldefinition = None) -> bool:\n        \"\"\" delete the message in queue \"\"\"\n        deleted = False\n        if (storagemodel.id != '') and (storagemodel.pop_receipt != '') and (not storagemodel.id is None) and (not storagemodel.pop_receipt is None):\n            try:\n                modeldefinition['queueservice'].delete_message(storagemodel._queuename, storagemodel.id, storagemodel.pop_receipt)\n                deleted = True\n\n            except Exception as e:\n                msg = 'can not delete queue message:  queue {} with message.id {!s} because {!s}'.format(storagemodel._queuename, storagemodel.id, e)\n                raise AzureStorageWrapException(msg=msg)\n\n        else:\n            log.info('cant update queuemessage {} due to missing id and pop_receipt'.format(storagemodel._queuename))\n\n        return deleted"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an object matching the primary key provided.", "response": "def get_object(self, request, object_id):\n        \"\"\"\n        Returns an instance matching the primary key provided. ``None``  is\n        returned if no match is found (or the object_id failed validation\n        against the primary key field).\n        \"\"\"\n        queryset = self.queryset(request)\n        model = queryset.model\n        try:\n            object_id = model._meta.pk.to_python(object_id)\n            return queryset.get(pk=object_id)\n        except (model.DoesNotExist, ValidationError):\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the given request has permission to add an object.", "response": "def has_add_permission(self, request):\n        \"\"\"\n        Returns True if the given request has permission to add an object.\n        Can be overriden by the user in subclasses.\n        \"\"\"\n        opts = self.opts\n        return request.user.has_perm(opts.app_label + '.' + opts.get_add_permission())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_change_permission(self, request, obj=None):\n        opts = self.opts\n        return request.user.has_perm(opts.app_label + '.' + opts.get_change_permission(), obj)", "response": "Returns True if the given request has permission to change the given\n        model instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_delete_permission(self, request, obj=None):\n        opts = self.opts\n        return request.user.has_perm(opts.app_label + '.' + opts.get_delete_permission(), obj)", "response": "Returns True if the given request has permission to delete the given object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_view(self, request, object_id, extra_context=None):\n        \"The 'delete' admin view for this model.\"\n        opts = self.model._meta\n        app_label = opts.app_label\n\n        obj = self.get_object(request, unquote(object_id))\n\n        if not self.has_delete_permission(request, obj):\n            raise PermissionDenied\n\n        if obj is None:\n            raise Http404(_('%(name)s object with primary key %(key)r does not exist.') % {'name': force_unicode(opts.verbose_name), 'key': escape(object_id)})\n\n        using = router.db_for_write(self.model)\n\n        # Populate deleted_objects, a data structure of all related objects that\n        # will also be deleted.\n        (deleted_objects, perms_needed, protected) = get_deleted_objects(\n            [obj], opts, request.user, self.admin_site, using)\n        perms_needed = False   # cheat! Only object permission is required\n\n        if request.POST:  # The user has already confirmed the deletion.\n            if perms_needed:\n                raise PermissionDenied\n            obj_display = force_unicode(obj)\n            self.log_deletion(request, obj, obj_display)\n            self.delete_model(request, obj)\n\n            self.message_user(request, _('The %(name)s \"%(obj)s\" was deleted successfully.') % {'name': force_unicode(opts.verbose_name), 'obj': force_unicode(obj_display)})\n\n            if not self.has_change_permission(request, None):\n                return HttpResponseRedirect(reverse('admin:index',\n                                                    current_app=self.admin_site.name))\n            return HttpResponseRedirect(reverse('admin:%s_%s_changelist' %\n                                        (opts.app_label, opts.module_name),\n                                        current_app=self.admin_site.name))\n\n        object_name = force_unicode(opts.verbose_name)\n\n        if perms_needed or protected:\n            title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n        else:\n            title = _(\"Are you sure?\")\n\n        context = {\n            \"title\": title,\n            \"object_name\": object_name,\n            \"object\": obj,\n            \"deleted_objects\": deleted_objects,\n            \"perms_lacking\": perms_needed,\n            \"protected\": protected,\n            \"opts\": opts,\n            \"app_label\": app_label,\n        }\n        context.update(extra_context or {})\n\n        return TemplateResponse(request, self.delete_confirmation_template or [\n            \"admin/%s/%s/delete_confirmation.html\" % (app_label, opts.object_name.lower()),\n            \"admin/%s/delete_confirmation.html\" % app_label,\n            \"admin/delete_confirmation.html\"\n        ], context, current_app=self.admin_site.name)", "response": "The delete admin view for this model."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes selected objects from the change list.", "response": "def delete_selected(self, request, queryset):\n        \"\"\"\n        Overrides django's default delete_selected action do call _model_.delete() to\n        pass through services\n\n        Default action which deletes the selected objects.\n\n        This action first displays a confirmation page whichs shows all the\n        deleteable objects, or, if the user has no permission one of the related\n        childs (foreignkeys), a \"permission denied\" message.\n\n        Next, it delets all selected objects and redirects back to the change list.\n        \"\"\"\n        opts = self.model._meta\n        app_label = opts.app_label\n\n        # Check that the user has delete permission for the actual model\n        if not self.has_delete_permission(request):\n            raise PermissionDenied\n\n        using = router.db_for_write(self.model)\n\n        # Populate deletable_objects, a data structure of all related objects that\n        # will also be deleted.\n        deletable_objects, perms_needed, protected = get_deleted_objects(\n            queryset, opts, request.user, self.admin_site, using)\n\n        # The user has already confirmed the deletion.\n        # Do the deletion and return a None to display the change list view again.\n        if request.POST.get('post'):\n            if perms_needed:\n                raise PermissionDenied\n            n = queryset.count()\n            if n:\n                for obj in queryset:\n                    obj_display = force_text(obj)\n                    self.log_deletion(request, obj, obj_display)\n                    #remove the object\n                    self.delete_model(request, obj)\n\n                self.message_user(request, _(\"Successfully deleted %(count)d %(items)s.\") % {\n                    \"count\": n, \"items\": model_ngettext(self.opts, n)\n                })\n            # Return None to display the change list page again.\n            return None\n\n        if len(queryset) == 1:\n            objects_name = force_text(opts.verbose_name)\n        else:\n            objects_name = force_text(opts.verbose_name_plural)\n\n        if perms_needed or protected:\n            title = _(\"Cannot delete %(name)s\") % {\"name\": objects_name}\n        else:\n            title = _(\"Are you sure?\")\n\n        context = {\n            \"title\": title,\n            \"objects_name\": objects_name,\n            \"deletable_objects\": [deletable_objects],\n            'queryset': queryset,\n            \"perms_lacking\": perms_needed,\n            \"protected\": protected,\n            \"opts\": opts,\n            \"app_label\": app_label,\n            'action_checkbox_name': helpers.ACTION_CHECKBOX_NAME,\n        }\n\n        # Display the confirmation page\n        return TemplateResponse(request, self.delete_selected_confirmation_template or [\n            \"admin/%s/%s/delete_selected_confirmation.html\" % (app_label, opts.object_name.lower()),\n            \"admin/%s/delete_selected_confirmation.html\" % app_label,\n            \"admin/delete_selected_confirmation.html\"\n        ], context, current_app=self.admin_site.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef should_exclude(type_or_instance, exclusion_list):\n    if type_or_instance in exclusion_list: # Check class definition\n        return True\n    if type(type_or_instance) in exclusion_list: # Check instance type\n        return True\n    try:\n        if type_or_instance.__class__ in exclusion_list: # Check instance class\n            return True\n    except:\n        pass\n\n    return False", "response": "Tests whether an object should be simply returned when being wrapped by a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Facade( some_instance=None, exclusion_list=[], cls=None, args=tuple(), kwargs={}  ):\n    if not USE_CALIENDO or should_exclude( some_instance, exclusion_list ):\n        if not util.is_primitive(some_instance):\n            # Provide dummy methods to prevent errors in implementations dependent\n            # on the Wrapper interface\n            some_instance.wrapper__unwrap = lambda : None\n            some_instance.wrapper__delete_last_cached = lambda : None\n        return some_instance # Just give it back.\n    else:\n        if util.is_primitive(some_instance) and not cls:\n            return some_instance\n        return Wrapper(o=some_instance, exclusion_list=list(exclusion_list), cls=cls, args=args, kwargs=kwargs )", "response": "Wrapper function to return the most specific object that is passed to the Facade."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cache(handle=lambda *args, **kwargs: None, args=UNDEFINED, kwargs=UNDEFINED, ignore=UNDEFINED, call_stack=UNDEFINED, callback=UNDEFINED, subsequent_rvalue=UNDEFINED):\n    if args == UNDEFINED:\n        args = tuple()\n    if kwargs == UNDEFINED:\n        kwargs = {}\n    if not USE_CALIENDO:\n        return handle(*args, **kwargs)\n\n     \n    filtered_args = ignore.filter_args(args) if ignore is not UNDEFINED else args\n    filtered_kwargs = ignore.filter_kwargs(kwargs) if ignore is not UNDEFINED else args\n\n    trace_string      = util.get_stack(handle.__name__)\n    call_hash         = get_hash(filtered_args, trace_string, filtered_kwargs, ignore)\n    cd                = call_descriptor.fetch(call_hash)\n    modify_or_replace = 'no'\n\n    util.set_current_hash(call_hash)\n\n    if config.CALIENDO_PROMPT:\n        display_name = (\"(test %s): \" % caliendo.util.current_test) if caliendo.util.current_test else ''\n        if hasattr(handle, '__module__') and hasattr(handle, '__name__'):\n            display_name += \"%s.%s\" % (handle.__module__, handle.__name__)\n        else:\n            display_name += handle\n\n        if cd:\n            modify_or_replace = prompt.should_modify_or_replace_cached(display_name)\n\n    if not cd or modify_or_replace == 'replace':\n        returnval = handle(*args, **kwargs)\n    elif cd and modify_or_replace == 'modify':\n        returnval = prompt.modify_cached_value(cd.returnval,\n                                               calling_method=display_name,\n                                               calling_test='')\n\n    if cd and subsequent_rvalue != UNDEFINED:\n        return subsequent_rvalue\n    elif subsequent_rvalue != UNDEFINED:\n        original_rvalue = returnval\n        returnval = subsequent_rvalue\n\n    if not cd or modify_or_replace != 'no':\n        if isinstance(handle, types.MethodType):\n            filtered_args = list(filtered_args)\n            filtered_args[0] = util.serialize_item(filtered_args[0])\n            filtered_args = tuple(filtered_args)\n\n        cd = call_descriptor.CallDescriptor( hash      = call_hash,\n                                             stack     = trace_string,\n                                             method    = handle.__name__,\n                                             returnval = returnval,\n                                             args      = filtered_args,\n                                             kwargs    = filtered_kwargs )\n\n        cd.save()\n\n    util.set_last_hash(cd.hash)\n\n    if call_stack != UNDEFINED:\n        call_stack.add(cd)\n        if callback != UNDEFINED:\n            call_stack.add_hook(Hook(call_descriptor_hash=cd.hash,\n                                     callback=callback))\n\n    if subsequent_rvalue == UNDEFINED:\n        return cd.returnval\n    else:\n        return original_rvalue", "response": "Cache a call descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef patch(*args, **kwargs):\n    from caliendo.patch import patch as p\n    return p(*args, **kwargs)", "response": "Deprecated. Use patch instead."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wrapper__unignore(self, type_):\n        if type_ in self.__exclusion_list:\n            self.__exclusion_list.remove( type_ )\n        return self.__exclusion_list", "response": "Stop selectively ignoring certain types when wrapping attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstores a call descriptor", "response": "def __cache( self, method_name, *args, **kwargs ):\n        \"\"\"\n        Store a call descriptor\n\n        \"\"\"\n        trace_string           = util.get_stack(method_name)\n        call_hash              = self.__get_hash(args, trace_string, kwargs)\n        cd                     = call_descriptor.fetch( call_hash )\n        if not cd:\n            c  = self.__store__['callables'][method_name]\n            if hasattr( c, '__class__' ) and c.__class__ == LazyBones:\n                c = c.init()\n            returnval = c(*args, **kwargs)\n            cd = call_descriptor.CallDescriptor( hash      = call_hash,\n                                                 stack     = trace_string,\n                                                 method    = method_name,\n                                                 returnval = returnval,\n                                                 args      = args,\n                                                 kwargs    = kwargs )\n            cd.save()\n            if not call_hash:\n                raise Exception(\"CALL HASH IS NONE\")\n\n            util.last_hash = call_hash\n            self.last_cached = call_hash\n        else:\n            returnval = cd.returnval\n\n        if inspect.isclass(returnval):\n            returnval = LazyBones( c, args, kwargs )\n\n        return returnval"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap a method to copy the object into a new Facade.", "response": "def __wrap( self, method_name ):\n        \"\"\"\n        This method actually does the wrapping. When it's given a method to copy it\n        returns that method with facilities to log the call so it can be repeated.\n\n        :param str method_name: The name of the method precisely as it's called on\n        the object to wrap.\n\n        :rtype lambda function:\n        \"\"\"\n        return lambda *args, **kwargs: Facade( self.__cache( method_name, *args, **kwargs ), list(self.__exclusion_list) )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstore a callable member to the private __store__ dictionary", "response": "def __store_callable(self, o, method_name, member):\n        \"\"\"\n        Stores a callable member to the private __store__\n\n        :param mixed o: Any callable (function or method)\n        :param str method_name: The name of the attribute\n        :param mixed member: A reference to the member\n\n        \"\"\"\n        self.__store__['callables'][method_name] = eval( \"o.\" + method_name )\n        self.__store__['callables'][method_name[0].lower() + method_name[1:]] = eval( \"o.\" + method_name )\n        ret_val = self.__wrap( method_name )\n        self.__store__[ method_name ] = ret_val\n        self.__store__[ method_name[0].lower() + method_name[1:] ] = ret_val"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __store_nonprimitive(self, o, method_name, member):\n        self.__store__[ method_name ] = ( 'attr', member )\n        self.__store__[ method_name[0].lower() + method_name[1:] ] = ( 'attr', member )", "response": "Stores any non - primitive."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring a reference to an attribute on o", "response": "def __store_other(self, o, method_name, member):\n        \"\"\"\n        Stores a reference to an attribute on o\n\n        :param mixed o: Some object\n        :param str method_name: The name of the attribute\n        :param mixed member: The attribute\n\n        \"\"\"\n        self.__store__[ method_name ] = eval( \"o.\" + method_name )\n        self.__store__[ method_name[0].lower() + method_name[1:] ] = eval( \"o.\" + method_name )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __save_reference(self, o, cls, args, kwargs):\n        if not o and cls:\n            self['__original_object'] = LazyBones( cls, args, kwargs )\n        else:\n            while hasattr( o, '__class__' ) and o.__class__ == Wrapper:\n                o = o.wrapper__unwrap()\n            self['__original_object'] = o", "response": "Saves a reference to the original object Facade is passed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstore the object o according to the method_name and member.", "response": "def __store_any(self, o, method_name, member):\n        \"\"\"\n        Determines type of member and stores it accordingly\n\n        :param mixed o: Any parent object\n        :param str method_name: The name of the method or attribuet\n        :param mixed member: Any child object\n\n        \"\"\"\n        if should_exclude( eval( \"o.\" + method_name ), self.__exclusion_list ):\n            self.__store__[ method_name ] = eval( \"o.\" + method_name )\n            return\n\n        if hasattr( member, '__call__' ):\n            self.__store_callable( o, method_name, member )\n        elif inspect.isclass( member ):\n            self.__store_class( o, method_name, member ) # Default ot lazy-loading classes here.\n        elif not util.is_primitive( member ):\n            self.__store_nonprimitive( o, method_name, member )\n        else:\n            self.__store_other( o, method_name, member )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the configuration directory where the file is located.", "response": "def _in_conf_dir(filename):\n    \"\"\"\n    Put the `filename` to the configuration directory context / path.\n    \"\"\"\n    return os.path.join(\n        os.path.dirname(__file__),\n        \"templates/conf\",\n        filename\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_all_constants():\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "response": "Get list of all uppercase non - private globals."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to read data from configuration paths.", "response": "def _read_from_paths():\n    \"\"\"\n    Try to read data from configuration paths ($HOME/_SETTINGS_PATH,\n    /etc/_SETTINGS_PATH).\n    \"\"\"\n    home = os.environ.get(\"HOME\", \"\")\n    home_path = os.path.join(home, _SETTINGS_PATH)\n    etc_path = os.path.join(\"/etc\", _SETTINGS_PATH)\n    env_path = os.environ.get(\"SETTINGS_PATH\", \"\")\n\n    read_path = None\n    if env_path and os.path.exists(env_path):\n        read_path = env_path\n    elif home and os.path.exists(home_path):\n        read_path = home_path\n    elif os.path.exists(etc_path):\n        read_path = etc_path\n\n    if not read_path:\n        return \"{}\"\n\n    with open(read_path) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the root node of the toolbar.", "response": "def get_toolbar_root():\n    \"\"\"\n    Init on demand.\n    :rtype: RootNode\n    \"\"\"\n    global _toolbar_root\n    if _toolbar_root is None:\n        items = [load_toolbar_item(item) for item in appsettings.STAFF_TOOLBAR_ITEMS]\n        _toolbar_root = RootNode(*items)\n    return _toolbar_root"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload an item in the toolbar.", "response": "def load_toolbar_item(import_path, *args, **kwargs):\n    \"\"\"\n    Load an item in the toolbar\n    :param import_path: the dotted python path to class or function.\n    :param args: For classes, any arguments to pass to the constructor.\n    :param kwargs: For classes, any keyword arguments to pass to the constructor.\n    \"\"\"\n    if isinstance(import_path, (tuple, list)):\n        children = [load_toolbar_item(path) for path in import_path]\n        return Group(*children)\n    elif isinstance(import_path, basestring):\n        symbol = _import_symbol(import_path, 'STAFF_TOOLBAR_ITEMS')\n    else:\n        symbol = import_path\n\n    if inspect.isclass(symbol):\n        # Instantiate the class.\n        symbol = symbol(*args, **kwargs)\n\n    if not callable(symbol):\n        raise ImproperlyConfigured(\"The {0} in {1} is not callable!\".format(import_path, 'STAFF_TOOLBAR_ITEMS'))\n\n    return symbol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _import_symbol(import_path, setting_name):\n    mod_name, class_name = import_path.rsplit('.', 1)\n\n    # import module\n    try:\n        mod = import_module(mod_name)\n        cls = getattr(mod, class_name)\n    except ImportError as e:\n        __, __, exc_traceback = sys.exc_info()\n        frames = traceback.extract_tb(exc_traceback)\n        if len(frames) > 1:\n            raise   # import error is a level deeper.\n\n        raise ImproperlyConfigured(\"{0} does not point to an existing class: {1}\".format(setting_name, import_path))\n    except AttributeError:\n        raise ImproperlyConfigured(\"{0} does not point to an existing class: {1}\".format(setting_name, import_path))\n\n    return cls", "response": "Imports a class or function by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a queue - name from a set of arguments and a delimiter", "response": "def construct(args):\n    '''Construct a queue-name from a set of arguments and a delimiter'''\n    # make everything unicode\n    name = u''\n    delimiter, encodeseq = delimiter_encodeseq(_c.FSQ_DELIMITER,\n                                               _c.FSQ_ENCODE, _c.FSQ_CHARSET)\n    if len(args) == 0:\n        return delimiter\n    for arg in args:\n        name = delimiter.join([ name,\n                                encode(coerce_unicode(arg, _c.FSQ_CHARSET),\n                                delimiter=delimiter, encodeseq=encodeseq)])\n\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deconstruct(name):\n    '''Deconstruct a queue-name to a set of arguments'''\n    name = coerce_unicode(name, _c.FSQ_CHARSET)\n    new_arg = sep = u''\n    args = []\n    # can't get delimiter, if string is empty\n    if 1 > len(name):\n        raise FSQMalformedEntryError(errno.EINVAL, u'cannot derive delimiter'\\\n                                     u'from: {0}'.format(name))\n\n    delimiter, encodeseq = delimiter_encodeseq(name[0], _c.FSQ_ENCODE,\n                                               _c.FSQ_CHARSET)\n    # edge case, no args\n    if 1 == len(name):\n        return delimiter, args\n\n    # normal case\n    encoding_trg = sep\n    for c in name[1:]:\n        if 3 == len(encoding_trg):\n            encoding_trg = sep\n        if c == encodeseq or len(encoding_trg):\n            encoding_trg = sep.join([encoding_trg, c])\n        elif c == delimiter:\n            # at delimiter, append and reset working arg\n            args.append(decode(new_arg, delimiter=delimiter,\n                               encodeseq=encodeseq))\n            new_arg = sep\n            continue\n\n        new_arg = sep.join([new_arg, c])\n\n    # append our last arg\n    args.append(decode(new_arg, delimiter=delimiter, encodeseq=encodeseq))\n    return delimiter, args", "response": "Deconstruct a queue - name to a set of arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def delete(self):\n        _val = await self.request.delete(\n            self._base_path,\n            params={\n                ATTR_SCENE_ID: self._raw_data.get(ATTR_SCENE_ID),\n                ATTR_SHADE_ID: self._raw_data.get(ATTR_SHADE_ID),\n            },\n        )\n        return _val", "response": "Deletes a scene from a shade"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef drop_param(_param, _method, *args, **kwargs):\n    assert callable(_method), \"method %r is not callable\" % (_method, )\n    return _method(*args, **kwargs)", "response": "Used as a callback to ignore the result from the previous callback\n    added to this fiber."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bridge_param(_param, _method, *args, **kwargs):\n    assert callable(_method), \"method %r is not callable\" % (_method, )\n    f = Fiber(debug_depth=1, debug_call=_method)\n    f.add_callback(drop_param, _method, *args, **kwargs)\n    f.add_callback(override_result, _param)\n    return f.succeed()", "response": "Used as a callback to drop the param and use that instead of the result of the given method when chaining to the next callback."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef break_fiber(depth=0):\n    set_stack_var(SECTION_BOUNDARY_TAG, True, depth=depth+1)\n    set_stack_var(SECTION_STATE_TAG, None, depth=depth+1)", "response": "After calling break_fiber get_state will return None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tabulate_body(\n    obj,\n    level_keys,\n    v_level_indexes,\n    h_level_indexes,\n    v_level_sort_keys=None,\n    h_level_sort_keys=None,\n):\n    \"\"\"\n    Args:\n        v_level_indexes: A sequence of level indexes.\n        h_level_indexes: A sequence of level indexes.\n    \"\"\"\n    v_key_sorted = make_sorter(v_level_sort_keys, v_level_indexes)\n    h_key_sorted = make_sorter(h_level_sort_keys, h_level_indexes)\n\n    h_level_keys = [level_keys[level] for level in h_level_indexes]\n    v_level_keys = [level_keys[level] for level in v_level_indexes]\n\n    h_key_tuples = h_key_sorted(product(*h_level_keys))\n    v_key_tuples = v_key_sorted(product(*v_level_keys))\n\n    h_size = len(h_key_tuples)\n    v_size = len(v_key_tuples)\n\n    table = [[MISSING for _ in range(h_size)] for _ in range(v_size)]\n\n    for h_index, h_keys in enumerate(h_key_tuples):\n        for v_index, v_keys in enumerate(v_key_tuples):\n            key_path = [None] * len(level_keys)\n            merge_into_by_index(key_path, h_level_indexes, h_keys)\n            merge_into_by_index(key_path, v_level_indexes, v_keys)\n            for v_level, v_key in zip(v_level_indexes, v_keys):\n                key_path[v_level] = v_key\n\n            item = obj\n            for key in key_path:\n                try:\n                    item = item[key]\n                except (IndexError, KeyError):\n                    break\n            else:  # no-break\n                table[v_index][h_index] = item\n\n    return table, v_key_tuples, h_key_tuples", "response": "Tabulate the content of a single object into a single object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tabulate(\n    obj,\n    v_level_indexes=None,\n    h_level_indexes=None,\n    v_level_visibility=None,\n    h_level_visibility=None,\n    v_level_sort_keys=None,\n    h_level_sort_keys=None,\n    v_level_titles=None,\n    h_level_titles=None,\n    empty=\"\",\n):\n    \"\"\"Render a nested data structure into a two-dimensional table.\n\n    Args:\n        obj: The indexable data structure to be rendered, which can\n            either be a non-string sequence or a mapping containing other\n            sequences and mappings nested to arbitrarily many levels,\n            with all the leaf items (which are neither sequences nor\n            mappings, excluding strings).\n\n        v_level_indexes: An iterable of the zero-based indexes of\n            the levels for which the keys/indexes will be displayed\n            along the vertical axis of the table. Taken together\n            with the levels in h_levels these must represent the\n            complete set of levels in the obj data structure. No\n            level index should appear in both v_level_indexes and\n            h_level_indexes, but all level indexes must appear in\n            either v_level_indexes or h_level_indexes. If None,\n            the levels not used in h_level_indexes will be used.\n            If both v_level_indexes and h_level_indexes are not\n            alternate indexes will be used as v_level and h_level\n            indexes.\n\n        h_level_indexes: An iterable of the zero-based indexes of\n            the levels for which the keys/indexes will be displayed\n            along the horizontal axis of the table. Taken together\n            with the levels in v_levels these must represent the\n            complete set of levels in the obj data structure. No\n            level index should appear in both h_level_indexes and\n            v_level_indexes, but all level indexes must appear in\n            either h_level_indexes or v_level_indexes. If None,\n            the levels not used in v_level_indexes will be used.\n            If both v_level_indexes and h_level_indexes are not\n            alternate indexes will be used as v_level and h_level\n            indexes.\n\n        v_level_visibility: An optional iterable of booleans, where each\n            item corresponds to a level in v_level_indexes, and\n            controls whether than level of index is included in\n            the table stub columns. This iterable must contain\n            the same number of items as v_level_indexes.\n\n        h_level_visibility: An optional iterable of booleans, where each\n            item corresponds to a level in h_level_indexes, and\n            controls whether than level of index is included in\n            the table header rows. This iterable must contain\n            the same number of items as h_level_indexes.\n\n        v_level_sort_keys: An optional iterable of Keys, where each\n            key corresponds to a level in v_level_indexes, and\n            controls how that key is sorted. If None, keys are sorted\n            as-is.\n\n        h_level_sort_keys: An optional iterable of Keys, where each\n            key corresponds to a level in v_level_indexes, and\n            controls how that key is sorted. If None, keys are sorted\n            as-is.\n\n        v_level_titles: An optional iterable of strings, where each\n            string is a title which corresponds to a level in v_level_indexes,\n            and which will be displayed against the row keys for that level.\n            If None, no titles will be included.\n\n        h_level_titles: An optional iterable of strings, where each\n            string is a title which corresponds to a level in h_level_indexes,\n            and which will be displayed against the column keys for that level.\n            If None, no titles will be included.\n\n        empty: An optional string value to use for empty cells.\n\n    Returns:\n        A list of lists representing the rows of cells.\n\n    Example:\n\n        tabulate(dict_of_dicts, [0, 1], [])\n\n    \"\"\"\n    level_keys = breadth_first(obj)\n\n    v_level_indexes, h_level_indexes = validate_level_indexes(\n        len(level_keys), v_level_indexes, h_level_indexes\n    )\n\n    if v_level_visibility is None:\n        v_level_visibility = [True] * len(v_level_indexes)\n    if h_level_visibility is None:\n        h_level_visibility = [True] * len(h_level_indexes)\n\n    table, v_key_tuples, h_key_tuples = tabulate_body(\n        obj, level_keys, v_level_indexes, h_level_indexes, v_level_sort_keys, h_level_sort_keys\n    )\n\n    table, v_key_tuples = strip_missing_rows(table, v_key_tuples)\n    table, h_key_tuples = strip_missing_columns(table, h_key_tuples)\n    v_key_tuples = strip_hidden(v_key_tuples, v_level_visibility)\n    h_key_tuples = strip_hidden(h_key_tuples, h_level_visibility)\n    return assemble_table(\n        table, v_key_tuples, h_key_tuples, v_level_titles, h_level_titles, empty=empty\n    )", "response": "Render a nested data structure into a two - dimensional table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure that v_level_indexes and h_level_indexes are consistent.", "response": "def validate_level_indexes(num_levels, v_level_indexes, h_level_indexes):\n    \"\"\"Ensure that v_level_indexes and h_level_indexes are consistent.\n\n    Args:\n        num_levels: The number of levels of keys in the data structure being tabulated.\n        v_level_indexes: A sequence of level indexes between zero and num_levels for\n            the vertical axis, or None.\n        h_level_indexes: A sequence of level indexes between zero and num_levels for for\n            the horizontal axis, or None.\n\n    Returns:\n        A 2-tuple containing v_level_indexes and h_level_indexes sequences.\n\n    Raises:\n        ValueError: If v_level_indexes contains duplicate values.\n        ValueError: If h_level_indexes contains duplicate values.\n        ValueError: If v_level_indexes contains out of range values.\n        ValueError: If h_level_indexes contains out of range values.\n        ValueError: If taken together v_level_indexes and h_level_indexes\n            do not include all levels from zero to up to, but not including\n            num_levels.\n        ValueError: If v_level_indexes and h_level_indexes have items in\n            common.\n    \"\"\"\n    if num_levels < 1:\n        raise ValueError(\"num_levels {} is less than one\".format(num_levels))\n\n    all_levels = SortedFrozenSet(range(num_levels))\n\n    if (h_level_indexes is None) and (v_level_indexes is None):\n        v_level_indexes = range(0, num_levels, 2)\n        h_level_indexes = range(1, num_levels, 2)\n\n    h_level_set = SortedFrozenSet(h_level_indexes)\n    v_level_set = SortedFrozenSet(v_level_indexes)\n\n    if h_level_indexes is None:\n        h_level_indexes = all_levels - v_level_set\n    if v_level_indexes is None:\n        v_level_indexes = all_levels - h_level_set\n\n    if len(h_level_indexes) != len(h_level_set):\n        raise ValueError(\"h_level_indexes contains duplicate values\")\n    if h_level_set and ((h_level_set[0] < 0) or (h_level_set[-1] >= num_levels)):\n        raise ValueError(\"h_level_indexes contains out of range values\")\n    if len(v_level_indexes) != len(v_level_set):\n        raise ValueError(\"v_level_indexes contains duplicate values\")\n    if v_level_set and ((v_level_set[0] < 0) or (v_level_set[-1] >= num_levels)):\n        raise ValueError(\"v_level_indexes contains out of range values\")\n\n    unmentioned_levels = all_levels - v_level_set - h_level_set\n    if len(unmentioned_levels) > 0:\n        raise ValueError(\n            \"v_level_indexes and h_level_indexes do not together include levels {}\".format(\n                \", \".join(map(str, unmentioned_levels))\n            )\n        )\n    if not h_level_set.isdisjoint(v_level_set):\n        raise ValueError(\"h_level_indexes and v_level_indexes are not disjoint\")\n    v_level_indexes = list(v_level_indexes)\n    h_level_indexes = list(h_level_indexes)\n    return v_level_indexes, h_level_indexes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiltering each tuple according to visibility.", "response": "def strip_hidden(key_tuples, visibilities):\n    \"\"\"Filter each tuple according to visibility.\n\n    Args:\n        key_tuples: A sequence of tuples of equal length (i.e. rectangular)\n        visibilities: A sequence of booleans equal in length to the tuples contained in key_tuples.\n\n    Returns:\n        A sequence equal in length to key_tuples where the items are tuples with a length corresponding\n        to the number of items in visibility which are True.\n    \"\"\"\n    result = []\n    for key_tuple in key_tuples:\n        if len(key_tuple) != len(visibilities):\n            raise ValueError(\n                \"length of key tuple {} is not equal to length of visibilities {}\".format(\n                    key_tuple, visibilities\n                )\n            )\n        filtered_tuple = tuple(item for item, visible in zip(key_tuple, visibilities) if visible)\n        result.append(filtered_tuple)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry converting the README to an RST document. Return it as is on failure.", "response": "def readme():\n    \"\"\"Try converting the README to an RST document. Return it as is on failure.\"\"\"\n    try:\n        import pypandoc\n        readme_content = pypandoc.convert('README.md', 'rst')\n    except(IOError, ImportError):\n        print(\"Warning: no pypandoc module found.\")\n        try:\n            readme_content = open('README.md').read()\n        except IOError:\n            readme_content = ''\n    return readme_content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the x position ( on the canvas ) corresponding to XVAL.", "response": "def x_pos(self, xval):\n        \"Return the x position (on the canvas) corresponding to XVAL.\"\n        off = self.x_coord.get_canvas_pos(self.size[0], xval,\n                                          self.x_range[0], self.x_range[1])\n        return self.loc[0] + off"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef y_pos(self, yval):\n        \"Return the y position (on the canvas) corresponding to YVAL.\"\n        off = self.y_coord.get_canvas_pos(self.size[1], yval,\n                                          self.y_range[0], self.y_range[1])\n        return self.loc[1] + off", "response": "Return the y position ( on the canvas ) corresponding to YVAL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef x_tic_points(self, interval):\n        \"Return the list of X values for which tick marks and grid lines are drawn.\"\n        if type(interval) == FunctionType:\n            return interval(*self.x_range)\n\n        return self.x_coord.get_tics(self.x_range[0], self.x_range[1], interval)", "response": "Return the list of X values for which tick marks and grid lines are drawn."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef y_tic_points(self, interval):\n        \"Return the list of Y values for which tick marks and grid lines are drawn.\"\n        if type(interval) == FunctionType:\n            return interval(*self.y_range)\n\n        return self.y_coord.get_tics(self.y_range[0], self.y_range[1], interval)", "response": "Return the list of Y values for which tick marks and grid lines are drawn."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _makeUniqueFilename(taken_names, name):\n    if name in taken_names:\n        # try to form up new name\n        basename, ext = os.path.splitext(name)\n        num = 1\n        name = \"%s-%d%s\" % (basename, num, ext)\n        while name in taken_names:\n            num += 1\n            name = \"%s-%d%s\" % (basename, num, ext)\n    # finally, enter name into set\n    taken_names.add(name)\n    return name", "response": "Helper function to make a unique filename for a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _sanitizeFilename(filename):\n    global _sanitize_trans\n    out = filename.translate(_sanitize_trans)\n    # leading dot becomes \"_\"\n    if out and out[0] == '.':\n        out = out[1:]\n    return out", "response": "Sanitize a filename for use on Windows and other brain - dead systems."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the event contains a file URL and returns the list of file URLs that are accepted or ignores if it doesn t.", "response": "def _checkDragDropEvent(self, ev):\n        \"\"\"Checks if event contains a file URL, accepts if it does, ignores if it doesn't\"\"\"\n        mimedata = ev.mimeData()\n        if mimedata.hasUrls():\n            urls = [str(url.toLocalFile()) for url in mimedata.urls() if url.toLocalFile()]\n        else:\n            urls = []\n        # accept event if drag text is a file URL\n        if urls:\n            ev.acceptProposedAction()\n            return urls\n        else:\n            ev.ignore()\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses drop event and accept the file URL.", "response": "def dropEvent(self, ev):\n        \"\"\"Process drop event.\"\"\"\n        # use function above to accept event if it contains a file URL\n        files = self._checkDragDropEvent(ev)\n        if files:\n            pos = ev.pos()\n            dropitem = self.itemAt(pos)\n            dprint(1, \"dropped on\", pos.x(), pos.y(), dropitem and str(dropitem.text(1)))\n            # if event originated with ourselves, reorder items\n            if ev.source() is self:\n                self.reorderItems(dropitem, *files)\n            # else event is from someone else, accept the dropped files\n            else:\n                self._dropped_on = dropitem\n                self.emit(SIGNAL(\"droppedFiles\"), *files)\n                # if event originated with another DPTreeWidget, emit a draggedAwayFiles() signal on its behalf\n                if isinstance(ev.source(), DPTreeWidget):\n                    ev.source().emit(SIGNAL(\"draggedAwayFiles\"), *files)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _updateItemComboBoxIndex(self, item, column, num):\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "response": "Callback for comboboxes that the given item and column has changed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the policy of the given item", "response": "def setItemPolicy(self, item, policy):\n        \"\"\"Sets the policy of the given item\"\"\"\n        index = item._combobox_indices[self.ColAction].get(policy, 0)\n        self._updateItemComboBoxIndex(item, self.ColAction, index)\n        combobox = self.itemWidget(item, self.ColAction)\n        if combobox:\n            combobox.setCurrentIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning list of item and dp pairs corresponding to content of listview. Not - yet - saved items will have dp = None.", "response": "def getItemDPList(self):\n        \"\"\"Returns list of item,dp pairs corresponding to content of listview.\n        Not-yet-saved items will have dp=None.\"\"\"\n        itemlist = [(item, item._dp) for item in self.iterator()]\n        return itemlist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a listview item for data product dp inserts it after item after", "response": "def _makeDPItem(self, parent, dp, after=None):\n        \"\"\"Creates listview item for data product 'dp', inserts it after item 'after'\"\"\"\n        if parent:\n            item = QTreeWidgetItem(parent, after)\n        else:\n            item = QTreeWidgetItem()\n        item.setTextAlignment(self.ColAction, Qt.AlignRight | Qt.AlignVCenter)\n        item.setTextAlignment(self.ColFilename, Qt.AlignRight | Qt.AlignVCenter)\n        item.setTextAlignment(self.ColType, Qt.AlignLeft | Qt.AlignVCenter)\n        item.setTextAlignment(self.ColRename, Qt.AlignLeft | Qt.AlignVCenter)\n        item.setTextAlignment(self.ColRender, Qt.AlignHCenter | Qt.AlignVCenter)\n        item.setTextAlignment(self.ColComment, Qt.AlignLeft | Qt.AlignVCenter)\n        item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled | Qt.ItemIsEnabled)\n        item._dp = dp\n        # init stuff for combobox functions above\n        item._combobox_option_list = {}\n        item._combobox_current_index = {}\n        item._combobox_current_value = {}\n        item._combobox_indices = {}\n        item._combobox_changed = {}\n        # setup available policies for new or archived items, set initial policy\n        if dp.archived:\n            item._menu = self._archived_dp_menu\n            item._combobox_option_list[self.ColAction] = policies = self._policy_list_archived\n            policy = \"keep\"\n        else:\n            item._combobox_option_list[self.ColAction] = policies = self._policy_list_default\n            policy = dp.policy\n        # create reverse mapping from policy names to indices\n        item._combobox_indices[self.ColAction] = dict([(name, num) for num, (name, icon) in enumerate(policies)])\n        # init item policy\n        self.setItemPolicy(item, policy)\n        # set other columns\n        basename = os.path.basename(dp.sourcepath)\n        name, ext = os.path.splitext(basename)\n        item.setText(self.ColFilename, name)\n        item.setText(self.ColType, ext)\n        item.setToolTip(self.ColFilename, basename)\n        item.setToolTip(self.ColType, basename)\n        item.setData(self.ColComment, Qt.EditRole, QVariant(dp.comment or \"\"))\n        # make sure new filenames are unique\n        filename = _sanitizeFilename(dp.filename)\n        if not dp.archived:\n            # tack on .tgz prefix onto dirs\n            if os.path.isdir(dp.sourcepath) and not filename.endswith(\".tgz\"):\n                filename += \".tgz\"\n            # form up set of taken names\n            taken_names = set()\n            for i0, dp0 in self.getItemDPList():\n                if dp0.policy not in [\"remove\", \"ignore\", \"banish\"]:\n                    taken_names.add(str(i0.text(self.ColRename)))\n            # ensure uniqueness of filename\n            filename = _makeUniqueFilename(taken_names, filename)\n        item.setData(self.ColRename, Qt.EditRole, QVariant(filename))\n        # get list of available renderers\n        item._renderers = Purr.Render.getRenderers(dp.fullpath or dp.sourcepath)\n        item._render = 0\n        item._combobox_option_list[self.ColRender] = [(name, None) for name in item._renderers]\n        # create reverse mapping from renderer names to indices\n        item._combobox_indices[self.ColRender] = dict([(name, num) for num, name in enumerate(item._renderers)])\n        # for archived items, try to find renderer in list\n        if dp.archived:\n            try:\n                item._render = item._renderers.index(dp.render)\n            except:\n                pass\n        self._updateItemComboBoxIndex(item, self.ColRender, item._render)\n        # add to map of items\n        self.dpitems[dp.fullpath or dp.sourcepath] = item\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nredefining focusOut events to stop editing", "response": "def focusOutEvent(self, ev):\n        \"\"\"Redefine focusOut events to stop editing\"\"\"\n        Kittens.widgets.ClickableTreeWidget.focusOutEvent(self, ev)\n        # if focus is going to a child of ours, do nothing\n        wid = QApplication.focusWidget()\n        while wid:\n            if wid is self:\n                return\n            wid = wid.parent()\n        # else we're truly losing focus -- stop the editor\n        self._startOrStopEditing()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops editing if enter is pressed", "response": "def keyPressEvent(self, ev):\n        \"\"\"Stop editing if enter is pressed\"\"\"\n        if ev.key() in (Qt.Key_Enter, Qt.Key_Return):\n            self._startOrStopEditing()\n        elif ev.key() == Qt.Key_Escape:\n            self._cancelEditing()\n        else:\n            Kittens.widgets.ClickableTreeWidget.keyPressEvent(self, ev)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _showItemContextMenu(self, item, point, col):\n        self._startOrStopEditing()\n        menu = getattr(item, '_menu', None)\n        if menu:\n            # self._current_item tells callbacks what item the menu was referring to\n            self._current_item = item\n            self.clearSelection()\n            self.setItemSelected(item, True)\n            menu.exec_(point)\n        else:\n            self._current_item = None", "response": "Callback for contextMenuRequested() signal. Pops up item menu."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfilling listview with existing data products", "response": "def fillDataProducts(self, dps):\n        \"\"\"Fills listview with existing data products\"\"\"\n        item = None\n        for dp in dps:\n            if not dp.ignored:\n                item = self._makeDPItem(self, dp, item)\n                # ensure combobox widgets are made\n                self._itemComboBox(item, self.ColAction)\n                self._itemComboBox(item, self.ColRender)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addDataProducts(self, dps):\n        busy = Purr.BusyIndicator()\n        wakeup = False\n        # build up list of items to be inserted\n        itemlist = []\n        for dp in dps:\n            item = self.dpitems.get(dp.sourcepath)\n            # If item already exists, it needs to be moved to its new position\n            # If takeTopLevelItem() returns None, then item was already removed (this shouldn't happen,\n            # but let's be defensive), and we make a new one anyway.\n            if item and self.takeTopLevelItem(self.indexOfTopLevelItem(item)):\n                itemlist.append(item)\n            else:\n                itemlist.append(self._makeDPItem(None, dp))\n            wakeup = wakeup or not (dp.ignored or dp.quiet)\n        # if these DPs were added as a result of a drag-and-drop, we need to insert them in FRONT of the dropped-on item\n        if self._dropped_on:\n            index = self.indexOfTopLevelItem(self._dropped_on)\n        # else insert at end (after=None)\n        else:\n            index = self.topLevelItemCount()\n        if itemlist:\n            self.insertTopLevelItems(index, itemlist)\n            self.emit(SIGNAL(\"updated\"))\n        for item in itemlist:\n            # ensure combobox widgets are made\n            self._itemComboBox(item, self.ColAction)\n            self._itemComboBox(item, self.ColRender)\n        return wakeup", "response": "Adds new data products to the listview. Returns True if new data products are added False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dropDataProducts(self, *pathnames):\n        trash = QTreeWidget(None)\n        updated = False\n        for path in pathnames:\n            item = self.dpitems.get(path)\n            if item and not item._dp.archived:\n                self.takeTopLevelItem(self.indexOfTopLevelItem(item))\n                trash.addTopLevelItem(item)\n                del self.dpitems[path]\n                updated = True\n        if updated:\n            self.emit(SIGNAL(\"updated\"))", "response": "Drops new DP items matching the given pathnames."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if some conflicts were found.", "response": "def resolveFilenameConflicts(self):\n        \"\"\"Goes through list of DPs to make sure that their destination names\n        do not clash. Adjust names as needed. Returns True if some conflicts were resolved.\n        \"\"\"\n        taken_names = set()\n        resolved = False\n        # iterate through items\n        for item, dp in self.getItemDPList():\n            # only apply this to saved DPs\n            if dp.policy not in [\"remove\", \"ignore\", \"banish\"]:\n                name0 = str(item.text(self.ColRename))\n                name = _makeUniqueFilename(taken_names, name0)\n                if name != name0:\n                    item.setText(self.ColRename, name)\n                    resolved = True\n                    self.emit(SIGNAL(\"updated\"))\n        return resolved"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef buildDPList(self):\n        updated = False\n        dps = []\n        itemlist = self.getItemDPList()\n        # first remove all items marked for removal, in case their names clash with new or renamed items\n        for item, dp in itemlist:\n            item._policy = item._combobox_current_value[self.ColAction]\n            if dp and item._policy == \"remove\":\n                dp.remove_file()\n                dp.remove_subproducts()\n        # now, make list\n        for item, dp in itemlist:\n            if item._policy == \"remove\":\n                continue\n            # update renderer and comment\n            render = item._combobox_current_value[self.ColRender]\n            comment = str(item.text(self.ColComment))\n            if render != dp.render:\n                dp.render = render\n                updated = True\n            if comment != dp.comment:\n                dp.comment = comment\n                updated = True\n            # archived DPs may need to be renamed, for new ones simply set the name\n            if dp.archived:\n                updated = updated or dp.rename(str(item.text(self.ColRename)))\n            else:\n                dp.set_policy(item._policy)\n                dp.filename = str(item.text(self.ColRename))\n            dps.append(dp)\n        return dps, updated", "response": "Builds list of data products."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsuggesting a title for the entry.", "response": "def suggestTitle(self, title):\n        \"\"\"Suggests a title for the entry.\n        If title has been manually edited, suggestion is ignored.\"\"\"\n        if not self._title_changed or not str(self.wtitle.text()):\n            self.wtitle.setText(title)\n            self._title_changed = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef countRemovedDataProducts(self):\n        return len([item for item, dp in self.wdplv.getItemDPList() if dp.policy == \"remove\"])", "response": "Returns the number of removed data products"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolveFilenameConflicts(self, dialog=True):\n        resolved = self.wdplv.resolveFilenameConflicts()\n        if resolved and dialog:\n            QMessageBox.warning(self, \"Filename conflicts\", \"\"\"<P>\n        <NOBR>PURR has found duplicate destination filenames among your data products.</NOBR>\n        This is not allowed, so some filenames have been adjusted to avoid name clashes.\n        Please review the changes before saving this entry.\n        </P>\"\"\",\n                                QMessageBox.Ok, 0)\n        return resolved", "response": "Resolves conflicts between the destination names of the data products and the entry s names. Returns True if some conflicts were resolved."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef updateEntry(self):\n        # form up new entry\n        title = str(self.wtitle.text())\n        comment = str(self.comment_doc.toPlainText())\n        # process comment string -- eliminate single newlines, make double-newlines into separate paragraphs\n        # exception are paragraphs that start with \"#LOG:\", these get special treatment and the single newlines are\n        # left intact\n        pars = []\n        for paragraph in comment.split(\"\\n\\n\"):\n            if paragraph.startswith(\"LOG:\"):\n                pars.append(paragraph.replace(\"\\n\", \"<BR>\"))\n            else:\n                pars.append(paragraph.replace(\"\\n\", \" \"))\n        comment = \"\\n\".join(pars)\n        # go through data products and decide what to do with each one\n        busy = Purr.BusyIndicator()\n        # get list of DPs\n        dps, updated = self.wdplv.buildDPList()\n        # emit signal for all newly-created DPs\n        for dp in dps:\n            if not dp.archived:\n                self.emit(SIGNAL(\"creatingDataProduct\"), dp.sourcepath)\n        # update or return new entry\n        if self.entry:\n            self.entry.update(title=title, comment=comment, dps=dps)\n            self.entry.save(refresh_index=updated)\n            return self.entry\n        else:\n            return Purr.LogEntry(time.time(), title, comment, dps)", "response": "Updates entry object with current content of dialog. Returns new entry object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating an entry with current content of dialog by returning a new entry with all data products for ignore.", "response": "def updateIgnoredEntry(self):\n        \"\"\"Updates an ignore-entry object with current content of dialog, by\n        marking all data products for ignore.\"\"\"\n        # collect new DPs from items\n        dps = []\n        for item, dp in self.wdplv.getItemDPList():\n            if dp and not dp.archived:  # None means a new DP\n                # set all policies to ignore, unless already set to banish\n                if dp.policy != \"banish\":\n                    self.wdplv.setItemPolicy(item, \"ignore\")\n                    dp.set_policy(\"ignore\")\n                dps.append(dp)\n        # return new entry\n        return Purr.LogEntry(time.time(), dps=dps, ignore=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npopulating the dialog with contents of an existing entry.", "response": "def setEntry(self, entry=None):\n        \"\"\"Populates the dialog with contents of an existing entry.\"\"\"\n        busy = Purr.BusyIndicator()\n        self.entry = entry\n        self.setEntryTitle(entry.title)\n        self.setEntryComment(entry.comment.replace(\"\\n\", \"\\n\\n\").replace(\"<BR>\", \"\\n\"))\n        self.wdplv.clear()\n        self.wdplv.fillDataProducts(entry.dps)\n        self.setTimestamp(entry.timestamp)\n        self.updated = False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _restoreDPFromArchive(self):\n        dp = self._dp_menu_on\n        if dp and dp.archived:\n            dp.restore_from_archive(parent=self)", "response": "Callback for item menu."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _startDPDrag(self):\n        dp = self._dp_menu_on\n        if dp and dp.archived:\n            drag = QDrag(self)\n            mimedata = QMimeData()\n            mimedata.setUrls([QUrl.fromLocalFile(dp.fullpath)])\n            drag.setMimeData(mimedata)\n            drag.exec_(Qt.CopyAction | Qt.LinkAction)", "response": "Callback for item menu."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a value in the range [ 0 1 ) to an RGB tuple using a colormap.", "response": "def _value_to_color(value, cmap):\n    \"\"\"Convert a value in the range [0,1] to an RGB tuple using a colormap.\"\"\"\n    cm = plt.get_cmap(cmap)\n    rgba = cm(value)\n    return [int(round(255*v)) for v in rgba[0:3]]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef vizarray(x, cmap=None, scale=None, vmin=None, vmax=None, block_size=None):\n    if not (x.ndim == 2 or x.ndim == 1):\n        raise TypeError('This function only works with 1 or 2 dimensional arrays')\n    global _cmap, _scale, _vmin, _vmax, _block_size\n    cmap = cmap if cmap is not None else _cmap\n    scale = scale if scale is not None else _scale\n    vmin = vmin if vmin is not None else _vmin\n    vmax = vmax if vmax is not None else _vmax\n    block_size = block_size if block_size is not None else _block_size\n    base = x.base if x.base is not None else None\n    data = x.copy()\n    if scale:\n        n = colors.Normalize(vmin=vmin, vmax=vmax)\n        if base is not None:\n            n.autoscale(base)\n        data = n(data)\n    if data.ndim == 1:\n        rows = 1\n        cols = data.shape[0]\n        bg = BlockGrid(cols, rows, block_size=block_size)\n        for col in range(cols):\n            bg[0,col] = _value_to_color(data[col], cmap)\n    elif data.ndim == 2:\n        rows = data.shape[0]\n        cols = data.shape[1]\n        bg = BlockGrid(cols, rows, block_size=block_size)\n        for row in range(rows):\n            for col in range(cols):\n                bg[row, col] = _value_to_color(data[row, col], cmap)\n    return bg", "response": "Visualize a NumPy array using ipythonblocks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenable automatic visualization of NumPy arrays in the IPython Notebook.", "response": "def enable_notebook():\n    \"\"\"Enable automatic visualization of NumPy arrays in the IPython Notebook.\"\"\"\n    try:\n        from IPython.core.getipython import get_ipython\n    except ImportError:\n        raise ImportError('This feature requires IPython 1.0+')\n    ip = get_ipython()\n    f = ip.display_formatter.formatters['text/html']\n    f.for_type(np.ndarray, _array_to_html)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disable_notebook():\n    try:\n        from IPython.core.getipython import get_ipython\n    except ImportError:\n        raise ImportError('This feature requires IPython 1.0+')\n    ip = get_ipython()\n    f = ip.display_formatter.formatters['text/html']\n    f.type_printers.pop(np.ndarray, None)", "response": "Disable automatic visualization of NumPy arrays in the IPython Notebook."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _deserialize(x, elementType, compress, relicReadBinFunc):\n    # Convert the bytearray into an appropriately sized ctypes array of bytes\n    b = (c_ubyte*len(x))(*bytearray(x))\n\n    # The compression flag is an integer.\n    flag = c_int(compress)\n\n    # Deserialize using the read function.\n    result = elementType()\n    relicReadBinFunc(byref(result), byref(b), len(x), flag)\n    return result", "response": "Deserializes a bytearray x into an element of the correct type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomparing two elements using the Relic function.", "response": "def _equal(a, b, identityLong, relicCompare):\n    \"\"\"\n    Compares element @a to @b. If @b is @identityLong, returns \n    a.isIdentity(). Otherwise, normalize a and b and use the relicCompare\n    function to test for equality.\n    \"\"\"\n    # Check for an identity comparison.\n    if isinstance(b, (long, int)) and b == identityLong:\n        return a.isIdentity()\n\n    # Verify type and fix normalization for a valid comparison.\n    assertSameType(a, b)\n    a.normalize()\n    b.normalize()\n\n    # Compare the elements using the relic function.\n    return relicCompare(byref(a), byref(b)) == EQUAL"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a value from obj. cached if not None", "response": "def _getCachedValue(obj, relicFunc, resultType):\n    \"\"\"\n    Retrieves a value from obj.cached (if not None) or calls @relicFunc and \n    caches the result (of @resultType) int obj.cached.\n\n    This is a common implementation for orderG1/G2/Gt and generatotG1/G2/Gt\n    \"\"\"\n    # If the value has not been previously cached, fetch \n    if not obj.cached:\n        obj.cached = resultType()\n        relicFunc(byref(obj.cached))\n    return obj.cached"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize an element using the proper function relicSizeBinFunc into a bytearray.", "response": "def _serialize(element, compress, relicSizeBinFunc, relicWriteBinFunc):\n    \"\"\"\n    Serializes an @element using the proper function @relicWriteBinFunc into\n    a bytearray. @compress specifies whether the element should be compressed.\n    @relicSizeBinFunc is used to determine the size of the serialized output.\n    This is underlying implementation for serialize G1, G2, and Gt.\n    \"\"\"\n    cFlag = c_int(compress)\n    size = relicSizeBinFunc(byref(element), cFlag)\n\n    # Make an array of the correct size. \n    binArray = (c_ubyte*size)()\n\n    # Serialize\n    relicWriteBinFunc(byref(binArray), size, byref(element), cFlag)\n    return bytearray(binArray)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a point into a string representation of the .", "response": "def formatPoint(point, affine):\n    \"\"\"\n    Retrieves a string representation of @point\n    \"\"\"\n    # Affine coordinates: (x,y)        \n    if affine:\n        fmt = \"\\tx:{}\\n\\ty:{}\"\n        coords = [point.x, point.y]\n\n    # Projected coordinates: (x,y,z)\n    else:\n        fmt = \"\\tx:{}\\n\\ty:{}\\n\\tz:{}\"\n        coords = [point.x, point.y, point.z]\n\n    coordText = map(hexString, coords)\n    return fmt.format(*coordText)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef serializeEc(P, compress=True):\n    return _serialize(P, compress, librelic.ec_size_bin_abi,\n        librelic.ec_write_bin_abi)", "response": "Serialize a binary version of the current point."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_templates():\n    templates = []\n    templates_directory = (inspect.getsourcefile(lambda: 0).rstrip('__init__.py') +\n                           'templates')\n    template_files = os.listdir(templates_directory)\n    for template_file in template_files:\n        if template_file.startswith('.') or not template_file.endswith('.py'):\n            continue\n        # Hack for dev development and disutils\n        try:\n            template_module = importlib.import_module('templates.{}'.format(\n               template_file.rstrip('.py')\n            ))\n        except ImportError:\n            template_module = importlib.import_module('ross.templates.{}'.format(\n               template_file.rstrip('.py')\n            ))\n        # Iterate throw items in template.\n        # If there are variable ends with 'templates',\n        # extend templates list with it.\n        for (name, content) in template_module.__dict__.items():\n            if name.endswith('templates'):\n                for (regex_text, data_func) in content:\n                    templates.append((re.compile(regex_text, re.IGNORECASE), data_func))\n    return templates", "response": "Load python modules from templates directory and get templates list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove punctuation marks articles and bot appeals from user s message text", "response": "def normalize_message(message_text):\n    \"\"\"\n    Remove punctuation marks, articles\n    and bot appeals (like 'hey bot')\n\n    :param message_text: user's message text\n    :return: normalized message text\n    \"\"\"\n    for mark in PUNCTUATION_MARKS:\n        message_text = message_text.replace(mark, ' ')\n    # Add barier elements for not deleting middle of word\n    message_text = ' ' + message_text + ' '\n    for article in ARTICLES:\n        message_text = message_text.replace(article, ' ')\n    # Delete extra spaces\n    message_text = ' '.join(message_text.split())\n    # TODO: Delete bot appeals (like 'hey bot', 'hi', 'bot') if it's not\n    #       the only content of message\n    return message_text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing a user s message text and return a result object.", "response": "def process_message(message_text):\n    \"\"\"\n    Search matches for message_text in templates and return data about message.\n    If there is no template for message: return None\n\n    :param message_text: user's message text\n    :return: Result object or None\n    \"\"\"\n    message_text = normalize_message(message_text)\n    for (regex, data_lambda) in TEMPLATES:\n        match = regex.search(message_text)\n        if match:\n            result = Request(**data_lambda(match))\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noutputting Pygments if required else use default html5 output", "response": "def code_block(self, node, entering):\n        '''Output Pygments if required else use default html5 output'''\n        if self.use_pygments:\n            self.cr()\n            info_words = node.info.split() if node.info else []\n\n            if len(info_words) > 0 and len(info_words[0]) > 0:\n                try:\n                    lexer = get_lexer_by_name(info_words[0])\n                except ValueError:\n                    # no lexer found - use the text one instead of an exception\n                    lexer = TextLexer()\n            else:\n                lexer = TextLexer()\n\n            formatter = HtmlFormatter(**self.pygments_options)\n            parsed = highlight(node.literal, lexer, formatter)\n            self.lit(parsed)\n            self.cr()\n        else:\n            super().code_block(node, entering)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses text with frontmatter return metadata and content.", "response": "def _parse(self, text):\n        '''\n        Parse text with frontmatter, return metadata and content.\n        If frontmatter is not found, returns an empty metadata dictionary and original text content.\n        '''\n        # ensure unicode first\n        text = str(text).strip()\n\n        if not text.startswith(DELIMITER):\n            return {}, text\n\n        try:\n            _, fm, content = BOUNDARY.split(text, 2)\n        except ValueError:\n            # if we can't split, bail\n            return {}, text\n        # loader_class = self.loader_factory(self)\n        metadata = yaml.load(fm, Loader=self.loader_class)\n        metadata = metadata if (isinstance(metadata, dict)) else {}\n        return metadata, content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the dict containing document metadata", "response": "def _parse_metadata(self, meta):\n        \"\"\"Return the dict containing document metadata\"\"\"\n        formatted_fields = self.settings['FORMATTED_FIELDS']\n\n        output = collections.OrderedDict()\n        for name, value in meta.items():\n            name = name.lower()\n            if name in formatted_fields:\n                rendered = self._render(value).strip()\n                output[name] = self.process_metadata(name, rendered)\n            else:\n                output[name] = self.process_metadata(name, value)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _render(self, text):\n        '''Render CommonMark with ettings taken in account'''\n        parser = commonmark.Parser()\n        ast = parser.parse(text)\n        renderer = HtmlRenderer(self)\n        html = renderer.render(ast)\n        return html", "response": "Render CommonMark with ettings taken in account"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef yaml_markdown_constructor(self, loader, node):\n        '''Allows to optionnaly parse Markdown in multiline literals'''\n        value = loader.construct_scalar(node)\n        return self._render(value).strip()", "response": "Allows to optionnaly parse Markdown in multiline literals"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallowing to optionnaly parse Markdown in multiline literals", "response": "def yaml_multiline_as_markdown_constructor(self, loader, node):\n        '''Allows to optionnaly parse Markdown in multiline literals'''\n        value = loader.construct_scalar(node)\n        return self._render(value).strip() if node.style == '|' else value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests if the integer n is a prime number.", "response": "def is_prime(n):\n\n    \"\"\" Miller-Rabin primality test. Keep in mind that this is not a deterministic algorithm: if it return True,\n    it means that n is probably a prime.\n\n    Args:\n        n (int): the integer to check\n\n    Returns:\n         True if n is probably a prime number, False if it is not\n\n    Raises:\n        TypeError: if n is not an integer\n\n    Note:\n        Adapted from https://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test#Python\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting an integer\")\n\n    if n < 2:\n        return False\n    if n in __known_primes:\n        return True\n    if any((n % p) == 0 for p in __known_primes):\n        return False\n    d, s = n - 1, 0\n    while not d % 2:\n        d, s = d >> 1, s + 1\n\n    def try_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2 ** i * d, n) == n - 1:\n                return False\n        return True\n\n    return not any(try_composite(a) for a in __known_primes[:16])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a generator that yields all the positive divisors of the given integer n.", "response": "def find_divisors(n):\n\n    \"\"\" Find all the positive divisors of the given integer n.\n\n    Args:\n        n (int): strictly positive integer\n\n    Returns:\n        A generator of all the positive divisors of n\n\n    Raises:\n        TypeError: if n is not an integer\n        ValueError: if n is negative\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting a strictly positive integer\")\n    if n <= 0:\n        raise ValueError(\"Expecting a strictly positive integer\")\n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors = {i, n//i}\n            for divisor in divisors:\n                yield divisor"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncount the number of divisors of an integer n.", "response": "def count_divisors(n):\n\n    \"\"\" Count the number of divisors of an integer n\n\n    Args:\n        n (int): strictly positive integer\n\n    Returns:\n        The number of distinct divisors of n\n\n    Raises:\n        TypeError: if n is not an integer\n        ValueError: if n is negative\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting a strictly positive integer\")\n    if n <= 0:\n        raise ValueError(\"Expecting a strictly positive integer\")\n\n    number_of_divisors = 1\n    remain = n\n\n    for p in prime_generator():\n        if p > n:\n            return number_of_divisors\n\n        exponent = 1\n        while remain % p == 0:\n            remain = remain // p\n            exponent += 1\n        number_of_divisors *= exponent\n\n        if remain == 1:\n            return number_of_divisors"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prime_generator(p_min=2, p_max=None):\n\n    \"\"\" Generator of prime numbers using the sieve of Eratosthenes.\n\n    Args:\n        p_min (int): prime numbers lower than p_min will not be in the resulting primes\n        p_max (int): the generator will stop when this value is reached, it means that there\n            will be no prime bigger than this number in the resulting primes. If p_max\n            is None, there will not be any upper limit\n\n    Returns:\n        A generator of all the consecutive primes between p_min and p_max\n\n    Raises:\n        TypeError: if p_min or p_max is not an integer\n\n    \"\"\"\n\n    if not isinstance(p_min, int):\n        raise TypeError(\"Expecting an integer\")\n    if p_max is not None and not isinstance(p_max, int):\n        raise TypeError(\"Expecting an integer\")\n\n    q = max(p_min, 3)\n    if q % 2 == 0:\n        q += 1\n    if p_min <= 2 and (p_max is None or p_max >= 2):\n        yield 2  # outside the while block to make the double increment optimization work\n\n    while p_max is None or q <= p_max:\n        if is_prime(q):\n            yield q\n        q += 2", "response": "Generator of prime numbers between two integer primes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sieve_of_eratosthenes(p_min=2, p_max=None):\n\n    \"\"\" Generator of prime numbers using the sieve of Eratosthenes.\n\n    Note:\n        Adapted from http://code.activestate.com/recipes/117119/\n\n    Args:\n        p_min (int): prime numbers lower than p_min will not be in the resulting primes\n        p_max (int): the generator will stop when this value is reached, it means that there\n            will be no prime bigger than this number in the resulting primes. If p_max\n            is None, there will not be any upper limit\n\n    Returns:\n        A generator of all the consecutive primes between p_min and p_max\n\n    Raises:\n        TypeError: if p_min or p_max is not an integer\n\n    \"\"\"\n\n    if not isinstance(p_min, int):\n        raise TypeError(\"Expecting an integer\")\n    if p_max is not None and not isinstance(p_max, int):\n        raise TypeError(\"Expecting an integer\")\n\n    sieve = {}\n    q = 2\n\n    while p_max is None or q <= p_max:\n        if q not in sieve:\n            if q >= p_min:\n                yield q\n            sieve[q * q] = [q]\n        else:\n            for p in sieve[q]:\n                sieve.setdefault(p + q, []).append(p)\n            del sieve[q]\n\n        q += 1", "response": "Generator of prime numbers using the sieve of Eratosthenes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the binomial coefficient of the current language tree element n and k.", "response": "def binomial_coefficient(n, k):\n\n    \"\"\" Calculate the binomial coefficient indexed by n and k.\n\n    Args:\n        n (int): positive integer\n        k (int): positive integer\n\n    Returns:\n        The binomial coefficient indexed by n and k\n\n    Raises:\n        TypeError: If either n or k is not an integer\n        ValueError: If either n or k is negative, or if k is strictly greater than n\n\n    \"\"\"\n\n    if not isinstance(k, int) or not isinstance(n, int):\n        raise TypeError(\"Expecting positive integers\")\n    if k > n:\n        raise ValueError(\"k must be lower or equal than n\")\n    if k < 0 or n < 0:\n        raise ValueError(\"Expecting positive integers\")\n\n    return factorial(n) // (factorial(k) * factorial(n - k))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eulers_totient(n):\n\n    \"\"\" Calculate the value of Euler's totient for a given integer\n\n    Args:\n        n (int): strictly positive integer\n\n    Returns:\n        The value of Euler's totient for n\n\n    Raises:\n        TypeError: If either n or k is not an integer\n        ValueError: If either n or k is negative, or if k is strictly greater than n\n\n    \"\"\"\n\n    if not isinstance(n, int):\n        raise TypeError(\"Expecting a strictly positive integer\")\n    if n <= 0:\n        raise ValueError(\"Expecting a strictly positive integer\")\n\n    if n == 1:\n        return 1\n\n    result = 0\n    for i in range(1, n):\n        if gcd(i, n) == 1:\n            result += 1\n    return result", "response": "Calculates the value of Euler s totient for a given integer n."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_searchable_typeahead(cls):\n        window.destroy_typeahead_tag(\"#conspect_subconspect_typeahead\")\n        args = [\n            {\n                \"name\": name,\n                \"data\": [x[\"name\"] for x in cls._get_subconspects(uid)],\n            }\n            for name, uid in conspectus.cosp_id_pairs\n        ]\n        window.make_multi_searchable_typeahead_tag(\n            \"#conspect_subconspect_typeahead\",\n            *args\n        )", "response": "Create typeahead element and fill it with data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(cls):\n        if cls.is_twoconspect:\n            return cls.subconspect_el.value or None\n\n        input_value = cls.input_el.value.strip()\n\n        # blank user input -> no value was yet set\n        if not input_value:\n            return None\n\n        mdt = conspectus.mdt_by_name.get(input_value)\n\n        if not mdt:\n            alert(\"Invalid sub-conspect `%s`!\" % input_value)\n            return None\n\n        return mdt", "response": "Get code selected by user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets value for input and select tags based on MDT.", "response": "def set(cls, mdt):\n        \"\"\"\n        Set value for <input> / <select> tags based on MDT.\n\n        Args:\n            mdt (str): MDT of the conspect / subconspect.\n        \"\"\"\n        if type(mdt) in [list, tuple]:\n            mdt = mdt[0]\n\n        if isinstance(mdt, dict):\n            mdt = mdt[\"val\"]\n\n        if not mdt:\n            cls.conspect_el.value = \"\"\n            cls.subconspect_el.html = \"\"\n            cls.input_el.value = \"\"\n            return\n\n        # set twoconspect\n        data = conspectus.subs_by_mdt.get(mdt)\n\n        if data:\n            cls.conspect_el.value = data[\"conspect_id\"]\n\n            cls._draw_subconspects(data[\"conspect_id\"])\n            cls.subconspect_el.value = mdt\n\n            # set input\n            cls.input_el.value = data[\"name\"]\n        else:\n            cls.input_el.value = mdt + \" not found\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning dictionary with conspect info.", "response": "def get_dict(cls):\n        \"\"\"\n        Return dictionary with conspect / subconspect info.\n        \"\"\"\n        mdt = cls.get()\n\n        if not mdt:\n            return {}\n\n        return conspectus.subs_by_mdt.get(mdt, {})"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bind_switcher(cls):\n        def show_two_conspect():\n            cls.is_twoconspect = True\n\n            # search by class\n            for el in cls.two_conspect_el:\n                el.style.display = \"block\"\n\n            cls.whole_conspect_subconspect_el.style.display = \"none\"\n\n        def hide_two_conspect():\n            cls.is_twoconspect = False\n\n            for el in cls.two_conspect_el:\n                el.style.display = \"none\"\n\n            cls.whole_conspect_subconspect_el.style.display = \"block\"\n\n        def show_or_hide_two_conspect(ev):\n            val = cls.get()\n\n            # check / uncheck both checkboxes\n            for el in cls.switcher_els:\n                el.checked = ev.target.checked\n\n            if ev.target.checked:\n                hide_two_conspect()\n                cls.set(val)\n                return\n\n            show_two_conspect()\n            cls.set(val)\n\n        # bind both `conspect_switchers`\n        for el in document.get(selector=\".conspect_switcher\"):\n            el.bind(\"change\", show_or_hide_two_conspect)", "response": "Bind the switch checkbox to functions for switching between types of types of switches."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow error around the conspect elements.", "response": "def show_error(cls, error=True):\n        \"\"\"\n        Show `error` around the conspect elements. If the `error` is ``False``,\n        hide it.\n        \"\"\"\n        if error:\n            cls.input_el.style.border = \"2px solid red\"\n            cls.conspect_el.style.border = \"2px solid red\"\n            cls.subconspect_el.style.border = \"2px solid red\"\n        else:\n            cls.input_el.style.border = \"0\"\n            cls.conspect_el.style.border = \"0\"\n            cls.subconspect_el.style.border = \"0\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init(cls):\n        for el in cls.switcher_els:\n            el.checked = False\n\n        cls.bind_switcher()\n\n        cls._draw_conspects()\n        cls._create_searchable_typeahead()", "response": "Initialize the switcher elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks that conspect element is properly selected.", "response": "def validate(cls):\n        \"\"\"\n        Make sure, that conspect element is properly selected. If not, show\n        error.\n        \"\"\"\n        if cls.get_dict():\n            cls.show_error(False)\n            return True\n\n        cls.show_error(True)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset the conspect elements to initial state.", "response": "def reset(cls):\n        \"\"\"\n        Reset the conspect elements to initial state.\n        \"\"\"\n        cls.input_el.value = \"\"\n        cls.subconspect_el.html = \"\"\n        cls.show_error(False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef motioncheck(ref_file, end_file, out_path=None, thres=5.0):\n\n    ref = nib.load(ref_file)\n    end = nib.load(end_file)\n    ref_data = ref.get_data()\n    end_data = end.get_data()    \n\n    # Check if same affine space. modality must be the same to use realign, \n    # and prescription must be the same to deduce motion\n    ref_aff=ref.get_affine()\n    end_aff=end.get_affine()\n\n    if np.array_equal(ref_aff, end_aff):\n        print('affines match')\n    else:\n        raise ValueError(\"Affines of start and end images do not match\")\n\n    # save only axials\n    refax = ref_data[:, :, :, 0, np.newaxis]\n    endax = end_data[:, :, :, 0, np.newaxis]\n\n    if out_path is None:\n        path = os.path.dirname(ref_file)\n    \n    refax_img = nib.Nifti1Image(refax, ref_aff)\n    nib.save(refax_img, op.join(out_path, 'refax.nii.gz'))\n    endax_img = nib.Nifti1Image(endax, ref_aff)\n    nib.save(endax_img, op.join(out_path, 'endax.nii.gz'))\n\n    # realignment\n    ref_file = op.join(out_path, 'refax.nii.gz')\n    in_file = op.join(out_path, 'endax.nii.gz')\n    mat_file = op.join(out_path, 'mat.nii.gz')\n\n    mcflt = fsl.MCFLIRT(in_file=in_file, ref_file=ref_file, save_mats=True,\n                        cost='mutualinfo')\n    res = mcflt.run() \n\n    print('realignment affine matrix saved in mat_file: %s'\n          %res.outputs.mat_file)\n\n    aff_file=res.outputs.mat_file\n    aff = np.loadtxt(aff_file, dtype=float)\n\n    # compute RMS as indicator of motion\n    rel=aff[0:3, 3]\n    rms = np.sqrt(np.mean(rel**2))\n  \n    if rms>=thres:\n        passed=False\n    else:\n        passed=True\n\n\n    return rms, passed", "response": "Checks if motion between two structural scans is allowed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a SQL query string for the related items.", "response": "def form_query(self, columns, options={}):\n        \"\"\"\n        :param str columns: literal sql string for list of columns\n        :param dict options: dict supporting a single key \"direct\" as in the constructor\n        :return: sql string\n        \"\"\"\n        from_cl = 'FROM'\n\n        direct = options.get('direct', self.direct)\n        if direct:\n            if columns != '*':\n                raise ProgrammingError(\"Column lists cannot be specified for a direct function call.\")\n            columns = ''\n            from_cl = ''\n\n        if len(self.args) >= 1:\n            replace = ['%s' for x in range(len(self.args))]\n            func = \"%s(\" % self.query_base + \",\".join(replace) + \")\"\n        else:\n            func = \"%s()\" % self.query_base\n\n        return \"SELECT %s %s %s\" % (columns, from_cl, func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses an array of string from argparser to SynonymSet", "response": "def parse_from_args(synonyms):\n    '''\n    Parse an array of string from argparser\n    to SynonymSet\n    '''\n\n    syns_str = ''.join(synonyms)\n\n    syns_str = syns_str.replace(' ', '')\n    \n    syn_set = SynonymSet()\n\n    # to check if we are parsing inside the parenthesis\n    inside_set = False\n    current_syn = ''\n    current_syn_set = set()\n\n    for char in syns_str:\n        if char == '{':\n            inside_set = True\n            current_syn_set = set()\n            continue\n\n        if char == '}':\n            inside_set = False\n            current_syn_set.add(current_syn)\n\n            syn_set.add_set(current_syn_set)\n\n            current_syn = ''\n\n            continue\n\n        if not inside_set:\n            raise Exception(\"Incorrect synonyms {}\".format(syns_str))\n\n        if char == ',':\n            if current_syn == '':\n                raise Exception(\"Incorrect synonyms {}\".format(syns_str))\n\n            current_syn_set.add(current_syn)\n            current_syn = ''\n\n            continue\n\n        current_syn += char\n\n    return syn_set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_from_array(arr):\n    syn_set = SynonymSet()\n\n    for synonyms in arr:\n        _set = set()\n\n        for synonym in synonyms:\n            _set.add(synonym)\n\n        syn_set.add_set(_set)\n\n    return syn_set", "response": "Parse 2d array into SynonymSet"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a psycopg2 cursor object.", "response": "def cursor(self,*args,**kwargs):\n        \"\"\"\n        :param cursor_factory: Override default Cursor\n        :return: psycopg2 cursor\n        \"\"\"\n        d_out(\"Handle.cursor: Creating cursor..\")\n        if not self.open:\n            raise Exception(\"Connection isn't open.\")\n\n        if 'cursor_factory' not in kwargs or kwargs['cursor_factory'] == None:\n            kwargs[\"cursor_factory\"] = Cursor\n        callback = kwargs.pop('callback', None)\n        cur = self.conn.cursor(*args,**kwargs)\n        if callback:\n            d_out('Handle.cursor() setting callback attrib {0}'.format(callback))\n            cur.callback = callback\n        return cur"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open(self):\n        try:\n            if self.conn.get_backend_pid():\n                return True\n        except psycopg2.InterfaceError as e:\n            if str(e) == \"connection already closed\":\n                # We already lost our connection. Attempt to reforge it.\n                self.__reconnect__()\n                if self.conn.get_backend_pid() >= 0:\n                    return True # Resets it.\n            else:\n                raise e", "response": "Open the connection and return True if it is open False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_mongodb_host_val(key, default, mongodb_host, mongodb_defaults):\n    # If mongodb_host[key] is not already set, its value is going to be picked\n    # from mongodb_defaults[key]\n    if key not in mongodb_host:\n        if key in mongodb_defaults:\n            mongodb_host[key] = mongodb_defaults[key]\n        else:\n            # BUT, if also mongodb_defaults[key] doesn't exist\n            # the value picked is going to be 'default' as last resort\n            mongodb_host[key] = default\n        if key != 'user_name' and key != 'password':\n            log.msg_debug(\"Setting default '{key}'='{value}' \"\n                          .format(key=key, value=mongodb_host[key]))", "response": "Set a value in a cascade fashion for mongodb_host"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_backup_files(*,\n                      mongodump=MONGODB_DEFAULT_MONGODUMP,\n                      hosts={},\n                      host_defaults={},\n                      dry_run=False,\n                      **kwargs):\n    \"\"\"\n    Backup all specified databases into a gzipped tarball via mongodump\n\n    :param mongodump(str, optional): Path to mongodump executable\n    :param hosts(dict, optional): A dict containing hosts info to be backed up\n    :param host_defaults(dict, optional): Default values applied to each host\n    :param dry_run(bool, optional): Whether to activate dry run mode\n    :param \\*\\*kwargs: arbitrary keyword arguments\n    :raises TypeError: if an argument in kwargs does not have the type expected\n    :raises ValueError: if an argument within kwargs has an invalid value\n    \"\"\"\n\n    # Output directory\n    output_dir = fs.get_output_dir()\n\n    # Type checks\n    utils.chkstr(mongodump, 'mongodump')\n\n    # List of mongodb hosts holding databases\n    mongodb_hosts = hosts\n    if len(mongodb_hosts) == 0:\n        raise ValueError(\"No mongodb 'hosts' specified!\")\n\n    # Default values applied to each host if necessary,\n    # this setting takes effect on a 'cascade' fashion.\n    mongodb_defaults = host_defaults\n\n    # Collected list of files generated by _make_backup_file\n    mongodump_files = {}\n\n    # Backup cycle for each mongodb host\n    for mongodb_host_name, mongodb_host in mongodb_hosts.items():\n\n        if type(mongodb_host) != dict:\n            raise TypeError(\"mongodb_host '{name}' must be dict\"\n                            .format(name=mongodb_host_name))\n\n        # For each host, its 'address' is essential\n        if 'address' not in mongodb_host:\n            raise KeyError(\"No 'address' specified!\")\n        utils.chkstr(mongodb_host['address'], 'address')\n\n        \"\"\"\n        For these keys, the value is going to be set in\n        in a 'cascade' fashion, if the value is not already set,\n        its value is going to be picked from the 'defaults'(mongodb_defaults)\n        sub-section within 'mongodb', as a last resort, its hardcoded default\n        value is going to be picked.\n        \"\"\"\n        # TODO: there has to be something better than this\n        _set_mongodb_host_val('user_name', MONGODB_DEFAULT_USER,\n                              mongodb_host, mongodb_defaults)\n        _set_mongodb_host_val('password', MONGODB_DEFAULT_PWD,\n                              mongodb_host, mongodb_defaults)\n        _set_mongodb_host_val('port', MONGODB_DEFAULT_PORT,\n                              mongodb_host, mongodb_defaults)\n        _set_mongodb_host_val('auth_db', MONGODB_DEFAULT_AUTH,\n                              mongodb_host, mongodb_defaults)\n\n        \"\"\"Merge dbs list with that of the host_defaults section (if any)\"\"\"\n        if 'dbs' in mongodb_defaults:\n            if 'dbs' in mongodb_host:\n                mongodb_host['dbs'] = _merge_dbs(mongodb_defaults['dbs'],\n                                                 mongodb_host['dbs'])\n            else:\n                mongodb_host['dbs'] = mongodb_defaults['dbs']\n\n        # Add the file name to the list to be returned\n        mongodump_files[mongodb_host_name] = _make_backup_file(dry_run=dry_run, mongodump=mongodump,\n                                                               output_dir=output_dir, name=mongodb_host_name,\n                                                               **mongodb_host)\n    # .. and finally, give it\n    return mongodump_files", "response": "This function takes a list of files and creates a backup file for each of the databases in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _mongodump_exec(mongodump, address, port, user, passwd, db,\n                    out_dir, auth_db, dry_run):\n    \"\"\"\n    Run mongodump on a database\n\n    :param address: server host name or IP address\n    :param port: server port\n    :param user: user name\n    :param passwd: password\n    :param db: database name\n    :param out_dir: output directory\n    :param auth_db: authentication database\n    :param dry_run: dry run mode\n    :raises OSError: if mongodump process returns error\n    \"\"\"\n\n    # Log the call\n    log.msg(\"mongodump [{mongodump}] db={db} auth_db={auth_db}\" \\\n            \" mongodb://{user}@{host}:{port} > {output}\"\n            .format(mongodump=mongodump, user=user, host=address,\n                    port=port, db=db, auth_db=auth_db, output=out_dir))\n\n    # Prepare the call\n    args = \"--host {host}:{port} -d {db} -u {user} -p {passwd} \" \\\n           \"--authenticationDatabase {auth_db} -o {output}\"\\\n           .format(host=address, port=port, db=db, user=user, passwd=passwd,\n                   auth_db=auth_db, output=out_dir)\n\n    if not dry_run:\n        # Make the actual call to mongodump\n        shell.run(mongodump, args=args)", "response": "Execute mongodump on a database and return the result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify_login(request):\n    verifier = request.registry['persona.verifier']\n    try:\n        data = verifier.verify(request.POST['assertion'])\n    except (ValueError, browserid.errors.TrustError) as e:\n        logger.info('Failed persona login: %s (%s)', e, type(e).__name__)\n        raise HTTPBadRequest('Invalid assertion')\n    return data['email']", "response": "Verifies the assertion and csrf token in the given request. Returns the email of the user if everything is valid raises HTTPBadRequest if everything is invalid raises HTTPBadRequest if everything is invalid raises HTTPBadRequest"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews to check the persona assertion and remember the user", "response": "def login(request):\n    \"\"\"View to check the persona assertion and remember the user\"\"\"\n    email = verify_login(request)\n    request.response.headers.extend(remember(request, email))\n    return {'redirect': request.POST.get('came_from', '/'), 'success': True}"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nviews to forget the user", "response": "def logout(request):\n    \"\"\"View to forget the user\"\"\"\n    request.response.headers.extend(forget(request))\n    return {'redirect': request.POST.get('came_from', '/')}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef forbidden(request):\n    template = pkg_resources.resource_string('pyramid_persona', 'templates/forbidden.html').decode()\n    html = template % {'js': request.persona_js, 'button': request.persona_button}\n    return Response(html, status='403 Forbidden')", "response": "A basic 403 view with a login button"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_bmp(path):\n        surface = object.__new__(Surface)\n        surface._ptr = check_ptr_err(lib.SDL_LoadBMP_RW(lib.SDL_RWFromFile(path, \"rb\"), 1))\n        return surface", "response": "Load a surface from a BMP file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform a fast blit from the source surface to the destination surface.", "response": "def blit(self, src_rect, dst_surf, dst_rect):\n        \"\"\"Performs a fast blit from the source surface to the destination surface.\n        This assumes that the source and destination rectangles are\n        the same size.  If either src_rect or dst_rect are None, the entire\n        surface is copied.  The final blit rectangles are saved\n        in src_rect and dst_rect after all clipping is performed.\n\n        Args:\n            src_rect (Rect): Source rect.\n            dst_surf (Surface): Destination surface.\n            dst_rect (Rect): Destination rect.\n\n        Raises:\n            SDLError: If the blit fails.\n        \"\"\"\n        check_int_err(lib.SDL_UpperBlit(self._ptr, src_rect._ptr, dst_surf._ptr, dst_rect._ptr))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef peek(quantity, min_type=EventType.firstevent, max_type=EventType.lastevent):\n\n    return _peep(quantity, lib.SDL_PEEKEVENT, min_type, max_type)", "response": "Return events at the front of the event queue within the specified minimum and maximum type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(quantity, min_type=EventType.firstevent, max_type=EventType.lastevent):\n    return _peep(quantity, lib.SDL_GETEVENT, min_type, max_type)", "response": "Return the specified number of events from the event queue within the specified minimum and maximum type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npolls for currently pending events.", "response": "def poll():\n    \"\"\"Polls for currently pending events.\n\n    Returns:\n        Iterable[Event]: Events from the event queue.\n    \"\"\"\n    event_ptr = ffi.new('SDL_Event *')\n    while lib.SDL_PollEvent(event_ptr):\n        yield Event._from_ptr(event_ptr)\n        event_ptr = ffi.new('SDL_Event *')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef separator(self):\n        cells = dict([(column, \"-\" * self.column_widths[column]) for column in self.columns])\n        return ColorRow(self, **cells)", "response": "Generate a separator row using current column widths."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_texture(renderer, file):\n    return Texture._from_ptr(check_ptr_err(lib.IMG_LoadTexture(renderer._ptr, file)))", "response": "Loads an image directly into a render texture."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self):\n        now = datetime.now()\n        if self._start_time:\n            if self._stop_time:\n                return (self._stop_time - self._start_time).total_seconds()\n            return (now - self._start_time).total_seconds()\n        return 0.", "response": "Get the current timer value in seconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a new Trello card.", "response": "def make_trello_card(*args, **kwargs):\n    \"\"\"Generate a new Trello card\"\"\"\n    # Generate our card board and list\n    # DEV: board is never used...\n    # TODO: This is very backwards with needing a board to get a client...\n    #   Might move to another lib\n    # https://github.com/sarumont/py-trello/blob/0.4.3/trello/trellolist.py#L11-L20\n    # https://github.com/sarumont/py-trello/blob/0.4.3/trello/trellolist.py#L48-L63\n    board = Board(client=trello_client, board_id=TRELLO_BOARD_ID)\n    card_list = List(board=board, list_id=TRELLO_LIST_ID)\n    return card_list.add_card(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to Slack", "response": "def send_slack_message(channel, text):\n    \"\"\"Send a message to Slack\"\"\"\n    http = httplib2.Http()\n    return http.request(SLACK_MESSAGE_URL, 'POST', body=json.dumps({\n        'channel': channel,\n        'text': text,\n    }))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bootstrap_stat(arr, stat=np.mean, n_iters=1000, alpha=0.05):\n    stat_orig = stat(arr, 0)\n\n    boot_arr = np.empty((arr.shape[-1] , n_iters))\n    for ii in xrange(n_iters):\n        this_arr=arr[np.random.random_integers(0, arr.shape[0]-1, arr.shape[0])]\n        boot_arr[:, ii] = stat(this_arr, 0)\n\n    eb = np.array([stats.scoreatpercentile(boot_arr[xx], 1-(alpha/2)) -\n                   stats.scoreatpercentile(boot_arr[xx], alpha/2)\n                   for xx in range(boot_arr.shape[0])])\n\n    return stat_orig, eb", "response": "This function generates a boot -strap distribution of the mean of an array on axis 0."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nseparate the water and non - water data from each other.", "response": "def separate_signals(data, w_idx=[1, 2, 3]):\n   \"\"\"\n   Separate the water and non-water data from each other\n\n   Parameters\n   ----------\n   data : nd array\n      FID signal with shape (transients, echos, coils, time-points)\n\n   w_idx : list (optional)\n      Indices into the 'transients' (0th) dimension of the data for the signal\n      that is not water-suppressed\n\n   Returns\n   -------\n   water_data, w_supp_data : tuple\n       The first element is an array with the transients in the data in which\n       no water suppression was applied. The second element is an array with\n       the transients in which water suppression was applied\n   \"\"\"\n   # The transients are the first dimension in the data\n   idxes_w = np.zeros(data.shape[0], dtype=bool)\n   idxes_w[w_idx] = True\n   # Data with water unsuppressed (first four transients - we throw away the\n   # first one which is probably crap):\n   w_data = data[np.where(idxes_w)]\n   # Data with water suppressed (the rest of the transients):\n   idxes_nonw = np.zeros(data.shape[0], dtype=bool)\n   idxes_nonw[np.where(~idxes_w)] = True\n   idxes_nonw[0] = False\n   w_supp_data = data[np.where(idxes_nonw)]\n\n   return w_data, w_supp_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncombining data across a set of coils.", "response": "def coil_combine(data, w_idx=[1,2,3], coil_dim=2, sampling_rate=5000.):\n    \"\"\"\n    Combine data across coils based on the amplitude of the water peak,\n    according to:\n\n    .. math::\n        \n        X = \\sum_{i}{w_i S_i}\n\n   Where X is the resulting combined signal, $S_i$ are the individual coil\n   signals and $w_i$ are calculated as:\n\n   .. math::\n   \n        w_i = mean(S_i) / var (S_i)\n        \n    following [Hall2013]_. In addition, we apply a phase-correction, so that\n    all the phases of the signals from each coil are 0\n\n    Parameters\n    ----------\n    data : float array\n       The data as it comes from the scanner, with shape (transients, echos,\n    coils, time points) \n    \n    w_idx : list\n       The indices to the non-water-suppressed transients. Per default we take\n        the 2nd-4th transients. We dump the first one, because it seems to be\n        quite different than the rest of them...\n\n    coil_dim : int\n        The dimension on which the coils are represented. Default: 2\n\n    sampling rate : float\n        The sampling rate in Hz. Default : 5000.\n  \n    References\n    ----------\n\n    .. [Hall2013] Emma L. Hall, Mary C. Stephenson, Darren Price, Peter\n       G. Morris (2013). Methodology for improved detection of low\n       concentration metabolites in MRS: Optimised combination of signals from \n       multi-element coil arrays. Neuroimage 86: 35-42.  \n\n    .. [Wald1997] Wald, L. and Wright, S. (1997). Theory and application of\n       array coils in MR spectroscopy. NMR in Biomedicine, 10: 394-410.\n\n    .. [Keeler2005] Keeler, J (2005). Understanding NMR spectroscopy, second\n       edition. Wiley (West Sussex, UK).\n    \n    \"\"\"\n    w_data, w_supp_data = separate_signals(data, w_idx)\n\n    fft_w = np.fft.fftshift(fft.fft(w_data))\n    fft_w_supp = np.fft.fftshift(fft.fft(w_supp_data))\n    freqs_w = np.linspace(-sampling_rate/2.0,\n                          sampling_rate/2.0,\n                          w_data.shape[-1])\n    \n    # To determine phase and amplitude, fit a Lorentzian line-shape to each\n    # coils data in each trial: \n    # No bounds except for on the phase:\n    bounds = [(None,None),\n              (0,None),\n              (0,None),\n              (-np.pi, np.pi),\n              (None,None),\n              (None, None)]\n\n    n_params = len(bounds)\n    params = np.zeros(fft_w.shape[:-1] + (n_params,))\n\n    # Let's fit a Lorentzian line-shape to each one of these:\n    for repeat in range(w_data.shape[0]):\n       for echo in range(w_data.shape[1]):\n          for coil in range(w_data.shape[2]):\n             sig = fft_w[repeat, echo, coil]\n             # Use the private function to do this:\n             params[repeat, echo, coil] = _do_lorentzian_fit(freqs_w,\n                                                             sig, bounds)\n\n\n    # The area parameter stands for the magnitude:\n    area_w = params[..., 1]\n\n    # In each coil, we derive S/(N^2):\n    s = np.mean(area_w.reshape(-1, area_w.shape[-1]), 0)\n    n = np.var(area_w.reshape(-1, area_w.shape[-1]), 0)\n    amp_weight = s/n \n    # Normalize to sum to 1: \n    amp_weight = amp_weight / np.sum(amp_weight)    \n    \n    # Next, we make sure that all the coils have the same phase. We will use\n    # the phase of the Lorentzian to align the phases:\n    phase_param = params[..., 3]\n    zero_phi_w = np.mean(phase_param.reshape(-1, phase_param.shape[-1]),0)\n\n    # This recalculates the weight with the phase alignment (see page 397 in\n    # Wald paper):\n    weight = amp_weight * np.exp(-1j * zero_phi_w) \n\n    # Multiply each one of the signals by its coil-weights and average across\n    # coils:\n    na = np.newaxis  # Short-hand\n\n    # Collapse across coils for the combination in both the water \n    weighted_w_data = np.mean(np.fft.ifft(np.fft.fftshift(\n       weight[na, na, :, na] * fft_w)), coil_dim)\n    weighted_w_supp_data = np.mean(np.fft.ifft(np.fft.fftshift(\n       weight[na, na, : ,na] * fft_w_supp)) , coil_dim)\n\n    # Normalize each series by the sqrt(rms):\n    def normalize_this(x):\n       return  x * (x.shape[-1] / (np.sum(np.abs(x))))\n\n    weighted_w_data = normalize_this(weighted_w_data)\n    weighted_w_supp_data = normalize_this(weighted_w_supp_data)\n    # Squeeze in case that some extraneous dimensions were introduced (can\n    # happen for SV data, for example)\n    return weighted_w_data.squeeze(), weighted_w_supp_data.squeeze()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_spectra(data, filt_method=dict(lb=0.1, filt_order=256),\n                spect_method=dict(NFFT=1024, n_overlap=1023, BW=2),\n                phase_zero=None, line_broadening=None, zerofill=None):\n    \"\"\"\n    Derive the spectra from MRS data\n\n    Parameters\n    ----------\n    data : nitime TimeSeries class instance or array\n        Time-series object with data of shape (echos, transients, time-points),\n        containing the FID data. If an array is provided, we will assume that a\n        sampling rate of 5000.0 Hz was used\n\n    filt_method : dict\n        Details for the filtering method. A FIR zero phase-delay method is used\n        with parameters set according to these parameters\n        \n    spect_method : dict\n        Details for the spectral analysis. Per default, we use \n\n    line_broadening : float\n        Linewidth for apodization (in Hz).\n\n    zerofill : int\n        Number of bins to zero fill with.\n        \n    Returns\n    -------\n    f : \n         the center frequency of the frequencies represented in the\n        spectra\n\n     spectrum_water, spectrum_water_suppressed: \n        The first spectrum is for the data with water not suppressed and\n        the second spectrum is for the water-suppressed data.\n\n    Notes\n    -----\n    This function performs the following operations:\n\n    1. Filtering.\n    2. Apodizing/windowing. Optionally, this is done with line-broadening (see\n    page 92 of Keeler2005_.\n    3. Spectral analysis.\n        \n    .. [Keeler2005] Keeler, J (2005). Understanding NMR spectroscopy, second\n       edition. Wiley (West Sussex, UK).\n\n    \"\"\"\n    if not isinstance(data, nt.TimeSeries):\n       data = nt.TimeSeries(data, sampling_rate=5000.0)  \n    if filt_method is not None:\n        filtered = nta.FilterAnalyzer(data, **filt_method).fir\n    else:\n        filtered = data\n    if line_broadening is not None: \n       lbr_time = line_broadening * np.pi  # Conversion from Hz to\n                                           # time-constant, see Keeler page 94 \n    else:\n       lbr_time = 0\n\n    apodized = ut.line_broadening(filtered, lbr_time)\n   \n    if zerofill is not None:\n         new_apodized = np.concatenate([apodized.data,\n                    np.zeros(apodized.shape[:-1] + (zerofill,))], -1)\n\n         apodized = nt.TimeSeries(new_apodized,\n                                  sampling_rate=apodized.sampling_rate)\n\n    S = nta.SpectralAnalyzer(apodized,\n                             method=dict(NFFT=spect_method['NFFT'],\n                                         n_overlap=spect_method['n_overlap']),\n                             BW=spect_method['BW'])\n    \n    f, c = S.spectrum_fourier\n\n    return f, c", "response": "Derive the spectra from MRS data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsubtracting the residual water signal from the input signal and returns the corrected water - suppressed signal.", "response": "def subtract_water(w_sig, w_supp_sig):\n    \"\"\"\n    Subtract the residual water signal from the \n    Normalize the water-suppressed signal by the signal that is not\n    water-suppressed, to get rid of the residual water peak.\n\n    Parameters\n    ----------\n    w_sig : array with shape (n_reps, n_echos, n_points)\n       A signal with water unsupressed\n\n    w_supp_sig :array with shape (n_reps, n_echos, n_points)\n       A signal with water suppressed.\n\n    Returns\n    -------\n    The water suppressed signal with the additional subtraction of a scaled\n    version of the signal that is presumably just due to water.\n\n    \"\"\"\n    mean_nw = np.mean(w_supp_sig,0)\n    water_only = np.mean(w_sig - mean_nw, 0)\n    mean_water = np.mean(w_sig, 0)\n\n    scale_factor = water_only/mean_nw\n\n    corrected = w_supp_sig - water_only/scale_factor[...,0,np.newaxis]\n    return corrected"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _do_two_gaussian_fit(freqs, signal, bounds=None):\n   initial = _two_func_initializer(freqs, signal)\n   # Edit out the ones we want in the order we want them: \n   initial = (initial[0], initial[1],\n              initial[6], initial[7],\n              initial[2], initial[3],\n              initial[10], initial[11])\n\n   # We want to preferntially weight the error on estimating the height of the\n   # individual peaks, so we formulate an error-weighting function based on\n   # these peaks, which is simply a two-gaussian bumpety-bump:\n   w = (ut.gaussian(freqs, initial[0], 0.075, 1, 0, 0) +\n        ut.gaussian(freqs, initial[1], 0.075, 1, 0, 0))\n\n   # Further, we want to also optimize on the individual gaussians error, to\n   # restrict the fit space a bit more. For this purpose, we will pass a list\n   # of gaussians with indices into the parameter list, so that we can do\n   # that (see mopt.err_func for the mechanics).\n   func_list = [[ut.gaussian, [0,2,4,6,7],\n                 ut.gaussian(freqs, initial[0], 0.075, 1, 0, 0)],\n                [ut.gaussian, [1,3,5,6,7],\n                 ut.gaussian(freqs, initial[1], 0.075, 1, 0, 0)]]\n\n   params, _ = lsq.leastsqbound(mopt.err_func, initial,\n                                args=(freqs, np.real(signal),\n                                ut.two_gaussian, w, func_list),\n                                bounds=bounds)\n\n   return params", "response": "This function is the main function for the two - gaussian fit. It is used to fit the two - gaussian peaks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fit_two_lorentzian(spectra, f_ppm, lb=2.6, ub=3.6):\n   # We are only going to look at the interval between lb and ub\n   idx = ut.make_idx(f_ppm, lb, ub)\n   n_points = np.abs(idx.stop - idx.start) \n   n_params = 10 # Lotsa params!\n   # Set the bounds for the optimization\n   bounds = [(lb,ub), #peak1 \n             (lb,ub), #peak2 \n             (0,None), #area1 \n             (0,None), #area2 \n             (0,ub-lb), #hwhm1 \n             (0,ub-lb), #hwhm2\n             (-np.pi/2, np.pi/2), #phase\n             (-np.pi/2, np.pi/2), #phase\n             (None,None), #offset\n             (None, None)] #drift \n\n   model = np.empty((spectra.shape[0], n_points))\n   signal = np.empty((spectra.shape[0], n_points))\n   params = np.empty((spectra.shape[0], n_params))\n   for ii, xx in enumerate(spectra):\n      # We fit to the real spectrum:\n      signal[ii] = np.real(xx[idx])\n      params[ii] = _do_two_lorentzian_fit(f_ppm[idx], np.real(signal[ii]),\n                                      bounds=bounds)\n      \n      model[ii] = ut.two_lorentzian(f_ppm[idx], *params[ii])\n   \n   return model, signal, params", "response": "Fit a lorentzian function to the sum of the spectra."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfitting a gaussian function to the difference spectra.", "response": "def fit_two_gaussian(spectra, f_ppm, lb=3.6, ub=3.9):\n   \"\"\"\n   Fit a gaussian function to the difference spectra\n\n   This is useful for estimation of the Glx peak, which tends to have two\n   peaks.\n\n\n   Parameters\n   ----------\n   spectra : array of shape (n_transients, n_points)\n      Typically the difference of the on/off spectra in each transient.\n\n   f_ppm : array\n\n   lb, ub : floats\n      In ppm, the range over which optimization is bounded\n\n   \"\"\"\n   idx = ut.make_idx(f_ppm, lb, ub)\n   # We are only going to look at the interval between lb and ub\n   n_points = idx.stop - idx.start\n   n_params = 8\n   fit_func = ut.two_gaussian\n   # Set the bounds for the optimization\n   bounds = [(lb,ub), # peak 1 location\n             (lb,ub), # peak 2 location\n             (0,None), # sigma 1\n             (0,None), # sigma 2\n             (0,None), # amp 1\n             (0,None), # amp 2\n             (None, None), # offset\n             (None, None),  # drift\n             ]\n\n   model = np.empty((spectra.shape[0], n_points))\n   signal = np.empty((spectra.shape[0], n_points))\n   params = np.empty((spectra.shape[0], n_params))\n   for ii, xx in enumerate(spectra):\n      # We fit to the real spectrum:\n      signal[ii] = np.real(xx[idx])\n      params[ii] = _do_two_gaussian_fit(f_ppm[idx], np.real(signal[ii]),\n                                      bounds=bounds)\n\n      model[ii] = fit_func(f_ppm[idx], *params[ii])\n\n   return model, signal, params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _do_scale_fit(freqs, signal, model, w=None):\n   scalefac = np.empty(model.shape[0])\n   scalemodel = np.empty((model.shape[0], np.real(model).shape[1]))\n   scalesignal = np.empty((signal.shape[0], np.real(signal).shape[1]))\n   for ii, xx in enumerate(signal): # per transient\n      scalesignal[ii] = np.real(xx)\n#      ratio = np.empty(scalesignal[ii].shape[0])\n#      for ppm, trans in enumerate(scalesignal[ii]):\n#          ratio[ppm] = trans/model[ii][ppm]\n#      scalefac[ii] = np.mean(ratio,0)\n      scalefac[ii] = np.nanmean(scalesignal[ii],0)/np.nanmean(model[ii],0)\n      scalemodel[ii] = scalefac[ii] * model[ii]\n   return scalefac, scalemodel", "response": "This function scales the signal and model on y - axis and returns the scaling factor and the model that is scaled."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmultiplying a model by a scale factor", "response": "def scalemodel(model, scalefac):\n   \"\"\"\n   Given a scale factor, multiply by model to get scaled model\n\n   Parameters\n   ----------\n   model : array\n      original model\n   scalefac : array of model.shape[0]\n      array of scalefactors\n\n   Returns\n   -------\n   scaledmodel : array\n      model scaled by scale factor\n   \"\"\"\n   for ii, mm in enumerate(model):\n      scaledmodel[ii] = mm * scalefac[ii]\n   return scaledmodel"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit_gaussian(spectra, f_ppm, lb=2.6, ub=3.6):\n   idx = ut.make_idx(f_ppm, lb, ub)\n   # We are only going to look at the interval between lb and ub\n   n_points = idx.stop - idx.start\n   n_params = 5\n   fit_func = ut.gaussian\n   # Set the bounds for the optimization\n   bounds = [(lb,ub), # peak location\n             (0,None), # sigma\n             (0,None), # amp\n             (None, None), # offset\n             (None, None)  # drift\n             ]\n\n   model = np.empty((spectra.shape[0], n_points))\n   signal = np.empty((spectra.shape[0], n_points))\n   params = np.empty((spectra.shape[0], n_params))\n   for ii, xx in enumerate(spectra):\n      # We fit to the real spectrum:\n      signal[ii] = np.real(xx[idx])\n      # Use the signal for a rough estimate of the parameters for\n      # initialization :\n      max_idx = np.argmax(signal[ii])\n      max_sig = np.max(signal[ii])\n      initial_f0 = f_ppm[idx][max_idx]\n      half_max_idx = np.argmin(np.abs(signal[ii] - max_sig/2))\n      # We estimate sigma as the hwhm:\n      initial_sigma = np.abs(initial_f0 - f_ppm[idx][half_max_idx])\n      initial_off = np.min(signal[ii])\n      initial_drift = 0\n      initial_amp = max_sig\n      \n      initial = (initial_f0,\n                 initial_sigma,\n                 initial_amp,\n                 initial_off,\n                 initial_drift)\n      \n      params[ii], _ = lsq.leastsqbound(mopt.err_func,\n                                       initial,\n                                       args=(f_ppm[idx],\n                                             np.real(signal[ii]),\n                                             fit_func), bounds=bounds)\n\n      model[ii] = fit_func(f_ppm[idx], *params[ii])\n   \n   return model, signal, params", "response": "Fit a gaussian function to the difference spectra to be used for estimation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nintegrates a function over the domain x with the given arguments.", "response": "def integrate(func, x, args=(), offset=0, drift=0):\n   \"\"\"\n   Integrate a function over the domain x\n\n   Parameters\n   ----------\n   func : callable\n       A function from the domain x to floats. The first input to this function\n       has to be x, an array with values to evaluate for, running in monotonic\n       order  \n\n   x : float array\n      The domain over which to integrate, as sampled. This can be monotonically\n      decreasing or monotonically increasing.\n      \n   args : tuple\n       The parameters of func after x.\n\n   offset : \n\n   Notes\n   -----\n   We apply the trapezoid rule for integration here, using\n   scipy.integrate.trapz.\n\n   See: http://en.wikipedia.org/wiki/Trapezoidal_rule\n   \n   \"\"\"\n   # If it's monotonically decreasing (as is often the case here), we invert\n   # it, so that our results are strictly positive\n   if x[1]<x[0]:\n      x = x[::-1]\n   y = func(x, *args)\n   # Correct for offset and drift, if those are present and specified\n   # (otherwise default to 0 on both):\n   y = y - offset\n   y = y - drift * (x-x[0])\n   # Use trapezoidal integration on the corrected function: \n   return spi.trapz(y, x)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the area under the curve", "response": "def simple_auc(spectrum, f_ppm, center=3.00, bandwidth=0.30):\n   \"\"\"\n   Calculates area under the curve (no fitting)\n\n   Parameters\n   ----------\n   spectrum : array of shape (n_transients, n_points)\n      Typically the difference of the on/off spectra in each transient.\n\n   center, bandwidth : float\n      Determine the limits for the part of the spectrum for which we want\n      to calculate the AUC.\n      e.g. if center = 3.0, bandwidth = 0.3, lower and upper bounds will be\n      2.85 and 3.15 respectively (center +/- bandwidth/2).\n\n   Notes\n   -----\n   Default center and bandwidth are 3.0 and 0.3ppm respectively\n    because of Sanacora 1999 pg 1045:\n   \"The GABA signal was integrated over a 0.30-ppm bandwidth at 3.00ppm\"\n\n   Ref: Sanacora, G., Mason, G. F., Rothman, D. L., Behar, K. L., Hyder, F.,\n   Petroff, O. A., ... & Krystal, J. H. (1999). Reduced cortical\n   {gamma}-aminobutyric acid levels in depressed patients determined by proton\n   magnetic resonance spectroscopy. Archives of general psychiatry, 56(11),\n   1043.\n\n   \"\"\"\n   range = np.max(f_ppm)-np.min(f_ppm)\n   dx=float(range)/float(len(f_ppm))\n   \n   lb = np.floor((np.max(f_ppm)-float(center)+float(bandwidth)/2)/dx)\n   ub = np.ceil((np.max(f_ppm)-float(center)-float(bandwidth)/2)/dx)\n\n   auc = trapz(spectrum[ub:lb].real, dx=dx)\n\n   return auc, ub, lb"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts a new startup dialog.", "response": "def startWizard(args, mainwin, modal=True):\n    \"\"\"\n    Parses list of directories ('args') and attaches to purrlogs appropriately.\n    'mainwin' is a Purr.MainWindow object.\n\n    Return value:\n      * if modal=True: True if arguments parse OK and Purr.MainWindow should be shown, False on error.\n      * if modal=False: True if attached to purrlog and Purr.MainWindow should be shown, False otherwise.\n\n    If modal=False, it will keep displaying the startup dialog as a modeless dialog, and attach the\n  mainwin to the specified purrlog when the dialog is closed.\n\n    Use cases:\n     $ purr <dirname> [<more dirs>]\n        1. If dirname does not exist:\n          * find other purrlogs in parent dir\n          * pop up wizard, with the name as the default \"create\" option, and create selected\n        2. If dirname exists:\n          2a. Not a directory: report error\n          2b. If dir is a purrlog, attach and add dirs\n          2c. If dir contains 1 valid purrlog, attach, and add more dirs.\n          2d. If dir contains 2+ purrlogs, offer choice (or create new), add more dirs\n          2e. If dir contains no purrlogs, offer to create one (or to attach to one), add \"more dirs\" to watchlist if creating new, ignore if attaching\n     $ purr\n         * same as \"purr .\"\n     $ from meqbrowser, when cd into a directory:\n         * if purr dialog is visible, do same as \"purr .\"\n     $ from meqbrowser, when purr button is pressed and purr is not yet visible\n         * do \"purr .\"\n     $ from Calico, when an MS is selected:\n         * do purr MS.purrlog .\n    \"\"\"\n\n    args = args or [os.getcwd()]\n    dirname = os.path.abspath(args[0])\n    moredirs = args[1:]\n\n    # case 1: dirname does not exist, or refers to a non-directory\n    if not os.path.exists(dirname) or not os.path.isdir(dirname):\n        message = \"\"\"To begin with, PURR must load an existing purrlog, or start a new purrlog. <tt>%s</tt> does not look to be an existing purrlog.\n            What would you like to do?\"\"\" % Kittens.utils.collapseuser(dirname)\n        create = dirname\n        dirname = os.getcwd()\n        parent = os.path.dirname(os.path.normpath(create)) or os.getcwd()\n        # if parent is valid dir, find purrlogs in parent (to offer as an option)\n        if os.path.isdir(parent):\n            purrlogs = list(filter(Purr.Purrer.is_purrlog, glob.glob(os.path.join(parent, \"*\"))))\n        # else use \".\" as dirname, and do not offer any purrlogs\n        else:\n            purrlogs = []\n    # case 2: dirname exists:\n    else:\n        create = None\n        # case 2b: is a valid purrlog\n        if Purr.Purrer.is_purrlog(dirname):\n            mainwin.attachPurrlog(dirname, moredirs)\n            mainwin.show()\n            return True\n        # case 2c-2e. Look for purrlogs in dirname\n        purrlogs = list(filter(Purr.Purrer.is_purrlog, glob.glob(os.path.join(dirname, \"*\"))))\n        # case 2c: exactly one purrlog. Attach without asking.\n        if len(purrlogs) == 1:\n            mainwin.show()\n            mainwin.attachPurrlog(purrlogs[0], moredirs)\n            return True\n        # else setup messages\n        if purrlogs:\n            message = \"\"\"To begin with, PURR must load an existing purrlog, or start a new purrlog. The directory <tt>%s</tt> contains\n          several purrlogs. What would you like to do?\"\"\" % Kittens.utils.collapseuser(dirname)\n        else:\n            message = \"\"\"To begin with, PURR must load an existing purrlog, or create a new purrlog. The directory <tt>%s</tt> contains\n          no purrlogs. What would you like to do?\"\"\" % Kittens.utils.collapseuser(dirname)\n\n    # case 1, 2d or 2e: make wizard dialog\n\n    # kill old wizard, if showing\n    global wizard_dialog\n    if wizard_dialog:\n        wizard_dialog.hide()\n        dum = QWidget()\n        wizard_dialog.setParent(dum)\n        dum = wizard_dialog = None\n\n    # create new wizard\n    wizard_dialog = PurrStartupWizard(mainwin, dirname, purrlogs, moredirs=moredirs, create=create, message=message)\n\n    if modal:\n        if wizard_dialog.exec_() == QDialog.Rejected:\n            return False\n        return True;\n    else:\n        wizard_dialog.setModal(False)\n        wizard_dialog.show()\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef day_postfix(day):\n\n    if day != 11 and day % 10 == 1:\n        postfix = \"st\"\n    elif day != 12 and day % 10 == 2:\n        postfix = \"nd\"\n    elif day != 13 and day % 10 == 3:\n        postfix = \"rd\"\n    else:\n        postfix = \"th\"\n\n    return postfix", "response": "Returns day s correct postfix."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a datetime object with optional params or today.", "response": "def _get_date(day=None, month=None, year=None):\n    \"\"\"Returns a datetime object with optional params or today.\"\"\"\n\n    now = datetime.date.today()\n    if day is None:\n        return now\n\n    try:\n        return datetime.date(\n            day=int(day),\n            month=int(month or now.month),\n            year=int(year or now.year),\n        )\n    except ValueError as error:\n        print(\"error: {0}\".format(error), file=sys.stderr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncommands line entry point.", "response": "def main():\n    \"\"\"Command line entry point.\"\"\"\n\n    def help_exit():\n        raise SystemExit(\"usage: ddate [day] [month] [year]\")\n\n    if \"--help\" in sys.argv or \"-h\" in sys.argv:\n        help_exit()\n\n    if len(sys.argv) == 2:  # allow for 23-2-2014 style, be lazy/sloppy with it\n        for split_char in \".-/`,:;\":  # who knows what the human will use...\n            if split_char in sys.argv[1]:\n                parts = sys.argv[1].split(split_char)\n                del sys.argv[1]\n                sys.argv.extend(parts)\n                break\n\n    date = _get_date(*sys.argv[1:])\n\n    if date:\n        print(DDate(date))\n    else:\n        help_exit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef doc_reader(infile):\n    if infile.endswith('.docx'):\n        docid = 'word/document.xml'\n    else:\n        docid = 'content.xml'\n    try:\n        zfile = zipfile.ZipFile(infile)\n    except:\n        print('Sorry, can\\'t open {}.'.format(infile))\n        return\n    body = ET.fromstring(zfile.read(docid))\n    text = '\\n'.join([et.text.strip() for et in body.iter() if et.text])\n    return text", "response": "Parse docx and odf files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncounting the expected number of bids for a list of recipients.", "response": "def _count_expected_bids(self, recipients):\n        '''\n        Count the expected number of bids (after receiving them we close the\n        contract. If the recipient type is broadcast return None which denotes\n        unknown number of bids (contract will be closed after timeout).\n        '''\n        count = 0\n        for recp in recipients:\n            if recp.type == RecipientType.broadcast:\n                return None\n            count += 1\n        return count"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _on_grant(self, grant):\n        '''\n        Called upon receiving the grant. Than calls granted and sets\n        up reporter if necessary.\n        '''\n        self.set_timeout(grant.expiration_time, ContractState.expired,\n                         self._run_and_terminate, self.contractor.cancelled,\n                         grant)\n\n        self.grant = grant\n        # this is necessary for nested contracts to work with handing\n        # the messages over\n        self.set_remote_id(grant.sender_id)\n        self.update_manager_address(grant.reply_to)\n\n        self.call_agent_side(self.contractor.granted, grant,\n                             ensure_state=ContractState.granted)", "response": "Called upon receiving a grant."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def component_coro_wrapper(coro_func: CoroutineFunction[T],\n                                 *args: Any, commands: PipeEnd, events: PipeEnd, **kwargs: Any) -> T:\n    \"\"\"\\\n    This function wraps a component workload to conform to the required lifecycle.\n    The following behavior is the passed coroutine function's responsibility:\n\n    - it must send `Component.EVENT_START` to its owner after the task is initialized;\n    - it must not send EOF on the event pipe;\n    - when `Component.COMMAND_STOP` is received, it should either stop eventually, or send an event to its owner;\n    - when it is cancelled, it should either stop eventually, or send an event to its owner.\n\n    Also, any `Component.LifecycleError` raised will be wrapped in `Component.Failure`.\n    \"\"\"\n    try:\n        return await coro_func(*args, commands=commands, events=events, **kwargs)\n    except Exception as err:\n        raise Component.Failure(err) from None\n    finally:\n        try:\n            await events.send(eof=True)\n        except EOFError as err:\n            raise Component.LifecycleError(\"component closed events pipe manually\") from err", "response": "A wrapper function for the coroutine function that wraps a component workload."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef component_workload(coro_func: CoroutineFunction[T]) -> CoroutineFunction[T]:\n    return functools.partial(component_coro_wrapper, coro_func)", "response": "A decorator that wraps a function to be used as a workload for a single component."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart a new component in the passed workload.", "response": "async def start_component(workload: CoroutineFunction[T], *args: Any, **kwargs: Any) -> Component[T]:\n    \"\"\"\\\n    Starts the passed `workload` with additional `commands` and `events` pipes.\n    The workload will be executed as a task.\n\n    A simple example. Note that here, the component is exclusively reacting to commands,\n    and the owner waits for acknowledgements to its commands, making the order of outputs predictable.\n\n    >>> @component_workload\n    ... async def component(msg, *, commands, events):\n    ...     # do any startup tasks here\n    ...     print(\"> component starting up...\")\n    ...     await events.send(Component.EVENT_START)\n    ...\n    ...     count = 0\n    ...     while True:\n    ...         command = await commands.recv()\n    ...         if command == Component.COMMAND_STOP:\n    ...             # honor stop commands\n    ...             break\n    ...         elif command == 'ECHO':\n    ...             print(f\"> {msg}\")\n    ...             count += 1\n    ...             # acknowledge the command was serviced completely\n    ...             await commands.send(None)\n    ...         else:\n    ...             # unknown command; terminate\n    ...             # by closing the commands pipe,\n    ...             # the caller (if waiting for a reply) will receive an EOFError\n    ...             await commands.send(eof=True)\n    ...             raise ValueError\n    ...\n    ...     # do any cleanup tasks here, probably in a finally block\n    ...     print(\"> component cleaning up...\")\n    ...     return count\n    ...\n    >>> async def example():\n    ...     print(\"call start\")\n    ...     comp = await start_component(component, \"Hello World\")\n    ...     print(\"done\")\n    ...\n    ...     print(\"send command\")\n    ...     await comp.request('ECHO')\n    ...     print(\"done\")\n    ...\n    ...     print(\"call stop\")\n    ...     count = await comp.stop()\n    ...     print(\"done\")\n    ...\n    ...     print(count)\n    ...\n    >>> asyncio.run(example())\n    call start\n    > component starting up...\n    done\n    send command\n    > Hello World\n    done\n    call stop\n    > component cleaning up...\n    done\n    1\n    \"\"\"\n\n    commands_a, commands_b = pipe()\n    events_a, events_b = pipe()\n\n    task = asyncio.create_task(workload(*args, commands=commands_b, events=events_b, **kwargs))\n\n    component = Component[T](commands_a, events_a, task)\n    await component.wait_for_start()\n    return component"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart a new component in a thread.", "response": "async def start_component_in_thread(executor, workload: CoroutineFunction[T], *args: Any, loop=None, **kwargs: Any) -> Component[T]:\n    \"\"\"\\\n    Starts the passed `workload` with additional `commands` and `events` pipes.\n    The workload will be executed on an event loop in a new thread; the thread is provided by `executor`.\n\n    This function is not compatible with `ProcessPoolExecutor`,\n    as references between the workload and component are necessary.\n\n    Be careful when using an executor with a maximum number of threads,\n    as long running workloads may starve other tasks.\n    Consider using a dedicated executor that can spawn at least as many threads\n    as concurrent long-running tasks are expected.\n    \"\"\"\n\n    loop = loop or asyncio.get_event_loop()\n\n    commands_a, commands_b = pipe(loop=loop)\n    events_a, events_b = pipe(loop=loop)\n\n    commands_b = ConcurrentPipeEnd(commands_b, loop=loop)\n    events_b = ConcurrentPipeEnd(events_b, loop=loop)\n\n    _workload = workload(*args, commands=commands_b, events=events_b, **kwargs)\n    future = cast(_Future[T], loop.run_in_executor(executor, asyncio.run, _workload))\n\n    component = Component[T](commands_a, events_a, future)\n    await component.wait_for_start()\n    return component"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting for the task to terminate and return the result.", "response": "async def result(self) -> T:\n        \"\"\"\\\n        Wait for the task's termination; either the result is returned or a raised exception is reraised.\n        If an event is sent before the task terminates, an `EventException` is raised with the event as argument.\n        \"\"\"\n        try:\n            event = await self.recv_event()\n        except Component.Success as succ:\n            # success was thrown; return the result\n            result, = succ.args\n            return cast(T, result)\n        except Component.Failure as fail:\n            # here we don't expect a wrapped result, so we unwrap the failure\n            cause, = fail.args\n            raise cause\n        else:\n            # there was a regular event; shouldn't happen/is exceptional\n            raise Component.EventException(event)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def request(self, value: Any) -> Any:\n        await self.send(value)\n        return await self.recv()", "response": "\\ Sends a command to and receives the reply from the task."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreceive an event from the task.", "response": "async def recv_event(self) -> Any:\n        \"\"\"\\\n        Receives an event from the task.\n        If the task terminates before another event, an exception is raised.\n        A normal return is wrapped in a `Success` exception,\n        other exceptions result in a `Failure` with the original exception as the cause.\n        \"\"\"\n        try:\n            return await self._events.recv()\n        except EOFError:\n            # component has terminated, raise the cause (either Failure, or LifecycleError) or Success\n            raise Component.Success(await self._future)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommands line interface for testing and submitting calculations. Usage: ./cli.py CODENAME COMPUTER_NAME CODENAME from \"verdi code setup\" COMPUTER_NAME from \"verdi computer setup\" This script extends submit.py, adding flexibility in the selected code/computer.", "response": "def main(codelabel, submit):\n    \"\"\"Command line interface for testing and submitting calculations.\n\n    Usage: ./cli.py CODENAME COMPUTER_NAME\n    \n    CODENAME       from \"verdi code setup\"\n\n    COMPUTER_NAME  from \"verdi computer setup\"\n\n    This script extends submit.py, adding flexibility in the selected code/computer.\n    \"\"\"\n    code = Code.get_from_string(codelabel)\n\n    # set up calculation\n    calc = code.new_calc()\n    calc.label = \"aiida_phtools example calculation\"\n    calc.description = \"Computes proper pore surface as needed for persistence homology calculation\"\n    calc.set_max_wallclock_seconds(1 * 60)\n    calc.set_withmpi(False)\n    calc.set_resources({\"num_machines\": 1})\n\n    # Prepare input parameters\n    PoreSurfaceParameters = DataFactory('phtools.surface')\n    d = {\n        'accessible_surface_area': 300.0,\n        'target_volume': 40e3,\n        'sampling_method': 'random',\n    }\n    parameters = PoreSurfaceParameters(dict=d)\n    calc.use_parameters(parameters)\n\n    SinglefileData = DataFactory('singlefile')\n    this_dir = os.path.dirname(os.path.realpath(__file__))\n    structure = SinglefileData(file=os.path.join(this_dir, 'HKUST-1.cssr'))\n    calc.use_structure(structure)\n\n    surface_sample = SinglefileData(file=os.path.join(this_dir, 'HKUST-1.vsa'))\n    calc.use_surface_sample(surface_sample)\n\n    if submit:\n        calc.store_all()\n        calc.submit()\n        print(\"submitted calculation; calc=Calculation(uuid='{}') # ID={}\"\\\n                .format(calc.uuid,calc.dbnode.pk))\n    else:\n        subfolder, script_filename = calc.submit_test()\n        path = os.path.relpath(subfolder.abspath)\n        print(\"submission test successful\")\n        print(\"Find remote folder in {}\".format(path))\n        print(\"In order to actually submit, add '--submit'\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a formset for the staff member object.", "response": "def get_formset(self, request, obj=None, **kwargs):\n        \"\"\"\n        Return a form, if the obj has a staffmember object, otherwise\n        return an empty form\n        \"\"\"\n        if obj is not None and self.model.objects.filter(user=obj).count():\n            return super(StaffMemberAdmin, self).get_formset(\n                request,\n                obj,\n                **kwargs\n            )\n\n        defaults = {\n            \"exclude\": None,\n            \"extra\": 0,\n            \"max_num\": 0,\n        }\n        return inlineformset_factory(self.parent_model, self.model, **defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef eval(w,t,x,msk,s):\n    # Verify types\n    assertType(w, (str, int, long))\n    assertType(t, (str, int, long))\n    assertType(x, (str, int, long))\n\n    # Construct the key\n    kw = genKw(w,msk,s)\n\n    # Compute y\n    beta = hashG1(t, x)\n    y = beta*kw\n    return y,kw,beta", "response": "Pythia server - side computation of intermediate PRF output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prove(x,beta,kw,y):\n    # Verify types\n    assertScalarType(kw)\n    assertType(beta, G1Element)\n    assertType(y, G1Element)\n\n    # Compute the proof.\n    Q = generatorG1()\n    p = Q*kw\n    v = randomZ(orderG1())\n    t1 = Q*v\n    t2 = beta*v\n\n    t1.normalize()\n    t2.normalize()\n\n    c = hashZ(Q,p,beta,y,t1,t2)\n    u = (v-(c*kw)) % orderG1()\n    return (p,c,u)", "response": "Generate a zero - knowledge proof that DL ( Q * kw ) = DL ( beta * kw ) where DL ( Q * kw ) = DL ( beta * kw ) where DL ( Q * kw ) = DL ( beta * kw ) where DL ( Q * kw ) = DL ( beta * kw ) where DL ( Q * kw ) = DL ( beta * kw ) where DL ( Q * kw ) = DL ( x"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef arg_bool(name, default=False):\n    v = request.args.get(name, '')\n    if not len(v):\n        return default\n    return v in BOOL_TRUISH", "response": "Fetch a query argument as a boolean."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef arg_int(name, default=None):\n    try:\n        v = request.args.get(name)\n        return int(v)\n    except (ValueError, TypeError):\n        return default", "response": "Fetch a query argument as an integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tick(self):\n        now = datetime.datetime.now()\n        self.add(now)\n\n        # Create a list of timestamps, one for each period and\n        # representing the beginning of that period (i.e. since now.)\n        tstamps = [now - datetime.timedelta(seconds=xx)\n                   for xx in self._periods]\n\n        # Trim off any tick values older than the earliest timestamp.\n        self.removeLT(min(tstamps))\n\n        # Create a list of counts, one for each period and\n        # representing the number of ticks in that period.\n        counts = [self.getCountGT(xx) for xx in tstamps]\n\n        # Compute a list of rates for the periods.\n        rates = [float(xx)/yy for xx, yy in zip(counts, self._periods)]\n\n        # Return the rates as a tuple.\n        return tuple(rates)", "response": "Tick the ticker.\n        Return a tuple of values corresponding to periods given in initializer and\n        each value representing the rate of ticks per second during that period."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints a message to the console.", "response": "def _puts(message, level, **kwargs):\n    \"\"\"\n    Generate fabric-style output if and only if status output\n    has been selected.\n    \"\"\"\n    if not output.get(level):\n        return\n    print \"[{hostname}] {message}\".format(hostname=env.host_string,\n                                          message=message.format(**kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfigures the output of a single node.", "response": "def configure_output(verbosity=0, output_levels=None, quiet=False):\n    \"\"\"\n    Configure verbosity level through Fabric's output managers.\n\n    Provides a default mapping from verbosity levels to output types.\n\n    :param verbosity: an integral verbosity level\n    :param output_levels: an optional mapping from Fabric output types to verbosity\n    :param quiet: specifies that all output should be suppressed\n\n    This function is designed to work with command line argument parsing.\n    For example:\n\n        # configure argparse\n        parser.add_option(\"-q\", dest=\"quiet\", action=\"store_true\", default=False)\n        parser.add_option(\"-v\", dest=\"verbosity\", action=\"count\", default=0)\n\n        # configure output\n        configure_output(options.verbosity, options.quiet)\n    \"\"\"\n    verbosity = verbosity if not quiet else -1\n\n    output_levels = output_levels or {\n        \"status\": 0,\n        \"aborts\": 0,\n        \"user\": 1,\n        \"warnings\": 1,\n        \"running\": 1,\n        \"stdout\": 2,\n        \"stderr\": 2,\n        \"debug\": 2\n    }\n\n    # configure output manager levels via verbosity\n    for manager, level in output_levels.iteritems():\n        output[manager] = level <= verbosity\n\n    # Hook up Python warnings to warning output manager\n    warnings.showwarning = warn_via_fabric\n    warnings.simplefilter(\"always\", UserWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new instance of the Route substituting the requested parameters.", "response": "def copy(self, **params):\n        '''Creates the new instance of the Route substituting the requested\n        parameters.'''\n        new_params = dict()\n        for name in ['owner', 'priority', 'key', 'final']:\n            new_params[name] = params.get(name, getattr(self, name))\n        return Route(**new_params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef objwalk(obj, path=(), memo=None):\n    if len( path ) > MAX_DEPTH + 1:\n        yield path, obj # Truncate it!\n    if memo is None:\n        memo = set()\n    iterator = None\n    if isinstance(obj, Mapping):\n        iterator = iteritems\n    elif isinstance(obj, (Sequence, Set)) and not isinstance(obj, string_types):\n        iterator = enumerate\n    elif hasattr( obj, '__class__' ) and hasattr( obj, '__dict__' ) and type(obj) not in primitives: # If type(obj) == <instance>\n        iterator = class_iterator\n    elif hasattr(obj, '__iter__') or isinstance(obj, types.GeneratorType):\n        obj = [o for o in obj]\n    else:\n        pass\n    if iterator:\n        if id(obj) not in memo:\n            memo.add(id(obj))\n            for path_component, value in iterator(obj):\n                for result in objwalk(value, path + (path_component,), memo):\n                    yield result\n            memo.remove(id(obj))\n    else:\n        yield path, obj", "response": "Walk an arbitrary python object and yield a set of attributes that are traversed thus far."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setattr_at_path( obj, path, val ):\n    target = obj\n    last_attr = path[-1]\n    for attr in path[0:-1]:\n        try:\n            if type(attr) in ( str, unicode ) and target and hasattr( target, attr ):\n                target = getattr( target, attr )\n            else:\n                target = target[attr]\n        except:\n            pass\n    # Ensures we set by reference\n    try:\n        setattr( target, last_attr, val )\n    except:\n        target[last_attr] = val", "response": "Sets the value of the attribute at the specified path on an object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef truncate_attr_at_path( obj, path ):\n    target = obj\n    last_attr = path[-1]\n    message = []\n\n    if type(last_attr) == tuple:\n        last_attr = last_attr[-1]\n    for attr in path[0:-1]:\n        try:\n            if type(attr) in ( str, unicode ) and target and hasattr( target, attr ) and hasattr( target, '__getitem__' ):\n                target = getattr( target, attr )\n            elif target:\n                try: target = target[attr]\n                except: target = eval( \"target.\" + str( attr ) )\n        except:\n            pass\n        try:\n            if not target: return\n        except: return\n        if isinstance( target, ( tuple, list ) ): target = list(target) # Tuples are immutable. Need to be able to manipulate.\n\n    try:\n        del_statement = \"del target.\" + str( last_attr )\n        eval( del_statement )\n        return\n    except: pass\n\n    if type( last_attr ) in ( str, unicode ) and target and hasattr( target, last_attr ):\n        try: delattr( target, last_attr )\n        except: message.append(\"Failed to delete attribute\" + str(last_attr) + \"on target\" + str(target) )\n    elif type(target) == list:\n        try: target.pop(last_attr)\n        except: message.append( \"Failed to delete value on list\" + str(target) + \"at index\" + str(last_attr) )\n    else:\n        try: del target[str(last_attr)]\n        except: message.append( \"failed to delete attribute on subscriptable object\" )", "response": "This function will traverse a set of nested attributes and truncates the value on the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pickle_with_weak_refs( o ):\n    if isinstance(o, types.GeneratorType):\n        o = [i for i in o]\n    walk = dict([ (path,val) for path, val in objwalk(o)])\n    for path, val in walk.items():\n        if len(path) > MAX_DEPTH or is_lambda(val):\n            truncate_attr_at_path(o, path)\n        if isinstance(val, weakref.ref):\n            setattr_at_path( o, path, val() ) # Resolve weak references\n    return pickle.dumps(o)", "response": "Pickles an object containing weak references."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprompts user for input until a value is retrieved or default is accepted. Return the input.", "response": "def user_input(\n        field, default='', choices=None, password=False,\n        empty_ok=False, accept=False):\n    \"\"\"Prompt user for input until a value is retrieved or default\n    is accepted. Return the input.\n\n    Arguments:\n\n    *field* - Description of the input being prompted for.\n\n    *default* - Default value for the input accepted with a Return-key.\n\n    *password* - Whether the user input should not be echoed to screen.\n\n    *empty_ok* - Whether it's okay to accept an empty input.\n\n    *accept* - Whether to skip getting actual user input and just accept\n    the default value, unless prevented by the combination of\n    arguments *empty_ok* and *default*. That is, unless *default*\n    is an empty string and *empty_ok* is False.\n    \"\"\"\n    result = ''\n    while not result:\n        prompt = field\n        if default:\n            prompt += ' [{0}]'.format(default)\n        prompt += ': '\n        if accept and not (not default and not empty_ok):\n            print(prompt)\n            result = '{0}'.format(default)\n        else:\n            if password:\n                result = getpass.getpass(prompt)\n            else:\n                result = input(prompt)\n        result = result.strip()\n        if not result:\n            result = default\n        if choices and result not in choices:\n            print('Must be one of {0}'.format(choices))\n            result = ''\n        if empty_ok:\n            break\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef value(value_info, label=None, desc=None):\n    _annotate(\"value\", value_info, label=label, desc=desc)", "response": "Annotate the value information of the action being defined."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef param(name, value_info, is_required=True, label=None, desc=None):\n    _annotate(\"param\", name, value_info, is_required=is_required,\n              label=label, desc=desc)", "response": "Annotate a parameter of the action being defined."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the keys of the dictionary prepending them with name.", "response": "def _prepend_name(self, prefix, dict_):\n        '''changes the keys of the dictionary prepending them with \"name.\"'''\n        return dict(['.'.join([prefix, name]), msg]\n                    for name, msg in dict_.iteritems())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(addr, args={},  headers={}, version='HTTP/1.1', auth=()):\n\n    \"\"\"\n    It does an http/https request.\n    \"\"\"\n\n    addr    = addr.strip().rstrip()\n    url     = urlparse(addr)\n    default = {\n    'user-agent':'Websnake/1.0.0', \n    'accept-charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n    'connection':'close',\n    'host': url.hostname}\n\n    default.update(headers)\n    args = '?%s' % urlencode(args) if args else ''\n\n    if auth: default['authorization'] = build_auth(*auth)\n\n    data = 'GET %s%s %s\\r\\n' % (url.path + ('?' + url.query if \\\n    url.query else ''), args, version)\n    data = data + build_headers(default)\n    port = url.port if url.port else getservbyname(url.scheme)\n    data = data.encode('utf8')\n\n    return create_con_ssl(url.hostname, port, data) \\\n    if url.scheme == 'https' else create_con(url.hostname, port, data)", "response": "This function does an http or https request. It does an http request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a human readable string to indicate the time duration for the given seconds.", "response": "def duration(cls, seconds, first=True):\n        \"\"\"\n        Constructs a human readable string to indicate the time duration for the given seconds\n\n        :param int seconds:\n        :param bool first: Just return the first unit instead of all\n        :rtype: str\n        \"\"\"\n        num_units = []\n\n        for unit in reversed(TimeUnit):\n            if seconds >= unit.seconds:\n                name = unit.name.lower()\n                count = int(seconds / unit.seconds)\n                num_units.append(f'{count} {plural(name, count=count)}')\n                seconds -= count * unit.seconds\n\n                if first or not seconds:\n                    break\n\n        return ' '.join(num_units)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall ``function`` asynchronously by creating a pickling it and calling it in a task.", "response": "def celery(function, *args, **kwargs):\n    '''\n    Calls ``function`` asynchronously by creating a pickling it and\n    calling it in a task.\n    '''\n    from .tasks import dill_callable\n\n    dilled_function = dill.dumps(function)\n    dill_callable.delay(dilled_function, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the file size of the database as a pretty string.", "response": "def getDatabaseFileSize(self):\n    \"\"\" Return the file size of the database as a pretty string. \"\"\"\n    if DISABLE_PERSISTENT_CACHING:\n      return \"?\"\n    size = os.path.getsize(self.__db_filepath)\n    if size > 1000000000:\n      size = \"%0.3fGB\" % (size / 1000000000)\n    elif size > 1000000:\n      size = \"%0.2fMB\" % (size / 1000000)\n    elif size > 1000:\n      size = \"%uKB\" % (size // 1000)\n    else:\n      size = \"%uB\" % (size)\n    return size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npurge obsolete items from the cache.", "response": "def purge(self):\n    \"\"\" Purge cache by removing obsolete items. \"\"\"\n    purged_count = 0\n    if self.__expiration is not None:\n      with self.__connection:\n        if self.__caching_strategy is CachingStrategy.FIFO:\n          # dump least recently added rows\n          for post in (False, True):\n            purged_count += self.__connection.execute(\"DELETE FROM \" +\n                                                      self.getDbTableName(post=post) + \" \"\n                                                      \"WHERE (strftime('%s', 'now') - added_timestamp) > ?;\",\n                                                      (self.__expiration,)).rowcount\n        elif self.__caching_strategy is CachingStrategy.LRU:\n          # dump least recently accessed rows\n          for post in (False, True):\n            purged_count += self.__connection.execute(\"DELETE FROM \" +\n                                                      self.getDbTableName(post=post) + \" \"\n                                                      \"WHERE (strftime('%s', 'now') - last_accessed_timestamp) > ?;\",\n                                                      (self.__expiration,)).rowcount\n    return purged_count"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting for the execution of the last enqueued job to be done and return the result or raise an exception.", "response": "def waitResult(self):\n    \"\"\" Wait for the execution of the last enqueued job to be done, and return the result or raise an exception. \"\"\"\n    self.thread.execute_queue.join()\n    try:\n      e = self.thread.exception_queue[threading.get_ident()].get_nowait()\n    except queue.Empty:\n      return self.thread.result_queue[threading.get_ident()].get_nowait()\n    else:\n      raise e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef callToThread(method):\n    def func_wrapped(self, *args, **kwargs):\n      self.thread.execute_queue.put_nowait((threading.get_ident(), method, args, kwargs))\n      return self.waitResult()\n    return func_wrapped", "response": "Wrap call to method to send it to WebCacheThread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing public key P where P = G1. x t and y are ignored.", "response": "def prove(x,t,kw,y):\n    \"\"\"\n    Computes public key P*kw where <P> = G1. \n    x, t, and y are ignored. They are included only for API compatibility with \n    other Pythia PRF implementations.\n    \"\"\"\n    # Verify the key type and compute the pubkey\n    assertScalarType(kw)\n    p = generatorG2() * kw\n    return (p,None,None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(x, t, y, pi, errorOnFail=True):\n    # Unpack the proof\n    p,_,_ = pi\n\n    # Verify types\n    assertType(x, str)\n    assertType(t, str)\n    assertType(y, G1Element)\n    assertType(p, G2Element)\n\n    # TODO: beta can be pre-computed while waiting for a server response.\n    beta = hashG1(t, x)\n\n    # Compute q = e( H(t,m), P)**kw two ways\n    q1 = pair(beta, p)\n    q2 = pair(y, generatorG2())\n\n    # The BLS signature is valid when q1 == q2\n    if q1 == q2:\n        return True\n\n    if errorOnFail:\n        raise Exception(\"BLS signature failed verification\")\n    else:\n        return False", "response": "Verify a zero - knowledge proof."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setNamingConvention(self, namingConvention):\n        # Remove getters and setters with old naming convention.\n        self._removeSyntheticMembers()\n        \n        # Set new naming convention.\n        self._syntheticMetaData().setNamingConvention(namingConvention)\n\n        # Update constructor and recreate accessors.\n        self._updateConstructorAndMembers()", "response": "Sets the naming convention for this object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef which(component, path_str):\n    '''helper method having same behaviour as \"which\" os command.'''\n\n    def is_exe(fpath):\n        return os.path.exists(fpath) and os.access(fpath, os.X_OK)\n\n    fpath, fname = os.path.split(component)\n    if fpath:\n        if is_exe(component):\n            return component\n    else:\n        for path in path_str.split(os.pathsep):\n            exe_file = os.path.join(path, component)\n            if is_exe(exe_file):\n                return exe_file", "response": "helper method having same behaviour as \"which os command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _wrap(func, msg):\n\n    @functools.wraps(func)\n    def new_func(*args, **kwargs):\n        warnings.simplefilter('always', DeprecationWarning)     # turn off filter\n        warnings.warn(msg, category=DeprecationWarning, stacklevel=2)\n        warnings.simplefilter('default', DeprecationWarning)    # reset filter\n        return func(*args, **kwargs)\n    return new_func", "response": "A decorator which can be used to mark functions\n    as deprecated. It will be used to mark functions\n    as deprecated. It will result in a warning being emitted\n        when the function is used."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a. md file and sanitize it for PyPI.", "response": "def md2pypi(filename):\n    '''\n    Load .md (markdown) file and sanitize it for PyPI.\n    Remove unsupported github tags:\n     - code-block directive\n     - travis ci build badges\n    '''\n    content = io.open(filename).read()\n\n    for match in RE_MD_CODE_BLOCK.finditer(content):\n        rst_block = '\\n'.join(\n            ['.. code-block:: {language}'.format(**match.groupdict()).replace('markdown', ''), ''] +\n            ['    {0}'.format(l) for l in match.group('lines').split('\\n')] +\n            ['']\n        )\n        content = content.replace(match.group(0), rst_block)\n\n    refs = dict(RE_LINK_REF.findall(content))\n    content = RE_LINK_REF.sub('.. _\\g<key>: \\g<url>', content)\n    content = RE_SELF_LINK.sub('`\\g<1>`_', content)\n    content = RE_LINK_TO_URL.sub('`\\g<text> <\\g<url>>`_', content)\n\n    for match in RE_BADGE.finditer(content):\n        params = match.groupdict()\n        params['badge'] = refs[match.group('badge')]\n        params['target'] = refs[match.group('target')]\n        content = content.replace(match.group(0), RST_BADGE.format(**params))\n\n    for match in RE_IMAGE.finditer(content):\n        url = match.group('url')\n        if not url.startswith('http'):\n            url = '/'.join((GITHUB_REPOSITORY, 'raw/master', url))\n\n        rst_block = '\\n'.join([\n            '.. image:: {0}'.format(url),\n            '  :alt: {0}'.format(match.group('text'))\n        ])\n        content = content.replace(match.group(0), rst_block)\n\n    # Must occur after badges\n    for match in RE_LINK_TO_REF.finditer(content):\n        content = content.replace(match.group(0), '`{text} <{url}>`_'.format(\n            text=match.group('text'),\n            url=refs[match.group('ref')]\n        ))\n\n    for match in RE_TITLE.finditer(content):\n        underchar = RST_TITLE_LEVELS[len(match.group('level')) - 1]\n        title = match.group('title')\n        underline = underchar * len(title)\n\n        full_title = '\\n'.join((title, underline))\n        content = content.replace(match.group(0), full_title)\n\n    content = RE_CODE.sub('``\\g<1>``', content)\n\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef converter(type_name):\n    converter = TYPES.get(type_name)\n    if converter is None:\n        raise ConverterError('Unknown converter: %r' % type_name)\n    return converter()", "response": "Get a given converter by name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a given string to the type indicated by type_name.", "response": "def cast(type_name, value, **opts):\n    \"\"\"Convert a given string to the type indicated by ``type_name``.\n\n    If ``None`` is passed in, it will always be returned.\n    Optional arguments can include ``true_values`` and ``false_values`` to\n    describe boolean types, and ``format`` for dates.\n    \"\"\"\n    type_name, opts = _field_options(type_name, opts)\n    return converter(type_name).cast(value, **opts)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stringify(type_name, value, **opts):\n    type_name, opts = _field_options(type_name, opts)\n    return converter(type_name).stringify(value, **opts)", "response": "Generate a string representation of the data in value based on the converter specified by type_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guesser(types=GUESS_TYPES, strict=False):\n    return TypeGuesser(types=types, strict=strict)", "response": "Create a type guesser for multiple values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mk_class_name(*parts):\n    cap = lambda s: s and (s[0].capitalize() + s[1:])\n    return \"\".join([\"\".join([cap(i)\n                             for i in re.split(\"[\\ \\-\\_\\.]\", str(p))])\n                    for p in parts])", "response": "Create a valid class name from a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nencodes strings in basic python objects.", "response": "def encode_simple(d):\n    \"\"\"Encode strings in basic python objects.\"\"\"\n    if isinstance(d, unicode):\n        return d.encode()\n    if isinstance(d, list):\n        return list(map(encode_simple, d))\n    if isinstance(d, dict):\n        return dict([(encode_simple(k), encode_simple(v)) for k, v in d.items()])\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a RADL document in JSON.", "response": "def parse_radl(data):\n    \"\"\"\n    Parse a RADL document in JSON.\n\n    Args.:\n    - data(str or list): document to parse.\n\n    Return(RADL): RADL object.\n    \"\"\"\n    if not isinstance(data, list):\n        if os.path.isfile(data):\n            f = open(data)\n            data = \"\".join(f.readlines())\n            f.close()\n        data = json.loads(data)\n    data = encode_simple(data)\n    res = RADL()\n    for aspect in [p_aspect(a) for a in data]:\n        res.add(aspect)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump_radl(radl, enter=\"\\n\", indent=\"  \"):\n\n    indent = len(indent) if enter else None\n    sort_keys = indent is not None\n    separators = (\",\", \":\" if indent is None else \": \")\n    return json.dumps(radlToSimple(radl), indent=indent, sort_keys=sort_keys, separators=separators)", "response": "Dump a RADL document."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a RADL data object to a list of simple maps.", "response": "def radlToSimple(radl_data):\n    \"\"\"\n    Return a list of maps whose values are only other maps or lists.\n    \"\"\"\n\n    aspects = (radl_data.ansible_hosts + radl_data.networks + radl_data.systems +\n               radl_data.configures + radl_data.deploys)\n    if radl_data.contextualize.items is not None:\n        aspects.append(radl_data.contextualize)\n    return [aspectToSimple(a) for a in aspects]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unique(series: pd.Series) -> pd.Series:\n    return ~series.duplicated(keep=False)", "response": "Test that the data items do not repeat."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_diff(test_case, test_case_result, output_file, base_file_path):\n    with open(File.file_path(base_file_path, test_case.expected.sha1)) as fp:\n        expected_output = fp.read()\n    actual_output = ''\n    if os.path.isfile(output_file):\n        with open('tc_{0}'.format(test_case.id)) as fp:\n            actual_output = fp.read()\n    unit = Diff(expected_output, actual_output)\n    if not unit.outputs_match():\n        test_case_result.diff = File.fetch_or_create(pickle.dumps(unit),\n                                                     base_file_path)\n        return False\n    return True", "response": "Compute the diff for the given test case and test case result."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open_audio(frequency=44100, format=AudioFormat.default, channels=2, chunksize=1024):\n    check_int_err(lib.Mix_OpenAudio(frequency, format, channels, chunksize))", "response": "Open the mixer with a certain audio format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a file - like object of the XML data in the specified language.", "response": "def reader(path):\n    \"\"\"\n    Turns a path to a dump file into a file-like object of (decompressed)\n    XML data assuming that '7z' is installed and will know what to do.\n\n    :Parameters:\n        path : `str`\n            the path to the dump file to read\n    \"\"\"\n    p = subprocess.Popen(\n        ['7z', 'e', '-so', path],\n        stdout=subprocess.PIPE,\n        stderr=file_open(os.devnull, \"w\")\n    )\n    return io.TextIOWrapper(p.stdout, encoding='utf-8',\n                            errors='replace')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset or get metadata associated with an object:: usage: cdstar metadata <URL> [<JSON>] <JSON> Path to metadata in JSON, or JSON literal.", "response": "def c_metadata(api, args, verbose=False):\n    \"\"\"\nSet or get metadata associated with an object::\n\n    usage: cdstar metadata <URL> [<JSON>]\n\n    <JSON>  Path to metadata in JSON, or JSON literal.\n\"\"\"\n    obj = api.get_object(args['<URL>'].split('/')[-1])\n    if not set_metadata(args['<JSON>'], obj):\n        return json.dumps(obj.metadata.read(), indent=4)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete an object:: usage: cdstar delete <URL>", "response": "def c_delete(api, args, verbose=False):\n    \"\"\"\nDelete an object::\n\n    usage: cdstar delete <URL>\n\"\"\"\n    obj = api.get_object(args['<URL>'].split('/')[-1])\n    obj.delete()\n    if verbose:\n        return ['deleted object at', api.url(obj)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist bitstreams of an object:: usage: cdstar ls [options] <URL> options: -t sort by modification time, newest first -s sort by filesize, biggest first -r reverse order while sorting", "response": "def c_ls(api, args, verbose=False):\n    \"\"\"\nList bitstreams of an object::\n\n    usage: cdstar ls [options] <URL>\n\n    options:\n        -t  sort by modification time, newest first\n        -s  sort by filesize, biggest first\n        -r  reverse order while sorting\n\"\"\"\n    obj = api.get_object(args['<URL>'].split('/')[-1])\n    res = []\n    for bitstream in obj.bitstreams:\n        res.append((\n            api.url(bitstream),\n            bitstream._properties['content-type'],\n            bitstream._properties['filesize'],\n            datetime.fromtimestamp(bitstream._properties['last-modified'] / 1000.0)\n        ))\n    if args['-t']:\n        res = sorted(res, key=lambda t: t[3], reverse=True)\n    elif args['-s']:\n        res = sorted(res, key=lambda t: t[2], reverse=True)\n    if args['-r']:\n        res = reversed(res)\n\n    for r in res:\n        yield '{0}\\t{1}\\t{2:>8}\\t{3}'.format(*r) if verbose else r[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef c_create(api, args, verbose=False):\n    def patterns(opt):\n        res = _split(opt)\n        if res:\n            return r'|'.join([fnmatch.translate(x) for x in res])\n\n    includes = patterns(args['--include'])\n    excludes = patterns(args['--exclude'])\n\n    obj = api.get_object()\n    if verbose:\n        yield 'object created at'\n        yield api.url(obj)\n\n    if set_metadata(args['--metadata'], obj):\n        if verbose:\n            yield 'adding metadata'\n            yield api.url(obj.metadata)\n\n    for root, dirs, files in os.walk(args['<DIR>']):\n        # exclude/include files\n        files = [os.path.join(root, f) for f in files]\n        if excludes:\n            files = [f for f in files if not re.match(excludes, f)]\n        if includes:\n            files = [f for f in files if re.match(includes, f)]\n\n        for fname in files:\n            bitstream = obj.add_bitstream(fname=fname)\n            if verbose:\n                yield 'adding bitstream'\n                yield api.url(bitstream)\n\n    yield api.url(obj)", "response": "cdstar create - create a new object uploading files from a directory as bitstreams ::\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms primitive operations for profiling", "response": "def primitives():\n    \"\"\"\n    Perform primitive operations for profiling\n    \"\"\"\n    z = randomZ(orderG1())\n\n    # G1 operations\n    P,Q = randomG1(),randomG1()\n    R = generatorG1()\n    g1Add = P + Q\n    g1ScalarMultiply = z*P\n    g1GeneratorMultiply = z*R\n    g1Hash = hashG1(hash_in)\n\n    # G2 operations\n    P,Q = randomG2(),randomG2()\n    R = generatorG2()\n    g2Add = P + Q\n    g2ScalarMultiply = z*P\n    g2GeneratorMultiply = z*R\n    g2hash = hashG2(hash_in)\n\n    # Gt operations\n    P = randomGt()\n    Q = randomGt()\n    gtMult = P * Q\n    gtExp = P**z\n\n    # Pairing\n    x,y = (randomG1(), randomG2())\n    R = pair(x,y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the full protocol including proof generation and verification.", "response": "def protoWithProof():\n    \"\"\"\n    Run the full protocol including proof generation and verification.\n    \"\"\"\n    r, x = blind(m)\n    y,kw,tTilde = eval(w,t,x,msk,s)\n\n    pi = prove(x, tTilde, kw, y)\n    verify(x, t, y, pi, errorOnFail=True)\n\n    z = deblind(r, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef proofMethods():\n    r, x = blind(m)\n    y,kw,tTilde = eval(w,t,x,msk,s)\n\n    # Proof in Gt/Gt\n    pi = proveGt(x, tTilde, kw, y)\n    verifyGt(x, tTilde, y, pi, errorOnFail=True)\n\n    # Proof in G1/Gt\n    pi = proveG1(x, tTilde, kw, y)\n    verifyG1(x, tTilde, y, pi, errorOnFail=True)\n\n    z = deblind(r, y)", "response": "Run the full protocol including proof generation and verification."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the protocol but omits proof generation and verification.", "response": "def protoFast():\n    \"\"\"\n    Runs the protocol but omits proof generation and verification.\n    \"\"\"\n    r, x = blind(m)\n    y,kw,tTilde = eval(w,t,x,msk,s)\n    z = deblind(r, y)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform an access flags to a string", "response": "def get_access_flags_string(value):\n    \"\"\"\n      Transform an access flags to the corresponding string\n\n      :param value: the value of the access flags\n      :type value: int\n\n      :rtype: string\n  \"\"\"\n    buff = \"\"\n    for i in ACCESS_FLAGS:\n        if (i[0] & value) == i[0]:\n            buff += i[1] + \" \"\n\n    if buff != \"\":\n        return buff[:-1]\n    return buff"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_shorty_idx_value(self):\n        if self.shorty_idx_value == None:\n            self.shorty_idx_value = self.CM.get_string(self.shorty_idx)\n        return self.shorty_idx_value", "response": "Returns the string associated to the shorty_idx attribute of the class attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_return_type_idx_value(self):\n        if self.return_type_idx_value == None:\n            self.return_type_idx_value = self.CM.get_type(self.return_type_idx)\n\n        return self.return_type_idx_value", "response": "Returns the string associated to the return_type_idx"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_parameters_off_value(self):\n        if self.parameters_off_value == None:\n            params = self.CM.get_type_list(self.parameters_off)\n            self.parameters_off_value = '({})'.format(' '.join(params))\n        return self.parameters_off_value", "response": "Returns the string associated to the parameters_off attribute of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the type of the field", "response": "def get_type(self):\n        \"\"\"\n            Return the type of the field\n\n            :rtype: string\n        \"\"\"\n        if self.type_idx_value == None:\n            self.type_idx_value = self.CM.get_type(self.type_idx)\n\n        return self.type_idx_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_name(self):\n        if self.name_idx_value == None:\n            self.name_idx_value = self.CM.get_string(self.name_idx)\n\n        return self.name_idx_value", "response": "Returns the name of the field\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the access flags string of the field", "response": "def get_access_flags_string(self):\n        \"\"\"\n            Return the access flags string of the field\n\n            :rtype: string\n        \"\"\"\n        if self.access_flags_string == None:\n            self.access_flags_string = get_access_flags_string(\n                self.get_access_flags())\n\n            if self.access_flags_string == \"\":\n                self.access_flags_string = \"0x%x\" % self.get_access_flags()\n        return self.access_flags_string"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay the information about the field.", "response": "def show(self):\n        \"\"\"\n            Display the information (with a pretty print) about the field\n        \"\"\"\n        bytecode._PrintSubBanner(\"Field Information\")\n        bytecode._PrintDefault(\"%s->%s %s [access_flags=%s]\\n\" % (\n            self.get_class_name(), self.get_name(), self.get_descriptor(),\n            self.get_access_flags_string()))\n\n        init_value = self.get_init_value()\n        if init_value != None:\n            bytecode._PrintDefault(\"\\tinit value: %s\\n\" %\n                                   str(init_value.get_value()))\n\n        self.show_xref(self.CM.get_vmanalysis().get_field_analysis(self))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying the XREFs of this field.", "response": "def show_xref(self, f_a):\n        \"\"\"\n            Display where this field is read or written\n        \"\"\"\n        if f_a:\n            bytecode._PrintSubBanner(\"XREF Read\")\n            xrefs_from = f_a.get_xref_read()\n            for ref_class, ref_method in xrefs_from:\n                bytecode._PrintDefault(ref_method.get_name())\n                bytecode._PrintDefault('\\n')\n\n            bytecode._PrintDefault('\\n')\n\n            bytecode._PrintSubBanner(\"XREF Write\")\n            xrefs_to = f_a.get_xref_write()\n            for ref_class, ref_method in xrefs_to:\n                bytecode._PrintDefault(ref_method.get_name())\n                bytecode._PrintDefault('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay the basic information about the method.", "response": "def show_info(self):\n        \"\"\"\n            Display the basic information about the method\n        \"\"\"\n        bytecode._PrintSubBanner(\"Method Information\")\n        bytecode._PrintDefault(\"%s->%s%s [access_flags=%s]\\n\" % (\n            self.get_class_name(), self.get_name(), self.get_descriptor(),\n            self.get_access_flags_string()))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the information about the method and its associated parameters.", "response": "def show(self):\n        \"\"\"\n            Display the information (with a pretty print) about the method\n        \"\"\"\n        self.show_info()\n        self.show_notes()\n        if self.code != None:\n            self.each_params_by_register(self.code.get_registers_size(),\n                                         self.get_descriptor())\n            self.code.show(self.CM.get_vmanalysis().get_method(self))\n            self.show_xref(self.CM.get_vmanalysis().get_method_analysis(self))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_instructions(self, instructions):\n        if self.code == None:\n            return []\n        return self.code.get_bc().set_instructions(instructions)", "response": "Set the instructions for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a message to a specific instruction by using the index of the address if specified.", "response": "def add_inote(self, msg, idx, off=None):\n        \"\"\"\n            Add a message to a specific instruction by using (default) the index of the address if specified\n\n            :param msg: the message\n            :type msg: string\n            :param idx: index of the instruction (the position in the list of the instruction)\n            :type idx: int\n            :param off: address of the instruction\n            :type off: int\n        \"\"\"\n        if self.code != None:\n            self.code.add_inote(msg, idx, off)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the XREF From and To of the class that this method is called or which method is called or which method is called.", "response": "def show_xref(self, c_a):\n        \"\"\"\n            Display where the method is called or which method is called\n        \"\"\"\n        if c_a:\n            ref_kind_map = {0: \"Class instanciation\", 1: \"Class reference\"}\n            bytecode._PrintSubBanner(\"XREF From\")\n\n            xrefs_from = c_a.get_xref_from()\n            for ref_class in xrefs_from:\n                if ref_class.get_vm_class().get_name() == self.get_name():\n                    continue\n                for ref_kind, ref_method, ref_offset in xrefs_from[ref_class]:\n                    bytecode._PrintDefault(ref_kind_map[ref_kind])\n                    bytecode._PrintDefault(' ')\n                    bytecode._PrintDefault(ref_method.get_name())\n                    bytecode._PrintDefault(' @ 0x%x' % ref_offset)\n                    bytecode._PrintDefault('\\n')\n\n            bytecode._PrintDefault('\\n')\n\n            bytecode._PrintSubBanner(\"XREF To\")\n            xrefs_to = c_a.get_xref_to()\n            for ref_class in xrefs_to:\n                if ref_class.get_vm_class().get_name() == self.get_name():\n                    continue\n                bytecode._PrintDefault(ref_class.get_vm_class().get_name())\n                bytecode._PrintDefault(' -->\\n')\n                for ref_kind, ref_method, ref_offset in xrefs_to[ref_class]:\n                    bytecode._PrintDefault(ref_kind_map[ref_kind])\n                    bytecode._PrintDefault(' ')\n                    bytecode._PrintDefault(ref_method.get_name())\n                    bytecode._PrintDefault(' @ 0x%x' % ref_offset)\n                    bytecode._PrintDefault('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_output(self, idx=-1):\n        buff = \"\"\n\n        data = self.get_data()\n\n        buff += repr(data) + \" | \"\n        for i in range(0, len(data)):\n            buff += \"\\\\x%02x\" % data[i]\n\n        return buff", "response": "Return an additional output of the instruction\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_buff(self, pos):\n        buff = self.get_name() + \" \"\n        for i in range(0, len(self.keys)):\n            buff += \"%x:%x \" % (self.keys[i], self.targets[i])\n\n        return buff", "response": "Return the display of the instruction\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_instructions(self, cm, size, insn, idx):\n        self.odex = cm.get_odex_format()\n\n        max_idx = size * calcsize('=H')\n        if max_idx > len(insn):\n            max_idx = len(insn)\n\n        # Get instructions\n        while idx < max_idx:\n            obj = None\n            classic_instruction = True\n\n            op_value = insn[idx]\n\n            #print \"%x %x\" % (op_value, idx)\n\n            #payload instructions or extented/optimized instructions\n            if (op_value == 0x00 or op_value == 0xff) and ((idx + 2) < max_idx):\n                op_value = unpack('=H', insn[idx:idx + 2])[0]\n\n                # payload instructions ?\n                if op_value in DALVIK_OPCODES_PAYLOAD:\n                    try:\n                        obj = get_instruction_payload(op_value, insn[idx:])\n                        classic_instruction = False\n                    except struct.error:\n                        warning(\"error while decoding instruction ...\")\n\n                elif op_value in DALVIK_OPCODES_EXTENDED_WIDTH:\n                    try:\n                        obj = get_extented_instruction(cm, op_value, insn[idx:])\n                        classic_instruction = False\n                    except struct.error as why:\n                        warning(\"error while decoding instruction ...\" +\n                                why.__str__())\n\n                # optimized instructions ?\n                elif self.odex and (op_value in DALVIK_OPCODES_OPTIMIZED):\n                    obj = get_optimized_instruction(cm, op_value, insn[idx:])\n                    classic_instruction = False\n\n            # classical instructions\n            if classic_instruction:\n                op_value = insn[idx]\n                obj = get_instruction(cm, op_value, insn[idx:], self.odex)\n\n            # emit instruction\n            yield obj\n            idx = idx + obj.get_length()", "response": "Get the instructions of the buffer at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a particular instruction by using the index of the address if specified", "response": "def get_instruction(self, idx, off=None):\n        \"\"\"\n            Get a particular instruction by using (default) the index of the address if specified\n\n            :param idx: index of the instruction (the position in the list of the instruction)\n            :type idx: int\n            :param off: address of the instruction\n            :type off: int\n\n            :rtype: an :class:`Instruction` object\n        \"\"\"\n        if off != None:\n            idx = self.off_to_pos(off)\n        return [i for i in self.get_instructions()][idx]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay this object s basic blocks and exceptions.", "response": "def show(self, m_a):\n        \"\"\"\n            Display (with a pretty print) this object\n\n            :param m_a: :class:`MethodAnalysis` object\n        \"\"\"\n        bytecode.PrettyShow(m_a, m_a.basic_blocks.gets(), self.notes)\n        bytecode.PrettyShowEx(m_a.exceptions.gets())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_item_type(self, ttype):\n        for i in self.map_item:\n            if TYPE_MAP_ITEM[i.get_type()] == ttype:\n                return i.get_item()\n        return None", "response": "Get a particular item type"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the dex of the current file in raw format", "response": "def save(self):\n        \"\"\"\n          Return the dex (with the modifications) into raw format (fix checksums)\n          (beta: do not use !)\n\n          :rtype: string\n      \"\"\"\n        l = []\n        h = {}\n        s = {}\n        h_r = {}\n\n        idx = 0\n        for i in self.map_list.get_obj():\n            length = 0\n\n            if isinstance(i, list):\n                for j in i:\n                    if isinstance(j, AnnotationsDirectoryItem):\n                        if idx % 4 != 0:\n                            idx = idx + (4 - (idx % 4))\n\n                    l.append(j)\n\n                    c_length = j.get_length()\n                    if isinstance(j, StringDataItem):\n                        c_length += 1\n                    h[j] = idx + length\n                    h_r[idx + length] = j\n                    s[idx + length] = c_length\n\n                    length += c_length\n                    #debug(\"SAVE\" + str(j) + \" @ 0x%x\" % (idx+length))\n\n                debug(\"SAVE \" + str(i[0]) + \" @0x%x (%x)\" % (idx, length))\n\n            else:\n                if isinstance(i, MapList):\n                    if idx % 4 != 0:\n                        idx = idx + (4 - (idx % 4))\n\n                l.append(i)\n                h[i] = idx\n                h_r[idx] = i\n\n                length = i.get_length()\n\n                s[idx] = length\n\n                debug(\"SAVE \" + str(i) + \" @0x%x (%x)\" % (idx, length))\n\n            idx += length\n\n        self.header.file_size = idx\n\n        for i in l:\n            idx = h[i]\n            i.set_off(idx)\n            if isinstance(i, CodeItem):\n                last_idx = idx\n                for j in i.get_obj():\n                    j.set_off(last_idx)\n                    #j.set_debug_info_off(0)\n                    last_idx += j.get_size()\n\n        last_idx = 0\n        buff = \"\"\n        for i in l:\n            idx = h[i]\n\n            if idx != last_idx:\n                debug(\"Adjust alignment @%x with 00 %x\" % (idx, idx - last_idx))\n                buff += \"\\x00\" * (idx - last_idx)\n\n            buff += i.get_raw()\n            if isinstance(i, StringDataItem):\n                buff += \"\\x00\"\n            last_idx = idx + s[idx]\n\n        debug(\"GLOBAL SIZE %d\" % len(buff))\n\n        return self.fix_checksums(buff)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fix_checksums(self, buff):\n        import zlib\n        import hashlib\n\n        signature = hashlib.sha1(buff[32:]).digest()\n\n        buff = buff[:12] + signature + buff[32:]\n        checksum = zlib.adler32(buff[12:])\n        buff = buff[:8] + pack(\"=i\", checksum) + buff[12:]\n\n        debug(\"NEW SIGNATURE %s\" % repr(signature))\n        debug(\"NEW CHECKSUM %x\" % checksum)\n\n        return buff", "response": "Fixes the checksums of a dex format buffer by setting all checksums\n\n         "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_classes_names(self, update=False):\n        if self.classes_names == None or update:\n            self.classes_names = [i.get_name() for i in self.classes.class_def]\n        return self.classes_names", "response": "Returns the names of the classes in this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a specific class in the class_def if it exists else None", "response": "def get_class(self, name):\n        \"\"\"\n          Return a specific class\n\n            :param name: the name of the class\n\n          :rtype: a :class:`ClassDefItem` object\n        \"\"\"\n        for i in self.classes.class_def:\n            if i.get_name() == name:\n                return i\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all field objects that are in the class_def", "response": "def get_fields(self):\n        \"\"\"\n          Return all field objects\n\n          :rtype: a list of :class:`EncodedField` objects\n        \"\"\"\n        l = []\n        for i in self.classes.class_def:\n            for j in i.get_fields():\n                l.append(j)\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all method objects in the hierarchy", "response": "def get_methods(self):\n        \"\"\"\n          Return all method objects\n\n          :rtype: a list of :class:`EncodedMethod` objects\n        \"\"\"\n        l = []\n        for i in self.classes.class_def:\n            for j in i.get_methods():\n                l.append(j)\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_method_by_idx(self, idx):\n        if self.__cached_methods_idx == None:\n            self.__cached_methods_idx = {}\n            for i in self.classes.class_def:\n                for j in i.get_methods():\n                    self.__cached_methods_idx[j.get_method_idx()] = j\n\n        try:\n            return self.__cached_methods_idx[idx]\n        except KeyError:\n            return None", "response": "Return a specific method by using an index"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_methods_descriptor(self, class_name, method_name):\n        l = []\n        for i in self.classes.class_def:\n            if i.get_name() == class_name:\n                for j in i.get_methods():\n                    if j.get_name() == method_name:\n                        l.append(j)\n\n        return l", "response": "Returns the specific methods of the class with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all methods of a specific class", "response": "def get_methods_class(self, class_name):\n        \"\"\"\n            Return all methods of a specific class\n\n            :param class_name: the class name\n            :type class_name: string\n\n            :rtype: a list with :class:`EncodedMethod` objects\n        \"\"\"\n        l = []\n        for i in self.classes.class_def:\n            for j in i.get_methods():\n                if class_name == j.get_class_name():\n                    l.append(j)\n\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all fields of a specific class", "response": "def get_fields_class(self, class_name):\n        \"\"\"\n            Return all fields of a specific class\n\n            :param class_name: the class name\n            :type class_name: string\n\n            :rtype: a list with :class:`EncodedField` objects\n        \"\"\"\n        l = []\n        for i in self.classes.class_def:\n            for j in i.get_fields():\n                if class_name == j.get_class_name():\n                    l.append(j)\n\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self):\n        dex_raw = super(DalvikOdexVMFormat, self).save()\n        return self.magic + self.odex_header.get_raw(\n        ) + dex_raw + self.dependencies.get_raw() + self.padding", "response": "Save the Dalvik OdexVM format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef identify(self, request):\n        try:\n            authorization = request.authorization\n        except ValueError:\n            return NO_IDENTITY\n        if authorization is None:\n            return NO_IDENTITY\n        authtype, params = authorization\n        auth = parse_basic_auth(authtype, params)\n        if auth is None:\n            return NO_IDENTITY\n        return Identity(userid=auth.username, password=auth.password)", "response": "Establish claimed identity using request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, validated_data):\n        '''We want to set the username to be the same as the email, and use\n        the correct create function to make use of password hashing.'''\n        validated_data['username'] = validated_data['email']\n        admin = validated_data.pop('is_superuser', None)\n\n        if admin is True:\n            user = User.objects.create_superuser(**validated_data)\n        else:\n            user = User.objects.create_user(**validated_data)\n\n        return user", "response": "Create a user object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the object with the data provided.", "response": "def update(self, instance, validated_data):\n        '''We want to set all the required fields if admin is set, and we want\n        to use the password hashing method if password is set.'''\n        admin = validated_data.pop('is_superuser', None)\n        password = validated_data.pop('password', None)\n        if validated_data.get('email') is not None:\n            validated_data['username'] = validated_data['email']\n\n        for attr, value in validated_data.items():\n            setattr(instance, attr, value)\n        if admin is not None:\n            instance.is_staff = admin\n            instance.is_superuser = admin\n        if password is not None:\n            instance.set_password(password)\n\n        instance.save()\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process(self, user, timestamp, data=None):\n        event = Event(user, mwtypes.Timestamp(timestamp), self.event_i, data)\n        self.event_i += 1\n\n        for user, events in self._clear_expired(event.timestamp):\n            yield Session(user, unpack_events(events))\n\n        # Apply revision\n        if event.user in self.active_users:\n            events = self.active_users[event.user]\n        else:\n            events = []\n            self.active_users[event.user] = events\n            active_session = ActiveSession(event.timestamp, event.i, events)\n            self.recently_active.push(active_session)\n\n        events.append(event)", "response": "Processes a user event and returns a generator of Sessions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the active unexpired sessions.", "response": "def get_active_sessions(self):\n        \"\"\"\n        Retrieves the active, unexpired sessions.\n\n        :Returns:\n            A generator of :class:`~mwsessions.Session`\n\n        \"\"\"\n        for last_timestamp, i, events in self.recently_active:\n            yield Session(events[-1].user, unpack_events(events))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all the values with name k.", "response": "def values_for(self, k):\n        \"\"\"\n        Each value with name `k`.\n        \"\"\"\n        return [getattr(frame, k) for frame in self.stack if hasattr(frame, k)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the internal state of the current object.", "response": "def reset(self):\n        \"\"\"\n        Used if you need to recursively parse forms.\n        \"\"\"\n        self.stack.append(Frame(src=None, src_path=None))\n        return Close(functools.partial(self.restore))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rewind(self, stop):\n        for i, frame in enumerate(reversed(self.stack)):\n            if stop(frame):\n                frames = self.stack[-i:]\n                break\n        else:\n            raise RewindDidNotStop()\n        del self.stack[-i:]\n        if self.src_path is not None:\n            for frame in frames:\n                if 'src_path' in frame:\n                    break\n                if 'src' in frame:\n                    self.src_path.pop()\n        return Close(functools.partial(self.restore, frames))", "response": "Rewinds the stack to a particular frame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _is_loggedin(self, auth_secret):\n        # Get the userid from the authentication secret.\n        userid = self._rc.hget(pytwis_constants.AUTHS_KEY, auth_secret)\n        if userid is None:\n            return (False, None)\n\n        # Compare the input authentication secret with the stored one.\n        userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n        stored_auth_secret = self._rc.hget(userid_profile_key, pytwis_constants.AUTH_KEY)\n        if auth_secret == stored_auth_secret:\n            return (True, userid)\n\n        # TODO: Resolve the inconsistency of the two authentication secrets.\n        return (False, None)", "response": "Checks if a user is logged - in by verifying the input authentication secret."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_password(password):\n        # Check the length.\n        length_error = len(password) < 8\n\n        # Search for digits.\n        digit_error = re.search(r'\\d', password) is None\n\n        # Search for uppercase letters.\n        uppercase_error = re.search(r'[A-Z]', password) is None\n\n        # Search for lowercase letters.\n        lowercase_error = re.search(r'[a-z]', password) is None\n\n        # Search for symbols (excluding whitespace characters).\n        symbol_error = re.search(r'[^A-Za-z\\d\\s]', password) is None\n\n        return not (length_error or digit_error or uppercase_error or\\\n                    lowercase_error or symbol_error)", "response": "Checks the strength of a password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a new user in the local cache.", "response": "def register(self, username, password):\n        \"\"\"Register a new user.\n\n        Parameters\n        ----------\n        username: str\n            The username.\n        password: str\n            The password.\n\n        Returns\n        -------\n        bool\n            True if the new user is successfully registered, False otherwise.\n        result\n            An empty dict if the new user is successfully registered, a dict\n            containing the error string with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_USERNAME_ALREADY_EXISTS.format(username)\n        -  ERROR_WEAK_PASSWORD\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check the username.\n        if not Pytwis._check_username(username):\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_INVALID_USERNAME\n            return (False, result)\n\n        # Check the password.\n        if not Pytwis._check_password(password):\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_WEAK_PASSWORD\n            return (False, result)\n\n        # Update the username-to-userid mapping.\n        with self._rc.pipeline() as pipe:\n            while True:\n                try:\n                    # Put a watch on the Hash 'users': username -> user-id, in case that\n                    # multiple clients are registering with the same username.\n                    pipe.watch(pytwis_constants.USERS_KEY)\n                    username_exists = pipe.hexists(pytwis_constants.USERS_KEY, username)\n                    if username_exists:\n                        result[pytwis_constants.ERROR_KEY] = \\\n                            pytwis_constants.ERROR_USERNAME_ALREADY_EXISTS.format(username)\n                        return (False, result)\n\n                    # Get the next user-id. If the key \"next_user_id\" doesn't exist,\n                    # it will be created and initialized as 0, and then incremented by 1.\n                    userid = pipe.incr(pytwis_constants.NEXT_USER_ID_KEY)\n\n                    # Set the username-to-userid pair in USERS_HASH_KEY.\n                    pipe.multi()\n                    pipe.hset(pytwis_constants.USERS_KEY, username, userid)\n                    pipe.execute()\n\n                    break\n                except WatchError:\n                    continue\n\n            # Generate the authentication secret.\n            auth_secret = secrets.token_hex()\n            userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n\n            # Generate the password hash.\n            # The format of the password hash looks like \"method$salt$hash\".\n            password_hash = generate_password_hash(password,\n                                                   method=\\\n                                                   pytwis_constants.PASSWORD_HASH_METHOD)\n\n            pipe.multi()\n            # Update the authentication_secret-to-userid mapping.\n            pipe.hset(pytwis_constants.AUTHS_KEY, auth_secret, userid)\n            # Create the user profile.\n            pipe.hmset(userid_profile_key,\n                       {pytwis_constants.USERNAME_KEY: username,\n                        pytwis_constants.PASSWORD_HASH_KEY: password_hash,\n                        pytwis_constants.AUTH_KEY: auth_secret})\n            pipe.execute()\n\n        return (True, result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef change_password(self, auth_secret, old_password, new_password):\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        if old_password == new_password:\n            result[pytwis_constants.ERROR_KEY] = \\\n                pytwis_constants.ERROR_NEW_PASSWORD_NO_CHANGE\n            return (False, result)\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Check if the old password matches.\n        userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n        stored_password_hash = self._rc.hget(userid_profile_key,\n                                             pytwis_constants.PASSWORD_HASH_KEY)\n        if not check_password_hash(stored_password_hash, old_password):\n            result[pytwis_constants.ERROR_KEY] = \\\n                pytwis_constants.ERROR_INCORRECT_OLD_PASSWORD\n            return (False, result)\n\n        # Check the password.\n        if not Pytwis._check_password(new_password):\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_WEAK_PASSWORD\n            return (False, result)\n\n        # Generate the new authentication secret.\n        new_auth_secret = secrets.token_hex()\n\n        # Generate the new password hash.\n        # The format of the new password hash looks like \"method$salt$hash\".\n        new_password_hash = generate_password_hash(new_password,\n                                                   method=\\\n                                                   pytwis_constants.PASSWORD_HASH_METHOD)\n\n        # Replace the old password hash by the new one and the old authentication secret\n        # by the new one.\n        with self._rc.pipeline() as pipe:\n            pipe.multi()\n            pipe.hset(userid_profile_key,\n                      pytwis_constants.PASSWORD_HASH_KEY,\n                      new_password_hash)\n            pipe.hset(userid_profile_key, pytwis_constants.AUTH_KEY, new_auth_secret)\n            pipe.hset(pytwis_constants.AUTHS_KEY, new_auth_secret, userid)\n            pipe.hdel(pytwis_constants.AUTHS_KEY, auth_secret)\n            pipe.execute()\n\n        result[pytwis_constants.AUTH_KEY] = new_auth_secret\n        return (True, result)", "response": "Change the user password."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog into a user.", "response": "def login(self, username, password):\n        \"\"\"Log into a user.\n\n        Parameters\n        ----------\n        username: str\n            The username.\n        password: str\n            The password.\n\n        Returns\n        -------\n        bool\n            True if the login is successful, False otherwise.\n        result\n            A dict containing the authentication secret with the key AUTH_KEY\n            if the login is successful, a dict containing the error string\n            with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_USERNAME_NOT_EXIST_FORMAT.format(username)\n        -  ERROR_INCORRECT_PASSWORD\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Get the user-id based on the username.\n        userid = self._rc.hget(pytwis_constants.USERS_KEY, username)\n        if userid is None:\n            result[pytwis_constants.ERROR_KEY] = \\\n                pytwis_constants.ERROR_USERNAME_NOT_EXIST_FORMAT.format(username)\n            return (False, result)\n\n        # Compare the input password hash with the stored one. If it matches,\n        # return the authentication secret.\n        userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n        stored_password_hash = self._rc.hget(userid_profile_key,\n                                             pytwis_constants.PASSWORD_HASH_KEY)\n        if check_password_hash(stored_password_hash, password):\n            result[pytwis_constants.AUTH_KEY] = \\\n                self._rc.hget(userid_profile_key, pytwis_constants.AUTH_KEY)\n            return (True, result)\n\n        result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_INCORRECT_PASSWORD\n        return (False, result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog out of a user.", "response": "def logout(self, auth_secret):\n        \"\"\"Log out of a user.\n\n        Parameters\n        ----------\n        auth_secret: str\n            The authentication secret of the logged-in user.\n\n        Returns\n        -------\n        bool\n            True if the logout is successful, False otherwise.\n        result\n            None if the logout is successful, a dict containing the error string\n            with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Generate the new authentication secret.\n        new_auth_secret = secrets.token_hex()\n\n        # Replace the old authentication secret by the new one.\n        userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n        with self._rc.pipeline() as pipe:\n            pipe.multi()\n            pipe.hset(userid_profile_key, pytwis_constants.AUTH_KEY, new_auth_secret)\n            pipe.hset(pytwis_constants.AUTHS_KEY, new_auth_secret, userid)\n            pipe.hdel(pytwis_constants.AUTHS_KEY, auth_secret)\n            pipe.execute()\n\n        result[pytwis_constants.USERNAME_KEY] = \\\n            self._rc.hget(userid_profile_key, pytwis_constants.USERNAME_KEY)\n        result[pytwis_constants.AUTH_KEY] = ''\n        return (True, result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the user profile.", "response": "def get_user_profile(self, auth_secret):\n        \"\"\"Get the profile (i.e., username, password, etc.) of a user.\n\n        Parameters\n        ----------\n        auth_secret: str\n            The authentication secret of the logged-in user.\n\n        Returns\n        -------\n        bool\n            True if the logout is successful, False otherwise.\n        result\n            A dict containing the following keys:\n\n            -  USERNAME_KEY\n            -  PASSWORD_HASH_KEY\n            -  AUTH_KEY\n\n            if the user profile is obtained successfully; otherwise a dict\n            containing the error string with the key ERROR_KEY.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = \\\n                pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        userid_profile_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n        result = self._rc.hgetall(userid_profile_key)\n\n        return (True, result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_tweet(self, auth_secret, tweet):\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Get the next user-id. If the key \"next_user_id\" doesn't exist,\n        # it will be created and initialized as 0, and then incremented by 1.\n        post_id = self._rc.incr(pytwis_constants.NEXT_TWEET_ID_KEY)\n        post_id_key = pytwis_constants.TWEET_KEY_FORMAT.format(post_id)\n\n        post_id_timeline_key = pytwis_constants.USER_TIMELINE_KEY_FORMAT.format(userid)\n        post_id_user_key = pytwis_constants.USER_TWEETS_KEY_FORMAT.format(userid)\n\n        follower_zset_key = pytwis_constants.FOLLOWER_KEY_FORMAT.format(userid)\n        followers = self._rc.zrange(follower_zset_key, 0, -1)\n\n        unix_time = int(time.time())\n        with self._rc.pipeline() as pipe:\n            pipe.multi()\n            # Store the tweet with its user ID and UNIX timestamp.\n            pipe.hmset(post_id_key,\n                       {pytwis_constants.TWEET_USERID_KEY: userid,\n                        pytwis_constants.TWEET_UNIXTIME_KEY: unix_time,\n                        pytwis_constants.TWEET_BODY_KEY: tweet})\n\n            # Add the tweet to the user timeline.\n            pipe.lpush(post_id_timeline_key, post_id)\n\n            # Add the tweet to the tweet list posted by the user.\n            pipe.lpush(post_id_user_key, post_id)\n\n            # Write fanout the tweet to all the followers' timelines.\n            for follower in followers:\n                post_id_follower_key = \\\n                    pytwis_constants.USER_TIMELINE_KEY_FORMAT.format(follower)\n                pipe.lpush(post_id_follower_key, post_id)\n\n            # Add the tweet to the general timeline and left trim the general timeline\n            # to only retain the latest GENERAL_TIMELINE_LIST_MAX_TWEET_CNT tweets.\n            pipe.lpush(pytwis_constants.GENERAL_TIMELINE_KEY, post_id)\n            pipe.ltrim(pytwis_constants.GENERAL_TIMELINE_KEY,\n                       0,\n                       pytwis_constants.GENERAL_TIMELINE_MAX_TWEET_CNT - 1)\n\n            pipe.execute()\n\n        return (True, result)", "response": "Post a tweet.\n\n        Parameters\n        ----------\n        auth_secret: str\n            The authentication secret of the logged-in user.\n        tweet: str\n            The tweet that will be posted.\n\n        Returns\n        -------\n        bool\n            True if the tweet is successfully posted, False otherwise.\n        result\n            None if the tweet is successfully posted, a dict containing\n            the error string with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef follow(self, auth_secret, followee_username):\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        with self._rc.pipeline() as pipe:\n            # Check if the followee exists.\n            while True:\n                try:\n                    # Put a watch on the Hash 'users': username -> user-id, in case that\n                    # other clients are modifying the Hash 'users'.\n                    pipe.watch(pytwis_constants.USERS_KEY)\n                    followee_userid = pipe.hget(pytwis_constants.USERS_KEY, followee_username)\n                    if followee_userid is None:\n                        result[pytwis_constants.ERROR_KEY] = \\\n                            pytwis_constants.ERROR_FOLLOWEE_NOT_EXIST_FORMAT.\\\n                                            format(followee_username)\n                        return (False, result)\n                    elif followee_userid == userid:\n                        result[pytwis_constants.ERROR_KEY] = \\\n                            pytwis_constants.ERROR_FOLLOW_YOURSELF_FORMAT.format(followee_username)\n                        return (False, result)\n\n                    break\n                except WatchError:\n                    continue\n\n            # Update the two zset 'followers:[followee_username]' and 'following:[username]'.\n            follower_zset_key = pytwis_constants.FOLLOWER_KEY_FORMAT.format(followee_userid)\n            following_zset_key = pytwis_constants.FOLLOWING_KEY_FORMAT.format(userid)\n            unix_time = int(time.time())\n            pipe.multi()\n            pipe.zadd(follower_zset_key, unix_time, userid)\n            pipe.zadd(following_zset_key, unix_time, followee_userid)\n            pipe.execute()\n\n        return (True, result)", "response": "Follow a user.\n\n        Parameters\n        ----------\n        auth_secret: str\n            The authentication secret of the logged-in user.\n        followee_username: str\n            The username of the followee.\n\n        Returns\n        -------\n        bool\n            True if the follow is successful, False otherwise.\n        result\n            None if the follow is successful, a dict containing\n            the error string with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN\n        -  ERROR_FOLLOWEE_NOT_EXIST_FORMAT.format(followee_username)\n        -  ERROR_FOLLOW_YOURSELF_FORMAT.format(followee_username)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_followers(self, auth_secret):\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Get the list of followers' userids.\n        follower_zset_key = pytwis_constants.FOLLOWER_KEY_FORMAT.format(userid)\n        follower_userids = self._rc.zrange(follower_zset_key, 0, -1)\n\n        if follower_userids is None or not follower_userids:\n            result[pytwis_constants.FOLLOWER_LIST_KEY] = []\n            return (True, result)\n\n        # Get the list of followers' usernames from their userids.\n        with self._rc.pipeline() as pipe:\n            pipe.multi()\n\n            for follower_userid in follower_userids:\n                follower_userid_profile_key = \\\n                    pytwis_constants.USER_PROFILE_KEY_FORMAT.format(follower_userid)\n                pipe.hget(follower_userid_profile_key, pytwis_constants.USERNAME_KEY)\n\n            result[pytwis_constants.FOLLOWER_LIST_KEY] = pipe.execute()\n\n        return (True, result)", "response": "Get the follower list of a logged - in user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_following(self, auth_secret):\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, userid = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Get the list of followers' userids.\n        following_zset_key = pytwis_constants.FOLLOWING_KEY_FORMAT.format(userid)\n        following_userids = self._rc.zrange(following_zset_key, 0, -1)\n\n        if following_userids is None or not following_userids:\n            result[pytwis_constants.FOLLOWING_LIST_KEY] = []\n            return (True, result)\n\n        # Get the list of followings' usernames from their userids.\n        with self._rc.pipeline() as pipe:\n            pipe.multi()\n\n            for following_userid in following_userids:\n                following_userid_profile_key = \\\n                    pytwis_constants.USER_PROFILE_KEY_FORMAT.format(following_userid)\n                pipe.hget(following_userid_profile_key, pytwis_constants.USERNAME_KEY)\n\n            result[pytwis_constants.FOLLOWING_LIST_KEY] = pipe.execute()\n\n        return (True, result)", "response": "Get the following list of a logged - in user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_tweets(self, tweets_key, max_cnt_tweets):\n        tweets = []\n        if max_cnt_tweets == 0:\n            return tweets\n        elif max_cnt_tweets == -1:\n            # Return all the tweets in the timeline.\n            last_tweet_index = -1\n        else:\n            # Return at most max_cnt_tweets tweets.\n            last_tweet_index = max_cnt_tweets - 1\n\n        # Get the post IDs of the tweets.\n        post_ids = self._rc.lrange(tweets_key, 0, last_tweet_index)\n\n        if not post_ids:\n            return tweets\n\n        with self._rc.pipeline() as pipe:\n            # Get the tweets with their user IDs and UNIX timestamps.\n            pipe.multi()\n            for post_id in post_ids:\n                post_id_key = pytwis_constants.TWEET_KEY_FORMAT.format(post_id)\n                pipe.hgetall(post_id_key)\n            tweets = pipe.execute()\n\n            # Get the userid-to-username mappings for all the user IDs associated with the tweets.\n            userid_set = {tweet[pytwis_constants.TWEET_USERID_KEY] for tweet in tweets}\n            userid_list = []\n            pipe.multi()\n            for userid in userid_set:\n                userid_list.append(userid)\n                userid_key = pytwis_constants.USER_PROFILE_KEY_FORMAT.format(userid)\n                pipe.hget(userid_key, pytwis_constants.USERNAME_KEY)\n            username_list = pipe.execute()\n\n        userid_to_username = {userid: username for userid, username in\\\n                              zip(userid_list, username_list)}\n\n        # Add the username for the user ID of each tweet.\n        for tweet in tweets:\n            tweet[pytwis_constants.USERNAME_KEY] = \\\n                userid_to_username[tweet[pytwis_constants.TWEET_USERID_KEY]]\n\n        return tweets", "response": "Get at most max_cnt_tweets tweets from the Redis list tweets_key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the general or user timeline.", "response": "def get_timeline(self, auth_secret, max_cnt_tweets):\n        \"\"\"Get the general or user timeline.\n\n        If an empty authentication secret is given, this method returns the general timeline.\n        If an authentication secret is given and it is valid, this method returns the user timeline.\n        If an authentication secret is given but it is invalid, this method returns an error.\n\n        Parameters\n        ----------\n        auth_secret: str\n            Either the authentication secret of the logged-in user or an empty string.\n        max_cnt_tweets: int\n            The maximum number of tweets included in the timeline. If it is set to -1,\n            then all the available tweets will be included.\n\n        Returns\n        -------\n        bool\n            True if the timeline is successfully retrieved, False otherwise.\n        result\n            A dict containing a list of tweets with the key TWEETS_KEY if\n            the timeline is successfully retrieved, a dict containing\n            the error string with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        if auth_secret == '':\n            # An empty authentication secret implies getting the general timeline.\n            timeline_key = pytwis_constants.GENERAL_TIMELINE_KEY\n        else:\n            # Check if the user is logged in.\n            loggedin, userid = self._is_loggedin(auth_secret)\n            if not loggedin:\n                result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n                return (False, result)\n\n            # Get the user timeline.\n            timeline_key = pytwis_constants.USER_TIMELINE_KEY_FORMAT.format(userid)\n\n        result[pytwis_constants.TWEETS_KEY] = self._get_tweets(timeline_key, max_cnt_tweets)\n        return (True, result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the tweets posted by one user.", "response": "def get_user_tweets(self, auth_secret, username, max_cnt_tweets):\n        \"\"\"Get the tweets posted by one user.\n\n        Parameters\n        ----------\n        auth_secret: str\n            The authentication secret of the logged-in user.\n        username:\n            The name of the user who post the tweets and may not be the logged-in user.\n        max_cnt_tweets: int\n            The maximum number of tweets included in the return. If it is set to -1,\n            then all the tweets posted by the user will be included.\n\n        Returns\n        -------\n        bool\n            True if the tweets are successfully retrieved, False otherwise.\n        result\n            A dict containing a list of tweets with the key TWEETS_KEY if\n            the tweets are successfully retrieved, a dict containing\n            the error string with the key ERROR_KEY otherwise.\n\n        Note\n        ----\n        Possible error strings are listed as below:\n\n        -  ERROR_NOT_LOGGED_IN\n        -  ERROR_USERNAME_NOT_EXIST_FORMAT.format(username)\n        \"\"\"\n        result = {pytwis_constants.ERROR_KEY: None}\n\n        # Check if the user is logged in.\n        loggedin, _ = self._is_loggedin(auth_secret)\n        if not loggedin:\n            result[pytwis_constants.ERROR_KEY] = pytwis_constants.ERROR_NOT_LOGGED_IN\n            return (False, result)\n\n        # Get the userid from the username.\n        userid = self._rc.hget(pytwis_constants.USERS_KEY, username)\n        if userid is None:\n            result[pytwis_constants.ERROR_KEY] = \\\n                pytwis_constants.ERROR_USERNAME_NOT_EXIST_FORMAT.format(username)\n            return (False, result)\n\n        # Get the tweets posted by the user.\n        user_tweets_key = pytwis_constants.USER_TWEETS_KEY_FORMAT.format(userid)\n\n        result[pytwis_constants.TWEETS_KEY] = \\\n            self._get_tweets(user_tweets_key, max_cnt_tweets)\n        return (True, result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef genKw(w,msk,z):\n    # Hash inputs into a string of bytes\n    b = hmac(msk, z + w, tag=\"TAG_PYTHIA_KW\")\n\n    # Convert the string into a long value (no larger than the order of Gt),\n    # then return a BigInt value.\n    return BigInt(longFromString(b) % long(orderGt()))", "response": "Generates a key Kw using key - selector w master secret key msk and and\n    table value z."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getDelta(original, update):\n    # Compute both keys\n    k = genKw(*original)\n    kPrime = genKw(*update)\n\n    # Compute delta,p'\n    delta = (kPrime * inverse(k, orderGt())) % orderGt()\n    pPrime = generatorGt()**kPrime\n    return delta,pPrime", "response": "Generates an update token delta_{k -> k }."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap(x):\n    # Detect the type so we can call the proper serialization routine\n    if isinstance(x, G1Element):\n        return _wrap(x, serializeG1)\n\n    elif isinstance(x, G2Element):\n        return _wrap(x, serializeG2)\n\n    elif isinstance(x, GtElement):\n        return _wrap(x, serializeGt)\n\n    elif isinstance(x, str):        \n        return x\n\n    elif isinstance(x, (int, long, BigInt)):\n        return hex(long(x))\n\n    # All other items\n    else:\n        raise NotImplementedError(\"Cannot unwrap {}; only types {} supported\".\n            format(type(x), \n                [G1Element, G2Element, GtElement, int, long, BigInt]) )", "response": "Wraps an element or integer type by serializing it and base64 encoding it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _wrap(x, serializeFunc, encodeFunc=base64.urlsafe_b64encode, compress=True):\n    return encodeFunc(serializeFunc(x, compress))", "response": "Wrap an element x by serializing and then encoding it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a mapping with a contract. It has high latency gives some kind of guarantee.", "response": "def add_mapping(agent, prefix, ip):\n    \"\"\"Adds a mapping with a contract.\n    It has high latency but gives some kind of guarantee.\"\"\"\n    return _broadcast(agent, AddMappingManager, RecordType.record_A,\n                      prefix, ip)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_mapping(agent, prefix, ip):\n    return _broadcast(agent, RemoveMappingManager,\n                      RecordType.record_A, prefix, ip)", "response": "Removes a mapping with a contract.\n    It has high latency gives some kind of guarantee."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_alias(agent, prefix, alias):\n    return _broadcast(agent, AddMappingManager, RecordType.record_CNAME,\n                      prefix, alias)", "response": "Adds an alias mapping with a contract.\n    It has high latency gives some kind of guarantee."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an alias mapping with a contract.", "response": "def remove_alias(agent, prefix, alias):\n    \"\"\"Removes an alias mapping with a contract.\n    It has high latency but gives some kind of guarantee.\"\"\"\n    return _broadcast(agent, RemoveMappingManager, RecordType.record_CNAME,\n                      prefix, alias)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new mapper object on witch add_mapping and remove_mapping can be called.", "response": "def new_mapper(agent):\n    \"\"\"Creates a mapper object on witch add_mapping() and remove_mapping()\n    can be called. It uses fire-and-forget notifications so it has a very\n    low overhead and latency but a little less guarantees.\"\"\"\n    recp = recipient.Broadcast(MappingUpdatesPoster.protocol_id, 'lobby')\n    return agent.initiate_protocol(MappingUpdatesPoster, recp)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef makeEqualFunction(self, originalEqualFunction, syntheticMemberList):\n        def equal(instance, other):\n            if instance.__class__ is not other.__class__:\n                return NotImplemented\n\n            for m in syntheticMemberList:\n                if getattr(instance, m.privateMemberName()) != getattr(other, m.privateMemberName()):\n                    return False\n\n            if inspect.isfunction(originalEqualFunction) or inspect.ismethod(originalEqualFunction):\n                return originalEqualFunction(instance, other)\n\n            return True\n\n        return equal", "response": "Creates a function that compares the given instance with the given synthetic members."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef makeNotEqualFunction(self, originalNotEqualFunction, syntheticMemberList):\n\n        def not_equal(instance, other):\n            if instance.__class__ is not other.__class__:\n                return NotImplemented\n\n            for m in syntheticMemberList:\n                if getattr(instance, m.privateMemberName()) != getattr(other, m.privateMemberName()):\n                    return True\n\n            if inspect.isfunction(originalNotEqualFunction) or inspect.ismethod(originalNotEqualFunction):\n                return originalNotEqualFunction(instance, other)\n\n            return False\n\n        return not_equal", "response": "Creates a function that returns True if the instance and other are not equal to the originalNotEqualFunction."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a hash function that will be used to hash the values of the synthetic members.", "response": "def makeHashFunction(self, originalHashFunction, syntheticMemberList):\n        \"\"\"\n        :param list(SyntheticMember) syntheticMemberList: a list of the class' synthetic members.\n        \"\"\"\n        if originalHashFunction is None:\n            return None\n\n        for member in syntheticMemberList:\n            if not member.readOnly():\n                return None\n\n        # All synthetic members are read-only: generate a hash function.\n        def hash_function(instance):\n            values = [getattr(instance, m.privateMemberName()) for m in syntheticMemberList]\n            if inspect.isfunction(originalHashFunction) or inspect.ismethod(originalHashFunction):\n                values.append(originalHashFunction(instance))\n            return hash(tuple(values))\n\n        return hash_function"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naugment implementation of __iFUNC__ method.", "response": "def _imethod(self, other, name, op):\n    \"\"\"\n    Shared implementation of __iFUNC__ method.\n\n    :param self:\n        A proxy_base instance\n    :param other:\n        Any right-hand-side value\n    :param name:\n        Name of the __iFUNC__\n    :param op:\n        Appropriate operator.__iFUNC__ operator\n    :returns:\n        self\n    \"\"\"\n    proxiee_old = proxiee_new = _get_proxiee(self)\n    _logger.debug(\"%s on proxiee (%r)\", name, proxiee_old)\n    # NOTE: This _may_ or _may not be_ calling __iFUNC__\n    # as the proxiee may not support it in the first place\n    proxiee_new = op(proxiee_old, other)\n    if proxiee_new is not proxiee_old:\n        # NOTE: all of the augmented assignment methods handle the case where\n        # the __iFUNC__ method returns something other than self. To maintain\n        # the illusion that the proxy is not there the internal proxiee\n        # reference is changed to the new proxiee.\n        _logger.debug(\"%s creates new %s (%r)\",\n                      name, type(self).__name__, proxiee_new)\n        return type(self)(proxiee_new)\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsanitizing the current settings of a Map - Reply message.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix where possible.\n        '''\n        # Record TTL:  The time in minutes the recipient of the Map-Reply will\n        # store the mapping.  If the TTL is 0, the entry SHOULD be removed\n        # from the cache immediately.  If the value is 0xffffffff, the\n        # recipient can decide locally how long to store the mapping.\n        if not isinstance(self.ttl, numbers.Integral) \\\n        or self.ttl < 0 or self.ttl > 0xffffffff:\n            raise ValueError('Invalid TTL')\n\n        # ACT:  This 3-bit field describes negative Map-Reply actions.  In any\n        # other message type, these bits are set to 0 and ignored on\n        # receipt.  These bits are used only when the 'Locator Count' field\n        # is set to 0.  The action bits are encoded only in Map-Reply\n        # messages.  The actions defined are used by an ITR or PITR when a\n        # destination EID matches a negative mapping cache entry.\n        # Unassigned values should cause a map-cache entry to be created\n        # and, when packets match this negative cache entry, they will be\n        # dropped.  The current assigned values are:\n        #\n        #  (0) No-Action:  The map-cache is kept alive and no packet\n        #     encapsulation occurs.\n        #\n        #  (1) Natively-Forward:  The packet is not encapsulated or dropped\n        #     but natively forwarded.\n        #\n        #  (2) Send-Map-Request:  The packet invokes sending a Map-Request.\n        #\n        #  (3) Drop:  A packet that matches this map-cache entry is dropped.\n        #     An ICMP Unreachable message SHOULD be sent.\n        if self.locator_records:\n            self.action = self.ACT_NO_ACTION\n\n        if self.action not in (self.ACT_NO_ACTION,\n                               self.ACT_NATIVELY_FORWARD,\n                               self.ACT_SEND_MAP_REQUEST,\n                               self.ACT_DROP):\n            raise ValueError('Invalid Negative Map-Reply action')\n\n        # A: The Authoritative bit, when sent is always set to 1 by an ETR.\n        # When a Map-Server is proxy Map-Replying [LISP-MS] for a LISP site,\n        # the Authoritative bit is set to 0.  This indicates to requesting\n        # ITRs that the Map-Reply was not originated by a LISP node managed\n        # at the site that owns the EID-prefix.\n        if not isinstance(self.authoritative, bool):\n            raise ValueError('Authoritative flag must be a boolean')\n\n        # Map-Version Number:  When this 12-bit value is non-zero the Map-Reply\n        # sender is informing the ITR what the version number is for the\n        # EID-record contained in the Map-Reply.  The ETR can allocate this\n        # number internally but MUST coordinate this value with other ETRs\n        # for the site.  When this value is 0, there is no versioning\n        # information conveyed.  The Map-Version Number can be included in\n        # Map-Request and Map-Register messages.  See Section 6.6.3 for more\n        # details.\n        if not isinstance(self.map_version, numbers.Integral) \\\n        or self.map_version < 0 \\\n        or self.map_version >= 2 ** 12:\n            raise ValueError('Invalid map version')\n\n        # EID-prefix:  4 octets if an IPv4 address-family, 16 octets if an IPv6\n        # address-family.\n        if not isinstance(self.eid_prefix, (IPv4Network, IPv6Network)):\n            raise ValueError('EID prefix must be IPv4 or IPv6')\n\n        # Check locator records\n        for locator_record in self.locator_records:\n            if not isinstance(locator_record, LocatorRecord):\n                raise ValueError('Invalid Locator record')\n\n            locator_record.sanitize()\n\n        # For each Map-Reply record, the list of Locators in a Locator-Set MUST\n        # appear in the same order for each ETR that originates a Map-Reply\n        # message.  The Locator-Set MUST be sorted in order of ascending IP\n        # address where an IPv4 locator address is considered numerically 'less\n        # than' an IPv6 locator address.\n        self.locator_records.sort(key=LocatorRecord.sort_key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_bytes(cls, bitstream):\n        '''\n        Parse the given record and update properties accordingly\n        '''\n        record = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the record TTL\n        record.ttl = bitstream.read('uint:32')\n\n        # Store the locator record count until we need it\n        locator_record_count = bitstream.read('uint:8')\n\n        # Store the EID prefix mask length until we need it\n        eid_prefix_len = bitstream.read('uint:8')\n\n        # Read the Negative Map_Reply action\n        record.action = bitstream.read('uint:3')\n\n        # Read the flag\n        record.authoritative = bitstream.read('bool')\n\n        # Read reserved bits\n        record._reserved1 = bitstream.read(12 + 4)\n\n        # Read the map version\n        record.map_version = bitstream.read('uint:12')\n\n        # Read the EID prefix\n        record.eid_prefix = read_afi_address_from_bitstream(bitstream,\n                                                            eid_prefix_len)\n\n        # Read the locator records\n        for dummy in range(locator_record_count):\n            locator_record = LocatorRecord.from_bytes(bitstream)\n            record.locator_records.append(locator_record)\n\n        # Verify that the properties make sense\n        record.sanitize()\n\n        return record", "response": "Parse the given record and update properties accordingly\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_bitstream(self):\n        '''\n        Create bitstream from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the TTL\n        bitstream = BitArray('uint:32=%d' % self.ttl)\n\n        # Add the locator count\n        bitstream += BitArray('uint:8=%d' % len(self.locator_records))\n\n        # Add the EID prefix mask length\n        bitstream += BitArray('uint:8=%d' % self.eid_prefix.prefixlen)\n\n        # Add the NMR action\n        bitstream += BitArray('uint:3=%d' % self.action)\n\n        # Add the authoritative flag\n        bitstream += BitArray('bool=%d' % self.authoritative)\n\n        # Add reserved bits\n        bitstream += self._reserved1\n\n        # Add the map version\n        bitstream += BitArray('uint:12=%d' % self.map_version)\n\n        # Add the EID prefix\n        bitstream += get_bitstream_for_afi_address(self.eid_prefix)\n\n        # Add the locator records\n        for locator_record in self.locator_records:\n            bitstream += locator_record.to_bitstream()\n\n        return bitstream", "response": "Create bitstream from properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_pin(text, background_color='green', font_color='white'):\n    '''Draws and returns a pin with the specified text and color scheme'''\n    image = Image.new('RGB', (120, 20))\n    draw = ImageDraw.Draw(image)\n    draw.rectangle([(1, 1), (118, 18)], fill=color(background_color))\n    draw.text((10, 4), text, fill=color(font_color))\n    return image", "response": "Draws and returns a pin with the specified text and color scheme"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator that yields a repository with the given namespace and name.", "response": "def repository(namespace, name, branch='master'):\n    '''Returns a repository'''\n    with TemporaryDirectory() as download_path:\n        old_directory = str(pwd()).strip()\n        try:\n            git.clone('https://github.com/{0}/{1}.git'.format(namespace, name), download_path)\n            cd(download_path)\n            git.fetch('origin', branch)\n            git.checkout(branch)\n            yield (download_path, git('rev-parse', 'HEAD'), redis.Dict(key=\"{0}.{1}\".format(namespace, name)))\n        except ErrorReturnCode_128:\n            mkdir(download_path)\n            yield (None, None, None)\n        cd(old_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ci_data(namespace, name, branch='master'):\n    '''Returns or starts the ci data collection process'''\n    with repository(namespace, name, branch) as (path, latest, cache):\n        if not path or not latest:\n            return {'build_success': NOT_FOUND, 'status': NOT_FOUND}\n        elif latest in cache:\n            return json.loads(cache[latest])\n\n    starting = {'status': 'starting'}\n    cache[latest] = json.dumps(starting)\n    ci_worker(namespace, name, branch=branch, _bg=True)\n    return starting", "response": "Returns or starts the ci data collection process"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_status(namespace, name, branch='master') -> pin:\n    '''Returns the current status of the build'''\n    return ci_data(namespace, name, branch).get('build_success', None)", "response": "Returns the current status of the build"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a data connector into this\n        object.\n\n        '''\n        self.connector_id = node.getAttributeNS(RTS_NS, 'connectorId')\n        self.name = node.getAttributeNS(RTS_NS, 'name')\n        self.data_type = node.getAttributeNS(RTS_NS, 'dataType')\n        self.interface_type = node.getAttributeNS(RTS_NS, 'interfaceType')\n        self.data_flow_type = node.getAttributeNS(RTS_NS, 'dataflowType')\n        if node.hasAttributeNS(RTS_NS, 'subscriptionType'):\n            self.subscription_type = node.getAttributeNS(RTS_NS,\n                                                         'subscriptionType')\n        else:\n            self.subscription_type = ''\n        if node.hasAttributeNS(RTS_NS, 'pushInterval'):\n            self.push_interval = float(node.getAttributeNS(RTS_NS,\n                                                           'pushInterval'))\n        else:\n            self.push_interval = 0.0\n        self.comment = node.getAttributeNS(RTS_EXT_NS, 'comment')\n        if node.hasAttributeNS(RTS_EXT_NS, 'visible'):\n            visible = node.getAttributeNS(RTS_EXT_NS, 'visible')\n            if visible == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n\n        if node.getElementsByTagNameNS(RTS_NS, 'sourceDataPort').length != 1:\n            raise InvalidDataPortConnectorNodeError\n        self.source_data_port = TargetPort().parse_xml_node(\\\n                node.getElementsByTagNameNS(RTS_NS, 'sourceDataPort')[0])\n        if node.getElementsByTagNameNS(RTS_NS, 'targetDataPort').length != 1:\n            raise InvalidDataPortConnectorNodeError\n        self.target_data_port = TargetPort().parse_xml_node(\\\n                node.getElementsByTagNameNS(RTS_NS, 'targetDataPort')[0])\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self", "response": "Parse an xml. dom Node object representing a data connector into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a data port connector into this\n        object.\n\n        '''\n        self.connector_id = y['connectorId']\n        self.name = y['name']\n        self.data_type = y['dataType']\n        self.interface_type = y['interfaceType']\n        self.data_flow_type = y['dataflowType']\n        if 'subscriptionType' in y:\n            self.subscription_type = y['subscriptionType']\n        else:\n            self.subscription_type = ''\n        if 'pushInterval' in y:\n            self.push_interval = float(y['pushInterval'])\n        else:\n            self.push_interval = 0.0\n        if RTS_EXT_NS_YAML + 'comment' in y:\n            self.comment = y[RTS_EXT_NS_YAML + 'comment']\n        else:\n            self.comment = ''\n        if RTS_EXT_NS_YAML + 'visible' in y:\n            visible = y[RTS_EXT_NS_YAML + 'visible']\n            if visible == True or visible == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n        if not 'sourceDataPort' in y:\n            raise InvalidDataPortConnectorNodeError\n        self.source_data_port = \\\n                TargetPort().parse_yaml(y['sourceDataPort'])\n        if not 'targetDataPort' in y:\n            raise InvalidDataPortConnectorNodeError\n        self.target_data_port = \\\n                TargetPort().parse_yaml(y['targetDataPort'])\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y[RTS_EXT_NS_YAML + 'properties']:\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self", "response": "Parse a YAML specification of a data port connector into this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave this data port into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this data port into an xml.dom.Element object.'''\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:dataport_connector_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'connectorId',\n                               self.connector_id)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'name', self.name)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'dataType', self.data_type)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'interfaceType',\n                               self.interface_type)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'dataflowType',\n                               self.data_flow_type)\n        if self.subscription_type:\n            element.setAttributeNS(RTS_NS, RTS_NS_S + 'subscriptionType',\n                                   self.subscription_type)\n        if self.push_interval != 0.0:\n            element.setAttributeNS(RTS_NS, RTS_NS_S + 'pushInterval',\n                                   str(self.push_interval))\n        if self.comment:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'comment',\n                                   self.comment)\n        if self.visible != True:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'visible',\n                                   str(self.visible).lower())\n        new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'sourceDataPort')\n        self.source_data_port.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'targetDataPort')\n        self.target_data_port.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave this data port connector into a dictionary.", "response": "def to_dict(self):\n        '''Save this data port connector into a dictionary.'''\n        d = {'connectorId': self.connector_id,\n                'name': self.name,\n                'dataType': self.data_type,\n                'interfaceType': self.interface_type,\n                'dataflowType': self.data_flow_type,\n                'sourceDataPort': self.source_data_port.to_dict(),\n                'targetDataPort': self.target_data_port.to_dict()}\n        if self.visible != True:\n            d[RTS_EXT_NS_YAML + 'visible'] = self.visible\n        if self.subscription_type:\n            d['subscriptionType'] = self.subscription_type\n        if self.push_interval:\n            d['pushInterval'] = self.push_interval\n        if self.comment:\n            d[RTS_EXT_NS_YAML + 'comment'] = self.comment\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a service port connector into\n        this object.\n\n        '''\n        self.connector_id = node.getAttributeNS(RTS_NS, 'connectorId')\n        self.name = node.getAttributeNS(RTS_NS, 'name')\n        if node.hasAttributeNS(RTS_NS, 'transMethod'):\n            self.trans_method = node.getAttributeNS(RTS_NS,\n                                                         'transMethod')\n        else:\n            self.trans_method = ''\n        self.comment = node.getAttributeNS(RTS_EXT_NS, 'comment')\n        if node.hasAttributeNS(RTS_EXT_NS, 'visible'):\n            visible = node.getAttributeNS(RTS_EXT_NS, 'visible')\n            if visible == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n\n        if node.getElementsByTagNameNS(RTS_NS, 'sourceServicePort').length != 1:\n            raise InvalidServicePortConnectorNodeError\n        self.source_service_port = TargetPort().parse_xml_node(\\\n                node.getElementsByTagNameNS(RTS_NS, 'sourceServicePort')[0])\n        if node.getElementsByTagNameNS(RTS_NS, 'targetServicePort').length != 1:\n            raise InvalidServicePortConnectorNodeError\n        self.target_service_port = TargetPort().parse_xml_node(\\\n                node.getElementsByTagNameNS(RTS_NS, 'targetServicePort')[0])\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self", "response": "Parse an xml. dom Node object representing a service port connector into this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a YAML specification of a service port connector into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a service port connector into this\n        object.\n\n        '''\n        self.connector_id = y['connectorId']\n        self.name = y['name']\n        if 'transMethod' in y:\n            self.trans_method = y['transMethod']\n        else:\n            self.trans_method = ''\n        if RTS_EXT_NS_YAML + 'comment' in y:\n            self.comment = y[RTS_EXT_NS_YAML + 'comment']\n        else:\n            self.comment = ''\n        if RTS_EXT_NS_YAML + 'visible' in y:\n            visible = y[RTS_EXT_NS_YAML + 'visible']\n            if visible == True or visible == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n        if 'sourceServicePort' not in y:\n            raise InvalidServicePortConnectorNodeError\n        self.source_service_port = \\\n                TargetPort().parse_yaml(y['sourceServicePort'])\n        if 'targetServicePort' not in y:\n            raise InvalidServicePortConnectorNodeError\n        self.target_service_port = \\\n                TargetPort().parse_yaml(y['targetServicePort'])\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y[RTS_EXT_NS_YAML + 'properties']:\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves this service port into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this service port into an xml.dom.Element object.'''\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:serviceport_connector_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'connectorId',\n                               self.connector_id)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'name', self.name)\n        if self.trans_method:\n            element.setAttributeNS(RTS_NS, RTS_NS_S + 'transMethod',\n                                   self.trans_method)\n        if self.comment:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'comment',\n                                   self.comment)\n        if self.visible != True:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'visible',\n                                   str(self.visible).lower())\n        new_element = doc.createElementNS(RTS_NS,\n                                          RTS_NS_S + 'sourceServicePort')\n        self.source_service_port.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        new_element = doc.createElementNS(RTS_NS,\n                                          RTS_NS_S + 'targetServicePort')\n        self.target_service_port.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_dict(self):\n        '''Save this service port connector into a dictionary.'''\n        d = {'connectorId': self.connector_id,\n                'name': self.name,\n                'sourceServicePort': self.source_service_port.to_dict(),\n                'targetServicePort': self.target_service_port.to_dict()}\n        if self.visible != True:\n            d[RTS_EXT_NS_YAML + 'visible'] = self.visible\n        if self.trans_method:\n            d['transMethod'] = self.trans_method\n        if self.comment:\n            d[RTS_EXT_NS_YAML + 'comment'] = self.comment\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d", "response": "Save this service port connector into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, doc):\n        d = defer.succeed(doc)\n        for element in self._elements:\n            d.addCallback(element.render)\n        return d", "response": "Render all elements using the specified document."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inject_to(self, objects, field_name, get_inject_object = lambda obj: obj,\n                  select_related = None, **kwargs):\n        '''\n        ``objects`` is an iterable. Related objects\n            will be attached to elements of this iterable.\n\n        ``field_name`` is the attached object attribute name\n\n        ``get_injector_object`` is a callable that takes object in `objects`\n            iterable. Related objects will be available as an attribute of the\n            result of ``get_inject_object(obj)``. It is assumed that ``fk_field``\n            points to  ``get_inject_object(obj)``.\n\n        ``select_related`` is a list to be passed to select_related method for\n            related objects.\n\n        All other kwargs will be passed as arguments to queryset filter function.\n\n        For example, we need to prefetch user profiles when we display a list of\n        comments::\n\n            # models.py\n            class UserProfile(models.Model):\n                user = models.ForeignKey(User, unique=True)\n                info = models.CharField(max_length=100)\n                objects = models.Manager()\n                injector = RelatedInjector(fk_field='user')\n\n            # views.py\n            def show_comments(request, obj_id):\n                ...\n                comments = list(Comment.objects.for_model(obj).select_related('user'))\n                UserProfile.injector.inject_to(comments, '_profile_cache',\n                                               lambda comment: comment.user)\n\n                return direct_to_template('comment_list.html', {'comments': comments})\n\n            # in comment_list.html\n            {% for comment in comments %}\n                <h3>{{ comment.user }}</h3>\n                <h4>{{ comment.user.get_profile.info }}</h4>\n                {{ comment.comment|linebreaks }}\n            {% endfor %}\n\n        ``comment.user`` attribute will be selected using ``select_related`` and\n        ``comment.user._profile_cache`` (exposed by get_profile method) will be\n        selected by our injector. So there will be only 2 SQL queries for\n        selecting all comments with users and user profiles.\n\n        '''\n\n        #get related data\n        kwargs.update({self.fk_field+'__in': [ get_inject_object(obj).pk for obj in objects ]})\n\n        data = self.get_query_set().filter(**kwargs)\n        if select_related:\n            data = data.select_related(select_related)\n\n        data_dict = dict((getattr(item, self.fk_field), item) for item in list(data))\n\n        # add info to original data\n        for obj in objects:\n            injected_obj = get_inject_object(obj)\n\n            if data_dict.has_key(injected_obj):\n                # fk_field was ForeignKey so there are objects in lookup dict\n                get_inject_object(obj).__setattr__(field_name, data_dict[injected_obj])\n\n            elif data_dict.has_key(injected_obj.pk):\n                # fk_field was simple IntegerField so there are pk's in lookup dict\n                get_inject_object(obj).__setattr__(field_name, data_dict[injected_obj.pk])", "response": "Injects related objects into the view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inject_to(self, objects, field_name, get_inject_object = lambda obj: obj, **kwargs):\n        '''\n        ``objects`` is an iterable. Images (or other generic-related model instances)\n            will be attached to elements of this iterable.\n\n        ``field_name`` is the attached object attribute name\n\n        ``get_inject_object`` is a callable that takes object in `objects` iterable.\n            Image will be available as an attribute of the result of\n            `get_injector_object(object)`. Images attached to `get_injector_object(object)`\n            will be selected.\n\n        All other kwargs will be passed as arguments to queryset filter function.\n\n        Example: you have a list of comments. Each comment has 'user' attribute.\n        You want to fetch 10 comments and their authors with avatars. Avatars should\n        be accessible as `user.avatar`::\n\n            comments = Comment.objects.all().select_related('user')[:10]\n            AttachedImage.injector.inject_to(comments, 'avatar', lambda obj: obj.user, is_main=True)\n\n        '''\n\n        try:\n            content_type = ContentType.objects.get_for_model(get_inject_object(objects[0]))\n        except IndexError:\n            return objects\n\n        kwargs.update({self.ct_field: content_type})\n        return super(GenericInjector, self).inject_to(objects, field_name, get_inject_object, **kwargs)", "response": "Injects images and comments into objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all objects that are attached to given model", "response": "def for_model(self, model, content_type=None):\n        ''' Returns all objects that are attached to given model '''\n        content_type = content_type or ContentType.objects.get_for_model(model)\n        kwargs = {\n                    self.ct_field: content_type,\n                    self.fk_field: model.pk\n                 }\n        objects = self.get_query_set().filter(**kwargs)\n        return objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_rows(data, *rows):\n    try:\n        # for python 2.2\n        # return [data[r] for r in rows]\n        out = []\n        for r in rows:\n            out.append(data[r])\n        return out\n    except IndexError:\n        raise IndexError(\"data=%s rows=%s\" % (data, rows))\n    return out", "response": "Extract rows specified in the argument list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting columns specified in the argument list.", "response": "def extract_columns(data, *cols):\n    \"\"\"Extract columns specified in the argument list.\n\n>>> chart_data.extract_columns([[10,20], [30,40], [50,60]], 0)\n[[10],[30],[50]]\n\"\"\"\n    out = []\n    try:\n        # for python 2.2:\n        # return [ [r[c] for c in cols] for r in data]\n        for r in data:\n            col = []\n            for c in cols:\n                col.append(r[c])\n            out.append(col)\n    except IndexError:\n        raise IndexError(\"data=%s col=%s\" % (data, col))\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef moving_average(data, xcol, ycol, width):\n\n    out = []\n    try:\n        for i in range(len(data)):\n            n = 0\n            total = 0\n            for j in range(i - width, i + width + 1):\n                if j >= 0 and j < len(data):\n                    total += data[j][ycol]\n                    n += 1\n            out.append((data[i][xcol], float(total) / n))\n    except IndexError:\n        raise IndexError(\"bad data: %s,xcol=%d,ycol=%d,width=%d\" % (data, xcol, ycol, width))\n\n    return out", "response": "This function computes the moving average of the YCOL'th column of each sample point in DATA."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter(func, data):\n\n    out = []\n    for r in data:\n        if func(r):\n            out.append(r)\n    return out", "response": "This procedure returns a list of all the elements in the data that pass the function func."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transform(func, data):\n    out = []\n    for r in data:\n        out.append(func(r))\n    return out", "response": "Apply a function on each element in data and return the list\nconsisting of the return values from func."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_csv(path, data):\n\n    fd = _try_open_file(path, 'w',\n                        'The first argument must be a pathname or an object that supports write() method')\n    for v in data:\n        fd.write(\",\".join([str(x) for x in v]))\n        fd.write(\"\\n\")\n    _try_close_file(fd, path)", "response": "This function writes comma - separated list of data to\n    <path. Parameter path is either a pathname or a file - like\n    object that supports the write method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef func(f, xmin, xmax, step=None):\n\n    data = []\n    x = xmin\n    if not step:\n        step = (xmax - xmin) / 100.0\n    while x < xmax:\n        data.append((x, f(x)))\n        x += step\n    return data", "response": "Create sample points from function f which must be a\n    single - parameter function that returns a number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the median of the frequency column of the values is data.", "response": "def median(data, freq_col=1):\n    \"\"\"Compute the median of the <freq_col>'th column of the values is <data>.\n\n>>> chart_data.median([(10,20), (20,4), (30,5)], 0)\n20\n>>> chart_data.median([(10,20), (20,4), (30,5)], 1)\n5.\n    \"\"\"\n\n    nr_data = _nr_data(data, freq_col)\n    median_idx = nr_data / 2\n    i = 0\n    for d in data:\n        i += d[freq_col]\n        if i >= median_idx:\n            return d\n    raise Exception(\"??? median ???\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mean_samples(data, xcol, ycollist):\n    out = []\n    numcol = len(ycollist)\n    try:\n        for elem in data:\n            v = 0\n            for col in ycollist:\n                v += elem[col]\n            out.append((elem[xcol], float(v) / numcol))\n    except IndexError:\n        raise IndexError(\"bad data: %s,xcol=%d,ycollist=%s\" % (data, xcol, ycollist))\n\n    return out", "response": "Create a sample list that contains\n    the mean of the original list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stddev_samples(data, xcol, ycollist, delta=1.0):\n    out = []\n    numcol = len(ycollist)\n    try:\n        for elem in data:\n            total = 0\n            for col in ycollist:\n                total += elem[col]\n            mean = float(total) / numcol\n            variance = 0\n            for col in ycollist:\n                variance += (mean - elem[col]) ** 2\n            stddev = math.sqrt(variance / numcol) * delta\n            out.append((elem[xcol], mean, stddev, mean - stddev, mean + stddev))\n\n\n\n    except IndexError:\n        raise IndexError(\"bad data: %s,xcol=%d,ycollist=%s\" % (data, xcol, ycollist))\n    return out", "response": "Create a sample list that contains the mean and standard deviation of the original list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef epanechnikov(xx, idx=None):\n    ans = np.zeros(xx.shape)\n    ans[idx] = 0.75 * (1-xx[idx]**2)\n    return ans", "response": "Estimate the Epanechnikov kernel for the given array of points xx."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tri_cube(xx, idx):\n\n    ans = np.zeros(xx.shape)\n    ans[idx] = (1-np.abs(xx[idx])**3)**3\n    return ans", "response": "Computes the tri - cube kernel estimated for xx values at indices idx"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates a kernel function on x in the neighborhood of x0", "response": "def do_kernel(x0, x, l=1.0, kernel=epanechnikov):\n    \"\"\"\n    Calculate a kernel function on x in the neighborhood of x0\n\n    Parameters\n    ----------\n    x: float array\n       All values of x\n    x0: float\n       The value of x around which we evaluate the kernel\n    l: float or float array (with shape = x.shape)\n       Width parameter (metric window size)\n    \n    \"\"\"\n    # xx is the norm of x-x0. Note that we broadcast on the second axis for the\n    # nd case and then sum on the first to get the norm in each value of x:\n    xx = np.sum(np.sqrt(np.power(x-x0[:,np.newaxis], 2)), 0)\n    idx = np.where(np.abs(xx<=1))\n    return kernel(xx,idx)/l"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the bi - square weight function calculated over values of xx.", "response": "def bi_square(xx, idx=None):\n    \"\"\"\n    The bi-square weight function calculated over values of xx\n\n    Parameters\n    ----------\n    xx: float array\n\n    Notes\n    -----\n    This is the first equation on page 831 of [Cleveland79].\n    \"\"\"\n\n    ans = np.zeros(xx.shape)\n    ans[idx] = (1-xx[idx]**2)**2\n    return ans"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate the matrix used to solve OLS regression.", "response": "def ols_matrix(A, norm_func=None):\n    \"\"\"\n    Generate the matrix used to solve OLS regression.\n\n    Parameters\n    ----------\n\n    A: float array\n        The design matrix\n\n    norm: callable, optional\n        A normalization function to apply to the matrix, before extracting the\n        OLS matrix.\n\n    Notes\n    -----\n\n    The matrix needed for OLS regression for the equation:\n\n    ..math ::\n\n        y = A \\beta\n\n   is given by:\n\n    ..math ::\n\n        \\hat{\\beta} = (A' x A)^{-1} A' y\n\n    See also\n    --------\n    http://en.wikipedia.org/wiki/Ordinary_least_squares#Estimation\n    \"\"\"\n\n    A = np.asarray(A)\n    \n    if norm_func is not None:\n        X = np.matrix(unit_vector(A.copy(), norm_func=norm_func))\n    else:\n        X = np.matrix(A.copy())\n\n    return la.pinv(X.T * X) * X.T"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the l2 norm of an array.", "response": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zero_pad(ts, n_zeros):\n    \n    zeros_shape = ts.shape[:-1] + (n_zeros,)\n    zzs = np.zeros(zeros_shape)\n    # Concatenate along the time-dimension:\n    new_data = np.concatenate((zzs, ts.data, zzs), axis=-1)\n\n    return nts.TimeSeries(new_data, sampling_rate=ts.sampling_rate)", "response": "Pad a nitime. TimeSeries instance with n_zeros before and after the\n    data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef line_broadening(ts, width):\n    # We'll need to broadcast into this many dims:\n    n_dims = len(ts.shape)\n    # We use the information in the TimeSeries.time attribute to get it:\n    win = np.exp(- width * ts.time/np.float(ts.time._conversion_factor))\n    \n    new_data = ts.data * win\n    return nts.TimeSeries(new_data, sampling_rate=ts.sampling_rate)", "response": "This function applies line - broadening to a time - series object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ppm_idx(f_ppm, lb, ub):\n    idx0 = np.argmin(np.abs(f_ppm - lb))\n    idx1 = np.argmin(np.abs(f_ppm - ub))\n    return slice(idx1, idx0)", "response": "Create a slice object corresponding to the frequency bin of the n - th entry in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncorrect the phases of a spectrum by phi radians", "response": "def phase_correct_zero(spec, phi):\n    \"\"\"\n    Correct the phases of a spectrum by phi radians\n\n    Parameters\n    ----------\n    spec : float array of complex dtype\n        The spectrum to be corrected. \n       \n    phi : float\n\n    Returns\n    -------\n    spec : float array\n         The phase corrected spectrum\n\n    Notes\n    -----\n    [Keeler2005] Keeler, J (2005). Understanding NMR Spectroscopy, 2nd\n        edition. Wiley. Page 88.  \n\n    \"\"\"\n    c_factor = np.exp(-1j * phi)\n    # If it's an array, we need to reshape it and broadcast across the\n    # frequency bands in the spectrum. Otherwise, we assume it's a scalar and\n    # apply it to all the dimensions of the spec array:\n    if hasattr(phi, 'shape'):\n        c_factor = c_factor.reshape(c_factor.shape + (1,))\n\n    return spec * c_factor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nphasing correction for the first order spectrum.", "response": "def phase_correct_first(spec, freq, k):\n    \"\"\"\n    First order phase correction.\n\n    Parameters\n    ----------\n    spec : float array\n        The spectrum to be corrected.\n\n    freq : float array\n        The frequency axis.\n\n    k : float\n        The slope of the phase correction as a function of frequency.\n\n    Returns\n    -------\n    The phase-corrected spectrum.\n\n    Notes\n    -----\n    [Keeler2005] Keeler, J (2005). Understanding NMR Spectroscopy, 2nd\n        edition. Wiley. Page 88\n\n    \"\"\"\n    c_factor = np.exp(-1j * k * freq)\n    c_factor = c_factor.reshape((len(spec.shape) -1) * (1,) + c_factor.shape)\n    return spec * c_factor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef two_lorentzian(freq, freq0_1, freq0_2, area1, area2, hwhm1, hwhm2, phase1,\n                   phase2, offset, drift):\n   \"\"\"\n   A two-Lorentzian model.\n\n   This is simply the sum of two lorentzian functions in some part of the\n   spectrum. Each individual Lorentzian has its own peak frequency, area, hwhm\n   and phase, but they share common offset and drift parameters.\n   \n   \"\"\"\n   return (lorentzian(freq, freq0_1, area1, hwhm1, phase1, offset, drift) +\n           lorentzian(freq, freq0_2, area2, hwhm2, phase2, offset, drift))", "response": "A two - Lorentzian model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gaussian(freq, freq0, sigma, amp, offset, drift):\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        return (amp * np.exp(- ((freq - freq0)**2) / (sigma**2) ) +\n                drift * freq + offset)", "response": "A Gaussian function with flexible offset drift and amplitude"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef two_gaussian(freq, freq0_1, freq0_2, sigma1, sigma2, amp1, amp2,\n                   offset, drift):\n   \"\"\"\n   A two-Gaussian model.\n\n   This is simply the sum of two gaussian functions in some part of the\n   spectrum. Each individual gaussian has its own peak frequency, sigma,\n   and amp, but they share common offset and drift parameters.\n\n   \"\"\"\n   return (gaussian(freq, freq0_1, sigma1, amp1, offset, drift) +\n           gaussian(freq, freq0_2, sigma2, amp2, offset, drift))", "response": "A two - Gaussian model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetecting outliers more than X standard deviations from mean.", "response": "def detect_outliers(in_arr, thresh=3.0):\n    \"\"\" \n    Detects outliers more than X standard deviations from mean. \n \n    Parameters \n    ----------   \n    in_list: ndarray\n        An array of measures for which outliers need to be detected. \n \n    thresh: float (optional)\n        Threshold number of standard deviations before a measure is considered\n        an outlier. Default = 3.0\n \n    Returns \n    ------- \n    outlier_idx: ndarray of boolean  \n        An array indicating if a measure is an outlier (True) or not (False). \n    \"\"\"\n\n    mean = np.nanmean(in_arr)\n    std = np.nanstd(in_arr)\n\n    # calculate cutoffs \n    uppthresh = mean + thresh * std\n    lowthresh = mean - thresh * std\n\n    return np.logical_or(in_arr < lowthresh, in_arr > uppthresh)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _compute(self):\n        src_path = self.ctx.src_path\n        if not src_path.exists:\n            return NONE\n        if src_path.is_null:\n            return None\n        try:\n            if self.parse:\n                value = self.parse(src_path)\n            else:\n                value = self._parse(src_path)\n            return value\n        except (SourceError, ValueError), ex:\n            self.ctx.errors.invalid(str(ex))\n            return ERROR", "response": "Compute the value of the src field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _resolve(self):\n        if self.src in (None, NONE):\n            return None\n        return self.ctx(src=self.src)", "response": "Resolves this fields src with ctx. src."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters the value to see if it is in the ignore list.", "response": "def _filter(self, value):\n        \"\"\"\n        Predicate used to exclude, False, or include, True, a computed value.\n        \"\"\"\n        if self.ignores and value in self.ignores:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npredicating used to determine if a computed value is valid True or False.", "response": "def _validate(self, value):\n        \"\"\"\n        Predicate used to determine if a computed value is valid, True, or\n        not, False.\n        \"\"\"\n        if value is None and not self.nullable:\n            self.ctx.errors.invalid('not nullable')\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map(self, value=NONE):\n        with self.ctx(field=self, parent=self):\n            value = self._map(value)\n        if self.attach_parent and value not in IGNORE:\n            if hasattr(self.ctx, 'parent'):\n                value.parent = weakref.proxy(self.ctx.parent)\n            else:\n                value.parent = None\n        return value", "response": "Maps the value from ctx. src to a\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format(self, fmt, **kwargs):\n\n        def compute(self):\n            values = {}\n            try:\n                for name, field in kwargs.iteritems():\n                    values[name] = reduce(getattr, field.split('.'), self.ctx.form)\n            except AttributeError, ex:\n                self.ctx.errors.invalid(str(ex))\n                return ERROR\n            return fmt.format(**values)\n\n        return self.compute.attach(self)(compute)", "response": "Hook to generate a value from a format string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef capture(self, pattern, name=None):\n\n        if isinstance(pattern, basestring):\n            pattern = re.compile(pattern)\n\n        def munge(self, value):\n            match = pattern.match(value)\n            if not match:\n                return NONE\n            for group in [name or self.name, 1]:\n                try:\n                    return match.group(group)\n                except IndexError:\n                    pass\n            return NONE\n\n        return self.munge.attach(self)(munge)", "response": "Hook to capture a value based on a regex."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nestablishes the connections to database and messaging platform and taking into account that it might meen performing asynchronous job.", "response": "def initiate(self, **kwargs):\n        '''Establishes the connections to database and messaging platform,\n        taking into account that it might meen performing asynchronous job.'''\n        run_startup = kwargs.pop('run_startup', True)\n\n        setter = lambda value, name: setattr(self, name, value)\n\n        d = defer.Deferred()\n        d.addCallback(defer.drop_param,\n                      self.agency._messaging.get_connection, self)\n        d.addCallback(setter, \"_messaging\")\n        d.addCallback(defer.drop_param,\n                      self.agency._database.get_connection)\n        d.addCallback(setter, '_database')\n        d.addCallback(defer.drop_param,\n                      self._reload_descriptor)\n        d.addCallback(defer.drop_param,\n                      self._subscribe_for_descriptor_changes)\n        d.addCallback(defer.drop_param, self._store_instance_id)\n        d.addCallback(defer.drop_param, self._load_configuration)\n        d.addCallback(setter, '_configuration')\n        d.addCallback(defer.drop_param,\n                      self.join_shard, self._descriptor.shard)\n        d.addCallback(defer.drop_param,\n                      self.journal_agent_created)\n        d.addCallback(defer.drop_param,\n                      self._call_initiate, **kwargs)\n        d.addCallback(defer.drop_param, self.call_next, self._call_startup,\n                      call_startup=run_startup)\n        d.addCallback(defer.override_result, self)\n        d.addErrback(self._startup_error)\n\n        # Ensure the execution chain is broken\n        self.call_next(d.callback, None)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive snapshot of everything related to the agent", "response": "def snapshot_agent(self):\n        '''Gives snapshot of everything related to the agent'''\n        protocols = [i.get_agent_side() for i in self._protocols.values()]\n        return (self.agent, protocols, )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse by Interest instances.", "response": "def create_binding(self, key, shard=None, public=False,\n                       special_lobby_binding=False):\n        '''Used by Interest instances.'''\n        shard = shard or self.get_shard_id()\n        factory = recipient.Broadcast if public else recipient.Agent\n        recp = factory(key, shard)\n        binding = self._messaging.create_binding(recp)\n        if special_lobby_binding:\n            # this is WeakKeyDictionary\n            self._bindings_preserved_on_shard_change[binding] = True\n        return binding"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _store_instance_id(self):\n        '''\n        Run at the initialization before calling any code at agent-side.\n        Ensures that descriptor holds our value, this effectively creates a\n        lock on the descriptor - if other instance is running somewhere out\n        there it would get the notification update and suicide.\n        '''\n\n        def do_set(desc):\n            desc.instance_id = self._instance_id\n            desc.under_restart = None\n\n        return self.update_descriptor(do_set)", "response": "Store the instance id of the current instance in the descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef initiate(self, database=None, journaler=None, *backends):\n        '''\n        Asynchronous part of agency initialization. Needs to be called before\n        agency is used for anything.\n        '''\n        return self._initiate(database=database, journaler=journaler,\n                              backends=backends)", "response": "Asynchronous part of agency initialization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_host_def(self, hostdef):\n        '''\n        Sets the hostdef param which will get passed to the Host Agent which\n        the agency starts if it becomes the master.\n        '''\n        if self._hostdef is not None:\n            self.info(\"Overwriting previous hostdef, which was %r\",\n                      self._hostdef)\n        self._hostdef = hostdef", "response": "Sets the hostdef param which will get passed to the Host Agent which is passed to the Host Agent which is the master."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_agent(self, desc):\n        '''Gives medium class of the agent if the agency hosts it.'''\n        agent_id = (desc.doc_id\n                    if IDocument.providedBy(desc)\n                    else desc)\n        self.log(\"I'm trying to find the agent with id: %s\", agent_id)\n        result = first(x for x in self._agents\n                       if x._descriptor.doc_id == agent_id)\n        return defer.succeed(result)", "response": "Gives medium class of the agent if the agency hosts it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists agents hosted by the agency.", "response": "def list_agents(self):\n        '''List agents hosted by the agency.'''\n        t = text_helper.Table(fields=(\"Agent ID\", \"Agent class\", \"State\"),\n                              lengths=(40, 25, 15))\n\n        return t.render((a._descriptor.doc_id, a.log_category,\n                         a._get_machine_state().name)\n                        for a in self._agents)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps for reactor. callLater that uses the time scalling. I18N implementation.", "response": "def call_later(_seconds, _f, *args, **kwargs):\n    '''\n    Wrapper for reactor.callLater() aware the time scalling.\n    This method should always be used instead directly touching the reactor.\n    See: L{twisted.internet.interfaces.IDelayedCall.callLater}.\n    '''\n    cur_scale = _get_scale()\n    if cur_scale == 1:\n        return reactor.callLater(_seconds, _f, #@UndefinedVariable\n                                 *args, **kwargs)\n    else:\n        _seconds = _seconds * cur_scale\n        call = reactor.callLater(_seconds, _f, #@UndefinedVariable\n                                 *args, **kwargs)\n        return ScaledDelayedCall(cur_scale, call)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a target component into\n        this object.\n\n        '''\n        self.component_id = node.getAttributeNS(RTS_NS, 'componentId')\n        self.instance_name = node.getAttributeNS(RTS_NS, 'instanceName')\n        for c in node.getElementsByTagNameNS(RTS_EXT_NS, 'Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self", "response": "Parse an xml. dom Node object representing a target component into this object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a target component into this\n        object.\n\n        '''\n        self.component_id = y['componentId']\n        self.instance_name = y['instanceName']\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y.get(RTS_EXT_NS_YAML + 'properties'):\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self", "response": "Parse a YAML specification of a target component into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_xml(self, doc, element):\n        '''Save this target component into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'componentId',\n                               self.component_id)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'instanceName',\n                               self.instance_name)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)", "response": "Save this target component into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        '''Save this target component into a dictionary.'''\n        d = {'componentId': self.component_id,\n                'instanceName': self.instance_name}\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d", "response": "Save this target component into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a target port into this\n        object.\n\n        '''\n        super(TargetPort, self).parse_xml_node(node)\n        self.port_name = node.getAttributeNS(RTS_NS, 'portName')\n        return self", "response": "Parse an xml. dom Node object representing a target port into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a YAML specification of a target port into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a target port into this object.'''\n        super(TargetPort, self).parse_yaml(y)\n        self.port_name = y['portName']\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_xml(self, doc, element):\n        '''Save this target port into an xml.dom.Element object.'''\n        super(TargetPort, self).save_xml(doc, element)\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:target_port_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'portName', self.port_name)", "response": "Save this target port into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n        '''Save this target port into a dictionary.'''\n        d = super(TargetPort, self).to_dict()\n        d['portName'] = self.port_name\n        return d", "response": "Save this target port into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses an xml. dom Node object representing a target execution context into this object.", "response": "def parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a target execution context\n        into this object.\n\n        '''\n        super(TargetExecutionContext, self).parse_xml_node(node)\n        if node.hasAttributeNS(RTS_NS, 'id'):\n            self.id = node.getAttributeNS(RTS_NS, 'id')\n        else:\n            self.id = ''\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a target execution context into this\n        object.\n\n        '''\n        super(TargetExecutionContext, self).parse_yaml(y)\n        if 'id' in y:\n            self.id = y['id']\n        else:\n            self.id = ''\n        return self", "response": "Parse a YAML specification of a target execution context into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave this target execution context into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this target execution context into an xml.dom.Element\n        object.\n\n        '''\n        super(TargetExecutionContext, self).save_xml(doc, element)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'id', self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves this target execution context into a dictionary.", "response": "def to_dict(self):\n        '''Save this target execution context into a dictionary.'''\n        d = super(TargetExecutionContext, self).to_dict()\n        d['id'] = self.id\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorizeClientRequest(self, request):\n        token = ''\n        if self.serverType == 'socket':\n            token = self.getSocketServerToken(request)\n        elif self.serverType == 'http':\n            token = self.getHttpServerToken(request)\n        if token != '' and token != None:\n            if token in self.__tokens:\n                if self.__tokens[token] == 'active':\n                    return True, ()\n                elif self.__tokens[token] == 'revoked':\n                    # token has been revoked\n                    return False, (401, self.errorMessages[401], \"This token has been revoked!\")\n            else:\n                # token is untrusted/invalid\n                return False, (401, self.errorMessages[401], \"\")\n        else:\n            # token is required, but none was provided\n            return False, (400, self.errorMessages[400], \"Authentication required! Client did not provide authentication.\")", "response": "Checks the authorization permissions of the bearer token passed and determines whether the sender is permitted to make the request housed in the payload."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nspawns new agency and return the reference.", "response": "def spawn_agency(self, *components, **kwargs):\n        '''\n        Spawn new agency, returns the reference. Usage:\n        > spawn_agency()\n        Also takes a list of components to switch into production mode.\n        By default all the components work in test mode.\n        Components are the canonical names of interfaces classes used by\n        dependencies (example: flt.agents.hapi.interface.IServerFactory).\n        '''\n        hostdef = kwargs.pop('hostdef', None)\n        ip = kwargs.pop('ip', None)\n        hostname = kwargs.pop('hostname', None)\n        start_host = kwargs.pop('start_host', True)\n        disable_monitoring = kwargs.pop('disable_monitoring', True)\n        if kwargs:\n            raise AttributeError(\"Unexpected kwargs argument %r\" % (kwargs, ))\n\n        ag = agency.Agency()\n        ag.set_host_def(hostdef)\n        self._agencies.append(ag)\n        for canonical_name in components:\n            comp = reflect.named_object(canonical_name)\n            ag.set_mode(comp, ExecMode.production)\n\n        tun_backend = tunneling.EmuBackend(version=self._tunneling_version,\n                                           bridge=self._tunneling_bridge)\n        if disable_monitoring:\n            ag.disable_protocol('setup-monitoring', 'Task')\n\n        counter = getattr(self, '_agency_counter', -1)\n        self._agency_counter = counter + 1\n        queue_name = \"agency_%d\" % (self._agency_counter, )\n        msg = rabbitmq.Client(self._messaging, queue_name)\n        tun = tunneling.Tunneling(tun_backend)\n\n        d = ag.initiate(self._database, self._journaler, self, ip, hostname,\n                        start_host, msg, tun)\n        d.addCallback(defer.override_result, ag)\n        d.addCallback(defer.bridge_param, self.wait_for_idle)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef descriptor_factory(self, type_name, shard=u'lobby', **kwargs):\n        desc = factories.build(type_name, shard=unicode(shard), **kwargs)\n        return self._database_connection.save_document(desc)", "response": "Creates and returns a descriptor for starting the agent later by creating it and saving it to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef breakpoint(self, name):\n        if name not in self._breakpoints:\n            self.warning(\"Reached breakpoint %s but found no \"\n                         \"callback registered\")\n            return\n        cb = self._breakpoints[name]\n        cb.callback(None)\n        return cb", "response": "Register the breakpoint with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_agency(self, agent_id):\n\n        def has_agent(agency):\n            for agent in agency._agents:\n                if agent._descriptor.doc_id == agent_id:\n                    return True\n            return False\n\n        matching = filter(has_agent, self._agencies)\n        if len(matching) > 0:\n            self.debug('Find agency returns %dth agency.',\n                       self._agencies.index(matching[0]))\n            return matching[0]", "response": "Returns the agency running the agent with agent_id or None."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_agent(self, agent_id):\n        try:\n            recp = IRecipient(agent_id)\n            agent_id = recp.key\n        except TypeError:\n            pass\n        agency = self.find_agency(agent_id)\n        if agency:\n            agent = yield agency.find_agent(agent_id)\n            defer.returnValue(agent)", "response": "Return the medium class of the agent with agent_id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef freeze_all(self):\n        '''\n        Stop all activity of the agents running.\n        '''\n        d = defer.succeed(None)\n        for x in self.iter_agents():\n            d.addCallback(defer.drop_param, x._cancel_long_running_protocols)\n            d.addCallback(defer.drop_param, x._cancel_all_delayed_calls)\n            d.addCallback(defer.drop_param, x._kill_all_protocols)\n        return d", "response": "Stop all activity of the agents running."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncleans up all resources and cleans up everything.", "response": "def destroy(self):\n        '''\n        Called from tearDown of simulation tests. Cleans up everything.\n        '''\n        defers = list()\n        for x in self.iter_agents():\n            defers.append(x.terminate_hard())\n        yield defer.DeferredList(defers)\n        yield self._journaler.close()\n        del(self._journaler)\n        del(self._jourwriter)\n        del(self._messaging)\n        del(self._tunneling_bridge)\n        del(self._database)\n        del(self._agencies)\n        del(self._breakpoints)\n        del(self._parser)\n        del(self._output)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getLevelName(level):\n    assert isinstance(level, int) and level > 0 and level < 6, \\\n           TypeError(\"Bad debug level\")\n    return getLevelNames()[level - 1]", "response": "Return the name of a log level."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the integer value of the levelName.", "response": "def getLevelInt(levelName):\n    \"\"\"\n    Return the integer value of the levelName.\n    @param levelName: The string value of the level name\n    @type levelName: str\n    @return: The value of the level name we are interested in.\n    @rtype: int\n    \"\"\"\n    assert isinstance(levelName, str) and levelName in getLevelNames(), \\\n        \"Bad debug level name\"\n    return  getLevelNames().index(levelName)+1"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef registerCategory(category):\n    # parse what level it is set to based on _DEBUG\n    # example: *:2,admin:4\n    global _DEBUG\n    global _levels\n    global _categories\n\n    level = 0\n    chunks = _DEBUG.split(',')\n    for chunk in chunks:\n        if not chunk:\n            continue\n        if ':' in chunk:\n            spec, value = chunk.split(':')\n        else:\n            spec = '*'\n            value = chunk\n\n        # our glob is unix filename style globbing, so cheat with fnmatch\n        # fnmatch.fnmatch didn't work for this, so don't use it\n        if category in fnmatch.filter((category, ), spec):\n            # we have a match, so set level based on string or int\n            if not value:\n                continue\n            try:\n                level = int(value)\n            except ValueError: # e.g. *; we default to most\n                level = 5\n    # store it\n    _categories[category] = level", "response": "Register a given category in the debug system."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the current log settings.", "response": "def setLogSettings(state):\n    \"\"\"Update the current log settings.\n    This can restore an old saved log settings object returned by\n    getLogSettings\n    @param state: the settings to set\n    \"\"\"\n\n    global _DEBUG\n    global _log_handlers\n    global _log_handlers_limited\n\n    (_DEBUG,\n     categories,\n     _log_handlers,\n     _log_handlers_limited) = state\n\n    for category in categories:\n        registerCategory(category)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scrubFilename(filename):\n    '''\n    Scrub the filename to a relative path for all packages in our scrub list.\n    '''\n    global _PACKAGE_SCRUB_LIST\n    for package in _PACKAGE_SCRUB_LIST:\n        i = filename.rfind(package)\n        if i > -1:\n            return filename[i:]\n\n    return filename", "response": "Scrub the filename to a relative path for all packages in our scrub list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getFileLine(where=-1, targetModule=None):\n    co = None\n    lineno = None\n\n    if isinstance(where, types.FunctionType):\n        co = where.func_code\n        lineno = co.co_firstlineno\n    elif isinstance(where, types.MethodType):\n        co = where.im_func.func_code\n        lineno = co.co_firstlineno\n    else:\n        stackFrame = sys._getframe()\n\n        while stackFrame:\n            co = stackFrame.f_code\n            if not co.co_filename in __file__:\n                # wind up the stack according to frame\n                while where < -1:\n                    stackFrame = stackFrame.f_back\n                    where += 1\n                co = stackFrame.f_code\n                lineno = stackFrame.f_lineno\n                break\n            stackFrame = stackFrame.f_back\n\n    if not co:\n        return \"<unknown file>\", 0\n\n    if targetModule:\n        while stackFrame:\n            co = stackFrame.f_code\n            lineno = stackFrame.f_lineno\n            if targetModule in co.co_filename:\n                break\n            stackFrame = stackFrame.f_back\n\n    return scrubFilename(co.co_filename), lineno", "response": "Return the filename and line number for the given location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ellipsize(o):\n    r = repr(o)\n    if len(r) < 800:\n        return r\n\n    r = r[:60] + ' ... ' + r[-15:]\n    return r", "response": "Ellipsize the representation of the given object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getFormatArgs(startFormat, startArgs, endFormat, endArgs, args, kwargs):\n    debugArgs = startArgs[:]\n    for a in args:\n        debugArgs.append(ellipsize(a))\n\n    for items in kwargs.items():\n        debugArgs.extend(items)\n    debugArgs.extend(endArgs)\n    debugFormat = startFormat \\\n              + ', '.join(('%s', ) * len(args)) \\\n              + (kwargs and ', ' or '') \\\n              + ', '.join(('%s=%r', ) * len(kwargs)) \\\n              + endFormat\n    return debugFormat, debugArgs", "response": "Helper function to create a format and args to use for logging."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef errorObject(object, cat, format, *args):\n    doLog(ERROR, object, cat, format, args)\n\n    # we do the import here because having it globally causes weird import\n    # errors if our gstreactor also imports .log, which brings in errors\n    # and pb stuff\n    if args:\n        raise SystemExit(format % args)\n    else:\n        raise SystemExit(format)", "response": "Log an error message in the given category."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef warningObject(object, cat, format, *args):\n    doLog(WARN, object, cat, format, args)", "response": "Log a warning message in the given category."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog an informational message in the given category.", "response": "def infoObject(object, cat, format, *args):\n    \"\"\"\n    Log an informational message in the given category.\n    \"\"\"\n    doLog(INFO, object, cat, format, args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef debugObject(object, cat, format, *args):\n    doLog(DEBUG, object, cat, format, args)", "response": "Log a debug message in the given category."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logObject(object, cat, format, *args):\n    doLog(LOG, object, cat, format, args)", "response": "Log a log message.  Used for debugging recurring events."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite to a file object ignoring errors.", "response": "def safeprintf(file, format, *args):\n    \"\"\"Write to a file object, ignoring errors.\n    \"\"\"\n    try:\n        if args:\n            file.write(format % args)\n        else:\n            file.write(format)\n    except IOError, e:\n        if e.errno == errno.EPIPE:\n            # if our output is closed, exit; e.g. when logging over an\n            # ssh connection and the ssh connection is closed\n            os._exit(os.EX_OSERR)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stderrHandler(level, object, category, file, line, message):\n\n    o = \"\"\n    if object:\n        o = '\"' + object + '\"'\n\n    where = \"(%s:%d)\" % (file, line)\n\n    # level   pid     object   cat      time\n    # 5 + 1 + 7 + 1 + 32 + 1 + 17 + 1 + 15 == 80\n    safeprintf(sys.stderr, '%s [%5d] %-32s %-17s %-15s ',\n               getFormattedLevelName(level), os.getpid(), o, category,\n               time.strftime(\"%b %d %H:%M:%S\"))\n\n    try:\n        safeprintf(sys.stderr, '%-4s %s %s\\n', \"\", message, where)\n    except UnicodeEncodeError:\n        # this can happen if message is a unicode object, convert it back into\n        # a string using the UTF-8 encoding\n        message = message.encode('UTF-8')\n        safeprintf(sys.stderr, '%-4s %s %s\\n', \"\", message, where)\n\n    sys.stderr.flush()", "response": "A log handler that writes to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the logging system and parse the environment variable with the given name.", "response": "def init(envVarName, enableColorOutput=False):\n    \"\"\"\n    Initialize the logging system and parse the environment variable\n    of the given name.\n    Needs to be called before starting the actual application.\n    \"\"\"\n    global _initialized\n\n    if _initialized:\n        return\n\n    global _ENV_VAR_NAME\n    _ENV_VAR_NAME = envVarName\n\n    if enableColorOutput:\n        _preformatLevels(envVarName + \"_NO_COLOR\")\n    else:\n        _preformatLevels(None)\n\n    if envVarName in os.environ:\n        # install a log handler that uses the value of the environment var\n        setDebug(os.environ[envVarName])\n    addLimitedLogHandler(stderrHandler)\n\n    _initialized = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the DEBUG string. This controls the log output.", "response": "def setDebug(string):\n    \"\"\"Set the DEBUG string.  This controls the log output.\"\"\"\n    global _DEBUG\n    global _ENV_VAR_NAME\n    global _categories\n\n    _DEBUG = string\n    debug('log', \"%s set to %s\" % (_ENV_VAR_NAME, _DEBUG))\n\n    # reparse all already registered category levels\n    for category in _categories:\n        registerCategory(category)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a custom log handler.", "response": "def addLogHandler(func):\n    \"\"\"\n    Add a custom log handler.\n\n    @param func: a function object with prototype (level, object, category,\n                 message) where level is either ERROR, WARN, INFO, DEBUG, or\n                 LOG, and the rest of the arguments are strings or None. Use\n                 getLevelName(level) to get a printable name for the log level.\n    @type func:  a callable function\n\n    @raises TypeError: if func is not a callable\n    \"\"\"\n\n    if not callable(func):\n        raise TypeError(\"func must be callable\")\n\n    if func not in _log_handlers:\n        _log_handlers.append(func)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addLimitedLogHandler(func):\n    if not callable(func):\n        raise TypeError(\"func must be callable\")\n\n    if func not in _log_handlers_limited:\n        _log_handlers_limited.append(func)", "response": "Add a custom log handler function to the log handlers list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getExceptionMessage(exception, frame=-1, filename=None):\n    stack = traceback.extract_tb(sys.exc_info()[2])\n    if filename:\n        stack = [f for f in stack if f[0].find(filename) > -1]\n\n    # badly raised exceptions can come without a stack\n    if stack:\n        (filename, line, func, text) = stack[frame]\n    else:\n        (filename, line, func, text) = ('no stack', 0, 'none', '')\n\n    filename = scrubFilename(filename)\n    exc = exception.__class__.__name__\n    msg = \"\"\n    # a shortcut to extract a useful message out of most exceptions\n    # for now\n    if str(exception):\n        msg = \": %s\" % str(exception)\n    return \"exception %(exc)s at %(filename)s:%(line)s: %(func)s()%(msg)s\" \\\n        % locals()", "response": "Return a short message based on an exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reopenOutputFiles():\n    if not _stdout and not _stderr:\n        debug('log', 'told to reopen log files, but log files not set')\n        return\n\n    def reopen(name, fileno, *args):\n        oldmask = os.umask(0026)\n        try:\n            f = open(name, 'a+', *args)\n        finally:\n            os.umask(oldmask)\n\n        os.dup2(f.fileno(), fileno)\n\n    if _stdout:\n        reopen(_stdout, sys.stdout.fileno())\n\n    if _stderr:\n        reopen(_stderr, sys.stderr.fileno(), 0)\n        debug('log', 'opened log %r', _stderr)", "response": "Reopens the stdout and stderr output files as set by\n    L { outputToFiles."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nredirecting stdout and stderr to named files.", "response": "def outputToFiles(stdout=None, stderr=None):\n    \"\"\"\n    Redirect stdout and stderr to named files.\n\n    Records the file names so that a future call to reopenOutputFiles()\n    can open the same files. Installs a SIGHUP handler that will reopen\n    the output files.\n\n    Note that stderr is opened unbuffered, so if it shares a file with\n    stdout then interleaved output may not appear in the order that you\n    expect.\n    \"\"\"\n    global _stdout, _stderr, _old_hup_handler\n    _stdout, _stderr = stdout, stderr\n    reopenOutputFiles()\n\n    def sighup(signum, frame):\n        info('log', \"Received SIGHUP, reopening logs\")\n        reopenOutputFiles()\n        if _old_hup_handler:\n            info('log', \"Calling old SIGHUP hander\")\n            _old_hup_handler(signum, frame)\n\n    try:\n        import signal\n    except ImportError:\n        debug('log', 'POSIX signals not supported, unable to install'\n              ' SIGHUP handler')\n    else:\n        debug('log', 'installing SIGHUP handler')\n        handler = signal.signal(signal.SIGHUP, sighup)\n        if handler == signal.SIG_DFL or handler == signal.SIG_IGN:\n            _old_hup_handler = None\n        else:\n            _old_hup_handler = handler"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getFailureMessage(failure):\n    str(failure.type)\n    failure.getErrorMessage()\n    if len(failure.frames) == 0:\n        return \"failure %(exc)s: %(msg)s\" % locals()\n\n    (func, filename, line, some, other) = failure.frames[-1]\n    filename = scrubFilename(filename)\n    return \"failure %(exc)s at %(filename)s:%(line)s: %(func)s(): %(msg)s\" \\\n        % locals()", "response": "Returns a short message based on the given failure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nintegrating twisted s logger with our logger.", "response": "def logTwisted():\n    \"\"\"\n    Integrate twisted's logger with our logger.\n\n    This is done in a separate method because calling this imports and sets\n    up a reactor.  Since we want basic logging working before choosing a\n    reactor, we need to separate these.\n    \"\"\"\n    global _initializedTwisted\n\n    if _initializedTwisted:\n        return\n\n    debug('log', 'Integrating twisted logger')\n\n    # integrate twisted's logging with us\n    from twisted.python import log as tlog\n\n    # this call imports the reactor\n    # that is why we do this in a separate method\n    from twisted.spread import pb\n\n    # we don't want logs for pb.Error types since they\n    # are specifically raised to be handled on the other side\n    observer = _getTheTwistedLogObserver()\n    observer.ignoreErrors([pb.Error, ])\n    tlog.startLoggingWithObserver(observer.emit, False)\n\n    _initializedTwisted = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adaptStandardLogging(loggerName, logCategory, targetModule):\n    logger = logging.getLogger(loggerName)\n    # if there is already a FluHandler, exit\n    if map(lambda h: isinstance(h, LogHandler), logger.handlers):\n        return\n    logger.setLevel(logLevelToStdLevel(getCategoryLevel(logCategory)))\n    logger.addHandler(LogHandler(logCategory, targetModule))", "response": "Adapt a standard logger through the Flumotion logging system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef writeMarker(self, marker, level):\n        # errorObject specifically raises, so treat it specially\n        if level == ERROR:\n            self.error('%s', marker)\n\n        doLog(level, self.logObjectName(), self.logCategory, '%s', marker)", "response": "Sets a marker that written to the logs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef error(self, *args):\n        if _canShortcutLogging(self.logCategory, ERROR):\n            return\n        errorObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(*args))", "response": "Log an error.  By default this will also raise an exception."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging a warning. Used for non - fatal problems.", "response": "def warning(self, *args):\n        \"\"\"Log a warning.  Used for non-fatal problems.\"\"\"\n        if _canShortcutLogging(self.logCategory, WARN):\n            return\n        warningObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(*args))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef info(self, *args):\n        if _canShortcutLogging(self.logCategory, INFO):\n            return\n        infoObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(*args))", "response": "Log an informational message. Used for normal operation."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs a debug message. Used for debugging.", "response": "def debug(self, *args):\n        \"\"\"Log a debug message.  Used for debugging.\"\"\"\n        if _canShortcutLogging(self.logCategory, DEBUG):\n            return\n        debugObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(*args))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log(self, *args):\n        if _canShortcutLogging(self.logCategory, LOG):\n            return\n        logObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(*args))", "response": "Log a message. Used for debugging recurring events."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef doLog(self, level, where, format, *args, **kwargs):\n        if _canShortcutLogging(self.logCategory, level):\n            return {}\n        args = self.logFunction(*args)\n        return doLog(level, self.logObjectName(), self.logCategory,\n            format, args, where=where, **kwargs)", "response": "Log a message at the given level with the possibility of going to go up in the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warningFailure(self, failure, swallow=True):\n        if _canShortcutLogging(self.logCategory, WARN):\n            if swallow:\n                return\n            return failure\n        warningObject(self.logObjectName(), self.logCategory,\n            *self.logFunction(getFailureMessage(failure)))\n        if not swallow:\n            return failure", "response": "Log a Twisted Failure. Useful as an errback handler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanitize_resources(resource):\n        try:\n            resource[ATTR_HUB_NAME_UNICODE] = base64_to_unicode(resource[ATTR_HUB_NAME])\n            return resource\n        except (KeyError, TypeError):\n            LOGGER.debug(\"no data available\")\n            return None", "response": "Sanitize incoming scene data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json_exception(context, request):\n    request.response.status = context.code\n    return {'error': context._status, 'messages': context.message}", "response": "Always return json content in the body of Exceptions to xhr requests."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getCountLT(self, item):\n        index = bisect.bisect_left(self._list, item)\n        return index", "response": "Return number of elements less than item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getCountGT(self, item):\n        index = bisect.bisect_right(self._list, item)\n        return len(self._list) - index", "response": "Return number of elements greater than item."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef removeLT(self, item):\n        count = self.getCountLT(item)\n        self._list = self._list[count:]\n        return count", "response": "Trim off any elements less than item. Returns the number of elements trimmed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_common(self, wlist):\n        self.com_dict = os.path.join(self.base_dir, 'dicts', 'EN_vocab.txt')\n        with open(self.com_dict) as words_file:\n            data = words_file.read()\n        self.common_words = set(data.splitlines())\n        if wlist:\n            new_words = ''\n            for wl in wlist:\n                with open(wl) as f:\n                    new_words += f.read()\n            if new_words:\n                new_dict = set(data.splitlines())\n                self.common_words.update(new_dict)", "response": "Create the dictionary of common words."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_dale_chall(self):\n        self.dale_chall_dict = os.path.join(self.base_dir, 'dicts', 'dale_chall.txt')\n        with open(self.dale_chall_dict) as words_file:\n            data = words_file.read()\n        self.dale_chall_words = set(data.splitlines())", "response": "Load the dictionary of words and grade dictionary for the Dale - Chall readability test."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pre_check(self, data):\n        sentences = len(re.findall('[\\.!?]+\\W+', data)) or 1\n        chars = len(data) - len(re.findall('[^a-zA-Z0-9]', data))\n        num_words = len(re.findall('\\s+', data))\n        data = re.split('[^a-zA-Z]+', data)\n        return data, sentences, chars, num_words", "response": "Count chars words and sentences in the text."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_check(self, data):\n        if not data:\n            sys.exit(1)\n        data, sentences, chars, num_words = self.pre_check(data)\n        w_dict = Counter(data)\n        uniq_len, uncommon, uncom_len = self.gsl(w_dict)\n        non_dchall_set = Counter({word: count for word, count in w_dict.items()\n            if word and word not in self.dale_chall_words})\n        diff_count = sum(non_dchall_set.values())\n        dc_score = round(self.dale_chall(diff_count, num_words, sentences), 1)\n        cli_score = round(self.coleman_liau(chars, num_words, sentences), 1)\n        return uncommon, uncom_len, uniq_len, dc_score, cli_score", "response": "Check for uncommon words and difficult words in file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate Dale - Chall readability score.", "response": "def dale_chall(self, diff_count, words, sentences):\n        \"\"\"Calculate Dale-Chall readability score.\"\"\"\n        pdw = diff_count / words * 100\n        asl = words / sentences\n        raw = 0.1579 * (pdw) + 0.0496 * asl\n        if pdw > 5:\n            return raw + 3.6365\n        return raw"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_config(data, env):\n    if isinstance(data, list):\n        return [format_config(datum, env) for datum in data]\n    elif isinstance(data, dict):\n        return {\n            format_config(key, env): format_config(value, env)\n            for key, value in data.items()\n        }\n    elif isinstance(data, str):\n        def replace(match):\n            var_name = match.group(1)\n            var = env.get(var_name)\n            assert var, 'Variable %s undefined.' % var_name\n            return var\n        return ENV_PLACEHODLER.sub(replace, data)\n    else:\n        return data", "response": "Format data with given env."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new report.", "response": "def create(cls, scheduled_analysis, tags=None, json_report_objects=None, raw_report_objects=None, additional_metadata=None, analysis_date=None):\n        \"\"\"\n        Create a new report.\n\n        For convenience :func:`~mass_api_client.resources.scheduled_analysis.ScheduledAnalysis.create_report`\n        of class :class:`.ScheduledAnalysis` can be used instead.\n\n        :param scheduled_analysis: The :class:`.ScheduledAnalysis` this report was created for\n        :param tags: A list of strings\n        :param json_report_objects: A dictionary of JSON reports, where the key is the object name.\n        :param raw_report_objects: A dictionary of binary file reports, where the key is the file name.\n        :param analysis_date: A datetime object of the time the report was generated. Defaults to current time.\n        :return: The newly created report object\n        \"\"\"\n        if tags is None:\n            tags = []\n\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        if analysis_date is None:\n            analysis_date = datetime.datetime.now()\n\n        url = cls._creation_point.format(scheduled_analysis=scheduled_analysis.id)\n        return cls._create(url=url, analysis_date=analysis_date, additional_json_files=json_report_objects,\n                           additional_binary_files=raw_report_objects, tags=tags,\n                           additional_metadata=additional_metadata, force_multipart=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a JSON report object of the report.", "response": "def get_json_report_object(self, key):\n        \"\"\"\n        Retrieve a JSON report object of the report.\n\n        :param key: The key of the report object\n        :return: The deserialized JSON report object.\n        \"\"\"\n        con = ConnectionManager().get_connection(self._connection_alias)\n        return con.get_json(self.json_report_objects[key], append_base_url=False)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download_raw_report_object_to_file(self, key, file):\n        con = ConnectionManager().get_connection(self._connection_alias)\n        return con.download_to_file(self.raw_report_objects[key], file, append_base_url=False)", "response": "Download a raw report object and store it in a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_dependencies(module, depth=0, deps=None, seen=None, max_depth=99):\n    deps = {} if not deps else deps\n    seen = set([]) if not seen else seen\n    if not isinstance(module, types.ModuleType) or module in seen or depth > max_depth:\n        return None\n    for name, object in module.__dict__.items():\n        seen.add(module)\n        if not hasattr(object, '__name__'):\n            continue\n        if depth in deps:\n            deps[depth].append((module, name, object))\n        else:\n            deps[depth] = [(module, name, object)]\n\n        find_dependencies(inspect.getmodule(object), depth=depth+1, deps=deps, seen=seen)\n\n    return deps", "response": "Finds all objects in a module that depend on a certain depth truncating cyclic dependencies at the first instance of the module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_modules_importing(dot_path, starting_with):\n    klass = None\n    filtered = []\n\n    if '.' not in dot_path:\n        module_or_method = __import__(dot_path)\n    else:\n        getter, attribute = _get_target(dot_path)\n        module_or_method = getattr(getter(), attribute)\n\n    if isinstance(module_or_method, types.UnboundMethodType):\n        klass = getter()\n        module_or_method = klass\n\n    deps = find_dependencies(inspect.getmodule(starting_with))\n\n    for depth, dependencies in deps.items():\n        for dependency in dependencies:\n            module, name, object = dependency\n            if object == module_or_method:\n                if klass:\n                    filtered.append((module, name, (klass, attribute)))\n                else:\n                    filtered.append((module, name, object))\n\n    return filtered", "response": "Find all the modules importing a particular attribute of a module pointed to by dot_path that starting_with is dependent on."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a side effect if one is defined.", "response": "def execute_side_effect(side_effect=UNDEFINED, args=UNDEFINED, kwargs=UNDEFINED):\n    \"\"\"\n    Executes a side effect if one is defined.\n\n    :param side_effect: The side effect to execute\n    :type side_effect: Mixed. If it's an exception it's raised. If it's callable it's called with teh parameters.\n    :param tuple args: The arguments passed to the stubbed out method\n    :param dict kwargs: The kwargs passed to the subbed out method.\n\n    :rtype: mixed\n    :returns: Whatever the passed side_effect returns\n    :raises: Whatever error is defined as the side_effect\n    \"\"\"\n    if args == UNDEFINED:\n        args = tuple()\n    if kwargs == UNDEFINED:\n        kwargs = {}\n    if isinstance(side_effect, (BaseException, Exception, StandardError)):\n        raise side_effect\n    elif hasattr(side_effect, '__call__'): # If it's callable...\n        return side_effect(*args, **kwargs)\n    else:\n        raise Exception(\"Caliendo doesn't know what to do with your side effect. {0}\".format(side_effect))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_replacement_method(method_to_patch, side_effect=UNDEFINED, rvalue=UNDEFINED, ignore=UNDEFINED, callback=UNDEFINED, context=UNDEFINED, subsequent_rvalue=UNDEFINED):\n    def patch_with(*args, **kwargs):\n        if side_effect != UNDEFINED:\n            return execute_side_effect(side_effect, args, kwargs)\n        if rvalue != UNDEFINED:\n            return rvalue\n\n        return cache(method_to_patch, args=args, kwargs=kwargs, ignore=ignore, call_stack=context.stack, callback=callback, subsequent_rvalue=subsequent_rvalue)\n    return patch_with", "response": "Returns a method that replaces all references to method_to_patch with a new value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a context for a target function.", "response": "def get_context(method):\n    \"\"\"\n    Gets a context for a target function.\n\n    :rtype: caliendo.hooks.Context\n    :returns: The context for the call. Patches are applied and removed within a context.\n    \"\"\"\n    if Context.exists(method):\n        return Context.increment(method)\n    else:\n        return Context(method)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npatch an attribute of a module referenced on import_path with a decorated version that will use the caliendo cache if rvalue is None. Otherwise it will patch the attribute of the module to return rvalue when called. This class provides a context in which to use the patched module. After the decorated method is called patch_in_place unpatches the patched module with the original method. :param str import_path: The import path of the method to patch. :param mixed rvalue: The return value of the patched method. :param mixed side_effect: The side effect to execute. Either a callable with the same parameters as the target, or an exception. :param caliendo.Ignore ignore: Arguments to ignore. The first element should be a list of positional arguments. The second should be a list of keys for keyword arguments. :param function callback: A pickleable callback to execute when the patched method is called and the cache is hit. (has to have been cached the first time). :param caliendo.hooks.Context ctxt: The context this patch should be executed under. Generally reserved for internal use. The vast majority of use cases should leave this parameter alone. :param mixed subsequent_rvalue: If passed; this will be the return value each time this method is run regardless of what is returned when it is initially cached. Caching for this method will be skipped. This is useful when the method returns something unpickleable but we still need to stub it out.", "response": "def patch(import_path, rvalue=UNDEFINED, side_effect=UNDEFINED, ignore=UNDEFINED, callback=UNDEFINED, ctxt=UNDEFINED, subsequent_rvalue=UNDEFINED):\n    \"\"\"\n    Patches an attribute of a module referenced on import_path with a decorated\n    version that will use the caliendo cache if rvalue is None. Otherwise it will\n    patch the attribute of the module to return rvalue when called.\n\n    This class provides a context in which to use the patched module. After the\n    decorated method is called patch_in_place unpatches the patched module with\n    the original method.\n\n    :param str import_path: The import path of the method to patch.\n    :param mixed rvalue: The return value of the patched method.\n    :param mixed side_effect: The side effect to execute. Either a callable with the same parameters as the target, or an exception.\n    :param caliendo.Ignore ignore: Arguments to ignore. The first element should be a list of positional arguments. The second should be a list of keys for keyword arguments.\n    :param function callback: A pickleable callback to execute when the patched method is called and the cache is hit. (has to have been cached the first time).\n    :param caliendo.hooks.Context ctxt: The context this patch should be executed under. Generally reserved for internal use. The vast majority of use cases should leave this parameter alone.\n    :param mixed subsequent_rvalue: If passed; this will be the return value each time this method is run regardless of what is returned when it is initially cached. Caching for this method will be skipped. This is useful when the method returns something unpickleable but we still need to stub it out.\n\n    \"\"\"\n    def patch_test(unpatched_test):\n        \"\"\"\n        Patches a callable dependency of an unpatched test with a callable corresponding to patch_with.\n\n        :param unpatched_test: The unpatched test for which we're patching dependencies\n        :type unpatched_test: instance method of a test suite\n        :param patch_with: A callable to patch the callable dependency with. Should match the function signature of the callable we're patching.\n        :type patch_with: callable\n\n        :returns: The patched test\n        :rtype: instance method\n        \"\"\"\n        if ctxt == UNDEFINED:\n            context = get_context(unpatched_test)\n        else:\n            context = ctxt\n            context.enter()\n\n\n        patched_test = get_patched_test(import_path=import_path,\n                                        unpatched_test=unpatched_test,\n                                        rvalue=rvalue,\n                                        side_effect=side_effect,\n                                        context=context,\n                                        ignore=ignore,\n                                        callback=callback,\n                                        subsequent_rvalue=subsequent_rvalue)\n\n        patched_test.__context = context\n        patched_test.__name__ = context.name\n\n        return patched_test\n    return patch_test"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_recorder(import_path, ctxt):\n    getter, attribute = _get_target(import_path)\n    method_to_patch = getattr(getter(), attribute)\n    def recorder(*args, **kwargs):\n        ctxt.stack.add_hook(Hook(call_descriptor_hash=util.get_current_hash(),\n                                 callback=lambda cd: method_to_patch(*args, **kwargs)))\n        ctxt.stack.skip_once(util.get_current_hash())\n        return method_to_patch(*args, **kwargs)\n    return recorder", "response": "Returns a function that returns a recorder for a particular target given a particular context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replay(import_path):\n    def patch_method(unpatched_method):\n        context = get_context(unpatched_method)\n\n        recorder = get_recorder(import_path, context)\n\n        @patch(import_path, side_effect=recorder, ctxt=context)\n        def patched_method(*args, **kwargs):\n            try:\n                return unpatched_method(*args, **kwargs)\n            finally:\n                context.exit()\n\n        patched_method.__context = context\n        return patched_method\n    return patch_method", "response": "Decorator that makes a method that replays all existing references to the target."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef patch_lazy(import_path, rvalue=UNDEFINED, side_effect=UNDEFINED, ignore=UNDEFINED, callback=UNDEFINED, ctxt=UNDEFINED):\n    def patch_method(unpatched_method):\n        context = get_context(unpatched_method)\n\n        getter, attribute = _get_target(import_path)\n        klass = getter()\n\n        getattr_path = \".\".join(import_path.split('.')[0:-1] + ['__getattr__'])\n\n        def wrapper(wrapped_method, instance, attr):\n            lazy_loaded = wrapped_method.original(instance, attr)\n\n            if attr != attribute:\n                return lazy_loaded\n\n            return get_replacement_method(lazy_loaded,\n                                          side_effect=side_effect,\n                                          rvalue=rvalue,\n                                          ignore=ignore,\n                                          callback=callback,\n                                          context=context)\n\n        @patch(getattr_path, side_effect=WrappedMethod(klass.__getattr__, wrapper), ctxt=context)\n        def patched_method(*args, **kwargs):\n            try:\n                return unpatched_method(*args, **kwargs)\n            finally:\n                context.exit()\n\n        return patched_method\n    return patch_method", "response": "Patches the lazy loaded method at the class definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a request to the server and return the response.", "response": "def send(self, request):\n        \"\"\"\n        Send request to server and return server response.\n        \"\"\"\n        self._logger.debug('Opening connection')\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.connect((self._host, self._port))\n        talk = SocketTalk(sock, encode=self._encode)\n\n        self._logger.debug('Sending action %s' % request.action)\n        if not talk.put(request.action):\n            self._logger.error('Failed to send action %s' % request.action)\n            return None\n\n        if request.key is not None:\n            self._logger.debug('Sending key %s' % request.key)\n            if not talk.put(request.key):\n                self._logger.error('Failed to send key %s' % request.key)\n                return None\n\n        if request.value is not None:\n            self._logger.debug('Sending value')\n            if not talk.put(request.value):\n                self._logger.error('Failed to send value')\n                return None\n\n        self._logger.debug('Receiving status')\n        response = talk.get()\n        if not response:\n            self._logger.error('Failed to receive status')\n            return None\n        self._logger.debug('Status response = %s' % response)\n\n        if request.action in ('get', 'size', 'keys') and response == 'ok':\n            self._logger.debug('Receiving value')\n            response = talk.get()\n            if not response:\n                self._logger.error('Failed to receive value')\n                return None\n\n        if request.action in ('keys',):\n            response = pickle.loads(response)\n\n        self._logger.debug('Closing connection')\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except:\n            self._logger.error('Failed to shutdown')\n        sock.close()\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _send(self, message):\n        result = self._talk.put(message)\n        if not result:\n            self._logger.error('Failed to send \"%s\"' % message)\n        return result", "response": "Send a message to the client."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _receive(self):\n        result = self._talk.get()\n        if not result:\n            self._logger.error('Failed to receive')\n        return result", "response": "Receive a chunk of request from client."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a data port into this\n        object.\n\n        '''\n\n        self.name = node.getAttributeNS(RTS_NS, 'name')\n        self.comment = node.getAttributeNS(RTS_EXT_NS, 'comment')\n        if node.hasAttributeNS(RTS_EXT_NS, 'visible'):\n            visible = node.getAttributeNS(RTS_EXT_NS, 'visible')\n            if visible.lower() == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self", "response": "Parse an xml. dom Node object representing a data port into this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a YAML specification of a data port into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a data port into this object.'''\n        self.name = y['name']\n        if RTS_EXT_NS_YAML + 'comment' in y:\n            self.comment = y[RTS_EXT_NS_YAML + 'comment']\n        if RTS_EXT_NS_YAML + 'visible' in y:\n            visible = y.get(RTS_EXT_NS_YAML + 'visible')\n            if visible == True or visible == 'true' or visible == 'True':\n                self.visible = True\n            else:\n                self.visible = False\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y.get(RTS_EXT_NS_YAML + 'properties'):\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves this service port into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this service port into an xml.dom.Element object.'''\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:serviceport_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'name', self.name)\n        if self.comment:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'comment',\n                                   self.comment)\n        if self.visible != True:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'visible',\n                                   str(self.visible).lower())\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving this service port into a dictionary.", "response": "def to_dict(self):\n        '''Save this service port into a dictionary.'''\n        d = {'name': self.name}\n        if self.visible != True:\n            d[RTS_EXT_NS_YAML + 'visible'] = self.visible\n        if self.comment:\n            d[RTS_EXT_NS_YAML + 'comment'] = self.comment\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef emit_event(project_slug, action_slug, payload, sender_name, sender_secret,\n               event_uuid=None):\n    \"\"\"Emit Event.\n\n    :param project_slug: the slug of the project\n    :param action_slug: the slug of the action\n    :param payload: the payload that emit with action\n    :param sender_name: name that identified the sender\n    :parma sender_secret: secret string\n    :return: dict with task_id and event_uuid\n\n    raise MissingSender if sender does not exist\n    raise WrongSenderSecret if sender_secret is wrong\n    raise NotAllowed if sender is not allowed to emit action to project\n    \"\"\"\n    project_graph = graph.get_project_graph(project_slug)\n\n    project_graph.verify_sender(sender_name, sender_secret)\n    action = project_graph.get_action(action_slug)\n    project = project_graph.project\n\n    # execute event\n    event_uuid = event_uuid or uuid4()\n    event = {'uuid': event_uuid, 'project': project['slug'], 'action': action['slug']}\n\n    res = exec_event(event, action['webhooks'], payload)\n\n    logger.info('EMIT %s \"%s\" \"%s\" %s',\n                 event_uuid, project_slug, action_slug, json.dumps(payload))\n\n    return dict(\n        task=dict(\n            id=res.id,\n        ),\n        event=dict(\n            uuid=event_uuid,\n        ),\n    )", "response": "Emit an event to a node in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _use_methods(cls):\n        use_dict = JobCalculation._use_methods\n        use_dict.update({\n            \"surface_sample\": {\n                'valid_types': SinglefileData,\n                'additional_parameter': None,\n                'linkname': 'surface_sample',\n                'docstring': \"surface sample generated by zeo++\",\n            },\n            \"cell\": {\n                'valid_types': SinglefileData,\n                'additional_parameter': None,\n                'linkname': 'cell',\n                'docstring': \"cell file containing cell vectors\",\n            },\n        })\n        return use_dict", "response": "Add use_* methods for calculations.\n            contains the name of the class that is used by the job calculation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _validate_inputs(self, inputdict):\n        # Check code\n        try:\n            code = inputdict.pop(self.get_linkname('code'))\n        except KeyError:\n            raise InputValidationError(\"No code specified for this \"\n                                       \"calculation\")\n\n        # Check input files\n        try:\n            surface_sample = inputdict.pop(self.get_linkname('surface_sample'))\n            if not isinstance(surface_sample, SinglefileData):\n                raise InputValidationError(\n                    \"surface_sample not of type SinglefileData\")\n        except KeyError:\n            raise InputValidationError(\n                \"No input structure specified for calculation\")\n\n        try:\n            cell = inputdict.pop(self.get_linkname('cell'))\n            if not isinstance(cell, SinglefileData):\n                raise InputValidationError(\"cell not of type SinglefileData\")\n        except KeyError:\n            raise InputValidationError(\n                \"No input structure specified for calculation\")\n\n        # Check that nothing is left unparsed\n        if inputdict:\n            raise ValidationError(\"Unrecognized inputs: {}\".format(inputdict))\n\n        return code, surface_sample, cell", "response": "Validate the input dictionary for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsynthesizes command line parameters e. g. [ struct. vsa struct. cell ]", "response": "def cmdline_params(self, surface_sample_file_name, cell_file_name):\n        \"\"\"Synthesize command line parameters\n\n        e.g. [ ['struct.vsa'], ['struct.cell']]\n        \"\"\"\n        parameters = []\n\n        parameters += [surface_sample_file_name]\n        parameters += [cell_file_name]\n        parameters += [self._OUTPUT_FILE_NAME]\n\n        return map(str, parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ordered_entries(self, queryset=False):\n        if queryset:\n            self.queryset = queryset\n        else:\n            self.queryset = EntryCategory.objects.all()\n        if self.queryset:\n            for category in self.queryset:\n                entries = category.get_entries()\n                if entries:\n                    amount_list = [e.amount_of_views for e in entries]\n                    rating_list = [e.rating() for e in entries]\n                    views_per_entry = fsum(amount_list) / len(amount_list)\n                    rating_per_entry = fsum(rating_list) / len(rating_list)\n                    category.last_rank = views_per_entry * rating_per_entry\n                    category.save()\n                else:\n                    self.queryset = self.queryset.exclude(pk=category.pk)\n            self.queryset = sorted(self.queryset, key=lambda c: c.last_rank,\n                                   reverse=True)\n        return self.queryset", "response": "Custom ordering for the EntryCategory objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_queryset(self):\n        self.queryset = super(EntryCategoryListView, self).get_queryset()\n        return self.get_ordered_entries(self.queryset)", "response": "Customized to get the ordered categories and entries from the Mixin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the correct constant for a given string.", "response": "def from_string(dir_string):\n    '''Returns the correct constant for a given string.\n\n    @raises InvalidDirectionError\n\n    '''\n    dir_string = dir_string.upper()\n    if dir_string == UP:\n        return UP\n    elif dir_string == DOWN:\n        return DOWN\n    elif dir_string == LEFT:\n        return LEFT\n    elif dir_string == RIGHT:\n        return RIGHT\n    else:\n        raise InvalidDirectionError(dir_string)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_string(direction):\n    '''Returns the correct string for a given direction.\n\n    @raises InvalidDirectionError\n\n    '''\n    if direction == UP:\n        return UP\n    elif direction == DOWN:\n        return DOWN\n    elif direction == LEFT:\n        return LEFT\n    elif direction == RIGHT:\n        return RIGHT\n    else:\n        raise InvalidDirectionError(type_string)", "response": "Returns the correct string for a given direction."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts nb_process processes and wait all processes finish.", "response": "def start_in_oneshot_processes(obj, nb_process):\n    \"\"\"\n    Start nb_process processes to do the job. Then process finish the job they die.\n    \"\"\"\n    processes = []\n    for i in range(nb_process):\n        #  Simple process style\n        p = Process(target=oneshot_in_process, args=(obj,))\n        p.start()\n        processes.append(p)\n\n    for process in processes:\n        # Wait all process finish\n        process.join()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start_in_keepedalive_processes(obj, nb_process):\n    processes = []\n    readers_pipes = []\n    writers_pipes = []\n    for i in range(nb_process):\n        # Start process with Pipes for communicate\n        local_read_pipe, local_write_pipe = Pipe(duplex=False)\n        process_read_pipe, process_write_pipe = Pipe(duplex=False)\n        readers_pipes.append(local_read_pipe)\n        writers_pipes.append(process_write_pipe)\n        p = Process(target=run_keepedalive_process, args=(local_write_pipe, process_read_pipe, obj))\n        p.start()\n        processes.append(p)\n    # Send to process some job to do\n    for job in range(3):\n        print('send new job to processes:')\n        for process_number in range(nb_process):\n            # Send data to process\n            writers_pipes[process_number].send(obj)\n            reader_useds = []\n        # Wait response from processes\n        while readers_pipes:\n            for r in wait(readers_pipes):\n                try:\n                    r.recv()\n                except EOFError:\n                    pass\n                finally:\n                    reader_useds.append(r)\n                    readers_pipes.remove(r)\n        readers_pipes = reader_useds\n\n    # Kill processes\n    for writer_pipe in writers_pipes:\n        writer_pipe.send('stop')", "response": "Start nb_process and keep them alive. Send job to all processes in the process pool. Kill all processes in the process pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_keepedalive_process(main_write_pipe, process_read_pipe, obj):\n    while obj != 'stop':\n        oneshot_in_process(obj)\n        # Send to main process \"I've done my job\"\n        main_write_pipe.send('job is done')\n        # Wait for new job to do (this part can be simplified no ?)\n        readers = [process_read_pipe]\n        while readers:\n            for r in wait(readers):\n                try:\n                    obj = r.recv()\n                except EOFError:\n                    pass\n                finally:\n                    readers.remove(r)", "response": "This function runs the keep - alive process."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing result from API.", "response": "def parse_devices(self, json):\n        \"\"\"Parse result from API.\"\"\"\n        result = []\n\n        for json_device in json:\n            license_plate = json_device['EquipmentHeader']['SerialNumber']\n\n            device = Device(self, license_plate)\n            device.update_from_json(json_device)\n            result.append(device)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef full_url(self):\n        if self.needs_auth:\n            netloc = '%s:%s@%s' % (self.username, self.password, self.netloc)\n        else:\n            netloc = self.netloc\n        return urlunparse((\n            self.scheme,\n            netloc,\n            self.path,\n            self.params,\n            self.query,\n            self.fragment,\n        ))", "response": "The full URL including username and password."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fill(self, config, section):\n        if config.has_section(section):\n            default_url = self.DEFAULT_REPOSITORIES.get(self.name, '')\n            self.url = RepositoryURL(config_get(config, section, 'repository', default_url))\n            self.username = config_get(config, section, 'username', '')\n            self.password = config_get(config, section, 'password', '')", "response": "Fill data from a given configuration section."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt the user for login and pass if needed.", "response": "def prompt_auth(self):\n        \"\"\"Prompt the user for login/pass, if needed.\"\"\"\n        if self.username and self.password:\n            return\n        sys.stdout.write(\"Please insert your credentials for %s\\n\" % self.url.base_url)\n        while not self.username:\n            self.username = raw_input(\"Username [%s]: \" % getpass.getuser())\n\n        while not self.password:\n            self.password = getpass.getpass(\"Password: \")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef needs_auth(self):\n        return self.username or self.password or (self.url and self.url.needs_auth)", "response": "Whether this repository needs authentication."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the clean full URL - including username and password.", "response": "def get_clean_url(self):\n        \"\"\"Retrieve the clean, full URL - including username/password.\"\"\"\n        if self.needs_auth:\n            self.prompt_auth()\n        url = RepositoryURL(self.url.full_url)\n        url.username = self.username\n        url.password = self.password\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_config(self):\n        config = configparser.ConfigParser()\n        config.read(self.path)\n        if config.has_section('distutils'):\n            server_names = config.get('distutils', 'index-servers')\n            servers = [name.strip() for name in server_names.split('\\n')]\n            servers = [server for server in servers if server]\n\n            for server in servers:\n                repo_config = RepositoryConfig(server)\n                repo_config.fill(config, server)\n                self.repositories.append(repo_config)\n\n        repo_config = RepositoryConfig('default')\n        repo_config.fill(config, 'server-login')", "response": "Read the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve configuration for a given repository.", "response": "def get_repo_config(self, repo='default'):\n        \"\"\"Retrieve configuration for a given repository.\n\n        Args:\n            repo (str): a repository \"realm\" (alias) or its URL\n\n        Returns:\n            RepositoryConfig: if there is configuration for that repository\n            None: otherwise\n        \"\"\"\n        for repo_config in self.repositories:\n            if repo_config.name == repo or repo_config.url in RepositoryURL(repo):\n                return repo_config\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_template_dirs(type=\"plugin\"):\n    template_dirs = [\n        os.path.expanduser(os.path.join(USER_CONFIG_DIR, \"templates\", type)),\n        os.path.join(\"rapport\", \"templates\", type)  # Local dev tree\n    ]\n    return template_dirs", "response": "Return a list of directories where templates may be located."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _gen_header(self, sequence, payloadtype):\n        protocol = bytearray.fromhex(\"00 34\")\n        source = bytearray.fromhex(\"42 52 4b 52\")\n        target = bytearray.fromhex(\"00 00 00 00 00 00 00 00\")\n        reserved1 = bytearray.fromhex(\"00 00 00 00 00 00\")\n        sequence = pack(\"<B\", sequence)\n        ack = pack(\">B\", 3)\n        reserved2 = bytearray.fromhex(\"00 00 00 00 00 00 00 00\")\n        packet_type = pack(\"<H\", payloadtype)\n        reserved3 = bytearray.fromhex(\"00 00\")\n\n        # assemble header\n        header = bytearray(protocol)\n        header.extend(source)\n        header.extend(target)\n        header.extend(reserved1)\n        header.extend(ack)\n        header.extend(sequence)\n        header.extend(reserved2)\n        header.extend(packet_type)\n        header.extend(reserved3)\n\n        return header", "response": "Generate a packet header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a complete packet.", "response": "def _gen_packet(self, sequence, payloadtype, payload=None):\n        \"\"\" Generate packet header. \"\"\"\n        contents = self._gen_header(sequence, payloadtype)\n\n        # add payload\n        if payload:\n            contents.extend(payload)\n\n        # get packet size\n        size = pack(\"<H\", len(contents) + 2)\n\n        # assemble complete packet\n        packet = bytearray(size)\n        packet.extend(contents)\n\n        return packet"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _gen_packet_setcolor(self, sequence, hue, sat, bri, kel, fade):\n        hue = min(max(hue, HUE_MIN), HUE_MAX)\n        sat = min(max(sat, SATURATION_MIN), SATURATION_MAX)\n        bri = min(max(bri, BRIGHTNESS_MIN), BRIGHTNESS_MAX)\n        kel = min(max(kel, TEMP_MIN), TEMP_MAX)\n\n        reserved1 = pack(\"<B\", 0)\n        hue = pack(\"<H\", hue)\n        saturation = pack(\"<H\", sat)\n        brightness = pack(\"<H\", bri)\n        kelvin = pack(\"<H\", kel)\n        duration = pack(\"<I\", fade)\n\n        # assemble payload\n        payload = bytearray(reserved1)\n        payload.extend(hue)\n        payload.extend(saturation)\n        payload.extend(brightness)\n        payload.extend(kelvin)\n        payload.extend(duration)\n\n        return self._gen_packet(sequence, PayloadType.SETCOLOR, payload)", "response": "Generate \"setcolor\" packet payload."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate \"setpower\" packet payload.", "response": "def _gen_packet_setpower(self, sequence, power, fade):\n        \"\"\" Generate \"setpower\" packet payload. \"\"\"\n        level = pack(\"<H\", Power.BULB_OFF if power == 0 else Power.BULB_ON)\n        duration = pack(\"<I\", fade)\n\n        # assemble payload\n        payload = bytearray(level)\n        payload.extend(duration)\n\n        return self._gen_packet(sequence, PayloadType.SETPOWER2, payload)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck packet for ack.", "response": "def _packet_ack(self, packet, sequence):\n        \"\"\" Check packet for ack. \"\"\"\n        if packet[\"sequence\"] == sequence:\n            if packet[\"payloadtype\"] == PayloadType.SETCOLOR:\n                # notify about colour change\n                self._color_callback(packet[\"target\"],\n                                     packet[\"hue\"],\n                                     packet[\"sat\"],\n                                     packet[\"bri\"],\n                                     packet[\"kel\"])\n\n            elif packet[\"payloadtype\"] == PayloadType.SETPOWER2:\n                # notify about power change\n                self._power_callback(packet[\"target\"],\n                                     packet[\"power\"])\n\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_packet(self, sequence):\n        if self._packets:\n            with self._packet_lock:\n                self._packets[:] = [packet for packet in self._packets\n                                    if self._packet_ack(packet, sequence)]", "response": "Process a single packet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _packet_timeout(self, packet, now):\n        if now >= packet[\"timeout\"]:\n            # timed out\n            return False\n\n        if now >= packet[\"resend\"]:\n            # resend command\n            self._send_command(packet)\n            return False\n\n        # keep packet\n        return True", "response": "Check packet for timeout."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _packet_manager(self):\n        while True:\n            if self._packets:\n                with self._packet_lock:\n                    now = time.time()\n\n                    self._packets[:] = \\\n                        [packet for packet in self._packets\n                         if self._packet_timeout(packet, now)]\n\n            # c.f. nyquist\n            time.sleep(ACK_RESEND / 2)", "response": "Watch packet list for timeouts."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef probe(self, ipaddr=None):\n        if ipaddr is None:\n            # no address so use broadcast\n            ipaddr = self._broadcast_addr\n\n        cmd = {\"payloadtype\": PayloadType.GET,\n               \"target\": ipaddr}\n\n        self._send_command(cmd)", "response": "Probe given address for bulbs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def create_scene(self, room_id, name, color_id=0, icon_id=0):\n        name = unicode_to_base64(name)\n        _data = {\n            \"scene\": {\n                ATTR_ROOM_ID: room_id,\n                ATTR_NAME: name,\n                ATTR_COLOR_ID: color_id,\n                ATTR_ICON_ID: icon_id,\n            }\n        }\n        _response = await self.request.post(self._base_path, data=_data)\n        return _response", "response": "Creates a new empty scene."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remote_trigger_pull(remote_addr, trg_queue, ignore_listener=False,\n                        protocol=u'jsonrpc'):\n    '''Write a non-blocking byte to a remote trigger fifo, to cause a triggered\n       scan'''\n    if protocol == u'jsonrpc':\n        try:\n            server = Server(remote_addr, encoding=_c.FSQ_CHARSET)\n            return server.trigger_pull(queue=trg_queue,\n                                       ignore_listener=ignore_listener,\n                                       trigger=_c.FSQ_TRIGGER)\n        except Exception, e:\n            raise FSQRemoteTriggerError(e)\n\n    raise ValueError('Unknown protocol: {0}'.format(protocol))", "response": "Write a non - blocking byte to a remote trigger fifo to cause a triggered\n       scan"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gotResolverError(self, failure, protocol, message, address):\n        '''\n        Copied from twisted.names.\n        Removes logging the whole failure traceback.\n        '''\n        if failure.check(dns.DomainError, dns.AuthoritativeDomainError):\n            message.rCode = dns.ENAME\n        else:\n            message.rCode = dns.ESERVER\n            log.msg(failure.getErrorMessage())\n\n        self.sendReply(protocol, message, address)\n        if self.verbose:\n            log.msg(\"Lookup failed\")", "response": "Called when a resolver error occurs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handleQuery(self, message, protocol, address):\n        query = message.queries[0]\n        d = self.resolver.query(query, address)\n        d.addCallback(self.gotResolverResponse, protocol, message, address)\n        d.addErrback(self.gotResolverError, protocol, message, address)\n        return d", "response": "Handles a query message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pairwise_longest(iterable, fillvalue=None):\n    \"s -> (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip_longest(a, b, fillvalue=fillvalue)", "response": "s -> s0 s1 s2 s3..."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_full_id(self, state):\n        desc = state.medium.get_descriptor()\n        return desc.doc_id + u\"/\" + unicode(desc.instance_id)", "response": "Return a global unique identifier for this agent instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef substitute_partner(self, state, partners_recp, recp, alloc_id):\n        '''\n        Establish the partnership to recp and, when it is successfull\n        remove partner with recipient partners_recp.\n\n        Use with caution: The partner which we are removing is not notified\n        in any way, so he still keeps link in his description. The correct\n        usage of this method requires calling it from two agents which are\n        divorcing.\n        '''\n        partner = state.partners.find(recipient.IRecipient(partners_recp))\n        if not partner:\n            msg = 'subsitute_partner() did not find the partner %r' %\\\n                  partners_recp\n            self.error(msg)\n            return fiber.fail(partners.FindPartnerError(msg))\n        return self.establish_partnership(recp, partner.allocation_id,\n                                          alloc_id, substitute=partner)", "response": "Substitute the partner with the given recipient."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef breakup(self, state, recp):\n        '''Order the agent to break the partnership with the given\n        recipient'''\n        recp = recipient.IRecipient(recp)\n        partner = self.find_partner(recp)\n        if partner:\n            return state.partners.breakup(partner)\n        else:\n            self.warning('We were trying to break up with agent recp %r.,'\n                         'but apparently he is not our partner!.', recp)", "response": "Order the agent to break the partnership with the given recipient"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the pid from the pid file in the run directory using the given process type and process name for the filename.", "response": "def get_pid(rundir, process_type=PROCESS_TYPE, name=None):\n    \"\"\"\n    Get the pid from the pid file in the run directory, using the given\n    process type and process name for the filename.\n\n    @returns: pid of the process, or None if not running or file not found.\n    \"\"\"\n    pidPath = get_pidpath(rundir, process_type, name)\n    log.log('run', 'pidfile for %s %s is %s' % (process_type, name, pidPath))\n\n    if not os.path.exists(pidPath):\n        return\n\n    pidFile = open(pidPath, 'r')\n    pid = pidFile.readline()\n    pidFile.close()\n    if not pid or int(pid) == 0:\n        return\n\n    return int(pid)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a given process a signal.", "response": "def signal_pid(pid, signum):\n    \"\"\"\n    Send the given process a signal.\n\n    @returns: whether or not the process with the given pid was running\n    \"\"\"\n    try:\n        os.kill(pid, signum)\n        return True\n    except OSError, e:\n        # see man 2 kill\n        if e.errno == errno.EPERM:\n            # exists but belongs to a different user\n            return True\n        if e.errno == errno.ESRCH:\n            # pid does not exist\n            return False\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_pidfile(rundir, process_type=PROCESS_TYPE, name=None):\n    # getting it from the start avoids an unneeded time.sleep\n    pid = get_pid(rundir, process_type, name)\n\n    while not pid:\n        time.sleep(0.1)\n        pid = get_pid(rundir, process_type, name)\n\n    return pid", "response": "Wait for the given process type and name to have started and created a pid file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_for_term():\n\n    class Waiter:\n\n        def __init__(self):\n            self.sleeping = True\n            import signal #@Reimport\n            self.oldhandler = signal.signal(signal.SIGTERM,\n                                            self._SIGTERMHandler)\n\n        def _SIGTERMHandler(self, number, frame):\n            self.sleeping = False\n\n        def sleep(self):\n            while self.sleeping:\n                time.sleep(0.1)\n\n    waiter = Waiter()\n    waiter.sleep()", "response": "Wait until we get killed by a TERM signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pidpath(rundir, process_type, name=None):\n    assert rundir, \"rundir is not configured\"\n    path = os.path.join(rundir, '%s.pid' % process_type)\n    if name:\n        path = os.path.join(rundir, '%s.%s.pid' % (process_type, name))\n    log.log('common', 'get_pidpath for type %s, name %r: %s'\n            % (process_type, name, path))\n    return path", "response": "Get the full path to the pid file for the given process type and name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure the given directory exists creating it if not.", "response": "def _ensure_dir(directory, description):\n    \"\"\"\n    Ensure the given directory exists, creating it if not.\n\n    @raise errors.FatalError: if the directory could not be created.\n    \"\"\"\n    if not os.path.exists(directory):\n        try:\n            os.makedirs(directory)\n        except OSError, e:\n            sys.stderr.write(\"could not create %s directory %s: %s\" % (\n                             description, directory, str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pipe(maxsize=0, *, loop=None) -> Pipe:\n\n    class QueueStream:\n        def __init__(self, maxsize=0, *, loop=None) -> None:\n            self._queue: asyncio.Queue = asyncio.Queue(maxsize, loop=loop)\n            self._eof = asyncio.locks.Event(loop=loop)\n\n        def _check_send(self, value: Any, *, eof: bool) -> None:\n            if self._eof.is_set():\n                raise EOFError(\"Cannot send after EOF\")\n            PipeEnd.check_send_args(value, eof=eof)\n\n        def send_nowait(self, value: Any, *, eof: bool) -> None:\n            self._check_send(value, eof=eof)\n\n            if eof:\n                self._eof.set()\n            else:\n                self._queue.put_nowait(value)\n\n        async def send(self, value: Any, *, eof: bool) -> None:\n            self._check_send(value, eof=eof)\n\n            if eof:\n                self._eof.set()\n            else:\n                await self._queue.put(value)\n\n        async def recv(self) -> Any:\n            get = asyncio.create_task(self._queue.get())\n            eof = asyncio.create_task(self._eof.wait())\n\n            done, pending = await asyncio.wait([get, eof], return_when=asyncio.FIRST_COMPLETED)\n\n            # cancel get or eof, whichever is not finished\n            for task in pending:\n                task.cancel()\n\n            if get in done:\n                return get.result()\n            else:\n                raise EOFError\n\n    class _PipeEnd(PipeEnd):\n        def __init__(self, send: QueueStream, recv: QueueStream) -> None:\n            super().__init__()\n            self._send = send\n            self._recv = recv\n\n        def send_nowait(self, value: Any=PipeEnd._none, *, eof=False):\n            self._send.send_nowait(value, eof=eof)\n\n        async def send(self, value: Any=PipeEnd._none, *, eof=False):\n            await self._send.send(value, eof=eof)\n\n        async def recv(self)-> Any:\n            return await self._recv.recv()\n\n    a, b = QueueStream(maxsize, loop=loop), QueueStream(maxsize, loop=loop)\n    return _PipeEnd(a, b), _PipeEnd(b, a)", "response": "A bidirectional pipe of Python objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def zmq_tcp_pipe_end(ctx, side, *, host=None, port=0, serializer: Optional[Serializer]=None, initialize=True):\n\n        if side == 'a':\n            host = host or '*'\n            result = ZmqPipeEnd(ctx, zmq.ROUTER, f'tcp://{host}', port=port, bind=True, serializer=serializer)\n        elif side == 'b':\n            host = host or '127.0.0.1'\n            if port == 0:\n                raise ValueError(\"b side requires port argument\")\n            result = ZmqPipeEnd(ctx, zmq.DEALER, f'tcp://{host}', port=port, serializer=serializer)\n        else:\n            raise ValueError(\"side must be 'a' or 'b'\")\n\n        if initialize:\n            await result.initialize()\n        return result", "response": "Returns a zmq pipe end that creates a TCP connection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def zmq_ipc_pipe_end(ctx, side, endpoint, *, serializer: Optional[Serializer]=None, initialize=True):\n\n        if side == 'a':\n            result = ZmqPipeEnd(ctx, zmq.ROUTER, endpoint, port=None, bind=True, serializer=serializer)\n        elif side == 'b':\n            result = ZmqPipeEnd(ctx, zmq.DEALER, endpoint, port=None, serializer=serializer)\n        else:\n            raise ValueError(\"side must be 'a' or 'b'\")\n\n        if initialize:\n            await result.initialize()\n        return result", "response": "Returns a ZmqPipeEnd backed by an ipc connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes a DEALER or ROUTER based connection.", "response": "async def initialize(self) -> None:\n            \"\"\"\\\n            Initializes a `DEALER`/`ROUTER` based connection.\n            The DEALER side will send a `[b'']` message;\n            the router side will receive it and store the received identifier for sending messages later.\n            \"\"\"\n\n            if self._socket_type == zmq.ROUTER:\n                self._dealer_ident, _ = await self._sock.recv_multipart()\n            elif self._socket_type == zmq.DEALER:\n                await self._sock.send_multipart([b''])\n            else:\n                raise RuntimeError(\"initialize() not necessary for PAIR sockets\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict - like object containing dataframes of which tests passed and failed for each column.", "response": "def _make_validations(self, table: pd.DataFrame) -> Box:\n        \"\"\"Return a dict-like object containing dataframes of which tests passed/failed for each column.\"\"\"\n        results = []\n\n        for column in self.columns:\n            results.append(column.validate(table))\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(self, table: pd.DataFrame) -> bool:\n        validations = self._make_validations(table=table)\n\n        results = [df.all().all() for df in validations]\n\n        return all(results)", "response": "Return True if all validation tests pass False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef recode(self, table: pd.DataFrame, validate=False) -> pd.DataFrame:\n        df = pd.DataFrame(index=table.index)\n\n        for column in self.columns:\n            df = column.update_dataframe(df, table=table, validate=validate)\n\n        return df", "response": "Return a fully recoded dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform self. recode and add resulting column(s ) to df and return df.", "response": "def update_dataframe(self, df, table, validate=False):\n        \"\"\"Perform ``self.recode`` and add resulting column(s) to ``df`` and return ``df``.\"\"\"\n        df = df.copy()\n        recoded_columns = self.recode(table=table, validate=validate)\n        return pd.concat([df, recoded_columns], axis=1)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dataframe of validation results for the appropriate series vs the vector of validators.", "response": "def validate(self, table: pd.DataFrame, failed_only=False) -> pd.DataFrame:\n        \"\"\"Return a dataframe of validation results for the appropriate series vs the vector of validators.\n\n        Args:\n            table (pd.DataFrame): A dataframe on which to apply validation logic.\n            failed_only (bool): If ``True``: return only the indexes that failed to validate.\n        \"\"\"\n        raise NotImplementedError(\"This method must be defined for each subclass.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npassing the appropriate columns through each recoder function sequentially and return the final result. Args: table (pd.DataFrame): A dataframe on which to apply recoding logic. validate (bool): If ``True``, recoded table must pass validation tests.", "response": "def recode(self, table: pd.DataFrame, validate=False) -> pd.DataFrame:\n        \"\"\"Pass the appropriate columns through each recoder function sequentially and return the final result.\n\n        Args:\n            table (pd.DataFrame): A dataframe on which to apply recoding logic.\n            validate (bool): If ``True``, recoded table must pass validation tests.\n        \"\"\"\n        raise NotImplementedError(\"This method must be defined for each subclass.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a pd. Series of functions with index derived from the function name.", "response": "def _dict_of_funcs(self, funcs: list) -> pd.Series:\n        \"\"\"Return a pd.Series of functions with index derived from the function name.\"\"\"\n        return {func.__name__: func for func in funcs}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _validate_series_dtype(self, series: pd.Series) -> pd.Series:\n        return series.apply(lambda i: isinstance(i, self.dtype))", "response": "Validate that the series data is the correct dtype."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dataframe of validation results for the appropriate series vs the vector of validators.", "response": "def validate(self, table: pd.DataFrame, failed_only=False) -> pd.DataFrame:\n        \"\"\"Return a dataframe of validation results for the appropriate series vs the vector of validators.\n\n        Args:\n            table (pd.DataFrame): A dataframe on which to apply validation logic.\n            failed_only (bool): If ``True``: return only the indexes that failed to validate.\n        \"\"\"\n        series = table[self.name]\n\n        self._check_series_name(series)\n\n        validators = self.validators\n\n        results = pd.DataFrame({validator: series for validator in validators}, index=series.index)\n\n        for name, func in validators.items():\n            results[name] = func(results[name])\n\n        results['dtype'] = self._validate_series_dtype(series)\n\n        if self.unique:\n            results['unique'] = v.funcs.unique(series)\n\n        if failed_only:\n            results = find_failed_rows(results)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses the provided series obj through each recoder function sequentially and return the final result.", "response": "def recode(self, table: pd.DataFrame, validate=False) -> pd.DataFrame:\n        \"\"\"Pass the provided series obj through each recoder function sequentially and return the final result.\n\n        Args:\n            table (pd.DataFrame): A dataframe on which to apply recoding logic.\n            validate (bool): If ``True``, recoded table must pass validation tests.\n        \"\"\"\n        series = table[self.name]\n\n        self._check_series_name(series)\n\n        col = self.name\n\n        data = series.copy()\n\n        for recoder in self.recoders.values():\n            try:\n                data = recoder(data)\n            except (BaseException) as err:\n                raise RecodingError(col, recoder, err)\n\n        if validate:\n            failed_rows = find_failed_rows(self.validate(data.to_frame()))\n            if failed_rows.shape[0] > 0:\n                raise ValidationError(f\"Rows that failed to validate for column '{self.name}':\\n{failed_rows}\")\n\n        return data.to_frame()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _do_validation_set(self, table: pd.DataFrame, columns, validation_type, failed_only=False) -> pd.DataFrame:\n        validations = []\n\n        for column in columns:\n            validation = column.validate(table=table, failed_only=failed_only)\n            validation[\"column_name\"] = column.name\n            validation[\"validation_type\"] = validation_type\n            validations.append(validation)\n\n        validation_table = pd.concat(validations)\n        validation_table.index.name = 'row'\n\n        return validation_table.reset_index().set_index([\"validation_type\", \"column_name\", \"row\"])", "response": "Return a dataframe of validation results for the appropriate series vs the vector of validators."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_input(self, table: pd.DataFrame, failed_only=False) -> pd.DataFrame:\n        return self._do_validation_set(\n            table=table,\n            columns=self.input_columns,\n            validation_type=\"input\",\n            failed_only=failed_only,)", "response": "Return a dataframe of validation results for the appropriate series vs the vector of validators."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self, table: pd.DataFrame, failed_only=False) -> pd.DataFrame:\n        return pd.concat([\n            self._validate_input(table, failed_only=failed_only),\n            self._validate_output(table, failed_only=failed_only),\n        ]).fillna(True)", "response": "Returns a dataframe of validation results for the appropriate series vs the vector of validators."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recode(self, table: pd.DataFrame, validate=False) -> pd.DataFrame:\n        return self._recode_output(self._recode_input(table, validate=validate), validate=validate)", "response": "Recode the given dataframe through each recoder function sequentially and return the final result."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_available_currencies():\n    r = requests.get(API_CURRENCIES)\n    if r.status_code != requests.codes.ok:\n        raise CryptonatorException(\n            (\"An error occurred while getting available currencies \"\n             \"({} from Cryptonator).\").format(r.status_code)\n        )\n\n    return [currency['code'] for currency in r.json()['rows']]", "response": "Return a list of all available Cryptonator currencies."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the base to target exchange rate.", "response": "def get_exchange_rate(base, target, *args, **kwargs):\n    \"\"\"\n    Return the ::base:: to ::target:: exchange rate.\n    Wraps around ::Cryptonator.get_exchange_rate::.\n    \"\"\"\n    return Cryptonator().get_exchange_rate(base, target, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_exchange_rate(self, base, target, raise_errors=True):\n        assert base and target\n\n        base, target = base.lower(), target.lower()\n\n        r = self.session.get(API_SIMPLE_TICKER.format(base, target))\n        if r.status_code != requests.codes.ok:\n            if not raise_errors:\n                return None\n            raise CryptonatorException(\n                (\"An error occurred while getting requested exchange rate \"\n                 \"({} from Cryptonator).\").format(r.status_code)\n            )\n\n        j = r.json()\n        if not j['success'] or j['error']:\n            if not raise_errors:\n                return None\n            raise CryptonatorException(\n                (\"An error occurred while getting requested exchange rate ({}, {})\"\n                 \"('{}').\").format(base, target, j['error'])\n            )\n\n        return float(j['ticker']['price'])", "response": "Get the base to target exchange rate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the base to target exchange rates as a dictionary.", "response": "def get_exchange_rates(self, base, targets=None):\n        \"\"\"Return the ::base:: to ::targets:: exchange rate (as a dictionary).\"\"\"\n        if targets is None:\n            targets = get_available_currencies()\n\n        return {t: self.get_exchange_rate(base, t, raise_errors=False) for t in targets}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nanalyzes given url and return output as JSON.", "response": "def analyzer_api(url):\n    \"\"\"\n    Analyze given `url` and return output as JSON.\n    \"\"\"\n    response.content_type = JSON_MIME\n\n    # handle cacheing\n    ri = get_cached_or_new(url)\n\n    try:\n\n        if ri.is_old():\n            logger.info(\"Running the analysis.\")\n\n            # forget the old one and create new request info - this prevents\n            # conflict errors\n            ri = get_cached_or_new(url, new=True)\n\n            # run the processing\n            ri.paralel_processing()\n\n    except (requests.exceptions.Timeout, requests.ConnectionError) as e:\n        error_msg = \"\"\"\n            Po\u017eadovanou str\u00e1nku {url} nebylo mo\u017en\u00e9 st\u00e1hnout b\u011bhem {timeout}\n            vte\u0159in. Zkuste URL zadat s `www.`, \u010di zkontrolovat funk\u010dnost\n            str\u00e1nek.\n            <span style=\"display: none\">{message}</span>\n        \"\"\"\n        error_msg = error_msg.format(\n            url=url,\n            timeout=REQUEST_TIMEOUT,\n            message=str(e.message)\n        )\n        logger.error(error_msg)\n\n        return {\n            \"status\": False,\n            \"log\": \"\",  # TODO: get real log\n            \"error\": error_msg,\n        }\n    except Exception as e:\n        error_msg = str(e.message) + \"\\n\" + traceback.format_exc().strip()\n        logger.error(error_msg)\n        return {\n            \"status\": False,\n            \"log\": \"ri.get_log()\",\n            \"error\": error_msg,\n        }\n\n    return {\n        \"status\": True,\n        \"body\": ri.to_dict(),\n        \"log\": \"ri.get_log()\",\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_gs_path():\n    path = os.environ.get(\"PATH\", os.defpath)\n\n    for dir in path.split(os.pathsep):\n        for name in (\"gs\", \"gs.exe\", \"gswin32c.exe\"):\n            g = os.path.join(dir, name)\n            if os.path.exists(g):\n                return g\n    raise Exception(\"Ghostscript not found. path=%s\" % str(path))", "response": "Guess where the Ghostscript executable is\n    and return its absolute path name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query_handler(cls, identifier, role=None):\n        '''\n        Lookup the handler for the giving idetifier (descriptor_type) and role.\n        In case it was not found return the default.\n\n        Logic goes as follows:\n         - First try to find exact match for identifier and role,\n         - Try to find match for identifier and role=None,\n         - Return default handler.\n        '''\n        key = cls._key_for(identifier, role)\n        handler = cls._handlers.get(key, None)\n        if handler is None:\n            default_for_identifier = cls._key_for(identifier, None)\n            handler = cls._handlers.get(default_for_identifier,\n                                        cls._handlers['_default'])\n        return handler", "response": "Query the handler for the given identifier and role."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_afi_address_from_bitstream(bitstream, prefix_len=None):\n    '''\n    This function decodes an AFI address from a readable bitstream:\n    >>> from bitstring import ConstBitStream\n\n    This is an example of an IPv4 address:\n    >>> afi_address = '0001c00002ab'.decode('hex')\n    >>> bitstream = ConstBitStream(bytes=afi_address)\n    >>> read_afi_address_from_bitstream(bitstream)\n    IPv4Address(u'192.0.2.171')\n\n    If a prefix length is provided then a prefix is returned:\n    >>> afi_address = '0001c0000200'.decode('hex')\n    >>> bitstream = ConstBitStream(bytes=afi_address)\n    >>> read_afi_address_from_bitstream(bitstream, 24)\n    IPv4Network(u'192.0.2.0/24')\n\n    The function consumes the bits used by the AFI address from the\n    bitstream, but won't read beyond that point:\n    >>> bitstream.pos == bitstream.len\n    True\n    '''\n\n    # Convert to ConstBitStream (if not already provided)\n    if not isinstance(bitstream, ConstBitStream):\n        if isinstance(bitstream, Bits):\n            bitstream = ConstBitStream(auto=bitstream)\n        else:\n            bitstream = ConstBitStream(bytes=bitstream)\n\n    # Read the source EID\n    afi = bitstream.read('uint:16')\n    if afi == Empty:\n        # No address\n        if prefix_len:\n            raise ValueError('Empty AFI addresses can not have prefix_len')\n\n        return None\n\n    elif afi == IPv4:\n        # IPv4 address\n        address_int = bitstream.read('uint:32')\n        address = IPv4Address(address_int)\n        if prefix_len is not None:\n            orig_address = address\n            address = ip_network(address).supernet(new_prefix=prefix_len)\n            if address[0] != orig_address:\n                raise ValueError(\"invalid prefix length %s for %r\"\n                                 % (prefix_len, address))\n\n    elif afi == IPv6:\n        # IPv6 address\n        address_int = bitstream.read('uint:128')\n        address = IPv6Address(address_int)\n        if prefix_len is not None:\n            orig_address = address\n            address = ip_network(address).supernet(new_prefix=prefix_len)\n            if address[0] != orig_address:\n                raise ValueError(\"invalid prefix length %s for %r\"\n                                 % (prefix_len, address))\n\n    elif afi == LCAF:\n        from pylisp.utils.lcaf import LCAFAddress\n        address = LCAFAddress.from_bytes(bitstream, prefix_len)\n\n    else:\n        raise ValueError('Unable to handle AFI {0}'.format(afi))\n\n    return address", "response": "This function decodes an AFI address from a readable bitstream and returns the AFI address as a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the internal state of the object.", "response": "def init(*, output_dir=FS_DEFAULT_OUTPUT_DIR, dry_run=False, **kwargs):\n    \"\"\"\n    Set up output directory\n\n    :param output_dir(str, optional): Output dir for holding temporary files\n    :param \\*\\*kwargs: arbitrary keyword arguments\n    \"\"\"\n    # Output directory\n    global _output_dir\n    _output_dir = output_dir\n\n    # Dry run mode\n    global _dry_run\n    _dry_run = dry_run\n\n    # Type checks\n    utils.chkstr(_output_dir, 'output_dir')\n\n    # log the thing\n    log.msg(\"Output directory will be: {output_dir}\"\n            .format(output_dir=_output_dir))\n\n    # Create output directory if it does not exist\n    if not os.path.exists(_output_dir):\n        log.msg_warn(\"Output path '{out_dir}' does not exist, creating it ...\"\n                     .format(out_dir=_output_dir))\n        if not _dry_run:\n            # create the actual root output directory\n            os.makedirs(_output_dir)\n            # set folder permissions to 0770\n            os.chmod(_output_dir, stat.S_IRWXU | stat.S_IRWXG)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_tmp_dir(prefix):\n\n    # Time in ISO8601 format\n    now = datetime.now().isoformat()\n\n    # A random UUID is appended to the output directory in order to\n    # avoid name collisions\n    f_uuid = uuid.uuid4().hex\n\n    # Directory name and path\n    out_dir = \"{out}/{p}-{now}-{uuid}\".format(out=_output_dir, p=prefix,\n                                              now=now, uuid=f_uuid)\n\n    # create the actual directory\n    if not _dry_run:\n        os.makedirs(out_dir)\n    log.msg_debug(\"Output directory: {out_dir}\".format(out_dir=_output_dir))\n\n    # Return a string containing the name and path of the output directory\n    return out_dir", "response": "Create a temporary directory containing the name and path of the new directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a gzipped tarball from a source directory", "response": "def make_tarball(src_dir):\n    \"\"\"\n    Make gzipped tarball from a source directory\n\n    :param src_dir: source directory\n    :raises TypeError: if src_dir is not str\n    \"\"\"\n    if type(src_dir) != str:\n        raise TypeError('src_dir must be str')\n    output_file = src_dir + \".tar.gz\"\n    log.msg(\"Wrapping tarball '{out}' ...\".format(out=output_file))\n    if not _dry_run:\n        with tarfile.open(output_file, \"w:gz\") as tar:\n            tar.add(src_dir, arcname=os.path.basename(src_dir))\n    return output_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _forecast_transform(f_d):\n    begins = f_d.get('localTimestamp', None)\n    issued = f_d.get('issueTimestamp', None)\n    solid_stars = f_d.get('solidRating', None)\n    faded_stars = f_d.get('fadedRating', None)\n    air_pressure = f_d.get('condition_pressure', None)\n    unit_pressure = f_d.get('condition_unitPressure', None)\n    air_temp = f_d.get('condition_temperature', None)\n    unit_temp = f_d.get('condition_unit', None)\n    max = f_d.get('swell_maxBreakingHeight', None)\n    abs_max = f_d.get('swell_absMaxBreakingHeight', None)\n    min = f_d.get('swell_minBreakingHeight', None)\n    abs_min = f_d.get('swell_absMinBreakingHeight', None)\n    swell_dir = f_d.get('swell_components_combined_compassDirection', None)\n    swell_unit = f_d.get('swell_unit', None)\n    probability = f_d.get('swell_probability', None)\n    period = f_d.get('swell_components_combined_period', None)\n    wind_chill = f_d.get('wind_chill', None)\n    wind_gusts = f_d.get('wind_gusts', None)\n    wind_direction = f_d.get('wind_compassDirection', None)\n    wind_degrees = f_d.get('wind_direction', None)\n    wind_speed = f_d.get('wind_speed', None)\n    wind_unit = f_d.get('wind_unit', None)\n\n    return {\n            'air_pressure': \"{}{}\".format(air_pressure, unit_pressure),\n            'air_temp': \"{}\u00b0 {}\".format(air_temp, unit_temp),\n            'stars': \"{} solid, {} faded\".format(solid_stars, faded_stars),\n            'begins': dt.utcfromtimestamp(begins).strftime(\"%a %-I %p\"),\n            'issued': dt.utcfromtimestamp(issued).strftime(\"%a %-I %p\"),\n            'max_breaking_height': \"{} {}\".format(max, swell_unit),\n            'min_breaking_height': \"{} {}\".format(min, swell_unit),\n            'probability': \"{}%\".format(probability),\n            'swell_direction': \"{}\".format(swell_dir),\n            'swell_period': \"{} seconds\".format(period),\n            'wind_chill': \"{}\u00b0\".format(wind_chill),\n            'wind_direction': \"{}\u00b0 {}\".format(wind_degrees, wind_direction),\n            'wind_gusts': \"{} {}\".format(wind_gusts, wind_unit),\n            'wind_speed': \"{} {}\".format(wind_speed, wind_unit),\n            }", "response": "Get attribute dict from flattened forecast dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting MSW API response.", "response": "def get_msw(requestURL):\n    \"\"\"Get MSW API response.\"\"\"\n    msw_response = requests.get(requestURL)\n    msw_response.raise_for_status()\n\n    json_d = msw_response.json()\n    headers = msw_response.headers\n\n    if ERROR_RESPONSE in json_d:\n        code = json_d.get(ERROR_RESPONE).get('code')\n        msg = json_d.get(ERROR_RESPONE).get('error_msg')\n        raise Exception('API returned error code {}. {}'.format(code, msg))\n    if len(json_d) == 1:\n        return ForecastDataPoint(json_d[0], headers, msw_response)\n    return ForecastDataBlock(json_d, headers, msw_response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_future(self):\n        now = dt.now()\n        four_days = now + timedelta(hours=96)\n        now = now.timestamp()\n        four_days = four_days.timestamp()\n        url = build_url(self.api_key, self.spot_id, self.fields,\n                        self.unit, now, four_days)\n        return get_msw(url)", "response": "Get current and future forecasts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all default forecasts some in past.", "response": "def get_all(self):\n        \"\"\"Get default forecasts, some in past.\"\"\"\n        url = build_url(self.api_key, self.spot_id, self.fields,\n                        self.unit, None, None)\n        return get_msw(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the forecasts for a manually selected time period.", "response": "def get_manual(self, start, end):\n        \"\"\"Get forecasts for a manually selected time period.\"\"\"\n        url = build_url(self.api_key, self.spot_id, self.fields,\n                        self.unit, start, end)\n        return get_msw(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget swell arrow url.", "response": "def get_swell_url(self, swell_type):\n        \"\"\"Get swell arrow url.\"\"\"\n        if swell_type not in SWELL_TYPES:\n            raise ValueError('Invalid swell type: {}'.format(swell_type))\n        key = \"swell_components_{}_direction\".format(swell_type)\n        swell_direction = self.f_d.get(key)\n        if swell_direction is not None:\n            rounded = int(5 * round(float(swell_direction)/5))\n            return SWELL_ARROW_URL.format(rounded)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_wind_url(self):\n        wind_direction = self.f_d.get('wind_direction', None)\n        if wind_direction is not None:\n            rounded = int(5 * round(float(wind_direction)/5))\n            return WIND_ARROW_URL.format(rounded)", "response": "Get wind arrow url."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of a property in the internal mapping.", "response": "def _set_property(self, name, value):\n        \"\"\"\n        Set property `name` to `value`, but only if it is part of the mapping\n        returned from `worker_mapping` (ie - data transported to frontend).\n\n        This method is used from the REST API DB, so it knows what to set and\n        what not, to prevent users from setting internal values.\n\n        Args:\n            name (str): Name of the property to set.\n            value (obj): Any python value.\n\n        Raises:\n            KeyError: If `name` can't be set.\n        \"\"\"\n        if name in worker_mapping().keys():\n            setattr(self, name, value)\n            return\n\n        raise KeyError(\"Can't set `%s`!\" % name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_all_set_properties(self):\n        return set(\n            property_name\n            for property_name in worker_mapping().keys()\n            if getattr(self, property_name) is not None\n        )", "response": "Collect names of all set properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a namedtuple of the number of jobs and their associated properties.", "response": "def progress(self):\n        \"\"\"\n        Get progress.\n\n        Returns:\n            namedtuple: :class:`Progress`.\n        \"\"\"\n        return Progress(\n            done=len(self._get_all_set_properties()),\n            base=len(worker_mapping()),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nis the object cached for too long so it should be redownloaded?", "response": "def is_old(self):\n        \"\"\"\n        Is the object cached for too long, so it should be redownloaded?\n\n        See :attr:`.DB_MAX_WAIT_TIME` and :attr:`.DB_CACHE_TIME` for details.\n\n        Returns:\n            bool: True if it is.\n        \"\"\"\n        if not self.processing_started_ts:\n            return True\n\n        if self.processing_ended_ts:\n            return self.processing_ended_ts + DB_CACHE_TIME < time.time()\n\n        # in case that processing started, but didn't ended in\n        # DB_MAX_WAIT_TIME\n        expected_end_ts = self.creation_ts + DB_MAX_WAIT_TIME\n        if expected_end_ts < time.time():\n            logger.error(\"Prosessing timeouted and properites were not set!\")\n\n        return expected_end_ts < time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a location into this\n        object.\n\n        '''\n        self.x = int(node.getAttributeNS(RTS_EXT_NS, 'x'))\n        self.y = int(node.getAttributeNS(RTS_EXT_NS, 'y'))\n        self.height = int(node.getAttributeNS(RTS_EXT_NS, 'height'))\n        self.width = int(node.getAttributeNS(RTS_EXT_NS, 'width'))\n        self.direction = dir.from_string(node.getAttributeNS(RTS_EXT_NS,\n                'direction'))\n        return self", "response": "Parse an xml. dom Node object representing a location into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a YAML specification of a location into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a location into this object.'''\n        self.x = int(y['x'])\n        self.y = int(y['y'])\n        self.height = int(y['height'])\n        self.width = int(y['width'])\n        self.direction = dir.from_string(y['direction'])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave this location into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this location into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'x', str(self.x))\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'y', str(self.y))\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'height',\n                               str(self.height))\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'width',\n                               str(self.width))\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'direction',\n                               dir.to_string(self.direction).lower())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        '''Save this location into a dictionary.'''\n        return {'x': self.x,\n                'y': self.y,\n                'height': self.height,\n                'width': self.width,\n                'direction': dir.to_string(self.direction)}", "response": "Save this location into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a configuration set in the component by its ID.", "response": "def get_configuration_set_by_id(self, id):\n        '''Finds a configuration set in the component by its ID.\n\n        @param id The ID of the configuration set to search for.\n        @return The ConfigurationSet object for the set, or None if it was not\n        found.\n\n        '''\n        for cs in self.configuration_sets:\n            if cs.id == id:\n                return cs\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses an xml. dom Node object representing a component into this object.", "response": "def parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a component into this\n        object.\n\n        >>> c = Component()\n        '''\n        self._reset()\n        # Get the attributes\n        self.id = node.getAttributeNS(RTS_NS, 'id')\n        self.path_uri = node.getAttributeNS(RTS_NS, 'pathUri')\n        if node.hasAttributeNS(RTS_NS, 'activeConfigurationSet'):\n            self.active_configuration_set = node.getAttributeNS(RTS_NS,\n                    'activeConfigurationSet')\n        else:\n            self.active_configuration_set = ''\n        self.instance_name = node.getAttributeNS(RTS_NS, 'instanceName')\n        self.compositeType = comp_type.from_string(node.getAttributeNS(RTS_NS,\n                'compositeType'))\n        required = node.getAttributeNS(RTS_NS, 'isRequired')\n        if required == 'true' or required == '1':\n            self.is_required = True\n        else:\n            self.is_required = False\n        self.comment = node.getAttributeNS(RTS_EXT_NS, 'comment')\n        if node.hasAttributeNS(RTS_EXT_NS, 'visible'):\n            visible = node.getAttributeNS(RTS_EXT_NS, 'visible')\n            if visible.lower() == 'true' or visible == '1':\n                self.visible = True\n            else:\n                self.visible = False\n\n        # Get the children\n        for c in node.getElementsByTagNameNS(RTS_NS, 'DataPorts'):\n            self._data_ports.append(DataPort().parse_xml_node(c))\n        for c in node.getElementsByTagNameNS(RTS_NS, 'ServicePorts'):\n            self._service_ports.append(ServicePort().parse_xml_node(c))\n        for c in node.getElementsByTagNameNS(RTS_NS, 'ConfigurationSets'):\n            self._config_sets.append(ConfigurationSet().parse_xml_node(c))\n        for c in node.getElementsByTagNameNS(RTS_NS, 'ExecutionContexts'):\n            self._exec_contexts.append(ExecutionContext().parse_xml_node(c))\n        for c in node.getElementsByTagNameNS(RTS_NS, 'Participants'):\n            self._participants.append(Participant().parse_xml_node(c))\n        # Extended profile children\n        c = node.getElementsByTagNameNS(RTS_EXT_NS, 'Location')\n        if c.length > 0:\n            if c.length > 1:\n                raise InvalidRtsProfileNodeError('Location')\n            self._location = Location().parse_xml_node(c[0])\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_xml(self, doc, element):\n        '''Save this component into an xml.dom.Element object.'''\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:component_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'id', self.id)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'pathUri', self.path_uri)\n        if self.active_configuration_set:\n            element.setAttributeNS(RTS_NS, RTS_NS_S + 'activeConfigurationSet',\n                                   self.active_configuration_set)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'instanceName',\n                               self.instance_name)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'compositeType',\n                               comp_type.to_string(self.composite_type))\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'isRequired',\n                               str(self.is_required).lower())\n        if self.comment:\n            element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'comment',\n                                   self.comment)\n        element.setAttributeNS(RTS_EXT_NS, RTS_EXT_NS_S + 'visible',\n                               str(self.visible).lower())\n        for port in self.data_ports:\n            new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'DataPorts')\n            port.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        for port in self.service_ports:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'ServicePorts')\n            port.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        for cs in self.configuration_sets:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'ConfigurationSets')\n            cs.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        for ec in self.execution_contexts:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'ExecutionContexts')\n            ec.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        for p in self.participants:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'Participants')\n            p.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        new_element = doc.createElementNS(RTS_EXT_NS,\n                                          RTS_EXT_NS_S + 'Location')\n        self._location.save_xml(doc, new_element)\n        element.appendChild(new_element)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)", "response": "Save this component into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a YAML specification of a component into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML specification of a component into this object.'''\n        self._reset()\n        self.id = y['id']\n        self.path_uri = y['pathUri']\n        if 'activeConfigurationSet' in y:\n            self.active_configuration_set = y['activeConfigurationSet']\n        else:\n            self.active_configuration_set = ''\n        self.instance_name = y['instanceName']\n        self.compositeType = comp_type.from_string(y['compositeType'])\n        required = y['isRequired']\n        if required == True or required == 'true' or required == '1':\n            self.is_required = True\n        else:\n            self.is_required = False\n        if RTS_EXT_NS_YAML + 'comment' in y:\n            self.comment = y[RTS_EXT_NS_YAML + 'comment']\n        self.visible = False\n        if RTS_EXT_NS_YAML + 'visible' in y:\n            visible = y.get(RTS_EXT_NS_YAML + 'visible')\n            if visible == True or visible == 'true' or visible == 'True':\n                self.visible = True\n\n        # Get the children\n        if 'dataPorts' in y:\n            for p in y.get('dataPorts'):\n                self._data_ports.append(DataPort().parse_yaml(p))\n        if 'servicePorts' in y:\n            for p in y.get('servicePorts'):\n                self._service_ports.append(ServicePort().parse_yaml(p))\n        if 'configurationSets' in y:\n            for p in y.get('configurationSets'):\n                self._config_sets.append(ConfigurationSet().parse_yaml(p))\n        if 'executionContexts' in y:\n            for p in y.get('executionContexts'):\n                self._exec_contexts.append(ExecutionContext().parse_yaml(p))\n        if 'participants' in y:\n            for p in y.get('participants'):\n                self._participants.append(Participant().parse_yaml(p))\n\n        # Extended profile children\n        if RTS_EXT_NS_YAML + 'location' in y:\n            l = y[RTS_EXT_NS_YAML + 'location']\n            self._location = Location().parse_yaml(l)\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y.get(RTS_EXT_NS_YAML + 'properties'):\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _calc_auc(self, model, params, idx):\n        # Here's what we are going to do: For each transient, we generate\n        # the spectrum for two distinct sets of parameters: one is exactly as\n        # fit to the data, the other is the same expect with amplitude set to\n        # 0. To calculate AUC, we take the difference between them:\n        auc = np.zeros(params.shape[0])\n        delta_f = np.abs(self.f_ppm[1]-self.f_ppm[0])\n        p = np.copy(params)\n        for t in range(auc.shape[0]):\n            model1 = model(self.f_ppm[idx], *p[t])\n            # This controls the amplitude in both the Gaussian and the\n            # Lorentzian: \n            p[t, 1] = 0\n            model0 = model(self.f_ppm[idx], *p[t])\n            auc[t] = np.sum((model1 - model0) * delta_f)\n        return auc", "response": "Calculates the area under the curve of a model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fit_creatine(self, reject_outliers=3.0, fit_lb=2.7, fit_ub=3.5):\n        # We fit a two-lorentz function to this entire chunk of the spectrum,\n        # to catch both choline and creatine\n        model, signal, params = ana.fit_two_lorentzian(self.sum_spectra,\n                                                       self.f_ppm,\n                                                       lb=fit_lb,\n                                                       ub=fit_ub)\n\n        # Use an array of ones to index everything but the outliers and nans:\n        ii = np.ones(signal.shape[0], dtype=bool)\n        # Reject outliers:\n        if reject_outliers:\n            model, signal, params, ii = self._outlier_rejection(params,\n                                                                model,\n                                                                signal,\n                                                                ii)\n            \n        # We'll keep around a private attribute to tell us which transients\n        # were good (this is for both creatine and choline):\n        self._cr_transients = np.where(ii)\n        \n        # Now we separate choline and creatine params from each other (remember\n        # that they both share offset and drift!):\n        self.choline_params = params[:, (0,2,4,6,8,9)]\n        self.creatine_params = params[:, (1,3,5,7,8,9)]\n        \n        self.cr_idx = ut.make_idx(self.f_ppm, fit_lb, fit_ub)\n\n        # We'll need to generate the model predictions from these parameters,\n        # because what we're holding in 'model' is for both together:\n        self.choline_model = np.zeros((self.creatine_params.shape[0],\n                                    np.abs(self.cr_idx.stop-self.cr_idx.start)))\n\n        self.creatine_model = np.zeros((self.choline_params.shape[0],\n                                    np.abs(self.cr_idx.stop-self.cr_idx.start)))\n        \n        for idx in range(self.creatine_params.shape[0]):\n            self.creatine_model[idx] = ut.lorentzian(self.f_ppm[self.cr_idx],\n                                                     *self.creatine_params[idx])\n            self.choline_model[idx] = ut.lorentzian(self.f_ppm[self.cr_idx],\n                                                    *self.choline_params[idx])\n        self.creatine_signal = signal\n        self.creatine_auc = self._calc_auc(ut.lorentzian,\n                                           self.creatine_params,\n                                           self.cr_idx)\n        self.choline_auc = self._calc_auc(ut.lorentzian,\n                                          self.choline_params,\n                                          self.cr_idx)", "response": "Fit a model to the portion of the summed spectra containing the creatine peak and choline signals."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _xval_choose_funcs(self, fit_spectra, reject_outliers, fit_lb, fit_ub,\n                           fitters=[ana.fit_gaussian,ana.fit_two_gaussian],\n                           funcs = [ut.gaussian, ut.two_gaussian]):\n        \"\"\" Helper function used to do split-half xvalidation to select among\n            alternative models\"\"\"\n\n        set1 = fit_spectra[::2]\n        set2 = fit_spectra[1::2]\n\n        errs = []\n        signal_select = [] \n        # We can loop over functions and try each one out, checking the\n        # error in each:\n        for fitter in fitters:\n            models = []\n            signals = []\n            for this_set in [set1, set2]:\n                choose_transients, model, signal, params, this_idx =\\\n                    self._fit_helper(this_set, reject_outliers,\n                                    fit_lb, fit_ub, fitter)\n                models.append(np.nanmean(model[choose_transients], 0))\n                signals.append(np.nanmean(signal[choose_transients], 0))\n\n                signal_select.append(signal[choose_transients])\n                \n            #Cross-validate!\n            errs.append(np.mean([ut.rmse(models[0], signals[1]),\n                                 ut.rmse(models[1], signals[0])]))\n        # We really only need to look at the first two:\n        signal_err = ut.rmse(np.nanmean(signal_select[0], 0),\n                             np.nanmean(signal_select[1], 0))\n        # Based on the errors, choose a function. Also report errors:\n        return (fitters[np.argmin(errs)], funcs[np.argmin(errs)], np.min(errs),\n                signal_err)", "response": "Helper function used to do split - half xvalidation to choose a function from a set of fitters and a set of functions to use."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _xval_model_error(self, fit_spectra, reject_outliers, fit_lb, fit_ub,\n                           fitter, func):\n        \"\"\"\n        Helper function for calculation of split-half cross-validation model\n        error and signal reliability.\n\n        \"\"\"\n        set1 = fit_spectra[::2]\n        set2 = fit_spectra[1::2]\n        errs = []\n        signal_select = [] \n        models = []\n        signals = []\n        for this_set in [set1, set2]:\n            choose_transients, model, signal, params, this_idx =\\\n                self._fit_helper(this_set, reject_outliers,\n                                 fit_lb, fit_ub, fitter)\n            models.append(np.nanmean(model[choose_transients], 0))\n            signals.append(np.nanmean(signal[choose_transients], 0))\n\n            signal_select.append(signal[choose_transients])\n                \n        #Cross-validation error estimation:\n        model_err = np.mean([ut.rmse(models[0], signals[1]),\n                              ut.rmse(models[1], signals[0])])\n        # Also for the signal:\n        signal_err = ut.rmse(np.nanmean(signal_select[0], 0),\n                             np.nanmean(signal_select[1], 0))\n        # Based on the errors, choose a function. Also report errors:\n        return model_err, signal_err", "response": "Helper function for calculation of split - half cross - validation model error and signal reliability."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fit_gaba(self, reject_outliers=3.0, fit_lb=2.8, fit_ub=3.4,\n                 phase_correct=True, fit_func=None):\n        \"\"\"\n        Fit either a single Gaussian, or a two-Gaussian to the GABA 3 PPM\n        peak.\n\n        Parameters\n        ----------\n        reject_outliers : float\n            Z-score criterion for rejection of outliers, based on their model\n            parameter\n\n        fit_lb, fit_ub : float\n            Frequency bounds (in ppm) for the region of the spectrum to be\n            fit.\n\n        phase_correct : bool\n            Where to perform zero-order phase correction based on the fit of\n            the creatine peaks in the sum spectra\n\n        fit_func : None or callable (default None).\n            If this is set to `False`, an automatic selection will take place,\n            choosing between a two-Gaussian and a single Gaussian, based on a\n            split-half cross-validation procedure. Otherwise, the requested\n            callable function will be fit. Needs to conform to the conventions\n            of `fit_gaussian`/`fit_two_gaussian` and\n            `ut.gaussian`/`ut.two_gaussian`.\n\n        \"\"\"\n        # We need to fit the creatine, so that we know which transients to\n        # exclude in fitting this peak:\n        if not hasattr(self, 'creatine_params'):\n            self.fit_creatine()\n\n        fit_spectra = np.ones(self.diff_spectra.shape) * np.nan\n        # Silence warnings:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            fit_spectra =\\\n                self.diff_spectra[self._cr_transients].copy()\n\n        if phase_correct:\n            for ii, this_spec in enumerate(fit_spectra):\n                # Silence warnings:\n                with warnings.catch_warnings():\n                    warnings.simplefilter(\"ignore\")\n                    fit_spectra[ii] = ut.phase_correct_zero(this_spec,\n                            self.creatine_params[self._cr_transients][ii, 3])\n\n        if fit_func is None:\n            # Cross-validate!\n            fitter, self.gaba_func, self.gaba_model_err, self.gaba_signal_err=\\\n                self._xval_choose_funcs(fit_spectra,\n                                        reject_outliers,\n                                        fit_lb, fit_ub)\n        # Otherwise, you had better supply a couple of callables that can be\n        # used to fit these spectra!\n        else:\n            fitter = fit_func[0]\n            self.gaba_func = fit_func[1]\n            self.gaba_model_err, self.gaba_signal_err = \\\n                self._xval_model_error(fit_spectra, reject_outliers,\n                                       fit_lb, fit_ub, fitter, self.gaba_func)\n        # Either way, we end up fitting to everything in the end: \n        choose_transients, model, signal, params, this_idx = self._fit_helper(\n                                         fit_spectra, reject_outliers,\n                                         fit_lb, fit_ub, fitter)\n\n        self._gaba_transients = choose_transients\n        self.gaba_model = model\n        self.gaba_signal = signal\n        self.gaba_params = params\n        self.gaba_idx = this_idx\n        mean_params = stats.nanmean(params, 0)\n\n        self.gaba_auc =  self._calc_auc(self.gaba_func, params, self.gaba_idx)", "response": "Fit the GABA 3 PPM to the GABA 3 PPM."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit_glx(self, reject_outliers=3.0, fit_lb=3.6, fit_ub=3.9,\n                fit_func=None):\n        \"\"\"\n        Fit a Gaussian function to the Glu/Gln (GLX) peak at 3.75ppm, +/-\n        0.15ppm [Hurd2004]_.  Compare this model to a model\n        that treats the Glx signal as two gaussian peaks.  Glx signal\n        at. Select between them based on cross-validation\n\n        Parameters\n        ----------\n        reject_outliers : float or bool\n           If set to a float, this is the z score threshold for rejection (on\n           any of the parameters). If set to False, no outlier rejection\n\n        fit_lb, fit_ub : float\n           What part of the spectrum (in ppm) contains the GLX peak.\n           Default (3.5, 4.5)\n\n        scalefit : boolean\n           If this is set to true, attempt is made to tighten the fit to the\n           peak with a second round of fitting where the fitted curve\n           is fit with a scale factor. (default false)\n\n        References\n        ----------\n        .. [Hurd2004] 2004, Measurement of brain glutamate using TE-averaged\n        PRESS at 3T\n\n        \"\"\"\n        # Use everything:\n        fit_spectra = self.diff_spectra.copy()\n\n        if fit_func is None:\n            # Cross-validate!\n            fitter, self.glx_func, self.glx_model_err, self.glx_signal_err=\\\n                self._xval_choose_funcs(fit_spectra,\n                                        reject_outliers,\n                                        fit_lb, fit_ub)\n        # Otherwise, you had better supply a couple of callables that can be\n        # used to fit these spectra!\n        else:\n            fitter = fit_func[0]\n            self.glx_func = fit_func[1]\n            self.glx_model_err, self.glx_signal_err = \\\n                self._xval_model_error(fit_spectra, reject_outliers,\n                                       fit_lb, fit_ub, fitter, self.glx_func)\n\n        # Do it!\n        choose_transients, model, signal, params, this_idx = self._fit_helper(\n                                         fit_spectra, reject_outliers,\n                                         fit_lb, fit_ub, fitter)\n\n        self._glx_transients = choose_transients\n        self.glx_model = model\n        self.glx_signal = signal\n        self.glx_params = params\n        self.glx_idx = this_idx\n        mean_params = stats.nanmean(params, 0)\n\n        self.glx_auc =  self._calc_auc(self.glx_func, params, self.glx_idx)", "response": "Fit a Gaussian function to the Glu - Gln GLX peak at 3. 75ppm + / - 3. 15ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 9ppm + / - 3. 0. 0."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit_naa(self, reject_outliers=3.0, fit_lb=1.8, fit_ub=2.4,\n                 phase_correct=True):\n        \"\"\"\n        Fit a Lorentzian function to the NAA peak at ~ 2 ppm.  Example of\n        fitting inverted peak: Foerster et al. 2013, An imbalance between\n        excitatory and inhibitory neurotransmitters in amyothrophic lateral\n        sclerosis revealed by use of 3T proton MRS\n        \"\"\"\n        model, signal, params = ana.fit_lorentzian(self.diff_spectra,\n                                                   self.f_ppm,\n                                                   lb=fit_lb,\n                                                   ub=fit_ub)\n\n        # Store the params:\n        self.naa_model = model\n        self.naa_signal = signal\n        self.naa_params = params\n        self.naa_idx = ut.make_idx(self.f_ppm, fit_lb, fit_ub)\n        mean_params = stats.nanmean(params, 0)\n        self.naa_auc = self._calc_auc(ut.lorentzian, params, self.naa_idx)", "response": "Fit a Lorentzian function to the NAA peak at ~ 2 ppm."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef est_gaba_conc(self):\n        # need gaba_auc and creatine_auc\n        if not hasattr(self, 'gaba_params'):\n            self.fit_gaba()\n\n        # estimate [GABA] according to equation9\n        gaba_conc_est = self.gaba_auc / self.creatine_auc * 1.5 * 9.0\n        \n        self.gaba_conc_est = gaba_conc_est", "response": "Estimate gaba concentration based on equation 9. 0. 1. 1."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef voxel_seg(self, segfile, MRSfile):\n        total, grey, white, csf, nongmwm, pGrey, pWhite, pCSF, pNongmwm =\\\n            fs.MRSvoxelStats(segfile, MRSfile)\n        \n        self.pGrey = pGrey\n        self.pWhite = pWhite\n        self.pCSF = pCSF\n        self.pNongmwm = pNongmwm", "response": "This function is used to add voxel segmentation info to the internal dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the task. Called from initiate.", "response": "def _init(self, state, initiate_arg):\n        '''\n        Set initial state of the task. Called from initiate.\n        @param initiate_arg: either the PartnerClass object (StartTask)\n                             or an agent_id (RestartTask)\n        '''\n        state.descriptor = None\n        state.hosts = state.agent.query_partners('hosts')\n        state.current_index = -1\n\n        self.log('%s task initiated, will be trying to start a '\n                 '%r on one of the hosts: %r', str(self.__class__.__name__),\n                 initiate_arg, state.hosts)\n        if len(state.hosts) == 0:\n            # FIXME: Here would be a good idea to put an alert\n            return self._fail('Shard Agent cannot start partner %r as it has '\n                              'no Host Partners!' % (initiate_arg, ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if variable is defined in the context.", "response": "def ifdef(parser, token):\n    \"\"\"\n    Check if variable is defined in the context.\n\n    Similar to django.template.defaulttags.do_if.\n    \"\"\"\n    block_tokens = ('elifdef', 'else', 'endifdef')\n    # {% ifdef ... %}\n    bits = token.split_contents()[1:]\n    if len(bits) > 1:\n        raise TemplateSyntaxError('%r is not an identifier.' % token)\n    condition = IfDefParser(bits).parse()\n    nodelist = parser.parse(block_tokens)\n    conditions_nodelists = [(condition, nodelist)]\n    token = parser.next_token()\n\n    # {% elifdef ... %} (repeatable)\n    while token.contents.startswith('elifdef'):\n        bits = token.split_contents()[1:]\n        if len(bits) > 1:\n            raise TemplateSyntaxError('%r is not an identifier.' % token)\n        condition = IfDefParser(bits).parse()\n        nodelist = parser.parse(block_tokens)\n        conditions_nodelists.append((condition, nodelist))\n        token = parser.next_token()\n\n    # {% else %} (optional)\n    if token.contents == 'else':\n        nodelist = parser.parse(block_tokens[-1:])\n        conditions_nodelists.append((None, nodelist))\n        token = parser.next_token()\n\n    # {% endifdef %}\n    assert token.contents == 'endifdef'\n\n    return IfNode(conditions_nodelists)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef down(queue, user=None, group=None, mode=None, host=None) :\n    '''Down a queue, by creating a down file'''\n    # default our owners and mode\n    user, group, mode = _dflts(user, group, mode)\n    down_path = fsq_path.down(queue, host=host)\n    fd = None\n    created = False\n    try:\n        # try to guarentee creation\n        try:\n            fd = os.open(down_path, os.O_CREAT|os.O_WRONLY|os.O_EXCL, mode)\n            created = True\n        except (OSError, IOError, ), e:\n            if e.errno != errno.EEXIST:\n                raise e\n            fd = os.open(down_path, os.O_CREAT|os.O_WRONLY, mode)\n        if user is not None or group is not None:\n            os.fchown(fd, *uid_gid(user, group, fd=fd))\n        if not created:\n            os.fchmod(fd, mode)\n    except (OSError, IOError, ), e:\n        if created:\n            _cleanup(down_path, e)\n        _raise(down_path, e)\n    finally:\n        if fd is not None:\n            os.close(fd)", "response": "Down a queue by creating a down file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupping a queue by removing a down file.", "response": "def up(queue, host=None):\n    '''Up a queue, by removing a down file -- if a queue has no down file,\n       this function is a no-op.'''\n    down_path = fsq_path.down(queue, host=host)\n    _queue_ok(os.path.dirname(down_path))\n    try:\n        os.unlink(down_path)\n    except (OSError, IOError, ), e:\n        if e.errno != errno.ENOENT:\n            raise FSQConfigError(e.errno, wrap_io_os_err(e))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if queue is down False if queue is up", "response": "def is_down(queue, host=None):\n    '''Returns True if queue is down, False if queue is up'''\n    down_path = fsq_path.down(queue, host=host)\n    _queue_ok(os.path.dirname(down_path))\n    # use stat instead of os.path.exists because non-ENOENT errors are a\n    # configuration issue, and should raise exeptions (e.g. if you can't\n    # access due to permissions, we want to raise EPERM, not return False)\n    try:\n        os.stat(down_path)\n    except (OSError, IOError, ), e:\n        if e.errno == errno.ENOENT:\n            return False\n        raise FSQConfigError(e.errno, wrap_io_os_err(e))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninstall a trigger for the specified queue.", "response": "def trigger(queue, user=None, group=None, mode=None, trigger=_c.FSQ_TRIGGER):\n    '''Installs a trigger for the specified queue.'''\n    # default our owners and mode\n    user, group, mode = _dflts(user, group, mode)\n    trigger_path = fsq_path.trigger(queue, trigger=trigger)\n    created = False\n    try:\n        # mkfifo is incapable of taking unicode, coerce back to str\n        try:\n            os.mkfifo(trigger_path.encode(_c.FSQ_CHARSET), mode)\n            created = True\n        except (OSError, IOError, ), e:\n            # if failure not due to existence, rm and bail\n            if e.errno != errno.EEXIST:\n                raise e\n\n        # don't open and fchown here, as opening WRONLY without an open\n        # reading fd will hang, opening RDONLY will zombie if we don't\n        # flush, and intercepts triggers meant to go elsewheres\n        os.chmod(trigger_path, mode)\n        if user is not None or group is not None:\n            os.chown(trigger_path, *uid_gid(user, group, path=trigger_path))\n    except (OSError, IOError, ), e:\n        # only rm if we created and failed, otherwise leave it and fail\n        if created:\n            _cleanup(trigger_path, e)\n        _raise(trigger_path, e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trigger_pull(queue, ignore_listener=False, trigger=_c.FSQ_TRIGGER):\n    '''Write a non-blocking byte to a trigger fifo, to cause a triggered\n       scan'''\n    fd = None\n    trigger_path = fsq_path.trigger(queue, trigger=trigger)\n    _queue_ok(os.path.dirname(trigger_path))\n    try:\n        fd = os.open(trigger_path,\n                     os.O_NDELAY|os.O_NONBLOCK|os.O_APPEND|os.O_WRONLY)\n        os.write(fd, '\\0')\n    except (OSError, IOError, ), e:\n        if e.errno != errno.ENXIO:\n            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:\n                raise FSQTriggerPullError(e.errno, wrap_io_os_err(e))\n        elif not ignore_listener:\n            raise FSQTriggerPullError(e.errno, u'No listener for:'\\\n                                      u' {0}'.format(trigger_path))\n    finally:\n        if fd is not None:\n            os.close(fd)", "response": "Write a non - blocking byte to a trigger fifo to cause a triggered\n       scan"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef down_host(trg_queue, host, user=None, group=None, mode=None):\n    ''' Down a host queue by creating a down file in the host queue\n        directory '''\n    down(trg_queue, user=user, group=group, mode=mode, host=host)", "response": "Down a host queue by creating a down file in the host queue\n        directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninstalls a host trigger for the specified queue.", "response": "def host_trigger(trg_queue, user=None, group=None, mode=None):\n    '''Installs a host trigger for the specified queue.'''\n    trigger(trg_queue, user=user, group=group, mode=mode,\n            trigger=_c.FSQ_HOSTS_TRIGGER)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef host_trigger_pull(trg_queue, ignore_listener=False):\n    '''Write a non-blocking byte to a host trigger fifo, to cause a triggered\n       scan'''\n    trigger_pull(trg_queue, ignore_listener=ignore_listener,\n                 trigger=_c.FSQ_HOSTS_TRIGGER)", "response": "Write a non - blocking byte to a host trigger fifo to cause a triggered\n       scan"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses an xml. dom Node object representing a component group into this object.", "response": "def parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a component group into\n        this object.\n\n        '''\n        self.group_id = node.getAttributeNS(RTS_NS, 'groupId')\n        self._members = []\n        for c in node.getElementsByTagNameNS(RTS_NS, 'Members'):\n            self._members.append(TargetComponent().parse_xml_node(c))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_yaml(self, node):\n        '''Parse a YAML specification of a component group into this\n        object.\n\n        '''\n        self.group_id = y['groupId']\n        self._members = []\n        if 'members' in y:\n            for m in y.get('members'):\n                self._members.append(TargetComponent().parse_yaml(m))\n        return self", "response": "Parse a YAML specification of a component group into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving this component group into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this component group into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'groupID', self.group_id)\n        for m in self.members:\n            new_element = doc.createElementNS(RTS_NS, RTS_NS_S + 'Members')\n            m.save_xml(doc, new_element)\n            element.appendChild(new_element)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave this component group to a dictionary.", "response": "def to_dict(self):\n        '''Save this component group to a dictionary.'''\n        d = {'groupId': self.group_id}\n        members = []\n        for m in self.members:\n            members.append(m.to_dict())\n        if members:\n            d['members'] = members\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef invalidate_paths(paths):\n    '''\n    Invalidate all pages for a certain path.\n    '''\n    for path in paths:\n        for key in all_cache_keys_from_path(path):\n            InvalidationLogger.invalidate(path, key)\n            dumper.utils.cache.delete(key)", "response": "Invalidate all pages for a certain path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all cache keys that can be used for a given path.", "response": "def all_cache_keys_from_path(path):\n    '''\n    Each path can actually have multiple cached entries, varying based on different HTTP\n    methods. So a GET request will have a different cached response from a HEAD request.\n    \n    In order to invalidate a path, we must first know all the different cache keys that the\n    path might have been cached at. This returns those keys\n    '''\n    return [dumper.utils.cache_key(path, method) for method in dumper.settings.CACHABLE_METHODS]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef staff_toolbar(context):\n    request = context['request']\n    if not request.user.is_staff:\n        return u''\n\n    toolbar_html = toolbar_root(request, context)\n    return format_html(u'<nav id=\"django-staff-toolbar\">{0}</nav>', toolbar_html)", "response": "Display the staff toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassigns an URL to be the admin link of this page.", "response": "def set_staff_url(parser, token):\n    \"\"\"\n    Assign an URL to be the \"admin link\" of this page.\n    Example::\n\n        {% set_staff_url %}{% url 'admin:fluent_pages_page_change' page.id %}{% end_set_staff_url %}\n    \"\"\"\n    nodelist = parser.parse(('end_set_staff_url',))\n    parser.delete_first_token()\n    return AdminUrlNode(nodelist)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_registered(url_id, remote_info):\n    return template(\n        read_index_template(),\n        registered=True,\n        url=remote_info[\"url\"],\n        seeder_data=json.dumps(remote_info),\n        url_id=url_id,\n    )", "response": "Render template file for the registered user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_unregistered(error=None):\n    return template(\n        read_index_template(),\n        registered=False,\n        error=error,\n        seeder_data=None,\n        url_id=None,\n    )", "response": "Render template file for the unregistered user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_form_template():\n    error = \"\"\n    remote_info = {}\n    registered_user_id = request.query.get(\"url_id\", False)\n\n    # try to read remote info, the the url_id parameter was specified\n    if registered_user_id:\n        try:\n            remote_info = seeder.get_remote_info(registered_user_id)\n        except AssertionError:  #: TODO: requests error\n            registered_user_id = False\n            error = \"Seeder neposlal o\u010dek\u00e1van\u00e1 data.\\n\"\n\n    if registered_user_id and remote_info:\n        return render_registered(registered_user_id, remote_info)\n\n    if not remote_info:\n        error += \"Seeder je nedostupn\u00fd!\\n\"\n\n    return render_unregistered(error)", "response": "Render the template for the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse given file and add it to graph", "response": "def unfold_file(self, path):\n        \"\"\"\n        Parse given file and add it to graph\n        \"\"\"\n        yaml_config = self.file_index.unfold_yaml(path)\n\n        self.unfold_config(path, yaml_config)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getValue(self, unit=None):\n\n        if unit or self.unit:\n            r = float(self.value * UnitToValue(self.unit)) / UnitToValue(unit)\n            return int(round(r)) if isinstance(self.value, int) else r\n        return self.value", "response": "Returns the value of the current feature."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks the type operator and unit of a feature.", "response": "def _check(self, check, radl):\n        \"\"\"\n        Check type, operator and unit in a feature.\n\n        Args:\n        - check(tuple):\n           - v[0]: expected type of the feature value.\n           - v[1]: can be a list of possible values or a function to test the value or None.\n           - v[2] (optional): can be a list of possible units; if None or not set the\n             unit valid is none.\n        - radl: second argument passed when calling v[1].\n        \"\"\"\n\n        # Check type\n        # If the value must be float, int is also valid\n        if check[0] == float:\n            if not isinstance(self.value, int) and not isinstance(self.value, float):\n                raise RADLParseException(\"Invalid type; expected %s\" % check[0],\n                                         line=self.line)\n        elif check[0] == str:\n            if not isinstance(self.value, str) and not isinstance(self.value, unicode):\n                raise RADLParseException(\"Invalid type; expected %s\" % check[0],\n                                         line=self.line)\n        else:\n            if not isinstance(self.value, check[0]):\n                raise RADLParseException(\"Invalid type; expected %s\" % check[0],\n                                         line=self.line)\n        # Check operator\n        if (isinstance(self.value, str) or isinstance(self.value, unicode)) and self.prop.find('version') == -1:\n            if self.operator != \"=\":\n                raise RADLParseException(\"Invalid operator; expected '='\",\n                                         line=self.line)\n        elif isinstance(self.value, int) or isinstance(self.value, float) or self.prop.find('version') >= 0:\n            if self.operator not in [\"=\", \"<=\", \">=\", \">\", \"<\"]:\n                raise RADLParseException(\"Invalid operator; expected '=', '<=', \" +\n                                         \"'>=', '>' or '<'\", line=self.line)\n        elif isinstance(self.value, Features):\n            if self.operator != \"contains\":\n                raise RADLParseException(\n                    \"Invalid operator; expected 'contains'\", line=self.line)\n        # Check value\n        if isinstance(check[1], list):\n            if self.value.upper() not in check[1]:\n                raise RADLParseException(\"Invalid value; expected one of %s\" % check[1],\n                                         line=self.line)\n        elif callable(check[1]):\n            if not check[1](self, radl):\n                raise RADLParseException(\"Invalid value in property '%s'\" % self.prop, line=self.line)\n        # Check unit\n        if len(check) < 3 or check[2] is None:\n            if self.unit:\n                raise RADLParseException(\"Invalid unit; expected none\", line=self.line)\n        elif len(check) > 2 and check[2]:\n            if self.unit.upper() not in check[2]:\n                raise RADLParseException(\n                    \"Invalid unit; expected one of %s\" % check[2], line=self.line)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef addFeature(self, f, conflict=\"error\", missing=\"other\"):\n\n        OPTIONS = [\"error\", \"ignore\", \"me\", \"other\"]\n        assert missing in OPTIONS, \"Invalid value in `missing`.\"\n        assert conflict in OPTIONS, \"Invalid value in `missing`.\"\n\n        if f.prop not in self.props and missing == \"error\":\n            raise Exception(\"Property has not set.\")\n        elif f.prop not in self.props and missing in [\"ignore\", \"first\"]:\n            return\n\n        if isinstance(f.value, int) or isinstance(f.value, float):\n            if f.operator == \"=\":\n                inter1 = (f, f)\n            elif f.operator[0] == \"<\":\n                inter1 = (None, f)\n            elif f.operator[0] == \">\":\n                inter1 = (f, None)\n            inter0 = self.props.get(f.prop, (None, None))\n            try:\n                self.props[f.prop] = Features._applyInter(inter0, inter1, conflict)\n            except Exception as e:\n                raise RADLParseException(\"%s. Involved features: %s\" % (e, [str(f0) for f0 in inter0]),\n                                         line=f.line)\n        elif isinstance(f, SoftFeatures):\n            self.props.setdefault(f.prop, []).append(f)\n        elif f.operator == \"contains\":\n            if f.prop in self.props and f.value.getValue(\"name\") in self.props[f.prop]:\n                feature = self.props[f.prop][f.value.getValue(\"name\")].clone()\n                for f0 in f.value.features:\n                    feature.value.addFeature(f0, conflict, missing)\n                self.props[f.prop][f.value.getValue(\"name\")] = feature\n            else:\n                self.props.setdefault(f.prop, {})[f.value.getValue(\"name\")] = f\n        else:\n            value0 = self.props.get(f.prop, None)\n            if not value0 or (conflict == \"other\"):\n                self.props[f.prop] = f\n            elif value0.value != f.value and conflict == \"error\":\n                raise RADLParseException(\"Conflict adding `%s` because `%s` is already set and conflict is\"\n                                         \" %s\" % (f, value0, conflict), line=f.line)", "response": "Adds a feature to the set of known features."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hasFeature(self, prop, check_softs=False):\n\n        return prop in self.props or (check_softs and\n                                      any([fs.hasFeature(prop) for fs in self.props.get(SoftFeatures.SOFT, [])]))", "response": "Return if there is a property with that name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getValue(self, prop, default=None):\n\n        f = self.props.get(prop, None)\n        if not f:\n            return default\n        if isinstance(f, Feature):\n            return f.getValue()\n        if isinstance(f, tuple):\n            # if f[0].getValue() == f[1].getValue():\n            #    return f[0].getValue()\n            # Miguel: para poder probar\n            if f[0]:\n                return f[0].getValue()\n            elif f[1]:\n                return f[1].getValue()\n            raise Exception(\"Getting value from a property with a constrain\")\n        return f", "response": "Return the value of a feature with that name or default."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getFeature(self, prop):\n\n        f = self.props.get(prop, None)\n        if not f:\n            return None\n        if isinstance(f, Feature):\n            return f\n        if isinstance(f, tuple):\n            if f[0]:\n                return f[0]\n            elif f[1]:\n                return f[1]\n            raise Exception(\"Getting value from a property with a constrain\")\n        if isinstance(f, list):\n            return f\n        raise Exception(\"Getting value from a not simple property.\")", "response": "Return the feature with that name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the value of feature with that name.", "response": "def setValue(self, prop, value, unit=None):\n        \"\"\"Set the value of feature with that name.\"\"\"\n\n        if isinstance(value, int) or isinstance(value, float):\n            if prop in self.props:\n                for i, j in [(0, 1), (1, 0)]:\n                    if self.props[prop][i] is None:\n                        self.props[prop] = (self.props[prop][j], self.props[prop][j])\n                for v in self.props[prop]:\n                    v.value, v.unit = value, unit\n            else:\n                f = Feature(prop, \"=\", value, unit=unit)\n                self.props[prop] = (f, f)\n        elif prop in self.props:\n            self.props[prop].value, self.props[prop].unit = value, unit\n        else:\n            self.props[prop] = Feature(prop, \"=\", value, unit=unit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _applyInter(finter0, finter1, conflict=\"ignore\"):\n\n        OPTIONS = [\"error\", \"ignore\", \"me\", \"other\"]\n        assert conflict in OPTIONS, \"Invalid value in `conflict`.\"\n\n        # Compute the comparison of the interval extremes\n        min_int = -2**63\n        # Remember, None <= number and None <= None are True, but number <= None is False.\n        inter0 = tuple([f.getValue() if f else min_int for f in finter0])\n        inter1 = tuple([f.getValue() if f else min_int for f in finter1])\n        le00 = inter0[0] <= inter1[0]                           # finter0[0] <= finter1[0]\n        le01 = inter1[1] == min_int or inter0[0] <= inter1[1]   # finter0[0] <= finter1[1]\n        le11 = inter1[1] == min_int or (inter0[1] != min_int and inter0[1] <= inter1[1])  # finter0[1] <= finter1[1]\n        ge00 = not le00 or inter0[0] == inter1[0]               # finter0[0] >= finter1[0]\n        ge10 = inter0[1] == min_int or inter0[1] >= inter1[0]   # finter0[1] >= finter1[0]\n\n        # print \"\\n\".join(\"%s: %s\" % (s, v) for v, s in [\n        #    (le00, \"finter0[0] <= finter1[0]\"),\n        #    (le01, \"finter0[0] <= finter1[1]\"),\n        #    (le11, \"finter0[1] <= finter1[1]\"),\n        #    (ge00, \"finter0[0] >= finter1[0]\"),\n        #    (ge10, \"finter0[1] >= finter1[0]\") ])\n\n        # First interval is (  ), second interval is [  ]\n        if le00 and ge10 and le11:                       # ( [ ) ] chain first-second\n            return finter1[0], finter0[1]\n        elif le00 and ge10 and not le11:                 # ( [ ] )  second is inside first\n            return finter1\n        elif ge00 and le01 and le11:                     # [ ( ) ] first is inside second\n            return finter0\n        elif ge00 and le01 and not le11:                 # [ ( ] ) chain second-first\n            return finter0[0], finter1[1]\n        elif conflict == \"me\":\n            return finter0\n        elif conflict == \"other\":\n            return finter1\n        elif conflict == \"error\":\n            raise Exception(\"Disjoint intervals!\")\n        return None", "response": "Apply the interval restriction to the first and second intervals."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef applyFeatures(self, new_features, conflict=\"error\", missing=\"error\"):\n\n        OPTIONS = [\"error\", \"ignore\", \"me\", \"other\"]\n        assert missing in OPTIONS, \"Invalid value in `missing`.\"\n        assert conflict in OPTIONS, \"Invalid value in `missing`.\"\n\n        self0 = self.clone()\n        if isinstance(new_features, Features):\n            new_features = new_features.features\n        for f in new_features:\n            self0.addFeature(f, conflict=conflict, missing=missing)\n        self.props = self0.props\n        return self", "response": "Apply the constrain of the features passed to this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_simple(self, checks, radl):\n\n        for f in self.features:\n            if not isinstance(f, Feature) or f.prop not in checks:\n                continue\n            f._check(checks[f.prop], radl)", "response": "Check types operators and units in simple features."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks types operators and units in features with numbers.", "response": "def check_num(self, checks, radl):\n        \"\"\"\n        Check types, operators and units in features with numbers.\n\n        Args:\n\n        - checks(dict of dict of str:tuples): keys are property name prefixes, and the\n          values are dict with keys are property name suffixes and values are iterable\n          as in ``_check_feature``.\n        - radl: passed to ``_check_feature``.\n        \"\"\"\n\n        prefixes = {}\n        for f in self.features:\n            if not isinstance(f, Feature):\n                continue\n            (prefix, sep, tail) = f.prop.partition(\".\")\n            if not sep or prefix not in checks:\n                continue\n            checks0 = checks[prefix]\n            (num, sep, suffix) = tail.partition(\".\")\n            try:\n                num = int(num)\n            except:\n                raise RADLParseException(\n                    \"Invalid property name; expected an index.\", line=f.line)\n            if not sep or suffix not in checks0:\n                continue\n            f._check(checks0[suffix], radl)\n            if prefix not in prefixes:\n                prefixes[prefix] = set()\n            prefixes[prefix].add(num)\n\n        # Check consecutive indices for num properties.\n        for prefix, nums in prefixes.items():\n            if min(nums) != 0 or max(nums) != len(nums) - 1:\n                raise RADLParseException(\n                    \"Invalid indices values in properties '%s'\" % prefix)\n\n        return prefixes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(self, radl):\n\n        if not radl.get_system_by_name(self.system):\n            raise RADLParseException(\"Invalid system id '%s'\" % self.system, line=self.line)\n        if not radl.get_configure_by_name(self.configure):\n            raise RADLParseException(\"Invalid configure id '%s'\" % self.configure, line=self.line)", "response": "Check a line under a contextualize."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, cont):\n\n        self.max_time = max(self.max_time, cont.max_time)\n        if cont.items is not None:\n            if self.items is None:\n                self.items = cont.items\n            else:\n                self.items.update(cont.items)", "response": "Update this instance with the contextualize passed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a dictionary of the contextualize_items grouped by the step or the default value", "response": "def get_contextualize_items_by_step(self, default=None):\n        \"\"\"Get a dictionary of the contextualize_items grouped by the step or the default value\"\"\"\n        if self.items:\n            res = {}\n            for elem in self.items.values():\n                if elem.num in res:\n                    res[elem.num].append(elem)\n                else:\n                    res[elem.num] = [elem]\n            return res\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the features in this network.", "response": "def check(self, radl):\n        \"\"\"Check the features in this network.\"\"\"\n\n        SIMPLE_FEATURES = {\n            \"outbound\": (str, [\"YES\", \"NO\"]),\n            \"outports\": (str, check_outports_format),\n            \"provider_id\": (str, None)\n        }\n        self.check_simple(SIMPLE_FEATURES, radl)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isNewerThan(self, other):\n        if self.getValue(\"name\") == other.getValue(\"name\"):\n            if other.getValue(\"version\"):\n                if not other.getValue(\"version\"):\n                    return False\n                else:\n                    return LooseVersion(self.getValue(\"version\")) > LooseVersion(other.getValue(\"version\"))\n            else:\n                return True\n        else:\n            return False", "response": "Compare if the version of this app is newer than the other."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks the features in this application.", "response": "def check(self, radl):\n        \"\"\"Check the features in this application.\"\"\"\n        SIMPLE_FEATURES = {\n            \"name\": (str, lambda x, _: bool(x.value)),\n            \"path\": (str, lambda x, _: bool(x.value)),\n            \"version\": (str, is_version),\n            \"preinstalled\": (str, [\"YES\", \"NO\"])\n        }\n        self.check_simple(SIMPLE_FEATURES, radl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hasIP(self, ip):\n\n        for f in self.features:\n            if (f.prop.startswith(\"net_interface.\") and\n                    f.prop.endswith(\".ip\") and f.value == ip):\n                return True\n        return False", "response": "Return True if some system has this IP."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getNumNetworkWithConnection(self, connection):\n\n        i = 0\n        while True:\n            value = self.getValue(\"net_interface.%d.connection\" % i, None)\n            if not value:\n                return None\n            if value == connection:\n                return i\n            i += 1", "response": "Return the number of network interfaces with the given connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getRequestedNameIface(self, iface_num=0, num=None, default_hostname=None, default_domain=None):\n\n        full_name = self.getValue(\"net_interface.%d.dns_name\" % iface_num)\n\n        if full_name:\n            replaced_full_name = system.replaceTemplateName(full_name, num)\n            (hostname, domain) = replaced_full_name\n            if not domain:\n                domain = default_domain\n            return (hostname, domain)\n        else:\n            if default_hostname:\n                (hostname, _) = system.replaceTemplateName(default_hostname, num)\n                return (hostname, default_domain)\n            else:\n                return None", "response": "Return the dns name associated to the net interface."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getNetworkIDs(self):\n\n        res = []\n        i = 0\n        while True:\n            netid = self.getValue(\"net_interface.%d.connection\" % i)\n            if not netid:\n                return res\n            res.append(netid)\n            i += 1", "response": "Return a list of network id of this system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef updateNewCredentialValues(self):\n\n        credentials_base = \"disk.0.os.credentials.\"\n        new_credentials_base = \"disk.0.os.credentials.new.\"\n\n        for elem in ['password', 'public_key', 'private_key']:\n            if self.getValue(new_credentials_base + elem):\n                self.setValue(credentials_base + elem, self.getValue(new_credentials_base + elem))\n                self.delValue(new_credentials_base + elem)", "response": "Updates the credentials to use and deletes the new ones from the credentials."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCredentialValues(self, username=None, password=None, public_key=None, private_key=None, new=False):\n\n        credentials_base = \"disk.0.os.credentials.\"\n        if new:\n            credentials_base = \"disk.0.os.credentials.new.\"\n\n        if username:\n            self.setValue(credentials_base + \"username\", username)\n        if password:\n            self.setValue(credentials_base + \"password\", password)\n        if public_key:\n            self.setValue(credentials_base + \"public_key\", public_key)\n        if private_key:\n            self.setValue(credentials_base + \"private_key\", private_key)", "response": "Set the values in disk. 0. os. credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getCredentials(self):\n\n        (username, password, public_key, private_key) = self.getCredentialValues()\n\n        if public_key or private_key:\n            return UserKeyCredential(username, public_key, private_key)\n\n        if username or password:\n            return UserPassCredential(username, password)\n\n        return None", "response": "Return UserKeyCredential or UserPassCredential."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCredentials(self, creds):\n\n        if isinstance(creds, UserKeyCredential):\n            self.setUserKeyCredentials(creds.username, creds.public_key, creds.private_key)\n        elif isinstance(creds, UserPassCredential):\n            self.setUserPasswdCredentials(creds.username, creds.password)", "response": "Set values in UserKeyCredential or UserPassCredential."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setUserPasswdCredentials(self, username, password):\n\n        self.setCredentialValues(username=username, password=password)", "response": "Set username and password in disk. 0. os. credentials."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting these properties in disk. 0. os. credentials.", "response": "def setUserKeyCredentials(self, username, public_key=None, private_key=None):\n        \"\"\"Set these properties in ``disk.0.os.credentials``.\"\"\"\n\n        self.setCredentialValues(username=username, public_key=public_key, private_key=private_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of Application with the specified apps in this system.", "response": "def getApplications(self):\n        \"\"\"Return a list of Application with the specified apps in this system.\"\"\"\n\n        res = []\n        for f in self.features:\n            if isinstance(f, Feature) and f.prop == \"disk.0.applications\":\n                res.append(FeaturesApp(f.value.features))\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addApplication(self, name, version=None, path=None, disk_num=0, soft=-1):\n\n        fapp = Features()\n        fapp.features.append(Feature(\"name\", \"=\", name))\n        if version:\n            fapp.features.append(Feature(\"version\", \"=\", version))\n        if path:\n            fapp.features.append(Feature(\"path\", \"=\", path))\n        self.features.append(Feature(\"disk.%d.applications\" % disk_num, \"contains\", fapp, soft > 0))", "response": "Add a new application in some disk."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check(self, radl):\n\n        def positive(f, _):\n            return f.value >= 0\n\n        def check_ansible_host(f, radl0):\n            if radl0.get_ansible_by_id(f.value) is None:\n                return False\n            return True\n\n        mem_units = [\"\", \"B\", \"K\", \"M\", \"G\", \"KB\", \"MB\", \"GB\"]\n        SIMPLE_FEATURES = {\n            \"spot\": (str, [\"YES\", \"NO\"]),\n            \"image_type\": (str, [\"VMDK\", \"QCOW\", \"QCOW2\", \"RAW\"]),\n            \"virtual_system_type\": (str, system._check_virtual_system_type),\n            \"price\": ((int, float), positive, None),\n            \"cpu.count\": ((int, float), positive, None),\n            \"cpu.arch\": (str, ['I386', 'X86_64']),\n            \"cpu.performance\": ((int, float), positive, [\"ECU\", \"GCEU\", \"HRZ\"]),\n            \"memory.size\": (int, positive, mem_units),\n            \"disk.0.os.credentials.new.password\": (str, check_password),\n            \"ansible_host\": (str, check_ansible_host),\n            SoftFeatures.SOFT: (SoftFeatures, lambda x, r: x.check(r))\n        }\n        self.check_simple(SIMPLE_FEATURES, radl)\n\n        net_connections = set()\n\n        def check_net_interface_connection(f, radl0):\n            if radl0.get_network_by_id(f.value) is None:\n                return False\n            net_connections.add(f.prop)\n            return True\n\n        def check_app(f, x):\n            FeaturesApp(f.value.features).check(x)\n            return True\n\n        NUM_FEATURES = {\n            \"net_interface\": {\n                \"connection\": (str, check_net_interface_connection),\n                \"ip\": (str, None),\n                \"dns_name\": (str, None)},\n            \"disk\": {\n                \"image.url\": ((str, unicode, list), system._check_disk_image_url),\n                \"image.name\": (str, None),\n                \"type\": (str, None),\n                \"device\": (str, None),\n                \"mount_path\": (str, None),\n                \"fstype\": (str, None),\n                \"size\": (float, positive, mem_units),\n                \"free_size\": (float, positive, mem_units),\n                \"os.name\": (str, [\"LINUX\", \"WINDOWS\", \"MAC OS X\"]),\n                \"os.flavour\": (str, None),\n                \"os.version\": (str, is_version),\n                \"os.credentials.username\": (str, None),\n                \"os.credentials.password\": (str, None),\n                \"os.credentials.private_key\": (str, None),\n                \"os.credentials.public_key\": (str, None),\n                \"applications\": (Features, check_app)\n            }\n        }\n        prefixes = self.check_num(NUM_FEATURES, radl)\n\n        # Check all interfaces\n        if len(net_connections) != len(prefixes.get(\"net_interface\", set())):\n            raise RADLParseException(\"Some net_interface does not have a connection\")\n\n        return True", "response": "Check the features in this system."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a copy and score after being applied other system and soft features.", "response": "def concrete(self, other=None):\n        \"\"\"\n        Return copy and score after being applied other system and soft features.\n\n        Args:\n\n        - other(system, optional): system to apply just before soft features.\n\n        Return(tuple): tuple of the resulting system and its score.\n        \"\"\"\n\n        new_system = self.clone()\n        if other:\n            new_system.applyFeatures(other, missing=\"other\")\n        soft_features = self.getValue(SoftFeatures.SOFT, [])\n        score = 0\n        for f in sorted(soft_features, key=lambda f: f.soft, reverse=True):\n            try:\n                new_system.applyFeatures(f, missing=\"other\")\n                score += f.soft\n            except:\n                pass\n        new_system.delValue(SoftFeatures.SOFT)\n        return new_system, score"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new resource to the RADL.", "response": "def add(self, aspect, ifpresent=\"error\"):\n        \"\"\"\n        Add a network, ansible_host, system, deploy, configure or contextualize.\n\n        Args:\n        - aspect(network, system, deploy, configure or contextualize): thing to add.\n        - ifpresent(str): if it has been defined, do:\n\n           - ``\"ignore\"``: not add the aspect.\n           - ``\"replace\"``: replace by the old defined.\n           - ``\"error\"``: raise an error.\n\n        Return(bool): True if aspect was added.\n        \"\"\"\n\n        # If aspect is a contextualization, it is trated separately\n        if isinstance(aspect, contextualize):\n            self.contextualize.update(aspect)\n            return True\n\n        classification = [(network, self.networks), (system, self.systems), (ansible, self.ansible_hosts),\n                          (deploy, self.deploys), (configure, self.configures)]\n        aspect_list = [l for t, l in classification if isinstance(aspect, t)]\n        assert len(aspect_list) == 1, \"Unexpected aspect for RADL.\"\n        aspect_list = aspect_list[0]\n\n        old_aspect = [a for a in aspect_list if a.getId() == aspect.getId()]\n        if old_aspect:\n            # If some aspect with the same id is found\n            if ifpresent == \"error\":\n                raise Exception(\"Aspect with the same id was found.\")\n            elif ifpresent == \"replace\":\n                for i, elem in enumerate(aspect_list):\n                    if elem.getId() == old_aspect[0].getId():\n                        del aspect_list[i]\n                        break\n                aspect_list.append(aspect)\n                return True\n            elif ifpresent == \"ignore\":\n                return False\n            else:\n                raise ValueError\n        else:\n            # Otherwise add aspect\n            aspect_list.append(aspect)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a network system or configure or contextualize with the same id as aspect passed.", "response": "def get(self, aspect):\n        \"\"\"Get a network, system or configure or contextualize with the same id as aspect passed.\"\"\"\n\n        classification = [(network, self.networks), (system, self.systems),\n                          (configure, self.configures)]\n        aspect_list = [l for t, l in classification if isinstance(aspect, t)]\n        assert len(aspect_list) == 1, \"Unexpected aspect for RADL.\"\n        aspect_list = aspect_list[0]\n\n        old_aspect = [a for a in aspect_list if a.getId() == aspect.getId()]\n        return old_aspect[0] if old_aspect else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __getIP(self, public):\n\n        maybeNot = (lambda x: x) if public else (lambda x: not x)\n        nets_id = [net.id for net in self.networks if maybeNot(net.isPublic())]\n        for s in self.systems:\n            i = 0\n            while True:\n                value = s.getValue(\"net_interface.%d.connection\" % i)\n                if not value:\n                    break\n                if value in nets_id:\n                    ip = s.getValue(\"net_interface.%d.ip\" % i)\n                    if ip:\n                        return ip\n                i += 1\n        return None", "response": "Return the first net_interface. ip for a system in a public or private network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hasPublicNet(self, system_name):\n\n        nets_id = [net.id for net in self.networks if net.isPublic()]\n        system = self.get_system_by_name(system_name)\n        if system:\n            i = 0\n            while True:\n                f = system.getFeature(\"net_interface.%d.connection\" % i)\n                if not f:\n                    break\n                if f.value in nets_id:\n                    return True\n                i += 1\n\n        return False", "response": "Return True if some system has a public network."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check(self):\n\n        for i in [f for fs in [self.networks, self.ansible_hosts, self.systems, self.deploys,\n                               self.configures, [self.contextualize]] for f in fs]:\n            i.check(self)\n\n        snames = [s.name for s in self.systems]\n        if len(set(snames)) != len(snames):\n            raise RADLParseException(\"Some System name duplicated.\")\n\n        nids = [s.id for s in self.networks]\n        if len(set(nids)) != len(nids):\n            raise RADLParseException(\"Some Network name duplicated.\")\n\n        return True", "response": "Check if the RADL document is a valid RADL document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a system with that name or None.", "response": "def get_system_by_name(self, name):\n        \"\"\"Return a system with that name or None.\"\"\"\n\n        for elem in self.systems:\n            if elem.name == name:\n                return elem\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_deploy_by_id(self, dep_id):\n\n        for elem in self.deploys:\n            if elem.id == dep_id:\n                return elem\n        return None", "response": "Return a deploy with that system id or None."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a configure with that name or None.", "response": "def get_configure_by_name(self, name):\n        \"\"\"Return a configure with that id or None.\"\"\"\n\n        for elem in self.configures:\n            if elem.name == name:\n                return elem\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_network_by_id(self, net_id):\n\n        for elem in self.networks:\n            if elem.id == net_id:\n                return elem\n        return None", "response": "Return a network with that id or None."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ansible_by_id(self, ansible_id):\n\n        for elem in self.ansible_hosts:\n            if elem.id == ansible_id:\n                return elem\n        return None", "response": "Return an ansible with that id or None."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check(self, radl):\n\n        SIMPLE_FEATURES = {\n            \"host\": (str, None),\n            \"credentials.username\": (str, None),\n            \"credentials.password\": (str, None),\n            \"credentials.private_key\": (str, None)\n        }\n        self.check_simple(SIMPLE_FEATURES, radl)\n\n        if not self.getHost():\n            raise RADLParseException(\"Ansible host must have a host\", line=self.line)\n        (username, password, private_key) = self.getCredentialValues()\n        if not username:\n            raise RADLParseException(\"Ansible host must have a credentials.username\", line=self.line)\n        if not password and not private_key:\n            raise RADLParseException(\"Ansible host must have a credentials.password or credentials.private_key\",\n                                     line=self.line)", "response": "Check the features in this network."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the values in credentials.", "response": "def getCredentialValues(self, new=False):\n        \"\"\"Return the values in credentials.*.\"\"\"\n\n        credentials_base = \"credentials.\"\n        return tuple([self.getValue(credentials_base + p) for p in [\n            \"username\", \"password\", \"private_key\"]])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the outports string and returns a list of outport objects.", "response": "def parseOutPorts(outports):\n        \"\"\"\n        Parse the outports string\n        Valid formats:\n        8899/tcp-8899/tcp,22/tcp-22/tcp\n        8899/tcp-8899,22/tcp-22\n        8899-8899,22-22\n        8899/tcp,22/udp\n        8899,22\n        1:10/tcp,9:22/udp\n        1:10,9:22\n        Returns a list of outport objects\n        \"\"\"\n        res = []\n        ports = outports.split(',')\n        for port in ports:\n            if port.find('-') != -1 and port.find(':') != -1:\n                raise RADLParseException('Port range (:) and port mapping (-) cannot be combined.')\n            if port.find(':') != -1:\n                parts = port.split(':')\n                range_init = parts[0]\n                range_end = parts[1]\n                range_end_parts = range_end.split(\"/\")\n                if len(range_end_parts) > 1:\n                    protocol = range_end_parts[1]\n                    range_end = range_end_parts[0]\n                else:\n                    protocol = \"tcp\"\n                res.append(outport(range_init, range_end, protocol, True))\n            else:\n                parts = port.split('-')\n                remote_port = parts[0]\n                if len(parts) > 1:\n                    local_port = parts[1]\n                else:\n                    local_port = remote_port\n\n                local_port_parts = local_port.split(\"/\")\n                if len(local_port_parts) > 1:\n                    local_protocol = local_port_parts[1]\n                    local_port = local_port_parts[0]\n                else:\n                    local_protocol = \"tcp\"\n\n                remote_port_parts = remote_port.split(\"/\")\n                if len(remote_port_parts) > 1:\n                    remote_protocol = remote_port_parts[1]\n                    remote_port = remote_port_parts[0]\n                else:\n                    remote_protocol = \"tcp\"\n\n                if remote_protocol != local_protocol:\n                    raise RADLParseException(\"Different protocols used in local and remote outports.\")\n\n                res.append(outport(remote_port, local_port, local_protocol))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating time and date formats with different delimeters.", "response": "def create_date_formats():\n    \"\"\"Generate time and date formats with different delimeters.\"\"\"\n    # European style:\n    base_formats = ['%d %m %Y', '%d %m %y', '%Y %m %d']\n    # US style:\n    base_formats += ['%m %d %Y', '%m %d %y', '%Y %m %d']\n    # Things with words in\n    base_formats += ['%d %b %Y', '%d %B %Y']\n\n    date_formats = []\n    for separator in ('-', '.', '/', ' '):\n        for date_format in base_formats:\n            date_formats.append((date_format.replace(' ', separator)))\n\n    datetime_formats = []\n    time_formats = ('%H:%M%Z', '%H:%M:%S', '%H:%M:%S%Z', '%H:%M%z',\n                    '%H:%M:%S%z')\n\n    for date_format in date_formats:\n        for time_format in time_formats:\n            for separator in ('', 'T', ' '):\n                datetime_formats.append(date_format + separator + time_format)\n\n    return tuple(date_formats), tuple(datetime_formats)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef injectClassCallback(annotationName, depth, methodName, *args, **kwargs):\n    locals = reflect.class_locals(depth, annotationName)\n    annotations = locals.get(_CLASS_ANNOTATIONS_ATTR, None)\n    if annotations is None:\n        annotations = list()\n        locals[_CLASS_ANNOTATIONS_ATTR] = annotations\n    annotation = (annotationName, methodName, args, kwargs)\n    annotations.append(annotation)", "response": "Injects an annotation for a class method to be called by the metaclass."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninject an attribute in a class from it s class frame.", "response": "def injectAttribute(annotationName, depth, attr, value):\n    \"\"\"\n    Inject an attribute in a class from it's class frame.\n    Use in class annnotation to create methods/properties dynamically\n    at class creation time without dealing with metaclass.\n\n    depth parameter specify the stack depth from the class definition.\n    \"\"\"\n    locals = reflect.class_locals(depth, annotationName)\n    injections = locals.get(_ATTRIBUTE_INJECTIONS_ATTR, None)\n    if injections is None:\n        injections = list()\n        locals[_ATTRIBUTE_INJECTIONS_ATTR] = injections\n    injections.append((attr, value))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slack_message():\n    # Incoming request format:\n    # token=TOKEN\n    # team_id=T0001\n    # team_domain=example\n    # channel_id=C12345\n    # channel_name=test\n    # user_id=U12345\n    # user_name=Steve\n    # command=/weather\n    # text=94070\n\n    # Verify Slack token lines up\n    if request.form['token'] != SLACK_TOKEN:\n        return ('Provided Slack token from message didn\\'t match our server\\'s Slack token. '\n                'Please double check they are aligned', 403)\n\n    # Extract our text and make a card\n    text = request.form['text']\n    user_name = request.form['user_name']\n    # Pre-emptively extract channel name before taking actions (transaction-esque)\n    channel_name = request.form['channel_name']\n    card = make_trello_card(name='{text} ({user_name})'.format(text=text, user_name=user_name))\n\n    # Send a message to Slack about our success\n    # TODO: Escape our content\n    send_slack_message(channel='#{channel_name}'.format(channel_name=channel_name),\n                       text='Trello card \"<{url}|{text}>\" created by \"{user_name}\"'\n                       .format(url=card.url, text=text, user_name=user_name))\n\n    # Reply with nothing (as the external message does more)\n    return ''", "response": "When we receive a message from Slack generate a Trello card and reply with a message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef merge_users(merge_to, merge_from):\n    # Determine most active user based on most recently created group\n    assert(merge_to.username.endswith('umail.ucsb.edu'))\n\n    # Merge groups\n    for u2g in merge_from.groups_assocs[:]:\n        merge_to.group_with(merge_from, u2g.project, bypass_limit=True)\n\n    # merge classes and files\n    merge_to.classes.extend(merge_from.classes)\n    merge_to.files.extend(merge_from.files)\n\n    # update file ownership\n    for sub in Submission.query_by(created_by=merge_from).all():\n        sub.created_by = merge_to\n\n    # Delete the secondary user\n    Session.delete(merge_from)", "response": "Merge a non - umail account with a umail account."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the data from Glances API.", "response": "async def get_data(self):\n        \"\"\"Retrieve the data.\"\"\"\n        url = '{}/{}'.format(self.url, 'all')\n\n        try:\n            with async_timeout.timeout(5, loop=self._loop):\n                if self.password is None:\n                    response = await self._session.get(url)\n                else:\n                    auth = aiohttp.BasicAuth(self.username, self.password)\n                    response = await self._session.get(url, auth=auth)\n\n            _LOGGER.debug(\"Response from Glances API: %s\", response.status)\n            print(response.status)\n            print(response.text)\n            self.data = await response.json()\n            _LOGGER.debug(self.data)\n        except (asyncio.TimeoutError, aiohttp.ClientError):\n            _LOGGER.error(\"Can not load data from Glances API\")\n            raise exceptions.GlancesApiConnectionError()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def get_metrics(self, element):\n        await self.get_data()\n        await self.get_plugins()\n\n        if element in self.plugins:\n            self.values = self.data[element]\n        else:\n            raise exceptions.GlancesApiError(\"Element data not available\")", "response": "Get all the metrics for a monitored element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(cmd, cwd=None, silent=None, return_output=False, raises=True, **subprocess_args):\n\n    if isinstance(cmd, str):\n        cmd = cmd.split()\n\n    cmd_str = ' '.join(cmd)\n\n    if 'shell' in subprocess_args and subprocess_args['shell']:\n        cmd = cmd_str\n\n    log.debug('Running: %s %s', cmd_str, '[%s]' % cwd if cwd else '')\n\n    if return_output and silent is None:\n        silent = True\n\n    try:\n        if silent or return_output:\n            p = subprocess.Popen(cmd, cwd=cwd, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                                 **subprocess_args)\n            exit_code = -1\n\n            if silent:\n                output, _ = p.communicate()\n                exit_code = p.returncode\n            else:\n                output = ''\n                ch = True\n                while ch:\n                    ch = p.stdout.read(1)\n                    sys.stdout.write(ch)\n                    sys.stdout.flush()\n                    output += ch\n                    if p.poll() is not None and exit_code == -1:\n                        exit_code = p.returncode\n\n            output = output.decode('utf-8')\n\n            if return_output is True:\n                return output\n            elif return_output == 2:\n                return output, exit_code == 0\n\n            if exit_code == 0:\n                if return_output:\n                    return output\n                else:\n                    return True\n\n            elif raises or silent == 2:\n                if output and silent:\n                    print(output.strip())\n\n        else:\n            exit_code = subprocess.call(cmd, cwd=cwd, **subprocess_args)\n            if exit_code == 0:\n                return True\n\n    except Exception as e:\n        if raises:\n            log.debug(e, exc_info=True)\n            raise RunError('Command \"%s\" could not be run because %s' % (cmd_str, e))\n\n    # We only get here if exit code != 0\n    if raises:\n        raise RunError('Command \"%s\" returned non-zero exit status %d' % (cmd_str, exit_code))\n\n    return False", "response": "Runs a command in a node - site site"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting raw incoming to class attributes.", "response": "def parse(self, raw):\n        \"\"\"Convert raw incoming to class attributes.\"\"\"\n        self._raw = raw\n        self.hub_name = self._parse(\"userData\", \"hubName\", converter=base64_to_unicode)\n        self.ip = self._parse(\"userData\", \"ip\")\n        self.ssid = self._parse(\"userData\", \"ssid\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def query_firmware(self):\n\n        _version = await self.request.get(join_path(self._base_path, \"/fwversion\"))\n        _fw = _version.get(\"firmware\")\n        if _fw:\n            _main = _fw.get(\"mainProcessor\")\n            if _main:\n                self._main_processor_version = self._make_version(_main)\n            _radio = _fw.get(\"radio\")\n            if _radio:\n                self._radio_version = self._make_version(_radio)", "response": "Query the firmware versions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the bounding box of the text assuming that the left - bottom corner of the first letter of the text is at ( 0 ).", "response": "def unaligned_get_dimension(text):\n    \"\"\"Return the bounding box of the text, assuming that the left-bottom corner\n    of the first letter of the text is at (0, 0). This procedure ignores\n    /h, /v, and /a directives when calculating the BB; it just returns the\n    alignment specifiers as a part of the return value. The return value is a\n    tuple (width, height, halign, valign, angle).\"\"\"\n\n    xmax = 0\n    ymax = 0\n    ymax = 0\n    angle = None\n    halign = None\n    valign = None\n    itr = text_iterator(None)\n    for line in str(text).split('\\n'):\n        cur_height = 0\n        cur_width = 0\n        itr.reset(line)\n        while 1:\n            elem = next(itr)\n            if not elem:\n                break\n            (font, size, line_height, color, new_h, new_v, new_a, chunk) = elem\n            if halign != None and new_h != halign:\n                raise FontException('Only one \"/h\" can appear in a string.',\n                                    str(text))\n            if valign != None and new_v != valign:\n                raise FontException('Only one \"/v\" can appear in a string.',\n                                    str(text))\n            if angle != None and new_a != angle:\n                raise FontException('Only one \"/a\" can appear in a string.',\n                                    str(text))\n            halign = new_h\n            valign = new_v\n            angle = new_a\n            cur_width += line_width(font, size, chunk)\n            cur_height = max(cur_height, line_height)\n        xmax = max(cur_width, xmax)\n        ymax += cur_height\n    return (xmax, ymax,\n            halign or theme.default_font_halign,\n            valign or theme.default_font_valign,\n            angle or theme.default_font_angle)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_dimension(text):\n    (xmax, ymax, halign, valign, angle) = unaligned_get_dimension(text)\n    xmin = ymin = 0\n    if halign == 'C':\n        xmin = -xmax / 2.0\n        xmax = xmax / 2.0\n    elif halign == 'R':\n        xmin = -xmax\n        xmax = 0\n    if valign == 'M':\n        ymin = -ymax / 2.0\n        ymax = ymax / 2.0\n    elif valign == 'T':\n        ymin = -ymax\n        ymax = 0\n    if angle != 0:\n        (x0, y0) = pychart_util.rotate(xmin, ymin, angle)\n        (x1, y1) = pychart_util.rotate(xmax, ymin, angle)\n        (x2, y2) = pychart_util.rotate(xmin, ymax, angle)\n        (x3, y3) = pychart_util.rotate(xmax, ymax, angle)\n        xmax = max(x0, x1, x2, x3)\n        xmin = min(x0, x1, x2, x3)\n        ymax = max(y0, y1, y2, y3)\n        ymin = min(y0, y1, y2, y3)\n        return (xmin, xmax, ymin, ymax)\n    return (xmin, xmax, ymin, ymax)", "response": "Return the bounding box of the text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef text_width(text):\n    (xmin, xmax, d1, d2) = get_dimension(text)\n    return xmax - xmin", "response": "Return the width of the text in points."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef text_height(text):\n    (d1, d2, ymin, ymax) = get_dimension(text)\n    return (ymax - ymin, ymax)", "response": "Return the total height of the text box and the length from the base point to the top of the text box."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns ( halign valign angle ) of the text.", "response": "def get_align(text):\n    \"Return (halign, valign, angle) of the <text>.\"\n    (x1, x2, h, v, a) = unaligned_get_dimension(text)\n    return (h, v, a)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quotemeta(text):\n    text = re.sub(r'/', '//', text)\n    text = re.sub(r'\\\\{', '/{', text)\n    text = re.sub(r'\\\\}', '/}', text)\n    return text", "response": "Quote letters with special meanings in pychart so that text will display\n as - is when passed to canvas. show. \n\n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to load category ranges from module.", "response": "def load_from_package():\n    '''\n    Try to load category ranges from module.\n\n    :returns: category ranges dict or None\n    :rtype: None or dict of RangeGroup\n    '''\n    try:\n        import pkg_resources\n        f = pkg_resources.resource_stream(\n            meta.__app__,\n            'cache/unicategories.cache'\n            )\n        dversion, mversion, data = pickle.load(f)\n        if dversion == data_version and mversion == module_version:\n            return data\n        warnings.warn(\n            'Unicode unicategories database is outdated. '\n            'Please reinstall unicategories module to regenerate it.'\n            if dversion < data_version else\n            'Incompatible unicategories database. '\n            'Please reinstall unicategories module to regenerate it.'\n            )\n    except (ValueError, EOFError):\n        warnings.warn(\n            'Incompatible unicategories database. '\n            'Please reinstall unicategories module to regenerate it.'\n            )\n    except (ImportError, FileNotFoundError):\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to load category ranges from userlevel cache file.", "response": "def load_from_cache(path=user_path):\n    '''\n    Try to load category ranges from userlevel cache file.\n\n    :param path: path to userlevel cache file\n    :type path: str\n    :returns: category ranges dict or None\n    :rtype: None or dict of RangeGroup\n    '''\n    if not path:\n        return\n    try:\n        with open(path, 'rb') as f:\n            dversion, mversion, data = pickle.load(f)\n        if dversion == data_version and mversion == module_version:\n            return data\n    except (FileNotFoundError, ValueError, EOFError):\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating category ranges and save to userlevel cache file.", "response": "def generate_and_cache(path=user_path):\n    '''\n    Generate category ranges and save to userlevel cache file.\n\n    :param path: path to userlevel cache file\n    :type path: str\n    :returns: category ranges dict\n    :rtype: dict of RangeGroup\n    '''\n    data = tools.generate()\n    if not path:\n        return data\n    try:\n        directory = os.path.dirname(path)\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        with open(path, 'wb') as f:\n            pickle.dump((data_version, module_version, data), f)\n    except (PermissionError, ValueError) as e:\n        warnings.warn('Unable to write cache file \"%s\": %s' % (path, e))\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef group(self, base_dn, samaccountname, attributes=(), explicit_membership_only=False):\n\n        groups = self.groups(base_dn, samaccountnames=[samaccountname], attributes=attributes,\n                             explicit_membership_only=explicit_membership_only)\n\n        try:\n            # Usually we will find a match, but perhaps not always\n            return groups[0]\n        except IndexError:\n            logging.info(\"%s - unable to retrieve object from AD by sAMAccountName\", samaccountname)", "response": "Returns a single populated ADGroup object for the given base DN and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef groups(self, base_dn, samaccountnames=(), attributes=(), explicit_membership_only=False):\n        ad_groups = []\n\n        search_filter = '(&(objectClass=group)(!(objectClass=user))(!(objectClass=computer)){0})'\n        # If no samaccountnames specified, filter will pull all group objects under\n        # base_dn\n        if not samaccountnames:\n            search_filter = search_filter.format('(sAMAccountName=*)')\n        else:\n            if len(samaccountnames) == 1:\n                group_names = '(sAMAccountName={0})'.format(samaccountnames[0])\n            else:\n                group_names = '(|{0})'.format(''.join(['(sAMAccountName={0})'.\\\n                                                       format(group) for group\n                                                       in samaccountnames]))\n\n            search_filter = search_filter.format(group_names)\n\n\n        logging.debug('%s Search filter: %s', self.__class__.__name__, search_filter)\n\n        results = self.adq.search(base_dn, search_filter, attributes)\n\n        for search_result in results:\n            adg = self._object_factory(search_result)\n            if not explicit_membership_only and 'member' in dir(adg):\n                member = [u[0] for u in\n                          self.adq.search(base_dn, '(memberOf:1.2.840.113556.1.4.1941:={0})'.\\\n                          format(search_result[0]), attributes=['member'])]\n                adg.member = member\n            ad_groups.append(adg)\n\n        return ad_groups", "response": "Returns a list of ADGroup objects for the specified base DN and optionally attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\n\t\t# Make sure page is available\n\t\tif self.page is None:\n\t\t\traise Exception(\"The HTML data was not fetched due to some reasons\")\n\n\t\t# Check for invalid tracking number\n\t\tif 'Numbers Not Found -'in self.page or 'Invalid Query Numbers -' in self.page:\n\t\t\traise ValueError('The Tracking number is invalid')\n\n\t\tsoup = BeautifulSoup(self.page,'html.parser')\n\n\t\t# Assign the current status of the shipment\n\t\tif 'Returned To Origin' in self.page:\t\t # Prioritise this first\n\t\t\tself.status = 'R'\n\t\telif 'SHIPMENT DELIVERED' in self.page:\t # If the above is false, only then check for this\n\t\t\tself.status = 'C'\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t # The shipment is in Transit\n\t\t\tself.status = 'T'\t\t\t\t\t\t\n\n\t\t# Checkpoints extraction begins here \n\t\tcells = []\n\n\t\t'''\n\t\t\tThe below for loop goes through the table of checkpoints adding relevant cell data to cells[]\n\t\t'''\n\n\t\tfor cell in soup.findAll('td', {\"align\" : \"LEFT\"}):\n\t\t    if cell.font[\"size\"] == '1':\n\t\t    \tcell_text = cell.font.string\n\t\t    \tif self.is_valid(cell_text):\n\t\t    \t\tcells.append(cell_text)\n\n\t\t# 4 cells in each row\n\t\trows = [cells[cell:cell + 4] for cell in xrange(0, len(cells), 4)]\n\n\t\tfor row in rows:\n\n\t\t\t'''\n\t\t\t\tEach row will have 4 columns: Location--Status--Date--Time\n\t\t\t\tMerge column three and four and format it. \n\t\t\t\tAppend to tracking_data list\n\t\t\t'''\n\n\t\t\tlocation = row[0]\n\t\t\tstatus = row[1]\n\t\t\tdate_time = ' '.join((row[2],row[3]))\n\t\t\tdate_time_format = \"%d-%b-%Y %H:%M\"\n\t\t\tdate_time = datetime.strptime(date_time,date_time_format)\n\n\t\t\tself.tracking_data.append({'status':status,'date':date_time,'location':location})\n\n\t\t# Sort the checkpoints based on Date and Time --- this is important\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])", "response": "Extracts the checkpoints from the HTML page and stores them in self. tracking_data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching the raw HTML data from the site for a given tracking_no", "response": "def Get_Page(self):\n\t\t'''\n\t\t\tFetches raw HTML data from the site for a given tracking_no\n\t\t'''\n\n\t\t# Simply encode the correct url as a string\n\t\turl = 'https://www.aramex.com/express/track-results-multiple.aspx?ShipmentNumber='\n\t\turl += self.tracking_no\n\n\t\tdriver = webdriver.PhantomJS()\t\t\t# create a selenium webdriver\n\t\tdriver.get(url)\t\t\t\t\t\t\t# make it send a request with the above url\n\t\tself.wait_till_page_load(driver,10)\t\t# wait till the page is fully loaded\n\t\tself.page = driver.page_source\t\t# store the html source\n\t\tdriver.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting the checkpoints and stores them in self. tracking_data", "response": "def Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\n\t\t# Make sure page is available\n\t\tif self.page is None:\n\t\t\traise Exception(\"The HTML data was not fetched due to some reasons\")\n\n\t\t# Check for invalid tracking number\n\t\tif 'Invalid number / data not currently available' in self.page:\n\t\t\traise ValueError('Invalid number/data not currently available')\n\n\t\t# Checkpoints extraction begins here \n\t\t\n\t\tsoup = BeautifulSoup(self.page,'html.parser')\n\t\t\n\t\t# Assign the current status of the shipment - self.status\n\n\t\tcurrent_status = soup.find('span',id='spnCurrentStatusValue').text.strip()\n\t\tif current_status == 'Supporting Document Returned to Shipper':\t\n\t\t\tself.status = 'R'\n\t\telif current_status == 'Delivered':\n\t\t\tself.status = 'C'\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t # The shipment is in Transit\n\t\t\tself.status = 'T'\n\n\t\t# Get all rows of the Checkpoints table (no particular order)\n\t\trows = soup.findAll('div',{'class':'fullWidth odd leftFloat bottomGreyBorder'})\n\t\trows += soup.findAll('div',{'class':'fullWidth even leftFloat bottomGreyBorder'})\n\n\t\tfor row in rows:\n\t\t\t# Get the data\n\n\t\t\tlocation = row.find('div',{'class':'leftFloat thirdWidth'}).string.strip()\n\t\t\tdate_time = row.find('div',{'class':'leftFloat shipmentSummaryLabel'}).string.strip()\n\t\t\tstatus = row.find('div',{'class':'leftFloat shipmentHistoryActivityLabel'}).string.strip()\n\n\t\t\t# Clean it\n\t\t\tlocation = self.remove_non_ascii(location)\n\t\t\tdate_time_format = \"%d-%b-%Y %H:%M\"\n\t\t\tdate_time = parse(self.remove_non_ascii(date_time))\n\t\t\tstatus = self.remove_non_ascii(status)\n\n\t\t\t# Add it to the checkpoint list\n\t\t\tself.tracking_data.append({'status':status,'date':date_time,'location':location})\n\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting the checkpoints from the HTML data and stores them in self. tracking_data .", "response": "def Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\n\t\t# Make sure page is available\n\t\tif self.page is None:\n\t\t\traise Exception(\"The HTML data was not fetched due to some reasons\")\n\n\t\tsoup = BeautifulSoup(self.page,'html.parser')\n\n\t\t# Check for invalid tracking number by checking if table element is present\n\t\tif soup.find('thead') == None:\n\t\t\traise ValueError('Invalid tracking number')\n\n\t\t\n\t\t# Assign the current status of the shipment - self.status\n\n\t\tif 'Returned' in self.page:\t\n\t\t\tself.status = 'R'\n\t\telif 'Signed for by:' in self.page:\n\t\t\tself.status = 'C'\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t # The shipment is in Transit\n\t\t\tself.status = 'T'\n\n\t\t# The full checkpoints table div.\n\t\ttable = soup.find('table',{'class':'result-checkpoints'}).contents\n\t\tcur_date = None\t\t# The date of the next few checkpoints, initially None\n\t\tcheckpoint = None\n\n\t\tfor element in table:\n\t\t\tif element.name == 'thead':\n\t\t\t\t# This has the date for the next few checkpoints\n\t\t\t\tcur_date = element.find('th',{'colspan':'2'}).string.strip() + ' '\n\n\t\t\telif element.name == 'tbody':\n\t\t\t\t# A checkpoint whose date = cur_date\n\t\t\t\tcheckpoint = {'status':'','date':cur_date,'location':''}\n\t\t\t\ttds = element.findAll('td')\n\t\t\t\tcheckpoint['status'] = tds[1].string.strip()\n\t\t\t\tcheckpoint['location'] = tds[2].string.strip()\n\t\t\t\tcheckpoint['date'] += tds[3].string.strip()\n\t\t\t\tdate_time_format = \"%d-%b-%Y %H:%M\"\n\t\t\t\tcheckpoint['date'] = parse(checkpoint['date'])\n\t\t\t\tself.tracking_data.append(checkpoint)\n\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting the checkpoints from the HTML page and stores them in self. tracking_data.", "response": "def Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\n\t\t# Make sure page is available\n\t\tif self.page is None:\n\t\t\traise Exception(\"The HTML data was not fetched due to some reasons\")\n\n\t\tsoup = BeautifulSoup(self.page,'html.parser')\n\n\t\tinvalid_tracking_no = soup.find('span',{'id':'ctl00_ContentPlaceHolder1_lblsMsg','class':'ErrorMessage','style':'font-family:Calibri;font-size:9pt;font-weight:bold;','name':'lblsMsg'})\n\t\tif invalid_tracking_no is not None:\n\t\t\traise ValueError('The Tracking number is invalid')\n\n\t\t# Assign the current status of the shipment\n\n\t\tif 'Delivered' in self.page:\n\t\t\tself.status = 'C'\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t # The shipment is in Transit\n\t\t\tself.status = 'T'\t\t\t\t\t\t\n\n\t\t# Checkpoints extraction begins here \n\t\t\n\t\trows = soup.findAll('tr',{'class':'gridItem'}) + soup.findAll('tr',{'class':'gridAltItem'})\n\n\t\tfor row in rows:\n\n\t\t\t'''\n\t\t\t\tEach row will have 4 columns: Date--Time--Status--Location\n\t\t\t\tMerge column one and two and format it. \n\t\t\t\tAppend to tracking_data list\n\t\t\t'''\n\t\t\trow_cells = row.findAll('td')\n\n\t\t\tdate = row_cells[0].string.strip()\n\t\t\ttime = row_cells[1].string.strip()\n\t\t\tdate_time = ' '.join([date,time])\n\t\t\tdate_time_format = \"%d %b %Y %H:%M\"\n\t\t\tdate_time = datetime.strptime(date_time,date_time_format)\n\t\t\tstatus = row_cells[2].string.strip()\n\t\t\tlocation = row_cells[3].string.strip()\n\t\t\t\n\t\t\tself.tracking_data.append({'status':status,'date':date_time,'location':location})\n\n\t\t# Sort the checkpoints based on Date and Time --- this is important\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Get_Page(self):\n\t\t'''\n\t\t\tFetches raw HTML data from the site for a given tracking_no\n\t\t'''\n\n\t\turl = 'http://www.overnitenet.com/Web-Track.aspx'\n\n\t\tdata = {\n\t\t\t'__EVENTTARGET':'',\n\t\t\t'__EVENTARGUMENT':'',\n\t\t\t'__VIEWSTATE':'/wEPDwUKLTY0MDE3NTA3NWQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFgQFFWN0bDAwJENvbnRlbnQkcmRBd2JObwUVY3RsMDAkQ29udGVudCRyZFJlZk5vBRVjdGwwMCRDb250ZW50JHJkUmVmTm8FGWN0bDAwJENvbnRlbnQkaW1nYnRuVHJhY2uCRZzZgz3GDGJ/LncXvzFMpEh90g==',\n\t\t\t'__EVENTVALIDATION':'/wEWBgKc68neCQLx5f2jAQKYpPrsCgKcioujBgL2vJr6BALJ97buCl91xQYFzc1Hb3E2f/BkGHccMKCx',\n\t\t\t'ctl00$Content$rb':'rdAwbNo',\n\t\t\t'ctl00$Content$txtAWB':self.tracking_no,\n\t\t\t'ctl00$Content$ValidatorCalloutExtender6_ClientState':'',\n\t\t\t'ctl00$Content$imgbtnTrack.x':'28',\n\t\t\t'ctl00$Content$imgbtnTrack.y':'8'\n\t\t}\n\n\t\theaders = {\n\t\t\t'Host': 'www.overnitenet.com',\n\t\t\t'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:43.0) Gecko/20100101 Firefox/43.0',\n\t\t\t'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n\t\t\t'Accept-Language': 'en-US,en;q=0.5',\n\t\t\t'Accept-Encoding': 'gzip, deflate',\n\t\t\t'DNT': '1',\n\t\t\t'Referer': 'http://www.overnitenet.com/Web-Track.aspx',\n\t\t\t'Cookie': 'ASP.NET_SessionId=3ncsag55xq0z4vqltg3egbr4',\n\t\t\t'Connection': 'keep-alive'\n\t\t}\n\n\t\t# request the server for the HTML data\n\t\tresponse = requests.post(url,data=data,headers=headers,verify=False)\n\n\t\tself.page = response.content", "response": "Retrieves the page for a given tracking_no."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract the checkpoints from the HTML page and stores them in self. tracking_data.", "response": "def Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\n\t\t# Make sure page is available\n\t\tif self.page is None:\n\t\t\traise Exception(\"The HTML data was not fetched due to some reasons\")\n\n\t\tsoup = BeautifulSoup(self.page,'html.parser')\n\n\t\tif 'Delivery information not found' in self.page:\n\t\t\traise ValueError('The Tracking number is invalid/Tracking number is over 45 days old.')\n\n\t\t# Assign the current status of the shipment\n\n\t\tif 'Delivered on' in self.page:\n\t\t\tself.status = 'C'\n\t\telse:\t\t\t\t\t\t\t\t\t\t\t # The shipment is in Transit\n\t\t\tself.status = 'T'\t\t\t\t\t\t\n\n\t\t# Checkpoints extraction begins here \n\t\t\n\t\ttable = soup.findAll('table',{'cellpadding':'1','cellspacing':'1','border':'1','align':'center','style':\"width:800px;border-color:#034291;\"})[1]\n\t\trows = table.findAll('tr')[1:]\n\n\t\tfor row in rows:\n\n\t\t\t'''\n\t\t\t\tEach row will have 3 columns: Date--Location--Status\n\t\t\t'''\n\t\t\trow_cells = row.findAll('td')\n\t\t\tdate = row_cells[0].string.strip()\n\t\t\tdate = datetime.strptime(date,\"%A, %B %d, %Y\")\n\t\t\tlocation = row_cells[1].find('a').string.strip()\n\t\t\tif location is '':\t\t# ignore the days which are holidays\n\t\t\t\tcontinue\n\t\t\tstatus = row_cells[2].text.strip()\n\t\t\t\n\t\t\tself.tracking_data.append({'status':status,'date':date,'location':location})\n\n\t\t# Sort the checkpoints based on Date and Time --- this is important\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching the raw XML data from the site for a given tracking_no", "response": "def Get_Page(self):\n\t\t'''\n\t\t\tFetches raw XML data from the site for a given tracking_no\n\t\t'''\n\t\turl = 'http://www.gati.com/webservices/gatiicedkttrack.jsp?dktno=' + self.tracking_no\n\t\tresponse = requests.get(url)\n\n\t\tself.page = response.text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts the checkpoints from the page and stores them in self. tracking_data.", "response": "def Extract_Checkpoints(self):\n\t\t'''\n\t\t\tExtract the checkpoints and store in self.tracking_data\n\t\t'''\n\t\tsoup = BeautifulSoup(self.page,'xml')\n\n\t\tif soup.find('result').string.strip() == 'failed':\n\t\t\traise ValueError('The Tracking number is invalid.')\n\n\t\tstatus = soup.find('DOCKET_STATUS').string.strip()\n\n\t\tif status == 'Delivered':\n\t\t\tself.status = 'C'\n\t\telif status == 'Rebooked':\n\t\t\tself.status = 'R'\n\t\telse:\n\t\t\tself.status = 'T'\n\n\t\t# Checkpoints extraction begins here\n\t\trows = soup.findAll('ROW')\n\n\t\tfor row in rows:\n\t\t\t'''\n\t\t\t\tEach row has four columns:\n\t\t\t\t\tdate --- time --- location --- status\n\t\t\t\tMerge #1 and #2\n\t\t\t\tAppend the 3 to self.tracking_data\n\t\t\t'''\n\t\t\tdate = row.find('INTRANSIT_DATE').string.strip()\n\t\t\ttime = row.find('INTRANSIT_TIME').string.strip()\n\t\t\ttry:\n\t\t\t\tlocation = row.find('INTRANSIT_LOCATION').string.strip()\n\t\t\texcept AttributeError:\n\t\t\t\tlocation = ''\n\t\t\tstatus = row.find('INTRANSIT_STATUS').string.strip()\n\t\t\tdate_time = datetime.strptime(' '.join([date,time]),\"%d-%b-%Y %H:%M\")\n\n\t\t\tself.tracking_data.append({'status':status,'date':date_time,'location':location})\n\n\t\t# Sort the checkpoints based on Date and Time --- this is important\n\t\tself.tracking_data = sorted(self.tracking_data, key=lambda k: k['date'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_parsecmdline(argv=[]):\n    # main argument parser\n    parser = argparse.ArgumentParser(prog=PKG_NAME)\n\n    # --version\n    parser.add_argument('--version', action='version', version=version)\n\n    # -c, --config <file_name>\n    parser.add_argument(\"-c\", \"--config\",\n                        action=\"store\",\n                        dest=\"config_file\", default=config.CONF_DEFAULT_FILE,\n                        help=\"specify configuration file to use\")\n\n    # --dry-run\n    parser.add_argument(\"-d\", \"--dry-run\",\n                        action=\"store_true\",  dest=\"dry_run\", default=False,\n                        help=\"don't actually do anything\")\n\n    # --quiet\n    parser.add_argument(\"-q\", \"--quiet\",\n                        action=\"store_true\",  dest=\"log_quiet\", default=False,\n                        help=\"quiet output\")\n\n    # --ll <level>\n    # logging level\n    parser.add_argument(\"--ll\", \"--log-level\",\n                        action=\"store\", type=int,\n                        dest=\"log_lvl\", default=log.LOG_LVL_DEFAULT,\n                        help=\"set logging level\")\n\n    # -l, --log-file\n    parser.add_argument(\"-l\", \"--log-file\",\n                        action=\"store\",\n                        dest=\"log_file\", default=log.LOG_FILE_DEFAULT,\n                        help=\"set log file\")\n\n    # Absorb the options\n    options = parser.parse_args(argv)\n\n    # Set whether we are going to perform a dry run\n    global _opt\n    _opt[\"dry_run\"] = options.dry_run\n\n    # Initiate the log level\n    log.init(threshold_lvl=options.log_lvl,\n             quiet_stdout=options.log_quiet, log_file=options.log_file)\n\n    #\n    # Print the splash\n    #\n    _splash()\n\n    # Merge configuration with a JSON file\n    config_file = os.path.abspath(options.config_file)\n    log.msg(\"Attempting to use configuration file '{config_file}'\"\n            .format(config_file=config_file))\n    try:\n        config.set_from_file(config_file)\n    except FileNotFoundError:\n        raise FileNotFoundError(\"Configuration file '{config_file}' not found!\"\n                                .format(config_file=config_file))", "response": "Parse command line arguments and initialize the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbootstrapping the whole thing", "response": "def init(argv):\n    \"\"\"\n    Bootstrap the whole thing\n\n    :param argv: list of command line arguments\n    \"\"\"\n    # Setting initial configuration values\n    config.set_default({\n        # driver section\n        \"driver\": {},\n        # fs section\n        \"fs\": {},\n        # MongoDB section\n        \"mongodb\": {},\n    })\n\n    # Parse the command line\n    init_parsecmdline(argv[1:])\n\n    # Initiatize the output directory\n    fs.init(dry_run=_opt[\"dry_run\"], **config.get_entry('fs'))\n\n    # This baby will handle UNIX signals\n    signal.signal(signal.SIGINT,  _handle_signal)\n    signal.signal(signal.SIGTERM, _handle_signal)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling any exception in the .", "response": "def _handle_except(e):\n    \"\"\"\n    Handle (log) any exception\n\n    :param e: exception to be handled\n    \"\"\"\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n    log.msg_err(\"Unhandled {e} at {file}:{line}: '{msg}'\"\n                .format(e=exc_type.__name__, file=fname,\n                        line=exc_tb.tb_lineno,  msg=e))\n    log.msg_err(traceback.format_exc())\n    log.msg_err(\"An error has occurred!. \"\n                \"For more details, review the logs.\")\n    return 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread an object from the database.", "response": "def read(self, document, iface, *args, **kwargs):\n        \"\"\"\n        Returns a Deferred that fire the read object.\n        \"\"\"\n        try:\n            document = IReadableDocument(document)\n            mime_type = document.mime_type\n            reader = self.lookup_reader(mime_type, iface)\n            if not reader:\n                msg = (\"No adapter found to read object %s from %s document\"\n                       % (iface.__class__.__name__, mime_type))\n                raise NoReaderFoundError(msg)\n            return reader.read(document, *args, **kwargs)\n        except:\n            return defer.fail(Failure())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting an object to a document.", "response": "def write(self, document, obj, *args, **kwargs):\n        \"\"\"\n        Returns a Deferred that fire the factory result\n        that should be the document.\n        \"\"\"\n        try:\n            document = IWritableDocument(document)\n            mime_type = document.mime_type\n            writer = self.lookup_writer(mime_type, obj)\n            if not writer:\n                msg = (\"No adapter found to write object %s to %s document\"\n                       % (obj.__class__.__name__, mime_type))\n                raise NoWriterFoundError(msg)\n            return writer.write(document, obj, *args, **kwargs)\n        except:\n            return defer.fail(Failure())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delimiter_encodeseq(delimiter, encodeseq, charset):\n    '''Coerce delimiter and encodeseq to unicode and verify that they are not\n       the same'''\n    delimiter = coerce_unicode(delimiter, charset)\n    encodeseq = coerce_unicode(encodeseq, charset)\n    if 1 != len(encodeseq):\n        raise FSQEncodeError(errno.EINVAL, u'encode sequence must be 1'\\\n                             u' character, not {0}'.format(len(encodeseq)))\n    if 1 != len(delimiter):\n        raise FSQEncodeError(errno.EINVAL, u'delimiter must be 1 character,'\\\n                             u' not {0}'.format(len(delimiter)))\n    if delimiter == encodeseq:\n        raise FSQEncodeError(errno.EINVAL, u'delimiter and encoding may not'\\\n                             u' be the same: both: {0}'.format(encodeseq))\n    try:\n        delimiter.encode('ascii')\n    except UnicodeEncodeError:\n        raise FSQEncodeError(errno.EINVAL, u'delimiter must be ascii')\n    try:\n        encodeseq.encode('ascii')\n    except UnicodeEncodeError:\n        raise FSQEncodeError(errno.EINVAL, u'encodeseq must be ascii')\n\n    return delimiter, encodeseq", "response": "Coerce delimiter and encodeseq to unicode and verify that they are not\n       the same"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef uid_gid(user, group, fd=None, path=None):\n    '''Get uid and gid from either uid/gid, user name/group name, or from the\n       environment of the calling process, or optionally from an fd, or\n       optionally from a path'''\n    type_msg = u'{0} must be a string or integer, not: {1}'\n    nosuch_msg = u'no such {0}: {1}'\n    if fd is not None and path is not None:\n        raise ValueError(u'received path and fd arguments, need one or'\\\n                         u' neither, not both.')\n\n    # -1 is don't change for chown/fchown\n    user = -1 if user is None else user\n    group = -1 if group is None else group\n    try:\n        user = int(user)\n    except (TypeError, ValueError):\n        try:\n            user = pwd.getpwnam(user).pw_uid\n        except TypeError:\n            raise TypeError(type_msg.format(u'user', user.__class__.__name__))\n        except KeyError:\n            raise FSQEnvError(errno.EINVAL, nosuch_msg.format(u'user', user))\n    except TypeError:\n        raise TypeError(type_msg.format(u'group', group.__class__.__name__))\n    try:\n        group = int(group)\n    except ValueError:\n        try:\n            group = grp.getgrnam(group).gr_gid\n        except TypeError:\n            raise TypeError(type_msg.format(u'group',\n                            group.__class__.__name__))\n        except KeyError:\n            raise FSQEnvError(errno.EINVAL, nosuch_msg.format(u'group',\n                              group))\n    except TypeError:\n        raise TypeError(type_msg.format(u'group', group.__class__.__name__))\n\n    return user, group", "response": "Get uid and gid from either uid or gid user name or group name or from the caller process s environment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rationalize_file(item_f, charset, mode='rb', lock=False):\n    '''FSQ attempts to treat all file-like things as line-buffered as an\n       optimization to the average case.  rationalize_file will handle file\n       objects, buffers, raw file-descriptors, sockets, and string\n       file-addresses, and will return a file object that can be safely closed\n       in FSQ scope without closing the file in the bounding caller.'''\n    # file, TmpFile, socket, etc ...\n    if hasattr(item_f, 'fileno'):\n        n_fd = os.dup(item_f.fileno())\n        try:\n            _lock(n_fd, lock)\n            # explicitily decrement file ref\n            del item_f\n            return os.fdopen(n_fd)\n        except Exception, e:\n            os.close(n_fd)\n            raise e\n\n    # StringIO, cStringIO, etc ...\n    elif hasattr(item_f, 'readline'):\n        return item_f\n    # raw file descriptor -- e.g. output of pipe\n    elif isinstance(item_f, numbers.Integral):\n        n_fd = os.dup(item_f)\n        try:\n            _lock(n_fd, lock)\n            return os.fdopen(n_fd)\n        except Exception, e:\n            os.close(n_fd)\n            raise e\n\n    # try to open, read+binary, line-buffered\n    f = open(coerce_unicode(item_f, charset), mode, 1)\n    try:\n        _lock(f.fileno(), lock)\n        return f\n    except Exception, e:\n        f.close()\n        raise e", "response": "Attempts to treat all file - like things as line - buffered as an an\n       optimization to the average case."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformat IO and OS error messages for wrapping in FSQExceptions", "response": "def wrap_io_os_err(e):\n    '''Formats IO and OS error messages for wrapping in FSQExceptions'''\n    msg = ''\n    if e.strerror:\n        msg = e.strerror\n    if e.message:\n        msg = ' '.join([e.message, msg])\n    if e.filename:\n        msg = ': '.join([msg, e.filename])\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_ttl_max_tries(tries, enqueued_at, max_tries, ttl):\n    '''Check that the ttl for an item has not expired, and that the item has\n       not exceeded it's maximum allotted tries'''\n    if max_tries > 0 and tries >= max_tries:\n        raise FSQMaxTriesError(errno.EINTR, u'Max tries exceded:'\\\n                               u' {0} ({1})'.format(max_tries, tries))\n    if ttl > 0 and datetime.datetime.now() < enqueued_at + datetime.timedelta(\n            seconds=ttl):\n        raise FSQTTLExpiredError(errno.EINTR, u'TTL Expired:'\\\n                                 u' {0}'.format(ttl))", "response": "Check that the ttl for an item has not expired and that it has not exceeded it s maximum allotted tries."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef camelcase_to_underscores(word):\n    s1 = _FIRST_CAP_RE.sub(r'\\1_\\2', word)\n    return _ALL_CAP_RE.sub(r'\\1_\\2', s1).lower()", "response": "Converts a CamelCase word into an under_score word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping for subprocess. Popen with suppressed output.", "response": "def silent_popen(args, **kwargs):\n    \"\"\"Wrapper for subprocess.Popen with suppressed output.\n\n    STERR is redirected to STDOUT which is piped back to the\n    calling process and returned as the result.\n    \"\"\"\n    return subprocess.Popen(args,\n                            stderr=subprocess.STDOUT,\n                            stdout=subprocess.PIPE, **kwargs).communicate()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the version - string version - info from added_value / version. py.", "response": "def read_version():\n    \"Read the `(version-string, version-info)` from `added_value/version.py`.\"\n    version_file = local_file('source', 'added_value', 'version.py')\n    local_vars = {}\n    with open(version_file) as handle:\n        exec(handle.read(), {}, local_vars)  # pylint: disable=exec-used\n    return local_vars['__version__']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(cls, service=Service(), private=False):\n        response = service.send(SRequest('POST', cls.path, data={'private': private}))\n        return cls.from_response(response, service=service)", "response": "create a new bin instance on the server"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches given bin from the service", "response": "def get(cls, name, service=Service()):\n        '''fetch given bin from the service'''\n        path = pathjoin(cls.path, name)\n        response = service.send(SRequest('GET', path))\n        return cls.from_response(response, service=service)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reload(self):\n        '''reload self from self.service'''\n        other = type(self).get(self.name, service=self.service)\n        self.request_count = other.request_count", "response": "reload self from self. service"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the api url of self", "response": "def api_url(self):\n        '''return the api url of self'''\n        return pathjoin(Bin.path, self.name, url=self.service.url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef requests(self):\n        '''return accumulated requests to this bin'''\n        path = pathjoin(self.path, self.name, Request.path)\n        response = self.service.send(SRequest('GET', path))\n        # a bin behaves as a push-down store --- better to return the requests\n        # in order of appearance\n        return list(reversed(Request.from_response(response, bin=self)))", "response": "return accumulated requests to this bin"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming a get request to a given url. Returns an empty str on error.", "response": "def get(url, last_modified=None):\n    \"\"\"Performs a get request to a given url. Returns an empty str on error.\n    \"\"\"\n    try:\n        with closing(urllib2.urlopen(url)) as page:\n            if last_modified is not None:\n                last_mod = dateutil.parser.parse(dict(page.info())['last-modified'])\n                if last_mod <= last_modified:\n                    return \"\"\n            return page.read()\n    except urllib2.URLError:\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_rocs_files(url=ROCS_URL):\n    soup = BeautifulSoup(get(url))\n    if not url.endswith('/'):\n        url += '/'\n    files = []\n    for elem in soup.findAll('a'):\n        if elem['href'].startswith('?'):\n            continue\n        if elem.string.lower() == 'parent directory':\n            continue\n        files.append(url + elem['href'])\n    return files", "response": "Gets the contents of the given url."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the path for the metadata block that is not already in the xml file.", "response": "def _create_path(self,xpath):\n        \"\"\"\n        Started to write an xpath parser to create the specified path but there are many\n        ways to specify a path in xpath - it is too expressive. This is not a sensible\n        thing to do from inside a property function. Let it return an error unless the\n        path exists and add helper functions to create the specific metadata block that is\n        required.\n        \"\"\"\n        raise NotImplementedError()\n\n        split_path = xpath.split('/')\n        test_paths = ['/'.join(sp[:i+1]) for i in range(1, len(split_path))]\n\n        for path in reversed(test_paths):\n            result = self._eval_xpath(path)\n            result_length = len(result)\n            if  result_length == 0:\n                # Still no elements found\n                continue\n            elif result_length == 1:\n                result = result[0]\n                break\n            else:\n                raise XmlDogmaException('Invalid xpath expression \"%s\" returns more than one element!' % xpath)\n\n        else:\n            raise XmlDogmaException('Root element \"%s\" of xpath expression \"%s\" not found while trying to create path.' % (path, xpath))\n\n        existing_elemet = result\n        existing_path = path\n        existing_index = test_paths.index(existing_path)\n\n        for new_element in split_path[existing_index+1:]:\n\n            #Regex it!\n            # 'employee[secretary][assistant]' => ['employee', 'secretary', 'assistant', '']\n            # 'toy[attribute::color = \"red\"]' => ['toy', 'attribute::color = \"red\"', '']\n            parts = re.split('\\[(.*?)\\]',new_element)\n            #@TODO - find a better regex that does not include one empty string for each bracket\n            try:\n                while True:\n                    parts.remove('')\n            except ValueError:\n                pass\n\n            tag = parts[0]\n            predicates = parts[1:]\n\n            e = etree.Element(tag)\n\n\n            ### Did not finish implementing... see comment above about why its a bad idea\n            for predicate in predicates:\n                if predicate.isdigit():\n                    # it is specifying where to insert this child\n                    pass\n                elif predicate.startswith('@'):\n                    #parse the attribute and set it...\n                    pass\n                else:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _eval_xpath(self, xpath):\n        if isinstance(xpath, etree.XPath):\n            result = xpath(self._dataObject)\n        else:\n            result = self._dataObject.xpath(xpath,namespaces=self._namespaces)\n\n        #print 'Xpath expression:', xpath\n        #print etree.tostring(self._dataObject)\n        #print 'Got Result: \\n%s\\n   End Result' % result\n\n        return result", "response": "Evaluates xpath expressions.\n\n        Either string or XPath object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nevaluating the teaching function.", "response": "def _eval(self, teaching):\n        \"\"\"\n        Returns the evaluation.\n        \"\"\"\n        # transform if someone called _get directly\n        if isinstance(teaching, string_types):\n            teaching = self._validate_teaching(None, teaching, namespaces=self._namespaces)\n\n        return teaching(self._dataObject)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a value and return current average.", "response": "def add(self, value):\n        \"\"\"Add a value, and return current average.\"\"\"\n        self._data.append(value)\n        if len(self._data) > self._max_count:\n            self._data.popleft()\n        return sum(self._data)/len(self._data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nflasking application factory function.", "response": "def create_app():\n    \"\"\"Flask application factory function.\"\"\"\n    app = Flask(__name__)\n    app.config_from_envvar = app.config.from_envvar\n    app.config_from_object = app.config.from_object\n    configure_app(app)\n    init_core(app)\n    register_blueprints(app)\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching the data dictionary for the key - value pair in the path.", "response": "def search(path: str, data: typing.Union[list, dict], default=_UNSET,\n           smart_unique: bool=True) -> typing.Union[int, float, bool, str, list, dict, None]:\n    \"\"\"\n    when not found:\n    if raise_not_found is true, raise NotFoundError, else return default value.\n    \"\"\"\n    expr = parse(path)\n    resp = expr.find(data)\n\n    if not resp:\n        if default is _UNSET:\n            raise NotFoundError(\"Can't find by path: {}\".format(path))\n        else:\n            return default\n\n    if len(resp) == 1 and smart_unique:\n        return resp[0].value\n    else:\n        return [match.value for match in resp]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_sql(engine):\n    Session.configure(bind=engine)\n    Base.metadata.bind = engine", "response": "Configure session and metadata with the database engine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the database schema.", "response": "def create_schema(alembic_config_ini=None):\n    \"\"\"Create the database schema.\n\n    :param alembic_config_ini: When provided, stamp with the current revision\n    version.\n\n    \"\"\"\n    Base.metadata.create_all()\n    if alembic_config_ini:\n        from alembic.config import Config\n        from alembic import command\n        alembic_cfg = Config(alembic_config_ini)\n        command.stamp(alembic_cfg, 'head')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef populate_database():\n    if User.fetch_by(username='admin'):\n        return\n\n    # Admin user\n    admin = User(name='Administrator', password='password',\n                 username='admin', is_admin=True)\n    # Class\n    class_ = Class(name='CS32')\n    Session.add(class_)\n    Session.flush()\n\n    # Project\n    project = Project(name='Project 1', class_id=class_.id)\n    Session.add(project)\n    Session.flush()\n\n    # File verification\n    fv = FileVerifier(filename='test.c', min_size=3, min_lines=1,\n                      project_id=project.id)\n\n    Session.add_all([admin, fv])\n    try:\n        transaction.commit()\n        print('Admin user created')\n    except IntegrityError:\n        transaction.abort()", "response": "Populate the database with some data useful for development."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_edit(self, user):\n        return user.is_admin or not self.is_locked and self in user.admin_for", "response": "Return whether or not user can make changes to the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_view(self, user):\n        # Perform simplest checks first\n        if user.is_admin or self in user.files:\n            return True\n        elif user.admin_for:  # Begin more expensive comparisions\n            # Single-indirect lookup\n            classes = set(x.class_ for x in self.makefile_for_projects)\n            if classes.intersection(user.admin_for):\n                return True\n            # Double indirect lookups\n            classes = set(x.project.class_ for x in self.build_files)\n            if classes.intersection(user.admin_for):\n                return True\n            classes = set(x.project.class_ for x in self.execution_files)\n            if classes.intersection(user.admin_for):\n                return True\n            # Triple-indirect lookups\n            classes = set(x.testable.project.class_ for x in self.expected_for)\n            if classes.intersection(user.admin_for):\n                return True\n            classes = set(x.testable.project.class_ for x in self.stdin_for)\n            if classes.intersection(user.admin_for):\n                return True\n            classes = set(x.submission.project.class_ for x in\n                          self.submission_assocs)\n            if classes.intersection(user.admin_for):\n                return True\n            # 4x-indirect lookups\n            classes = set(x.test_case.testable.project.class_ for x\n                          in self.test_case_result_for)\n            if classes.intersection(user.admin_for):\n                return True\n        return False", "response": "Return True if the user can view the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef can_view(self, user):\n        return user.is_admin or user in self.users \\\n            or self.project.class_ in user.admin_for", "response": "Return whether or not user can view info about the group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_access(self, user):\n        return self.class_.is_admin(user) or \\\n            self.is_ready and self.class_ in user.classes", "response": "Return whether or not user can access a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns whether or not user can make changes to the project.", "response": "def can_edit(self, user):\n        \"\"\"Return whether or not `user` can make changes to the project.\"\"\"\n        return self.class_.can_edit(user) and self.status != u'locked'"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef points_possible(self, include_hidden=False):\n        return sum([test_case.points for testable in self.testables\n                    for test_case in testable.test_cases\n                    if include_hidden or not testable.is_hidden])", "response": "Return the total number of points possible for this project."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a list of the most recent submissions for each user.", "response": "def recent_submissions(self):\n        \"\"\"Generate a list of the most recent submissions for each user.\n\n        Only yields a submission for a user if they've made one.\n\n        \"\"\"\n        for group in self.groups:\n            submission = Submission.most_recent_submission(self, group)\n            if submission:\n                yield submission"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef submit_string(self):\n        required = []\n        optional = []\n        for file_verifier in self.file_verifiers:\n            if file_verifier.optional:\n                optional.append('[{0}]'.format(file_verifier.filename))\n            else:\n                required.append(file_verifier.filename)\n        return ' '.join(sorted(required) + sorted(optional))", "response": "Return a string specifying the files to submit for this project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_submission(self, base_path, submission, update):\n        results = VerificationResults()\n        valid_files = set()\n        file_mapping = submission.file_mapping()\n\n        # Create a list of in-use file verifiers\n        file_verifiers = set(fv for testable in self.testables\n                             for fv in testable.file_verifiers)\n\n        for fv in file_verifiers:\n            if fv.filename in file_mapping:\n                errors, warnings = fv.verify(base_path,\n                                             file_mapping[fv.filename])\n                if errors:\n                    results.set_errors_for_filename(errors, fv.filename)\n                else:\n                    valid_files.add(fv.filename)\n                if warnings:\n                    results.set_warnings_for_filename(warnings, fv.filename)\n                del file_mapping[fv.filename]\n            elif not fv.optional:\n                results.set_errors_for_filename(['missing'], fv.filename)\n        if file_mapping:\n            results.set_extra_filenames(frozenset(file_mapping.keys()))\n\n        # Determine valid testables\n        retval = []\n        for testable in self.testables:\n            missing = frozenset(x.filename for x in testable.file_verifiers\n                                if not x.optional) - valid_files\n            if missing:\n                results._missing_to_testable_ids.setdefault(\n                    missing, set()).add(testable.id)\n            elif testable.file_verifiers:\n                retval.append(testable)\n\n        if update:\n            # Reset existing attributes\n            submission.test_case_results = []\n            submission.testable_results = []\n            # Set new information\n            submission.verification_results = results\n            submission.verified_at = func.now()\n        return retval", "response": "Return list of testables that can be built."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the submission immediately prior to the given submission.", "response": "def earlier_submission_for_group(submission):\n        \"\"\"Return the submission immediately prior to the given submission.\"\"\"\n        return (Submission\n                .query_by(project=submission.project, group=submission.group)\n                .filter(Submission.created_at < submission.created_at)\n                .order_by(Submission.created_at.desc()).first())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef later_submission_for_group(submission):\n        return (Submission\n                .query_by(project=submission.project, group=submission.group)\n                .filter(Submission.created_at > submission.created_at)\n                .order_by(Submission.created_at).first())", "response": "Return the submission immediately prior to the given submission."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef most_recent_submission(project, group):\n        return (Submission.query_by(project=project, group=group)\n                .order_by(Submission.created_at.desc()).first())", "response": "Return the most recent submission for the user and project id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef can_view(self, user):\n        return user in self.group.users or self.project.can_view(user)", "response": "Return whether or not user can view the submission."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_delay(self, update):\n        if hasattr(self, '_delay'):\n            return self._delay\n\n        now = datetime.now(UTC())\n        zero = timedelta(0)\n        delay = self.project.delay - (now - self.created_at)\n        if delay <= zero:  # Never delay longer than the project's delay time\n            self._delay = None\n        elif self.group.viewed_at is None:  # Don't delay\n            if update:\n                self.group.viewed_at = func.now()\n            self._delay = None\n        elif self.created_at <= self.group.viewed_at:  # Show older results\n            self._delay = None\n        else:\n            pv_delay = self.project.delay - (now - self.group.viewed_at)\n            if pv_delay <= zero:\n                if update:  # Update the counter\n                    self.group.viewed_at = func.now()\n                self._delay = None\n            else:\n                self._delay = min(delay, pv_delay).total_seconds() / 60\n        return self._delay", "response": "Return the minutes to delay the viewing of submission results. Only store information into the datebase when update is set."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the number of points awarded to this submission.", "response": "def points(self, include_hidden=False):\n        \"\"\"Return the number of points awarded to this submission.\"\"\"\n        return sum(x.points for x in self.testable_results\n                   if include_hidden or not x.testable.is_hidden)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify(self, base_path, update=False):\n        return self.project.verify_submission(base_path, self, update=update)", "response": "Verify the submission and return testables that can be executed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake the class of the item that we want to query along with a potential instance of that class.", "response": "def get_value(cls, value):\n        '''Takes the class of the item that we want to\n        query, along with a potential instance of that class.\n        If the value is an instance of int or basestring, then\n        we will treat it like an id for that instance.'''\n        if isinstance(value, (basestring, int)):\n            value = cls.fetch_by(id=value)\n        return value if isinstance(value, cls) else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login(username, password, development_mode=False):\n        retval = None\n        try:\n            user = User.fetch_by(username=username)\n            if user and (development_mode or user.verify_password(password)):\n                retval = user\n        except OperationalError:\n            pass\n        return retval", "response": "Return the user if successful None otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_join_group(self, project):\n        if project.class_.is_locked or project.group_max < 2:\n            return False\n        u2g = self.fetch_group_assoc(project)\n        if u2g:\n            return len(list(u2g.group.users)) < project.group_max\n        return True", "response": "Return whether or not user can join a group on project."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning whether or not user can view information about the user.", "response": "def can_view(self, user):\n        \"\"\"Return whether or not `user` can view information about the user.\"\"\"\n        return user.is_admin or self == user \\\n            or set(self.classes).intersection(user.admin_for)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all the classes that this user can admin for.", "response": "def classes_can_admin(self):\n        \"\"\"Return all the classes (sorted) that this user can admin.\"\"\"\n        if self.is_admin:\n            return sorted(Session.query(Class).all())\n        else:\n            return sorted(self.admin_for)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\njoining the users in a group.", "response": "def group_with(self, to_user, project, bypass_limit=False):\n        \"\"\"Join the users in a group.\"\"\"\n        from_user = self\n        from_assoc = from_user.fetch_group_assoc(project)\n        to_assoc = to_user.fetch_group_assoc(project)\n\n        if from_user == to_user or from_assoc == to_assoc and from_assoc:\n            raise GroupWithException('You are already part of that group.')\n\n        if not from_assoc and not to_assoc:\n            to_assoc = UserToGroup(group=Group(project=project),\n                                   project=project, user=to_user)\n            Session.add(to_assoc)\n            from_count = 1\n        elif not to_assoc:\n            from_assoc, to_assoc = to_assoc, from_assoc\n            from_user, to_user = to_user, from_user\n            from_count = 1\n        elif not from_assoc:\n            from_count = 1\n        elif to_assoc.user_count > from_assoc.user_count:\n            from_assoc, to_assoc = to_assoc, from_assoc\n            from_user, to_user = to_user, from_user\n            from_count = from_assoc.user_count\n        else:\n            from_count = from_assoc.user_count\n\n        if not bypass_limit and \\\n                project.group_max < to_assoc.user_count + from_count:\n            raise GroupWithException('There are too many users to join that '\n                                     'group.')\n\n        if from_assoc:  # Move the submissions and users\n            old_group = from_assoc.group\n            for submission in from_assoc.group.submissions[:]:\n                submission.group = to_assoc.group\n            for assoc in from_assoc.group.group_assocs[:]:\n                assoc.group = to_assoc.group\n            if to_assoc.group.viewed_at is None:\n                to_assoc.group.viewed_at = old_group.viewed_at\n            elif old_group.viewed_at:\n                to_assoc.group.viewed_at = max(old_group.viewed_at,\n                                               to_assoc.group.viewed_at)\n            Session.delete(old_group)\n        else:  # Add the user to the group\n            from_assoc = UserToGroup(group=to_assoc.group, project=project,\n                                     user=from_user)\n            Session.add(from_assoc)\n\n        # Update the group's submissions' files' permissions\n        files = set(assoc.file for sub in to_assoc.group.submissions\n                    for assoc in sub.files)\n        for user in to_assoc.group.users:\n            user.files.update(files)\n\n        return to_assoc.group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if an allocation is used by any of the partners.", "response": "def allocation_used(self, state, allocation_id):\n        '''\n        Checks if allocation is used by any of the partners.\n        If allocation does not exist returns False.\n        @param allocation_id: ID of the allocation\n        @returns: True/False\n        '''\n        return len(filter(lambda x: x.allocation_id == allocation_id,\n                          state.partners.all)) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter_macro(func, *args, **kwargs):\n    filter_partial = partial(func, *args, **kwargs)\n\n    class FilterMacroMeta(FilterMeta):\n        @staticmethod\n        def __new__(mcs, name, bases, attrs):\n            # This is as close as we can get to running\n            # ``update_wrapper`` on a type.\n            for attr in WRAPPER_ASSIGNMENTS:\n                if hasattr(func, attr):\n                    attrs[attr] = getattr(func, attr)\n\n            # Note that we ignore the ``name`` argument, passing in\n            # ``func.__name__`` instead.\n            return super(FilterMacroMeta, mcs)\\\n                .__new__(mcs, func.__name__, bases, attrs)\n\n        def __call__(cls, *runtime_args, **runtime_kwargs):\n            return filter_partial(*runtime_args, **runtime_kwargs)\n\n    class FilterMacro(with_metaclass(FilterMacroMeta, FilterMacroType)):\n        # This method will probably never get called due to overloaded\n        # ``__call__`` in the metaclass, but just in case, we'll include\n        # it because it is an abstract method in `BaseFilter`.\n        def _apply(self, value):\n            # noinspection PyProtectedMember\n            return self.__class__()._apply(value)\n\n    return FilterMacro", "response": "Promotes a function that returns a filter into its own filter type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pathjoin(*parts, **kvs):\n    '''join path parts into a path; in case url is not none, use that, too'''\n    url = kvs.pop('url', '/')\n    url = url + '/' + '/'.join(parts)\n    url = normalize_url(url)\n    return url", "response": "join path parts into a path ; in case url is not none use that too"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef verify(info, directory_path):\n    base_path = os.path.join(directory_path, info['name'])\n    if 'length' in info:\n        if os.stat(base_path).st_size != info['length']:\n            return False\n        getfile = lambda: open(base_path, 'rb')\n    else:\n        assert 'files' in info, 'invalid torrent file'\n        for f in info['files']:\n            p = os.path.join(base_path, *f['path'])\n            if os.stat(p).st_size != f['length']:\n                return False\n        getfile = lambda: ConcatenatedFile(base_path, info['files'])\n    with getfile() as f:\n        return compare_checksum(info, f)", "response": "Verify that the checksum values in the torrent file matches the computed checksum values of downloaded files in the directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the checksum values in the info dictionary match the computed checksum values of file content.", "response": "def compare_checksum(info, f):\n    \"\"\"Return True if the checksum values in the info dictionary match the\n    computed checksum values of file content.\n    \"\"\"\n    pieces = info['pieces']\n\n    def getchunks(f, size):\n        while True:\n            chunk = f.read(size)\n            if chunk == '':\n                break\n            yield hashlib.sha1(chunk).digest()\n\n    calc = getchunks(f, info['piece length'])\n    ref = (pieces[i:i + 20] for i in xrange(0, len(pieces), 20))\n    for expected, actual in itertools.izip(calc, ref):\n        if expected != actual:\n            return False\n    return ensure_empty(calc) and ensure_empty(ref)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure global log level to given one", "response": "def configure_logging(level):\n    \"\"\"\n    Configure global log level to given one\n    :param level: Level (INFO | DEBUG | WARN | ERROR)\n    :return:\n    \"\"\"\n\n    global logging_level\n    logging_level = logging.ERROR\n    if \"info\" == level.lower():\n        logging_level = logging.INFO\n    elif \"warn\" == level.lower():\n        logging_level = logging.WARNING\n    elif \"debug\" == level.lower():\n        logging_level = logging.DEBUG"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_pretty_body(headers, body):\n\n    if HEADER_CONTENT_TYPE in headers:\n        if HEADER_REPRESENTATION_XML == headers[HEADER_CONTENT_TYPE]:\n            xml_parsed = parseString(body)\n            pretty_xml_as_string = xml_parsed.toprettyxml()\n            return pretty_xml_as_string\n        else:\n            if HEADER_REPRESENTATION_JSON in headers[HEADER_CONTENT_TYPE]:\n                parsed = json.loads(body)\n                return json.dumps(parsed, sort_keys=True, indent=4)\n            else:\n                return body\n    else:\n        return body", "response": "Return a pretty printed body using the Content - Type header information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef log_print_request(logger, method, url, query_params=None, headers=None, body=None):\n\n    log_msg = '>>>>>>>>>>>>>>>>>>>>> Request >>>>>>>>>>>>>>>>>>> \\n'\n    log_msg += '\\t> Method: %s\\n' % method\n    log_msg += '\\t> Url: %s\\n' % url\n    if query_params is not None:\n        log_msg += '\\t> Query params: {}\\n'.format(str(query_params))\n    if headers is not None:\n        log_msg += '\\t> Headers: {}\\n'.format(str(headers))\n    if body is not None:\n        log_msg += '\\t> Payload sent:\\n {}\\n'.format(_get_pretty_body(headers, body))\n\n    logger.debug(log_msg)", "response": "Log an HTTP request data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_print_response(logger, response):\n\n    log_msg = '<<<<<<<<<<<<<<<<<<<<<< Response <<<<<<<<<<<<<<<<<<\\n'\n    log_msg += '\\t< Response code: {}\\n'.format(str(response.status_code))\n    log_msg += '\\t< Headers: {}\\n'.format(str(dict(response.headers)))\n    try:\n        log_msg += '\\t< Payload received:\\n {}'.format(_get_pretty_body(dict(response.headers), response.content))\n    except ValueError:\n        log_msg += '\\t< Payload received:\\n {}'.format(_get_pretty_body(dict(response.headers), response.content.text))\n\n    logger.debug(log_msg)", "response": "Log an HTTP response to logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace(text, old, new, count=None, strip=False):\n    '''\n    Replace an ``old`` subset of ``text`` with ``new``.\n    \n    ``old`` type may be either a string or regular expression.\n    \n    If ``strip``, remove all leading/trailing whitespace.\n    \n    If ``count``, replace the specified number of occurence, otherwise replace all.\n    '''\n    if is_string(old):\n        text = text.replace(old, new, -1 if count is None else count)\n    else:\n        text = old.sub(new, text, 0 if count is None else count)\n    \n    if strip:\n        text = text.strip(None if strip == True else strip)\n    \n    return text", "response": "Replace an old subset of text with new."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlikes replace but returns a new string.", "response": "def remove(text, what, count=None, strip=False):\n    '''\n    Like ``replace``, where ``new`` replacement is an empty string.\n    '''\n    return replace(text, what, '', count=count, strip=strip)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_each(text, items, count=None, strip=False):\n    '''\n    Like ``replace``, where each occurrence in ``items`` is a 2-tuple of \n    ``(old, new)`` pair.\n    '''\n    for a,b in items:\n        text = replace(text, a, b, count=count, strip=strip)\n    return text", "response": "Like replace but for each occurrence in items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nliking remove but returns text with items removed.", "response": "def remove_each(text, items, count=None, strip=False):\n    '''\n    Like ``remove``, where each occurrence in ``items`` is ``what`` to remove.\n    '''\n    for item in items:\n        text = remove(text, item, count=count, strip=strip)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if what occurs in text.", "response": "def matches(text, what):\n    '''\n    Check if ``what`` occurs in ``text``\n    \n    '''\n    return text.find(what) > -1 if is_string(what) else what.match(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for what in the iterable data and return the index of the first match. Return None if no match found.", "response": "def find_first(data, what):\n    '''\n    Search for ``what`` in the iterable ``data`` and return the index of the \n    first match. Return ``None`` if no match found.\n    '''\n    for i, line in enumerate(data):\n        if contains(line, what):\n            return i\n            \n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef splitter(text, token=None, expected=2, default='', strip=False):\n    '''\n    Split ``text`` by ``token`` into at least ``expected`` number of results.\n    \n    When ``token`` is ``None``, the default for Python ``str.split`` is used, \n    which will split on all whitespace.\n    \n    ``token`` may also be a regex.\n    \n    If actual number of results is less than ``expected``, pad with ``default``.\n    \n    If ``strip``, than do just that to each result.\n    '''\n    if is_string(token) or token is None:\n        bits = text.split(token, expected - 1)\n    else:\n        bits = [s for s in token.split(text, expected) if s]\n        \n    if strip:\n        bits = [s.strip() for s in bits]\n    \n    n = len(bits)\n    while n < expected:\n        bits.append(default)\n        n += 1\n    \n    return bits", "response": "Split text by token into at least expected number of results."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef versioned_static(file_path):\n\n    full_path = find(file_path)\n    url = static(file_path)\n\n    if type(full_path) is list and len(full_path) > 0:\n        full_path = full_path[0]\n\n    if not full_path:\n        msg = 'Could not find static file: {0}'.format(file_path)\n        logger.warning(msg)\n        return url\n\n    # Use MD5 as we care about speed a lot\n    # and not security in this case\n    file_hash = md5()\n    with open(full_path, \"rb\") as file_contents:\n        for chunk in iter(lambda: file_contents.read(4096), b\"\"):\n            file_hash.update(chunk)\n\n    return url + '?v=' + file_hash.hexdigest()[:7]", "response": "Given a path for a static file Output a url path with a hex has query string for versioning\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef progbar(iterable, *a, verbose=True, **kw):\n    iterable = range(iterable) if isinstance(iterable, int) else iterable\n    if verbose:\n        return _tqdm(iterable, *a, **kw)\n    else:\n        return iterable", "response": "Prints a progress bar at the given iterable"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parallel_progbar(mapper, iterable, nprocs=None, starmap=False, flatmap=False, shuffle=False,\n                     verbose=True, verbose_flatmap=None, **kwargs):\n    \"\"\"Performs a parallel mapping of the given iterable, reporting a progress bar as values get returned\n\n    :param mapper: The mapping function to apply to elements of the iterable\n    :param iterable: The iterable to map\n    :param nprocs: The number of processes (defaults to the number of cpu's)\n    :param starmap: If true, the iterable is expected to contain tuples and the mapper function gets each element of a\n        tuple as an argument\n    :param flatmap: If true, flatten out the returned values if the mapper function returns a list of objects\n    :param shuffle: If true, randomly sort the elements before processing them. This might help provide more uniform\n        runtimes if processing different objects takes different amounts of time.\n    :param verbose: Whether or not to print the progress bar\n    :param verbose_flatmap: If performing a flatmap, whether or not to report each object as it's returned\n    :param kwargs: Any other keyword arguments to pass to the progress bar (see ``progbar``)\n    :return: A list of the returned objects, in the same order as provided\n    \"\"\"\n\n    results = _parallel_progbar_launch(mapper, iterable, nprocs, starmap, flatmap, shuffle, verbose, verbose_flatmap, **kwargs)\n    return [x for i, x in sorted(results, key=lambda p: p[0])]", "response": "Performs a parallel mapping of the given iterable returning a list of objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms a parallel mapping of the given iterable returning a list of objects that get returned by the parallel map.", "response": "def iparallel_progbar(mapper, iterable, nprocs=None, starmap=False, flatmap=False, shuffle=False,\n                      verbose=True, verbose_flatmap=None, max_cache=-1, **kwargs):\n    \"\"\"Performs a parallel mapping of the given iterable, reporting a progress bar as values get returned. Yields\n    objects as soon as they're computed, but does not guarantee that they'll be in the correct order.\n\n    :param mapper: The mapping function to apply to elements of the iterable\n    :param iterable: The iterable to map\n    :param nprocs: The number of processes (defaults to the number of cpu's)\n    :param starmap: If true, the iterable is expected to contain tuples and the mapper function gets each element of a\n        tuple as an argument\n    :param flatmap: If true, flatten out the returned values if the mapper function returns a list of objects\n    :param shuffle: If true, randomly sort the elements before processing them. This might help provide more uniform\n        runtimes if processing different objects takes different amounts of time.\n    :param verbose: Whether or not to print the progress bar\n    :param verbose_flatmap: If performing a flatmap, whether or not to report each object as it's returned\n    :param max_cache: Maximum number of mapped objects to permit in the queue at once\n    :param kwargs: Any other keyword arguments to pass to the progress bar (see ``progbar``)\n    :return: A list of the returned objects, in whatever order they're done being computed\n    \"\"\"\n\n    results = _parallel_progbar_launch(mapper, iterable, nprocs, starmap, flatmap, shuffle, verbose,\n                                       verbose_flatmap, max_cache, **kwargs)\n    return (x for i, x in results)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_isodate(value, strict=False):\n    if value or strict:\n        return arrow.get(value).date()", "response": "Convert an ISO formatted date into a Date object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_isodatetime(value, strict=False):\n    if value or strict:\n        return arrow.get(value).datetime", "response": "Convert an ISO formatted datetime into a Date object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_arrow(value, format_string):\n    assert isinstance(value, arrow.Arrow)\n    return value.format(format_string)", "response": "Format an arrow datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsynthesize command line parameters e. g. [ struct. cssr struct. vsa 2. 4 ]", "response": "def cmdline_params(self, structure_file_name, surface_sample_file_name):\n        \"\"\"Synthesize command line parameters\n\n        e.g. [ ['struct.cssr'], ['struct.vsa'], [2.4]]\n        \"\"\"\n        parameters = []\n\n        parameters += [structure_file_name]\n        parameters += [surface_sample_file_name]\n\n        pm_dict = self.get_dict()\n\n        # replace sampling method string by number\n        pm_dict['sampling_method'] = sampling_methods[pm_dict[\n            'sampling_method']]\n\n        # order matters here!\n        for key in [\n                'accessible_surface_area',\n                'sampling_density',\n                'output_surface',\n                'target_volume',\n                'sampling_method',\n                'cubic_target',\n        ]:\n            parameters.append(pm_dict[key])\n\n        return map(str, parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning list of output files to be retrieved", "response": "def output_files(self):\n        \"\"\"Return list of output files to be retrieved\"\"\"\n        output_list = []\n\n        pm_dict = self.get_dict()\n        output_list.append(pm_dict['output_surface'])\n        if pm_dict['target_volume'] != 0.0:\n            output_list.append(pm_dict['output_surface'] + str(\".cell\"))\n\n        return output_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef output_links(self):\n        output_links = []\n\n        pm_dict = self.get_dict()\n        output_links.append('surface_sample')\n        if pm_dict['target_volume'] != 0.0:\n            output_links.append('cell')\n\n        return output_links", "response": "Return list of output link names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exec(self, args):\n\n        logger.debug(\"update %s\", args.update)\n        self.update(args.update)", "response": "todo Docstring for exec\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncopy from twsited.internet.defer and add a check to detect fibers.", "response": "def maybeDeferred(f, *args, **kw):\n    \"\"\"\n    Copied from twsited.internet.defer and add a check to detect fibers.\n    \"\"\"\n    try:\n        result = f(*args, **kw)\n    except Exception:\n        return fail(failure.Failure())\n\n    if IFiber.providedBy(result):\n        import traceback\n        frames = traceback.extract_stack()\n        msg = \"%s returned a fiber instead of a deferred\" % (f, )\n        if len(frames) > 1:\n            msg += \"; called from %s\" % (frames[-2], )\n        raise RuntimeError(msg)\n\n    if isinstance(result, Deferred):\n        return result\n    elif isinstance(result, failure.Failure):\n        return fail(result)\n    else:\n        return succeed(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nappend a station to the database.", "response": "def append(self, station):\n        \"\"\" Append station to database.\n\n        Returns the index of the appended station.\n\n        \"\"\"\n        rec = station._pack(self)\n        with self:\n            _libtcd.add_tide_record(rec, self._header)\n            return self._header.number_of_records - 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump the tide record at the specified index to stderr.", "response": "def dump_tide_record(self, i):\n        \"\"\" Dump tide record to stderr (Debugging only.)\n        \"\"\"\n        with self:\n            rec = _libtcd.read_tide_record(i)\n            if rec is None:\n                raise IndexError(i)\n            _libtcd.dump_tide_record(rec)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to dabatase checks the version and creates the design document used by feat.", "response": "def configure_replicator_database(host, port, username=None, password=None):\n    \"\"\"\n    Connects to dabatase, checks the version and creates the\n    design document used by feat (if it doesn't exist).\n\n    @returns: IDatabaseConnection bound to _replicator database\n    \"\"\"\n    database = driver.Database(host, port, '_replicator', username, password)\n    connection = database.get_connection()\n    version = yield database.get_version()\n    if version < (1, 1, 0):\n        database.disconnect()\n        raise ValueError(\"Found couchdb version %r. \"\n                         \"_replicator database has been introduced in 1.1.0.\" %\n                         (version, ))\n    design_docs = view.DesignDocument.generate_from_views([Replications])\n    for doc in design_docs:\n        try:\n            doc2 = yield connection.get_document(doc.doc_id)\n            if doc.views != doc2.views or doc.filters != doc2.filters:\n                doc.rev = doc2.rev\n                yield connection.save_document(doc)\n\n        except NotFoundError:\n            yield connection.save_document(doc)\n    defer.returnValue(connection)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cleanup_logs(connection, rconnection):\n    '''\n    Perform a cleanup of update logs.\n    This methods analazyes what replication are configured and removes\n    the update logs which we will not need in future.\n    It returns the C{int} counter of performed deletes.\n    '''\n    source = connection.database.db_name\n    statuses = yield get_replication_status(rconnection, source)\n\n    counters = dict((name, max([row[0] for row in replications]))\n                    for name, replications in statuses.iteritems())\n    cleanup_seq = min(counters.values()) if statuses else None\n    own_tag = yield connection.get_database_tag()\n\n    context = dict()\n    context['deletes_count'] = 0 # this is returned as a result\n    context['connection'] = connection\n\n    # this is cleanup for the update logs created locally\n    keys = UpdateLogs.until_seq(own_tag, cleanup_seq)\n    rows = yield connection.query_view(UpdateLogs, **keys)\n\n    @defer.inlineCallbacks\n    def clean_local(context, row):\n        connection = context['connection']\n        in_conflict, raw_doc = yield _check_conflict(connection, row[1])\n        if not in_conflict:\n            context['deletes_count'] += 1\n            yield _cleanup_update_log(connection, row[2])\n\n    yield itask.coiterate((clean_local(context, row) for row in rows))\n\n    # this is cleanup of the update logs imported from remote partinions\n    # they should be cleaned up if the document is not in conflict state\n    rows = yield connection.query_view(UpdateLogs, **UpdateLogs.all())\n    grouped = _group_rows(rows,\n                          # (partition_tag, owner_id)\n                          key=lambda row: (row[0][1], row[0][2]),\n                          # (rev, doc_id)\n                          value=lambda row: (row[0][3], row[2]))\n\n    @defer.inlineCallbacks\n    def clean_imported(context, partition_tag, owner_id, entries):\n        connection = context['connection']\n        if partition_tag == own_tag:\n            # this is local update log, this is handeled by the code above\n            return\n\n        in_conflict, raw_doc = yield _check_conflict(connection, owner_id)\n        last_rev = entries[-1][0]\n        if (not in_conflict and\n            (raw_doc.get('_deleted') or\n             parse_rev(last_rev) <= parse_rev(raw_doc['_rev']))):\n            for (rev, doc_id) in entries:\n                context['deletes_count'] += 1\n                yield _cleanup_update_log(connection, doc_id)\n\n    yield itask.coiterate((\n        clean_imported(context, partition_tag, owner_id, entries)\n        for (partition_tag, owner_id), entries in grouped.iteritems()))\n\n    defer.returnValue(context['deletes_count'])", "response": "Perform a cleanup of update logs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef err_func(params, x, y, func, w=None, func_list=None):\n    err = y - func(x, *params)\n    if w is not None:\n        err = err * w\n    if func_list is not None:\n        err2 = 0\n        for f in func_list: \n            this_err = (y - f[0](x, *[params[ii] for ii in f[1]]))\n            if f[2] is not None:\n                this_err = this_err * f[2]\n            err2 = err2 + this_err \n        err = err2 + err\n\n    return err", "response": "Function for fitting a function on the base of a node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stem(self, word):\n\n        if len(word) <= 2:\n            return word\n        else:\n            word = self.remove_initial_apostrophe(word)\n            word = self.set_ys(word)\n            self.find_regions(word)\n\n            word = self.strip_possessives(word)\n            word = self.replace_suffixes_1(word)\n            word = self.replace_suffixes_2(word)\n            word = self.replace_ys(word)\n            word = self.replace_suffixes_3(word)\n            word = self.replace_suffixes_4(word)\n            word = self.delete_suffixes(word)\n            word = self.process_terminals(word)\n\n            return word", "response": "Stem the word and return it as is."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_ys(self, word):\n\n        if word[0] == 'y':\n            word = 'Y' + word[1:]\n\n        for match in re.finditer(\"[aeiou]y\", word):\n            y_index = match.end() - 1\n            char_list = [x for x in word]\n            char_list[y_index] = 'Y'\n            word = ''.join(char_list)\n\n        return word", "response": "Identify Ys that are to be treated as consonants and make them uppercase."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding regions R1 and R2.", "response": "def find_regions(self, word):\n        \"\"\"\n        Find regions R1 and R2.\n        \"\"\"\n        length = len(word)\n\n        for index, match in enumerate(re.finditer(\"[aeiouy][^aeiouy]\", word)):\n            if index == 0:\n                if match.end() < length:\n                    self.r1 = match.end()\n            if index == 1:\n                if match.end() < length:\n                    self.r2 = match.end()\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_short(self, word):\n\n        short = False\n        length = len(word)\n\n        if self.r1 >= length:\n            if length > 2:\n                ending = word[length - 3:]\n                if re.match(\"[^aeiouy][aeiouy][^aeiouwxY]\", ending):\n                    short = True\n            else:\n                if re.match(\"[aeiouy][^aeiouy]\", word):\n                    short = True\n\n        return short", "response": "Determine if the word is short."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstrip possessives from the beginning of a word.", "response": "def strip_possessives(self, word):\n        \"\"\"\n        Get rid of apostrophes indicating possession.\n        \"\"\"\n\n        if word.endswith(\"'s'\"):\n            return word[:-3]\n        elif word.endswith(\"'s\"):\n            return word[:-2]\n        elif word.endswith(\"'\"):\n            return word[:-1]\n        else:\n            return word"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_suffixes_1(self, word):\n        length = len(word)\n\n        if word.endswith(\"sses\"):\n            return word[:-2]\n\n        elif word.endswith(\"ied\") or word.endswith(\"ies\"):\n            word = word[:-3]\n            if len(word) == 1:\n                word += 'ie'\n            else:\n                word += 'i'\n            return word\n\n        # This ensures that words like conspicous stem properly\n        elif word.endswith('us') or word.endswith('ss'):\n            return word\n\n        # From spec: 'delete if the preceding word part contains a vowel\n        # not immediately before the s (so gas and this retain the s,\n        # gaps and kiwis lose it)\n        elif word[length - 1] == 's':\n            for letter in word[:-2]:\n                if letter in self.vowels:\n                    return word[:-1]\n\n        return word", "response": "Replace suffixes that are not part of a vowel with a suffix that is not part of a vowel."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreplaces suffixes of two words with the longest suffix.", "response": "def replace_suffixes_2(self, word):\n        \"\"\"\n        Find the longest suffix among the ones specified\n        and perform the required action.\n        \"\"\"\n        has_vowel = False\n\n        if word.endswith('eed'):\n            if len(word) >= self.r1:\n                word = word[:-3] + 'ee'\n            return word\n\n        elif word.endswith('eedly'):\n            if len(word) >= self.r1:\n                word = word[:-5] + 'ee'\n            return word\n\n        elif word.endswith('ed'):\n            for vowel in self.vowels:\n                if vowel in word[:-2]:\n                    has_vowel = True\n                    word = word[:-2]\n                    break\n\n        elif word.endswith('edly'):\n            for vowel in self.vowels:\n                if vowel in word[:-4]:\n                    has_vowel = True\n                    word = word[:-4]\n                    break\n\n        elif word.endswith('ing'):\n            for vowel in self.vowels:\n                if vowel in word[:-3]:\n                    has_vowel = True\n                    word = word[:-3]\n                    break\n\n        elif word.endswith('ingly'):\n            for vowel in self.vowels:\n                if vowel in word[:-5]:\n                    has_vowel = True\n                    word = word[:-5]\n                    break\n\n        # Be sure to only perform one of these.\n        if has_vowel:\n            length = len(word)\n            if word[length - 2:] in ['at', 'bl', 'iz']:\n                word += 'e'\n            elif word[length - 2:] in self.doubles:\n                word = word[:-1]\n            elif self.is_short(word):\n                word += 'e'\n\n        return word"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace_ys(self, word):\n        length = len(word)\n\n        if word[length - 1] in 'Yy':\n            if length > 2:\n                if word[length - 2] not in self.vowels:\n                    word = word[:-1] + 'i'\n\n        return word", "response": "Replace y or Y with i if preceded by a non - vowel\nCOOKIE."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform replacements on more common suffixes.", "response": "def replace_suffixes_3(self, word):\n        \"\"\".\n        Perform replacements on more common suffixes.\n        \"\"\"\n        length = len(word)\n\n        replacements = {'tional': 'tion', 'enci': 'ence', 'anci': 'ance',\n                        'abli': 'able', 'entli': 'ent', 'ization': 'ize',\n                        'izer': 'ize', 'ation': 'ate', 'ator': 'ate', 'alism': 'al',\n                        'aliti': 'al', 'alli': 'al', 'fulness': 'ful',\n                        'ousness': 'ous', 'ousli': 'ous', 'iveness': 'ive',\n                        'iviti': 'ive', 'biliti': 'ble', 'bli': 'ble',\n                        'fulli': 'ful', 'lessli': 'less'}\n\n        for suffix in replacements.keys():\n            if word.endswith(suffix):\n                suffix_length = len(suffix)\n                if self.r1 <= (length - suffix_length):\n                    word = word[:-suffix_length] + replacements[suffix]\n\n        if word.endswith('ogi'):\n            if self.r1 <= (length - 3):\n                if (length - 3) > 0:\n                    if word[length - 4] == 'l':\n                        word = word[:-3]\n\n        if word.endswith('li'):\n            if self.r1 <= (length - 2):\n                if word[length - 3] in self.li_endings:\n                    word = word[:-2]\n\n        return word"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_suffixes_4(self, word):\n        length = len(word)\n        replacements = {'ational': 'ate', 'tional': 'tion', 'alize': 'al',\n                        'icate': 'ic', 'iciti': 'ic', 'ical': 'ic',\n                        'ful': '', 'ness': ''}\n\n        for suffix in replacements.keys():\n            if word.endswith(suffix):\n                suffix_length = len(suffix)\n                if self.r1 <= (length - suffix_length):\n                    word = word[:-suffix_length] + replacements[suffix]\n\n        if word.endswith('ative'):\n            if self.r1 <= (length - 5) and self.r2 <= (length - 5):\n                word = word[:-5]\n\n        return word", "response": "Perform replacements on even more common suffixes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_suffixes(self, word):\n        length = len(word)\n        suffixes = ['al', 'ance', 'ence', 'er', 'ic', 'able', 'ible',\n                    'ant', 'ement', 'ment', 'ent', 'ism', 'ate',\n                    'iti', 'ous', 'ive', 'ize']\n\n        for suffix in suffixes:\n            if word.endswith(suffix) and self.r2 <= (length - len(suffix)):\n                word = word[:-len(suffix)]\n                return word\n\n        if word.endswith('ion') and self.r2 <= (length - 3):\n            if word[length - 4] in 'st':\n                word = word[:-3]\n\n        return word", "response": "Delete some common suffixes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_terminals(self, word):\n        length = len(word)\n\n        if word[length - 1] == 'e':\n            if self.r2 <= (length - 1):\n                word = word[:-1]\n\n            elif self.r1 <= (length - 1):\n                if not self.is_short(word[:-1]):\n                    word = word[:-1]\n\n        elif word[length - 1] == 'l':\n            if self.r2 <= (length - 1) and word[length - 2] == 'l':\n                word = word[:-1]\n\n        char_list = [x if x != 'Y' else 'y' for x in word]\n        word = ''.join(char_list)\n\n        return word", "response": "Deal with terminal Es and Ls and returns the original word."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef xdg_compose(to, subject, body=None, cc=None, bcc=None):\n    command = [\"xdg-email\", \"--utf8\", \"--subject\", subject]\n\n    if body:\n        command += [\"--body\", body]\n    if cc:\n        if type(cc) is list:\n            cc = \", \".join(cc)\n        command += [\"--cc\", cc]\n    if bcc:\n        if type(bcc) is list:\n            bcc = \", \".join(bcc)\n        command += [\"--bcc\", bcc]\n    if type(to) is list:\n        to = \", \".join(to)\n    command.append(to)\n    return subprocess.call(command)", "response": "Use xdg - email to compose in an X environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a particular path is larger than expected. Useful before any recursive remove.", "response": "def safe_size_check(checked_path, error_detail, max_bytes=500000000):\n    \"\"\"Determines if a particular path is larger than expected. Useful before any recursive remove.\"\"\"\n    actual_size = 0\n    for dirpath, dirnames, filenames in os.walk(checked_path):\n        for f in filenames:\n            fp = os.path.join(dirpath, f)\n            actual_size += os.path.getsize(fp)\n\n    assert actual_size <= max_bytes, \"Path {} size of {} >= {} bytes. {}\".format(\n        checked_path, actual_size, max_bytes, error_detail)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the end date of the current date.", "response": "def get_end_date(self):\n        \"\"\"\n            Returns the end_date on which the Heart's Right center boundary will be.\n            i.e:\n                                              **   **\n                                            *    *    *\n                                            *         * <------- This point\n                                              *     *\n                                                 *\n        \"\"\"\n        try:\n            today = datetime.date.today()\n            end_date = today + \\\n                datetime.timedelta(\n                    days=-1*today.weekday()+2, weeks=-self.weeks_from_now)\n            return end_date\n        except Exception as e:\n            msg = \"Please enter the 'weeks_from_now' as Int, Error: \" + str(e)\n            raise ErrorMessage(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a Heart on the Summary.", "response": "def create_heart(self, git_repo_url, max_commits=10, weeks_from_now=1):\n        \"\"\"\n            Creates heart on the Summary.\n            Args:\n                git_repo_url: The url (ssh or https) of the Repository, used for cloning\n                max_commits: Maximum number of commits in a day\n                weeks_from_now: The number of week from this week the Heart's Right center boundary will be. \n        \"\"\"\n        self.weeks_from_now = weeks_from_now\n        self.end_date = self.get_end_date()\n        try:\n            self.repository_name = git_repo_url.split('/')[-1][:-4]\n            self.git_repo_url = git_repo_url\n            self.max_commits = max_commits\n            self.do_commits()\n            self.do_commit_amends()\n        except IndexError as ie:\n            raise ErrorMessage(\n                \"Please provide the correct URL for the Repository\")\n        except Exception as e:\n            raise ErrorMessage(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending msg onto the Given File", "response": "def append_onto_file(self, file_name, msg):\n        \"\"\"\n            Appends msg onto the Given File\n        \"\"\"\n        with open(file_name, \"a\") as heart_file:\n            heart_file.write(msg)\n            heart_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms max_commits and push to the Repository", "response": "def do_commits(self):\n        \"\"\"\n            Perform len(MARKED_DAYS)*self.max_commits and Push to the Repository\n        \"\"\"\n        git_clone_command = \"git clone \" + str(self.git_repo_url)\n        subprocess.call(git_clone_command, shell=True)\n        subprocess.check_call(\n            ['touch', 'gitHeart.txt'], cwd=self.repository_name)\n        self.append_onto_file(self.repository_name+\"/gitHeart.txt\", HEADER)\n        subprocess.check_call(\n            ['git', 'add', 'gitHeart.txt'], cwd=self.repository_name)\n        subprocess.check_call(\n            ['git', 'commit', '-m', '\"Commit Number 0\"'], cwd=self.repository_name)\n        for commit_number in range(1, len(MARKED_DAYS)*self.max_commits+1):\n            heart_msg = HEART.format(commit_number=str(commit_number))\n            self.append_onto_file(\n                self.repository_name+\"/gitHeart.txt\", heart_msg)\n            subprocess.check_call(\n                ['git', 'add', 'gitHeart.txt'], cwd=self.repository_name)\n            subprocess.check_call(['git', 'commit', '-m', '\"Commit Number {commit_number}\"'.format(\n                commit_number=commit_number)], cwd=self.repository_name)\n        subprocess.check_call(\n            ['git', 'push', 'origin', 'master'], cwd=self.repository_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_commit_amends(self):\n        commit_cumalative_count = 0\n        for days in MARKED_DAYS:\n            amend_date = (\n                self.end_date - datetime.timedelta(days)).strftime(\"%Y-%m-%d %H:%M:%S\")\n            for commit_number_in_a_day in xrange(0, self.max_commits):\n                commit_cumalative_count += 1\n                subprocess.check_call(\n                    ['git', 'commit', '--amend', \"--date='<\" + amend_date + \" + 0530 >' \", '-C',\n                     'HEAD~{commit_number}'.format(commit_number=commit_cumalative_count)], cwd=self.repository_name)\n                subprocess.check_call(\n                    ['git', 'pull', '--no-edit'], cwd=self.repository_name)\n                subprocess.check_call(\n                    ['git', 'push', 'origin', 'master'], cwd=self.repository_name)", "response": "This method amends the Commit to form the heart\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the message that is sent to the bulb.", "response": "def build_message(self):\n        \"\"\"\n            Make the one string message sent to the bulb\n        \"\"\"\n        if self.params is None:\n            inline_params = \"\"\n        else:\n            # Put all params in one string\n            inline_params = \"\"\n            if type(self.params) is list:\n                for x in self.params:\n                    if x != self.params[0]:\n                        inline_params += \", \"\n                    if type(x) is int:\n                        inline_params += str(x)\n                    else:\n                        inline_params += '\"{}\"'.format(x)\n            else:\n                inline_params += '\"{}\"'.format(self.params)\n\n        # Build message with that string\n        self.message = self.COMMAND_BODY.format(str(self.command_id), self.method, inline_params)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_response(self, raw_response):\n        # Transform response into a dict\n        import json\n        data = json.loads(raw_response)\n        # Retrieve the response id\n        self.response_id = data[self.RESPONSE_ID]\n        # Check if the response id match the command id\n        self.check_id()\n        # Get response data\n        if self.RESPONSE_RESULT in data:\n            self.result = data[self.RESPONSE_RESULT]\n        elif self.RESPONSE_ERROR in data:\n            # If the response is an error raise YeelightError Exception\n            message = data[self.RESPONSE_ERROR][self.ERROR_MESSAGE]\n            code = data[self.RESPONSE_ERROR][self.ERROR_CODE]\n            raise YeelightError(message, code, self.command)", "response": "Decode the response into a dict and store the result in self. result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_id(self):\n        if self.response_id != self.command.get_command_id():\n            raise Exception(\n                \"Error decoding response : the response id {} doesn't match the command id {}\".format(self.response_id,\n                                                                                                      self.command.get_command_id()))", "response": "Raise an exception if the command and the response id doesn t match the command id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _season_overflow(season, moved_year, now):\n\n    if season > 4:\n        while season > 4:\n            if moved_year is None:\n                moved_year = now.year + 1\n            else:\n                moved_year += 1\n            season -= 5\n    elif season < 0:\n        while season < 0:\n            if moved_year is None:\n                moved_year = now.year - 1\n            else:\n                moved_year -= 1\n            season += 5\n    return season, moved_year", "response": "Pushes illegal seasons ints into the next / previous year."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef discordian_calendar(season=None, year=None, dtobj=None):\n\n    now = DDate(dtobj)\n\n    moved_year = None\n\n    if season is None:\n        season = now.season\n    elif season.lower() == \"next\":\n        season, moved_year = _season_overflow(now.season or 0 + 1, moved_year,\n                                              now)\n    else:\n        # allow for +1, -2, for seasons...\n        for symbol, oper in zip((\"+\", \"-\"), (operator.add, operator.sub)):\n            if symbol in season:\n                try:\n                    amount = int(season.strip(symbol))\n                except ValueError:\n                    raise ValueError(\"unknown season: {}\".format(season))\n                else:\n                    season, moved_year = _season_overflow(\n                        oper(now.season or 0, amount),\n                        moved_year,\n                        now,\n                    )\n                    break\n        else:\n            # allow to use the season name or some starting part of it\n            input_name = season.lower()\n            for season_name in now.SEASONS:\n                _name = season_name.lower()\n                if input_name == _name or any(\n                        [n.startswith(input_name) for n in _name.split(\" \")]):\n                    season = now.SEASONS.index(season_name)\n                    break\n            else:\n                try:  # last try with a literal int being passed in\n                    season = int(season)\n                except ValueError:\n                    raise ValueError(\"unknown season: {}\".format(season))\n                else:\n                    if not 1 <= season <= 5:\n                        raise ValueError(\"season must be in 1..5\")\n                    season -= 1  # allowing cardinal numbers from the user\n\n    if year is None:\n        year = moved_year or now.year\n    elif year.lower() == \"next\":\n        year = (moved_year or now.year) + 1\n    else:\n        for symbol, oper in zip((\"+\", \"-\"), (operator.add, operator.sub)):\n            if symbol in year:\n                year = oper(moved_year or now.year, int(year.strip(symbol)))\n                break\n        else:\n            try:\n                year = int(year)\n            except ValueError:\n                raise ValueError(\"invalid year: {}\".format(year))\n\n    if not MINYEAR <= year <= MAXYEAR:\n        # otherwise this error isn't that helpful\n        raise ValueError(\"year must be in {}..{}\".format(MINYEAR, MAXYEAR))\n\n    if now.day_of_season is None:\n        if is_leap_year(year - 1166):\n            day_of_season = None\n        else:\n            day_of_season = 59\n        season = season or 0\n    else:\n        day_of_season = now.day_of_season\n\n    if day_of_season:\n        cal_date = DDate(year=year, season=season, day_of_season=day_of_season)\n        cal = MultiCalendar(discordian=True, date=cal_date)\n        cal.print_calendar()\n    else:\n        print(\"{} in YOLD {}\".format(now.holiday, year))", "response": "Prints a discordian calendar for a particular season and year."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncommand line entry point for dcal.", "response": "def main():\n    \"\"\"Command line entry point for dcal.\"\"\"\n\n    if \"--help\" in sys.argv or \"-h\" in sys.argv or len(sys.argv) > 3:\n        raise SystemExit(__doc__)\n\n    try:\n        discordian_calendar(*sys.argv[1:])\n    except ValueError as error:\n        raise SystemExit(\"Error: {}\".format(\"\\n\".join(error.args)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compare(a, b):\n    assertType(a, BigInt)\n    b = coerceBigInt(b)\n    if not b:\n        return NotImplemented\n\n    return librelic.bn_cmp(byref(a), byref(b))", "response": "Compares two BigInt objects. Returns LESS_THAN EQUAL or GREATER_THAN."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef coerceBigInt(x):\n    # BigInt's are easy.\n    if isinstance(x, BigInt):\n        return x\n\n    # Convert ints and longs using the constructor\n    elif isinstance(x, (long, int)):\n        return BigInt(x)\n\n    else:\n        return None", "response": "Converts a BigInt to a base - 10 BigInt."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhashes the given arguments into a BigInt using a cryptographic hash function.", "response": "def hashZ(*args):\n    \"\"\"\n    Hash @args into a BigInt using a cryptographic hash function.\n    \"\"\"\n    TAG = \"TAG_RELIC_HASH_Z\"\n    MESSAGE = \"MESSAGE_HASH_Z\"\n\n    # Combine the arguments into a canonical string representation.\n    text = TAG.join([str(val) for val in args ] )\n\n    # Hash the string using HMAC\n    # b: byte string \n    b = hmac(text, MESSAGE)\n    return BigInt(longFromString(b))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the inverse of BigInt x in a field of prime order p.", "response": "def inverse(x, p, errorOnFail=False):\n    \"\"\"\n    Find the inverse of BigInt @x in a field of (prime) order @p.\n    \"\"\"\n    # Check types\n    assertType(x, BigInt)\n\n    # There are a number of ways in RELIC to compute this inverse, but\n    # for simplicity, we'll use the extended GCD algorithm because it \n    # involves less type conversions. On the initial development platform\n    # Lehmer's algorithm was the most performant: we call it directly.\n    gcd = BigInt()\n    inv = BigInt()\n\n    # bn_gcd_ext(c, d, e, a, b) computes: c = a*d + b*e\n    # We take x=a. b=p, and expect: c = 1 = gcd(x,p), d = 1/x, and e is unused.\n    librelic.bn_gcd_ext_lehme(byref(gcd), byref(inv), None, byref(x), byref(p))\n\n    # Check that GCD == 1 \n    if gcd != 1:\n        if errorOnFail:\n            raise Exception(\"Cannot find an inverse. gcd(x,p) == {}, but we need gcd(x,p) == 1 to find an inverse.\".\n                format(long(gcd)))\n        else:\n            return None\n\n    return inv"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef randomZ(maximum=None, bits=256):\n    result = BigInt()\n\n    # Select a random number smaller than the maximum.\n    if maximum:\n        maximum = coerceBigInt(maximum)\n        librelic.bn_rand_mod(byref(result), byref(maximum))\n\n    # Otherwise, select a random BigInt of the appropriate size in bits.\n    else:\n        librelic.bn_rand_abi(byref(result), BigInt.POSITIVE_FLAG, c_int(bits))\n    \n    return result", "response": "Retrieve a random BigInt."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emit_event(project_slug, action_slug):\n\n    if request.headers.get('Content-Type') == 'application/json':\n        payload = request.get_json()\n    elif request.method == 'POST':\n        payload = request.form.to_dict()\n    else:\n        payload = request.args.to_dict()\n\n    if not request.authorization:\n        return jsonify({'message': 'unauthorized'}), 401\n\n    sender_name = request.authorization.username\n    sender_secret = request.authorization.password\n\n    event_uuid = request.headers.get('X-Rio-Event-UUID') or \\\n           request.headers.get('X-B3-TraceId')\n\n    data = _emit_event(project_slug, action_slug, payload, sender_name, sender_secret,\n                       event_uuid=event_uuid)\n    data['message'] = 'ok'\n\n    event_received.send(None, project_slug=project_slug, data=data)\n\n    return jsonify(data)", "response": "Publish message to action."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresolves a FilterExpression within the context of the template.", "response": "def strict_resolve(self, context, ignore_failures=False):\n    \"\"\"\n    Resolves a ``FilterExpression`` within the context of the template.\n\n    This patched method acts as a proxy to the original, but forces\n    ``ignore_failures`` to False so that an exception is always raised when a\n    variable is accessed out of scope/context.\n    \"\"\"\n    return __orig_resolve(self, context, ignore_failures=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering the debug variable node.", "response": "def debug_variable_node_render(self, context):\n    \"\"\"\n    Like DebugVariableNode.render, but doesn't catch UnicodeDecodeError.\n    \"\"\"\n    try:\n        output = self.filter_expression.resolve(context)\n        output = template_localtime(output, use_tz=context.use_tz)\n        output = localize(output, use_l10n=context.use_l10n)\n        output = force_text(output)\n    except Exception as e:\n        if not hasattr(e, 'django_template_source'):\n            e.django_template_source = self.source\n        raise\n    if (context.autoescape and not isinstance(output, SafeData)) or isinstance(output, EscapeData):  # nopep8\n        return escape(output)\n    else:\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nliking VariableNode. render but doesn t catch UnicodeDecodeError", "response": "def variable_node_render(self, context):\n    \"\"\"\n    Like VariableNode.render, but doesn't catch UnicodeDecodeError.\n    \"\"\"\n    output = self.filter_expression.resolve(context)\n    return render_value_in_context(output, context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npatches a template modules to prevent catching UnicodeDecodeError.", "response": "def _disallow_catching_UnicodeDecodeError(f):\n    \"\"\"\n    Patches a template modules to prevent catching UnicodeDecodeError.\n\n    Note that this has the effect of also making Template raise a\n    UnicodeDecodeError instead of a TemplateEncodingError if the template\n    string is not UTF-8 or unicode.\n    \"\"\"\n    patch_base = patch.object(VariableNode, 'render', variable_node_render)\n    patch_all = patch_base\n    if django.VERSION < (1, 9):\n        from django.template.debug import DebugVariableNode\n        patch_debug = patch.object(\n            DebugVariableNode, 'render', debug_variable_node_render)\n        patch_all = _compose(patch_all, patch_debug)\n    return patch_all(f)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncatching UnicodeDecodeError and logs UnicodeDecodeError.", "response": "def _log_unicode_errors(logger, log_level):\n    \"\"\"\n    Catches/logs UnicodeDecodeError.\n    \"\"\"\n    def log_debug_render(*args, **kwargs):\n        try:\n            return debug_variable_node_render(*args, **kwargs)\n        except UnicodeDecodeError:\n            logger.log(\n                log_level,\n                \"UnicodeDecodeError in template rendering\",\n                exc_info=True)\n        return ''\n\n    def log_render(*args, **kwargs):\n        try:\n            return variable_node_render(*args, **kwargs)\n        except UnicodeDecodeError:\n            logger.log(\n                log_level,\n                \"UnicodeDecodeError in template rendering\",\n                exc_info=True)\n        return ''\n\n    patch_base = patch.object(VariableNode, 'render', log_render)\n    patch_all = patch_base\n    if django.VERSION < (1, 9):\n        from django.template.debug import DebugVariableNode\n        patch_debug = patch.object(DebugVariableNode, 'render',\n                                   log_debug_render)\n        patch_all = _compose(patch_all, patch_debug)\n    return lambda f: patch_all(f)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fail_on_template_errors(f, *args, **kwargs):\n    decorators = [\n        _fail_template_string_if_invalid,\n        _always_strict_resolve,\n        _disallow_catching_UnicodeDecodeError,\n    ]\n    if django.VERSION < (1, 8):\n        decorators.append(_patch_invalid_var_format_string)\n\n    return reduce(__apply, decorators, f)(*args, **kwargs)", "response": "Decorator that causes templates to fail on template errors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the RFC and fix where possible\n        '''\n        # Let the parent do its stuff\n        super(IPv4Packet, self).sanitize()\n\n        # Check the version\n        if self.version != 4:\n            raise ValueError(\"Protocol version must be 4\")\n\n        # Treat type-of-service as an 8-bit unsigned integer. Future versions\n        # of this code may implement methods to treat it as DSCP+ECN\n        if not isinstance(self.tos, numbers.Integral) \\\n        or self.tos < 0 \\\n        or self.tos >= 2 ** 8:\n            raise ValueError('Invalid type of service')\n\n        # Identification: An identifying value assigned by the sender to aid in\n        # assembling the fragments of a datagram.\n        if not isinstance(self.identification, numbers.Integral) \\\n        or self.identification < 0 \\\n        or self.identification >= 2 ** 16:\n            raise ValueError('Invalid fragment identification')\n\n        # An internet datagram can be marked \"don't fragment.\"  Any internet\n        # datagram so marked is not to be internet fragmented under any\n        # circumstances.  If internet datagram marked don't fragment cannot be\n        # delivered to its destination without fragmenting it, it is to be\n        # discarded instead.\n        if not isinstance(self.dont_fragment, bool):\n            raise ValueError(\"Don't fragment flag must be a boolean\")\n\n        # The More Fragments flag bit (MF) is set if the datagram is not the\n        # last fragment.  The Fragment Offset field identifies the fragment\n        # location, relative to the beginning of the original unfragmented\n        # datagram.  Fragments are counted in units of 8 octets.  The\n        # fragmentation strategy is designed so than an unfragmented datagram\n        # has all zero fragmentation information (MF = 0, fragment offset =\n        # 0).  If an internet datagram is fragmented, its data portion must be\n        # broken on 8 octet boundaries.\n        if not isinstance(self.more_fragments, bool):\n            raise ValueError('More fragments flag must be a boolean')\n\n        # Fragment offset: This field indicates where in the datagram this\n        # fragment belongs. The fragment offset is measured in units of 8\n        # octets (64 bits).  The first fragment has offset zero.\n        if not isinstance(self.fragment_offset, numbers.Integral) \\\n        or self.fragment_offset < 0 \\\n        or self.fragment_offset >= 2 ** 13:\n            raise ValueError('Invalid fragment offset')\n\n        # Check for don't-fragment combined with a fragment offset\n        if self.dont_fragment and self.fragment_offset > 0:\n            raise ValueError(\"A packet marked don't fragment can't have \"\n                             \"a fragment-offset\")\n\n        # Check that the TTL is correct\n        if not isinstance(self.ttl, numbers.Integral) \\\n        or self.ttl < 0 \\\n        or self.ttl >= 2 ** 8:\n            raise ValueError('Invalid TTL')\n\n        # Check the source and destination addresses\n        if not isinstance(self.source, IPv4Address):\n            raise ValueError('Source address must be IPv4')\n\n        if not isinstance(self.destination, IPv4Address):\n            raise ValueError('Destination address must be IPv4')", "response": "Sanitize the current settings and return a new set of unfragmented datagram - related attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the ISO - 8601 - format IPv4 packet and update properties accordingly.", "response": "def from_bytes(cls, bitstream, decode_payload=True):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the version\n        version = bitstream.read('uint:4')\n        if version != packet.version:\n            raise ValueError('Provided bytes do not contain an IPv4 packet')\n\n        # Read the header length\n        ihl = bitstream.read('uint:4')\n        if ihl < 5:\n            raise ValueError('Invalid IPv4 header length')\n\n        # Now that we know the length of the header we store it to be able\n        # to easily recalculate the header checksum later\n        remaining_header_bits = (ihl * 32) - 8\n        header = (BitStream('uint:4=4, uint:4=%d' % ihl) +\n                  bitstream.peek(remaining_header_bits))\n\n        # Read the type of service\n        packet.tos = bitstream.read('uint:8')\n\n        # Read the total length\n        total_length = bitstream.read('uint:16')\n        if total_length < ihl * 4:\n            raise ValueError('Total length is shorter than the header')\n\n        # Read the identification\n        packet.identification = bitstream.read('uint:16')\n\n        # Read the flags\n        (reserved,\n         packet.dont_fragment,\n         packet.more_fragments) = bitstream.readlist('3*bool')\n\n        if reserved:\n            raise ValueError('Reserved flag must be 0')\n\n        # Read the fragment offset\n        packet.fragment_offset = bitstream.read('uint:13')\n\n        # Read the TTL\n        packet.ttl = bitstream.read('uint:8')\n\n        # Read the protocol number\n        packet.protocol = bitstream.read('uint:8')\n\n        # Read the header checksum\n        header_checksum = bitstream.read('uint:16')\n\n        # Set the checksum bits in the header to 0 and re-calculate\n        header[80:96] = BitStream(16)\n        my_checksum = checksum.ones_complement(header.bytes)\n\n        if my_checksum != header_checksum:\n            raise ValueError('Header checksum does not match')\n\n        # Read the source and destination addresses\n        packet.source = IPv4Address(bitstream.read('uint:32'))\n        packet.destination = IPv4Address(bitstream.read('uint:32'))\n\n        # Read the options\n        option_len = (ihl - 5) * 4\n        packet.options = bitstream.read('bytes:%d' % option_len)\n\n        # And the rest is payload\n        payload_bytes = (total_length) - (ihl * 4)\n        packet.payload = bitstream.read('bytes:%d' % payload_bytes)\n\n        if decode_payload:\n            payload_class = protocol_registry.get_type_class(packet.protocol)\n            if payload_class:\n                packet.payload = payload_class.from_bytes(packet.payload)\n\n        # There should be no remaining bits\n        if bitstream.pos != bitstream.len:\n            raise ValueError('Bits remaining after processing packet')\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate bytes from properties and return them as a string.", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the version\n        bitstream = BitStream('uint:4=%d' % self.version)\n\n        # Write the header length\n        options_len = math.ceil(len(self.options) / 4.0)\n        bitstream += BitStream('uint:4=%d' % (5 + options_len))\n\n        # Write the type of service\n        bitstream += BitStream('uint:8=%d' % self.tos)\n\n        # Write the total length\n        payload_bytes = bytes(self.payload)\n        total_length = 20 + len(payload_bytes)\n        bitstream += BitStream('uint:16=%d' % total_length)\n\n        # Write the identification\n        bitstream += BitStream('uint:16=%d' % self.identification)\n\n        # Write the flags\n        bitstream += BitStream('bool=False, bool=%d, '\n                               'bool=%d' % (self.dont_fragment,\n                                            self.more_fragments))\n\n        # Write the fragment offset\n        bitstream += BitStream('uint:13=%d' % self.fragment_offset)\n\n        # Write the TTL\n        bitstream += BitStream('uint:8=%d' % self.ttl)\n\n        # Write the protocol number\n        bitstream += BitStream('uint:8=%d' % self.protocol)\n\n        # Write the header checksum as 0 for now, we calculate it later\n        bitstream += BitStream('uint:16=0')\n\n        # Write the source and destination addresses\n        bitstream += BitStream('uint:32=%d, '\n                               'uint:32=%d' % (int(self.source),\n                                               int(self.destination)))\n\n        # Add the options\n        bitstream += BitStream(bytes=self.options)\n        padding_len = (4 - (len(self.options) % 4)) % 4\n        bitstream += BitStream(padding_len * 8)\n\n        # Calculate the header checksum and fill it in\n        my_checksum = checksum.ones_complement(bitstream.bytes)\n        bitstream[80:96] = BitStream('uint:16=%d' % my_checksum)\n\n        return bitstream.bytes + payload_bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts a new synthetic member at the beginning of the list", "response": "def insertSyntheticMemberAtBegin(self, synthesizedMember):\n        \"\"\"\n    :type synthesizedMember: SyntheticMember\n    :raises DuplicateMemberNameError\n\"\"\"\n        memberName = synthesizedMember.memberName()\n        if memberName in [m.memberName() for m in self._syntheticMemberList]:\n            raise DuplicateMemberNameError(memberName, self._class.__name__)\n        \n        self._syntheticMemberList.insert(0, synthesizedMember)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply(self, cls, originalMemberNameList, memberName, classNamingConvention, getter, setter):\n        # The new property.\n        originalProperty = None\n        if memberName in originalMemberNameList:\n            member = getattr(cls, memberName)\n            \n            # There's already a member with that name and it's not a property\n            if not isinstance(member, property):\n                raise InvalidPropertyOverrideError(memberName, cls.__name__)\n            \n            # If property already exists, we will just modify it.\n            originalProperty = member\n        \n        kwargs = {self._KEY_PROPERTY_GET: getattr(originalProperty, self._KEY_PROPERTY_GET, None) or getter,\n                  self._KEY_PROPERTY_SET: getattr(originalProperty, self._KEY_PROPERTY_SET, None) or setter,\n                  self._KEY_PROPERTY_DEL: getattr(originalProperty, self._KEY_PROPERTY_DEL, None) or None,\n                  self._KEY_PROPERTY_DOC: getattr(originalProperty, self._KEY_PROPERTY_DOC, None) or None}\n        setattr(cls, memberName, property(**kwargs))", "response": "Applies the property to the class with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self, cls, originalMemberNameList, memberName, classNamingConvention):\n        if memberName not in originalMemberNameList:\n            delattr(cls, memberName)", "response": "Removes a member from the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_module_with_import(self, uri):\n        mod = __import__(uri, fromlist=[uri])\n        # find all public objects in the module.\n        obj_strs = [obj for obj in dir(mod) if not obj.startswith('_')]\n        functions = []\n        classes = []\n        for obj_str in obj_strs:\n            # find the actual object from its string representation\n            if obj_str not in mod.__dict__:\n                continue\n            obj = mod.__dict__[obj_str]\n            # figure out if obj is a function or class\n            if hasattr(obj, 'func_name') or \\\n               isinstance(obj, BuiltinFunctionType):\n                functions.append(obj_str)\n            else:\n                try:\n                    issubclass(obj, object)\n                    classes.append(obj_str)\n                except TypeError:\n                    # not a function or class\n                    pass\n        return functions, classes", "response": "Parse a module with importable functions and classes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_api_doc(self, uri):\n        '''Make autodoc documentation template string for a module\n\n        Parameters\n        ----------\n        uri : string\n            python location of module - e.g 'sphinx.builder'\n\n        Returns\n        -------\n        head : string\n            Module name, table of contents.\n        body : string\n            Function and class docstrings.\n        '''\n        # get the names of all classes and functions\n        functions, classes = self._parse_module_with_import(uri)\n        if not len(functions) and not len(classes) and DEBUG:\n            print('WARNING: Empty -', uri)  # dbg\n\n        # Make a shorter version of the uri that omits the package name for\n        # titles\n        uri_short = re.sub(r'^%s\\.' % self.package_name,'',uri)\n\n        head = '.. AUTO-GENERATED FILE -- DO NOT EDIT!\\n\\n'\n        body = ''\n\n        # Set the chapter title to read 'module' for all modules except for the\n        # main packages\n        if '.' in uri_short:\n            title = 'Module: :mod:`' + uri_short + '`'\n            head += title + '\\n' + self.rst_section_levels[2] * len(title)\n        else:\n            title = ':mod:`' + uri_short + '`'\n            head += title + '\\n' + self.rst_section_levels[1] * len(title)\n\n        head += '\\n.. automodule:: ' + uri + '\\n'\n        head += '\\n.. currentmodule:: ' + uri + '\\n'\n        body += '\\n.. currentmodule:: ' + uri + '\\n'\n        for c in classes:\n            body += '\\n:class:`' + c + '`\\n' \\\n                  + self.rst_section_levels[3] * \\\n                  (len(c)+9) + '\\n\\n'\n            body += '\\n.. autoclass:: ' + c + '\\n'\n            # must NOT exclude from index to keep cross-refs working\n            body += '  :members:\\n' \\\n                  '  :undoc-members:\\n' \\\n                  '  :show-inheritance:\\n' \\\n                  '\\n' \\\n                  '  .. automethod:: __init__\\n\\n'\n        head += '.. autosummary::\\n\\n'\n        for f in classes + functions:\n            head += '   ' + f + '\\n'\n        head += '\\n'\n\n        for f in functions:\n            # must NOT exclude from index to keep cross-refs working\n            body += f + '\\n'\n            body += self.rst_section_levels[3] * len(f) + '\\n'\n            body += '\\n.. autofunction:: ' + f + '\\n\\n'\n\n        return head, body", "response": "Generate the autodoc documentation for a module."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a path to the tmp dir for a queue", "response": "def tmp(p_queue, host=None):\n    if host is not None:\n        return _path(_c.FSQ_TMP, root=_path(host, root=hosts(p_queue)))\n    '''Construct a path to the tmp dir for a queue'''\n    return _path(p_queue, _c.FSQ_TMP)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a path to the queue dir for a queue", "response": "def queue(p_queue, host=None):\n    '''Construct a path to the queue dir for a queue'''\n    if host is not None:\n        return _path(_c.FSQ_QUEUE, root=_path(host, root=hosts(p_queue)))\n    return _path(p_queue, _c.FSQ_QUEUE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a path to the fail dir for a queue", "response": "def fail(p_queue, host=None):\n    if host is not None:\n        return _path(_c.FSQ_FAIL, root=_path(host, root=hosts(p_queue)))\n    '''Construct a path to the fail dir for a queue'''\n    return _path(p_queue, _c.FSQ_FAIL)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef done(p_queue, host=None):\n    if host is not None:\n        return _path(_c.FSQ_DONE, root=_path(host, root=hosts(p_queue)))\n    '''Construct a path to the done dir for a queue'''\n    return _path(p_queue, _c.FSQ_DONE)", "response": "Construct a path to the done dir for a queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a path to the down file for a queue", "response": "def down(p_queue, host=None):\n    if host is not None:\n        return _path(_c.FSQ_DOWN, root=_path(host, root=hosts(p_queue)))\n    '''Construct a path to the down file for a queue'''\n    return _path(p_queue, _c.FSQ_DOWN)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef item(p_queue, queue_id, host=None):\n    if host is not None:\n        return os.path.join(_path(host, _c.FSQ_QUEUE, root=hosts(p_queue)),\n                            valid_name(queue_id))\n    '''Construct a path to a queued item'''\n    return os.path.join(_path(p_queue, _c.FSQ_QUEUE), valid_name(queue_id))", "response": "Construct a path to a queued item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fromfile(self, path_to_file, mimetype=None):\n\n        if os.path.isfile(path_to_file):\n\n            # Load file into self.__content__\n            self.filename = os.path.basename(path_to_file)\n            with open(path_to_file, \"rb\") as in_file:\n                self.content = in_file.read()\n\n            #guess mime-type\n            self.properties.content_settings = ContentSettings()\n            \n            if mimetype is None:\n                mimetype = guess_type(path_to_file)\n                if mimetype[0] is None:\n                    mimetype = 'application/octet-stream'\n                else: \n                    if not mimetype[1] is None:\n                        self.properties.content_settings.content_encoding = mimetype[1]\n                    mimetype = mimetype[0]\n\n            self.properties.content_settings.content_type = mimetype\n\n        else:\n            raise AzureStorageWrapException(self, 'Can not load blob content, because given path is not a local file')", "response": "Loads the content of a blob from a local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset blob content from given text.", "response": "def fromtext(self, text, encoding='utf-8', mimetype='text/plain'):\n        \"\"\" \n        set blob content from given text in StorageBlobModel instance. Parameters are:\n        - text (required): path to a local file \n        - encoding (optional): text encoding (default is utf-8)\n        - mimetype (optional): set a mimetype. azurestoragewrap will guess it if not given \n        \"\"\"\n        if isinstance(text, str):\n            text = text.encode(encoding, 'ignore')\n\n            # Load text into self.__content__\n            self.content = bytes(text)\n\n            self.properties.content_settings = ContentSettings(content_type=mimetype, content_encoding=encoding)\n\n        else:\n            raise AzureStorageWrapException(self, 'Can not load blob content, because given text is not from type string')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the contents of this object to file in given path.", "response": "def tofile(self, path_to_file, replace_file=False):\n        \"\"\" \n        save blob content from StorageBlobModel instance to file in given path/file. Parameters are:\n        - path_to_file (required): local path or file\n        \"\"\"\n\n        # create full path\n        if os.path.isdir(path_to_file):\n            if self.filename != '':\n                path_to_file = os.path.join(path_to_file, self.filename)\n            \n            else:\n                # guess extention from mimetype\n                path_to_file = os.path.join(path_to_file, self.name + guess_extension(self.properties.content_settings.content_type))\n\n        elif os.path.isfile(path_to_file):\n            # check if given file extention fits to self.filename or mime type\n            #  \n            if self.filename != '':\n                if os.path.splitext(self.filename)[1] != os.path.splitext(path_to_file)[1]:\n                    raise AzureStorageWrapException(self, 'can not save blob to file because file extention {!s} does not fit to source file or mime type'.format(path_to_file))\n      \n            else:\n                mimetype = guess_type(path_to_file)[0]\n                if mimtype != self.properties.content_settings.content_type:\n                    raise AzureStorageWrapException(self, 'can not save blob to file because file extention {!s} does not fit to source file or mime type'.format(path_to_file))\n                \n        else:\n            raise AzureStorageWrapException(self, 'can not save blob to file because {!s} is not a dir nor a file'.format(path_to_file))\n        \n        # check if file exists (and replace or error)\n        if os.path.isfile(path_to_file):\n            if replace_file:\n                os.remove(path_to_file)\n            else:\n                raise AzureStorageWrapException(self, 'can not save blob to file {!s} because file exists and replace_file is False'.format(path_to_file))\n\n        # save file into self.__content__\n        self.filename = os.path.basename(path_to_file)\n        with open(path_to_file, \"wb\") as out_file:\n            out_file.write(self.content)\n\n        return path_to_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef totext(self) ->str:\n        sreturn = ''\n        if self.properties.content_settings.content_encoding is None:\n            raise AzureStorageWrapException(self, 'can not convert blob {!s} to text because content_encoding is not given'.format(self.name))\n        else:\n            sreturn = self.content.decode(self.properties.content_settings.content_encoding, 'ignore')\n\n        return sreturn", "response": "converts blob content from StorageBlobModel instance to text"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears up an Queueservice for an StorageQueueModel in your Azure Storage Account Will delete the hole Queue if delete_queue Flag is True! required Parameter is: - storagemodel: StorageQueueModel(Object) Optional Parameter is: - delete_queue: bool", "response": "def unregister_model(self, storagemodel:object, modeldefinition = None,  delete_blob=False):\n        \"\"\" clear up an Queueservice for an StorageQueueModel in your  Azure Storage Account\n            Will delete the hole Queue if delete_queue Flag is True!\n        \n            required Parameter is:\n            - storagemodel: StorageQueueModel(Object)\n\n            Optional Parameter is:\n            - delete_queue: bool\n        \"\"\"\n        \n        \"\"\" remove from modeldefinitions \"\"\"\n        for i in range(len(self._modeldefinitions)):\n            if self._modeldefinitions[i]['modelname'] == modeldefinition['modelname']:\n                del self._modeldefinitions[i]\n                break\n\n        \"\"\" delete queue from storage if delete_queue == True \"\"\"        \n        if delete_blob:\n            self.__delete__(modeldefinition)\n\n        log.info('model {} unregistered successfully. Models are {!s}'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))      \n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupload blob to storage", "response": "def upload(self, storagemodel:object, modeldefinition = None):\n        \"\"\" insert blob message into storage \"\"\"\n\n        if (storagemodel.content is None) or (storagemodel.properties.content_settings.content_type is None):\n            # No content to upload\n            raise AzureStorageWrapException(storagemodel, \"StorageBlobModel does not contain content nor content settings\")\n\n        else:\n            blobservice = modeldefinition['blobservice']\n            container_name = modeldefinition['container']\n            blob_name = storagemodel.name\n\n            try:\n\n                # refresh metadata\n                storagemodel.__instance_to_metadata__()\n\n                \"\"\" upload bytes \"\"\"\n                blobservice.create_blob_from_bytes(\n                        container_name=container_name, \n                        blob_name=blob_name, \n                        blob=storagemodel.content, \n                        metadata=storagemodel.metadata, \n                        content_settings=storagemodel.properties.content_settings\n                    )\n\n                storagemodel.properties = blobservice.get_blob_properties(container_name=container_name, blob_name=blob_name).properties\n                 \n            except Exception as e:\n                msg = 'can not save blob in container {} because {!s}'.format(storagemodel._containername, e)\n                raise AzureStorageWrapException(storagemodel, msg=msg)\n           \n        return storagemodel"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads a blob from storage into storage", "response": "def download(self, storagemodel:object, modeldefinition = None):\n        \"\"\" load blob from storage into StorageBlobModelInstance \"\"\"\n\n        if (storagemodel.name is None):\n            # No content to download\n            raise AzureStorageWrapException(storagemodel, \"StorageBlobModel does not contain content nor content settings\")\n\n        else:\n            container_name = modeldefinition['container']\n            blob_name = storagemodel.name\n            try:\n                if modeldefinition['blobservice'].exists(container_name, blob_name):\n                    \"\"\" download blob \"\"\"\n                    blob = modeldefinition['blobservice'].get_blob_to_bytes(\n                            container_name=modeldefinition['container'], \n                            blob_name=storagemodel.name\n                        )\n\n                    storagemodel.__mergeblob__(blob)\n                 \n            except Exception as e:\n                msg = 'can not load blob from container {} because {!s}'.format(storagemodel._containername, e)\n                raise AzureStorageWrapException(storagemodel, msg=msg)\n           \n        return storagemodel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete the object from storage", "response": "def delete(self, storagemodel:object, modeldefinition = None) -> bool:\n        \"\"\" delete the blob from storage \"\"\"\n        deleted = False\n\n        blobservice = modeldefinition['blobservice']\n        container_name = modeldefinition['container']\n        blob_name = storagemodel.name\n\n        try:\n            if blobservice.exists(container_name, blob_name):\n\n                \"\"\" delete \"\"\"\n                blob = blobservice.delete_blob(container_name, blob_name)\n                deleted = True\n                 \n        except Exception as e:\n            msg = 'can not delete blob {} from storage because {!s}'.format(blob_name, e)\n            raise AzureStorageWrapException(storagemodel, msg=msg)\n\n        return deleted"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exists(self, storagemodel:object, modeldefinition = None) -> bool:\n        exists = False\n\n        blobservice = modeldefinition['blobservice']\n        container_name = modeldefinition['container']\n        blob_name = storagemodel.name\n\n        try:\n            blobs = self.list(storagemodel, modeldefinition, where=storagemodel.name)\n            if len(blobs) == 1:\n                storagemodel.__mergeblob__(blobs[0])\n                exists = True\n                 \n        except Exception as e:\n            msg = 'can not retireve blob {} from storage because {!s}'.format(blob_name, e)\n            raise AzureStorageWrapException(storagemodel, msg=msg)\n\n        return exists", "response": "check if the blob exists in storage"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list(self, storagemodel:object, modeldefinition = None, where=None) ->list:\n        try:\n            blobnames = []\n            if where is None:\n                generator = modeldefinition['blobservice'].list_blobs(modeldefinition['container'])\n            else:\n                generator = modeldefinition['blobservice'].list_blobs(modeldefinition['container'], prefix=where)\n\n            for blob in generator:\n                blobnames.append(blob)\n\n        except Exception as e:\n            msg = 'can not list blobs in container {} because {!s}'.format(storagemodel._containername, e)\n            raise AzureStorageWrapException(storagemodel, msg=msg)\n           \n        finally:\n            return blobnames", "response": "list blob messages in container"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef naa_correct(G):\n\n    \"\"\"\n    This function resets the fits and corrects shifts in the spectra.\n    It uses uses the NAA peak at 2.0ppm as a guide to replaces the existing\n    f_ppm values! \n    \"\"\"\n    G.reset_fits()\n\n    # calculate diff\n    diff = np.mean(G.diff_spectra, 0)\n    # find index of NAA peak in diff spectrum, that is between 3 and 1ppm\n    temp_diff = np.mean(G.diff_spectra, 0)\n    temp_diff[slice(0,np.min(np.where(G.f_ppm<3)))]=0\n    temp_diff[np.max(np.where(G.f_ppm>1)):]=0 \n    idx = np.argmin(temp_diff)\n    adjust_by=(float(idx)/len(diff))*(np.max(G.f_ppm)-\n                                      np.min(G.f_ppm))\n    NAA_ppm = np.max(G.f_ppm)-adjust_by \n    \n    # determine how far spectrum is shifted\n    NAA_shift = 2.0-NAA_ppm\n    \n    # correct\n    G.f_ppm = G.f_ppm + NAA_shift\n\n    # tag as corrected\n    G.naa_corrected = True", "response": "This function corrects the NAA peak in the spectra."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the object with the given parameters.", "response": "def initialize(self, action=None, comment=None, user=None,\n                   restricted=None):\n        self.action = none_or(action, bool)\n        \"\"\"\n        Is the text of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.comment = none_or(comment, bool)\n        \"\"\"\n        Is the comment of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.user = none_or(user, bool)\n        \"\"\"\n        Is the user of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.restricted = none_or(restricted, bool)\n        \"\"\"\n        Is the revision restricted? : `bool`\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the object with the given parameters.", "response": "def initialize(self, id, timestamp=None, user=None, page=None,\n                   comment=None, type=None, action=None, text=None,\n                   params=None, deleted=None):\n\n        self.id = int(id)\n        \"\"\"\n        Log item ID : `int`\n        \"\"\"\n\n        self.timestamp = none_or(timestamp, Timestamp)\n        \"\"\"\n        log item timestamp : :class:`mwtypes.Timestamp`\n        \"\"\"\n\n        self.user = none_or(user, User)\n        \"\"\"\n        Contributing user metadata : :class:`mwtypes.User`\n        \"\"\"\n\n        self.page = none_or(page, self.Page)\n        \"\"\"\n        Related page : :class:`mwtypes.log_item.Page`\n        \"\"\"\n\n        self.comment = none_or(comment, str)\n        \"\"\"\n        Comment left with log item : `str`\n        \"\"\"\n\n        self.type = none_or(type, str)\n        \"\"\"\n        Type of log item : `str`\n        \"\"\"\n\n        self.action = none_or(action, str)\n        \"\"\"\n        Action of log item : `str`\n        \"\"\"\n\n        self.text = none_or(text, str)\n        \"\"\"\n        Content of text : `str`\n        \"\"\"\n\n        self.params = none_or(params, str)\n        \"\"\"\n        Content of params : `str`\n        \"\"\"\n\n        self.deleted = none_or(deleted, self.Deleted)\n        \"\"\"\n        The deleted/suppressed status of the log item.\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef entity(self) -> dict:        \n        image = {}\n        image['PartitionKey'] = self.getPartitionKey()\n        image['RowKey'] = self.getRowKey()\n        for key, value in vars(self).items():\n            if not key.startswith('_') and key not in ['','PartitionKey','RowKey']:\n                if type(value) in [str, int, bool, datetime.date, datetime.datetime]:\n                    image[key] = value                    \n        return image", "response": "parse self into dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getmodeldefinition(self, storageobject, required=False):\n\n        \"\"\" find modeldefinition for StorageTableModel or StorageTableQuery \"\"\"\n        if isinstance(storageobject, StorageTableModel):\n            definitionlist = [definition for definition in self._modeldefinitions if definition['modelname'] == storageobject.__class__.__name__]\n     \n        elif isinstance(storageobject, StorageTableQuery):\n            \"\"\" StorageTableQuery \"\"\"\n            storagemodel = storageobject._storagemodel\n            definitionlist = [definition for definition in self._modeldefinitions if definition['modelname'] == storagemodel.__class__.__name__]\n        else:\n            raise Exception(\"Argument is not an StorageTableModel nor an StorageTableQuery\")\n                                                                            \n        # is there only one modeldefinition ?\n        # hopefully!\n        modeldefinition = None\n\n        if len(definitionlist) == 1:\n            modeldefinition = definitionlist[0]\n\n        elif len(definitionlist) > 1:\n            raise ModelRegisteredMoreThanOnceError(storageobject)\n\n        # is there a modeldefinition if required ?\n        if required and modeldefinition is None:\n            raise ModelNotRegisteredError(storageobject)\n\n        return modeldefinition", "response": "get modeldefinition for storageobject"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_model(self, storagemodel:object):\n\n        modeldefinition = self.getmodeldefinition(storagemodel, False)\n\n        if modeldefinition is None:\n\n            \"\"\" test if queuename already exists \"\"\"\n            if [model for model in self._modeldefinitions if model['tablename'] == storagemodel._tablename]:\n                raise NameConventionError(storagemodel._tablename)\n\n            \"\"\" test if queuename fits to azure naming rules \"\"\"\n            if not test_azurestorage_nameconventions(storagemodel._tablename, 'StorageTableModel'):\n                raise NameConventionError(storagemodel._tablename)            \n                \n            \"\"\" now register model \"\"\"\n            modeldefinition = {\n                'modelname': storagemodel.__class__.__name__,\n                'tablename': storagemodel._tablename,\n                'encrypt': storagemodel._encrypt,\n                'tableservice': self._account.create_table_service()\n                }\n\n            if modeldefinition['encrypt']:\n                \"\"\" encrypt init \"\"\"\n                # Create the KEK used for encryption.\n                # KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.\n                kek = KeyWrapper(self._key_identifier, self._secret_key) #  Key identifier\n\n                # Create the key resolver used for decryption.\n                # KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.\n                key_resolver = KeyResolver()\n                key_resolver.put_key(kek)\n\n                # Create the EncryptionResolver Function to determine Properties to en/decrypt\n                encryptionresolver = self.__encryptionresolver__(modeldefinition['encrypt'])\n\n\n                # Set the require Encryption, KEK and key resolver on the service object.\n                modeldefinition['tableservice'].key_encryption_key = kek\n                modeldefinition['tableservice'].key_resolver_funcion = key_resolver.resolve_key\n                modeldefinition['tableservice'].encryption_resolver_function = encryptionresolver\n                pass\n\n            self.__createtable__(modeldefinition)\n                \n            self._modeldefinitions.append(modeldefinition)\n\n            log.info('model {} registered successfully. Models are {!s}.'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))\n        else:\n            log.info('model {} already registered. Models are {!s}.'.format(modeldefinition['modelname'], [model['modelname'] for model in self._modeldefinitions]))", "response": "register a new StorageTableModel in the Azure Storage Account"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unregister_model(self, storagemodel:object, delete_table=False):\n        \n        # get modeldefinition\n        modeldefinition = self.getmodeldefinition(storagemodel, True)\n\n        # remove from modeldefinitions\n        for i in range(len(self._modeldefinitions)):\n            if self._modeldefinitions[i]['modelname'] == modeldefinition['modelname']:\n                del self._modeldefinitions[i]\n                break\n        \n        # delete table from storage if delete_table == True        \n        if delete_table:\n            self.__deletetable__(modeldefinition)\n        pass", "response": "unregister an Azure Storage Account model"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, storagemodel) -> StorageTableModel:\n\n        modeldefinition = self.getmodeldefinition(storagemodel, True)\n\n        try:\n\n            pk = storagemodel.getPartitionKey()\n            rk = storagemodel.getRowKey()\n\n            entity = modeldefinition['tableservice'].get_entity(modeldefinition['tablename'], pk, rk)\n            storagemodel._exists = True\n        \n            \"\"\" sync with entity values \"\"\"\n            for key, default in vars(storagemodel).items():\n                if not key.startswith('_') and key not in ['','PartitionKey','RowKey']:\n                    value = getattr(entity, key, None)\n                    if not value is None:\n                        setattr(storagemodel, key, value)\n             \n        except AzureMissingResourceHttpError as e:\n            log.debug('can not get table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], pk, rk, e))\n            storagemodel._exists = False\n\n        except Exception as e:\n            msg = 'can not get table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], pk, rk, e)\n            raise AzureStorageWrapException(msg=msg)\n\n        finally:\n            return storagemodel", "response": "get the entity from storage"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, storagemodel) -> StorageTableModel:\n\n        modeldefinition = self.getmodeldefinition(storagemodel, True)\n\n        try:\n            modeldefinition['tableservice'].insert_or_replace_entity(modeldefinition['tablename'], storagemodel.entity())\n            storagemodel._exists = True\n\n        except AzureMissingResourceHttpError as e:\n            storagemodel._exists = False\n            log.debug('can not insert or replace table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], storagemodel.getPartitionKey(), storagemodel.getRowKey(), e))\n\n        except Exception as e:\n            storagemodel._exists = False\n            msg = 'can not insert or replace table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], storagemodel.PartitionKey, storagemodel.RowKey, e)\n            raise AzureStorageWrapException(msg=msg)\n\n        finally:\n            return storagemodel", "response": "insert a new instance of StorageTableModel into storage"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge the given object with the current one", "response": "def merge(self, storagemodel) -> StorageTableModel:\n        \"\"\" try to merge entry \"\"\"\n        modeldefinition = self.getmodeldefinition(storagemodel, True)\n       \n        try:\n            pk = storagemodel.getPartitionKey()\n            rk = storagemodel.getRowKey()\n            entity = modeldefinition['tableservice'].get_entity(modeldefinition['tablename'], pk, rk)\n        \n            \"\"\" merge with entity values \"\"\"\n            for key, default in vars(storagemodel.__class__).items():\n                if not key.startswith('_') and key not in ['']:\n\n                    if isinstance(default, PartitionKey) or isinstance(default, RowKey) or  isinstance(default, EncryptKey):\n                        default = default._default\n\n                    newvalue = getattr(storagemodel, key, None)\n                    if (newvalue is None) or (newvalue == default):\n                        oldvalue = getattr(entity, key, default)\n                        setattr(storagemodel, key, oldvalue)\n            \n            modeldefinition['tableservice'].insert_or_replace_entity(modeldefinition['tablename'], storagemodel.entity())\n            storagemodel._exists = True\n\n        except AzureMissingResourceHttpError as e:\n            log.debug('can not merge table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], pk, rk, e))\n\n        except Exception as e:\n            log.debug('can not merge table entity:  Table {}, PartitionKey {}, RowKey {} because {!s}'.format(modeldefinition['tablename'], pk, rk, e))\n\n        finally:\n            return storagemodel"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload a backup driver from the backup directory.", "response": "def load(*, name=\"dummy\", options={}, dry_run=False, **kwargs):\n    \"\"\"\n    Load a backup driver\n\n    :param name(str, optional): name of the backup driver to load\n    :param options(dict, optional): A dictionary passed to the driver\n    :param dry_run(bool, optional): Whether to activate dry run mode\n    :param \\*\\*kwargs: arbitrary keyword arguments\n    :raises ValueError: if specified driver does not exist\n    \"\"\"\n    global _driver\n\n    # Try to load specified driver\n    if name in VALID_DRIVERS:\n        # log the thing first\n        log.msg_debug(\"Attempting to load driver: {d}\".format(d=name))\n\n        # Load the driver (which is actually a python\n        # module inside the drivers directory)\n        _driver = importlib.import_module(\".drivers.{name}\"\n                                          .format(name=name), __package__)\n        if _driver:\n            _driver.load(dry_run=dry_run, **options)\n            log.msg_debug(\"Backup driver '{driver}'\" \\\n                          \" has been loaded successfully!\"\n                          .format(driver=_driver.get_name()))\n    else:\n        raise ValueError(\"Invalid backup driver name: {driver}\"\n                         .format(driver=name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef backup_file(*, file, host):\n    if _driver:\n        log.msg_debug(\"[{driver}] Backing up file '{file}'\"\n                      .format(driver=_driver.get_name(), file=file))\n        _driver.backup_file(file=file, host=host)", "response": "Backup a file in the set of available resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms cleanup on set driver Perform cleanup on set driver", "response": "def dispose():\n    \"\"\"\n    Perform cleanup on set driver\n    \"\"\"\n    if _driver:\n        log.msg_debug(\"[{driver}] dispose\".format(driver=_driver.get_name()))\n        _driver.dispose()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(global_config, **settings):\n    # Initialize the database\n    engine = engine_from_config(settings, 'sqlalchemy.')\n    configure_sql(engine)\n\n    secure_cookies = settings.get('secure_cookies') != 'false'\n    if 'pyramid_debugtoolbar' in settings['pyramid.includes']:\n        create_schema(global_config['__file__'])\n        populate_database()\n        secure_cookies = False\n\n    # Configure the webapp\n    authen = AuthTktAuthenticationPolicy(secret=settings['auth_secret'],\n                                         callback=group_finder,\n                                         secure=secure_cookies,\n                                         include_ip=False, hashalg='sha512',\n                                         wild_domain=False, max_age=5000000)\n    author = ACLAuthorizationPolicy()\n    session_factory = UnencryptedCookieSessionFactoryConfig(\n        settings['cookie_secret'])\n    config = Configurator(settings=settings, authentication_policy=authen,\n                          authorization_policy=author, root_factory=Root,\n                          session_factory=session_factory)\n    config.add_static_view('static', 'static', cache_max_age=3600)\n    # Add attributes to request\n    config.add_request_method(get_user, 'user', reify=True)\n    config.add_request_method(get_queue_func, 'queue', reify=True)\n\n    add_routes(config)\n    config.scan()\n    return config.make_wsgi_app()", "response": "This function returns a Pyramid WSGI application."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse list of TimeResource objects based on the mementoweb. org API.", "response": "def mementoweb_api_tags(url):\n    \"\"\"\n    Parse list of :class:`TimeResource` objects based on the mementoweb.org.\n\n    Args:\n        url (str): Any url.\n\n    Returns:\n        list: :class:`TimeResource` objects.\n    \"\"\"\n    memento_url = \"http://labs.mementoweb.org/timemap/json/\"\n\n    r = requests.get(memento_url + url)\n\n    if r.status_code != 200:\n        return []\n\n    data = r.json().get(\"mementos\", {}).get(\"list\", [])\n\n    if not data:\n        return []\n\n    resources = (\n        TimeResource(\n            url=item.get(\"uri\", \"\"),\n            date=item.get(\"datetime\", \"\"),\n            val=item.get(\"datetime\", \"\").split(\"-\")[0],\n            source=\"MementoWeb.org\",\n        )\n        for item in data\n    )\n\n    # deduplicate the resources\n    resource_dict = {\n        res.val: res\n        for res in resources\n    }\n\n    return sorted(resource_dict.values(), key=lambda x: x.val)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_whois_tags(domain):\n    data = pythonwhois.get_whois(domain)\n\n    return [\n        TimeResource(\n            url=WHOIS_URL % domain.strip(),\n            date=date.isoformat(\"T\"),\n            val=date.strftime(\"%Y\"),\n            source=\"Whois\",\n        )\n        for date in data.get(\"creation_date\", [])\n    ]", "response": "Get list of TimeResource objects with creation dates from Whois database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_creation_date_tags(url, domain, as_dicts=False):\n    creation_date_tags = [\n        mementoweb_api_tags(url),\n        get_whois_tags(domain),\n    ]\n\n    creation_date_tags = sorted(\n        sum(creation_date_tags, []),\n        key=lambda x: x.date\n    )\n\n    if not as_dicts:\n        return creation_date_tags\n\n    return [\n        item._as_dict()\n        for item in creation_date_tags\n    ]", "response": "Put together all data sources in this module and return it s output."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pil_image_to_django_file(self, pil_image):\n        '''\n        Gets a PIL image ready to be able to be saved using\n        :py:meth:`django.db.models.fields.files.FieldFile.save`\n\n        It converts the mode first to ``RGB`` or ``L``, so that it can\n        then save it as a ``JPEG``. It will save it as a progressive\n        ``JPEG`` with a quality of :py:attr:`IMAGE_QUALITY`.\n\n        :param pil_image: original image\n        :type pil_image: :py:class:`PIL.Image.Image`\n        :return: transformed image\n        :rtype: :py:class:`django.core.files.base.ContentFile`\n        '''\n        if pil_image.mode not in ('L', 'RGB'):\n            pil_image = pil_image.convert(\"RGB\")\n        temp_io = six.BytesIO()\n\n        pil_image.save(\n            temp_io,\n            \"JPEG\",\n            quality=self.IMAGE_QUALITY,\n            optimize=True,\n            progressive=True,\n            icc_profile=pil_image.info.get('icc_profile')\n        )\n\n        temp_io.seek(0)\n        django_file = ContentFile(temp_io.getvalue())\n        return django_file", "response": "Converts a PIL image to a django file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef django_file_to_pil_image(self, django_file):\n        '''\n        Converts a the file returned by\n        :py:class:`django.db.models.fields.ImageField` to a PIL image.\n\n        :param django_file: django file\n        :type django_file: :py:class:`django.db.models.fields.files.FieldFile`\n        :rtype: :py:class:`PIL.Image.Image`\n        '''\n        django_file.open()\n        pil_image = Image.open(django_file.file)\n        return pil_image", "response": "Converts a django file returned by django_file to a PIL image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transform_pil_image(self, pil_image):\n        '''\n        Uses :py:meth:`PIL.Image.Image.transform` to scale\n        down the image.\n\n        Based on `this stackoverflow discussions <http://stackoverflow.com/a/940368/907060>`_, uses\n        :attr:`PIL.Image.ANTIALIAS`\n        '''\n        max_width = min(self.dimensions[0] or float('inf'), pil_image.size[0])\n        max_height = min(self.dimensions[1] or float('inf'), pil_image.size[1])\n        max_dimensions = (max_width, max_height)\n\n        pil_image.thumbnail(max_dimensions, Image.ANTIALIAS)\n        return pil_image", "response": "Transform the PIL image to fit the image size."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntemplating tag to render a category with all it s entries.", "response": "def render_category(slug):\n    \"\"\"Template tag to render a category with all it's entries.\"\"\"\n    try:\n        category = EntryCategory.objects.get(slug=slug)\n    except EntryCategory.DoesNotExist:\n        pass\n    else:\n        return {'category': category}\n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_Name(name, short=False):\n\n    # For the shortform, we have a lookup table\n    # See RFC4514 for more details\n    sf = {\n          \"countryName\": \"C\",\n          \"stateOrProvinceName\": \"ST\",\n          \"localityName\": \"L\",\n          \"organizationalUnitName\": \"OU\",\n          \"organizationName\": \"O\",\n          \"commonName\": \"CN\",\n          \"emailAddress\": \"E\",\n         }\n    return \", \".join([\"{}={}\".format(attr.oid._name if not short or attr.oid._name not in sf else sf[attr.oid._name], attr.value) for attr in name])", "response": "Return the distinguished name of an X509 Certificate containing the name of the given name object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_Certificate(cert, short=False):\n\n    for h in [hashes.MD5, hashes.SHA1, hashes.SHA256, hashes.SHA512]:\n        print(\"{}: {}\".format(h.name, binascii.hexlify(cert.fingerprint(h())).decode(\"ascii\")))\n    print(\"Issuer: {}\".format(get_Name(cert.issuer, short=short)))\n    print(\"Subject: {}\".format(get_Name(cert.subject, short=short)))", "response": "Prints the fingerprints Issuer and Subject of a cryptography. x509. Certificate object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the appname of the APK", "response": "def get_app_name(self):\n        \"\"\"\n            Return the appname of the APK\n\n            :rtype: string\n        \"\"\"\n        main_activity_name = self.get_main_activity()\n\n        app_name = self.get_element('activity', 'label', name=main_activity_name)\n        if not app_name:\n            app_name = self.get_element('application', 'label')\n\n        if app_name.startswith(\"@\"):\n            res_id = int(app_name[1:], 16)\n            res_parser = self.get_android_resources()\n\n            try:\n                app_name = res_parser.get_resolved_res_configs(\n                    res_id,\n                    ARSCResTableConfig.default_config())[0][1]\n            except Exception as e:\n                anconf.warning(\"Exception selecting app name: %s\" % e)\n                app_name = \"\"\n        return app_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_files_types(self):\n        for i in self.get_files():\n            buffer = self.zip.read(i)\n            self.files_crc32[i] = crc32(buffer)\n            self.files[i] = \"Unknown\"\n        return self.files", "response": "Return the files inside the APK with their associated types"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_files_information(self):\n        if self.files == {}:\n            self.get_files_types()\n\n        for i in self.get_files():\n            try:\n                yield i, self.files[i], self.files_crc32[i]\n            except KeyError:\n                yield i, \"\", \"\"", "response": "Return the files inside the APK with their associated types and crc32"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the raw data of all classes. dex files", "response": "def get_all_dex(self):\n        \"\"\"\n            Return the raw data of all classes dex files\n\n            :rtype: a generator\n        \"\"\"\n        try:\n            yield self.get_file(\"classes.dex\")\n\n            # Multidex support\n            basename = \"classes%d.dex\"\n            for i in range(2, sys.maxsize):\n                yield self.get_file(basename % i)\n        except FileNotPresent:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the elements in xml files which match with the tag name and the specific attribute", "response": "def get_elements(self, tag_name, attribute):\n        \"\"\"\n            Return elements in xml files which match with the tag name and the specific attribute\n\n            :param tag_name: a string which specify the tag name\n            :param attribute: a string which specify the attribute\n        \"\"\"\n        l = []\n        for i in self.xml:\n            for item in self.xml[i].getElementsByTagName(tag_name):\n                value = item.getAttributeNS(NS_ANDROID_URI, attribute)\n                value = self.format_value(value)\n\n                l.append(str(value))\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_element(self, tag_name, attribute, **attribute_filter):\n        for i in self.xml:\n            if self.xml[i] is None :\n                continue\n            tag = self.xml[i].getElementsByTagName(tag_name)\n            if tag is None:\n                return None\n            for item in tag:\n                skip_this_item = False\n                for attr, val in list(attribute_filter.items()):\n                    attr_val = item.getAttributeNS(NS_ANDROID_URI, attr)\n                    if attr_val != val:\n                        skip_this_item = True\n                        break\n\n                if skip_this_item:\n                    continue\n\n                value = item.getAttributeNS(NS_ANDROID_URI, attribute)\n\n                if len(value) > 0:\n                    return value\n        return None", "response": "Return the element in xml files which match with the tag name and the specific attribute"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_main_activity(self):\n        x = set()\n        y = set()\n\n        for i in self.xml:\n            activities_and_aliases = self.xml[i].getElementsByTagName(\"activity\") + \\\n                                     self.xml[i].getElementsByTagName(\"activity-alias\")\n\n            for item in activities_and_aliases:\n                # Some applications have more than one MAIN activity.\n                # For example: paid and free content\n                activityEnabled = item.getAttributeNS(NS_ANDROID_URI, \"enabled\")\n                if activityEnabled is not None and activityEnabled != \"\" and activityEnabled == \"false\":\n                    continue\n\n                for sitem in item.getElementsByTagName(\"action\"):\n                    val = sitem.getAttributeNS(NS_ANDROID_URI, \"name\")\n                    if val == \"android.intent.action.MAIN\":\n                        x.add(item.getAttributeNS(NS_ANDROID_URI, \"name\"))\n\n                for sitem in item.getElementsByTagName(\"category\"):\n                    val = sitem.getAttributeNS(NS_ANDROID_URI, \"name\")\n                    if val == \"android.intent.category.LAUNCHER\":\n                        y.add(item.getAttributeNS(NS_ANDROID_URI, \"name\"))\n\n        z = x.intersection(y)\n        if len(z) > 0:\n            return self.format_value(z.pop())\n        return None", "response": "Return the name of the main activity."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a certificate object by giving the name in the apk file", "response": "def get_certificate(self, filename):\n        \"\"\"\n            Return a certificate object by giving the name in the apk file\n        \"\"\"\n        pkcs7message = self.get_file(filename)\n\n        message, _ = decode(pkcs7message)\n        cert = encode(message[1][3])\n        # Remove the first identifier\u00b7\n        # byte 0 == identifier, skip\n        # byte 1 == length. If byte1 & 0x80 > 1, we have long format\n        #                   The length of to read bytes is then coded\n        #                   in byte1 & 0x7F\n        cert = cert[2 + (cert[1] & 0x7F) if cert[1] & 0x80 > 1 else 2:]\n\n        certificate = x509.load_der_x509_certificate(cert, default_backend())\n\n        return certificate"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new zip file containing all the items in the archive.", "response": "def new_zip(self, filename, deleted_files=None, new_files={}):\n        \"\"\"\n            Create a new zip file\n\n            :param filename: the output filename of the zip\n            :param deleted_files: a regex pattern to remove specific file\n            :param new_files: a dictionnary of new files\n\n            :type filename: string\n            :type deleted_files: None or a string\n            :type new_files: a dictionnary (key:filename, value:content of the file)\n        \"\"\"\n        if self.zipmodule == 2:\n            from reston.patch import zipfile\n            zout = zipfile.ZipFile(filename, 'w')\n        else:\n            import zipfile\n            zout = zipfile.ZipFile(filename, 'w')\n\n        for item in self.zip.infolist():\n            if deleted_files is not None:\n                if re.match(deleted_files, item.filename) == None:\n                    if item.filename in new_files:\n                        zout.writestr(item, new_files[item.filename])\n                    else:\n                        buffer = self.zip.read(item.filename)\n                        zout.writestr(item, buffer)\n        zout.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_android_resources(self):\n        try:\n            return self.arsc[\"resources.arsc\"]\n        except KeyError:\n            self.arsc[\"resources.arsc\"] = ARSCParser(self.zip.read(\n                \"resources.arsc\"))\n            return self.arsc[\"resources.arsc\"]", "response": "Return the ARSCParser object which corresponds to the resources. arsc file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of the signature file names.", "response": "def get_signature_names(self):\n        \"\"\"\n             Return a list of the signature file names.\n        \"\"\"\n        signature_expr = re.compile(\"^(META-INF/)(.*)(\\.RSA|\\.EC|\\.DSA)$\")\n        signatures = []\n\n        for i in self.get_files():\n            if signature_expr.search(i):\n                signatures.append(i)\n\n        if len(signatures) > 0:\n            return signatures\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_view(view, decorators=None):\n    # http://stackoverflow.com/questions/9222129/python-inspect-getmembers-does-not-return-the-actual-function-when-used-with-dec\n    if decorators is None:\n        decorators = []\n    if getattr(view, 'func_closure', None) is not None:\n        decorators.append(view)\n        for closure in view.func_closure:\n            if callable(closure.cell_contents):\n                return extract_view(closure.cell_contents, decorators)\n    if inspect.isfunction(view) or inspect.ismethod(view):\n        pass\n    elif inspect.isclass(view):\n        pass\n    else:\n        view = view.__class__\n    return view, decorators", "response": "Extract a view object out of any wrapping decorators."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_decorators(func):\n    decorators = []\n    # Parse the source code of the function with ast to find the names of\n    # all of its decorators.\n    tree = ast.parse(inspect.getsource(func))\n    for node in ast.iter_child_nodes(tree):\n        for dnode in node.decorator_list:\n            if isinstance(dnode, ast.Name):\n                decorator = func.func_globals[dnode.id]\n            elif isinstance(dnode, ast.Attribute):\n                module = func.func_globals[dnode.value.id]\n                decorator = getattr(module, dnode.attr)\n            else:\n                raise Exception(\"Unable to handle decorator node: %s\" % dnode)\n            decorators.append(decorator)\n    return decorators", "response": "Return a list of decorator names for this function."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string representation of the side effect.", "response": "def side_effect_as_string(*args):\n    '''\n    side_effect_as_string() -> \"ANY_FUNCTION(ANY_ARGS, ANY_KWARGS)\"\n    side_effect_as_string(\"foo\") -> \"foo(ANY_ARGS, ANY_KWARGS)\"\n    side_effect_as_string(\"foo\", (42, )) -> \"foo(42, ANY_KWARGS)\"\n    side_effect_as_string(\"foo\", (42, 18)) -> \"foo(42, 18, ANY_KWARGS)\"\n    side_effect_as_string(\"foo\", (), {}) -> \"foo()\"\n    side_effect_as_string(\"foo\", (), {\"barr\": \"spam\"}) -> \"foo(barr=\\\"spam\\\")\"\n    side_effect_as_string(\"foo\", (), {}, None) -> \"foo(): None\"\n    side_effect_as_string(\"foo\", None, {}, 42) -> \"foo(ANY_ARGS): 42\"\n    '''\n    fun_id = \"ANY_FUNCTION\"\n    se_args = None\n    se_kwargs= None\n\n    if len(args) > 0:\n        fun_id = args[0] or \"ANY_FUNCTION\"\n\n    if len(args) > 1:\n        se_args = args[1]\n\n    if len(args) > 2:\n        se_kwargs = args[2]\n\n    if se_args is None:\n        args_desc = [\"ANY_ARGS\"]\n    elif isinstance(se_args, tuple):\n        args_desc = [repr(a) for a in se_args]\n    else:\n        args_desc = [str(se_args)]\n\n    if se_kwargs is None:\n        kwargs_desc = [\"ANY_KWARGS\"]\n    elif isinstance(se_kwargs, dict):\n        kwargs_desc = [\"%s=%r\" % (n, v) for n, v in se_kwargs.items()]\n    else:\n        kwargs_desc = [str(se_kwargs)]\n\n    params = \", \".join(args_desc + kwargs_desc)\n    text = \"%s(%s)\" % (fun_id, params)\n\n    if len(args) < 5:\n        return text\n\n    if len(args) > 5:\n        raise RuntimeError(\"Invalid side-effect specification\")\n\n    result = args[4]\n    return text + \": \" + repr(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snapshot_registry(self):\n        '''\n        Give the dictionary of recorders detached from the existing instances.\n        It is safe to store those references for future use. Used by feattool.\n        '''\n        unserializer = banana.Unserializer(externalizer=self)\n        serializer = banana.Serializer(externalizer=self)\n        return unserializer.convert(serializer.convert(self.registry))", "response": "Returns the dictionary of recorders detached from the existing instances."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_driver(secret_key=config.DEFAULT_SECRET_KEY, userid=config.DEFAULT_USERID,\n               provider=config.DEFAULT_PROVIDER):\n\n    \"\"\"A driver represents successful authentication.  They become\n    stale, so obtain them as late as possible, and don't cache them.\"\"\"\n\n    if hasattr(config, 'get_driver'):\n        logger.debug('get_driver %s' % config.get_driver)\n        return config.get_driver()\n    else:\n        logger.debug('get_driver {0}@{1}'.format(userid, provider))\n        return libcloud.compute.providers.get_driver(\n            config.PROVIDERS[provider])(userid, secret_key)", "response": "A driver represents successful authentication."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform substitution on script based on template type and return the script.", "response": "def substitute(script, submap):\n\n    \"\"\"Check for presence of template indicator and if found, perform\n    variable substition on script based on template type, returning\n    script.\"\"\"\n\n    match = config.TEMPLATE_RE.search(script)\n    if match:\n        template_type = match.groupdict()['type']\n        try:\n            return config.TEMPLATE_TYPEMAP[template_type](script, submap)\n        except KeyError:\n            logger.error('Unsupported template type: %s' % template_type)\n            raise\n    return script"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef script_deployment(path, script, submap=None):\n\n    \"\"\"Return a ScriptDeployment from script with possible template\n    substitutions.\"\"\"\n\n    if submap is None:\n        submap = {}\n    script = substitute(script, submap)\n    return libcloud.compute.deployment.ScriptDeployment(script, path)", "response": "Return a ScriptDeployment from a script with possible template\n    substitutions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(items, amap, load=False):\n\n    \"\"\"Merge list of tuples into dict amap, and optionally load source as value\"\"\"\n\n    for target, source in items:\n        if amap.get(target):\n            logger.warn('overwriting {0}'.format(target))\n        if load:\n            amap[target] = open(source).read()\n        else:\n            amap[target] = source", "response": "Merge list of tuples into dict amap and optionally load source as value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmerging list of key = val strings into dict amap warning of duplicate keys", "response": "def merge_keyvals_into_map(keyvals, amap):\n\n    \"\"\"Merge list of 'key=val' strings into dict amap, warning of duplicate keys\"\"\"\n\n    for kv in keyvals:\n        k,v = kv.split('=')\n        if k in amap:\n            logger.warn('overwriting {0} with {1}'.format(k, v))\n        amap[k] = v"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a size from a list of sizes.", "response": "def size_from_name(size, sizes):\n\n    \"\"\"Return a size from a list of sizes.\"\"\"\n\n    by_name = [s for s in sizes if s.name == size]\n    if len(by_name) > 1:\n        raise Exception('more than one image named %s exists' % size)\n    return by_name[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef image_from_name(name, images):\n\n    \"\"\"Return an image from a list of images.  If the name is an exact\n    match, return the last exactly matching image.  Otherwise, sort\n    images by 'natural' order, using decorate-sort-undecorate, and\n    return the largest.\n\n    see:\n    http://code.activestate.com/recipes/285264-natural-string-sorting/\n    \"\"\"\n\n    prefixed_images = [i for i in images if i.name.startswith(name)]\n\n    if name in [i.name for i in prefixed_images]:\n        return [i for i in prefixed_images if i.name == name][-1]\n\n    decorated = sorted(\n        [(int(re.search('\\d+', i.name).group(0)), i) for i in prefixed_images])\n    return [i[1] for i in decorated][-1]", "response": "Return an image from a list of images."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndestroys all nodes matching specified name", "response": "def destroy_by_name(name, driver):\n\n    \"\"\"Destroy all nodes matching specified name\"\"\"\n\n    matches = [node for node in list_nodes(driver) if node.name == name]\n    if len(matches) == 0:\n        logger.warn('no node named %s' % name)\n        return False\n    else:\n        return all([node.destroy() for node in matches])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef destroy(self):\n\n        \"\"\"Insure only destroyable nodes are destroyed\"\"\"\n\n        node = self.node\n        if not config.is_node_destroyable(node.name):\n            logger.error('node %s has non-destroyable prefix' % node.name)\n            return False\n        logger.info('destroying node %s' % node)\n        return node.destroy()", "response": "Insure only destroyable nodes are destroyed"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeploys this node using the given driver.", "response": "def deploy(self, driver, location_id=config.DEFAULT_LOCATION_ID,\n               size=config.DEFAULT_SIZE):\n\n        \"\"\"Use driver to deploy node, with optional ability to specify\n        location id and size id.\n\n        First, obtain location object from driver.  Next, get the\n        size.  Then, get the image. Finally, deploy node, and return\n        NodeProxy. \"\"\"\n\n        logger.debug('deploying node %s using driver %s' % (self.name, driver))\n\n        args = {'name': self.name}\n\n        if hasattr(config, 'SSH_KEY_NAME'):\n            args['ex_keyname'] = config.SSH_KEY_NAME\n\n        if hasattr(config, 'EX_USERDATA'):\n            args['ex_userdata'] = config.EX_USERDATA\n\n        args['location'] = driver.list_locations()[location_id]\n        logger.debug('location %s' % args['location'])\n\n        args['size'] = size_from_name(size, driver.list_sizes())\n        logger.debug('size %s' % args['size'])\n\n        logger.debug('image name %s' % config.IMAGE_NAMES[self.image_name])\n        args['image'] = image_from_name(\n            config.IMAGE_NAMES[self.image_name], driver.list_images())\n        logger.debug('image %s' % args['image'])\n\n        logger.debug('creating node with args: %s' % args)\n        node = driver.create_node(**args)\n        logger.debug('node created')\n\n        # password must be extracted before _wait_until_running(), where it goes away\n        logger.debug('driver.features %s' % driver.features)\n        password = node.extra.get('password') \\\n            if 'generates_password' in driver.features['create_node'] else None\n\n        logger.debug('waiting for node to obtain %s' % config.SSH_INTERFACE)\n        node, ip_addresses = driver._wait_until_running(\n            node, timeout=1200, ssh_interface=config.SSH_INTERFACE)\n\n        ssh_args = {'hostname': ip_addresses[0], 'port': 22, 'timeout': 10}\n        if password:\n            ssh_args['password'] = password\n        else:\n            ssh_args['key'] = config.SSH_KEY_PATH if hasattr(config, 'SSH_KEY_PATH') else None\n\n        logger.debug('initializing ssh client with %s' % ssh_args)\n        ssh_client = libcloud.compute.ssh.SSHClient(**ssh_args)\n\n        logger.debug('ssh client attempting to connect')\n        ssh_client = driver._ssh_client_connect(ssh_client)\n        logger.debug('ssh client connected')\n\n        logger.debug('starting node deployment with %s steps' % len(self.deployment.steps))\n        driver._run_deployment_script(self.deployment, node, ssh_client)\n\n        node.script_deployments = self.script_deployments # retain exit_status, stdout, stderr\n\n        logger.debug('node.extra[\"imageId\"] %s' % node.extra['imageId'])\n\n        return NodeProxy(node, args['image'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nannotates a possible value for an option in the order they appear.", "response": "def option(value, is_default=False, label=None):\n    \"\"\"\n    Annotates a possible value for IValueOptions,\n    will be validated at instance creation time.\n\n    @param value:      a possible value for the IValueOptions being defined.\n    @type  value:      Any\n    @param is_default: if the option should be the default value.\n    @type  is_default: bool\n    @param label:      option label or None; if none the string representation\n                       of the value will be used as label.\n    @type  label:      str or unicode or None\n    \"\"\"\n    _annotate(\"option\", value, is_default=is_default, label=label)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates that the value is a valid unicode object.", "response": "def validate(self, value):\n        \"\"\"\n        Accepts: str, unicode\n        Returns: unicode\n        \"\"\"\n        val = value\n        if isinstance(val, str):\n            #FIXME: unsafe decoding\n            val = unicode(value)\n        val = super(String, self).validate(val)\n        if not isinstance(val, unicode):\n            raise ValueError(\"Not a string: %r\" % (value, ))\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the value of the national product key.", "response": "def validate(self, value):\n        \"\"\"\n        Accepts: float, int, long, str, unicode\n        Returns: float\n        \"\"\"\n        if isinstance(value, (str, unicode, int, long)):\n            value = float(value)\n        value = super(Float, self).validate(value)\n        if not isinstance(value, (float)):\n            raise ValueError(\"Not an float: %r\" % (value, ))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the value of the field.", "response": "def publish(self, value):\n        \"\"\"\n        Accepts: float\n        Returns: float\n        \"\"\"\n        value = super(Float, self).publish(value)\n        if isinstance(value, int):\n            value = float(value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef publish(self, value):\n        value = super(Integer, self).publish(value)\n        if isinstance(value, float):\n            value = int(value)\n        if not isinstance(value, (int, long)):\n            raise ValueError(\"Not an integer: %r\" % (value, ))\n        return value", "response": "Publishes an integer to the current value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate the value of the Taxonomy field.", "response": "def validate(self, value):\n        \"\"\"\n        Accepts: str, unicode, bool\n        Returns: bool\n        \"\"\"\n        if isinstance(value, bool):\n            return value\n        if isinstance(value, (str, unicode)):\n            if value.lower() == \"true\":\n                value = True\n            elif value.lower() == \"false\":\n                value = False\n            else:\n                raise ValueError(\"Not a boolean: %r\" % (value, ))\n        value = super(Boolean, self).validate(value)\n        if not isinstance(value, bool):\n            raise ValueError(\"Not a boolean: %r\" % (value, ))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _eq(field, value, document):\n    try:\n        return document.get(field, None) == value\n    except TypeError:  # pragma: no cover Python < 3.0\n        return False", "response": "Returns True if the value of a document field is equal to a given value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _gt(field, value, document):\n    try:\n        return document.get(field, None) > value\n    except TypeError:  # pragma: no cover Python < 3.0\n        return False", "response": "Returns True if the value of a document field is greater than a given value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _lt(field, value, document):\n    try:\n        return document.get(field, None) < value\n    except TypeError:  # pragma: no cover Python < 3.0\n        return False", "response": "Returns True if the value of a document field is less than a given value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _gte(field, value, document):\n    try:\n        return document.get(field, None) >= value\n    except TypeError:  # pragma: no cover Python < 3.0\n        return False", "response": "Returns True if the value of a document field is greater than orEquals to a given value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the value of a document field is less than orEquals to a given value", "response": "def _lte(field, value, document):\n    \"\"\"\n    Returns True if the value of a document field is less than or\n    equal to a given value\n    \"\"\"\n    try:\n        return document.get(field, None) <= value\n    except TypeError:  # pragma: no cover Python < 3.0\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the value of document field contains all the values specified by value.", "response": "def _all(field, value, document):\n    \"\"\"\n    Returns True if the value of document field contains all the values\n    specified by ``value``. If supplied value is not an iterable, a\n    MalformedQueryException is raised. If the value of the document field\n    is not an iterable, False is returned\n    \"\"\"\n    try:\n        a = set(value)\n    except TypeError:\n        raise MalformedQueryException(\"'$all' must accept an iterable\")\n\n    try:\n        b = set(document.get(field, []))\n    except TypeError:\n        return False\n    else:\n        return a.intersection(b) == a"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _in(field, value, document):\n    try:\n        values = iter(value)\n    except TypeError:\n        raise MalformedQueryException(\"'$in' must accept an iterable\")\n\n    return document.get(field, None) in values", "response": "Returns True if the document [ field ] is in the value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _mod(field, value, document):\n    try:\n        divisor, remainder = map(int, value)\n    except (TypeError, ValueError):\n        raise MalformedQueryException(\"'$mod' must accept an iterable: [divisor, remainder]\")\n\n    try:\n        return int(document.get(field, None)) % divisor == remainder\n    except (TypeError, ValueError):\n        return False", "response": "Returns True if the value of a field is divisible by the value of a document."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _exists(field, value, document):\n    if value not in (True, False):\n        raise MalformedQueryException(\"'$exists' must be supplied a boolean\")\n\n    if value:\n        return field in document\n    else:\n        return field not in document", "response": "Checks if a given field exists in a given document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, *args, **kwargs):\n        self.db = sqlite3.connect(*args, **kwargs)\n        self.db.isolation_level = None", "response": "Connect to a sqlite database only if no connection exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, document):\n        if '_id' in document:\n            return self.update(document)\n\n        # Create it and return a modified one with the id\n        cursor = self.db.execute(\"\"\"\n            insert into %s(data) values (?)\n        \"\"\" % self.name, (json.dumps(document),))\n\n        document['_id'] = cursor.lastrowid\n        return document", "response": "Inserts a document into this collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating a document stored in this collection.", "response": "def update(self, document):\n        \"\"\"\n        Updates a document stored in this collection. If the document does not\n        already have an '_id' value, it will be created\n        \"\"\"\n        if '_id' not in document:\n            return self.insert(document)\n\n        # Update the stored document, removing the id\n        copy = document.copy()\n        del copy['_id']\n\n        self.db.execute(\"\"\"\n            update %s set data = ? where id = ?\n        \"\"\" % self.name, (json.dumps(copy), document['_id']))\n\n        return document"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a document from this collection.", "response": "def remove(self, document):\n        \"\"\"\n        Removes a document from this collection. This will raise AssertionError if the\n        document does not have an _id attribute\n        \"\"\"\n        assert '_id' in document, 'Document must have an id'\n        self.db.execute(\"delete from %s where id = ?\" % self.name, (document['_id'],))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load(self, id, data):\n        if isinstance(data, bytes):  # pragma: no cover Python >= 3.0\n            data = data.decode('utf-8')\n\n        document = json.loads(data)\n        document['_id'] = id\n        return document", "response": "Load a JSON document taking care to apply the document id\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find(self, query=None, limit=None):\n        results = []\n        query = query or {}\n\n        # TODO: When indexes are implemented, we'll need to intelligently hit one of the\n        # index stores so we don't do a full table scan\n        cursor = self.db.execute(\"select id, data from %s\" % self.name)\n        apply = partial(self._apply_query, query)\n\n        for match in filter(apply, starmap(self._load, cursor.fetchall())):\n            results.append(match)\n\n            # Just return if we already reached the limit\n            if limit and len(results) == limit:\n                return results\n\n        return results", "response": "Returns a list of documents in this collection that match a given query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _apply_query(self, query, document):\n        matches = []  # A list of booleans\n        reapply = lambda q: self._apply_query(q, document)\n\n        for field, value in query.items():\n            # A more complex query type $and, $or, etc\n            if field == '$and':\n                matches.append(all(map(reapply, value)))\n            elif field == '$or':\n                matches.append(any(map(reapply, value)))\n            elif field == '$nor':\n                matches.append(not any(map(reapply, value)))\n            elif field == '$not':\n                matches.append(not self._apply_query(value, document))\n\n            # Invoke a query operator\n            elif isinstance(value, dict):\n                for operator, arg in value.items():\n                    if not self._get_operator_fn(operator)(field, arg, document):\n                        matches.append(False)\n                        break\n                else:\n                    matches.append(True)\n\n            # Standard\n            elif value != document.get(field, None):\n                # check if field contains a dot\n                if '.' in field:\n                    nodes = field.split('.')\n                    document_section = document\n\n                    try:\n                        for path in nodes[:-1]:\n                            document_section = document_section.get(path, None)\n                    except AttributeError:\n                        document_section = None\n\n                    if document_section is None:\n                        matches.append(False)\n                    else:\n                        if value != document_section.get(nodes[-1], None):\n                            matches.append(False)\n                else:\n                    matches.append(False)\n\n        return all(matches)", "response": "Applies a query to a document. Returns True if the document meets the criteria of\n        the supplied query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_operator_fn(self, op):\n        if not op.startswith('$'):\n            raise MalformedQueryException(\"Operator '%s' is not a valid query operation\" % op)\n\n        try:\n            return getattr(sys.modules[__name__], op.replace('$', '_'))\n        except AttributeError:\n            raise MalformedQueryException(\"Operator '%s' is not currently implemented\" % op)", "response": "Returns the function in this module that corresponds to an operator string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_one(self, query=None):\n        try:\n            return self.find(query=query, limit=1)[0]\n        except (sqlite3.OperationalError, IndexError):\n            return None", "response": "Returns the first record in the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_and_modify(self, query=None, update=None):\n        update = update or {}\n\n        for document in self.find(query=query):\n            document.update(update)\n            self.update(document)", "response": "Find and modify all the related objects in this collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrename this collection and all related data.", "response": "def rename(self, new_name):\n        \"\"\"\n        Rename this collection\n        \"\"\"\n        new_collection = Collection(self.db, new_name, create=False)\n        assert not new_collection.exists()\n\n        self.db.execute(\"alter table %s rename to %s\" % (self.name, new_name))\n        self.name = new_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef distinct(self, key):\n        return set(d[key] for d in filter(lambda d: key in d, self.find()))", "response": "Get a set of distinct values for the given key excluding an implicit\n        None for documents that do not contain the key\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_index(self, key, reindex=True, sparse=False):\n        warnings.warn('Index support is currently very alpha and is not guaranteed')\n        if isinstance(key, (list, tuple)):\n            index_name = ','.join(key)\n            index_columns = ', '.join('%s text' % f for f in key)\n        else:\n            index_name = key\n            index_columns = '%s text' % key\n\n        table_name = '[%s{%s}]' % (self.name, index_name)\n        reindex = reindex or not self._object_exists('table', table_name)\n\n        # Create a table store for the index data\n        self.db.execute(\"\"\"\n            create table if not exists {table} (\n                id integer primary key,\n                {columns},\n                foreign key(id) references {collection}(id) on delete cascade on update cascade\n            )\n        \"\"\".format(\n            table=table_name,\n            collection=self.name,\n            columns=index_columns\n        ))\n\n        # Create the index\n        self.db.execute(\"\"\"\n            create index if not exists [idx.{collection}{{index}}] on {table}({index})\n        \"\"\".format(\n            collection=self.name,\n            index=index_name,\n            table=table_name,\n        ))\n\n        if reindex:\n            self.reindex(key)", "response": "Creates an index for the given key in the specified collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the given key is in the index.", "response": "def ensure_index(self, key, sparse=False):\n        \"\"\"\n        Equivalent to ``create_index(key, reindex=False)``\n        \"\"\"\n        self.create_index(key, reindex=False, sparse=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request_done(self, request):\n        if self._requests is None:\n            # Channel been cleaned up because the connection was lost.\n            return\n\n        assert request == self._requests[0], \"Unexpected request done\"\n        del self._requests[0]\n\n        if request.persistent:\n            # Activate the next request in the pipeline if any\n            if self._requests:\n                self._requests[0].activate()\n        else:\n            self.transport.loseConnection()", "response": "Called by the active request when it is done writing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef meta(name, value, scheme=None):\n    annotate.injectClassCallback(\"meta\", 3, \"annotate_meta\",\n                                 name, value, scheme=scheme)", "response": "Adds meta information to the class definition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure_logging(args):\n    log_format = logging.Formatter('%(levelname)s:%(name)s:line %(lineno)s:%(message)s')\n    log_level = logging.INFO if args.verbose else logging.WARN\n    log_level = logging.DEBUG if args.debug else log_level\n    console = logging.StreamHandler()\n    console.setFormatter(log_format)\n    console.setLevel(log_level)\n    root_logger = logging.getLogger()\n    if len(root_logger.handlers) == 0:\n        root_logger.addHandler(console)\n    root_logger.setLevel(log_level)\n    root_logger.handlers[0].setFormatter(log_format)\n    logging.getLogger(__name__)", "response": "Configure logging to console"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_arguments():\n    # Pull a few settings from the environment, should they exist\n    base_dn = os.environ['PUDL_BASE_DN'] if 'PUDL_BASE_DN' in os.environ \\\n              else 'OU=Departments,DC=example,DC=com'\n    domain = os.environ['PUDL_DOMAIN'].upper() if 'PUDL_DOMAIN' in os.environ else 'EXAMPLE'\n    page_size = os.environ['PUDL_PAGE_SIZE'].upper() if 'PUDL_PAGE_SIZE' in os.environ else 300\n    tls_no_verify = bool(os.environ['PUDL_TLS_NO_VERIFY'].lower().capitalize()) \\\n                    if 'PUDL_TLS_NO_VERIFY' in os.environ else False\n\n    parser = argparse.ArgumentParser(prog='pudl',\n                                     description='A script for interacting with Active ' + \\\n                                     'Directory, leveraging python-ldap')\n    parser.add_argument('-V', '--version', action='version', version='pudl v' + pudl_version,\n                        help=\"Print the version number and exit\")\n    subparsers = parser.add_subparsers(dest='subcommand', help='Sub-command help')\n    parser_common = subparsers.add_parser('common', add_help=False)\n    parser_common.add_argument('--user', '-u', action='store', dest='user',\n                               help='The ldap user (bind dn) to connect as. ' + \\\n                               'The full DN will work, or often, just the CN may be ' + \\\n                               'sufficient, such as \"John Smith\", or more commonly, ' + \\\n                               'specify the domain and sAMAccountName. Defaults to ' + \\\n                               '{0}\\\\username.  The domain '.format(domain) + \\\n                               'portion may be overridden with PUDL_DOMAIN',\n                               default='{0}\\\\{1}'.format(domain, getpass.getuser()))\n    parser_common.add_argument('--password', '-p', action='store',\n                               dest='password', help=\"The connecting user's password\")\n    parser_common.add_argument('--host', '-H', action='store',\n                               dest='host', help='The AD/LDAP host, defaults to ldap',\n                               default='ldap')\n    parser_common.add_argument('--port', '-P', action='store', dest='port',\n                               help='The ldap port, defaults to 389.  389 is ' + \\\n                               'is the standard port', type=int, default=389)\n    parser_common.add_argument('--page-size', '-s', action='store', dest='page_size',\n                               help='The ldap results are paged, specify the ' + \\\n                               'number of results per page, defaults to ' + \\\n                               '{0}. May be overridden with PUDL_PAGE_SIZE'.format(page_size),\n                               type=int, default=page_size)\n    parser_common.add_argument('--base-dn', '-b', action='store',\n                               dest='base_dn', default=base_dn,\n                               help=\"The Base DN to use, defaults to {0}. \".format(base_dn) + \\\n                               \"May be overridden with PUDL_BASE_DN\")\n    parser_common.add_argument('--attribute', '-a', action='append',\n                               dest='attributes', metavar='ATTRIBUTE',\n                               help=\"Attributes to include in results objects.  Note that \" + \\\n                               \"any nested objects return all attributes.  Maybe be used \" + \\\n                               \"multiple times, and if not specified, all \" + \\\n                               \"attributes are included in top-level objects\")\n    parser_common.add_argument('--grep', '-g', action='append', dest='grep',\n                               help='Filter results to only those matching the specified ' + \\\n                               'regular expression (compares against all attributes). ' + \\\n                               'May be used multiple times')\n    parser_common.add_argument('--attributes-only', '-A', action='store_true',\n                               dest='attributes_only', help=\"Only display a list of attributes \" + \\\n                               \"that are present for the object type returned by the LDAP query\")\n    parser_common.add_argument('--output-format', '-f', action='store', dest='output_format',\n                               choices=['json', 'yaml'], default='json',\n                               help=\"Output format, defaults to json.\")\n    parser_common.add_argument('--verbose', '-v', action='store_true', dest='verbose',\n                               help='Turn on verbose output', default=False)\n    parser_common.add_argument('--debug', '-d', action='store_true', dest='debug', default=False,\n                               help=\"Print out debugging information, very chatty\")\n    parser_common.add_argument('--tls-no-verify', '-V', action='store_true',\n                               dest='tls_no_verify',\n                               default=tls_no_verify, help=\"Don't verify the authenticity \" + \\\n                               \"of the server's certificate, defaults to \" + \\\n                               \"{0} and may be overridden with \".format(tls_no_verify) + \\\n                               \"PUDL_TLS_NO_VERIFY\")\n    parser_user = subparsers.add_parser('user', parents=[parser_common], conflict_handler='resolve',\n                                        help='Pull user objects from AD')\n    parser_user.add_argument(nargs=\"*\", dest='samaccountnames',\n                             help='sAMAccountNames for any user objects that are to be ' + \\\n                             'looked up. If unspecified, returns all users under the base ' + \\\n                             'DN provided')\n    parser_user.add_argument('--explicit-membership-only', '-e', action='store_true',\n                             dest='explicit_membership_only', default=False,\n                             help=\"Only show membership for users that is explicit, \" + \\\n                             \"not taking into account group nesting.  Defaults to False\")\n    parser_group = subparsers.add_parser('group', parents=[parser_common],\n                                         conflict_handler='resolve',\n                                         help='Pull group objects from AD')\n    parser_group.add_argument(nargs=\"*\", dest='samaccountnames',\n                              help=\"sAMAccountNames for any group objects that are to be \" + \\\n                              'looked up. If unspecified, returns all groups under the base ' + \\\n                              'DN provided. sAMAccountName may not be present in group ' + \\\n                              'objects in modern AD schemas')\n    parser_group.add_argument('--explicit-membership-only', '-e', action='store_true',\n                              dest='explicit_membership_only', default=False,\n                              help=\"Only show membership for users that is explicit, \" + \\\n                              \"not taking into account group nesting.  Defaults to False\")\n    parser_computer = subparsers.add_parser('computer', parents=[parser_common],\n                                            conflict_handler='resolve',\n                                            help='Pull computer objects from AD')\n    parser_computer.add_argument(nargs=\"*\", dest='samaccountnames',\n                                 help=\"sAMAccountNames for any computer objects that are to be \" + \\\n                                 'looked up. If unspecified, returns all computers under ' + \\\n                                 'the base DN provided.')\n\n    # sphinx is not add_help=False aware...\n    del subparsers.choices['common']\n\n    return parser", "response": "Collect command - line arguments and return an instance of argparse. ArgumentParser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_html_titles(index_page):\n    dom = dhtmlparser.parseString(index_page)\n\n    title_tags = dom.find(\"title\")\n\n    return [\n        SourceString(tag.getContent().strip(), \"HTML\")\n        for tag in title_tags\n        if tag.getContent().strip()\n    ]", "response": "Returns a list of titles parsed from HTML."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_title_tags(index_page):\n    dom = dhtmlparser.parseString(index_page)\n\n    titles = [\n        get_html_titles(dom),\n        get_html_meta_titles(dom),\n        get_dublin_core_titles(dom),\n    ]\n\n    return sum(titles, [])", "response": "Collect data from all the functions defined in this module and return list\n    of titles parsed from HTML meta tags and dublin core inlined in\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a scene and returns the scene object.", "response": "async def create_scene(self, scene_name, room_id) -> Scene:\n        \"\"\"Create a scene and returns the scene object.\n\n        :raises PvApiError when something is wrong with the hub.\n        \"\"\"\n        _raw = await self._scenes_entry_point.create_scene(room_id, scene_name)\n        result = Scene(_raw, self.request)\n        self.scenes.append(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def get_scene(self, scene_id, from_cache=True) -> Scene:\n        if not from_cache:\n            await self.get_scenes()\n        for _scene in self.scenes:\n            if _scene.id == scene_id:\n                return _scene\n        raise ResourceNotFoundException(\"Scene not found scene_id: {}\".format(scene_id))", "response": "Get a scene resource instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_room(self, room_id, from_cache=True) -> Room:\n        if not from_cache:\n            await self.get_rooms()\n        for _room in self.rooms:\n            if _room.id == room_id:\n                return _room\n        raise ResourceNotFoundException(\"Room not found. Id: {}\".format(room_id))", "response": "Get a scene resource instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a shade instance based on the id.", "response": "async def get_shade(self, shade_id, from_cache=True) -> BaseShade:\n        \"\"\"Get a shade instance based on shade id.\"\"\"\n        if not from_cache:\n            await self.get_shades()\n        for _shade in self.shades:\n            if _shade.id == shade_id:\n                return _shade\n        raise ResourceNotFoundException(\"Shade not found. Id: {}\".format(shade_id))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nactivate a scene :param scene_id: Scene id. :return:", "response": "async def activate_scene(self, scene_id: int):\n        \"\"\"Activate a scene\n\n        :param scene_id: Scene id.\n        :return:\n        \"\"\"\n\n        _scene = await self.get_scene(scene_id)\n        await _scene.activate()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting a scene by ID", "response": "async def delete_scene(self, scene_id: int):\n        \"\"\"Delete a scene\n\n        :param scene_id:\n        :return:\n        \"\"\"\n        _scene = await self.get_scene(scene_id, from_cache=False)\n        return await _scene.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def add_shade_to_scene(self, shade_id, scene_id, position=None):\n        if position is None:\n            _shade = await self.get_shade(shade_id)\n            position = await _shade.get_current_position()\n\n        await (SceneMembers(self.request)).create_scene_member(\n            position, scene_id, shade_id\n        )", "response": "Add a shade to a scene."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset all progress bars to zero and hide them.", "response": "def reset_bars(self):\n        \"\"\"\n        Set all progress bars to zero and hide them.\n        \"\"\"\n        self.url_progressbar.reset()\n        self.url_progressbar.show([0, 0])\n\n        self.issn_progressbar.reset()\n\n        self.urlbox_error.reset()\n        self.issnbox_error.reset()\n\n        InputController._reset_typeaheads()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef keywords(self):\n        dataset = [\n            self.aleph_kw_handler.keywords,\n            self.user_kw_handler.keywords,\n            self.analysis_kw_handler.keywords,\n        ]\n\n        return sum(dataset, [])", "response": "Get all keywords set by user and analysis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_properties(self):\n        properties = {\n            prop_name: getattr(self, prop_name)\n            for prop_name in self._property_list\n        }\n\n        return properties", "response": "Get dictionary with all properties readable by this class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(self):\n        properties = (\n            getattr(self.__class__, prop)\n            for prop in self._property_list\n            if hasattr(self.__class__, prop)\n        )\n\n        all_valid = True\n        for prop in properties:\n            if hasattr(prop, \"validate\"):\n                # oh for fucks sake, brython has broken parser and return in\n                # prop.validate() will also return from this function if used\n                # with `and` operator\n                result = prop.validate()\n                all_valid = all_valid and result\n\n        return all_valid", "response": "Validate all inputs. Highlight invalid inputs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reset(self):\n        self.reset_bars()\n        self.url_progressbar.reset()\n\n        # reset all resetable components\n        for prop in dir(self):\n            if prop.startswith(\"__\"):\n                continue\n\n            prop_obj = getattr(self, prop)\n            if prop_obj is not None and hasattr(prop_obj, \"reset\"):\n                prop_obj.reset()\n\n        # reset descriptors\n        properties = (\n            getattr(self.__class__, prop)\n            for prop in self._property_list\n            if hasattr(self.__class__, prop)\n        )\n        for prop in properties:\n            if hasattr(prop, \"reset\"):\n                prop.reset()\n            elif hasattr(prop, \"__set__\"):\n                prop.__set__(None, \"\")\n\n        self.additional_info = None", "response": "Reset all inputs to default."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of hierarchical list of action where an action is always placed in list after list containing his Action dependencies", "response": "def get_steps_for_actions(self, actions: list):\n        \"\"\"\n        Return a list of hierarchical list of action where an action is always\n        placed in list after list containing his Action dependencies\n        :param actions: list of Action\n        :return: list of steps where step contain list of Event\n        \"\"\"\n        actions_copy = actions[:]\n        steps = [[]]\n        count = 0\n        for action in actions_copy:\n            count += 1\n            if count > 10000:  # TODO: hard code\n                raise Exception(\"Impossible to find dependencies of action\", actions)\n            last_action = action\n            action_dependencies = action.get_dependencies()\n            if action_dependencies:\n                try:\n                    step_index = self._get_step_index_for_dependencies(steps, action_dependencies)\n                    if step_index is not None:\n                        try:\n                            steps[step_index+1].append(action)\n                        except IndexError:\n                            steps.append([action])\n                    else:\n                        step = []\n                        step.extend(action_dependencies)\n                        steps.append(step)\n                # Si une des dependences n'est pas encore dans les steps, on s'occupera de cette action plus tard\n                except NotFoundError:\n                    # TODO: Prevoir le cas ou la dependance n'existera jamais dans la liste et lever une erreur\n                    actions_copy.append(action)\n            else:\n                steps[0].append(action)\n        return steps"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting for the device to become ready for reliable interaction via adb.", "response": "def wait_for_device_ready(self, timeout=None, wait_polling_interval=None, after_first=None):\n        \"\"\"Wait for the device to become ready for reliable interaction via adb.\n        NOTE: if the device is *already* ready this method will timeout.\n\n        :param timeout: Maximum time to wait for the device to become ready\n        :param wait_polling_interval: Interval at which to poll for device readiness.\n        :param after_first: A function to run after first polling for device\n                            readiness. This allows use cases such as stopping b2g\n                            setting the unready state, and then restarting b2g.\n        \"\"\"\n\n        if timeout is None:\n            timeout = self._timeout\n        if wait_polling_interval is None:\n            wait_polling_interval = self._wait_polling_interval\n\n        self._logger.info(\"Waiting for device to become ready\")\n        profiles = self.get_profiles()\n        assert len(profiles) == 1\n\n        profile_dir = profiles.itervalues().next()\n        prefs_file = posixpath.normpath(profile_dir + \"/prefs.js\")\n\n        current_date = int(self.shell_output('date +\\\"%s\\\"'))\n        set_date = current_date - (365 * 24 * 3600 + 24 * 3600 + 3600 + 60 + 1)\n\n        try:\n            self.shell_output(\"touch -t %i %s\" % (set_date, prefs_file))\n        except adb.ADBError:\n            # See Bug 1092383, the format for the touch command\n            # has changed for flame-kk builds.\n            set_date = datetime.datetime.fromtimestamp(set_date)\n            self.shell_output(\"touch -t %s %s\" %\n                              (set_date.strftime('%Y%m%d.%H%M%S'),\n                              prefs_file))\n\n        def prefs_modified():\n            times = [None, None]\n\n            def inner():\n                try:\n                    listing = self.shell_output(\"ls -l %s\" % (prefs_file))\n                    mode, user, group, size, date, time, name = listing.split(None, 6)\n                    mtime = \"%s %s\" % (date, time)\n                except:\n                    return False\n                if times[0] is None:\n                    times[0] = mtime\n                else:\n                    times[1] = mtime\n                    if times[1] != times[0]:\n                        return True\n\n                return False\n\n            return inner\n\n        poll_wait(prefs_modified(), timeout=timeout,\n                  polling_interval=wait_polling_interval, after_first=after_first)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for the network connection to be established.", "response": "def wait_for_net(self, timeout=None, wait_polling_interval=None):\n        \"\"\"Wait for the device to be assigned an IP address.\n\n        :param timeout: Maximum time to wait for an IP address to be defined\n        :param wait_polling_interval: Interval at which to poll for ip address.\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        if wait_polling_interval is None:\n            wait_polling_interval = self._wait_polling_interval\n\n        self._logger.info(\"Waiting for network connection\")\n        poll_wait(self.get_ip_address, timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, wait=True, timeout=None, wait_polling_interval=None):\n        self._logger.info(\"Starting b2g process\")\n\n        if timeout is None:\n            timeout = self._timeout\n\n        if wait_polling_interval is None:\n            wait_polling_interval = self._wait_polling_interval\n\n        if wait:\n            self.wait_for_device_ready(timeout,\n                                       after_first=lambda:self.shell_bool(\"start b2g\",\n                                                                          timeout=timeout))\n        else:\n            self.shell_bool(\"start b2g\", timeout=timeout)", "response": "Start b2g, waiting for the adb connection to become stable.\n\n        :param wait:\n        :param timeout: Maximum time to wait for restart.\n        :param wait_polling_interval: Interval at which to poll for device readiness."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestart b2g, waiting for the adb connection to become stable. :param timeout: Maximum time to wait for restart. :param wait_polling_interval: Interval at which to poll for device readiness.", "response": "def restart(self, wait=True, timeout=None, wait_polling_interval=None):\n        \"\"\"Restart b2g, waiting for the adb connection to become stable.\n\n        :param timeout: Maximum time to wait for restart.\n        :param wait_polling_interval: Interval at which to poll for device readiness.\n        \"\"\"\n        self.stop(timeout=timeout)\n        self.start(wait, timeout=timeout, wait_polling_interval=wait_polling_interval)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_profiles(self, profile_base=\"/data/b2g/mozilla\", timeout=None):\n\n        rv = {}\n\n        if timeout is None:\n            timeout = self._timeout\n\n        profile_path = posixpath.join(profile_base, \"profiles.ini\")\n        try:\n            proc = self.shell(\"cat %s\" % profile_path, timeout=timeout)\n            config = ConfigParser.ConfigParser()\n            config.readfp(proc.stdout_file)\n            for section in config.sections():\n                items = dict(config.items(section))\n                if \"name\" in items and \"path\" in items:\n                    path = items[\"path\"]\n                    if \"isrelative\" in items and int(items[\"isrelative\"]):\n                        path = posixpath.normpath(\"%s/%s\" % (profile_base, path))\n                    rv[items[\"name\"]] = path\n        finally:\n            proc.stdout_file.close()\n            proc.stderr_file.close()\n\n        return rv", "response": "Return a list of paths to gecko profiles on the device"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute adb devices - l and returns a list of objects describing attached devices.", "response": "def devices(self, timeout=None):\n        \"\"\"Executes adb devices -l and returns a list of objects describing attached devices.\n\n        :param timeout: optional integer specifying the maximum time in\n            seconds for any spawned adb process to complete before\n            throwing an ADBTimeoutError.  This timeout is per adb call. The\n            total time spent may exceed this value. If it is not\n            specified, the value set in the ADBHost constructor is used.\n        :returns: an object contain\n        :raises: * ADBTimeoutError\n                 * ADBError\n\n        The output of adb devices -l ::\n\n            $ adb devices -l\n            List of devices attached\n            b313b945               device usb:1-7 product:d2vzw model:SCH_I535 device:d2vzw\n\n        is parsed and placed into an object as in\n\n        [{'device_serial': 'b313b945', 'state': 'device', 'product': 'd2vzw',\n          'usb': '1-7', 'device': 'd2vzw', 'model': 'SCH_I535' }]\n\n        \"\"\"\n        # b313b945               device usb:1-7 product:d2vzw model:SCH_I535 device:d2vzw\n        # from Android system/core/adb/transport.c statename()\n        re_device_info = re.compile(r'([^\\s]+)\\s+(offline|bootloader|device|host|recovery|sideload|no permissions|unauthorized|unknown)')\n        devices = []\n        lines = self.command_output([\"devices\", \"-l\"], timeout=timeout).split('\\n')\n        for line in lines:\n            if line == 'List of devices attached ':\n                continue\n            match = re_device_info.match(line)\n            if match:\n                device = {\n                    'device_serial': match.group(1),\n                    'state': match.group(2)\n                }\n                remainder = line[match.end(2):].strip()\n                if remainder:\n                    try:\n                        device.update(dict([j.split(':')\n                                            for j in remainder.split(' ')]))\n                    except ValueError:\n                        self._logger.warning('devices: Unable to parse '\n                                             'remainder for device %s' % line)\n                devices.append(device)\n        return devices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadjust the bounding box as specified by user.", "response": "def adjust_bounding_box(bbox):\n    \"\"\"Adjust the bounding box as specified by user.\n    Returns the adjusted bounding box.\n\n    - bbox: Bounding box computed from the canvas drawings.\n    It must be a four-tuple of numbers.\n    \"\"\"\n    for i in range(0, 4):\n        if i in bounding_box:\n            bbox[i] = bounding_box[i]\n        else:\n            bbox[i] += delta_bounding_box[i]\n    return bbox"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resolve_path(self, address):\n        '''\n        Resolve the given address in this tree branch\n        '''\n        match = self.find_one(address)\n        if not match:\n            return [self]\n\n        # Go further up the tree if possible\n        if isinstance(match, ContainerNode):\n            return match.resolve_path(address) + [self]\n\n        # This is as far as we go\n        return [match, self]", "response": "Resolve the given address in this tree branch\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the given address or prefix.", "response": "def find_one(self, address):\n        '''\n        Find the given address or prefix\n        '''\n        # Convert to a network and find all matches\n        prefix = ip_network(address)\n        matches = self.find_all(prefix)\n\n        if not matches:\n            # Nothing found\n            return None\n\n        if len(matches) > 1:\n            # Found too much\n            raise MoreSpecificsFoundError('Found more-specifics for %r' % prefix)\n\n        # One match is what we want\n        match = matches.pop()\n\n        # The match should completely contain the prefix we look for\n        if match.prefix[0] <= prefix[0] and match.prefix[-1] >= prefix[-1]:\n            return match"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_exact(self, prefix):\n        '''\n        Find the exact child with the given prefix\n        '''\n        matches = self.find_all(prefix)\n        if len(matches) == 1:\n            match = matches.pop()\n            if match.prefix == prefix:\n                return match\n\n        return None", "response": "Find the exact child with the given prefix."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds all the entries in the given prefix and return them as a set.", "response": "def find_all(self, prefix):\n        '''\n        Find everything in the given prefix\n        '''\n        prefix = ip_network(prefix)\n\n        # Check that we are authoritative for the given prefix\n        if not self.prefix.overlaps(prefix) \\\n        or self.prefix[0] > prefix[0] \\\n        or self.prefix[-1] < prefix[-1]:\n            raise NotAuthoritativeError('This node is not authoritative for %r'\n                                        % prefix)\n\n        # Find all matching existing prefixes and return them in a set\n        matches = set()\n        for child in self.children:\n            if prefix.overlaps(child.prefix):\n                matches.add(child)\n\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_suite():\n    global test_suite\n    frm = inspect.stack()[1]\n    test_suite = \".\".join(os.path.basename(frm[1]).split('.')[0:-1])", "response": "Register a test suite in the module containing a test suite."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if an object is a primitive", "response": "def is_primitive(var):\n    \"\"\"\n    Checks if an object is in ( float, long, str, int, dict, list, unicode, tuple, set, frozenset, datetime.datetime, datetime.timedelta )\n\n    \"\"\"\n    primitives = ( float, long, str, int, dict, list, unicode, tuple, set, frozenset, datetime.datetime, datetime.timedelta, type(None) )\n    for primitive in primitives:\n        if type( var ) == primitive:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef seq():\n    current_frame     = inspect.currentframe().f_back\n    trace_string      = \"\"\n    while current_frame.f_back:\n      trace_string = trace_string + current_frame.f_back.f_code.co_name\n      current_frame = current_frame.f_back\n    return counter.get_from_trace(trace_string)", "response": "Counts up sequentially from a number based on the current time\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random(*args):\n    current_frame     = inspect.currentframe().f_back\n    trace_string      = \"\"\n    while current_frame.f_back:\n      trace_string = trace_string + current_frame.f_back.f_code.co_name\n      current_frame = current_frame.f_back\n    return counter.get_from_trace(trace_string)", "response": "Returns a random number from the current time\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recache( methodname=None, filename=None ):\n    if not methodname and not filename:\n        hashes = get_unique_hashes()\n        deleted = 0\n        for hash in hashes:\n            delete_io(hash)\n            deleted = deleted + 1\n    else:\n        reqd_strings = []\n        if methodname:\n            reqd_strings.append( methodname )\n        if filename:\n            reqd_strings.append( filename )\n        hashes = get_unique_hashes()\n        deleted = 0\n        for hash in hashes:\n            cd = call_descriptor.fetch( hash )\n            if all( [ s in cd.stack for s in reqd_strings ] ):\n                delete_io( hash )\n                deleted = deleted + 1\n        return deleted", "response": "Delete all entries corresponding to methodname in filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the stack trace to hash to identify a call descriptor.", "response": "def get_stack(method_name):\n    \"\"\"\n    Returns the stack trace to hash to identify a call descriptor\n\n    :param str method_name: The calling method.\n\n    :rtype str:\n    \"\"\"\n    global test_suite\n    trace_string      = method_name + \" \"\n    for f in inspect.stack():\n        module_name = os.path.basename(f[1])\n        method_name = f[3]\n        trace_string = trace_string + \"%s %s \" % (module_name, method_name)\n        if test_suite and module_name == test_suite or (module_name == 'patch.py' and method_name == 'patched_test'):\n            return trace_string\n    return trace_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload the document given the id.", "response": "def get_document(self, doc_id):\n        '''Download the document given the id.'''\n        conn = self.agency._database.get_connection()\n        return conn.get_document(doc_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the medium class for the given agent_type. Optional index tells which one to give.", "response": "def get_medium(self, agent_type, index=0):\n        '''Returns the medium class for the\n        given agent_type. Optional index tells which one to give.'''\n        mediums = list(x for x in self.agency._agents\n                       if x.get_descriptor().type_name == agent_type)\n        try:\n            return mediums[index]\n        except KeyError:\n            raise RuntimeError(\n                'Requested medium class of %s with index %d, but found only '\n                '%d medium of this type'\n                % (agent_type, index, len(mediums))), None, sys.exc_info()[2]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef restart_agent(self, agent_id, **kwargs):\n        '''tells the host agent running in this agency to restart the agent.'''\n        host_medium = self.get_medium('host_agent')\n        agent = host_medium.get_agent()\n        d = host_medium.get_document(agent_id)\n        # This is done like this on purpose, we want to ensure that document\n        # exists before passing it to the agent (even though he would handle\n        # this himself).\n        d.addCallback(\n            lambda desc: agent.start_agent(desc.doc_id, **kwargs))\n        return d", "response": "tells the host agent running in this agency to restart the agent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the user s key is in the specified credentials and return 1 if the user is in the specified credentials and 0 if the user is not in the specified credentials.", "response": "def checkKey(self, credentials):\n        \"\"\"\n        Retrieve the keys of the user specified by the credentials, and check\n        if one matches the blob in the credentials.\n        \"\"\"\n        filename = self._keyfile\n        if not os.path.exists(filename):\n            return 0\n        lines = open(filename).xreadlines()\n        for l in lines:\n            l2 = l.split()\n            if len(l2) < 2:\n                continue\n            try:\n                if base64.decodestring(l2[1]) == credentials.blob:\n                    return 1\n            except binascii.Error:\n                continue\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of template search list.", "response": "def get_template_search_list(app_name, object, template_name):\n    \"\"\" Returns template search list.\n        Example::\n        \n    >>> from django.contrib.auth.models import User\n    >>> user=User()\n    >>> get_template_search_list('my_app', user, 'list.html')\n    [u'my_app/auth/user/list.html', u'my_app/auth/list.html', 'my_app/list.html']\n\n    \"\"\"\n    ctype = ContentType.objects.get_for_model(object)\n    return [\n        u\"%s/%s/%s/%s\" % (app_name, ctype.app_label, ctype.model, template_name),\n        u\"%s/%s/%s\" % (app_name, ctype.app_label, template_name,),\n        u\"%s/%s\" % (app_name, template_name,)\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef source_call(method_name, *args, **kwargs):\n\n    def source_call(_value, context, **_params):\n        method = getattr(context[\"model\"].source, method_name)\n        return _call(method, args, kwargs)\n\n    return source_call", "response": "Creates an effect that will drop the current effect value and call the source s method with the specified name with the specified arguments and keywords."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an effect that will call the source s method with the current value and specified arguments and keywords.", "response": "def source_filter(method_name, *args, **kwargs):\n    \"\"\"\n    Creates an effect that will call the source's method with the current\n    value and specified arguments and keywords.\n    @param method_name: the name of method belonging to the source reference.\n    @type method_name: str\n    \"\"\"\n\n    def source_filter(value, context, **_params):\n        method = getattr(context[\"model\"].source, method_name)\n        return _filter(method, value, args, kwargs)\n\n    return source_filter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an effect that will call the source s method with the current value and specified arguments and the union of effect parameters and keyword arguments.", "response": "def source_perform(method_name, *args, **kwargs):\n    \"\"\"\n    Creates an effect that will call the source's method with the current\n    value and specified arguments and the union of effect parameters and\n    specified keywords (action's parameters take precedence).\n    @param method_name: the name of method belonging to the source reference.\n    @type method_name: str\n    \"\"\"\n\n    def source_perform(value, context, **params):\n        method = getattr(context[\"model\"].source, method_name)\n        return _perform(method, value, params, args, kwargs)\n\n    return source_perform"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an effect that will call the action s method with the current value and specified arguments and keywords.", "response": "def action_filter(method_name, *args, **kwargs):\n    \"\"\"\n    Creates an effect that will call the action's method with the current\n    value and specified arguments and keywords.\n    @param method_name: the name of method belonging to the action.\n    @type method_name: str\n    \"\"\"\n\n    def action_filter(value, context, **_params):\n        method = getattr(context[\"action\"], method_name)\n        return _filter(method, value, args, kwargs)\n\n    return action_filter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an effect that will call the action s method with the current value and the union of effect parameters and keyword arguments.", "response": "def action_perform(method_name, *args, **kwargs):\n    \"\"\"\n    Creates an effect that will call the action's method with the current\n    value and specified arguments and the union of effect parameters and\n    specified keywords (action's parameters take precedence).\n    @param method_name: the name of method belonging to the action.\n    @type method_name: str\n    \"\"\"\n\n    def action_perform(value, context, **params):\n        method = getattr(context[\"action\"], method_name)\n        return _perform(method, value, params, args, kwargs)\n\n    return action_perform"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef view_call(method_name, *args, **kwargs):\n\n    def view_call(_value, context, **_params):\n        method = getattr(context[\"view\"], method_name)\n        return _call(method, args, kwargs)\n\n    return view_call", "response": "Creates an effect that will drop the current effect value and call the view s method with the specified name with the specified arguments and keywords."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value_call(method_name, *args, **kwargs):\n\n    def value_call(value, context, **_params):\n        method = getattr(value, method_name)\n        return _call(method, args, kwargs)\n\n    return value_call", "response": "Creates an effect that will call the specified method with the specified arguments and keywords."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if an incoming value is None or the empty string.", "response": "def _is_null(self, value):\n        \"\"\"Check if an incoming value is ``None`` or the empty string.\"\"\"\n        if isinstance(value, six.string_types):\n            if not len(value.strip()):\n                return True\n        return value is None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the given value to the target type.", "response": "def cast(self, value, **opts):\n        \"\"\"Convert the given value to the target type.\n\n        Return ``None`` if the value is empty. If an error occurs,\n        raise a ``ConverterError``.\n        \"\"\"\n        if isinstance(value, self.result_type):\n            return value\n        if self._is_null(value):\n            return None\n        try:\n            opts_ = self.opts.copy()\n            opts_.update(opts)\n            return self._cast(value, **opts_)\n        except Exception as e:\n            if not isinstance(e, ConverterError):\n                e = ConverterError(None, exc=e)\n            e.converter = self.__class__\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a string representation of the data.", "response": "def stringify(self, value, **opts):\n        \"\"\"Generate a string representation of the data.\n\n        Inverse of conversion: generate a string representation of the data\n        that is guaranteed to be parseable by this library.\n        \"\"\"\n        if self._is_null(value):\n            return None\n        try:\n            opts_ = self.opts.copy()\n            opts_.update(opts)\n            return self._stringify(value, **opts_)\n        except Exception as e:\n            if not isinstance(e, ConverterError):\n                e = ConverterError(None, exc=e)\n            e.converter = self.__class__\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_pattern_list(patterns):\n    pattstrs = []\n    for desc, patts in patterns:\n        # \";,\" not allowed in descriptions or patterns\n        patts = [p.replace(\";\", \"\").replace(\",\", \"\") for p in patts]\n        desc = desc.replace(\";\", \"\").replace(\",\", \"\")\n        pattstrs.append(\"%s=%s\" % (desc, ','.join(patts)))\n    return \";\".join(pattstrs)", "response": "Makes a string of filename patterns from a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if path refers to a valid purrlog.", "response": "def is_purrlog(path):\n        \"\"\"Checks if path refers to a valid purrlog.\n        Path must exist, and must contain either at least one directory called entry-YYYYMMDD-HHMMSS, or the file \"dirconfig\"\n        \"\"\"\n        if not os.path.isdir(path):\n            return False\n        if list(filter(os.path.isdir, glob.glob(\n                os.path.join(path, \"entry-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]\")))):\n            return True\n        return os.path.exists(os.path.join(path, \"dirconfig\"))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new watch - directory to the watchlist.", "response": "def addWatchedDirectory(self, dirname, watching=Purr.WATCHED, save_config=True):\n        \"\"\"Starts watching the specified directories for changes\"\"\"\n        # see if we're alredy watching this exact set of directories -- do nothing if so\n        dirname = Purr.canonizePath(dirname)\n        # do nothing if already watching\n        if dirname in self.watched_dirs:\n            dprint(1, \"addWatchDirectory(): already watching %s\\n\", dirname)\n            # watching=None means do not change the watch-state\n            if watching is None:\n                return\n        else:\n            if watching is None:\n                watching = Purr.WATCHED\n            # make watcher object\n            wdir = Purrer.WatchedDir(dirname, mtime=self.timestamp,\n                                     watch_patterns=self._watch_patterns, ignore_patterns=self._ignore_patterns)\n            # fileset=None indicates error reading directory, so ignore it\n            if wdir.fileset is None:\n                print(\"There was an error reading the directory %s, will stop watching it.\" % dirname)\n                self.setWatchingState(dirname, Purr.REMOVED, save_config=True)\n                return\n            self.watchers[dirname] = wdir\n            self.watched_dirs.append(dirname)\n            dprintf(2, \"watching directory %s, mtime %s, %d files\\n\",\n                    dirname, time.strftime(\"%x %X\", time.localtime(wdir.mtime)), len(wdir.fileset))\n            # find files in this directory matching the watch_patterns, and watch them for changes\n            watchset = set()\n            for patt in self._watch_patterns:\n                watchset.update(fnmatch.filter(wdir.fileset, patt))\n            for fname in watchset:\n                quiet = matches_patterns(fname, self._quiet_patterns)\n                fullname = Purr.canonizePath(os.path.join(dirname, fname))\n                if fullname not in self.watchers:\n                    wfile = Purrer.WatchedFile(fullname, quiet=quiet, mtime=self.timestamp)\n                    self.watchers[fullname] = wfile\n                    dprintf(3, \"watching file %s, timestamp %s, quiet %d\\n\",\n                            fullname, time.strftime(\"%x %X\", time.localtime(wfile.mtime)), quiet)\n            # find subdirectories  matching the subdir_patterns, and watch them for changes\n            for fname in wdir.fileset:\n                fullname = Purr.canonizePath(os.path.join(dirname, fname))\n                if os.path.isdir(fullname):\n                    for desc, dir_patts, canary_patts in self._subdir_patterns:\n                        if matches_patterns(fname, dir_patts):\n                            quiet = matches_patterns(fname, self._quiet_patterns)\n                            wdir = Purrer.WatchedSubdir(fullname, canary_patterns=canary_patts, quiet=quiet,\n                                                        mtime=self.timestamp)\n                            self.watchers[fullname] = wdir\n                            dprintf(3, \"watching subdirectory %s/{%s}, timestamp %s, quiet %d\\n\",\n                                    fullname, \",\".join(canary_patts),\n                                    time.strftime(\"%x %X\", time.localtime(wdir.mtime)), quiet)\n                            break\n        # set state and save config\n        self.setWatchingState(dirname, watching, save_config=save_config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the list of log entries. If save = True saves the log and also updates default policies based on these entries. If update_policies = True also updates default policies based on these entries.", "response": "def setLogEntries(self, entries, save=True, update_policies=True):\n        \"\"\"Sets list of log entries. If save=True, saves the log. If update_policies=True, also updates default policies based\n        on these entries\"\"\"\n        prev = None;  # \"previous\" valid entry for \"Prev\" link\n        uplink = os.path.join(\"..\", Purr.RenderIndex.INDEX);  # \"Up\" link\n        self.entries = []\n        for entry in entries:\n            if not entry.ignore:\n                entry.setPrevUpNextLinks(prev=prev, up=uplink)\n                prev = entry\n                self.entries.append(entry)\n        if save:\n            self.save()\n        if update_policies:\n            # populate default policies and renames based on entry list\n            self._default_dp_props = {}\n            for entry in entries:\n                self.updatePoliciesFromEntry(entry)\n            dprint(4, \"default policies:\", self._default_dp_props)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete given list of entries from the log. If save = True re - saves the log itself.", "response": "def deleteLogEntries(self, del_entries, save=True):\n        \"\"\"Deletes given list of entries from the log. Some entries' index.html files may be updated to reflect changes in prev/next links. If save=True, re-saves the log itself.\"\"\"\n        prev_valid = prev_deleted = None\n        # fix Next/Prev links in remaining entries\n        newents = []\n        updated = set()\n        for ent in self.entries:\n            if not ent.ignore:\n                if ent in del_entries:\n                    prev_deleted = ent\n                else:\n                    if prev_deleted:\n                        ent.setPrevUpNextLinks(prev=prev_valid)\n                        prev_valid and prev_valid.generateIndex()\n                        ent.generateIndex()\n                        prev_deleted = None\n                    prev_valid = ent\n                    newents.append(ent)\n            else:\n                newents.append(ent)\n        # fix last \"Next\" link if we had a deleted entry followed by nothing\n        if prev_deleted and prev_valid:\n            prev_valid.setPrevUpNextLinks(next='')\n            prev_valid.generateIndex()\n        # regenerate indices\n        for ent in newents:\n            if id(ent) in updated:\n                ent.generateIndex()\n        self.entries = newents\n        if save:\n            self.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn relative link to index. html of this entry. Link will be of the form.. / entry - xxx. html", "response": "def _relIndexLink(self):\n        \"\"\"Returns relative link to index.html of this entry. Link will be of the form ../entry-xxx/index.html\"\"\"\n        return os.path.join(\"..\", os.path.basename(self.pathname), \"index.html\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes sure purrlog directory is properly set up", "response": "def _initIndexDir(self):\n        \"\"\"makes sure purrlog directory is properly set up\"\"\"\n        if not os.path.exists(self.logdir):\n            os.mkdir(self.logdir)\n            dprint(1, \"created\", self.logdir)\n        Purr.RenderIndex.initIndexDir(self.logdir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the log. If refresh is set to a timestamp, will regenerate everything from scratch.", "response": "def save(self, refresh=False):\n        \"\"\"Saves the log.\n        If refresh is set to a timestamp, will regenerate everything from scratch.\n        \"\"\"\n        # create directory if it doesn't exist\n        # error will be thrown if this is not possible\n        _busy = Purr.BusyIndicator()\n        Purr.progressMessage(\"Generating index in %s\" % self.logdir)\n        self._initIndexDir()\n        # if refresh is True, re-save all entries.\n        if refresh:\n            refresh = time.time()\n            for i, entry in enumerate(self.entries):\n                entry.save(refresh=refresh)\n        Purr.RenderIndex.writeLogIndex(self.logdir, self.logtitle, self.timestamp, self.entries, refresh=refresh)\n        Purr.progressMessage(\"Wrote %s\" % self.logdir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a list of DPs from a list of filenames.", "response": "def makeDataProducts(self, files, unbanish=False, unignore=False):\n        \"\"\"makes a list of DPs from a list of (filename,quiet) pairs.\n        If unbanish is False, DPs with a default \"banish\" policy will be skipped.\n        Symlinks will be resolved, and non-unique filenames removed from list.\n        \"\"\"\n        paths = set()\n        dps = []\n        for filename, quiet in files:\n            filename = filename.rstrip('/')\n            sourcepath = Purr.canonizePath(filename)\n            if sourcepath not in paths:\n                paths.add(sourcepath)\n                filename = os.path.basename(filename)\n                policy, filename, comment = self._default_dp_props.get(filename, (\"copy\", filename, \"\"))\n                dprintf(4, \"%s: default policy is %s,%s,%s\\n\", sourcepath, policy, filename, comment)\n                if policy == \"banish\":\n                    if unbanish:\n                        policy = \"copy\"\n                    else:\n                        continue\n                if unignore and policy == \"ignore\":\n                    policy = \"copy\"\n                dps.append(Purr.DataProduct(filename=filename, sourcepath=sourcepath,\n                                            policy=policy, comment=comment, quiet=quiet))\n        return sorted(dps, lambda a, b: cmp(a.filename, b.filename))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompare only the content of the documents (ignoring the meta fields).", "response": "def compare_content(self, other):\n        '''\n        Compare only the content of the documents (ignoring the meta fields).\n        '''\n        if type(self) is not type(other):\n            return False\n        s1 = self.snapshot()\n        s2 = other.snapshot()\n        for snapshot in (s1, s2):\n            for key in snapshot.keys():\n                if key[0] in ('_', '.'):\n                    del snapshot[key]\n        return s1 == s2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator of doc_ids of the documents of the specified type.", "response": "def by_type(self, type_name):\n        '''\n        Return an iterator of doc_ids of the documents of the\n        specified type.\n        '''\n        if IRestorator.providedBy(type_name):\n            type_name = type_name.type_name\n        return (x[1] for x in self._links if x[0] == type_name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ssh_cmd(self, *args):\n        command = \"gerrit {0}\".format(\" \".join(args))\n        _, stdout, stderr = self._client.exec_command(command)\n        return (stdout.readlines(), stderr.readlines())", "response": "Execute a gerrit command over SSH."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef factory(raw_data, request):\n    if ATTR_SHADE in raw_data:\n        raw_data = raw_data.get(ATTR_SHADE)\n\n    shade_type = raw_data.get(ATTR_TYPE)\n\n    def find_type(shade):\n        for tp in shade.shade_types:\n            if tp.shade_type == shade_type:\n                return shade(raw_data, tp, request)\n        return None\n\n    _shade = find_type(ShadeTdbu)\n    if _shade:\n        return _shade\n\n    _shade = find_type(ShadeBottomUp)\n    if _shade:\n        return _shade\n\n    _shade = find_type(ShadeBottomUpTilt)\n    if _shade:\n        return _shade\n\n    _shade = find_type(ShadeBottomUpTiltAnywhere)\n    if _shade:\n        return _shade\n\n    _shade = find_type(Silhouette)\n    if _shade:\n        return _shade\n\n    return BaseShade(raw_data, BaseShade.shade_types[0], request)", "response": "Class factory to create different types of shades based on shade type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a shade data object to be sent to the hub", "response": "def _create_shade_data(self, position_data=None, room_id=None):\n        \"\"\"Create a shade data object to be sent to the hub\"\"\"\n        base = {ATTR_SHADE: {ATTR_ID: self.id}}\n        if position_data:\n            base[ATTR_SHADE][ATTR_POSITION_DATA] = position_data\n        if room_id:\n            base[ATTR_SHADE][ATTR_ROOM_ID] = room_id\n        return base"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying the hub and the actual shade to get the most recent shade data. Including current shade position.", "response": "async def refresh(self):\n        \"\"\"Query the hub and the actual shade to get the most recent shade\n        data. Including current shade position.\"\"\"\n        raw_data = await self.request.get(self._resource_path, {\"refresh\": \"true\"})\n\n        self._raw_data = raw_data[ATTR_SHADE]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_current_position(self, refresh=True) -> dict:\n        if refresh:\n            await self.refresh()\n        position = self._raw_data.get(ATTR_POSITION_DATA)\n        return position", "response": "Return the current shade position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restart_complete(self, state, new_address):\n        '''\n        Called when we get notified that the restart has been completed by\n        some agent who has volontureed to do so.\n        '''\n        if state.timeout_call_id:\n            state.agent.cancel_delayed_call(state.timeout_call_id)\n            state.timeout_call_id = None\n        return self._send_restarted_notifications(new_address)", "response": "Called when a restart has been completed by the agent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _start_collective_solver(self, state):\n        '''\n        Determines who from all the monitors monitoring this agent should\n        resolve the issue.\n        '''\n        own_address = state.agent.get_own_address()\n        monitors = [IRecipient(x) for x in state.descriptor.partners\n                    if x.role == u'monitor']\n        im_included = any([x == own_address for x in monitors])\n        if not im_included:\n            monitors.append(own_address)\n        # this object is going to be stored in the state of CollectiveSolver,\n        # we need to deepcopy it not to share a refrence\n        state.monitors = copy.deepcopy(monitors)\n        state.agent.initiate_protocol(problem.CollectiveSolver,\n                                      self, monitors)\n        return task.NOT_DONE_YET", "response": "Determines who from all the monitors monitoring this agent should\n        resolve the issue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting a single try of the whole restart path.", "response": "def _retry(self, state):\n        '''\n        Starts a single try of the whole restart path.\n        '''\n        state.attempt += 1\n        self.debug('Starting restart attempt: %d.', state.attempt)\n        if self._cmp_strategy(RestartStrategy.buryme):\n            self.debug('Agent %r is going to by buried according to his '\n                       'last will.', state.factory.descriptor_type)\n            return self._send_buried_notifications()\n        else:\n            f = self._set_restart_flag()\n            f.add_callback(fiber.drop_param, self._send_died_notifications)\n            f.add_both(self._ensure_someone_took_responsability)\n            return f"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if someone has responsability to restart the agent.", "response": "def _ensure_someone_took_responsability(self, state, _responses):\n        '''\n        Called as a callback for sending *died* notifications to all the\n        partners.\n        Check if someone has offered to restart the agent.\n        If yes, setup expiration call and wait for report.\n        If no, initiate doing it on our own.\n        '''\n        if not state.so_took_responsability:\n            self.debug('Noone took responsability, I will try to restart '\n                       '%r agent myself', state.factory.descriptor_type)\n            return self._restart_yourself()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _local_restart_failed(self, state, fail):\n        '''\n        Getting here means that all the host agents in the shard are gone.\n        Depending on the restart strategy we finish here, migrate out of the\n        shard or take over (monitoring agent).\n        '''\n        self.info('Restarting of %r in the same shard failed.',\n                  state.descriptor.type_name)\n        if self._cmp_strategy(RestartStrategy.local):\n            self.info('Giving up, just sending buried notifications.')\n            f = self._send_buried_notifications()\n            f.add_callback(fiber.drop_param, state.medium.terminate, None)\n            return f\n        elif self._cmp_strategy(RestartStrategy.wherever):\n            self.info('Trying to find an allocation anywhere in the cluster.')\n            # first we need to clear the host partner, it is necessary, because\n            # agent will bind to different exchange after the restart, so\n            # he will never receive the notification\n            # about burring his previous host\n            f = self._clear_host_partner()\n            f.add_callback(fiber.inject_param, 2,\n                           state.agent.initiate_protocol,\n                           start_agent.GloballyStartAgent)\n            f.add_callback(fiber.call_param, 'notify_finish')\n            # GloballyStartAgent task is updating descriptor, to get things\n            # we need to redownload it here\n            f.add_callback(fiber.bridge_param, self._fetch_descriptor)\n            f.add_callbacks(self._send_restarted_notifications,\n                            self._global_restart_failed)\n            return f\n        elif self._cmp_strategy(RestartStrategy.monitor):\n            self.info('Taking over the role of the died monitor.')\n            f = self._send_buried_notifications()\n            f.add_callback(fiber.drop_param, self._checkup_partners)\n            f.add_callback(fiber.drop_param, self._adopt_notifications)\n            f.add_callback(fiber.drop_param, state.medium.terminate, None)\n            return f\n        else:\n            state.medium.fail(RestartFailed('Unknown restart strategy: %r' %\n                                            (self.factory.restart_strategy, )))", "response": "Called when a local restart of the local agent in the same shard has failed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparts of the monitor restart strategy. The pending notifications from descriptor of dead agent are imported to our pending list.", "response": "def _adopt_notifications(self, state):\n        '''Part of the \"monitor\" restart strategy. The pending notifications\n        from descriptor of dead agent are imported to our pending list.'''\n\n        def iterator():\n            it = state.descriptor.pending_notifications.iteritems()\n            for _, nots in it:\n                for x in nots:\n                    yield x\n\n        to_adopt = list(iterator())\n        self.info(\"Will adopt %d pending notifications.\", len(to_adopt))\n        return state.sender.notify(to_adopt)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _iter_categorized_partners(self, state):\n        '''\n        Iterator over the partners giving as extra param partners of the same\n        category.\n        '''\n        # categorize partners into the structure\n        # partner_class -> list of its instances\n        categorized = dict()\n        for partner in state.descriptor.partners:\n            category, index = categorized.get(partner.__class__,\n                                              (list(), len(categorized)))\n            category.append(partner)\n            categorized[partner.__class__] = tuple([category, index])\n\n        for category, (brothers, index) in sorted(categorized.items(),\n                                                  key=lambda x: x[1][1]):\n            for partner in brothers:\n                yield partner, brothers", "response": "Iterate over the partners that are categorized into the structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen a PID file for writing.", "response": "def acquire_pidfile(rundir, process_type=PROCESS_TYPE, name=None):\n    \"\"\"\n    Open a PID file for writing, using the given process type and\n    process name for the filename. The returned file can be then passed\n    to writePidFile after forking.\n\n    @rtype:   str\n    @returns: file object, open for writing\n    \"\"\"\n    from feat.common.run import get_pidpath\n    _ensure_dir(rundir, \"rundir\")\n    path = get_pidpath(rundir, process_type, name)\n    return open(path, 'w')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_pidfile(rundir, process_type=PROCESS_TYPE,\n                  name=None, file=None): #@ReservedAssignment\n    \"\"\"\n    Write a pid file in the run directory, using the given process type\n    and process name for the filename.\n\n    @rtype:   str\n    @returns: full path to the pid file that was written\n    \"\"\"\n    from feat.common.run import get_pidpath\n    # don't shadow builtin file\n    pid_file = file\n    if pid_file is None:\n        _ensure_dir(rundir, \"rundir\")\n        filename = get_pidpath(rundir, process_type, name)\n        pid_file = open(filename, 'w')\n    else:\n        filename = pid_file.name\n    pid_file.write(\"%d\\n\" % (os.getpid(), ))\n    pid_file.close()\n    os.chmod(filename, 0644)\n    return filename", "response": "Writes a pid file in the run directory using the given process type\n    and process name for the filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_pidfile(rundir, process_type=PROCESS_TYPE, name=None, force=False):\n    from feat.common.run import get_pidpath\n    log.debug(process_type, 'deleting pid file')\n    path = get_pidpath(rundir, process_type, name)\n    try:\n        os.unlink(path)\n    except OSError, e:\n        if e.errno == errno.ENOENT and force:\n            pass\n        else:\n            raise\n    return path", "response": "Delete the pid file in the run directory using the given process type and process name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wait_pidfile(rundir, process_type=PROCESS_TYPE, name=None):\n    from feat.common.run import get_pid\n    # getting it from the start avoids an unneeded time.sleep\n    pid = get_pid(rundir, process_type, name)\n\n    while not pid:\n        time.sleep(0.1)\n        pid = get_pid(rundir, process_type, name)\n\n    return pid", "response": "Wait for the given process type and name to have started and created\n    a pid file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sign(idText, request, caPrivkey):\n    # Verify input types\n    assertType(request, ec1Element)\n    assertScalarType(caPrivkey)\n\n    # Switch to new notation\n    R = request\n    d = caPrivkey\n    G = generatorEc()\n    N = orderEc()\n\n    # TODO: use simultaneous mul to speed this up.\n    # Random integer\n    k = randomZ(N)\n    P = R + k*G\n\n    # Hash the identity string and implicit cert into an integer\n    e = _exp(P, idText)\n\n    # Compute the private key contribution\n    r = (e*k + d) % N\n    return (r, P)", "response": "Generates an implicit certificate using the identity string and request and caPrivkey."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recoverPubkey(idText, cert, caPubkey):\n    # Verify types\n    assertType(cert, ec1Element)\n    assertType(caPubkey, ec1Element)\n\n    # Compute the pubkey\n    return _exp(cert, idText)*cert + caPubkey", "response": "A client can recover the server s pubkey using the identity string idText and the trusted caPubkey."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a configuration set into\n        this object.\n\n        '''\n        self.id = node.getAttributeNS(RTS_NS, 'id')\n        self._config_data = []\n        for d in node.getElementsByTagNameNS(RTS_NS, 'ConfigurationData'):\n            self._config_data.append(ConfigurationData().parse_xml_node(d))\n        return self", "response": "Parse an xml. dom Node object representing a configuration set into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a configuration set into this\n        object.\n\n        '''\n        self.id = y['id']\n        self._config_data = []\n        if 'configurationData' in y:\n            for d in y.get('configurationData'):\n                self._config_data.append(ConfigurationData().parse_yaml(d))\n        return self", "response": "Parse a YAML specification of a configuration set into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_xml(self, doc, element):\n        '''Save this configuration set into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'id', self.id)\n        for c in self._config_data:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'ConfigurationData')\n            c.save_xml(doc, new_element)\n            element.appendChild(new_element)", "response": "Save this configuration set into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_dict(self):\n        '''Save this configuration set into a dictionary.'''\n        d = {'id': self.id}\n        data = []\n        for c in self._config_data:\n            data.append(c.to_dict())\n        if data:\n            d['configurationData'] = data\n        return d", "response": "Save this configuration set into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing a configuration data into\n        this object.\n\n        '''\n        self.name = node.getAttributeNS(RTS_NS, 'name')\n        if node.hasAttributeNS(RTS_NS, 'data'):\n            self.data = node.getAttributeNS(RTS_NS, 'data')\n        else:\n            self.data = ''\n        return self", "response": "Parse an xml. dom Node object representing a configuration data into this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_yaml(self, y):\n        '''Parse a YAML specification of a configuration data into this\n        object.\n\n        '''\n        self.name = y['name']\n        if 'data' in y:\n            self.data = y['data']\n        else:\n            self.data = ''\n        return self", "response": "Parse a YAML specification of a configuration data into this\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave this configuration data into an xml. dom. Element object.", "response": "def save_xml(self, doc, element):\n        '''Save this configuration data into an xml.dom.Element object.'''\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'name', self.name)\n        if self.data:\n            element.setAttributeNS(RTS_NS, RTS_NS_S + 'data', self.data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave this configuration data into a dictionary.", "response": "def to_dict(self):\n        '''Save this configuration data into a dictionary.'''\n        d = {'name': self.name}\n        if self.data:\n            d['data'] = self.data\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mutable(function):\n    '''Combined decorator of guarded.mutable and journal.recorded.\n\n    When called from outside a recording context, it returns a Deferred.\n    When called from inside a recording context, it returns a L{fiber.Fiber}\n    or any synchronous value.\n\n    Same as using::\n\n      @journal.recorded()\n      @guard.mutable\n      def spam(self, state, some, args):\n          pass\n    '''\n\n    guard_wrapper = guard.mutable(function)\n\n    # Register the function\n    canonical = reflect.class_canonical_name(3)\n    annotate.injectClassCallback(\"recorded\", 4,\n                                 \"_register_recorded_call\", guard_wrapper,\n                                 class_canonical_name=canonical)\n\n    def wrapper(self, *args, **kwargs):\n        recorder = IRecorder(self)\n        return recorder.call(guard_wrapper, args, kwargs)\n\n    return wrapper", "response": "Decorator for guarded. mutable and journal. recorded.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef acquire(self, specification, arguments=None):\n        if arguments is None:\n            realized_dependencies = {}\n        else:\n            realized_dependencies = copy.copy(arguments)\n\n        provider = self.providers[specification]\n\n        scope = None\n        if provider.scope is not None:\n            try:\n                scope = self.scopes[provider.scope]\n            except KeyError:\n                raise UnknownScopeError(provider.scope)\n\n        if scope is not None and specification in scope:\n            return scope[specification]\n\n        dependencies = six.iteritems(provider.dependencies)\n        for argument, dependency_specification in dependencies:\n            if argument not in realized_dependencies:\n                if isinstance(dependency_specification, Factory):\n                    realized_dependencies[argument] = self.FactoryProxy(\n                        self,\n                        dependency_specification.specification\n                    )\n                else:\n                    realized_dependencies[argument] = self.acquire(\n                        dependency_specification\n                    )\n\n        args = []\n        kwargs = {}\n        for argument, value in six.iteritems(realized_dependencies):\n            if isinstance(argument, six.integer_types):\n                # Integer keys are for positional arguments.\n                if len(args) <= argument:\n                    args.extend([None] * (argument + 1 - len(args)))\n                args[argument] = value\n            elif isinstance(argument, six.string_types):\n                # String keys are for keyword arguments.\n                kwargs[argument] = value\n            else:\n                raise TypeError(\n                    \"{} is not a valid argument key\".format(repr(argument))\n                )\n\n        instance = provider(*args, **kwargs)\n\n        if scope is not None:\n            scope[specification] = instance\n\n        return instance", "response": "Returns an object for the given specification injecting its provider\n            with a mix of its dependencies and given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_provider(self, specification, provider):\n        if provider.scope is not None and provider.scope not in self.scopes:\n            raise UnknownScopeError(provider.scope)\n        self.providers[specification] = provider", "response": "Registers a provider to be called when an object specified by specification is needed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating that every declared dependency is realized and that all of its self - dependencies are realized.", "response": "def validate(self):\n        \"\"\"\n        Asserts that every declared :term:`specification` can actually be\n        realized, meaning that all of its :term:`dependencies <dependency>` are\n        present and there are no self-dependencies or :term:`dependency cycles\n        <dependency cycle>`. If such a problem is found, a proper exception\n        (deriving from :py:class:`GraphValidationError`) is raised.\n\n        :raises:\n            :py:exc:`MissingDependencyError`,\n            :py:exc:`SelfDependencyError`,\n            :py:exc:`DependencyCycleError`\n        \"\"\"\n        # This method uses Tarjan's strongly connected components algorithm\n        # with added self-dependency check to find dependency cyclces.\n\n        # Index is just an integer, it's wrapped in a list as a workaround for\n        # Python 2's lack of `nonlocal` keyword, so the nested\n        # `strongconnect()` may modify it.\n        index = [0]\n\n        indices = {}\n        lowlinks = {}\n        stack = []\n\n        def strongconnect(specification):\n            # Set the depth index for the node to the smallest unused index.\n            indices[specification] = index[0]\n            lowlinks[specification] = index[0]\n            index[0] += 1\n            stack.append(specification)\n            provider = self.providers[specification]\n            dependencies = six.itervalues(provider.dependencies)\n            for dependency in dependencies:\n                if isinstance(dependency, Factory):\n                    dependency = dependency.specification\n                if dependency not in self.providers:\n                    raise MissingDependencyError(specification, dependency)\n                if dependency == specification:\n                    raise SelfDependencyError(specification)\n                if dependency not in indices:\n                    # Dependency has not yet been visited; recurse on it.\n                    strongconnect(dependency)\n                    lowlinks[specification] = min(\n                        lowlinks[specification],\n                        lowlinks[dependency]\n                    )\n                elif dependency in stack:\n                    # Dependency is in stack and hence in the current strongly\n                    # connected component.\n                    lowlinks[specification] = min(\n                        lowlinks[specification],\n                        indices[dependency]\n                    )\n            if lowlinks[specification] == indices[specification]:\n                component = []\n                while True:\n                    component.append(stack.pop())\n                    if component[-1] == specification:\n                        break\n                if len(component) > 1:\n                    raise DependencyCycleError(reversed(component))\n\n        for specification, provider in six.iteritems(self.providers):\n            if specification not in indices:\n                strongconnect(specification)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_with_retrieved(self, retrieved):\n        success = False\n        node_list = []\n\n        # Check that the retrieved folder is there\n        try:\n            out_folder = retrieved['retrieved']\n        except KeyError:\n            self.logger.error(\"No retrieved folder found\")\n            return success, node_list\n\n        # Check the folder content is as expected\n        list_of_files = out_folder.get_folder_list()\n        output_files = [self._calc._OUTPUT_FILE_NAME]\n        # Note: set(A) <= set(B) checks whether A is a subset\n        if set(output_files) <= set(list_of_files):\n            pass\n        else:\n            self.logger.error(\n                \"Not all expected output files {} were found\".format(\n                    output_files))\n            return success, node_list\n\n        # Do not return distance matrix, as it is too large\n        #from aiida.orm.data.singlefile import SinglefileData\n        #node = SinglefileData(\n        #    file=out_folder.get_abs_path(self._calc._OUTPUT_FILE_NAME))\n        #node_list.append(('distance_matrix', node))\n\n        success = True\n        return success, node_list", "response": "Parse the output data folder and store the result in the database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef server(addr):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind(addr)\n        sock.listen(1)\n        conn, addr = sock.accept()\n        talk = SocketTalk(conn)\n        return talk", "response": "Return a SocketTalk server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a SocketTalk client.", "response": "def client(addr):\n        \"\"\"Return a SocketTalk client.\"\"\"\n        success = False\n        while not success:\n            try:\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                sock.connect(addr)\n                success = True\n            except socket.error as err:\n                sock.close()\n        talk = SocketTalk(sock)\n        return talk"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, message):\n\n        # First assemble the complete message string by prefixing the header.\n        header = self.HEADER_FORMAT.format(len(message))\n        full_message = header + message\n\n        # Then send all bytes of the message.\n        sent_count = 0\n        while sent_count < len(full_message):\n            try:\n                msg = full_message[sent_count:]\n                msg = msg.encode() if self._encode else msg\n                count = self._sock.send(msg)\n            except socket.error as err:\n                print('error')\n                return False\n            if count == 0:\n                return False\n            sent_count += count\n        return True", "response": "Send the given message. Return True if successful False if not."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self):\n\n        # First retrieve all header bytes in order to extract\n        # length of the message remainder.\n        header = ''\n        while len(header) < self.HEADER_LENGTH:\n            chunk = self._sock.recv(self.HEADER_LENGTH - len(header))\n            chunk = chunk.decode() if self._encode else chunk\n            if chunk == '':\n                return None\n            header += chunk\n        length = int(header)\n\n        # Then retrieve the remainder of the message.\n        message = ''\n        while len(message) < length:\n            chunk = self._sock.recv(length - len(message))\n            chunk = chunk.decode() if self._encode else chunk\n            if chunk == '':\n                return None\n            message += chunk\n        return message", "response": "Receive a message.\n            Return the message upon successful reception or None upon failure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize(code):\n    if len(code) == 3:\n        return code\n\n    normalized = translate(code)\n\n    if normalized:\n        return normalized\n\n    country = countries.get(code, None)\n\n    if country:\n        return country.alpha3.lower()\n\n    return code", "response": "Normalizes language codes to ISO 639 - 2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exec(self, args):\n\n        logger.debug(\"install %s, location %s\", args.install, args.location)\n        location = args.location and os.path.abspath(args.location)\n\n        if location and len(args) > 1:\n            raise Exception((\"You cannot specify multiple install packages when \"\n                             \"using the --location option.\"\n                            ))\n\n        for repo in args.install:\n            self.install_repo(repo, location)", "response": "exec - Executes the command line tool for the\nTaxonomy class"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninclude persona settings into a pyramid config.", "response": "def includeme(config):\n    \"\"\"Include persona settings into a pyramid config.\n\n    This function does the following:\n\n        * Setup default authentication and authorization policies, and a default session factory.\n          Keep in mind that the sessions are not encrypted, if you need to store secret information in it, please\n          override the session factory.\n        * Add two request attributes :\n            * persona_js, the javascript code to inclue on a page to make persona work.\n            * persona_button, the html for a default login/logout button.\n        * Set login and logout views for use with persona.\n        * Set a forbidden view with a loggin button\n    \"\"\"\n    settings = config.get_settings()\n\n    if 'persona.audience' in settings:\n        settings['persona.audiences'] = settings['persona.audience']\n        warnings.warn('persona.audience has been changed to persona.audiences, and may accept more than one value. '\n                      'Please update you config file accordingly.', stacklevel=3)\n\n    if not 'persona.audiences' in settings:\n        raise ConfigurationError('Missing persona.audience settings. This is needed for security reasons. '\n                                 'See https://developer.mozilla.org/en-US/docs/Persona/Security_Considerations for details.')\n\n    # Default authentication and authorization policies. Those are needed to remember the userid.\n    authz_policy = ACLAuthorizationPolicy()\n    config.set_authorization_policy(authz_policy)\n    secret = settings.get('persona.secret', '')\n    authn_policy = AuthTktAuthenticationPolicy(secret, hashalg='sha512')\n    config.set_authentication_policy(authn_policy)\n\n    # A default session factory, needed for the csrf check.\n\n\n    session_factory = SignedCookieSessionFactory(secret)\n    config.set_session_factory(session_factory)\n\n    # Either a secret must be provided or the session factory must be overriden.\n    def check():\n        if config.registry.queryUtility(ISessionFactory) == session_factory and not secret:\n            raise ConfigurationError('If you do not override the session factory, you have to provide a persona.secret settings.')\n    config.action(None, check, order=PHASE2_CONFIG)\n\n\n    # Construct a browserid Verifier using the configured audience.\n    # This will pre-compile some regexes to reduce per-request overhead.\n    verifier_factory = config.maybe_dotted(settings.get('persona.verifier',\n                                                        'browserid.RemoteVerifier'))\n    audiences = aslist(settings['persona.audiences'])\n    config.registry['persona.verifier'] = verifier_factory(audiences)\n\n    # Parameters for the request API call\n    request_params = {}\n    for option in ('privacyPolicy', 'siteLogo', 'siteName', 'termsOfService', 'backgroundColor'):\n        setting_name = 'persona.%s'%option\n        if setting_name in settings:\n            request_params[option] = settings[setting_name]\n    config.registry['persona.request_params'] = json.dumps(request_params)\n\n    # Login and logout views.\n    login_route = settings.get('persona.login_route', 'login')\n    config.registry['persona.login_route'] = login_route\n    login_path = settings.get('persona.login_path', '/login')\n    config.add_route(login_route, login_path)\n    config.add_view(login, route_name=login_route, check_csrf=True,\n                    renderer='json',\n                    permission=NO_PERMISSION_REQUIRED)\n\n    logout_route = settings.get('persona.logout_route', 'logout')\n    config.registry['persona.logout_route'] = logout_route\n    logout_path = settings.get('persona.logout_path', '/logout')\n    config.add_route(logout_route, logout_path)\n    config.add_view(logout, route_name=logout_route, check_csrf=True,\n                    renderer='json',\n                    permission=NO_PERMISSION_REQUIRED)\n\n    # A simple 403 view, with a login button.\n    config.add_forbidden_view(forbidden)\n\n    # A quick access to the login button\n    config.add_request_method(button, 'persona_button', reify=True)\n\n    # The javascript needed by persona\n    config.add_request_method(js, 'persona_js', reify=True)\n\n    config.registry['persona.redirect_url_parameter'] = settings.get('persona.redirect_url_parameter', 'came_from')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_teaching(cls, belief, teaching, *args, **kwargs):\n        if teaching.__hash__ is None:\n            raise DictionaryDogmaException(''''The belief '%s' does not have a hashable teaching '%s' ''' % (belief, teaching ))\n\n        return teaching", "response": "Validate that the teaching object is hashable and return it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_color_temperature(self, temperature, effect=EFFECT_SUDDEN, transition_time=MIN_TRANSITION_TIME):\n        # Check bulb state\n        if self.is_off():\n            raise Exception(\"set_color_temperature can't be used if the bulb is off. Turn it on first\")\n        # Input validation\n        schema = Schema({'temperature': All(int, Range(min=1700, max=6500)),\n                         'effect': Any(self.EFFECT_SUDDEN, self.EFFECT_SMOOTH),\n                         'transition_time': All(int, Range(min=30))})\n        schema({'temperature': temperature, 'effect': effect, 'transition_time': transition_time})\n        # Send command\n        params = [temperature, effect, transition_time]\n        self.api_call.operate_on_bulb(\"set_ct_abx\", params)\n        # Update property\n        self.property[self.PROPERTY_NAME_COLOR_TEMPERATURE] = temperature", "response": "Set the white color temperature of the bulb."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the color of the bulb using rgb code.", "response": "def set_rgb_color(self, red, green, blue, effect=EFFECT_SUDDEN, transition_time=MIN_TRANSITION_TIME):\n        \"\"\"\n            Set the color of the bulb using rgb code. The bulb must be switched on.\n\n            :param red: Red component of the color between 0 and 255\n            :param green: Green component of the color between 0 and 255\n            :param blue: Blue component of the color between 0 and 255\n            :param effect: if the change is made suddenly or smoothly\n            :param transition_time: in case the change is made smoothly, time in ms that change last\n\n            :type red: int\n            :type green: int\n            :type blue: int\n            :type effect: str\n            :type transition_time : int\n        \"\"\"\n        # Check bulb state\n        if self.is_off():\n            raise Exception(\"set_rgb_color can't be used if the bulb is off. Turn it on first\")\n        # Input validation\n        schema = Schema({'red': All(int, Range(min=0, max=255)),\n                         'green': All(int, Range(min=0, max=255)),\n                         'blue': All(int, Range(min=0, max=255)),\n                         'effect': Any(self.EFFECT_SUDDEN, self.EFFECT_SMOOTH),\n                         'transition_time': All(int, Range(min=30))})\n        schema({'red': red, 'green': green, 'blue': blue,  'effect': effect, 'transition_time': transition_time})\n        # Send command\n        rgb = (red*65536) + (green*256) + blue\n        params = [rgb, effect, transition_time]\n        self.api_call.operate_on_bulb(\"set_rgb\", params)\n        # Update property\n        self.property[self.PROPERTY_NAME_RGB_COLOR] = rgb"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the color of the bulb using hsv code.", "response": "def set_hsv_color(self, hue, saturation, effect=EFFECT_SUDDEN, transition_time=MIN_TRANSITION_TIME):\n        \"\"\"\n            Set the color of the bulb using hsv code. The bulb must be switched on.\n            TODO : Resolve bug found trying to set hue to 100 and sat to 100 (General error)\n\n            :param hue: Hue component of the color between 0 and 359\n            :param saturation: Saturation component of the color between 0 and 100\n            :param effect: if the change is made suddenly or smoothly\n            :param transition_time: in case the change is made smoothly, time in ms that change last\n\n            :type hue: int\n            :type saturation: int\n            :type effect: str\n            :type transition_time : int\n        \"\"\"\n        # Check bulb state\n        if self.is_off():\n            raise Exception(\"set_hsv_color can't be used if the bulb is off. Turn it on first\")\n        # Input validation\n        schema = Schema({'hue': All(int, Range(min=0, max=359)),\n                         'saturation': All(int, Range(min=0, max=100)),\n                         'effect': Any(self.EFFECT_SUDDEN, self.EFFECT_SMOOTH),\n                         'transition_time': All(int, Range(min=30))})\n        schema({'hue': hue, 'saturation': saturation, 'effect': effect, 'transition_time': transition_time})\n        # Send command\n        params = [hue, saturation, effect, transition_time]\n        self.api_call.operate_on_bulb(\"set_hsv\", params)\n        # Update property\n        self.property[self.PROPERTY_NAME_HUE] = hue\n        self.property[self.PROPERTY_NAME_SATURATION] = saturation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adjust(self, action, prop):\n        # Input validation\n        schema = Schema(\n            {'action': Any(self.ADJUST_ACTION_CIRCLE, self.ADJUST_ACTION_DECREASE, self.ADJUST_ACTION_INCREASE),\n             'prop': Any(self.ADJUST_PROPERTY_BRIGHTNESS, self.ADJUST_PROPERTY_COLOR,\n                         self.ADJUST_PROPERTY_COLOR_TEMPERATURE)})\n        schema({'action': action, 'prop': prop})\n        # Send command\n        params = [action, prop]\n        self.api_call.operate_on_bulb(\"set_adjust\", params)\n        # Update property\n        self.refresh_property()", "response": "This method is used to adjust the brightness of a smart LED without knowing the current value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Deleted response builder with specified message.", "response": "def created(message):\n    \"\"\"Create a Deleted response builder with specified message.\"\"\"\n\n    def create(value, _context, **_params):\n        return Created(value, message)\n\n    return create"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deleted(message):\n\n    def deleted(value, _context, **_params):\n        return Deleted(value, message)\n\n    return deleted", "response": "Create a Deleted response builder with specified message."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a Deleted response builder with specified message.", "response": "def done(message):\n    \"\"\"Create a Deleted response builder with specified message.\"\"\"\n\n    def done(value, _context, **_params):\n        return Done(value, message)\n\n    return done"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_elements_with_source(source, field):\n    return freeze(\n        [element for element in field if element.get('source', '').lower() != source]\n    )", "response": "Remove all elements matching source in field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef keep_only_update_source_in_field(field, root, head, update):\n    update_sources = {source.lower() for source in get_value(thaw(update), '.'.join([field, 'source']), [])}\n    if len(update_sources) != 1:\n        return root, head, update\n    source = update_sources.pop()\n\n    if field in root:\n        root = root.set(field, remove_elements_with_source(source, root[field]))\n    if field in head:\n        head = head.set(field, remove_elements_with_source(source, head[field]))\n\n    return root, head, update", "response": "Remove elements from root and head where source matches the update."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove references from either head or update depending on curation.", "response": "def filter_curated_references(root, head, update):\n    \"\"\"Remove references from either ``head`` or ``update`` depending on curation.\n\n    If references have been curated, then it removes all references from the\n    update to keep the existing ones. Otherwise, it removes all references from\n    the head to force replacement with the update ones.\n\n    Args:\n        root (pmap): the root record.\n        head (pmap): the head record.\n        update (pmap): the update record.\n\n    Returns:\n        tuple: ``(root, head, update)`` with ``references`` removed from ``root`` and either\n        ``head`` or ``update``.\n    \"\"\"\n    if 'references' not in head or 'references' not in update:\n        return root, head, update\n\n    references_curated = are_references_curated(root.get('references', []), head.get('references', []))\n    if 'references' in root:\n        root = root.remove('references')\n    if references_curated:\n        update = update.remove('references')\n    else:\n        head = head.remove('references')\n\n    return root, head, update"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_publisher_references(root, head, update):\n    if 'references' in head:\n        root = _remove_if_present(root, 'references')\n        update = _remove_if_present(update, 'references')\n\n    return root, head, update", "response": "Remove references from update if there are any in head."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef button(request):\n    if not authenticated_userid(request):\n        return markupsafe.Markup(SIGNIN_HTML)\n    else:\n        return markupsafe.Markup(SIGNOUT_HTML)", "response": "Returns the button to be displayed when the user is logged in."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the javascript needed to run persona", "response": "def js(request):\n    \"\"\"Returns the javascript needed to run persona\"\"\"\n    userid = authenticated_userid(request)\n    user = markupsafe.Markup(\"'%s'\")%userid if userid else \"null\"\n    redirect_paramater = request.registry['persona.redirect_url_parameter']\n    came_from = '%s%s' % (request.host_url,\n                          request.GET.get(redirect_paramater, request.path_qs))\n    data = {\n        'user': user,\n        'login': request.route_path(request.registry['persona.login_route']),\n        'logout': request.route_path(request.registry['persona.logout_route']),\n        'csrf_token': request.session.get_csrf_token(),\n        'came_from': came_from,\n        'request_params': markupsafe.Markup(request.registry['persona.request_params']),\n    }\n    template = markupsafe.Markup(pkg_resources.resource_string('pyramid_persona', 'templates/persona.js').decode())\n    return template % data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n    empty = False\n    while not empty:\n      try:\n        s = self.series.get()\n        result_dict = itunes.get_rss_feed_data_from_series(s)\n        self.storer.store(result_dict)\n        self.logger.info('Retrieved and stored %s', str(s.id))\n      except Exception as e: # pylint: disable=W0703\n        print e\n      finally:\n        self.series.task_done()\n        empty = self.series.empty()", "response": "Run the task - compose full series + add to our results\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing all the crosslistings and stores them in the catalog.", "response": "def crosslisting_feature(catalog, soup):\n    \"\"\"Parses all the crosslistings. These refer to the similar CRNs,\n    such as a grad & undergrad level course.\n    \"\"\"\n    listing = {}\n    for elem in soup.coursedb.findAll('crosslisting'):\n        seats = int(elem['seats'])\n        crns = [safeInt(crn.string) for crn in elem.findAll('crn')]\n\n        # we want to refer to the same object to save space\n        cl = CrossListing(crns, seats)\n        for crn in crns:\n            listing[crn] = cl\n    catalog.crosslistings = FrozenDict(listing)\n\n    logger.info('Catalog has %d course crosslistings' % len(catalog.crosslistings))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse all the courses in the catalog.", "response": "def course_feature(catalog, soup):\n    \"\"\"Parses all the courses (AKA, the most important part).\n    \"\"\"\n    courses = {}\n    course_crns = {}\n    for course in soup.findAll('course'):\n        c = Course.from_soup_tag(course)\n        courses[str(c)] = c\n    catalog.courses = courses\n    catalog.courses\n    logger.info('Catalog has %d courses' % len(courses))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfix the belief of a DogmaMetaClass instance to be consistent with the current state of the Dogma class.", "response": "def _fixup_belief(cls, belief):\n        \"\"\"\n        Transforms beliefs into valid strings if possible and parses any options.\n\n        Beliefs will always be lowercased.\n        If it has spaces, they are converted to underscores ex: \"Sensor Names\" -> \"sensor_names\"\n\n        Options:\n            Multiple values: a belief with a suffix of \"*\" will allow multiple values returned from the get\n                             when used with MultipleXmlDogma.\n        \"\"\"\n        extra = {}\n        belief = belief.lower()\n\n        if ' ' in belief:\n            belief = belief.replace(' ', '_')\n\n        if belief.endswith(\"*\"):\n            belief = belief[:-1]\n            extra['multiple'] = True\n\n        # check for invalid characters in the belief which is used as a property name\n        if re.match('^[\\w-]+$', belief) is None:\n            raise DogmaMetaClassException('''blasphemous belief! (property name: '%s') - even god can not make properties with non-alpha-numeric symbols or whitespace''' % belief)\n\n        if belief.startswith('_'):\n            raise DogmaMetaClassException('''Blasphemous belief! (property name: '%s') - even god can not make properties that start with an underscore''' % belief)\n\n        return belief, extra"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle a message received from the server.", "response": "def on_message(self, msg):\n        '''\n        When a message with an already known traversal_id is received,\n        we try to build a duplication message and send it in to a protocol\n        dependent recipient. This is used in contracts traversing\n        the graph, when the contract has reached again the same shard.\n        This message is necessary, as silently ignoring the incoming bids\n        adds a lot of latency to the nested contracts (it is waiting to receive\n        message from all the recipients).\n        '''\n        self.log('Received message: %r', msg)\n\n        # Check if it isn't expired message\n        time_left = time.left(msg.expiration_time)\n        if time_left < 0:\n            self.log('Throwing away expired message. Time left: %s, '\n                     'msg_class: %r', time_left, msg.get_msg_class())\n            return False\n\n        # Check for duplicated message\n        if msg.message_id in self._message_ids:\n            self.log(\"Throwing away duplicated message %r\",\n                     msg.get_msg_class())\n            return False\n        else:\n            self._message_ids.set(msg.message_id, True, msg.expiration_time)\n\n        # Check for known traversal ids:\n        if IFirstMessage.providedBy(msg):\n            t_id = msg.traversal_id\n            if t_id is None:\n                self.warning(\n                    \"Received corrupted message. The traversal_id is None ! \"\n                    \"Message: %r\", msg)\n                return False\n            if t_id in self._traversal_ids:\n                self.log('Throwing away already known traversal id %r, '\n                         'msg_class: %r', t_id, msg.get_msg_class())\n                recp = msg.duplication_recipient()\n                if recp:\n                    resp = msg.duplication_message()\n                    self.post(recp, resp)\n                return False\n            else:\n                self._traversal_ids.set(t_id, True, msg.expiration_time)\n\n        # Handle registered dialog\n        if IDialogMessage.providedBy(msg):\n            recv_id = msg.receiver_id\n            if recv_id is not None and \\\n               recv_id in self._agency_agent._protocols:\n                protocol = self._agency_agent._protocols[recv_id]\n                protocol.on_message(msg)\n                return True\n\n        # Handle new conversation coming in (interest)\n        # if msg.protocol_id == 'alert':\n        #     print self._agency_agent._interests\n        p_type = msg.protocol_type\n        if p_type in self._agency_agent._interests:\n            p_id = msg.protocol_id\n            interest = self._agency_agent._interests[p_type].get(p_id)\n            if interest and interest.schedule_message(msg):\n                return True\n\n        self.debug(\"Couldn't find appropriate protocol for message: \"\n                   \"%s\", msg.get_msg_class())\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the next header type\n        bitstream = BitStream('uint:8=%d' % self.next_header)\n\n        # Add the reserved bits\n        bitstream += BitStream(8)\n\n        # Add the fragment offset\n        bitstream += BitStream('uint:13=%d' % self.fragment_offset)\n\n        # Add the reserved bits\n        bitstream += BitStream(2)\n\n        # Add the flags\n        bitstream += BitStream('bool=%d' % self.more_fragments)\n\n        # Add the identification\n        bitstream += BitStream('uint:32=%d' % self.identification)\n\n        return bitstream.bytes + bytes(self.payload)", "response": "Create bytes from properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wrapwrite(text):\n    try:  # Python3\n        sys.stdout.buffer.write(text)\n    except AttributeError:\n        sys.stdout.write(text.encode('utf-8'))", "response": "Wrap text in a new line in a new line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading card data from a JSON - file.", "response": "def from_file(cls, db_file=ALL_SETS_PATH):\n        \"\"\"Reads card data from a JSON-file.\n\n        :param db_file: A file-like object or a path.\n        :return: A new :class:`~mtgjson.CardDb` instance.\n        \"\"\"\n        if callable(getattr(db_file, 'read', None)):\n            return cls(json.load(db_file))\n\n        with io.open(db_file, encoding='utf8') as inp:\n            return cls(json.load(inp))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_url(cls, db_url=ALL_SETS_ZIP_URL):\n        r = requests.get(db_url)\n        r.raise_for_status()\n\n        if r.headers['content-type'] == 'application/json':\n            return cls(json.loads(r.text))\n\n        if r.headers['content-type'] == 'application/zip':\n            with zipfile.ZipFile(six.BytesIO(r.content), 'r') as zf:\n                names = zf.namelist()\n                assert len(names) == 1, 'One datafile in ZIP'\n                return cls.from_file(io.TextIOWrapper(\n                    zf.open(names[0]),\n                    encoding='utf8'))", "response": "Load a card from a URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef login(self, email=None, password=None):\n        auth_url = self.url('auth')\n        email = email or self._config.get('email')\n        password = password or self._config.get('password')\n        if password and not email:\n            raise Exception('Email must be provided when password is.')\n        while True:\n            if not email:\n                sys.stdout.write('Email: ')\n                sys.stdout.flush()\n                email = sys.stdin.readline().strip()\n                if not email:\n                    print('Goodbye!')\n                    sys.exit(1)\n            if not password:\n                password = getpass.getpass('Password for {0}: '.format(email))\n            response = self.request(auth_url, 'PUT', email=email,\n                                    password=password)\n            if response.status_code == 201:\n                print('logged in as {0}'.format(email))\n                self.save_prompt(email, password)\n                self.email = email\n                break\n            else:\n                print(response.json()['messages'])\n                email = password = None", "response": "Login to establish a valid session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef report(     callingClass,\n                astr_key,\n                ab_exitToOs     = 1,\n                astr_header     = \"\",\n                **kwargs\n                ):\n    '''\n    Error handling.\n\n    Based on the <astr_key>, error information is extracted from\n    _dictErr and sent to log object.\n\n    If <ab_exitToOs> is False, error is considered non-fatal and\n    processing can continue, otherwise processing terminates.\n\n    '''\n\n    astr_header         = \"\"\n    ab_exitToOS         = False\n    ab_drawBox          = False\n    for k, v in kwargs.items():\n        if k == 'header':   astr_header     = v\n        if k == 'exitToOS': ab_exitToOS     = v\n        if k == 'drawBox':  ab_drawBox      = v\n\n    if ab_drawBox:\n        log     = slog()\n    else:\n        log     = Message()\n\n    b_syslog    = log.syslog()\n    log.syslog(False)\n    if ab_exitToOS: log( Colors.RED +    \":: FATAL ERROR :: \" + Colors.NO_COLOUR )\n    else:           log( Colors.YELLOW + \"::   WARNING   :: \" + Colors.NO_COLOUR )\n    if len(astr_header): log( Colors.BROWN + astr_header + Colors.NO_COLOUR )\n    log( \"\\n\" )\n    log( \"\\tSorry, some error seems to have occurred in:\\n\\n\\t\\t<\" )\n    try:\n        caller = inspect.stack()[3][4][0].strip()\n    except:\n        caller = '__main__'\n    log( Colors.LIGHT_GREEN + (\"%s\" % callingClass.__class__.__name__) + Colors.NO_COLOUR + \"::\")\n    log( Colors.LIGHT_CYAN + (\"%s\" % caller) + Colors.NO_COLOUR)\n    log( \">\\n\\n\")\n\n    log( \"\\tWhile %s\\n\" % callingClass._dictErr[astr_key]['action'] )\n    log( \"\\t%s\\n\" % callingClass._dictErr[astr_key]['error'] )\n    log( \"\\n\" )\n    log( \"Returning with error code %s%d%s\" % (\n                    Colors.YELLOW,\n                    callingClass._dictErr[astr_key]['exitCode'],\n                    Colors.NO_COLOUR\n                    )\n    )\n\n    if ab_drawBox:\n        print(log.border_draw())\n    if ab_exitToOS:\n        sys.exit( callingClass._dictErr[astr_key]['exitCode'] )\n    log.syslog(b_syslog)\n    return callingClass._dictErr[astr_key]['exitCode']", "response": "Report the error of a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fatal( callingClass, astr_key, **kwargs ):\n    '''\n    Convenience dispatcher to the error_exit() method.\n\n    Will raise \"fatal\" error, i.e. terminate script.\n    '''\n    kwargs['exitToOS']  = True\n    report( callingClass, astr_key, **kwargs )", "response": "This method is used to raise a fatal error in the current interpreter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warn( callingClass, astr_key, **kwargs ):\n    '''\n    Convenience dispatcher to the error_exit() method.\n\n    Will raise \"warning\" error, i.e. script processing continues.\n    '''\n    kwargs['exitToOS']  = False\n    report( callingClass, astr_key, **kwargs )", "response": "A helper method to raise a warning error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_command(raw_command):\n    parsed_command = raw_command.split()\n    arg_count = len(parsed_command) - 1\n\n    if not parsed_command:\n        return\n\n    if parsed_command[0] == pytwis_clt_constants.CMD_REGISTER:\n        if arg_count < 2:\n            raise ValueError('{cmd} {{{arg1}}} {{{arg2}}}'.\\\n                             format(cmd=pytwis_clt_constants.CMD_REGISTER,\n                                    arg1=pytwis_clt_constants.ARG_USERNAME,\n                                    arg2=pytwis_clt_constants.ARG_PASSWORD))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_LOGIN:\n        if arg_count < 2:\n            raise ValueError('{cmd} {{{arg1}}} {{{arg2}}}'.\\\n                             format(cmd=pytwis_clt_constants.CMD_LOGIN,\n                                    arg1=pytwis_clt_constants.ARG_USERNAME,\n                                    arg2=pytwis_clt_constants.ARG_PASSWORD))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_LOGOUT:\n        pass\n    elif parsed_command[0] == pytwis_clt_constants.CMD_CHANGE_PASSWORD:\n        if arg_count < 3:\n            raise ValueError('{cmd} {{{arg1}}} {{{arg2}}} {{{arg3}}}'.\\\n                             format(cmd=pytwis_clt_constants.CMD_CHANGE_PASSWORD,\n                                    arg1=pytwis_clt_constants.ARG_OLD_PASSWORD,\n                                    arg2=pytwis_clt_constants.ARG_NEW_PASSWORD,\n                                    arg3=pytwis_clt_constants.ARG_CONFIRMED_NEW_PASSWORD))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_GET_USER_PROFILE:\n        pass\n    elif parsed_command[0] == pytwis_clt_constants.CMD_POST:\n        if arg_count < 1:\n            raise ValueError('{cmd} {{{arg}}}'.format(cmd=pytwis_clt_constants.CMD_POST,\n                                                      arg=pytwis_clt_constants.ARG_TWEET))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_FOLLOW:\n        if arg_count < 1:\n            raise ValueError('{cmd} {{{arg}}}'.format(cmd=pytwis_clt_constants.CMD_FOLLOW,\n                                                      arg=pytwis_clt_constants.ARG_FOLLOWEE))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_UNFOLLOW:\n        if arg_count < 1:\n            raise ValueError('{cmd} {{{arg}}}'.format(cmd=pytwis_clt_constants.CMD_UNFOLLOW,\n                                                      arg=pytwis_clt_constants.ARG_FOLLOWEE))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_GET_FOLLOWERS:\n        pass\n    elif parsed_command[0] == pytwis_clt_constants.CMD_GET_FOLLOWINGS:\n        pass\n    elif parsed_command[0] == pytwis_clt_constants.CMD_TIMELINE:\n        if arg_count > 1:\n            raise ValueError('{cmd} {{{arg}}} or {cmd}'.\\\n                             format(cmd=pytwis_clt_constants.CMD_TIMELINE,\n                                    arg=pytwis_clt_constants.ARG_MAX_TWEETS))\n    elif parsed_command[0] == pytwis_clt_constants.CMD_GET_USER_TWEETS:\n        if arg_count > 2:\n            raise ValueError('{cmd} {{{arg1}}} {{{arg2}}} or {cmd} {{{arg1}}} or {cmd}'.\\\n                             format(cmd=pytwis_clt_constants.CMD_GET_USER_TWEETS,\n                                    arg1=pytwis_clt_constants.ARG_USERNAME,\n                                    arg2=pytwis_clt_constants.ARG_MAX_TWEETS))\n    elif (parsed_command[0] == pytwis_clt_constants.CMD_EXIT) or\\\n         (parsed_command[0] == pytwis_clt_constants.CMD_QUIT):\n        pass\n    else:\n        raise ValueError('Invalid pytwis command')", "response": "Validate the command input."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the raw command input and returns the result as a sequence of arguments.", "response": "def pytwis_command_parser(raw_command):\n    \"\"\"Parse the command input.\n\n    Parameters\n    ----------\n    raw_command: str\n        The raw command input, e.g., `register xxxxxx yyyyyy`.\n\n    Returns\n    -------\n    arg_dict: dict(str, str or int)\n        The parsed command output.\n        {'command':'register', 'username': <username>, 'password': <password>} for `register`.\n    Raises\n    ------\n    ValueError\n        If the raw command can't be parsed correctly, e.g., it has an incorrect number of\n        arguments or incorrect arguments.\n    \"\"\"\n    validate_command(raw_command)\n\n    # Some command (e.g., logout) may not have arguments.\n    # Separate the command from its arguments.\n    splited_raw_command = raw_command.split(' ', 1)\n\n    arg_dict = {}\n\n    if splited_raw_command[0] == pytwis_clt_constants.CMD_REGISTER:\n        # register must have two arguments: username and password.\n        args = splited_raw_command[1]\n\n        arg_dict = parse.parse('{{{arg1}}} {{{arg2}}}'.\\\n                               format(arg1=pytwis_clt_constants.ARG_USERNAME,\n                                      arg2=pytwis_clt_constants.ARG_PASSWORD),\n                               args)\n        if arg_dict is None:\n            raise ValueError('{} has incorrect arguments'.format(pytwis_clt_constants.CMD_REGISTER))\n        elif ' ' in arg_dict[pytwis_clt_constants.ARG_PASSWORD]:\n            raise ValueError(\"password can't contain spaces\")\n\n        print('{}: username = {}, password = {}'.\\\n              format(pytwis_clt_constants.CMD_REGISTER,\n                     arg_dict[pytwis_clt_constants.ARG_USERNAME],\n                     arg_dict[pytwis_clt_constants.ARG_PASSWORD]))\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_LOGIN:\n        # login must have two arguments: username and password.\n        args = splited_raw_command[1]\n        arg_dict = parse.parse('{{{arg1}}} {{{arg2}}}'.\\\n                               format(arg1=pytwis_clt_constants.ARG_USERNAME,\n                                      arg2=pytwis_clt_constants.ARG_PASSWORD),\n                               args)\n        if arg_dict is None:\n            raise ValueError('{} has incorrect arguments'.format(pytwis_clt_constants.CMD_LOGIN))\n\n        print('{}: username = {}, password = {}'.\\\n              format(pytwis_clt_constants.CMD_LOGIN,\n                     arg_dict[pytwis_clt_constants.ARG_USERNAME],\n                     arg_dict[pytwis_clt_constants.ARG_PASSWORD]))\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_LOGOUT:\n        # logout doesn't have any arguments.\n        pass\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_CHANGE_PASSWORD:\n        # changepwd must have three arguments: old_password, new_password, and\n        # confirmed_new_password.\n        args = splited_raw_command[1]\n        arg_dict = parse.parse('{{{arg1}}} {{{arg2}}} {{{arg3}}}'.\\\n                               format(arg1=pytwis_clt_constants.ARG_OLD_PASSWORD,\n                                      arg2=pytwis_clt_constants.ARG_NEW_PASSWORD,\n                                      arg3=pytwis_clt_constants.ARG_CONFIRMED_NEW_PASSWORD),\n                               args)\n        if arg_dict is None:\n            raise ValueError('{} has incorrect arguments'.\\\n                             format(pytwis_clt_constants.CMD_CHANGE_PASSWORD))\n        elif arg_dict[pytwis_clt_constants.ARG_NEW_PASSWORD] !=\\\n            arg_dict[pytwis_clt_constants.ARG_CONFIRMED_NEW_PASSWORD]:\n            raise ValueError('The confirmed new password is different from the new password')\n        elif arg_dict[pytwis_clt_constants.ARG_NEW_PASSWORD] ==\\\n            arg_dict[pytwis_clt_constants.ARG_OLD_PASSWORD]:\n            raise ValueError('The new password is the same as the old password')\n\n        print('{}: old = {}, new = {}'.format(pytwis_clt_constants.CMD_CHANGE_PASSWORD,\n                                              arg_dict[pytwis_clt_constants.ARG_OLD_PASSWORD],\n                                              arg_dict[pytwis_clt_constants.ARG_NEW_PASSWORD]))\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_GET_USER_PROFILE:\n        # userprofile doesn't have any arguments.\n        pass\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_POST:\n        # post must have one argument: tweet\n        arg_dict = {pytwis_clt_constants.ARG_TWEET: splited_raw_command[1]}\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_FOLLOW:\n        # follow must have one argument: followee.\n        arg_dict = {pytwis_clt_constants.ARG_FOLLOWEE: splited_raw_command[1]}\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_UNFOLLOW:\n        # unfollow must have one argument: followee.\n        arg_dict = {pytwis_clt_constants.ARG_FOLLOWEE: splited_raw_command[1]}\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_GET_FOLLOWERS:\n        # followers doesn't have any arguments.\n        pass\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_GET_FOLLOWINGS:\n        # followings doesn't have any arguments.\n        pass\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_TIMELINE:\n        # timeline has either zero or one argument.\n        max_cnt_tweets = -1\n        if len(splited_raw_command) >= 2:\n            max_cnt_tweets = int(splited_raw_command[1])\n\n        arg_dict = {pytwis_clt_constants.ARG_MAX_TWEETS: max_cnt_tweets}\n    elif splited_raw_command[0] == pytwis_clt_constants.CMD_GET_USER_TWEETS:\n        # tweetsby has either zero or one or two arguments.\n        arg_dict = {pytwis_clt_constants.ARG_USERNAME: None,\n                    pytwis_clt_constants.ARG_MAX_TWEETS: -1}\n\n        if len(splited_raw_command) >= 2:\n            # tweetsby has either one or two arguments.\n            args = splited_raw_command[1]\n            arg_dict = parse.parse('{{{arg1}}} {{{arg2}:d}}'.\\\n                                   format(arg1=pytwis_clt_constants.ARG_USERNAME,\n                                          arg2=pytwis_clt_constants.ARG_MAX_TWEETS),\n                                   args)\n            if arg_dict is None:\n                # tweetsby has only one argument.\n                arg_dict = {pytwis_clt_constants.ARG_USERNAME: args}\n                arg_dict[pytwis_clt_constants.ARG_MAX_TWEETS] = -1\n    elif (splited_raw_command[0] == pytwis_clt_constants.CMD_EXIT) or\\\n        (splited_raw_command[0] == pytwis_clt_constants.CMD_QUIT):\n        # exit or quit doesn't have any arguments.\n        pass\n    else:\n        pass\n\n    if isinstance(arg_dict, parse.Result):\n        arg_dict = arg_dict.named\n    arg_dict[pytwis_clt_constants.ARG_COMMAND] = splited_raw_command[0]\n\n    return arg_dict"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_tweets(tweets):\n    print('=' * 60)\n    for index, tweet in enumerate(tweets):\n        print('-' * 60)\n        print('Tweet {}:'.format(index))\n        print('Username:', tweet[pytwis_constants.USERNAME_KEY])\n        print('Time:',\n              datetime.datetime.fromtimestamp(int(tweet[pytwis_constants.TWEET_UNIXTIME_KEY])).\\\n              strftime('%Y-%m-%d %H:%M:%S'))\n        print('Body:\\n\\t', tweet[pytwis_constants.TWEET_BODY_KEY])\n        print('-' * 60)\n    print('=' * 60)", "response": "Print a list of tweets one by one separated by = s."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pytwis_command_processor(twis, auth_secret, args):\n    command = args[pytwis_clt_constants.ARG_COMMAND]\n\n    if command == pytwis_clt_constants.CMD_REGISTER:\n        succeeded, result = twis.register(args[pytwis_clt_constants.ARG_USERNAME],\n                                          args[pytwis_clt_constants.ARG_PASSWORD])\n        if succeeded:\n            print('Registered {}'.format(args[pytwis_clt_constants.ARG_USERNAME]))\n        else:\n            print(\"Couldn't register {} with error = {}\".\\\n                  format(args[pytwis_clt_constants.ARG_USERNAME],\n                         result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_LOGIN:\n        succeeded, result = twis.login(args[pytwis_clt_constants.ARG_USERNAME],\n                                       args[pytwis_clt_constants.ARG_PASSWORD])\n        if succeeded:\n            auth_secret[0] = result[pytwis_constants.AUTH_KEY]\n            print('Logged into username {}'.format(args[pytwis_clt_constants.ARG_USERNAME]))\n        else:\n            print(\"Couldn't log into username {} with error = {}\".\\\n                  format(args[pytwis_clt_constants.ARG_USERNAME],\n                         result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_LOGOUT:\n        succeeded, result = twis.logout(auth_secret[0])\n        if succeeded:\n            auth_secret[0] = result[pytwis_constants.AUTH_KEY]\n            print('Logged out of username {}'.format(result[pytwis_constants.USERNAME_KEY]))\n        else:\n            print(\"Couldn't log out with error = {}\".format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_CHANGE_PASSWORD:\n        succeeded, result = twis.change_password(auth_secret[0],\n                                                 args[pytwis_clt_constants.ARG_OLD_PASSWORD],\n                                                 args[pytwis_clt_constants.ARG_NEW_PASSWORD])\n        if succeeded:\n            auth_secret[0] = result[pytwis_constants.AUTH_KEY]\n            print('Changed the password')\n        else:\n            print(\"Couldn't change the password with error = {}\".\\\n                  format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_GET_USER_PROFILE:\n        succeeded, result = twis.get_user_profile(auth_secret[0])\n        if succeeded:\n            print('Got the user profile')\n            print('=' * 20)\n            for key, value in result.items():\n                print('{}: {}'.format(key, value))\n            print('=' * 20)\n        else:\n            print(\"Couldn't get the user profile with error = {}\".\\\n                  format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_POST:\n        succeeded, result = twis.post_tweet(auth_secret[0], args['tweet'])\n        if succeeded:\n            print('Posted the tweet')\n        else:\n            print(\"Couldn't post the tweet with error = {}\".\\\n                  format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_FOLLOW:\n        succeeded, result = twis.follow(auth_secret[0],\n                                        args[pytwis_clt_constants.ARG_FOLLOWEE])\n        if succeeded:\n            print('Followed username {}'.format(args[pytwis_clt_constants.ARG_FOLLOWEE]))\n        else:\n            print(\"Couldn't follow the username {} with error = {}\".\\\n                  format(args[pytwis_clt_constants.ARG_FOLLOWEE],\n                         result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_UNFOLLOW:\n        succeeded, result = twis.unfollow(auth_secret[0],\n                                          args[pytwis_clt_constants.ARG_FOLLOWEE])\n        if succeeded:\n            print('Unfollowed username {}'.format(args[pytwis_clt_constants.ARG_FOLLOWEE]))\n        else:\n            print(\"Couldn't unfollow the username {} with error = {}\".\\\n                  format(args[pytwis_clt_constants.ARG_FOLLOWEE],\n                         result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_GET_FOLLOWERS:\n        succeeded, result = twis.get_followers(auth_secret[0])\n        if succeeded:\n            print('Got the list of {} followers'.\\\n                  format(len(result[pytwis_constants.FOLLOWER_LIST_KEY])))\n            print('=' * 20)\n            for follower in result[pytwis_constants.FOLLOWER_LIST_KEY]:\n                print('\\t' + follower)\n            print('=' * 20)\n        else:\n            print(\"Couldn't get the follower list with error = {}\".\\\n                  format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_GET_FOLLOWINGS:\n        succeeded, result = twis.get_following(auth_secret[0])\n        if succeeded:\n            print('Got the list of {} followings'.\\\n                  format(len(result[pytwis_constants.FOLLOWING_LIST_KEY])))\n            print('=' * 60)\n            for following in result[pytwis_constants.FOLLOWING_LIST_KEY]:\n                print('\\t' + following)\n            print('=' * 60)\n        else:\n            print(\"Couldn't get the following list with error = {}\".\\\n                  format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_TIMELINE:\n        succeeded, result = twis.get_timeline(auth_secret[0],\n                                              args[pytwis_clt_constants.ARG_MAX_TWEETS])\n        if succeeded:\n            if auth_secret[0] != '':\n                print('Got {} tweets in the user timeline'.\\\n                      format(len(result[pytwis_constants.TWEETS_KEY])))\n            else:\n                print('Got {} tweets in the general timeline'.\\\n                      format(len(result[pytwis_constants.TWEETS_KEY])))\n            print_tweets(result[pytwis_constants.TWEETS_KEY])\n        else:\n            if auth_secret[0] != '':\n                print(\"Couldn't get the user timeline with error = {}\".\\\n                      format(result[pytwis_constants.ERROR_KEY]))\n            else:\n                print(\"Couldn't get the general timeline with error = {}\".\\\n                      format(result[pytwis_constants.ERROR_KEY]))\n    elif command == pytwis_clt_constants.CMD_GET_USER_TWEETS:\n        # Get the username of the currently logged-in user if no username is given.\n        if args[pytwis_clt_constants.ARG_USERNAME] is None:\n            succeeded, result = twis.get_user_profile(auth_secret[0])\n            if succeeded:\n                args[pytwis_clt_constants.ARG_USERNAME] = result[pytwis_constants.USERNAME_KEY]\n                print('No username is given, so use the currently logged-in user {}'.\\\n                      format(args[pytwis_clt_constants.ARG_USERNAME]))\n            else:\n                print(\"Couldn't get the username of the currently logged-in user with error = {}\".\\\n                      format(result[pytwis_constants.ERROR_KEY]))\n                return\n\n        succeeded, result = twis.get_user_tweets(auth_secret[0],\n                                                 args[pytwis_clt_constants.ARG_USERNAME],\n                                                 args[pytwis_clt_constants.ARG_MAX_TWEETS])\n        if succeeded:\n            print('Got {} tweets posted by {}'.format(len(result[pytwis_constants.TWEETS_KEY]),\n                                                      args[pytwis_clt_constants.ARG_USERNAME]))\n            print_tweets(result[pytwis_constants.TWEETS_KEY])\n        else:\n            print(\"Couldn't get the tweets posted by {} with error = {}\".\\\n                  format(args[pytwis_clt_constants.ARG_USERNAME],\n                         result[pytwis_constants.ERROR_KEY]))\n    else:\n        pass", "response": "Process the command output by pytwis_command_parser."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pytwis(epilog):\n    # Note that we set the conflict handler of ArgumentParser to 'resolve' because we reuse\n    # the short help option '-h' for the host name.\n    parser = argparse.ArgumentParser(conflict_handler=\"resolve\",\n                                     formatter_class=argparse.RawDescriptionHelpFormatter,\n                                     description=\\\n                                     'Connect to the Redis database of a Twitter clone and '\n                                     'then run commands to access and update the database.',\n                                     epilog=epilog)\n    parser.add_argument('-h', '--hostname', nargs='?', default='127.0.0.1',\n                        help='''the Redis server hostname. If the option is not specified,\n                             will be defaulted to 127.0.0.1. If the option is specified but\n                             no value is given after the option, then the help information\n                             is displayed instead.\n                             ''')\n    parser.add_argument('-p', '--port', default=6379,\n                        help='''the Redis server port. If the option is not specified, will\n                             be defaulted to 6379.\n                             ''')\n    parser.add_argument('-s', '--socket', default='',\n                        help='''the Redis server socket (usually /tmp/redis.sock). If it is\n                             given, it will override hostname and port. Make sure that the\n                             unixsocket parameter is defined in your redis.conf file. It\u2019s\n                             commented out by default.\n                             ''')\n    parser.add_argument('-n', '--db', default=0,\n                        help='''the Redis server database. If the option is not specified,\n                             will be defaulted to 0.\n                             ''')\n    parser.add_argument('-a', '--password', default='',\n                        help='''the Redis server password. If the option not specified,\n                             will be defaulted to an empty string.\n                             ''')\n\n    args = parser.parse_args()\n\n    # If no value is given after the option '-h', then the help information is displayed.\n    if args.hostname is None:\n        parser.print_help()\n        return 0\n\n    if args.socket:\n        print('The input Redis server socket is {}'.format(args.socket))\n        prompt = args.socket\n    else:\n        print('The input Redis server hostname is {}.'.format(args.hostname))\n        print('The input Redis server port is {}.'.format(args.port))\n        prompt = '{}:{}'.format(args.hostname, args.port)\n    print('The input Redis server database is {}.'.format(args.db))\n    if args.password != '':\n        print('The input Redis server password is \"{}\".'.format(args.password))\n    else:\n        print('The input Redis server password is empty.')\n\n    try:\n        if args.socket:\n            twis = pytwis.Pytwis(socket=args.socket,\n                                 db=args.db,\n                                 password=args.password)\n        else:\n            twis = pytwis.Pytwis(hostname=args.hostname,\n                                 port=args.port,\n                                 db=args.db,\n                                 password=args.password)\n        return twis, prompt\n\n    except ValueError as excep:\n        print('Failed to connect to the Redis server: {}'.format(str(excep)),\n              file=sys.stderr)\n        return None, None", "response": "Connect to the Redis database and return the Pytwis instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef synthesizeMember(memberName,\n                     default = None,\n                     contract = None,\n                     readOnly = False,\n                     getterName = None,\n                     setterName = None,\n                     privateMemberName = None):\n    \"\"\"\n    When applied to a class, this decorator adds getter/setter methods to it and overrides the constructor in order to set\\\n    the default value of the member.\n    By default, the getter will be named ``memberName``. (Ex.: ``memberName = 'member' => instance.member()``)\n    \n    By default, the setter will be named ``memberName`` with the first letter capitalized and 'set' prepended it to it.\n    (Ex.: ``memberName = \"member\" => instance.setMember(...)``)\n\n    By default, the private attribute containing the member's value will be named ``memberName`` with '_' prepended to it.\n\n    Naming convention can be overridden with a custom one using :meth:`namingConvention <namingConvention>` decorator.\n\n    :param memberName: Name of the member to synthesize.\n    :type memberName: str\n    :param default: Member's default value.\n    :type default: *\n    :param contract: Type constraint. See `PyContracts <http://andreacensi.github.com/contracts/>`_\n    :type contract: *\n    :param readOnly: If set to ``True``, the setter will not be added to the class.\n    :type readOnly: bool\n    :param getterName: Custom getter name. This can be useful when the member is a boolean. (Ex.: ``isAlive``)\n    :type getterName: str|None\n    :param setterName: Custom setter name.\n    :type setterName: str|None\n    :param privateMemberName: Custom name for the private attribute that contains the member's value.\n    :type privateMemberName: str|None\n    \n    :raises: :class:`DuplicateMemberNameError` when two synthetic members have the same name.\n\"\"\"\n    accessorDelegate = AccessorDelegate(namingConvention = NamingConventionCamelCase(),\n                                        getterName = getterName,\n                                        setterName = setterName)\n    return SyntheticDecoratorFactory().syntheticMemberDecorator(memberName = memberName,\n                                                                defaultValue = default,\n                                                                contract = contract,\n                                                                readOnly = readOnly,\n                                                                privateMemberName = privateMemberName,\n                                                                memberDelegate = accessorDelegate)", "response": "Synthesizes a member in a synthetic language."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsynthesizing a member of a base class.", "response": "def synthesize_member(member_name,\n                      default = None,\n                      contract = None,\n                      read_only = False,\n                      getter_name = None,\n                      setter_name = None,\n                      private_member_name = None):\n    \"\"\"\n    When applied to a class, this decorator adds getter/setter methods to it and overrides the constructor in order to set\\\n    the default value of the member.\n    By default, the getter will be named ``member_name``. (Ex.: ``member_name = 'member' => instance.member()``)\n    \n    By default, the setter will be named ``member_name`` with 'set\\_' prepended it to it.\n    (Ex.: ``member_name = 'member' => instance.set_member(...)``)\n\n    By default, the private attribute containing the member's value will be named ``member_name`` with '_' prepended to it.\n\n    Naming convention can be overridden with a custom one using :meth:`naming_convention <naming_convention>` decorator.\n\n    :param member_name: Name of the member to synthesize.\n    :type member_name: str\n    :param default: Member's default value.\n    :type default: *\n    :param contract: Type constraint. See `PyContracts <http://andreacensi.github.com/contracts/>`_\n    :type contract: *\n    :param read_only: If set to ``True``, the setter will not be added to the class.\n    :type read_only: bool\n    :param getter_name: Custom getter name. This can be useful when the member is a boolean. (Ex.: ``is_alive``)\n    :type getter_name: str|None\n    :param setter_name: Custom setter name.\n    :type setter_name: str|None\n    :param private_member_name: Custom name for the private attribute that contains the member's value.\n    :type private_member_name: str|None\n    \n    :raises: :class:`DuplicateMemberNameError` when two synthetic members have the same name.\n\"\"\"\n    accessorDelegate = AccessorDelegate(namingConvention = NamingConventionUnderscore(),\n                                       getterName = getter_name,\n                                       setterName = setter_name)\n    return SyntheticDecoratorFactory().syntheticMemberDecorator(memberName = member_name,\n                                                                defaultValue = default,\n                                                                contract = contract,\n                                                                readOnly = read_only,\n                                                                privateMemberName = private_member_name,\n                                                                memberDelegate = accessorDelegate)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a fully named module - global object.", "response": "def named_function(name):\n    \"\"\"Gets a fully named module-global object.\"\"\"\n    name_parts = name.split('.')\n    module = named_object('.'.join(name_parts[:-1]))\n    func = getattr(module, name_parts[-1])\n    if hasattr(func, 'original_func'):\n        func = func.original_func\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a module given its name.", "response": "def named_module(name):\n    \"\"\"Returns a module given its name.\"\"\"\n    module = __import__(name)\n    packages = name.split(\".\")[1:]\n    m = module\n    for p in packages:\n        m = getattr(m, p)\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a fully named module - global object.", "response": "def named_object(name):\n    \"\"\"Gets a fully named module-global object.\"\"\"\n    name_parts = name.split('.')\n    module = named_module('.'.join(name_parts[:-1]))\n    return getattr(module, name_parts[-1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_():  # pylint: disable=redefined-builtin\n    load_dbenv_if_not_loaded(\n    )  # Important to load the dbenv in the last moment\n\n    from aiida.orm.querybuilder import QueryBuilder\n    from aiida.orm import DataFactory\n    MultiplyParameters = DataFactory('phtools.factors')\n\n    qb = QueryBuilder()\n    qb.append(MultiplyParameters)\n    results = qb.all()\n\n    s = \"\"\n    for result in results:\n        obj = result[0]\n        s += \"{}, pk: {}\\n\".format(str(obj), obj.pk)\n    sys.stdout.write(s)", "response": "Display all MultiplyParameters nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexports a MultiplyParameters node identified by pk to plain text", "response": "def export(outfile, pk):\n    \"\"\"Export a MultiplyParameters node, identified by PK, to plain text\"\"\"\n    load_dbenv_if_not_loaded(\n    )  # Important to load the dbenv in the last moment\n\n    from aiida.orm import load_node\n    node = load_node(pk)\n    string = str(node)\n\n    if outfile:\n        with open(outfile, 'w') as f:\n            f.write(string)\n    else:\n        click.echo(string)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery multiple objects. :param kwargs: The query parameters. The key is the filter parameter and the value is the value to search for. :return: The list of matching objects :raises: A `ValueError` if at least one of the supplied parameters is not in the list of allowed parameters.", "response": "def query(cls, **kwargs):\n        \"\"\"\n        Query multiple objects.\n\n        :param kwargs: The query parameters. The key is the filter parameter and the value is the value to search for.\n        :return: The list of matching objects\n        :raises: A `ValueError` if at least one of the supplied parameters is not in the list of allowed parameters.\n        \"\"\"\n        params = dict(cls._default_filters)\n\n        for key, value in kwargs.items():\n            if key in cls._filter_parameters:\n                if isinstance(value, datetime):\n                    params[key] = value.strftime('%Y-%m-%dT%H:%M:%S+00:00')\n                else:\n                    params[key] = value\n            else:\n                raise ValueError('\\'{}\\' is not a filter parameter for class \\'{}\\''.format(key, cls.__name__))\n\n        return cls._get_iter_from_url('{}/'.format(cls._endpoint), params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_psd():\n    # psd has freq resolution = 1/3 with 6145 samples\n    psd = np.loadtxt(\"ZERO_DET_high_P_PSD.txt\")[:,1]\n    down_factor = 3\n    pad_size = int(np.ceil(float(psd.size)/down_factor)*down_factor - psd.size)\n    psd_padded = np.append(psd, np.zeros(pad_size)*np.NaN)\n    psd = sp.nanmean(psd_padded.reshape(-1,down_factor), axis=1)\n    # now dF = 1\n    # length of psd = 2048\n    return psd", "response": "Resamples advLIGO noise PSD to 4096 Hz"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resample_waveforms(Y_dict):\n    # right now, Y_dict, using my ccsnmultivar github waveform sets\n    for key in Y_dict.keys():\n        Y_dict[key] = signal.decimate(Y_dict[key], 4, ftype='fir')\n    metadata = {}\n    metadata[\"fs\"] = 4096. # in Hz\n    metadata[\"T\"] = 1. # in seconds\n    metadata[\"source distance\"] = 10. # in kpc\n    return Y_dict, metadata", "response": "This function resamples the waveforms in the dictionary Y_dict by resampling the waveforms in the timeseries indexed by name \nY_dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the waveform list from a CSV file.", "response": "def load_waveforms_from_file(path_to_waveforms):\n    \"\"\"\n     Waveforms must be:\n    - in a .csv or .dat file\n    - each row is a waveform, values comma separated\n    - each waveform is preprocessed\n        -- aligned to core bounce\n        -- all have same sampling frequencies\n        -- all have same number of time samples\n    - the name of the waveform is the first column\n    - subsequent columns are the waveform time samples\n    \"\"\"\n    wave_list = list(csv.reader(open(path_to_waveforms,\"rb\")))\n    # delete empty elements (if any)\n    wave_list = [x for x in wave_list if x != []]\n    Y_dict = {}\n    for i in np.arange(0,len(wave_list)):\n        Y_dict[wave_list[i][0]] = map(np.float, wave_list[i][1:])\n    return Y_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fourier(self):\n\n        freq_bin_upper = 2000\n        freq_bin_lower = 40\n        fs = self._metadata['fs']\n        Y_transformed = {}\n        for key in self.Y_dict.keys():\n            # normalize by fs, bins have units strain/Hz\n            fs = self._metadata[\"fs\"]\n            Y_transformed[key] = (1./fs)*np.fft.fft(self.Y_dict[key])[freq_bin_lower:freq_bin_upper]\n        self.Y_transformed = Y_transformed\n        # add in transform metadata\n        self._metadata[\"dF\"] = 1./self._metadata[\"T\"]\n\n        # because we are in the fourier domain, we will need the psd\n        self.psd = load_psd()[freq_bin_lower:freq_bin_upper]\n        dF = self._metadata['dF']\n        self.sigma = convert_psd_to_sigma(self.psd, dF)", "response": "1 side Fourier transform and scale by dt all waveforms in catalog"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dict with number of people in space and their name and craftical ID.", "response": "def people_in_space(self):\n        \"\"\"Number of people in space.\n        Be aware that does not mean these people are inside the ISS (it does\n        most of the time), They can be travelling to and from the station.\n\n        :return: Return a dict with number of people in space right now and\n        their name and their craft\n        :rtype: dict\n        \"\"\"\n        data = requests.get('{}{}'.format(self.API_URL, self.API_PEOPLE),\n                            timeout=5)\n\n        if data.status_code is 200:\n            return data.json()\n        else:\n            raise Exception(\"Error server n {}\".format(data.status_code))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the current location of the ISS.", "response": "def current_location(self):\n        \"\"\"Current location of the ISS.\n\n        :return: A dict with latitude and longitude of ISS\n        :rtype: dict\n        \"\"\"\n        data = requests.get('{}{}'.format(\n            self.API_URL, self.API_CURRENT_LOCATION), timeout=5)\n\n        if data.status_code is 200:\n            return data.json()['iss_position']\n        else:\n            raise Exception(\"Error server n {}\".format(data.status_code))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pass_times(self, latitude, longitude, altitude=None, number=None):\n        # Check input\n        schema = Schema({\n            Required('lat'): All(Any(int, float), Range(min=-80, max=80)),\n            Required('long'): All(Any(int, float), Range(min=-180, max=180)),\n            'alt': Any(None, All(Any(int, float), Range(min=0, max=10000))),\n            'number': Any(None, All(int, Range(min=1, max=100)))\n        })\n        schema({\n            'lat' : latitude, 'long': longitude, 'alt' : altitude,\n            'number': number})\n\n        # Build request\n        payload = {'lat': latitude, 'lon': longitude}\n\n        if altitude is not None:\n            payload['alt'] = altitude\n\n        if number is not None:\n            payload['n'] = number\n\n        data = requests.get('{}{}'.format(self.API_URL, self.API_PASS_TIMES),\n                            params=payload, timeout=5)\n\n        # Check error\n        if data.status_code is 200:\n            return data.json()['response']\n        else:\n            raise Exception(\"Error server n {}\".format(data.status_code))", "response": "Returns a list of next pass times of the ISS."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next_rise(self, latitude, longitude, altitude=None):\n        rise = self.pass_times(latitude, longitude, altitude,\n                               2)\n        timestamp = rise[0]['risetime']\n\n        return datetime.fromtimestamp(timestamp)", "response": "Returns the next rise of the ISS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_ISS_above(self, latitude, longitude, altitude=None):\n        test = self.pass_times(latitude, longitude, altitude, 2)\n        # 2 results where asked so if API return only 1, that mean ISS is\n        # above the location\n        return len(test) is 1", "response": "Returns True if the ISS is above the current location False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the stdout of the ioloop", "response": "def _handle_stdout(self, ioloop, f, count=-1):\n        \"\"\" because anonymous pipes in windows can be blocked, we need to pay attention\n        on how much we read\n        \"\"\"\n        output = non_blocking_read(self._popen.stdout, count)\n        if not output:\n            self._popen.stdout.close()\n            self._popen.stdout = None\n        else:\n            self._output.write(output)\n            self._register_stdout(ioloop)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_stderr(self, ioloop, f, count=-1):\n        output = non_blocking_read(self._popen.stderr, count)\n        if not output:\n            self._popen.stderr.close()\n            self._popen.stderr = None\n        else:\n            self._error.write(output)\n            self._register_stderr(ioloop)", "response": "handle stderr from the server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef grandparent_path(self):\n        return os.path.basename(os.path.join(self.path, '../..'))", "response": "return grandparent s path string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef n_parent_paths(self, n):\n        rv = os.path.relpath(os.path.join(self.path, '..'), os.path.join(self.path, *['..'] * (n+1)))\n        return rv.replace('\\\\', '/')", "response": "return the parent paths of n levels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef n_relative_paths(self, n):\n        rv = os.path.join(self.n_parent_paths(n-1), self.basename)\n        return rv.replace('\\\\', '/')", "response": "Return relative paths of n levels including basename."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove blank dir and all blank subdirectories", "response": "def remove_blank_dirs(self):\n        \"\"\"Remove blank dir and all blank subdirectories\"\"\"\n        if self.is_blank():\n            try:\n                os.rmdir(self.path)\n            except OSError as e:\n                print(e)\n        else:\n            remove_empty_dir(self.path)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_allproductandrelease(self):\n        logger.info(\"Get all ProductAndReleases\")\n        response = self.get(PRODUCTANDRELEASE_RESOURCE_ROOT_URI, headers=self.headers)\n        sr_response = response_body_to_dict(response, self.headers[HEADER_CONTENT_TYPE],\n                                          xml_root_element_name=PRODUCTANDRELEASE_BODY_ROOT)\n        return sr_response, response", "response": "Get All ProductAndReleases from SDC Catalog as a dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef arr_normalize(arr, *args, **kwargs):\n    f_max = arr.max()\n    f_min = arr.min()\n    f_range = f_max - f_min\n    arr_shifted = arr + -f_min\n    arr_norm = arr_shifted / f_range\n    for key, value in kwargs.items():\n        if key == 'scale': arr_norm *= value\n    return arr_norm", "response": "Normalizes an array to be a range of the max and min values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command on the underlying shell and keeps the stdout and stderr stream separate.", "response": "def shell(command, **kwargs):\n    \"\"\"\n        Runs 'command' on the underlying shell and keeps the stdout and\n        stderr stream separate.\n\n        Returns [stdout, stderr, exitCode]\n    \"\"\"\n    b_stdoutflush       = False\n    b_stderrflush       = False\n    b_waitForChild      = True\n    for key, val in kwargs.items():\n        if key == 'stdoutflush':        b_stdoutflush   = val\n        if key == 'stderrflush':        b_stderrflush   = val\n        if key == 'waitForChild':       b_waitForChild  = val\n    child = popen2.Popen3(command, 1) # capture stdout and stderr from command\n    child.tochild.close()             # don't need to talk to child\n    outfile = child.fromchild\n    outfd = outfile.fileno()\n    errfile = child.childerr\n    errfd = errfile.fileno()\n    makeNonBlocking(outfd)            # don't deadlock!\n    makeNonBlocking(errfd)\n    outdata = errdata = ''\n    outeof = erreof = 0\n    while b_waitForChild:\n        ready = select.select([outfd,errfd],[],[]) # wait for input\n        if outfd in ready[0]:\n            outchunk = outfile.read()\n            if b_stdoutflush: sys.stdout.write(outchunk)\n            if outchunk == '': outeof = 1\n            outdata = outdata + outchunk\n        if errfd in ready[0]:\n            errchunk = errfile.read()\n            if b_stderrflush: sys.stderr.write(errchunk)\n            if errchunk == '': erreof = 1\n            errdata = errdata + errchunk\n        if outeof and erreof: break\n        select.select([],[],[],.1) # give a little time for buffers to fill\n    err = child.wait()\n    return outdata, errdata, err"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef touch(fname, times=None):\n    '''\n    Emulates the UNIX touch command.\n    '''\n    with io.open(fname, 'a'):\n        os.utime(fname, times)", "response": "Emulates the UNIX touch command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef file_writeOnce(astr_fileName, astr_val, **kwargs):\n    '''\n    Simple \"one-shot\" writer. Opens <astr_fileName>\n    and saves <astr_val> to file, then closes\n    file.\n    '''\n\n    _str_mode = 'w'\n    for key, val in kwargs.items():\n        if key == 'mode':   _str_mode   = val\n\n    FILE = open(astr_fileName, _str_mode)\n    FILE.write(astr_val)\n    FILE.close()", "response": "Simple one - shot writer. Opens astr_fileName and saves astr_val to file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_key(self, key, version=None):\n        return '{}:{}:{}'.format(\n            self.prefix,\n            version or self.version,\n            key,\n        )", "response": "Make a key for the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _only_safe_emails(self, emails):\n\n        email_modified = False\n        if any(not self._is_whitelisted(email) for email in emails):\n            email_modified = True\n            emails = [email for email in emails if self._is_whitelisted(email)]\n            if settings.SAFE_EMAIL_RECIPIENT not in emails:\n                emails.append(settings.SAFE_EMAIL_RECIPIENT)\n        return emails, email_modified", "response": "Given a list of emails checks whether they are all in the white\n        list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_whitelisted(self, email):\n\n        return hasattr(settings, \"SAFE_EMAIL_WHITELIST\") and \\\n            any(re.match(m, email) for m in settings.SAFE_EMAIL_WHITELIST)", "response": "Check if an email is in the whitelist."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_webhook(event, webhook, payload):\n    started_at = time()\n\n    request = _build_request_for_calling_webhook(event, webhook, payload)\n\n    logger.info('REQUEST %(uuid)s %(method)s %(url)s %(payload)s' % dict(\n        uuid=str(event['uuid']),\n        url=request['url'],\n        method=request['method'],\n        payload=payload,\n    ))\n\n    try:\n        content = dispatch_webhook_request(**request)\n\n        logger.debug('RESPONSE %(uuid)s %(method)s %(url)s %(data)s' % dict(\n            uuid=str(event['uuid']),\n            url=request['url'],\n            method=request['method'],\n            data=content,\n        ))\n\n        data = dict(\n            parent=str(event['uuid']),\n            content=content,\n            started_at=started_at,\n            ended_at=time()\n        )\n    except (FailureWebhookError, ConnectionError) as exception:\n        if sentry.client:\n            http_context = raven_context(**request)\n            sentry.captureException(data={'request': http_context})\n\n        logger.error('RESPONSE %(uuid)s %(method)s %(url)s %(error)s' % dict(\n            uuid=str(event['uuid']),\n            method=request['method'],\n            url=request['url'],\n            error=exception.message,))\n\n        data = dict(\n            parent=str(event['uuid']),\n            error=exception.message,\n            started_at=started_at,\n            ended_at=time(),\n        )\n\n    webhook_ran.send(None, data=data)\n\n    return data", "response": "Build request from event webhook payoad and parse response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_webhooks_runset(runset):\n    min_started_at = min([w['started_at'] for w in runset])\n    max_ended_at = max([w['ended_at'] for w in runset])\n    ellapse = max_ended_at - min_started_at\n    errors_count = sum(1 for w in runset if 'error' in w)\n    total_count = len(runset)\n\n    data = dict(\n        ellapse=ellapse,\n        errors_count=errors_count,\n        total_count=total_count,\n    )\n\n    return data", "response": "Make some statistics on the runset."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exec_event(event, webhooks, payload):\n    calls = (\n        call_webhook.s(event, webhook, payload)\n        for webhook in webhooks\n    )\n    callback = merge_webhooks_runset.s()\n\n    call_promise = chord(calls)\n    promise = call_promise(callback)\n    return promise", "response": "Execute the event and return a promise that resolves with the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload url and return it as utf - 8 encoded text.", "response": "def download(url):\n    \"\"\"\n    Download `url` and return it as utf-8 encoded text.\n\n    Args:\n        url (str): What should be downloaded?\n\n    Returns:\n        str: Content of the page.\n    \"\"\"\n    headers = {\"User-Agent\": USER_AGENT}\n    resp = requests.get(\n        url,\n        timeout=REQUEST_TIMEOUT,\n        headers=headers,\n        allow_redirects=True,\n        verify=False,\n    )\n\n    def decode(st, alt_encoding=None):\n        encodings = ['ascii', 'utf-8', 'iso-8859-1', 'iso-8859-15']\n\n        if alt_encoding:\n            if isinstance(alt_encoding, basestring):\n                encodings.append(alt_encoding)\n            else:\n                encodings.extend(alt_encoding)\n\n        for encoding in encodings:\n            try:\n                return st.encode(encoding).decode(\"utf-8\")\n            except UnicodeEncodeError, UnicodeDecodeError:\n                pass\n\n        raise UnicodeError('Could not find encoding.')\n\n    return decode(resp.text, resp.encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the state. descriptor with the new agent s incluster information.", "response": "def _update_descriptor(self, state, allocation):\n        '''Sometime creating the descriptor for new agent we cannot know in\n        which shard it will endup. If it is None or set to lobby, the HA\n        will update the field to match his own'''\n        if state.descriptor.shard is None or state.descriptor.shard == 'lobby':\n            own_shard = state.agent.get_shard_id()\n            state.descriptor.shard = own_shard\n        state.descriptor.resources = allocation.alloc\n        f = fiber.succeed(state.descriptor)\n        f.add_callback(state.agent.save_document)\n        f.add_callback(self._store_descriptor)\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fail_tmp(item, max_tries=None, ttl=None):\n    '''Try to fail a work-item temporarily (up recount and keep in queue),\n       if max tries or ttl is exhausted, escalate to permanant failure.'''\n    try:\n        max_tries = item.max_tries if max_tries is None else max_tries\n        ttl = item.ttl if ttl is None else ttl\n\n        # see if we need to fail perm\n        check_ttl_max_tries(item.tries+1, item.enqueued_at, max_tries, ttl)\n        # mv to same plus 1\n        item.tries += 1\n        new_name = construct(( fmt_time(item.enqueued_at, _c.FSQ_TIMEFMT,\n                               _c.FSQ_CHARSET), item.entropy,\n                               item.pid, item.hostname,\n                               item.tries, ) + tuple(item.arguments))\n        os.rename(fsq_path.item(item.queue, item.id, host=item.host),\n\t\t\t\t  fsq_path.item(item.queue, new_name, host=item.host))\n        return new_name\n    except (FSQMaxTriesError, FSQTTLExpiredError, FSQEnqueueError, ), e:\n        fail_perm(item)\n        e.strerror = u': '.join([\n            e.strerror,\n            u'for item {0}; failed permanently'.format(item.id),\n        ])\n        raise e", "response": "Try to fail a work - item temporarily ( up recount and keep in queue and escalate to permanant failure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fail_perm(item):\n    '''Fail a work-item permanatly by mv'ing it to queue's fail directory'''\n    # The only thing we require to fail is an item_id and a queue\n    # as an item may fail permanently due to malformed item_id-ness\n    item_id = item.id\n    trg_queue = item.queue\n    host = item.host\n    try:\n        os.rename(fsq_path.item(trg_queue, item_id, host=host),\n                  os.path.join(fsq_path.fail(trg_queue, host=host), item_id))\n    except (OSError, IOError, ), e:\n        raise FSQFailError(e.errno, u'cannot mv item to fail: {0}:'\\\n                           u' {1}'.format(item.id, wrap_io_os_err(e)))\n\n    return item.id", "response": "Fail a work - item permanatly by mving it to queue s fail directory"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap for any type of finish successful permanant failure or temporary failure", "response": "def done(item, done_type=None, max_tries=None, ttl=None):\n    '''Wrapper for any type of finish, successful, permanant failure or\n       temporary failure'''\n    if done_type is None or done_type == _c.FSQ_SUCCESS:\n        return success(item)\n    return fail(item, fail_type=done_type, max_tries=max_tries, ttl=ttl)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfailing a work item either temporarily or permanently", "response": "def fail(item, fail_type=None, max_tries=None, ttl=None):\n    '''Fail a work item, either temporarily or permanently'''\n    # default to fail_perm\n    if fail_type is not None and fail_type == _c.FSQ_FAIL_TMP:\n        return fail_tmp(item, max_tries=max_tries, ttl=ttl)\n    return fail_perm(item)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a request to self. url authenticated with self. auth", "response": "def send(self, request):\n        '''send a request to self.url authenticated with self.auth'''\n        return self.session.send(request(self.url, self.auth))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register(provider_factory, *args, **kwargs):\n    def decorator(target):\n        def callback(scanner, name, target):\n            if not args:\n                specification = target\n            elif len(args) == 1:\n                specification = args[0]\n            else:\n                specification = tuple(args)\n            scanner.callback(\n                specification,\n                provider_factory(target, **kwargs)\n            )\n        venusian.attach(target, callback, category=WIRING_VENUSIAN_CATEGORY)\n        return target\n    return decorator", "response": "Decorator that registers a provider factory for scanning the sequence of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eps_from_series(self):\n    csvs = []\n    for _, _, filenames in os.walk('./{}'.format(self.directory)):\n      csvs.extend(filenames)\n\n    series_set = set()\n    for c in csvs:\n      file_name = './{}/{}'.format(self.directory, c)\n      reader = csv.DictReader(open(file_name, 'rb'))\n      for line in reader:\n        series_set.add(Series.from_line(line))\n\n    series = [s for s in series_set]\n    series_q = Queue(len(series))\n    for s in series:\n      series_q.put(s)\n\n    for _ in xrange(0, self.num_threads):\n      t = EpisodeWorker(self.storer, series_q)\n      t.daemon = True\n      t.start()\n\n    series_q.join()", "response": "This function handles grabbing series data from csvs and requesting episodal information from RSS feeds\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef notify(self, state, notifications):\n        '''\n        Call this to schedule sending partner notification.\n        '''\n\n        def do_append(desc, notifications):\n            for notification in notifications:\n                if not isinstance(notification, PendingNotification):\n                    raise ValueError(\"Expected notify() params to be a list \"\n                                     \"of PendingNotification instance, got %r.\"\n                                     % notification)\n                key = str(notification.recipient.key)\n                if key not in desc.pending_notifications:\n                    desc.pending_notifications[key] = list()\n                desc.pending_notifications[key].append(notification)\n\n        return state.agent.update_descriptor(do_append, notifications)", "response": "Add a list of pending notifications to the pending_notifications dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef turn(self):\n        first = self._data.pop(0)\n        self._data.append(first)", "response": "Turn the ring for a single position."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(MapRequestMessage, self).sanitize()\n\n        # A: This is an authoritative bit, which is set to 0 for UDP-based Map-\n        # Requests sent by an ITR.  Set to 1 when an ITR wants the\n        # destination site to return the Map-Reply rather than the mapping\n        # database system.\n        if not isinstance(self.authoritative, bool):\n            raise ValueError('Authoritative flag must be a boolean')\n\n        # M: This is the map-data-present bit, when set, it indicates a Map-\n        # Reply Record segment is included in the Map-Request.\n        # Checked below\n\n        # P: This is the probe-bit which indicates that a Map-Request SHOULD be\n        # treated as a locator reachability probe.  The receiver SHOULD\n        # respond with a Map-Reply with the probe-bit set, indicating the\n        # Map-Reply is a locator reachability probe reply, with the nonce\n        # copied from the Map-Request.  See Section 6.3.2 for more details.\n        if not isinstance(self.probe, bool):\n            raise ValueError('Probe flag must be a boolean')\n\n        # S: This is the Solicit-Map-Request (SMR) bit.  See Section 6.6.2 for\n        # details.\n        if not isinstance(self.smr, bool):\n            raise ValueError('SMR flag must be a boolean')\n\n        # p: This is the PITR bit.  This bit is set to 1 when a PITR sends a\n        # Map-Request.\n        if not isinstance(self.pitr, bool):\n            raise ValueError('PITR flag must be a boolean')\n\n        # s: This is the SMR-invoked bit.  This bit is set to 1 when an xTR is\n        # sending a Map-Request in response to a received SMR-based Map-\n        # Request.\n        if not isinstance(self.smr_invoked, bool):\n            raise ValueError('SMR-invoked flag must be a boolean')\n\n        # IRC:  This 5-bit field is the ITR-RLOC Count which encodes the\n        # additional number of (ITR-RLOC-AFI, ITR-RLOC Address) fields\n        # present in this message.  At least one (ITR-RLOC-AFI, ITR-RLOC-\n        # Address) pair MUST be encoded.  Multiple ITR-RLOC Address fields\n        # are used so a Map-Replier can select which destination address to\n        # use for a Map-Reply.  The IRC value ranges from 0 to 31.  For a\n        # value of 0, there is 1 ITR-RLOC address encoded, and for a value\n        # of 1, there are 2 ITR-RLOC addresses encoded and so on up to 31\n        # which encodes a total of 32 ITR-RLOC addresses.\n        if len(self.itr_rlocs) < 1 or len(self.itr_rlocs) > 32:\n            raise ValueError('Number of ITR RLOCs must be between 1 and 32')\n\n        # Record Count:  The number of records in this Map-Request message.  A\n        # record is comprised of the portion of the packet that is labeled\n        # 'Rec' above and occurs the number of times equal to Record Count.\n        # For this version of the protocol, a receiver MUST accept and\n        # process Map-Requests that contain one or more records, but a\n        # sender MUST only send Map-Requests containing one record.  Support\n        # for requesting multiple EIDs in a single Map-Request message will\n        # be specified in a future version of the protocol.\n        if len(self.eid_prefixes) < 1 or len(self.eid_prefixes) > 32:\n            raise ValueError('Number of EID prefix records must be between ' +\n                             '1 and 255')\n\n        # Nonce: An 8-octet random value created by the sender of the Map-\n        # Request.  This nonce will be returned in the Map-Reply.  The\n        # security of the LISP mapping protocol depends critically on the\n        # strength of the nonce in the Map-Request message.  The nonce\n        # SHOULD be generated by a properly seeded pseudo-random (or strong\n        # random) source.  See [RFC4086] for advice on generating security-\n        # sensitive random data.\n        if len(bytes(self.nonce)) != 8:\n            raise ValueError('Invalid nonce')\n\n        # Source EID Address:  This is the EID of the source host which\n        # originated the packet which is caused the Map-Request.  When Map-\n        # Requests are used for refreshing a map-cache entry or for RLOC-\n        # probing, an AFI value 0 is used and this field is of zero length.\n        if self.source_eid is not None:\n            # Extract the address(es)\n            if isinstance(self.source_eid, LCAFAddress):\n                addresses = self.source_eid.get_addresses()\n            else:\n                addresses = [self.source_eid]\n\n            # We must have exactly one address\n            if len(addresses) != 1:\n                raise ValueError('Source EID must be one address')\n\n            if not isinstance(addresses[0], (IPv4Address, IPv6Address)):\n                raise ValueError('Invalid source EID: %r' % self.source_eid)\n\n        # ITR-RLOC Address:  Used to give the ETR the option of selecting the\n        # destination address from any address family for the Map-Reply\n        # message.  This address MUST be a routable RLOC address of the\n        # sender of the Map-Request message.\n        for itr_rloc in self.itr_rlocs:\n            if not isinstance(itr_rloc, (IPv4Address, IPv6Address)):\n                raise ValueError('Invalid ITR RLOC')\n\n        # EID-prefix:  4 octets if an IPv4 address-family, 16 octets if an IPv6\n        # address-family.  When a Map-Request is sent by an ITR because a\n        # data packet is received for a destination where there is no\n        # mapping entry, the EID-prefix is set to the destination IP address\n        # of the data packet.  And the 'EID mask-len' is set to 32 or 128\n        # for IPv4 or IPv6, respectively.  When an xTR wants to query a site\n        # about the status of a mapping it already has cached, the EID-\n        # prefix used in the Map-Request has the same mask-length as the\n        # EID-prefix returned from the site when it sent a Map-Reply\n        # message.\n        for eid_prefix in self.eid_prefixes:\n            # Extract the address(es)\n            if isinstance(eid_prefix, LCAFAddress):\n                addresses = eid_prefix.get_addresses()\n            else:\n                addresses = [eid_prefix]\n\n            for address in addresses:\n                if not isinstance(address, (IPv4Network, IPv4Address,\n                                            IPv6Network, IPv6Address)):\n                    raise ValueError('Invalid EID prefix: %r' % address)\n\n        # Map-Reply Record:  When the M bit is set, this field is the size of a\n        # single \"Record\" in the Map-Reply format.  This Map-Reply record\n        # contains the EID-to-RLOC mapping entry associated with the Source\n        # EID.  This allows the ETR which will receive this Map-Request to\n        # cache the data if it chooses to do so.\n        if self.map_reply is not None:\n            if not isinstance(self.map_reply, MapReplyRecord):\n                raise ValueError('Invalid Map-Reply')\n\n            self.map_reply.sanitize()", "response": "Sanitize the current settings and return the new value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef strptime(cls, string, format):\n        return cls.from_time_struct(time.strptime(string, format))", "response": "Constructs a : class:`mw. Timestamp from an explicitly formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a : class:`mw. Timestamp` from a time. time_struct.", "response": "def from_time_struct(cls, time_struct):\n        \"\"\"\n        Constructs a :class:`mw.Timestamp` from a :class:`time.time_struct`.\n\n        :Parameters:\n            time_struct : :class:`time.time_struct`\n                A time structure\n\n        :Returns:\n            :class:`mw.Timestamp`\n        \"\"\"\n        instance = super().__new__(cls, time_struct)\n        instance.initialize(time_struct)\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a : class : mw. Timestamp from a unix timestamp.", "response": "def from_unix(cls, seconds):\n        \"\"\"\n        Constructs a :class:`mw.Timestamp` from a unix timestamp (in seconds\n        since Jan. 1st, 1970 UTC).\n\n        :Parameters:\n            seconds : int\n                A unix timestamp\n\n        :Returns:\n            :class:`mw.Timestamp`\n        \"\"\"\n        time_struct = datetime.datetime.utcfromtimestamp(seconds).timetuple()\n        return cls.from_time_struct(time_struct)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a : class : mw. Timestamp object from a MediaWiki formatted string.", "response": "def from_string(cls, string):\n        \"\"\"\n        Constructs a :class:`mw.Timestamp` from a MediaWiki formatted string.\n        This method is provides a convenient way to construct from common\n        MediaWiki timestamp formats. E.g., ``%Y%m%d%H%M%S`` and\n        ``%Y-%m-%dT%H:%M:%SZ``.\n\n        :Parameters:\n            string : str\n                A formatted timestamp\n\n        :Returns:\n            :class:`mw.Timestamp`\n        \"\"\"\n        if type(string) == bytes:\n            string = str(string, 'utf8')\n        else:\n            string = str(string)\n\n        try:\n            return cls.strptime(string, SHORT_MW_TIME_STRING)\n        except ValueError as e:\n            try:\n                return cls.strptime(string, LONG_MW_TIME_STRING)\n            except ValueError as e:\n                raise ValueError(\n                    \"{0} is not a valid Wikipedia date format\".format(\n                        repr(string)\n                    )\n                )\n\n        return cls.from_time_struct(time_struct)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef usage(asked_for=0):\n    '''Exit with a usage string, used for bad argument or with -h'''\n    exit =  fsq.const('FSQ_SUCCESS') if asked_for else\\\n                fsq.const('FSQ_FAIL_PERM')\n    f = sys.stdout if asked_for else sys.stderr\n    shout('{0} [opts] src_queue trg_queue host item_id [item_id [...]]'.format(\n          os.path.basename(_PROG)), f)\n    if asked_for:\n        shout('{0} [-p|--protocol=jsonrpc] [-L|--no-lock] [-t|--trigger] '\\\n              '[-i|--ignore-listener] <proto>://<host>:<port>/url'\\\n              .format(os.path.basename(_PROG)), f)\n        shout('{0} [-p|--protocol=jsonrpc] [-L|--no-lock] [-t|--trigger]'\\\n              '[-i|--ignore-listener] unix://var/sock/foo.sock'\\\n              .format(os.path.basename(_PROG)), f)\n        shout('        src_queue trg_queue host_queue item [item [...]]', f)\n    return exit", "response": "Exit with a usage string used for bad argument or with - h"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_software_renderer(self, surface):\n        renderer = object.__new__(Renderer)\n        renderer._ptr = self._ptr = check_ptr_err(lib.SDL_CreateSoftwareRenderer(surface._ptr))\n        return renderer", "response": "Create a 2D software rendering context for a surface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef texture_formats(self):\n        info = self._get_renderer_info()\n        return {PixelFormat(info.texture_formats[i]) for i in range(info.num_texture_formats)}", "response": "Returns a set of available texture formats."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the color used for drawing operations in ( red green blue alpha ) format.", "response": "def draw_color(self):\n        \"\"\"Tuple[int, int, int, int]: The color used for drawing operations in (red, green, blue, alpha) format.\"\"\"\n        rgba = ffi.new('Uint8[]', 4)\n        check_int_err(lib.SDL_GetRenderDrawColor(self._ptr, rgba + 0, rgba + 1, rgba + 2, rgba + 3))\n        return (rgba[0], rgba[1], rgba[2], rgba[3])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef viewport(self):\n        viewport = rect.Rect(0, 0, 0, 0)\n        check_int_err(lib.SDL_RenderGetViewport(self._ptr, viewport._ptr))\n        return viewport", "response": "Rect: The drawing area for rendering on the current target."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render_target(self):\n        render_target = lib.SDL_GetRenderTarget(self._ptr)\n        if render_target == ffi.NULL:\n            return None\n        else:\n            return Texture._from_ptr(render_target)", "response": "Texture: The current render target or None if using the default render target."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blend_mode(self):\n        blend_mode_ptr = ffi.new('int *')\n        check_int_err(lib.SDL_GetRenderDrawBlendMode(self._ptr, blend_mode_ptr))\n        return BlendMode(blend_mode_ptr[0])", "response": "Returns the blend mode used for drawing operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_line(self, x1, y1, x2, y2):\n        check_int_err(lib.SDL_RenderDrawLine(self._ptr, x1, y1, x2, y2))", "response": "Draw a line on the current rendering target."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_lines(self, *points):\n        point_array = ffi.new('SDL_Point[]', len(points))\n        for i, p in enumerate(points):\n            point_array[i] = p._ptr[0]\n        check_int_err(lib.SDL_RenderDrawLines(self._ptr, point_array, len(points)))", "response": "Draw a series of connected lines on the current rendering target."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndrawing a point on the current rendering target.", "response": "def draw_point(self, x, y):\n        \"\"\"Draw a point on the current rendering target.\n\n        Args:\n            x (int): The x coordinate of the point.\n            y (int): The y coordinate of the point.\n\n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        check_int_err(lib.SDL_RenderDrawPoint(self._ptr, x, y))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw_points(self, *points):\n        point_array = ffi.new('SDL_Point[]', len(points))\n        for i, p in enumerate(points):\n            point_array[i] = p._ptr[0]\n        check_int_err(lib.SDL_RenderDrawPoints(self._ptr, point_array, len(points)))", "response": "Draw multiple points on the current rendering target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw a rectangle on the current rendering target.", "response": "def draw_rect(self, rect):\n        \"\"\"Draw a rectangle on the current rendering target.\n\n        Args:\n            rect (Rect): The destination rectangle, or None to outline the entire rendering target.\n\n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        check_int_err(lib.SDL_RenderDrawRect(self._ptr, rect._ptr))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws some number of rectangles on the current rendering target.", "response": "def draw_rects(self, *rects):\n        \"\"\"Draw some number of rectangles on the current rendering target.\n\n        Args:\n            *rects (Rect): The destination rectangles.\n\n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        rect_array = ffi.new('SDL_Rect[]', len(rects))\n        for i, r in enumerate(rects):\n            rect_array[i] = r._ptr[0]\n        check_int_err(lib.SDL_RenderDrawRects(self._ptr, rect_array, len(rects)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fill_rect(self, rect):\n        check_int_err(lib.SDL_RenderFillRect(self._ptr, rect._ptr))", "response": "Fill a rectangle on the current rendering target with the drawing color."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fill_rects(self, *rects):\n        rect_array = ffi.new('SDL_Rect[]', len(rects))\n        for i, r in enumerate(rects):\n            rect_array[i] = r._ptr[0]\n        check_int_err(lib.SDL_RenderFillRects(self._ptr, rect_array, len(rects)))", "response": "Fill some number of rectangles on the current rendering target with the drawing color."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, texture, source_rect=None, dest_rect=None, rotation=0, center=None, flip=lib.SDL_FLIP_NONE):\n        if source_rect == None:\n            source_rect_ptr = ffi.NULL\n        else:\n            source_rect_ptr = source_rect._ptr\n            \n        if dest_rect == None:\n            dest_rect_ptr = ffi.NULL\n        else:\n            dest_rect_ptr = dest_rect._ptr\n\n        if center == None:\n            center_ptr = ffi.NULL\n        else:\n            center_ptr = center._ptr\n            \n        check_int_err(lib.SDL_RenderCopyEx(self._ptr, texture._ptr, source_rect_ptr, dest_rect_ptr, rotation, center_ptr, flip))", "response": "Copy a portion of the source texture to the current rendering target."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a texture from an existing surface.", "response": "def from_surface(renderer, surface):\n        \"\"\"Create a texture from an existing surface.\n\n        Args:\n            surface (Surface): The surface containing pixel data used to fill the texture.\n\n        Returns:\n            Texture: A texture containing the pixels from surface.\n\n        Raises:\n            SDLError: If an error is encountered.\n        \"\"\"\n        texture = object.__new__(Texture)\n        texture._ptr = check_ptr_err(lib.SDL_CreateTextureFromSurface(renderer._ptr, surface._ptr))\n        return texture"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the format of the texture.", "response": "def format(self):\n        \"\"\"PixelFormat: The raw format of the texture. The actual format may differ, but pixel transfers will use this\n                        format.\n        \"\"\"\n        fmt = ffi.new('Uint32 *')\n        check_int_err(lib.SDL_QueryTexture(self._ptr, fmt, ffi.NULL, ffi.NULL, ffi.NULL))\n        return PixelFormat(fmt[0])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the actual access to the texture.", "response": "def access(self):\n        \"\"\"TextureAccess: The actual access to the texture.\"\"\"\n        access = ffi.new('int *')\n        check_int_err(lib.SDL_QueryTexture(self._ptr, ffi.NULL, access, ffi.NULL, ffi.NULL))\n        return TextureAccess(access[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef w(self):\n        w = ffi.new('int *')\n        check_int_err(lib.SDL_QueryTexture(self._ptr, ffi.NULL, ffi.NULL, w, ffi.NULL))\n        return w[0]", "response": "int: The width of the texture in pixels."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef h(self):\n        h = ffi.new('int *')\n        check_int_err(lib.SDL_QueryTexture(self._ptr, ffi.NULL, ffi.NULL, ffi.NULL, h))\n        return h[0]", "response": "int : The height of the texture in pixels."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the additional color value used in render copy operations in ( red green blue ).", "response": "def color_mod(self):\n        \"\"\"Tuple[int, int, int]: The additional color value used in render copy operations in (red, green, blue)\n                                 format.\n        \"\"\"\n        rgb = ffi.new('Uint8[]', 3)\n        check_int_err(lib.SDL_GetTextureColorMod(self._ptr, rgb + 0, rgb + 1, rgb + 2))\n        return (rgb[0], rgb[1], rgb[2])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the additional alpha value used in render copy operations.", "response": "def alpha_mod(self):\n        \"\"\"int: The additional alpha value used in render copy operations.\"\"\"\n        a = ffi.new('Uint8 *')\n        check_int_err(lib.SDL_GetTextureAlphaMod(self._ptr, a))\n        return a[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blend_mode(self):\n        blend_mode_ptr = ffi.new('int *')\n        lib.SDL_GetTextureBlendMode(self._ptr, blend_mode_ptr)\n        return BlendMode(blend_mode_ptr[0])", "response": "Returns the blend mode used for drawing operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_author_tags(index_page):\n    dom = dhtmlparser.parseString(index_page)\n\n    authors = [\n        get_html_authors(dom),\n        get_dc_authors(dom),\n    ]\n\n    return sum(authors, [])", "response": "Parse authors from HTML meta and dublin core."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(argv=None):\n    args = docopt(__doc__, version=pycdstar.__version__, argv=argv, options_first=True)\n    subargs = [args['<command>']] + args['<args>']\n\n    if args['<command>'] in ['help', None]:\n        cmd = None\n        if len(subargs) > 1:\n            cmd = COMMANDS.get(subargs[1])\n        if cmd:\n            print(cmd.__doc__)\n        else:\n            print(__doc__)\n        return 0\n\n    cmd = COMMANDS.get(args['<command>'])\n    if not cmd:\n        print('unknown command')\n        print(__doc__)\n        return 0\n\n    cfg = Config(**dict(\n        cfg=args.pop('--cfg', None),\n        url=args.pop('--service', None),\n        user=args.pop('--user', None),\n        password=args.pop('--password', None)))\n\n    try:\n        res = cmd(\n            Cdstar(cfg=cfg),\n            docopt(cmd.__doc__, argv=subargs),\n            verbose=args.get('--verbose'))\n        if isinstance(res, types.GeneratorType):\n            res = list(res)\n        if isinstance(res, list):\n            for line in res:\n                print(line)\n            res = 0\n        return res or 0\n    except:  # noqa: E722; # pragma: no cover\n        # FIXME: log exception!\n        return 256", "response": "Entry point for the cdstar CLI."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanitize_resources(resource: dict):\n        try:\n            for shade in resource[ATTR_SHADE_DATA]:\n                _name = shade.get(ATTR_NAME)\n                if _name:\n                    shade[ATTR_NAME_UNICODE] = base64_to_unicode(_name)\n            return resource\n        except (KeyError, TypeError):\n            LOGGER.debug(\"no shade data available\")\n            return None", "response": "Cleans up incoming scene data with shade data to be sanitized."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_agent(agent, recp, desc, allocation_id=None, *args, **kwargs):\n    '''\n    Tells remote host agent to start agent identified by desc.\n    The result value of the fiber is IRecipient.\n    '''\n    f = fiber.Fiber()\n    f.add_callback(agent.initiate_protocol, IRecipient(recp), desc,\n                   allocation_id, *args, **kwargs)\n    f.add_callback(StartAgentRequester.notify_finish)\n    f.succeed(StartAgentRequester)\n    return f", "response": "Tells remote host agent to start agent identified by desc."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling an invalid value.", "response": "def handle_invalid_value(self, message, exc_info, context):\n        # type: (Text, bool, dict) -> Any\n        \"\"\"\n        Handles an invalid value.\n\n        :param message:\n            Error message.\n\n        :param exc_info:\n            Whether to include output from :py:func:``sys.exc_info``.\n\n        :param context:\n            Additional context values for the error.\n        \"\"\"\n        raise NotImplementedError(\n            'Not implemented in {cls}.'.format(cls=type(self).__name__),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles an uncaught exception.", "response": "def handle_exception(self, message, exc):\n        # type: (Text, Exception) -> Any\n        \"\"\"\n        Handles an uncaught exception.\n        \"\"\"\n        return self.handle_invalid_value(\n            message     = message,\n            exc_info    = True,\n            context     = getattr(exc, 'context', {}),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(oauth_key, oauth_secret, username, password, oauth_redirect=_DEFAULT_REDIRECT, oauth_scopes=set(), useragent=_DEFAULT_USERAGENT, script_key=None):\n\timport praw\n\t\n\toauth_token = get_oauth_token(oauth_key, oauth_secret, username, password, useragent=useragent, script_key=script_key)\n\tif oauth_token is None:\n\t\tlog.debug(\"Can't create PRAW instance without token\")\n\t\treturn None\n\t\n\tr = praw.Reddit(user_agent=useragent, disable_update_check=True)\n\tr.set_oauth_app_info(oauth_key, oauth_secret, oauth_redirect)\n\tr.set_access_credentials(oauth_scopes, oauth_token)\n\tr.config.api_request_delay = 1\n\treturn r", "response": "Creates a new Reddit instance using the given authentication information."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_oauth_token(oauth_key, oauth_secret, username, password, useragent=_DEFAULT_USERAGENT, script_key=None):\n\ttoken = _get_local_token(script_key, username)\n\tif token is None:\n\t\ttoken_time = _time_ms()\n\t\ttoken = _request_oauth_token(oauth_key, oauth_secret, username, password, useragent=useragent)\n\t\twrite_config(token, token_time, _get_config_file(script_key, username))\n\treturn token", "response": "Get an OAuth token from Reddit or returns a valid locally stored token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the getter and setter methods to the given class.", "response": "def apply(self, cls, originalMemberNameList, classNamingConvention):\n        \"\"\"\n    :type cls: type\n    :type originalMemberNameList: list(str)\n    :type classNamingConvention: INamingConvention\n\"\"\"\n        self._memberDelegate.apply(cls = cls,\n                                   originalMemberNameList = originalMemberNameList,\n                                   memberName = self._memberName,\n                                   classNamingConvention = classNamingConvention,\n                                   getter = self._makeGetter(),\n                                   setter = self._makeSetter())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the specified class from the set of members.", "response": "def remove(self, cls, originalMemberNameList, classNamingConvention):\n        \"\"\"\n    :type cls: type\n    :type originalMemberNameList: list(str)\n    :type classNamingConvention: INamingConvention\n\"\"\"\n        self._memberDelegate.remove(cls = cls,\n                                    originalMemberNameList = originalMemberNameList,\n                                    memberName = self._memberName,\n                                    classNamingConvention = classNamingConvention)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef computer(self, base_dn, samaccountname, attributes=()):\n\n        computers = self.computers(base_dn, samaccountnames=[samaccountname], attributes=attributes)\n\n        try:\n            # Usually we will find a match, but perhaps not always\n            return computers[0]\n        except IndexError:\n            logging.info(\"%s - unable to retrieve object from AD by sAMAccountName\", samaccountname)", "response": "Returns a single populated ADComputer object through the object factory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef computers(self, base_dn, samaccountnames=(), attributes=()):\n        ad_computers = []\n\n        search_filter = '(&(objectClass=computer){0})'\n        # If no samaccountnames specified, filter will pull all computer objects under\n        # base_dn\n        if not samaccountnames:\n            search_filter = search_filter.format('(sAMAccountName=*)')\n        else:\n            if len(samaccountnames) == 1:\n                computer_names = '(sAMAccountName={0})'.format(samaccountnames[0])\n            else:\n                computer_names = '(|{0})'.format(''.join(['(sAMAccountName={0})'.\\\n                                                          format(computer) for computer\n                                                          in samaccountnames]))\n\n            search_filter = search_filter.format(computer_names)\n\n\n        logging.debug('%s Search filter: %s', self.__class__.__name__, search_filter)\n\n        results = self.adq.search(base_dn, search_filter, attributes)\n\n        for search_result in results:\n            adc = self._object_factory(search_result)\n            ad_computers.append(adc)\n\n        return ad_computers", "response": "Returns a list of ADComputer objects for the specified base DN and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef source_get(method_name):\n\n    def source_get(_value, context, **_params):\n        method = getattr(context[\"model\"].source, method_name)\n        return _get(method, context[\"key\"], (), {})\n\n    return source_get", "response": "Creates a getter that will drop the current value and call the source s method with specified name\n    using the context s key as first argument."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a getter that will drop the current value and retrieve the source s attribute with specified name.", "response": "def source_attr(attr_name):\n    \"\"\"\n    Creates a getter that will drop the current value\n    and retrieve the source's attribute with specified name.\n    @param attr_name: the name of an attribute belonging to the source.\n    @type attr_name: str\n    \"\"\"\n\n    def source_attr(_value, context, **_params):\n        value = getattr(context[\"model\"].source, attr_name)\n        return _attr(value)\n\n    return source_attr"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef source_getattr():\n\n    def source_getattr(_value, context, **_params):\n        value = getattr(context[\"model\"].source, context[\"key\"])\n        return _attr(value)\n\n    return source_getattr", "response": "Returns a getter that will drop the current value\n    and retrieve the source s attribute with the context key as name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a getter that will drop the current value and call the model s method with specified name using the context s key as first argument.", "response": "def model_get(method_name):\n    \"\"\"\n    Creates a getter that will drop the current value,\n    and call the model's method with specified name\n    using the context's key as first argument.\n    @param method_name: the name of a method belonging to the model.\n    @type method_name: str\n    \"\"\"\n\n    def model_get(_value, context, **_params):\n        method = getattr(context[\"model\"], method_name)\n        return _get(method, context[\"key\"], (), {})\n\n    return model_get"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a getter that will drop the current value and retrieve the model s attribute with specified name.", "response": "def model_attr(attr_name):\n    \"\"\"\n    Creates a getter that will drop the current value\n    and retrieve the model's attribute with specified name.\n    @param attr_name: the name of an attribute belonging to the model.\n    @type attr_name: str\n    \"\"\"\n\n    def model_attr(_value, context, **_params):\n        value = getattr(context[\"model\"], attr_name)\n        return _attr(value)\n\n    return model_attr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a getter that will drop the current value and retrieve the model s attribute with the context key as name.", "response": "def model_getattr():\n    \"\"\"\n    Creates a getter that will drop the current value\n    and retrieve the model's attribute with the context key as name.\n    \"\"\"\n\n    def model_getattr(_value, context, **_params):\n        value = getattr(context[\"model\"], context[\"key\"])\n        return _attr(value)\n\n    return model_getattr"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef action_get(method_name):\n\n    def action_get(_value, context, **_params):\n        method = getattr(context[\"action\"], method_name)\n        return _get(method, context[\"key\"], (), {})\n\n    return action_get", "response": "Creates a getter that will drop the current value and call the action s method with specified name\n    using the context s key as first argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef action_attr(attr_name):\n\n    def action_attr(_value, context, **_params):\n        value = getattr(context[\"action\"], attr_name)\n        return _attr(value)\n\n    return action_attr", "response": "Creates a getter that will drop the current value\n    and retrieve the action s attribute with specified name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a getter that will drop the current value and retrieve the action s attribute with the context key as name.", "response": "def action_getattr():\n    \"\"\"\n    Creates a getter that will drop the current value\n    and retrieve the action's attribute with the context key as name.\n    \"\"\"\n\n    def action_getattr(_value, context, **_params):\n        value = getattr(context[\"action\"], context[\"key\"])\n        return _attr(value)\n\n    return action_getattr"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef view_get(method_name):\n\n    def view_get(_value, context, **_params):\n        method = getattr(context[\"view\"], method_name)\n        return _get(method, context[\"key\"], (), {})\n\n    return view_get", "response": "Creates a getter that will drop the current value and call the view s method with specified name\n    using the context s key as first argument."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef view_attr(attr_name):\n\n    def view_attr(_value, context, **_params):\n        value = getattr(context[\"view\"], attr_name)\n        return _attr(value)\n\n    return view_attr", "response": "Creates a getter that will drop the current value\n    and retrieve the view s attribute with specified name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef view_getattr():\n\n    def view_getattr(_value, context, **_params):\n        value = getattr(context[\"view\"], context[\"key\"])\n        return _attr(value)\n\n    return view_getattr", "response": "Returns a getter that will drop the current value\n    and retrieve the source s attribute with the context key as name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a getter that will call value s method with specified name using the context s key as first argument.", "response": "def value_get(method_name):\n    \"\"\"\n    Creates a getter that will call value's method with specified name\n    using the context's key as first argument.\n    @param method_name: the name of a method belonging to the value.\n    @type method_name: str\n    \"\"\"\n\n    def value_get(value, context, **_params):\n        method = getattr(value, method_name)\n        return _get(method, context[\"key\"], (), {})\n\n    return value_get"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value_attr(attr_name):\n\n    def value_attr(value, context, **_params):\n        value = getattr(value, attr_name)\n        return _attr(value)\n\n    return value_attr", "response": "Creates a getter that will retrieve value s attribute\n    with specified name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a getter that will retrieve the value s attribute with the context key as name.", "response": "def value_getattr():\n    \"\"\"\n    Creates a getter that will retrieve the value's attribute\n    with the context key as name.\n    \"\"\"\n\n    def value_getattr(value, context, **_params):\n        value = getattr(value, context[\"key\"])\n        return _attr(value)\n\n    return source_getattr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show(self, progress, msg=None):\n        if self.whole_tag.style.display == \"none\":\n            self.whole_tag.style.display = \"block\"\n\n        # allow either direct percentage value, or (done / len(all)) pairs\n        if isinstance(progress, int) or isinstance(progress, float):\n            percentage = progress\n        else:\n            percentage = self.__class__._compute_percentage(progress)\n\n        # toggle animation\n        self.tag.class_name = \"progress-bar\"\n        if percentage < 100:\n            self.tag.class_name += \" progress-bar-striped active\"\n        else:\n            msg = \"Hotovo\"\n\n        # show percentage in progress bar\n        self.tag.aria_valuemin = percentage\n        self.tag.style.width = \"{}%\".format(percentage)\n\n        if msg:\n            self.tag.text = msg", "response": "Show the progress bar and set it to progress tuple or value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresetting the progressbar to 0 hide it and set original text message at background.", "response": "def reset(self):\n        \"\"\"\n        Reset the progressbar to 0, hide it and set original text message at\n        background.\n        \"\"\"\n        self.hide()\n        self.tag.class_name = \"progress-bar progress-bar-striped active\"\n        self.tag.aria_valuemin = 0\n        self.tag.style.width = \"{}%\".format(0)\n        self.tag.text = self.original_message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def check_response(response, valid_response_codes):\n    if response.status == 204:\n        return True\n    if response.status in valid_response_codes:\n        _js = await response.json()\n        return _js\n    else:\n        raise PvApiResponseStatusError(response.status)", "response": "Check the response for correctness."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def delete(self, url: str, params: dict = None):\n        response = None\n        try:\n            with async_timeout.timeout(self._timeout, loop=self.loop):\n                response = await self.websession.delete(url, params=params)\n            return await check_response(response, [200, 204])\n        except (asyncio.TimeoutError, aiohttp.ClientError) as error:\n            _LOGGER.error(\"Failed to communicate with PowerView hub: %s\", error)\n            raise PvApiConnectionError\n        finally:\n            if response is not None:\n                await response.release()", "response": "Delete a resource.\n\n        :param url: Endpoint\n        :param params: parameters\n        :return: Response body\n\n        :raises PvApiError when something is wrong."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsanitize the current settings and return the new value.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(MapReferralMessage, self).sanitize()\n\n        # WARNING: http://tools.ietf.org/html/draft-ietf-lisp-ddt-00\n        # does not define this field so the description is taken from\n        # http://tools.ietf.org/html/draft-ietf-lisp-24\n        #\n        # Nonce: An 8-octet random value created by the sender of the Map-\n        # Request.  This nonce will be returned in the Map-Reply.  The\n        # security of the LISP mapping protocol depends critically on the\n        # strength of the nonce in the Map-Request message.  The nonce\n        # SHOULD be generated by a properly seeded pseudo-random (or strong\n        # random) source.  See [RFC4086] for advice on generating security-\n        # sensitive random data.\n        if len(bytes(self.nonce)) != 8:\n            raise ValueError('Invalid nonce')\n\n        # Map-Referral Records:  When the M bit is set, this field is the size\n        # of a single \"Record\" in the Map-Reply format.  This Map-Reply record\n        # contains the EID-to-RLOC mapping entry associated with the Source\n        # EID.  This allows the ETR which will receive this Map-Request to\n        # cache the data if it chooses to do so.\n        for record in self.records:\n            if not isinstance(record, MapReferralRecord):\n                raise ValueError('Invalid record')\n\n            record.sanitize()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_bytes(cls, bitstream):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the type\n        type_nr = bitstream.read('uint:4')\n        if type_nr != packet.message_type:\n            msg = 'Invalid bitstream for a {0} packet'\n            class_name = packet.__class__.__name__\n            raise ValueError(msg.format(class_name))\n\n        # Skip reserved bits\n        packet._reserved1 = bitstream.read(20)\n\n        # Store the record count\n        record_count = bitstream.read('uint:8')\n\n        # Store the nonce\n        packet.nonce = bitstream.read('bytes:8')\n\n        # Read the records\n        for dummy in range(record_count):\n            record = MapReferralRecord.from_bytes(bitstream)\n            packet.records.append(record)\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "Parse the given packet and update properties accordingly\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the type\n        bitstream = BitArray('uint:4=%d' % self.message_type)\n\n        # Add padding\n        bitstream += self._reserved1\n\n        # Add the record count\n        bitstream += BitArray('uint:8=%d' % len(self.records))\n\n        # Add the nonce\n        bitstream += BitArray(bytes=self.nonce)\n\n        # Add the records\n        for record in self.records:\n            bitstream += record.to_bitstream()\n\n        return bitstream.bytes", "response": "Create bytes from properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bootstrap(parser=None, args=None, descriptors=None):\n\n    tee = log.init()\n    # The purpose of having log buffer here, is to be able to dump the\n    # log lines to a journal after establishing connection with it.\n    # This is done in stage_configure() of net agency Startup procedure.\n    tee.add_keeper('buffer', log.LogBuffer(limit=10000))\n\n    # use the resolver from twisted.names instead of the default\n    # the reason for this is that ThreadedResolver behaves strangely\n    # after the reconnection - raises the DNSLookupError for names\n    # which have been resolved while there was no connection\n    resolver.installResolver(reactor)\n\n    if parser is None:\n        parser = optparse.OptionParser()\n        options.add_options(parser)\n    try:\n        opts, args = check_options(*parser.parse_args(args))\n    except Exception as e:\n        error.handle_exception('bootstrap', e, \"Failed parsing config\")\n        sys.exit(1)\n\n    if opts.standalone:\n        cls = standalone.Agency\n    else:\n        cls = net_agency.Agency\n    config = config_module.Config()\n    config.load(os.environ, opts)\n    agency = cls(config)\n\n    applications.load('feat.agents.application', 'feat')\n    applications.load('feat.gateway.application', 'featmodels')\n\n    d = defer.Deferred()\n    reactor.callWhenRunning(d.callback, None)\n\n    if not opts.standalone:\n        # specific to running normal agency\n\n        hostdef = opts.hostdef\n\n        if opts.hostres or opts.hostcat or opts.hostports:\n            from feat.agents.common import host\n            hostdef = host.HostDef()\n            for resdef in opts.hostres:\n                parts = resdef.split(\":\", 1)\n                name = parts[0]\n                value = 1\n                if len(parts) > 1:\n                    try:\n                        value = int(parts[1])\n                    except ValueError:\n                        raise OptionError(\n                            \"Invalid host resource: %s\" % resdef), \\\n                            None, sys.exc_info()[2]\n                hostdef.resources[name] = value\n\n            for catdef in opts.hostcat:\n                name, value = check_category(catdef)\n                hostdef.categories[name] = value\n\n            if opts.hostports:\n                hostdef.ports_ranges = dict()\n            for ports in opts.hostports:\n                group, start, stop = tuple(ports.split(\":\"))\n                hostdef.ports_ranges[group] = (int(start), int(stop))\n\n        agency.set_host_def(hostdef)\n\n        d.addCallback(defer.drop_param, agency.initiate)\n        for desc, kwargs, name in opts.agents:\n            d.addCallback(defer.drop_param, agency.add_static_agent,\n                          desc, kwargs, name)\n    else:\n        # standalone specific\n        kwargs = opts.standalone_kwargs or dict()\n        to_spawn = opts.agent_id or opts.agents[0][0]\n        d.addCallback(defer.drop_param, agency.initiate)\n        d.addCallback(defer.drop_param, agency.spawn_agent,\n                      to_spawn, **kwargs)\n    queue = None\n    if opts.agency_daemonize:\n        import multiprocessing\n        queue = multiprocessing.Queue()\n\n    d.addCallbacks(_bootstrap_success, _bootstrap_failure,\n                   callbackArgs=(queue, ), errbackArgs=(agency, queue))\n\n    if not opts.agency_daemonize:\n        reactor.run()\n    else:\n        logname = \"%s.%s.log\" % ('feat', agency.agency_id)\n        logfile = os.path.join(config.agency.logdir, logname)\n        log.info(\"bootstrap\", \"Daemon processs will be logging to %s\",\n                 logfile)\n\n        try:\n            pid = os.fork()\n        except OSError, e:\n            sys.stderr.write(\"Failed to fork: (%d) %s\\n\" %\n                             (e.errno, e.strerror))\n            os._exit(1)\n\n        if pid > 0:\n            # original process waits for information about what status code\n            # to use on exit\n            log.info('bootstrap',\n                     \"Waiting for deamon process to intialize the agency\")\n            try:\n                exit_code, reason = queue.get(timeout=20)\n            except multiprocessing.queues.Empty:\n                log.error('bootstrap',\n                          \"20 seconds timeout expires waiting for agency\"\n                          \" in child process to initiate.\")\n                os._exit(1)\n            else:\n                log.info('bootstrap', \"Process exiting with %d status\",\n                         exit_code)\n                if exit_code:\n                    log.info('bootstrap', 'Reason for failure: %s', reason)\n                sys.exit(exit_code)\n        else:\n            # child process performs second fork\n            try:\n                pid = os.fork()\n            except OSError, e:\n                sys.stderr.write(\"Failed to fork: (%d) %s\\n\" %\n                                 (e.errno, e.strerror))\n                os._exit(1)\n            if pid > 0:\n                # child process just exits\n                sys.exit(0)\n            else:\n                # grandchild runs the reactor and logs to an external log file\n                log.FluLogKeeper.redirect_to(logfile, logfile)\n                reactor.run()\n\n    global _exit_code\n    log.info('bootstrap', 'Process exiting with %d status', _exit_code)\n    sys.exit(_exit_code)", "response": "Bootstrap a feat process handling command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, iterable):\n        for pair in pairwise_longest(iterable, fillvalue=_FILL):\n            self._edges.append(pair)\n            self._results = None", "response": "Update with an ordered iterable of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npreparing a minimal dictionary with keys mapping to attributes for the current instance.", "response": "def to_dict(self):\n        \"\"\"Prepare a minimal dictionary with keys mapping to attributes for\n        the current instance.\n\n        \"\"\"\n        o_copy = copy.copy(self)\n        # Remove some stuff that is not likely related to AD attributes\n        for attribute in dir(self):\n            if attribute == 'logger' or attribute == 'adq':\n                try:\n                    delattr(o_copy, attribute)\n                except AttributeError:\n                    pass\n\n        return o_copy.__dict__"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the sAMAccountName for a specific DistinguishedName", "response": "def samaccountname(self, base_dn, distinguished_name):\n        \"\"\"Retrieve the sAMAccountName for a specific DistinguishedName\n\n        :param str base_dn: The base DN to search within\n        :param list distinguished_name: The base DN to search within\n        :param list attributes: Object attributes to populate, defaults to all\n\n        :return: A populated ADUser object\n        :rtype: ADUser\n        \"\"\"\n        mappings = self.samaccountnames(base_dn, [distinguished_name])\n\n        try:\n            # Usually we will find a match, but perhaps not always\n            return mappings[distinguished_name]\n        except KeyError:\n            logging.info(\"%s - unable to retrieve object from AD by DistinguishedName\",\n                         distinguished_name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef samaccountnames(self, base_dn, distinguished_names):\n        attributes = ['sAMAccountName']\n        search_filter = '(|{0})'.format(''.join(['(DistinguishedName={0})'.format(dn)\n                                                 for dn in distinguished_names]))\n        logging.debug('%s Search filter: %s', self.__class__.__name__, search_filter)\n\n        results = self.adq.search(base_dn, search_filter, attributes)\n\n        mappings = {result[0]: result[1]['sAMAccountName'][0] for result in results}\n\n        return mappings", "response": "Retrieve the sAMAccountNames for the specified base DN and list of distinguished names."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _object_factory(self, search_result):\n        class_name = self.__class__.__name__\n        module = self.__module__\n        logging.debug('Creating object of type %s for DN: %s', class_name, search_result[0])\n        module = importlib.import_module('{0}'.format(module))\n        class_ = getattr(module, class_name)\n        ado = class_(self.adq)\n\n        # A unique set of all attribute names found\n        attribute_names = set()\n        # A unique set\n        multiples = set()\n        for k in search_result[1].keys():\n            if k not in attribute_names:\n                attribute_names.add(k)\n            else:\n                multiples.add(k)\n        for k, val in search_result[1].iteritems():\n            if k in multiples and not hasattr(ado, k):\n                setattr(ado, k.lower(), list())\n            if hasattr(ado, k):\n                value = getattr(ado, k)\n                if len(val) == 1:\n                    value.append(val[0])\n                else:\n                    value.append(val)\n            else:\n                if len(val) == 1:\n                    setattr(ado, k.lower(), val[0])\n                else:\n                    setattr(ado, k.lower(), val)\n\n\n        logging.debug('Attributes and values for %s object (DN: %s): %s', class_name,\n                      search_result[0], ado.__dict__)\n\n        return ado", "response": "Given a single search result create and return an object of type object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_message(received_message, control_plane_sockets, data_plane_sockets):\n    logger.debug(u\"Handling message #{0} ({1}) from {2}\".format(received_message.message_nr,\n                                                                received_message.message.__class__.__name__,\n                                                                received_message.source[0]))\n\n    try:\n        if isinstance(received_message.message, MapRequestMessage):\n            # A map-request message\n            handle_map_request(received_message, control_plane_sockets, data_plane_sockets)\n\n        elif isinstance(received_message.message, MapReplyMessage):\n            # A map-reply message\n            handle_map_reply(received_message, control_plane_sockets, data_plane_sockets)\n\n        elif isinstance(received_message.message, MapNotifyMessage):\n            # A map-notify message (subclass of MapRegisterMessage, so put above it!)\n            handle_map_notify(received_message, control_plane_sockets, data_plane_sockets)\n\n        elif isinstance(received_message.message, MapRegisterMessage):\n            # A map-register message\n            handle_map_register(received_message, control_plane_sockets, data_plane_sockets)\n\n        elif isinstance(received_message.message, MapReferralMessage):\n            # A map-referral message\n            handle_map_referral(received_message, control_plane_sockets, data_plane_sockets)\n\n        elif isinstance(received_message.message, EncapsulatedControlMessage):\n            # Determine the type of ECM\n            if isinstance(received_message.inner_message, MapRequestMessage):\n                if received_message.message.ddt_originated:\n                    # A DDT map-request message\n                    handle_ddt_map_request(received_message, control_plane_sockets, data_plane_sockets)\n                else:\n                    # An encapsulated map-request message\n                    handle_enc_map_request(received_message, control_plane_sockets, data_plane_sockets)\n            else:\n                logger.warning(\"ECM does not contain a map-request in message %d\", received_message.message_nr)\n        elif isinstance(received_message.message, InfoMessage):\n            handle_info_message(received_message, control_plane_sockets, data_plane_sockets)\n        else:\n            logger.warning(\"Unknown content in message %d\", received_message.message_nr)\n    except:\n        logger.exception(\"Unexpected exception while handling message %d\", received_message.message_nr)", "response": "Handles a LISP message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_master_missing(self):\n        '''\n        Tries to spawn a master agency if the slave agency failed to connect\n        for several times. To avoid several slave agencies spawning the master\n        agency a file lock is used\n        '''\n        self.info(\"We could not contact the master agency, starting a new one\")\n        if self._starting_master:\n            self.info(\"Master already starting, waiting for it\")\n            return\n        if self._shutdown_task is not None:\n            self.info(\"Not spwaning master because we are about to terminate \"\n                      \"ourselves\")\n            return\n        if self._startup_task is not None:\n            raise error.FeatError(\"Standalone started without a previous \"\n                                  \"master agency already running, terminating \"\n                                  \"it\")\n\n        # Try the get an exclusive lock on the master agency startup\n        if self._acquire_lock():\n            self._starting_master = True\n            # Allow restarting a master if we didn't succeed after 10 seconds\n            self._release_lock_cl = time.callLater(10, self._release_lock)\n            return self._spawn_agency('master')", "response": "Tries to spawn a master agency if the slave agency failed to connect to a master agency. If the slave agency failed to connect to a master agency a new master agency is created and the slave agency is restarted."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the elements from the data obtained from REST API.", "response": "def set(cls, values):\n        \"\"\"\n        Set the elements from the data obtained from REST API.\n\n        Args:\n            values (dict): Dict with ``mrc``, ``oai``, ``dc`` and ``fn`` keys.\n        \"\"\"\n        cls.mrc_out_el.text = values.get(\"mrc\", \"\")\n        cls.oai_out_el.text = values.get(\"oai\", \"\")\n        cls.dc_out_el.text = values.get(\"dc\", \"\")\n        cls.filename = values.get(\"fn\", \"fn\")\n\n        cls.values = values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing the interface for picking or downloading the datasets.", "response": "def show(cls, values=None):\n        \"\"\"\n        Show the interface for picking / downloading the datasets.\n        \"\"\"\n        if values:\n            cls.set(values)\n\n        cls.el.style.display = \"block\"\n\n        cls.overlay.show()\n        cls.overlay.el.bind(\"click\", lambda x: cls.hide())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bind_download_buttons(cls):\n        def on_click(ev):\n            button_el = ev.target\n            form_el = button_el.parent.parent.parent\n\n            # this allows to use disabled <textearea>, which is normally not\n            # sent\n            content = form_el.get(selector=\"textarea\")[0].text\n\n            # change filename according to output\n            suffix = form_el.name\n            download_path = \"as_file/%s.%s\" % (cls.filename, suffix)\n            form_el.action = join(settings.API_PATH, download_path)\n\n            input_el = form_el.get(selector=\"input\")[0]\n            input_el.value = content\n\n        for el in document.get(selector=\"button.output_download_button\"):\n            el.bind(\"click\", on_click)", "response": "Bind buttons to callbacks.\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the datasets and interface to default values.", "response": "def reset(cls):\n        \"\"\"\n        Reset the datasets and interface to default values.\n        \"\"\"\n        cls.hide()\n\n        cls.values = None\n        cls.filename = \"fn\"\n        cls.dc_out_el.text = \"\"\n        cls.oai_out_el.text = \"\"\n        cls.mrc_out_el.text = \"\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving the current object to the database.", "response": "def save(self):\n\n        \"\"\"\n        *DEPRECATED*\n\n        Performs the __save__ method, if it has been declared.\n        If not, this function raises a CannotSave exception.\n        .save() does *not* implicitly commit the model.\n        To commit, it must be done manually.\"\"\"\n\n        if hasattr(self, \"__save__\"):\n\n            args = self.__save__.args()\n            my_args = {}\n            for arg in args:\n                my_args[arg] = self.__dict__.get(arg, None)\n            rs = self.__save__(**my_args).fetchone()\n\n            for arg in self.table:\n                if arg in rs:\n                    self.__dict__[arg] = rs[arg]\n        else:\n#            from simpycity import CannotSave\n            raise NotImplementedError(\"Cannot save without __save__ declaration.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_composite(cls, name, handle=None, factory=None):\n        class CustomCompositeCaster(psycopg2.extras.CompositeCaster):\n\n            def make(self, values):\n                d_out(\"CustomCompositeCaster.make: cls={0} values={1}\".format(repr(cls), repr(values)))\n                return cls(**dict(list(zip(self.attnames, values))))\n\n        PG_TYPE_SQL = \"\"\"SELECT array_agg(attname)\nFROM\n    (\n        SELECT attname\n        FROM\n            pg_type t\n            JOIN pg_namespace ns ON typnamespace = ns.oid\n            JOIN pg_attribute a ON attrelid = typrelid\n        WHERE nspname = %s AND typname = %s\n            AND attnum > 0 AND NOT attisdropped\n        ORDER BY attnum\n    ) sub;\"\"\"\n        if handle is None:\n            handle = g_config.handle_factory()\n        d_out(\"SimpleModel.register_composite: before: table for {0} is {1}\".format(repr(cls.pg_type), cls.table))\n        if cls.pg_type is not None:\n            super_table = cls.__mro__[1].table if hasattr(cls.__mro__[1], 'table') else []\n            if cls.table == [] or cls.table is super_table:\n                cursor = handle.cursor()\n                cursor.execute(PG_TYPE_SQL, cls.pg_type)\n                row = cursor.fetchone()\n                d_out(\"SimpleModel.register_composite: row={0}\".format(row))\n                row[0] = [_ for _ in row[0] if _ != 'base_']\n                cls.table = cls.table + row[0]\n                d_out(\"SimpleModel.register_composite: after: table for {0} is {1}\".format(repr(cls.pg_type), cls.table))\n        if factory is None:\n            factory = CustomCompositeCaster\n        if sys.version_info[0] < 3:\n            name = str(name)\n        return psycopg2.extras.register_composite(\n            name,\n            handle.conn,\n            globally=True,  # in case of reconnects\n            factory=factory\n        )", "response": "Register a Postgresql composite type with the Postgres database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmerging base attributes into a new attribute dict.", "response": "def merge_base_attrs(attrs):\n        \"\"\"\n        :param dict attrs: If one of the attrs is named \"base\\_\", assume that attribute is an instance of SimpleModel mapped on a Postgresql composite type, and that the base\\_ instance is of a superclass of this class. Expand the attributes of the base\\_ type and assign to class attributes.\n\n        psycopg2's type casting uses namedtuple() and that forbids a\n        name to start with underscore, so we end it with _ instead\n        \"\"\"\n        base = attrs.pop('base_', None)\n        if base:\n            d_out(\"SimpleModel.merge_base_attrs: base.table={0}\".format(base.table))\n            for name in base.table:\n                attrs[name] = base.__dict__[name]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the value for the AAF A AAFAFAFAFAFAFAFAFAFAFAFAFAF AAF AAFAFAF AAF AAF", "response": "def validate(self, value):\n        \"\"\"\n        Accepts: str, unicode\n        Returns: list of tuples in the format (ip, port)\n        \"\"\"\n        val = super(SlavesValue, self).validate(value)\n\n        slaves = val.replace(\" \", \"\")\n        slaves = filter(None, slaves.split(','))\n        slaves = [x.split(\":\") for x in slaves]\n        res = list()\n        for x in slaves:\n            self._validate_ip(x[0])\n            if len(x) == 1:\n                res.append((x[0], 53))\n            else:\n                res.append((x[0], int(x[1])))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a list of tuples in the format ip port", "response": "def publish(self, value):\n        \"\"\"\n        Accepts: list of tuples in the format (ip, port)\n        Returns: unicode\n        \"\"\"\n        if not isinstance(value, list):\n            raise ValueError(value)\n        slaves = ['%s:%d' % x for x in value]\n        return unicode(\", \".join(slaves))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_capture(self):\n        if not self._connect():\n            log.warning('Treal is not connected')\n            self._error()\n            return\n        super(Treal, self).start_capture()", "response": "Begin listening for output from the stenotype machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops listening for output from the stenotype machine.", "response": "def stop_capture(self):\n        \"\"\"Stop listening for output from the stenotype machine.\"\"\"\n        super(Treal, self).stop_capture()\n        if self._machine:\n            self._machine.close()\n        self._stopped()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndraws a vertical gradient strip.", "response": "def vertical_strip(width=10, height=100, color=rgb(100, 100, 100),\n                   subtlety=0.1):\n    \"\"\"\n    Draws a subtle vertical gradient strip.\n    \"\"\"\n\n    cairo_color = color / rgb(255, 255, 255)\n\n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n    ctx = cairo.Context(surface)\n\n    ctx.scale(width / 1.0, height / 1.0)\n\n    pat = cairo.LinearGradient(0.0, 0.0, 0.0, 1.0)\n    pat.add_color_stop_rgba(\n        0,\n        cairo_color.red,\n        cairo_color.green,\n        cairo_color.blue,\n        0\n    )\n    pat.add_color_stop_rgba(\n        1,\n        cairo_color.red,\n        cairo_color.green,\n        cairo_color.blue,\n        1\n    )\n\n    ctx.rectangle(0, 0, 1, 1)\n    ctx.set_source(pat)\n    ctx.fill()\n\n    surface.write_to_png('vertical_strip.png')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws a subtle vertical gradient strip.", "response": "def vertical_white(width=10, height=100, subtlety=0.1):\n    \"\"\"\n    Draws a subtle vertical gradient strip: white with varying alpha.\n    \"\"\"\n\n    start = 0.5 - subtlety\n    end = 0.5 + subtlety\n\n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n    ctx = cairo.Context(surface)\n\n    ctx.scale(width/1.0, height/1.0)\n\n    pat = cairo.LinearGradient(0.0, 0.0, 0.0, 1.0)\n    pat.add_color_stop_rgba(0, 1, 1, 1, start)\n    pat.add_color_stop_rgba(1, 1, 1, 1, end)\n\n    ctx.rectangle(0, 0, 1, 1)\n    ctx.set_source(pat)\n    ctx.fill()\n\n    surface.write_to_png('vertical_white.png')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_filter_type(target):\n    # type: (Any) -> Union[bool, Text]\n    \"\"\"\n    Returns whether the specified object can be registered as a filter.\n\n    :return:\n        Returns ``True`` if the object is a filter.\n        Otherwise, returns a string indicating why it is not valid.\n    \"\"\"\n    if not is_class(target):\n        return 'not a class'\n\n    if not issubclass(target, BaseFilter):\n        return 'does not extend BaseFilter'\n\n    if is_abstract(target):\n        return 'abstract class'\n\n    return True", "response": "Checks if the object is a filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_filters_in(target):\n    # type: (Any) -> Generator[Tuple[Text, Type[BaseFilter]]]\n    \"\"\"\n    Iterates over all filters in the specified module/class.\n    \"\"\"\n    global legacy_warned\n    if not legacy_warned:\n        # Set the global flag to ``True`` first, in case the user has\n        # ``simplefilter('error')`` set.\n        legacy_warned = True\n\n        warn(\n            'Legacy extension loader is deprecated and will be removed in '\n                'Filters v1.4.  '\n                'See http://filters.readthedocs.io/en/latest/extensions.html#legacy-extensions-loader '\n                'for more information.',\n\n            DeprecationWarning,\n        )\n\n    ift_result = is_filter_type(target)\n\n    if ift_result is True:\n        logger.debug(\n            'Registering extension filter '\n            '{cls.__module__}.{cls.__name__}.'.format(\n                cls = target,\n            ),\n        )\n\n        yield target.__name__, target\n    elif is_module(target):\n        for member_name, member in get_members(target):\n            member_ift_result = is_filter_type(member)\n\n            if member_ift_result is True:\n                logger.debug(\n                    'Registering extension filter '\n                    '{cls.__module__}.{cls.__name__}.'.format(\n                        cls = member,\n                    ),\n                )\n\n                yield member.__name__, member\n            else:\n                logger.debug(\n                    'Ignoring {module}.{name} ({reason})'.format(\n                        module  = target.__name__,\n                        name    = member_name,\n                        reason  = member_ift_result,\n                    ),\n                )\n    elif is_class(target):\n        logger.debug(\n            'Ignoring {cls.__module__}.{cls.__name__} ({reason}).'.format(\n                cls     = target,\n                reason  = ift_result,\n            ),\n        )\n    else:\n        logger.debug(\n            'Ignoring {target!r} ({reason}).'.format(\n                reason  = ift_result,\n                target  = target,\n            ),\n        )", "response": "Iterate over all filters in the specified module or class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the descriptor and the partners of the host agent who left his descriptor in database.", "response": "def do_cleanup(connection, host_agent_id):\n    '''\n    Performs cleanup after the host agent who left his descriptor in database.\n    Deletes the descriptor and the descriptors of the partners he was hosting.\n    '''\n    desc = yield safe_get(connection, host_agent_id)\n    if isinstance(desc, host.Descriptor):\n        for partner in desc.partners:\n            partner_desc = yield safe_get(connection, partner.recipient.key)\n            if partner_desc:\n                host_part = first(x for x in partner_desc.partners\n                                  if x.role == 'host')\n                if host_part is None:\n                    log.warning('host_restart',\n                                'Agent id: %s type: %s did not have any '\n                                'host partner. So we are leaving it be.',\n                                partner_desc.doc_id,\n                                partner_desc.type_name)\n                elif host_part.recipient.key == host_agent_id:\n                    log.info('host_restart', \"Deleting document with ID: %s\",\n                             partner_desc.doc_id)\n                    yield connection.delete_document(partner_desc)\n                else:\n                    log.warning('host_restart',\n                                \"Not deleting descriptor of the agent id: %s, \"\n                                \"agent_type: %s, as it seems to be hosted by \"\n                                \"the host agent: %s. Although keep in mind \"\n                                \"that he will not receive the goodbye \"\n                                \"notification from us!\",\n                                partner_desc.doc_id,\n                                partner_desc.type_name,\n                                host_part.recipient.key)\n        log.info('host_restart', \"Deleting document with ID: %s\",\n                 desc.doc_id)\n        yield connection.delete_document(desc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fix_alert_poster(self, state, shard):\n        '''\n        Called after agent has switched a shard. Alert poster needs an update\n        in this case, bacause otherwise its posting to lobby instead of the\n        shard exchange.\n        '''\n        recp = recipient.Broadcast(AlertPoster.protocol_id, shard)\n        state.alerter.update_recipients(recp)", "response": "Called after agent has switched a shard."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all possible schedules for the given courses.", "response": "def compute_schedules(courses=None, excluded_times=(), free_sections_only=True, problem=None, return_generator=False, section_constraint=None):\n    \"\"\"\n    Returns all possible schedules for the given courses.\n    \"\"\"\n    s = Scheduler(free_sections_only, problem, constraint=section_constraint)\n    s.exclude_times(*tuple(excluded_times))\n    return s.find_schedules(courses, return_generator)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the given section conflicts with this time range.", "response": "def conflicts_with(self, section):\n        \"Returns True if the given section conflicts with this time range.\"\n        for p in section.periods:\n            t = (p.int_days, p.start, p.end)\n            if t in self:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exclude_time(self, start, end, days):\n        self._excluded_times.append(TimeRange(start, end, days))\n        return self", "response": "Add an excluded time by start end times and the days."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd multiple excluded times by start end days or by TimeRange instance.", "response": "def exclude_times(self, *tuples):\n        \"\"\"Adds multiple excluded times by tuple of (start, end, days) or by\n        TimeRange instance.\n\n        ``start`` and ``end`` are in military integer times (e.g. - 1200 1430).\n        ``days`` is a collection of integers or strings of fully-spelt, lowercased days\n                 of the week.\n        \"\"\"\n        for item in tuples:\n            if isinstance(item, TimeRange):\n                self._excluded_times.append(item)\n            else:\n                self.exclude_time(*item)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn all the possible course combinations.", "response": "def find_schedules(self, courses=None, return_generator=False):\n        \"\"\"Returns all the possible course combinations. Assumes no duplicate courses.\n\n        ``return_generator``: If True, returns a generator instead of collection. Generators\n            are friendlier to your memory and save computation time if not all solutions are\n            used.\n        \"\"\"\n        self.p.reset()\n        self.create_variables(courses)\n        self.create_constraints(courses)\n        if return_generator:\n            return self.p.iter_solutions()\n        return self.p.get_solutions()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef time_conflict(self, schedule):\n        if is_nil(schedule):\n            return True\n        for timerange in self._excluded_times:\n            if timerange.conflicts_with(schedule):\n                return False\n        return True", "response": "Internal use. Determines when the given time range conflicts with the set of excluded time ranges."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_variables(self, courses):\n        has_sections = isinstance(courses, dict)\n        for course in courses:\n            self.p.add_variable(course, courses.get(course, []) if has_sections else self.get_sections(course))", "response": "Internal use. Creates all variables in the problem instance for the given courses."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_constraints(self, courses):\n        for i, course1 in enumerate(courses):\n            for j, course2 in enumerate(courses):\n                if i <= j:\n                    continue\n                self.p.add_constraint(self.section_constraint, [course1, course2])\n            self.p.add_constraint(self.time_conflict, [course1])", "response": "Internal use. Creates all constraints in the problem instance for the given set of courses."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new : class :. AnalysisRequest object on the server.", "response": "def create(cls, sample, analysis_system):\n        \"\"\"\n        Create a new :class:`.AnalysisRequest` on the server.\n\n        :param sample: A `Sample` object\n        :param analysis_system: The :class:`AnalysisSystem` that should be used for the analysis.\n        :return: The created :class:`AnalysisRequest` object.\n        \"\"\"\n        return cls._create(sample=sample.url, analysis_system=analysis_system.url)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef const(const):\n    '''Convenience wrapper to yield the value of a constant'''\n    try:\n        return getattr(_c, const)\n    except AttributeError:\n        raise FSQEnvError(errno.EINVAL, u'No such constant:'\\\n                               u' {0}'.format(const))\n    except TypeError:\n        raise TypeError(errno.EINVAL, u'const name must be a string or'\\\n                        u' unicode object, not:'\\\n                        u' {0}'.format(const.__class__.__name__))", "response": "Convenience wrapper to yield the value of a constant"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_const(const, val):\n    '''Convenience wrapper to reliably set the value of a constant from\n       outside of package scope'''\n    try:\n        cur = getattr(_c, const)\n    except AttributeError:\n        raise FSQEnvError(errno.ENOENT, u'no such constant:'\\\n                          u' {0}'.format(const))\n    except TypeError:\n        raise TypeError(errno.EINVAL, u'const name must be a string or'\\\n                        u' unicode object, not:'\\\n                        u' {0}'.format(const.__class__.__name__))\n    should_be = cur.__class__\n    try:\n        if not isinstance(val, should_be):\n            if should_be is unicode or cur is None:\n                val = coerce_unicode(val, _c.FSQ_CHARSET)\n            elif should_be is int and const.endswith('MODE'):\n                val = int(val, 8)\n            elif isinstance(cur, numbers.Integral):\n                val = int(val)\n            else:\n                should_be(val)\n    except (TypeError, ValueError, ):\n        raise FSQEnvError(errno.EINVAL, u'invalid type for constant {0},'\\\n                          u' should be {1}, not:'\\\n                          u' {2}'.format(const, should_be.__name__,\n                                         val.__class__.__name__))\n    setattr(_c, const, val)\n    return val", "response": "Convenience wrapper to reliably set the value of a constant from\n       outside of package scope"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exec(self, args):\n\n        logger.debug(\"status %s\", args.status)\n        self.status(args.status)", "response": "todo: Docstring for exec\n\n        :param args: arg description\n        :type args: type description\n        :return:\n        :rtype:"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking AJAX request to url with given POST data. Call on_complete callback when complete.", "response": "def make_request(url, data, on_complete):\n    \"\"\"\n    Make AJAX request to `url` with given POST `data`. Call `on_complete`\n    callback when complete.\n\n    Args:\n        url (str): URL.\n        data (dict): Dictionary with POST data.\n        on_complete (ref): Reference to function / method which will be called\n            when the request is done.\n    \"\"\"\n    req = ajax.ajax()\n    req.bind('complete', on_complete)\n    req.open('POST', url, True)\n    req.set_header('content-type', 'application/x-www-form-urlencoded')\n    req.send(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters the function to react only to ENTER.", "response": "def func_on_enter(func):\n    \"\"\"\n    Register the `func` as a callback reacting only to ENTER.\n\n    Note:\n        This function doesn't bind the key to the element, just creates sort of\n        filter, which ignores all other events.\n    \"\"\"\n    def function_after_enter_pressed(ev):\n        ev.stopPropagation()\n\n        # if the key was `enter` ..\n        if ev.keyCode == 13:\n            func(ev)\n\n    return function_after_enter_pressed"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the number of seconds elapsed since object creation or last call to this function.", "response": "def get(self):\n        \"\"\"Return the number of seconds elapsed since object creation,\n        or since last call to this function, whichever is more recent.\"\"\"\n        elapsed = datetime.now() - self._previous\n        self._previous += elapsed\n        return elapsed.total_seconds()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating and register a new connection.", "response": "def register_connection(self, alias, api_key, base_url, timeout=5):\n        \"\"\"\n        Create and register a new connection.\n\n        :param alias:   The alias of the connection. If not changed with `switch_connection`,\n                        the connection with default 'alias' is used by the resources.\n        :param api_key: The private api key.\n        :param base_url: The api url including protocol, host, port (optional) and location.\n        :param timeout: The time in seconds to wait for 'connect' and 'read' respectively.\n                        Use a tuple to set these values separately or None to wait forever.\n        :return:\n        \"\"\"\n        if not base_url.endswith('/'):\n            base_url += '/'\n\n        self._connections[alias] = Connection(api_key, base_url, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cformat(msg, reset=True, template=ColorTemplate):\n    ct = ColorTemplate(msg)\n    m = ct.safe_substitute(ANSI_STRING_MAP)\n\n    if reset:\n        m += ANSI_STRING_MAP['RESET;']\n\n    return m", "response": "Transform msg so that ANSI escape codes are mapped to the ANSI escape codes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_xml_node(self, node):\n        '''Parse an xml.dom Node object representing an execution context into\n        this object.\n\n        '''\n        self.id = node.getAttributeNS(RTS_NS, 'id')\n        self.kind = node.getAttributeNS(RTS_NS, 'kind')\n        if node.hasAttributeNS(RTS_NS, 'rate'):\n            self.rate = float(node.getAttributeNS(RTS_NS, 'rate'))\n        else:\n            self.rate = 0.0\n        self._participants = []\n        for c in node.getElementsByTagNameNS(RTS_NS, 'Participants'):\n            self._participants.append(TargetComponent().parse_xml_node(c))\n        for c in get_direct_child_elements_xml(node, prefix=RTS_EXT_NS,\n                                               local_name='Properties'):\n            name, value = parse_properties_xml(c)\n            self._properties[name] = value\n        return self", "response": "Parse an xml. dom Node object representing an execution context into this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a YAML spefication of an execution context into this object.", "response": "def parse_yaml(self, y):\n        '''Parse a YAML spefication of an execution context into this\n        object.\n\n        '''\n        self.id = y['id']\n        self.kind = y['kind']\n        if 'rate' in y:\n            self.rate = float(y['rate'])\n        else:\n            self.rate = 0.0\n        self._participants = []\n        if 'participants' in y:\n            for p in y.get('participants'):\n                self._participants.append(TargetComponent().parse_yaml(p))\n        if RTS_EXT_NS_YAML + 'properties' in y:\n            for p in y.get(RTS_EXT_NS_YAML + 'properties'):\n                if 'value' in p:\n                    value = p['value']\n                else:\n                    value = None\n                self._properties[p['name']] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_xml(self, doc, element):\n        '''Save this execution context into an xml.dom.Element object.'''\n        element.setAttributeNS(XSI_NS, XSI_NS_S + 'type', 'rtsExt:execution_context_ext')\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'id', self.id)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'kind', self.kind)\n        element.setAttributeNS(RTS_NS, RTS_NS_S + 'rate', str(self.rate))\n        for p in self.participants:\n            new_element = doc.createElementNS(RTS_NS,\n                                              RTS_NS_S + 'Participants')\n            p.save_xml(doc, new_element)\n            element.appendChild(new_element)\n        for p in self.properties:\n            new_prop_element = doc.createElementNS(RTS_EXT_NS,\n                                                   RTS_EXT_NS_S + 'Properties')\n            properties_to_xml(new_prop_element, p, self.properties[p])\n            element.appendChild(new_prop_element)", "response": "Save this execution context into an xml. dom. Element object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self):\n        '''Save this execution context into a dictionary.'''\n        d = {'id': self.id,\n                'kind': self.kind}\n        if self.rate != 0.0:\n            d['rate'] = self.rate\n        participants = []\n        for p in self.participants:\n            participants.append(p.to_dict())\n        if participants:\n            d['participants'] = participants\n        props = []\n        for name in self.properties:\n            p = {'name': name}\n            if self.properties[name]:\n                p['value'] = str(self.properties[name])\n            props.append(p)\n        if props:\n            d[RTS_EXT_NS_YAML + 'properties'] = props\n        return d", "response": "Save this execution context into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef alphanum_key(string):\n    convert = lambda text: int(text) if text.isdigit() else text\n    return [convert(segment) for segment in re.split('([0-9]+)', string)]", "response": "Return a comparable tuple with extracted number segments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a clone of the SQLA object.", "response": "def clone(item, exclude=None, update=None):\n    \"\"\"Return a clone of the SQLA object.\n\n    :param item: The SQLA object to copy the attributes from.\n    :param exclude: If provided, should be an iterable that contains the names\n        attributes to exclude from the copy. The attributes `created_at` and\n        `id` are always excluded.\n    :param update: If provided, should be a mapping of attribute name, to the\n        value that should be set.\n\n    \"\"\"\n    # Prepare attribute exclusion set\n    if not exclude:\n        exclude = set()\n    if not isinstance(exclude, set):\n        exclude = set(exclude)\n    exclude.update(('created_at', 'id'))\n    # Build a mapping of attributes to values\n    attrs = {x: getattr(item, x) for x in item.__mapper__.columns.keys()\n             if x not in exclude}\n    if update:  # Update the mapping if necessary\n        attrs.update(update)\n    # Build and return the SQLA object\n    return item.__class__(**attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch the items from the list of item_ids.", "response": "def fetch_request_ids(item_ids, cls, attr_name, verification_list=None):\n    \"\"\"Return a list of cls instances for all the ids provided in item_ids.\n\n    :param item_ids: The list of ids to fetch objects for\n    :param cls: The class to fetch the ids from\n    :param attr_name: The name of the attribute for exception purposes\n    :param verification_list: If provided, a list of acceptable instances\n\n    Raise InvalidId exception using attr_name if any do not\n        exist, or are not present in the verification_list.\n\n    \"\"\"\n    if not item_ids:\n        return []\n    items = []\n    for item_id in item_ids:\n        item = cls.fetch_by_id(item_id)\n        if not item or (verification_list is not None and\n                        item not in verification_list):\n            raise InvalidId(attr_name)\n        items.append(item)\n    return items"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nestablishing the connection to rabbitmq.", "response": "def get_queue_func(request):\n    \"\"\"Establish the connection to rabbitmq.\"\"\"\n    def cleanup(request):\n        conn.close()\n\n    def queue_func(**kwargs):\n        return conn.channel().basic_publish(\n            exchange='', body=json.dumps(kwargs), routing_key=queue,\n            properties=pika.BasicProperties(delivery_mode=2))\n    server = request.registry.settings['queue_server']\n    queue = request.registry.settings['queue_verification']\n    conn = pika.BlockingConnection(pika.ConnectionParameters(host=server))\n    request.add_finished_callback(cleanup)\n    return queue_func"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prev_next_group(project, group):\n    # TODO: Profile and optimize this query if necessary\n    groups = sorted(x for x in project.groups if x.submissions)\n    try:\n        index = groups.index(group)\n    except ValueError:\n        return None, None\n    prev_group = groups[index - 1] if index > 0 else None\n    next_group = groups[index + 1] if index + 1 < len(groups) else None\n    return prev_group, next_group", "response": "Return adjacent group objects or None for the given project and group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare_renderable(request, test_case_result, is_admin):\n    test_case = test_case_result.test_case\n    file_directory = request.registry.settings['file_directory']\n    sha1 = test_case_result.diff.sha1 if test_case_result.diff else None\n    kwargs = {'number': test_case.id, 'group': test_case.testable.name,\n              'name': test_case.name, 'points': test_case.points,\n              'status': test_case_result.status,\n              'extra': test_case_result.extra}\n\n    if test_case.output_type == 'image':\n        url = request.route_path('file_item', filename='_', _query={'raw': 1},\n                                 sha1sum=sha1) if sha1 else None\n        return ImageOutput(url=url, **kwargs)\n    elif test_case.output_type == 'text':\n        content = None\n        if sha1:\n            with open(File.file_path(file_directory, sha1)) as fp:\n                content = fp.read()\n        return TextOutput(content=content, **kwargs)\n    elif not test_case_result.diff:  # Outputs match\n        return DiffWithMetadata(diff=None, **kwargs)\n\n    try:\n        with open(File.file_path(file_directory, sha1)) as fp:\n            diff = pickle.load(fp)\n    except (AttributeError, EOFError):\n        content = 'submit system mismatch -- requeue submission'\n        content += traceback.format_exc(1)\n        return TextOutput(content=content, **kwargs)\n    except Exception:\n        content = 'unexected error -- requeue submission\\n'\n        content += traceback.format_exc(1)\n        return TextOutput(content=content, **kwargs)\n\n    diff.hide_expected = not is_admin and test_case.hide_expected\n    return DiffWithMetadata(diff=diff, **kwargs)", "response": "Return a completed Renderable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef zip_response(request, filename, files):\n    tmp_file = NamedTemporaryFile()\n    try:\n        with ZipFile(tmp_file, 'w') as zip_file:\n            for zip_path, actual_path in files:\n                zip_file.write(actual_path, zip_path)\n        tmp_file.flush()  # Just in case\n        response = FileResponse(tmp_file.name, request=request,\n                                content_type=str('application/zip'))\n        response.headers['Content-disposition'] = ('attachment; filename=\"{0}\"'\n                                                   .format(filename))\n        return response\n    finally:\n        tmp_file.close()", "response": "Returns a Response object that is a zipfile with name filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef zip_response_adv(request, filename, files):\n    tmp_file = NamedTemporaryFile()\n    try:\n        with ZipFile(tmp_file, 'w') as zip_file:\n            for type, zip_path, actual in files:\n                if type == \"file\":\n                    zip_file.write(actual, zip_path)\n                else:\n                    zip_file.writestr(zip_path, actual)\n        tmp_file.flush()  # Just in case\n        response = FileResponse(tmp_file.name, request=request,\n                                content_type=str('application/zip'))\n        response.headers['Content-disposition'] = ('attachment; filename=\"{0}\"'\n                                                   .format(filename))\n        return response\n    finally:\n        tmp_file.close()", "response": "Return a Response object that is a zipfile with name filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the object if valid and available otherwise None.", "response": "def run(self, value, errors, request):\n        \"\"\"Return the object if valid and available, otherwise None.\"\"\"\n        value = self.id_validator(value, errors, request)\n        if errors:\n            return None\n        if self.fetch_by:\n            thing = self.cls.fetch_by(**{self.fetch_by: value})\n        else:\n            thing = self.cls.fetch_by_id(value)\n        if not thing and self.source == SOURCE_MATCHDICT:\n            # If part of the URL we should have a not-found error\n            raise HTTPNotFound()\n        elif not thing:\n            self.add_error(errors, 'Invalid {0}'\n                           .format(self.cls.__name__))\n        return thing"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, value, errors, request):\n        thing = super(AccessibleDBThing, self).run(value, errors, request)\n        if errors:\n            return None\n        if not thing.can_access(request.user):\n            message = 'Insufficient permissions for {0}'.format(self.param)\n            raise HTTPForbidden(message)\n        return thing", "response": "Return thing but abort validation if request. user cannot edit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, value, errors, request):\n        thing = super(EditableDBThing, self).run(value, errors, request)\n        if errors:\n            return None\n        if not thing.can_edit(request.user):\n            message = 'Insufficient permissions for {0}'.format(self.param)\n            raise HTTPForbidden(message)\n        return thing", "response": "Return thing but abort validation if request. user cannot edit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning thing but abort validation if request. user cannot view.", "response": "def run(self, value, errors, request):\n        \"\"\"Return thing, but abort validation if request.user cannot view.\"\"\"\n        thing = super(ViewableDBThing, self).run(value, errors, request)\n        if errors:\n            return None\n        if not thing.can_view(request.user):\n            message = 'Insufficient permissions for {0}'.format(self.param)\n            raise HTTPForbidden(message)\n        return thing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tupletize_version(version_string):\n    '''\n    Given \"1.2.3-6\" returns a tuple of (1, 2, 3, 6).\n    This is used for sorting versions.\n    '''\n    return tuple(int(x) for x in re.findall(r'[0-9]+', version_string))", "response": "Given \"1.2.3-6\" returns a tuple of (1, 2, 3, 6).\n    This is used for sorting versions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef define_standalone_options(parser, extra_options=None):\n    '''\n    Adds the options specific to the database connection.\n    Parses the agency configuration files and uses its configuration as the\n    default values.\n    '''\n    c = config.parse_service_config()\n\n    parser.add_option('--dbhost', '-H', action='store', dest='db_host',\n                      type='str', help='hostname of the database',\n                      default=c.db.host)\n    parser.add_option('--dbname', '-n', action='store', dest='db_name',\n                      type='str', help='name of database to use',\n                      default=c.db.name)\n    parser.add_option('--dbport', '-P', action='store', dest='db_port',\n                      type='str', help='port of database to use',\n                      default=c.db.port)\n    parser.add_option('--dbusername', dest=\"db_username\",\n                      help=\"username to use for authentication \",\n                      metavar=\"USER\", default=c.db.username)\n    parser.add_option('--dbpassword', dest=\"db_password\",\n                      help=\"password to use for authentication \",\n                      metavar=\"PASSWORD\", default=c.db.password)\n    parser.add_option('--ssl', '-S', action='store_true', dest='db_https',\n                      help='whether to use SSL db connections',\n                      default=False)\n\n    parser.add_option('--log', action='store', dest='log',\n                      type='str', help='log level to set',\n                      default=os.environ.get('FEAT_DEBUG', '2'))\n\n    if extra_options:\n        for option in extra_options:\n            parser.add_option(option)\n    return parser", "response": "Define the standalone options for the agency command line parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the header to prevent sites under herokuapp. com from being indexed.", "response": "def process_response(self, request, response):\n        \"\"\"\n        Add the header to prevent sites under *.herokuapp.com from being indexed.\n        \"\"\"\n        http_host = request.get_host()\n\n        if http_host and 'herokuapp' in http_host:\n            response['X-Robots-Tag'] = 'noindex, nofollow'\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_config_dirs():\n    config_dirs = [\n        USER_CONFIG_DIR,\n        os.path.join(\"/\", \"etc\", \"rapport\"),\n        os.path.abspath(os.path.join(\"rapport\", \"config\"))\n    ]\n    return config_dirs", "response": "Return a list of directories where config files may be located."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_config_files():\n\n    config_files = []\n\n    for config_dir in _get_config_dirs():\n        path = os.path.join(config_dir, \"rapport.conf\")\n        if os.path.exists(path):\n            config_files.append(path)\n\n    return list(filter(bool, config_files))", "response": "Return a list of default configuration files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate and populate the ~. config directory tree if it s not existing.", "response": "def init_user():\n    \"\"\"Create and populate the ~/.config/rapport directory tree if it's not existing.\n\n    Doesn't interfere with already existing directories or configuration files.\n    \"\"\"\n    if not os.path.exists(USER_CONFIG_DIR):\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n            print(\"Create user directory {0}\".format(USER_CONFIG_DIR))\n        os.makedirs(USER_CONFIG_DIR)\n    for subdir in [\"plugins\", \"reports\", \"templates/plugin\", \"templates/email\", \"templates/web\"]:\n        user_conf_subdir = os.path.join(USER_CONFIG_DIR, subdir)\n        if not os.path.exists(user_conf_subdir):\n            if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n                print(\"Create user directory {0}\".format(user_conf_subdir))\n            os.makedirs(user_conf_subdir)\n        if subdir == \"reports\" and not (os.stat(user_conf_subdir).st_mode & 0o777) == 0o700:\n            if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n                print(\"Set secure directory permissions for {0}\".format(user_conf_subdir))\n            os.chmod(user_conf_subdir, 0o700)\n    if not os.path.exists(USER_CONFIG_FILE):\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n            print(\"Create user configuration {0}\".format(USER_CONFIG_FILE))\n        default_config = os.path.abspath(os.path.join(os.path.splitext(__file__)[0], \"rapport.conf\"))\n        shutil.copyfile(default_config, USER_CONFIG_FILE)\n\n    if not (os.stat(USER_CONFIG_FILE).st_mode & 0o777) == 0o600:\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n            print(\"Set secure file permissions for {0}\".format(USER_CONFIG_FILE))\n        os.chmod(USER_CONFIG_FILE, 0o600)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_version(package_name, version_file='_version.py'):\n    filename = os.path.join(os.path.dirname(__file__), package_name, version_file)\n    with open(filename, 'rb') as fp:\n        return fp.read().decode('utf8').split('=')[1].strip(\" \\n'\")", "response": "Retrieve the package version from a version file in the package root."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads content of the file containing keyword informations in JSON. File is packed using BZIP.", "response": "def read_kw_file():\n    \"\"\"\n    Read content of the file containing keyword informations in JSON. File is\n    packed using BZIP.\n\n    Returns:\n        list: List of dictionaries containing keywords.\n    \"\"\"\n    self_path = os.path.dirname(__file__)\n    kw_list_path = join(self_path, \"../templates/keyword_list.json.bz2\")\n\n    with bz2.BZ2File(kw_list_path) as f:\n        kw_list = f.read()\n\n    return json.loads(kw_list)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_kw_dict(kw_list):\n    kw_dict = OrderedDict()\n    sorted_list = sorted(\n        kw_list,\n        key=lambda x: x.get(\"zahlavi\").encode(\"utf-8\")\n    )\n\n    for keyword_data in sorted_list:\n        if \"zahlavi\" not in keyword_data:\n            continue\n\n        zahlavi = keyword_data[\"zahlavi\"].encode(\"utf-8\")\n        old_record = kw_dict.get(zahlavi)\n\n        if not old_record:\n            kw_dict[zahlavi] = keyword_data\n            continue\n\n        key = \"angl_ekvivalent\"\n        if not old_record.get(key) and keyword_data.get(key):\n            kw_dict[zahlavi] = keyword_data\n            continue\n\n        key = \"zdroj_angl_ekvivalentu\"\n        if not old_record.get(key) and keyword_data.get(key):\n            kw_dict[zahlavi] = keyword_data\n            continue\n\n        if len(str(keyword_data)) > len(str(old_record)):\n            kw_dict[zahlavi] = keyword_data\n            continue\n\n    return kw_dict", "response": "Build keyword dictionary from raw keyword data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing all global variables.", "response": "def init():\n    \"\"\"\n    Initialize all global variables (:attr:`.KW_DICT`, :attr:`.KEYWORDS`,\n    :attr:`.KEYWORDS_LOWER`, :attr:`.KW_CACHE_PATH`) to their values.\n\n    Global variables are then used from analyzers and so on.\n    \"\"\"\n    global _INITIALIZED\n\n    if _INITIALIZED:\n        return\n\n    global KW_DICT\n    global KEYWORDS\n    global KW_CACHE_PATH\n    global KEYWORDS_LOWER\n\n    KW_DICT = build_kw_dict(read_kw_file())\n    KEYWORDS = sorted([k.decode(\"utf-8\") for k in KW_DICT.keys()])\n    KEYWORDS_LOWER = {\n        k.lower(): k\n        for k in KEYWORDS\n    }\n    keywords_json = json.dumps(KEYWORDS)\n    KW_CACHE_PATH = \"/tmp/wa_kat_cache_keywords.json\"\n\n    # create cached files\n    with open(KW_CACHE_PATH, \"w\") as f:\n        f.write(keywords_json)\n    with open(KW_CACHE_PATH + \".gz\", \"w\") as f:\n        to_gzipped_file(keywords_json, out=f)\n\n    _INITIALIZED = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_extension(path):\n    filename = os.path.basename(path)\n    parts = filename.split(\".\")\n    if len(parts) == 1:\n        return filename, None\n    else:\n        return \".\".join(parts[:-1]), parts[-1]", "response": "Reads a file path and returns the extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_path(path_or_f):\n    if hasattr(path_or_f, \"read\"):\n        return path_or_f\n    else:\n        path = path_or_f\n\n    path = os.path.expanduser(path)\n\n    # Check if exists and is a file\n    if os.path.isdir(path):\n        raise IsADirectoryError(\"Is a directory: {0}\".format(path))\n    elif not os.path.isfile(path):\n        raise FileNotFoundError(\"No such file: {0}\".format(path))\n\n    _, extension = extract_extension(path)\n\n    if extension not in FILE_READERS:\n        raise FileTypeError(\"Extension {0} is not supported.\"\n                            .format(repr(extension)))\n\n    return path", "response": "Normalizes a dump file or file at a given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a file - like object of the nacite_cache. xml file.", "response": "def reader(path_or_f):\n    \"\"\"\n    Turns a path to a compressed file into a file-like object of (decompressed)\n    data.\n\n    :Parameters:\n        path : `str`\n            the path to the dump file to read\n    \"\"\"\n    if hasattr(path_or_f, \"read\"):\n        return path_or_f\n    else:\n        path = path_or_f\n\n    path = normalize_path(path)\n    _, extension = extract_extension(path)\n\n    reader_func = FILE_READERS[extension]\n\n    return reader_func(path)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef writer(path):\n    filename, extension = extract_extension(path)\n    if extension in FILE_WRITERS:\n        writer_func = FILE_WRITERS[extension]\n        return writer_func(path)\n    else:\n        raise RuntimeError(\"Output compression {0} not supported.  Type {1}\"\n                           .format(extension, tuple(FILE_WRITERS.keys())))", "response": "Creates a compressed file writer from a specified path with a specified\n    compression type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the x and y position of the window.", "response": "def position(self):\n        \"\"\"Tuple[int, int]: The x and y position of the window.\"\"\"\n        position = ffi.new('int[]', 2)\n        lib.SDL_GetWindowPosition(self._ptr, position + 0, position + 1)\n        return (position[0], position[1])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef size(self):\n        size = ffi.new('int[]', 2)\n        lib.SDL_GetWindowSize(self._ptr, size + 0, size + 1)\n        return (size[0], size[1])", "response": "Tuple[int int ] : The width and height of the window."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the size of the desktop display", "response": "def get_desktop_size(self):\n        \"\"\"Get the size of the desktop display\"\"\"\n\n        _ptr = ffi.new('SDL_DisplayMode *')\n        check_int_err(lib.SDL_GetDesktopDisplayMode(self._index, _ptr))\n        return (_ptr.w, _ptr.h)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating that passed params are valid.", "response": "def validate_params(bits, arguments_count, keyword_positions):\n    '''\n        Raises exception if passed params (`bits`) do not match signature.\n        Signature is defined by `arguments_count` (acceptible number of params) and\n        keyword_positions (dictionary with positions in keys and keywords in values,\n        for ex. {2:'by', 4:'of', 5:'type', 7:'as'}).            \n    '''    \n    \n    if len(bits) != arguments_count+1:\n        raise InvalidParamsError(\"'%s' tag takes %d arguments\" % (bits[0], arguments_count,))\n    \n    for pos in keyword_positions:\n        value = keyword_positions[pos]\n        if bits[pos] != value:\n            raise InvalidParamsError(\"argument #%d to '%s' tag must be '%s'\" % (pos, bits[0], value))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef TAF_datetime_to_datetime_object(\n    datetime_string             = None,\n    datetime_for_year_and_month = None  # e.g. datetime.datetime.utcnow()\n    ):\n\n    \"\"\"\n    Preprocess datetimes to change hours from 24 to 00, incrementing the date\n    as necessary.\n    \"\"\"\n\n    if datetime_string.endswith(\"24\"):\n\n        datetime_string = datetime_string[:-2] + \"00\"\n\n        tmp = datetime.datetime.strptime(datetime_string, \"%d%H\") +\\\n              datetime.timedelta(days = 1)\n\n    else:\n\n        tmp = datetime.datetime.strptime(datetime_string, \"%d%H\")\n\n    return datetime.datetime(\n        datetime_for_year_and_month.year,\n        datetime_for_year_and_month.month,\n        tmp.day,\n        tmp.hour,\n        tmp.minute\n    )", "response": "Convert a TAF datetime string to a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix where possible.\n        '''\n        # The N bit is the nonce-present bit.  When this bit is set to 1,\n        # the low-order 24-bits of the first 32-bits of the LISP header\n        # contains a Nonce.  See Section 6.3.1 for details.  Both N and V\n        # bits MUST NOT be set in the same packet.  If they are, a\n        # decapsulating ETR MUST treat the \"Nonce/Map-Version\" field as\n        # having a Nonce value present.\n        if self.nonce is not None and (not isinstance(self.nonce, bytes) or\n                                       len(self.nonce) != 3):\n            raise ValueError('Nonce must be a None or a sequence of 3 bytes')\n\n        if self.nonce is not None \\\n        and (self.source_map_version is not None or\n             self.destination_map_version is not None):\n            raise ValueError('Cannot have both a nonce and map versions')\n\n        # The L bit is the Locator Status Bits field enabled bit.  When this\n        # bit is set to 1, the Locator Status Bits in the second 32-bits of\n        # the LISP header are in use.\n        if self.lsb is not None:\n            # Determine how many bits we expect\n            if self.instance_id is not None:\n                lsb_bits = 8\n            else:\n                lsb_bits = 32\n\n            # Check if LSBs is a sequence of booleans of the right length\n            if not isinstance(self.lsb, collections.Sequence) \\\n            or len(self.lsb) != lsb_bits \\\n            or any(map(lambda v: type(v) != bool, self.lsb)):\n                raise ValueError('Invalid locator status bits')\n\n        # The E bit is the echo-nonce-request bit.  This bit MUST be ignored\n        # and has no meaning when the N bit is set to 0.  When the N bit is\n        # set to 1 and this bit is set to 1, means an ITR is requesting for\n        # the nonce value in the Nonce field to be echoed back in LISP\n        # encapsulated packets when the ITR is also an ETR.  See\n        # Section 6.3.1 for details.\n        if not isinstance(self.echo_nonce_request, bool):\n            raise ValueError('Echo-Nonce-Request flag must be a boolean')\n\n        if self.echo_nonce_request and self.nonce is None:\n            self.echo_nonce_request = False\n\n        # The V bit is the Map-Version present bit.  When this bit is set to\n        # 1, the N bit MUST be 0.  Refer to Section 6.6.3 for more details.\n        if self.source_map_version is not None \\\n        or self.destination_map_version is not None:\n            if not isinstance(self.source_map_version, numbers.Integral) \\\n            or self.source_map_version < 0 \\\n            or self.source_map_version >= 2 ** 12:\n                raise ValueError('Invalid source map version')\n\n            if not isinstance(self.destination_map_version, numbers.Integral) \\\n            or self.destination_map_version < 0 \\\n            or self.destination_map_version >= 2 ** 12:\n                raise ValueError('Invalid destination map version')\n\n        # The I bit is the Instance ID bit.  See Section 5.5 for more\n        # details.  When this bit is set to 1, the Locator Status Bits field\n        # is reduced to 8-bits and the high-order 24-bits are used as an\n        # Instance ID.  If the L-bit is set to 0, then the low-order 8 bits\n        # are transmitted as zero and ignored on receipt.\n        if self.instance_id is not None:\n            if not isinstance(self.instance_id, numbers.Integral) \\\n            or self.instance_id < 0 \\\n            or self.instance_id >= 2 ** 24:\n                raise ValueError('Invalid instance id')", "response": "Sanitize the current settings of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_bytes(cls, bitstream, decode_payload=True):\n        r'''\n        Parse the given packet and update properties accordingly\n\n        >>> data_hex = ('c033d3c10000000745c0005835400000'\n        ...             'ff06094a254d38204d45d1a30016f597'\n        ...             'a1c3c7406718bf1b50180ff0793f0000'\n        ...             'b555e59ff5ba6aad33d875c600fd8c1f'\n        ...             'c5268078f365ee199179fbd09d09d690'\n        ...             '193622a6b70bcbc7bf5f20dda4258801')\n        >>> data = data_hex.decode('hex')\n        >>> message = DataPacket.from_bytes(data)\n        >>> message.echo_nonce_request\n        False\n        >>> message.nonce\n        '3\\xd3\\xc1'\n        >>> message.source_map_version\n        >>> message.destination_map_version\n        >>> message.lsb\n        ... # doctest: +ELLIPSIS\n        [True, True, True, False, False, ..., False, False, False, False]\n        >>> message.instance_id\n        >>> bytes(message.payload)\n        ... # doctest: +ELLIPSIS\n        'E\\xc0\\x00X5@\\x00\\x00\\xff\\x06\\tJ%M8...\\xdd\\xa4%\\x88\\x01'\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the flags\n        (nonce_present,\n         lsb_enabled,\n         packet.echo_nonce_request,\n         map_version_present,\n         instance_id_present) = bitstream.readlist('5*bool')\n\n        # Skip over reserved bits\n        bitstream.read(3)\n\n        # Parse nonce or map versions\n        if nonce_present:\n            # Nonce: yes, versions: no\n            packet.nonce = bitstream.read('bytes:3')\n            packet.source_map_version = None\n            packet.destination_map_version = None\n        elif map_version_present:\n            # Nonce: no, versions: yes\n            packet.nonce = None\n            (packet.source_map_version,\n             packet.destination_map_version) = bitstream.readlist('2*uint:12')\n        else:\n            # Nonce: no, versions: no\n            packet.nonce = None\n            packet.source_map_version = None\n            packet.destination_map_version = None\n\n            # Skip over the nonce/map-version bits\n            bitstream.read(24)\n\n        # Parse instance-id\n        if instance_id_present:\n            packet.instance_id = bitstream.read('uint:24')\n\n            # 8 bits remaining for LSB\n            lsb_bits = 8\n        else:\n            # 32 bits remaining for LSB\n            lsb_bits = 32\n\n        # Parse LSBs\n        if lsb_enabled:\n            packet.lsb = bitstream.readlist('%d*bool' % lsb_bits)\n\n            # Reverse for readability: least significant locator-bit first\n            packet.lsb.reverse()\n        else:\n            # Skip over the LSBs\n            bitstream.read(lsb_bits)\n\n        # The rest of the packet is payload\n        remaining = bitstream[bitstream.pos:]\n\n        # Parse IP packet\n        if len(remaining):\n            ip_version = remaining.peek('uint:4')\n            if ip_version == 4:\n                packet.payload = IPv4Packet.from_bytes(remaining, decode_payload=decode_payload)\n            elif ip_version == 6:\n                packet.payload = IPv6Packet.from_bytes(remaining, decode_payload=decode_payload)\n            else:\n                packet.payload = remaining.bytes\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "r Returns a new instance of the class from the given byte stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef api_url(self):\n        '''return the api url of this request'''\n        return pathjoin(Request.path, self.id, url=self.bin.api_url)", "response": "return the api url of this request"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists out the directories in the install location", "response": "def repo_dirlist():\n    \"\"\"List out the directories in the install location(s)\n    :return:\n    :rtype:\n    \"\"\"\n\n    for d in os.listdir(settings.upkg_destdir):\n        dp = os.path.join(settings.upkg_destdir, d)\n        # logger.debug(\"%s\", dp)\n        if os.path.isdir(dp) and d[0] != '.':\n            # logger.debug(\"adding %s\", dp)\n            yield {'base': d, 'root': settings.upkg_destdir,\n                   'path': dp}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef did_u_mean(name):\n    logger.debug(\"%s\", name)\n\n    dlist = Repo.installed_list()\n    res = []\n    for d in dlist:\n        if name in d.name or d.name in name:\n            res.append(nice_pkg_name(d.name))\n    # end for d in dlist\n\n    if res:\n        return \"Did you mean '\" + \" or \".join(res) + \"'?\"\n\n    return \"\"", "response": "todo - Docstring for did_u_mean\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the file with the given package name", "response": "def pkg_name_to_path(pkgname):\n    \"\"\"todo: Docstring for pkg_name_to_path\n\n    :param pkgname: arg description\n    :type pkgname: type description\n    :return:\n    :rtype:\n    \"\"\"\n\n    logger.debug(\"'%s'\", pkgname)\n\n    fp = os.path.join(settings.upkg_destdir, pkgname)\n    if os.path.isdir(fp):\n        logger.debug(\"found %s\", fp)\n        return fp\n\n    # Try to find the repo dir if just needs an extension\n    for d in repo_dirlist():\n        logger.debug(\"trying %s\", d)\n        if d['base'].startswith(pkgname):\n            # logger.debug(\"startwith\")\n            root, ext = os.path.splitext(d['base'])\n            if pkgname == root:\n                logger.debug(\"found %s\", d)\n                return d['path']\n    # end for d in dlist\n\n    logger.debug(\"found nothing\")\n    return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn name in nice format", "response": "def nice_pkg_name(name):\n    \"\"\"todo: Docstring for nice_pkg_name\n\n    :param name: arg description\n    :type name: type description\n    :return:\n    :rtype:\n    \"\"\"\n    logger.debug(\"%s\", name)\n\n    root, ext = os.path.splitext(name)\n    logger.debug(\"root :'%s', ext: '%s'\", root, ext)\n\n    if ext in ugly_ext:\n        logger.debug(\"remove ext %s to get %s\", ext, root)\n        return root\n\n    logger.debug(\"no change %s\", name)\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef installed_list(cls):\n        logger.debug(\"\")\n\n        res = []\n        for x in repo_dirlist():\n            d = x['path']\n            try:\n                res.append(Repo(repo_dir=d, name=x['base']))\n            except InvalidRepo:\n                logger.warning(\"Invalid repo '%s' in the installation directory.\", d)\n\n        return res", "response": "todo - Docstring for list\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncloning the current repository into the repo_dir", "response": "def clone(self):\n        \"\"\"todo: Docstring for clone\n        :return:\n        :rtype:\n        \"\"\"\n        logger.debug(\"\")\n    \n        if not self.url:\n            estr = \"Cannot install this repos without a URL. %s\" % self.info()\n            logger.warning(estr)\n            raise ValueError(estr)\n\n        # check if the already exists, if so, don't install, update it?\n        url = urlparse(self.url)\n        url_path = url[2]\n        path_end = url_path.split('/')\n        path_end = path_end[len(path_end) - 1]\n\n        if url.scheme not in self.supported_schemes:\n            raise ValueError(\"Unsupported scheme '{}' for {}\".format(url.scheme, self.url))\n\n        assert self.repo_dir, \"Invalid repo directory.\"\n\n        # Clone it.\n        logger.debug(\"cloning %s into %s .\", self.url, self.repo_dir)\n        self.pr_pass(\"\\nInstalling %s ... \" % self.url)\n\n        p = git.clone('--progress', self.url, self.repo_dir,\n                      _out=self._sh_stdout('blue'), _err=self._sh_stderr('blue'))\n        p.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninstalls update dependencies for this item", "response": "def install_update_deps(self):\n        \"\"\"todo: Docstring for install_update_deps\n        :return:\n        :rtype:\n        \"\"\"\n        logger.debug(\"\")\n        self._ctx.installed(self.name)\n\n        # are there any dependencies?\n        depfile = os.path.join(self.repo_dir, '_upkg', 'depends')\n        logger.debug(\"depfile? %s\", depfile)\n        if os.path.exists(depfile):\n            logger.debug(\"Found depends file at %s\", depfile)\n            deps = open(depfile, 'r')\n            dep = deps.readline()\n            while dep:\n                dep = dep.strip()\n                logger.debug(\"depends: %s\", dep)\n                self._ctx.add_dep(nice_pkg_name(os.path.basename(dep)), dep)\n                dep = deps.readline()\n            deps.close()\n\n        for rep in self._ctx.deps_needed:\n            repo = Repo(url=rep)\n            if repo.installed:\n                repo.update()\n            else:\n                repo.install()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef install(self):\n        logger.debug(\"\")\n\n        # If we're already installed, don't do anything.\n        if self.installed:\n            self.pr_info(\"pkg {} is already installed. Perhaps you want to update it?\",\n                    self.name)\n            return\n\n        self.clone()\n        self.install_update_deps()\n\n        logger.debug(\"Checking for install script\")\n\n        inst = os.path.join(self.repo_dir, '_upkg', 'install')\n        if os.path.exists(inst):\n            cwd = os.getcwd()\n            logger.debug(\"chdir to %s\", os.path.join(self.repo_dir, '_upkg'))\n            logger.debug(\"install script is %s\", inst)\n            self.pr_info(\"Running install script at {}\", inst)\n            logger.debug(\"runnin script %s\", inst)\n            # We use subprocess instead of the sh module due to problems with\n            # runing shell scripts with sh\n            os.chdir(os.path.join(self.repo_dir, '_upkg'))\n            subprocess.check_call(inst, shell=True)\n            os.chdir(cwd)\n            self.pr_pass(\"install script finished\")", "response": "install the pkg into the repository"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self):\n        logger.debug(\"\")\n\n        rd = self.repo_dir\n\n        logger.debug(\"pkg path %s\", rd)\n        if not rd:\n            print(\n                \"unable to find pkg '%s'. %s\" % (self.name, did_u_mean(self.name))\n            )\n            return\n\n        # Does the repo have any uncommitted changes?\n        # Is the repo out of sync(needs a push?)\n\n        # Are you sure?\n        resp = input(self.term.red(\"Are you sure you want to remove the '%s' pkg? [y|N] \" %\n                                   self.name))\n\n        if resp == 'y' or resp == 'yes':\n            self.pr_atten('removing {}...', self.name)\n            shutil.rmtree(rd)", "response": "todo remove the pkg?"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self):\n        logger.debug(\"\")\n\n        rd = self.repo_dir\n\n        logger.debug(\"pkg path %s\", rd)\n        if not rd:\n            print(\n                \"unable to find pkg '%s'. %s\" % (self.name, did_u_mean(self.name))\n            )\n\n        cwd = os.getcwd()\n        os.chdir(self.repo_dir)\n        logger.debug(\"cwd: %s, updating %s \", cwd, self.repo_dir)\n        try:\n            p = git.pull('--rebase', '--progress',\n                         _out=self._sh_stdout('blue'),\n                         _err=self._sh_stderr('red'))\n            p.wait()\n        except Exception as e:\n            pass\n            # logger.warn(e)\n\n        os.chdir(cwd)\n\n        # Update or install any dependancies before running the\n        # update script.\n        self.install_update_deps()\n\n        up = os.path.join(self.repo_dir, '_upkg', 'update')\n        if os.path.exists(up):\n            # We use subprocess instead of the sh module due to problems with\n            # runing shell scripts with sh\n            cwd = os.getcwd()\n            os.chdir(os.path.join(self.repo_dir, '_upkg'))\n            self.pr_info(\"Running update script for {} @ {}\", self.name, up)\n            subprocess.check_call(up, shell=True)\n            os.chdir(cwd)", "response": "Update the internal cache for the current package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting status on the repo.", "response": "def status(self):\n        \"\"\"Get status on the repo.\n        :return:\n        :rtype:\n        \"\"\"\n\n        rd = self.repo_dir\n\n        logger.debug(\"pkg path %s\", rd)\n        if not rd:\n            print(\n                \"unable to find pkg '%s'. %s\" % (self.name, did_u_mean(self.name))\n            )\n\n        cwd = os.getcwd()\n        os.chdir(self.repo_dir)\n        logger.debug(\"cwd: %s, getting status %s \", cwd, self.repo_dir)\n        try:\n            p = git.status(_out=self._sh_stdout('blue'),\n                           _err=self._sh_stderr('red'))\n            p.wait()\n        except Exception:\n            pass\n            # logger.warn(e)\n        os.chdir(cwd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrecords that a particular cachefile with the given name has been used.", "response": "def record_used(kind, hash):\n    \"\"\"\n    Indicates a cachefile with the name 'hash' of a particular kind has been used so it will note be deleted on the next purge.\n\n    :param str kind: The kind of cachefile. One of 'cache', 'seeds', or 'evs'\n    :param str hash: The hash for the call descriptor, expected value descriptor, or counter seed.\n\n    :rtype: None\n    \"\"\"\n    if os.path.exists(LOG_FILEPATH):\n        log = open(os.path.join(ROOT, 'used'), 'a')\n    else:\n        log = open(os.path.join(ROOT, 'used'), 'w+')\n\n    log.writelines([\"%s...%s\\n\" % (kind, hash)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting records associated with a particular hash", "response": "def delete_io( hash ):\n    \"\"\"\n    Deletes records associated with a particular hash\n\n    :param str hash: The hash\n\n    :rtype int: The number of records deleted\n    \"\"\"\n    global CACHE_\n    load_cache(True)\n    record_used('cache', hash)\n    num_deleted = len(CACHE_['cache'].get(hash, []))\n    if hash in CACHE_['cache']:\n        del CACHE_['cache'][hash]\n    write_out()\n    return num_deleted"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a method s i/o into the datastore", "response": "def insert_io( args ):\n    \"\"\"\n    Inserts a method's i/o into the datastore\n\n    :param dict args: A dictionary of the hash, stack, packet_num, methodname, args, and returnval\n\n    :rtype None:\n    \"\"\"\n    global CACHE_\n    load_cache()\n    hash = args['hash']\n    record_used('cache', hash)\n    packet_num = args['packet_num']\n    if hash not in CACHE_['cache']:\n        CACHE_['cache'][hash] = {}\n    CACHE_['cache'][hash][packet_num] = pickle.dumps(args, PPROT)\n    write_out()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_io( hash ):\n    load_cache(True)\n    global CACHE_\n    res = []\n    record_used('cache', hash)\n    for d in CACHE_['cache'].get(hash, {}).values():\n        d = pickle.loads(d)\n        res += [(d['hash'], d['stack'], d['methodname'], d['returnval'], d['args'], d['packet_num'])]\n    return res", "response": "Returns the relevant i/o for a method whose call is characterized by the hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_from_directory_by_hashes(cache_type, hashes):\n    global CACHE_\n    if hashes == '*':\n        CACHE_[cache_type] = {}\n    for h in hashes:\n        if h in CACHE_[cache_type]:\n            del CACHE_[cache_type][h]\n    write_out()", "response": "Delete all cache files corresponding to a list of hashes from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread all hashes that have been used since the last call to purge or reset_hashes.", "response": "def read_used():\n    \"\"\"\n    Read all hashes that have been used since the last call to purge (or reset_hashes).\n\n    :rtype: dict\n    :returns: A dictionary of sets of hashes organized by type\n    \"\"\"\n    used_hashes = {\"evs\": set([]),\n                   \"cache\": set([]),\n                   \"seeds\": set([])}\n\n    with open(LOG_FILEPATH, 'rb') as logfile:\n        for line in logfile.readlines():\n            kind, hash = tuple(line.split('...'))\n            used_hashes[kind].add(hash.rstrip())\n\n    return used_hashes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_all():\n    global CACHE_\n    load_cache(True)\n    evs = CACHE_['evs'].keys()\n    cache = CACHE_['cache'].keys()\n    seeds = CACHE_['seeds'].keys()\n    return {\"evs\"  : evs,\n            \"cache\": cache,\n            \"seeds\": seeds}", "response": "Reads all the hashes and returns them in a dictionary by type\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef purge():\n    all_hashes = read_all()\n    used_hashes = read_used()\n    for kind, hashes in used_hashes.items():\n        hashes = set(hashes)\n        to_remove = set(all_hashes[kind]).difference(hashes)\n        delete_from_directory_by_hashes(kind, to_remove)\n\n    reset_used()\n    write_out()", "response": "Deletes all the cached files in the current directory that have not been used."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_stack(stack):\n    global CACHE_\n    serialized = pickle.dumps(stack, PPROT)\n    CACHE_['stacks'][\"{0}.{1}\".format(stack.module, stack.caller)] = serialized\n    write_out()", "response": "Saves a stack object to a flatfile."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_stack(stack):\n    global CACHE_\n    load_cache(True)\n    key = \"{0}.{1}\".format(stack.module, stack.caller)\n    if key in CACHE_['stacks']:\n        return pickle.loads(CACHE_['stacks'][key])", "response": "Loads the saved state of a CallStack and returns a whole instance given an instance with incomplete state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes a stack that was previously saved.", "response": "def delete_stack(stack):\n    \"\"\"\n    Deletes a stack that was previously saved.load_stack\n\n    :param caliendo.hooks.CallStack stack: The stack to delete.\n    \"\"\"\n    global CACHE_\n    key = \"{0}.{1}\".format(stack.module, stack.caller)\n    if key in CACHE_['stacks']:\n        del CACHE_['stacks'][key]\n        write_out()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites something to the Purr pipe", "response": "def _write(self, what):\n        \"\"\"writes something to the Purr pipe\"\"\"\n        try:\n            open(self.pipefile, \"a\").write(what)\n        except:\n            print(\"Error writing to %s:\" % self.pipefile)\n            traceback.print_exc()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef title(self, title, show=False):\n        self._write(\"title:%d:%s\\n\" % (int(show), title))\n        return self", "response": "writes a title tag to the Purr pipe"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a comment tag to the Purr pipe", "response": "def comment(self, comment, show=False, endline=True, newpar=False):\n        \"\"\"writes a comment tag to the Purr pipe\"\"\"\n        if not endline:\n            comment += \"<NOBR>\"\n        if newpar:\n            comment += \"<BR>\"\n        self._write(\"comment:%d:%s\\n\" % (int(show), comment))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite a pounce command to the Purr pipe", "response": "def pounce(self, file, show=False):\n        \"\"\"writes a pounce command to the Purr pipe\"\"\"\n        file = os.path.abspath(os.path.normpath(os.path.realpath(file)))\n        self._write(\"pounce:%d:%s\\n\" % (int(show), file))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self):\n        # read file is set to None on error, so that we stop reading\n        if self.pipefile_read is None:\n            return []\n        # no pipe -- read nothing\n        if not os.path.exists(self.pipefile):\n            return []\n        # move pipe file out of the way before we start reading from it\n        try:\n            os.rename(self.pipefile, self.pipefile_read)\n        except:\n            print(\"Error renaming %s to %s:\" % self.pipefile, self.pipefile_read)\n            traceback.print_exc()\n            self.pipefile_read = None\n            return []\n        # now read everything\n        try:\n            lines = open(self.pipefile_read).readlines()\n        except:\n            print(\"Error reading %s:\" % self.pipefile_read)\n            traceback.print_exc()\n            self.pipefile_read = None\n            return []\n        # parse lines\n        cmds = []\n        for line in lines:\n            tokens = line.rstrip().split(\":\", 2)\n            if len(tokens) < 3:\n                continue\n            command, show, content = tokens\n            # convert 'show' to bool\n            try:\n                show = bool(int(show))\n            except:\n                show = False\n            # if 'comment' command, parse content string\n            if command == \"comment\":\n                # <BR> inserts new paragraph (double-newline)\n                content = content.replace(\"<BR>\", \"\\n\\n\")\n                # <NOBR> blocks newline at end, which is otherwise implictly added...\n                if content.endswith(\"<NOBR>\"):\n                    content = content[:-6]\n                # ...here\n                elif not content.endswith(\"\\n\"):\n                    content += \"\\n\"\n            # add to list of contents\n            # print \"read %s:%d:%s:\"%(command,show,content)\n            cmds.append((command, show, content))\n        return cmds", "response": "Reads the pipe file and returns list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef echo_with_markers(text, marker='=', marker_color='blue', text_color=None):\n    text = ' ' + text + ' '\n    width, _ = click.get_terminal_size()\n    if len(text) >= width:\n        click.echo(text)  # this is probably never the case\n    else:\n        leftovers = width - len(text)\n        click.secho(marker * (leftovers / 2), fg=marker_color, nl=False)\n        click.secho(text, nl=False, fg=text_color)\n        click.secho(marker * (leftovers / 2 + leftovers % 2), fg=marker_color)", "response": "Print a text to the screen with markers surrounding it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef echo_heading(text, marker='=', marker_color='blue'):\n    click.secho(marker * 3 + '>', fg=marker_color, nl=False)\n    click.echo(' ' + text)", "response": "Print a text formatted to look like a heading."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bash_complete_command(app_name):\n    @click.command('bash-complete')\n    @click.pass_context\n    def bash_complete(ctx):\n        \"\"\"Display the commands to set up bash completion.\n        \"\"\"\n        bash_name = _bash_complete_name(app_name)\n        click.echo(\"\"\"\neval \"`_{bash_name}_COMPLETE=source {app_name}`\"\n# Run this command to configure your shell:\n# eval `{command}`\n\"\"\".format(\n            bash_name=bash_name,\n            app_name=app_name,\n            command=ctx.command_path\n        ).strip())\n    return bash_complete", "response": "Return a command that outputs the script that the user can run bash completion."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _process_compute(self, pipe_package):\n        context = pipe_package.get_context()\n        step_key = pipe_package.get_step_key()\n        actions = []\n        for mechanism in self._event_manager.get_mechanisms_steps()[step_key]:\n            mechanism_actions = mechanism.run(context)\n            for mechanism_action in mechanism_actions:\n                actions.append(mechanism_action)\n        return actions", "response": "Process the compute operation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a function that updates the staff members of a user.", "response": "def get_staff_updater(cls):\n    \"\"\"\n    This returns a function for passing to a signal.\n    \"\"\"\n    from django.core.exceptions import ImproperlyConfigured\n    if not issubclass(cls, BaseStaffMember):\n        raise ImproperlyConfigured(\"%s is not a sublass of StaffMember\" % cls)\n\n    def update_staff_member(sender, instance, created, *args, **kwargs):\n        \"\"\"\n        Update the Staff Member instance when a User object is changed.\n        \"\"\"\n        if instance.is_staff and not cls.objects.filter(user=instance).count():\n            staffmember = cls(\n                user=instance,\n                is_active=True)\n            staffmember.save()\n        elif instance.is_staff:\n            staffmembers = cls.objects.filter(user=instance)\n            if len(staffmembers):\n                staffmember = staffmembers[0]\n                staffmember.is_active = True\n                if instance.first_name != staffmember.first_name:\n                    staffmember.first_name = instance.first_name\n                    staffmember.slug = slugify('%s %s' % (\n                        instance.first_name, instance.last_name))\n                if instance.last_name != staffmember.last_name:\n                    staffmember.last_name = instance.last_name\n                    staffmember.slug = slugify('%s %s' % (\n                        instance.first_name, instance.last_name))\n                if instance.email != staffmember.email:\n                    staffmember.email = instance.email\n                staffmember.save()\n        elif not instance.is_staff:\n            # Make sure we deactivate any staff members associated with this user\n            for staffmember in cls.objects.filter(user=instance):\n                staffmember.is_active = False\n                staffmember.save()\n        from django.db import transaction\n        transaction.commit_unless_managed()\n\n    return update_staff_member"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn only the current staff members", "response": "def active(self):\n        \"\"\"\n        Return only the current staff members\n        \"\"\"\n        qset = super(StaffMemberManager, self).get_queryset()\n        return qset.filter(is_active=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef inactive(self):\n        qset = super(StaffMemberManager, self).get_queryset()\n        return qset.filter(is_active=False)", "response": "Return inactive staff members"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the object to the database.", "response": "def save(self, force_insert=False, force_update=False, *args, **kwargs):\n        \"\"\"\n        Makes sure we are in sync with the User field\n        \"\"\"\n        self.first_name = self.user.first_name\n        self.last_name = self.user.last_name\n        self.email = self.user.email\n        full_name = '%s %s' % (self.first_name, self.last_name)\n        theslug = slugify(full_name)\n        if not theslug.strip():\n            theslug = str(self.user.pk)\n        while self.__class__.objects.filter(slug=theslug).exclude(pk=self.pk).count():\n            theslug = \"%s_\" % theslug\n        if self.slug != theslug:\n            self.slug = theslug\n        self.slug = self.slug[:50]\n        super(BaseStaffMember, self).save(\n            force_insert, force_update, *args, **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn details of a specific report", "response": "def get_report(report=None):\n    \"\"\"Returns details of a specific report\n    \"\"\"\n    if not report:\n        report = list_reports()[-1:][0]\n    report_path = _get_reports_path(report)\n    report_dict = {\"report\": report}\n    for filename in os.listdir(report_path):\n        with open(os.path.join(report_path, filename), \"r\") as f:\n            report_dict[filename] = f.read()\n    return report_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_report(report):\n    for path in glob.glob(os.path.join(_get_reports_path(), report)):\n        shutil.rmtree(path)", "response": "Delete report from the reports directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cleanup_processing_chain(self):\n        self.log(\"Removing stale processing chain entries.\")\n        self._processing_chain = [x for x in self._processing_chain\n                                  if x.remember_between_connections]", "response": "Removes all the entries which are don t have the remember_between_connections flag set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_files(self, path):\n\n        if self.verbose == 2:\n            print(\"Indexing {}\".format(path))\n\n        for filename in os.listdir(path):\n\n            file_path = path + \"/\" + filename\n\n            if os.path.isdir(file_path):\n                self.load_files(file_path)\n            elif filename.endswith(\".yaml\") or filename.endswith(\".yml\"):\n                self.unfold_yaml(file_path)", "response": "Loads all files in a given path and all its subdirectories and unfolds them."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_file(self, path, yaml):\n\n        if is_job_config(yaml):\n            name = self.get_job_name(yaml)\n\n            file_data = FileData(path=path, yaml=yaml)\n            self.files[path] = file_data\n            self.jobs[name] = file_data\n        else:\n            self.files[path] = FileData(path=path, yaml=yaml)", "response": "Adds given file to the file index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrap a dictionary into dict that contains config itself and include info", "response": "def inject_include_info(self, path, config, include_type):\n        \"\"\"\n        Wrap a dictionary into dict that contains config itself\n        and include info\n        \"\"\"\n        if isinstance(config, list):\n            config = config[0]\n\n        ret = OrderedDict()\n\n        ret[include_flag] = IncludeInfo(type=include_type, path=path)\n        ret['config'] = config\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef include_constructor(self, loader, node):\n        v = self._unfold_yaml(node.value)\n\n        return v", "response": "Called when PyYaml encounters '!include'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef include_raw_constructor(self, loader, node):\n\n        path = convert_path(node.value)\n\n        with open(path, 'r') as f:\n            config = f.read()\n\n            config = self.inject_include_info(path, config, include_type='include-raw')\n\n            self.add_file(path, config)\n\n            return config", "response": "Called when PyYaml encounters '!include - raw'"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_dep(self, name, dep):\n        logger.debug(\"name: %s, dep: %s\", name, dep)\n\n        if dep not in self._deps:\n            self._deps[name] = dep", "response": "add a dependency to the set of available items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef position(string, index):\n\n\tif not string:\n\t\treturn None\n\n\tif index < 0 or index >= len(string):\n\t\traise InternalError(\"Out-of-range index passed to errors.position!\")\n\n\tlines = string.split(\"\\n\")\n\n\t# If there only is one single line the\n\t# line:index format wouldn't be so intuitive\n\tif len(lines) == 1:\n\t\treturn str(index)\n\n\tbefore = n = 0\n\n\tfor n, line in enumerate(lines):\n\t\tfuture = before + len(line) + 1 # \\n\n\t\t# Note that we really want > and not\n\t\t# >= because the length is 1-indexed\n\t\t# while the index is not, i.e. the\n\t\t# value of 'before' already includes the\n\t\t# first character of the next line when\n\t\t# speaking of its 0-indexed index\n\t\tif future > index:\n\t\t\tbreak\n\t\tbefore = future\n\n\t# index - before to have only the\n\t# index within the relevant line\n\treturn \"{0}:{1}\".format(n, index - before)", "response": "Returns a helpful position description for an index in a multi - line string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a spoken - word representation for a number.", "response": "def number(digit):\n\t\"\"\"\n\tGets a spoken-word representation for a number.\n\n\tArguments:\n\t\tdigit (int): An integer to convert into spoken-word.\n\n\tReturns:\n\t\tA spoken-word representation for a digit,\n\t\tincluding an article ('a' or 'an') and a suffix,\n\t\te.g. 1 -> 'a 1st', 11 -> \"an 11th\". Adittionally\n\t\tdelimits characters in pairs of three for values > 999.\n\t\"\"\"\n\n\tspoken = str(digit)\n\n\tif spoken.startswith(\"8\") or spoken[:len(spoken) % 3] == \"11\":\n\t\tarticle = \"an \"\n\telse:\n\t\tarticle = \"a \"\n\n\tif spoken.endswith(\"1\") and spoken != \"11\":\n\t\tsuffix = \"st\"\n\telif spoken.endswith(\"2\") and spoken != \"12\":\n\t\tsuffix = \"nd\"\n\telif spoken.endswith(\"3\") and spoken != \"13\":\n\t\tsuffix = \"rd\"\n\telse:\n\t\tsuffix = \"th\"\n\n\tif digit > 999:\n\t\tprefix = len(spoken) % 3\n\t\tseparated = spoken[:prefix]\n\t\tfor n in range(prefix, len(spoken), 3):\n\t\t\tseparated += \",\" + spoken[n : n + 3]\n\t\tspoken = separated\n\n\treturn article + spoken + suffix"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncombining a warning with a call to errors. position.", "response": "def warn(what, string, pos):\n\n\t\"\"\"\n\tCombines a warning with a call to errors.position().\n\n\tSimple convenience function.\n\n\tArguments:\n\t\tstring (str): The string being parsed.\n\t\tpos (int): The index of the character that caused trouble.\n\t\"\"\"\n\n\tpos = position(string, pos)\n\n\twarnings.warn(\"{0} at position {1}!\".format(what, pos), Warning)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ins2dict(ins, kind=''):\n    if kind and hasattr(ins, 'to_%s_dict' % kind):\n        return getattr(ins, 'to_%s_dict' % kind)()\n    elif hasattr(ins, 'to_dict'):\n        return getattr(ins, 'to_dict')()\n    else:\n        return _turn_row_to_dict(ins)", "response": "Turn a SQLAlchemy Model instance to dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an instance by id.", "response": "def get_instance(model, instance_id):\n    \"\"\"Get an instance by id.\n\n    :param model: a string, model name in rio.models\n    :param id: an integer, instance id.\n    :return: None or a SQLAlchemy Model instance.\n    \"\"\"\n    try:\n        model = get_model(model)\n    except ImportError:\n        return None\n\n    return model.query.get(instance_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_data_or_404(model, instance_id, kind=''):\n    data = get_data(model, instance_id, kind)\n\n    if not data:\n        return abort(404)\n\n    return data", "response": "Wrap get_data to raise BadRequest."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget instance data by id.", "response": "def get_data(model, instance_id, kind=''):\n    \"\"\"Get instance data by id.\n\n    :param model: a string, model name in rio.models\n    :param id: an integer, instance id.\n    :param kind: a string specified which kind of dict tranformer should be called.\n    :return: data.\n    \"\"\"\n    instance = get_instance(model, instance_id)\n\n    if not instance:\n        return\n\n    return ins2dict(instance, kind)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_instance_by_slug(model, slug, **kwargs):\n    try:\n        model = get_model(model)\n    except ImportError:\n        return None\n\n    query_params = dict(kwargs)\n    query_params['slug'] = slug\n\n    return model.query.filter_by(**query_params).first()", "response": "Get an instance by slug."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_by_slug(model, slug, kind='', **kwargs):\n\n    instance = get_instance_by_slug(model, slug, **kwargs)\n\n    if not instance:\n        return\n\n    return ins2dict(instance, kind)", "response": "Get instance data by slug and kind. Raise 404 Not Found"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_data_by_slug_or_404(model, slug, kind='', **kwargs):\n    data = get_data_by_slug(model, slug, kind, **kwargs)\n\n    if not data:\n        abort(404)\n\n    return data", "response": "Wrap get_data_by_slug abort 404 if missing data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting an instance by binary uuid.", "response": "def get_instance_by_bin_uuid(model, bin_uuid):\n    \"\"\"Get an instance by binary uuid.\n\n    :param model: a string, model name in rio.models.\n    :param bin_uuid: a 16-bytes binary string.\n    :return: None or a SQLAlchemy instance.\n    \"\"\"\n    try:\n        model = get_model(model)\n    except ImportError:\n        return None\n\n    return model.query.filter_by(**{'bin_uuid': bin_uuid}).first()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_data_by_hex_uuid_or_404(model, hex_uuid, kind=''):\n    uuid = UUID(hex_uuid)\n    bin_uuid = uuid.get_bytes()\n\n    instance = get_instance_by_bin_uuid(model, bin_uuid)\n\n    if not instance:\n        return abort(404)\n\n    return ins2dict(instance, kind)", "response": "Get data by uuid and kind Raise 404 Not Found"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an instance to the database.", "response": "def add_instance(model, _commit=True, **kwargs):\n    \"\"\"Add instance to database.\n\n    :param model: a string, model name in rio.models\n    :param _commit: control whether commit data to database or not. Default True.\n    :param \\*\\*kwargs: persisted data.\n    :return: instance id.\n    \"\"\"\n    try:\n        model = get_model(model)\n    except ImportError:\n        return None\n\n    instance = model(**kwargs)\n    db.session.add(instance)\n\n    try:\n        if _commit:\n            db.session.commit()\n        else:\n            db.session.flush()\n        return instance.id\n    except IntegrityError:\n        db.session.rollback()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete an instance from the database.", "response": "def delete_instance(model, instance_id, _commit=True):\n    \"\"\"Delete instance.\n\n    :param model: a string, model name in rio.models.\n    :param instance_id: integer, instance id.\n    :param _commit: control whether commit data to database or not. Default True.\n    \"\"\"\n    try:\n        model = get_model(model)\n    except ImportError:\n        return\n\n    instance = model.query.get(instance_id)\n    if not instance:\n        return\n\n    db.session.delete(instance)\n    try:\n        if _commit:\n            db.session.commit()\n        else:\n            db.session.flush()\n    except Exception as exception:\n        db.session.rollback()\n        raise exception"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a whoosh. fields. Schema object from a list of field names.", "response": "def make_schema(fields, datefields=()):\n    '''Create a whoosh.fields.Schema object from a list of field names.\n    All fields will be set as TEXT fields. If datefields is supplied,\n    additionally create DATETIME fields with those names\n    \n    '''\n    text_field = whoosh.fields.TEXT(analyzer=whoosh.analysis.SimpleAnalyzer())\n    fields = dict.fromkeys(fields, text_field)\n    if datefields:\n        datefields = dict.fromkeys(datefields, whoosh.fields.DATETIME)\n        fields.update(datefields)\n    schema = whoosh.fields.Schema()\n    for fieldname in fields:\n        schema.add(fieldname, fields[fieldname])\n    return schema"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_key(request, group=None, perm=None, keytype=None):\n    def update_last_access():\n        if KEY_LAST_USED_UPDATE:\n            request.key.save()\n    \n    if request.user.is_authenticated() and is_valid_consumer(request):\n        if not group and not perm and not keytype:\n            return update_last_access()\n        elif keytype:\n            if request.key.is_type( keytype ):\n                return update_last_access()\n        elif group:\n            if request.key.belongs_to_group( group ):\n                return update_last_access()\n        elif perm:\n            if request.key.has_perm( perm ):\n                return update_last_access()\n        raise AccessForbidden\n    raise AccessUnauthorized", "response": "Validate the given key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the client for view access with the given key", "response": "def is_valid_consumer(request):\n    \"\"\"\n    Validate the client for view/resource access with the given key\n    \n    The client is authorized to access the view:\n        - if there is a `Consumer` with the client's *IP* that is explicitly allowed to use the given key,\n        - if there is no `Consumer` with a different *IP* explicitly allowed to use the given key\n    \"\"\"\n    try:\n        ip = request.META.get('REMOTE_ADDR', None)\n        return Consumer.objects.get(key=request.key, ip=ip).allowed\n    except Consumer.DoesNotExist:\n        consumers = Consumer.objects.filter(key=request.key, allowed=True)\n        return not consumers.exists()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef HttpResponse401(request, template=KEY_AUTH_401_TEMPLATE,\ncontent=KEY_AUTH_401_CONTENT, content_type=KEY_AUTH_401_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for not-authorized access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=401)", "response": "Returns an access - failed response for a 403 error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef HttpResponse403(request, template=KEY_AUTH_403_TEMPLATE,\ncontent=KEY_AUTH_403_CONTENT, content_type=KEY_AUTH_403_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for forbidden access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=403)", "response": "Returns a HttpResponse for 403 access."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef changeDefaultMessageConst(self, header_segment, segment_len, separator_count):\n        self.header_segment = header_segment\n        self.segment_len = segment_len\n        self.separator_count = separator_count", "response": "This method is used to change the default message constant for the HL7 segment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extractSeparators(self, hl7dict, msg):\n        assert msg[:self.segment_len] == self.header_segment, \\\n            \"Message MUST start with the %s segment : Here %s\" % (self.header_segment, msg[:self.segment_len])\n        hl7dict.separators = msg[self.segment_len:self.segment_len+self.separator_count]", "response": "Extract the separators used to separate the pieces\n        and the message s pieces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef emit(self, dictValues, key, value):\n        if key and value:\n            dictValues[key] = value", "response": "Emits a new value in the HL7 dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef buildSegmentMap(self, lines):\n        lineMap = ['']\n        segmentNameCount = {}\n\n        # walk the lines\n        for line in lines:\n            # get the segment name\n            name = line[:self.segment_len]\n            # inc the segment count\n            if name not in segmentNameCount:\n                segmentNameCount[name] = 1\n            else:\n                segmentNameCount[name] += 1\n\n            qualifiedSegmentName = \"%s[%d]\" % (name, segmentNameCount[name])\n            lineMap.append(qualifiedSegmentName)\n\n        # return the list of qualified segment name\n        # ['', 'MSH[1]', 'PID[1]', 'PV1[1]', 'ORC[1]', 'OBR[1]', 'TQ1[1]', 'OBX[1]', 'SPM[1]', ...\n        return segmentNameCount, lineMap", "response": "Build the map of the various segments. Each segment has a qualified name according to the number\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an HL7 message and returns an HL7 dictionary.", "response": "def parse(self, msg):\n        \"\"\" Parse an HL7 message and return an HL7 dictionary.\n\n        :param msg: HL7 message to parse\n        :return: An HL7 dictionary\n        \"\"\"\n        #init\n        dictValues = HL7Dict(self.tersersep)\n        msg_ = msg.strip('\\r\\n ')\n\n        # extracts separator defined in the message itself\n        self.extractSeparators(dictValues, msg_)\n        msg_ = msg_.replace('\\r', '\\n')\n        lines = msg_.split('\\n')\n        lineNumber = 1\n\n        # build the map of segments\n        segmentNameCount, lineMap = self.buildSegmentMap(lines)\n        dictValues.setSegmentsMap(segmentNameCount, lineMap)\n\n        # Parse each line of the message : 1 line = 1 segment\n        for line in lines:\n            dictValues.currentLineNumber = lineNumber\n            self.extractValues(dictValues, line)\n            lineNumber += 1\n\n        return dictValues"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app):\n        self.init_config(app)\n\n        # Install datetime helpers.\n        app.jinja_env.filters.update(\n            from_isodate=from_isodate,\n            from_isodatetime=from_isodatetime,\n            to_arrow=to_arrow,\n            format_arrow=format_arrow,\n        )\n\n        if app.config['FORMATTER_BADGES_ENABLE']:\n            from invenio_formatter.context_processors.badges import \\\n                badges_processor\n\n            # Registration of context processors.\n            app.context_processor(badges_processor)\n            # Register blueprint.\n            app.register_blueprint(create_badge_blueprint(\n                app.config['FORMATTER_BADGES_ALLOWED_TITLES']))\n\n        app.extensions['invenio-formatter'] = self", "response": "Initializes the Flask application."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_config(app):\n        try:\n            get_distribution('CairoSVG')\n            has_cairo = True\n        except DistributionNotFound:\n            has_cairo = False\n\n        app.config.setdefault('FORMATTER_BADGES_ENABLE', has_cairo)\n\n        for attr in dir(config):\n            if attr.startswith('FORMATTER_'):\n                app.config.setdefault(attr, getattr(config, attr))", "response": "Initialize configuration.\n\n        .. note:: If CairoSVG is installed then the configuration\n            ``FORMATTER_BADGES_ENABLE`` is ``True``.\n\n        :param app: The Flask application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreport usage to host", "response": "def report_usage_to_host(host_ip, vmid):\n\t\n\t#base value\n\tcpu_usage = 0.0\n\tos_mem_usage = 0.0\n\ttask_mem_usage = 0.0\n\tio_usage = 0.0\n\n\tcpu_usage = get_cpu_usage()\n\tos_mem_usage = get_os_mem_usage()\n\ttask_mem_usage = get_task_mem_usage()\n\tio_usage = get_io_usage()\n\n\tusage = str(vmid.strip())+' | '+str(cpu_usage)+' | '+str(os_mem_usage)+' | '+str(task_mem_usage)+' | '+str(io_usage)\n\t#usage = \"'cpu |sdbfsj |sdfsdhf |sdfvsdvfgdfvj'\"\n\t#cmd = 'python /var/lib/virtdc/vmonere/host/vmonere_listener.py '+usage\n\t\n\n\t'''cmd = '/bin/ssh -n -q -o StrictHostKeyChecking=no root@host_ip \\\"/bin/nohup /bin/python /var/lib/virtdc/vmonere/host/vmonere_listener.py '+usage+' &\\\"'\n\tcmd = cmd.replace(\"host_ip\",str(host_ip).strip())'''\n\n\t#report usage via socket\n\tstart_client_socket(host_ip, usage)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef long2str(l):\n    if type(l) not in (types.IntType, types.LongType):\n        raise ValueError('the input must be an integer')\n\n    if l < 0:\n        raise ValueError('the input must be greater than 0')\n    s = ''\n    while l:\n        s = s + chr(l & 255)\n        l >>= 8\n\n    return s", "response": "Convert an integer to a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a string to a long integer.", "response": "def str2long(s):\n    \"\"\"Convert a string to a long integer.\"\"\"\n    if type(s) not in (types.StringType, types.UnicodeType):\n        raise ValueError('the input must be a string')\n\n    l = 0\n    for i in s:\n        l <<= 8\n        l |= ord(i)\n\n    return l"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the type of the file", "response": "def is_android(filename):\n    \"\"\"Return the type of the file\n\n        @param filename : the filename\n        @rtype : \"APK\", \"DEX\", None\n    \"\"\"\n    if not filename:\n        return None\n\n    with open(filename, \"rb\") as fd:\n        f_bytes = fd.read()\n        return is_android_raw(f_bytes)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_android_raw(raw):\n    val = None\n\n    if raw[0:2] == b\"PK\" and b'META-INF/MANIFEST.MF' in raw:\n        val = \"APK\"\n    elif raw[0:3] == b\"dex\":\n        val = \"DEX\"\n    elif raw[0:3] == b\"dey\":\n        val = \"DEY\"\n    elif raw[0:4] == b\"\\x03\\x00\\x08\\x00\":\n        val = \"AXML\"\n    elif raw[0:4] == b\"\\x02\\x00\\x0C\\x00\":\n        val = b\"ARSC\"\n\n    return val", "response": "Returns a string that describes the type of file for Android."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake two RGB color sets and mix them over a specified number of steps.", "response": "def interpolate_tuple(startcolor, goalcolor, steps):\n    \"\"\"\n    Take two RGB color sets and mix them over a specified number of steps.  Return the list\n    \"\"\"\n    # white\n\n    R = startcolor[0]\n    G = startcolor[1]\n    B = startcolor[2]\n\n    targetR = goalcolor[0]\n    targetG = goalcolor[1]\n    targetB = goalcolor[2]\n\n    DiffR = targetR - R\n    DiffG = targetG - G\n    DiffB = targetB - B\n\n    buffer = []\n\n    for i in range(0, steps + 1):\n        iR = R + (DiffR * i // steps)\n        iG = G + (DiffG * i // steps)\n        iB = B + (DiffB * i // steps)\n\n        hR = string.replace(hex(iR), \"0x\", \"\")\n        hG = string.replace(hex(iG), \"0x\", \"\")\n        hB = string.replace(hex(iB), \"0x\", \"\")\n\n        if len(hR) == 1:\n            hR = \"0\" + hR\n        if len(hB) == 1:\n            hB = \"0\" + hB\n\n        if len(hG) == 1:\n            hG = \"0\" + hG\n\n        color = string.upper(\"#\" + hR + hG + hB)\n        buffer.append(color)\n\n    return buffer"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_img_button(width=200, height=50, text='This is a button', color=rgb(200,100,50)):\n    \n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n    ctx = cairo.Context(surface)\n    ctx.rectangle(0, 0, width - 1, height - 1)\n\n    ctx.set_source_rgb(color.red/255.0, color.green/255.0, color.blue/255.0)\n    ctx.fill()\n    \n    # Draw text\n    ctx.set_source_rgb(1.0, 1.0, 1.0)\n    ctx.select_font_face(\n        \"Helvetica\",\n        cairo.FONT_SLANT_NORMAL,\n        cairo.FONT_WEIGHT_BOLD\n    )\n    ctx.set_font_size(15.0)\n    ctx.move_to(15, 2 * height / 3)\n    ctx.show_text(text)\n    \n    surface.write_to_png('button.png')", "response": "Draws a simple image button."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndrawing a simple CSS button.", "response": "def draw_css_button(width=200, height=50, text='This is a button', color=rgb(200,100,50)):\n    \"\"\" Draws a simple CSS button. \"\"\"\n\n    # TODO: once we've decided on a scss compiler, import it at the top instead\n    from scss import Scss\n\n    # TODO: make this customizable\n    css_class = 'button'\n    \n    html = '<a class=\"{0}\" href=\"TODO\">{1}</a>'.format(css_class, text)\n    \n    css = Scss()\n    scss_str = \"a.{0} {{color: red + green;}}\".format(css_class)\n    css.compile(scss_str)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_project(self, executable, target):\n        command = 'make -f ../Makefile -C {0} {1}'.format(SRC_PATH, target)\n        pipe = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT,\n                     env=CHILD_ENV)\n        output = pipe.communicate()[0]\n        if pipe.returncode != 0:\n            raise MakeFailed(output)\n        if not os.path.isfile(os.path.join(SRC_PATH, executable)):\n            raise NonexistentExecutable(output)\n        return output", "response": "Build the project and verify the executable exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_package_version(self):\n        res = {\n            'pip_version': None,\n            'pip_url': None,\n            'pip_requirement': None,\n            'pkg_resources_version': None,\n            'pkg_resources_url': None,\n            'git_tag': None,\n            'git_commit': None,\n            'git_remotes': None,\n            'git_is_dirty': None\n        }\n        try:\n            pip_info = self._find_pip_info()\n        except Exception:\n            # we NEVER want this to crash the program\n            logger.debug('Caught exception running _find_pip_info()')\n            pip_info = {}\n        logger.debug(\"pip info: %s\", pip_info)\n        for k, v in pip_info.items():\n            if v is not None:\n                res['pip_' + k] = v\n        try:\n            pkg_info = self._find_pkg_info()\n        except Exception:\n            logger.debug('Caught exception running _find_pkg_info()')\n            pkg_info = {}\n        logger.debug(\"pkg_resources info: %s\", pkg_info)\n        for k, v in pkg_info.items():\n            res['pkg_resources_' + k] = v\n        gitdir = self._git_repo_path\n        if gitdir is not None:\n            git_info = self._find_git_info(gitdir)\n            logger.debug(\"Git info: %s\", git_info)\n            for k, v in git_info.items():\n                if k == 'dirty':\n                    res['git_is_dirty'] = v\n                elif k == 'commit':\n                    res['git_commit'] = v\n                elif k == 'remotes':\n                    res['git_remotes'] = v\n                elif k == 'tag':\n                    res['git_tag'] = v\n        else:\n            logger.debug(\"Install does not appear to be a git clone\")\n        logger.debug(\"Final package info: %s\", res)\n        return VersionInfo(**res)", "response": "Find the installed version of the specified package and return the version and commit and url."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the git repository for the current version of the package.", "response": "def _git_repo_path(self):\n        \"\"\"\n        Attempt to determine whether this package is installed via git or not;\n        if so, return the path to the git repository.\n\n        :rtype: str\n        :returns: path to git repo, or None\n        \"\"\"\n        logger.debug('Checking for git directory in: %s', self._package_top_dir)\n        for p in self._package_top_dir:\n            gitdir = os.path.join(p, '.git')\n            if os.path.exists(gitdir):\n                logger.debug('_is_git_clone() true based on %s' % gitdir)\n                return gitdir\n        logger.debug('_is_git_clone() false')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind information about the installed package from pkg_resources.", "response": "def _find_pkg_info(self):\n        \"\"\"\n        Find information about the installed package from pkg_resources.\n\n        :returns: information from pkg_resources about ``self.package_name``\n        :rtype: dict\n        \"\"\"\n        dist = pkg_resources.require(self.package_name)[0]\n        self._pkg_resources_locations = [dist.location]\n        ver, url = self._dist_version_url(dist)\n        return {'version': ver, 'url': url}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries to find information about the installed package from pip.", "response": "def _find_pip_info(self):\n        \"\"\"\n        Try to find information about the installed package from pip.\n        This should be wrapped in a try/except.\n\n        :returns: information from pip about ``self.package_name``.\n        :rtype: dict\n        \"\"\"\n        res = {}\n        dist = None\n        dist_name = self.package_name.replace('_', '-')\n        logger.debug('Checking for pip distribution named: %s', dist_name)\n        for d in pip.get_installed_distributions():\n            if d.project_name == dist_name:\n                dist = d\n        if dist is None:\n            logger.debug('could not find dist matching package_name')\n            return res\n        logger.debug('found dist: %s', dist)\n        self._pip_locations = [dist.location]\n        ver, url = self._dist_version_url(dist)\n        res['version'] = ver\n        res['url'] = url\n        # this is a bit of an ugly, lazy hack...\n        req = pip.FrozenRequirement.from_dist(dist, [])\n        logger.debug('pip FrozenRequirement: %s', req)\n        res['requirement'] = str(req.req)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets version and homepage URL for a pkg_resources. Distribution object.", "response": "def _dist_version_url(self, dist):\n        \"\"\"\n        Get version and homepage for a pkg_resources.Distribution\n\n        :param dist: the pkg_resources.Distribution to get information for\n        :returns: 2-tuple of (version, homepage URL)\n        :rtype: tuple\n        \"\"\"\n        ver = str(dist.version)\n        url = None\n        for line in dist.get_metadata_lines(dist.PKG_INFO):\n            line = line.strip()\n            if ':' not in line:\n                continue\n            (k, v) = line.split(':', 1)\n            if k == 'Home-page':\n                url = v.strip()\n        return (ver, url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding information about the git repository.", "response": "def _find_git_info(self, gitdir):\n        \"\"\"\n        Find information about the git repository, if this file is in a clone.\n\n        :param gitdir: path to the git repo's .git directory\n        :type gitdir: str\n        :returns: information about the git clone\n        :rtype: dict\n        \"\"\"\n        res = {'remotes': None, 'tag': None, 'commit': None, 'dirty': None}\n        try:\n            logger.debug('opening %s as git.Repo', gitdir)\n            repo = Repo(path=gitdir, search_parent_directories=False)\n            res['commit'] = repo.head.commit.hexsha\n            res['dirty'] = repo.is_dirty(untracked_files=True)\n            res['remotes'] = {}\n            for rmt in repo.remotes:\n                # each is a git.Remote\n                urls = [u for u in rmt.urls]  # generator\n                if len(urls) > 0:\n                    res['remotes'][rmt.name] = urls[0]\n            for tag in repo.tags:\n                # each is a git.Tag object\n                if tag.commit.hexsha == res['commit']:\n                    res['tag'] = tag.name\n        except Exception:\n            logger.debug('Exception getting git information', exc_info=True)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _package_top_dir(self):\n        r = [self.package_dir]\n        for l in self._pip_locations:\n            if l is not None:\n                r.append(l)\n        for l in self._pkg_resources_locations:\n            if l is not None:\n                r.append(l)\n        return sorted(list(set(r)))", "response": "Find one or more directories that we think may be the top - level directories of the package ; return a list of their absolute paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches the RepositoryURL for a given repository", "response": "def get_repo_url(pypirc, repository):\n    \"\"\"Fetch the RepositoryURL for a given repository, reading info from pypirc.\n\n    Will try to find the repository in the .pypirc, including username/password.\n\n    Args:\n        pypirc (str): path to the .pypirc config file\n        repository (str): URL or alias for the repository\n\n    Returns:\n        base.RepositoryURL for the repository\n    \"\"\"\n    pypirc = os.path.abspath(os.path.expanduser(pypirc))\n    pypi_config = base.PyPIConfig(pypirc)\n    repo_config = pypi_config.get_repo_config(repository)\n    if repo_config:\n        return repo_config.get_clean_url()\n    else:\n        return base.RepositoryURL(repository)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the RFC and fix where possible\n        '''\n        # Let the parent do its stuff\n        super(IPv6Packet, self).sanitize()\n\n        # Check the version\n        if self.version != 6:\n            raise ValueError(\"Protocol version must be 6\")\n\n        # Treat traffic class as an 8-bit unsigned integer. Future versions of\n        # this code may implement methods to treat it as DSCP+ECN\n        if not isinstance(self.traffic_class, numbers.Integral) \\\n        or self.traffic_class < 0 \\\n        or self.traffic_class >= 2 ** 8:\n            raise ValueError('Invalid traffic class')\n\n        # Treat flow label as a 20-bit unsigned integer. Future versions of\n        # this code may do more once the IETF figures out what a flow label\n        # means ;-)\n        if not isinstance(self.flow_label, numbers.Integral) \\\n        or self.flow_label < 0 \\\n        or self.flow_label >= 2 ** 20:\n            raise ValueError('Invalid flow label')\n\n        # Check that the hop-limit is correct\n        if not isinstance(self.hop_limit, numbers.Integral) \\\n        or self.hop_limit < 0 \\\n        or self.hop_limit >= 2 ** 8:\n            raise ValueError('Invalid hop limit')\n\n        # Check the source and destination addresses\n        if not isinstance(self.source, IPv6Address):\n            raise ValueError('Source address must be IPv6')\n\n        if not isinstance(self.destination, IPv6Address):\n            raise ValueError('Destination address must be IPv6')", "response": "Sanitize the current settings and return a new set of possible values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_bytes(cls, bitstream, decode_payload=True):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the version\n        version = bitstream.read('uint:4')\n        if version != packet.version:\n            raise ValueError('Provided bytes do not contain an IPv6 packet')\n\n        # Read the traffic class\n        packet.traffic_class = bitstream.read('uint:8')\n\n        # Read the flow label\n        packet.flow_label = bitstream.read('uint:20')\n\n        # Read the payload length\n        payload_length = bitstream.read('uint:16')\n\n        # Read the next header type\n        packet.next_header = bitstream.read('uint:8')\n\n        # Read the hop limit\n        packet.hop_limit = bitstream.read('uint:8')\n\n        # Read the source and destination addresses\n        packet.source = IPv6Address(bitstream.read('uint:128'))\n        packet.destination = IPv6Address(bitstream.read('uint:128'))\n\n        # And the rest is payload\n        packet.payload = bitstream.read('bytes:%d' % payload_length)\n\n        if decode_payload:\n            payload_class = protocol_registry.get_type_class(packet.next_header)\n            if payload_class:\n                packet.payload = payload_class.from_bytes(packet.payload)\n\n        # There should be no remaining bits\n        if bitstream.pos != bitstream.len:\n            raise ValueError('Bits remaining after processing packet')\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "Parse the given packet and update properties accordingly."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates bytes from properties", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the version\n        bitstream = BitStream('uint:4=%d' % self.version)\n\n        # Write the traffic class\n        bitstream += BitStream('uint:8=%d' % self.traffic_class)\n\n        # Write the flow label\n        bitstream += BitStream('uint:20=%d' % self.flow_label)\n\n        # Write the payload length\n        payload_bytes = bytes(self.payload)\n        payload_length = len(payload_bytes)\n        bitstream += BitStream('uint:16=%d' % payload_length)\n\n        # Write the next header type\n        bitstream += BitStream('uint:8=%d' % self.next_header)\n\n        # Write the hop limit\n        bitstream += BitStream('uint:8=%d' % self.hop_limit)\n\n        # Write the source and destination addresses\n        bitstream += BitStream('uint:128=%d, '\n                               'uint:128=%d' % (int(self.source),\n                                                int(self.destination)))\n\n        return bitstream.bytes + payload_bytes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pre(self, *args):\n            if len(args):\n                self.str_pre = args[0]\n            else:\n                return self.str_pre", "response": "Get or set the str_pre atomically"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef depth(self, *args):\n            if len(args):\n                self._depth = args[0]\n            else:\n                return self._depth", "response": "Set the depth of the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the b_printPre flag", "response": "def printPre(self, *args):\n            \"\"\"\n            get/set the str_pre string.\n            \"\"\"\n            if len(args):\n                self.b_printPre = args[0]\n            else:\n                return self.b_printPre"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef node_branch(self, al_keys, al_values):\n            if len(al_keys) != len(al_values):\n                self.error_exit(\"adding branch nodes\", \"#keys != #values\", 1)\n            ldict = dict(zip(al_keys, al_values))\n            self.node_dictBranch(ldict)", "response": "Add a branch node in a dictionary using the keys and values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef node_branch(self, astr_node, abranch):\n            self.dict_branch[astr_node].node_dictBranch(abranch.dict_branch)", "response": "Adds a branch to a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initFromDict(self, adict, **kwargs):\n            # First, flatten the dictionary into a dictionary of paths/files\n            a_flat  = C_stree.flatten(adict)\n\n            l_dir   = []\n            # Now, build a tree from this structure by generating a list of paths\n            for k, v in a_flat.items():\n                l_dir.append(k.split('/')[1:-1])\n\n            # remove duplicates...\n            l_dir = [list(x) for x in set(tuple(x) for x in l_dir)]\n\n            # build sorted list of paths...\n            l_path  = ['/' + '/'.join(p) for p in l_dir]\n            l_path.sort()\n\n            # build the tree\n            for dir in l_path: self.mkdir(dir)\n\n            # and now add the leaves\n            for file,contents in a_flat.items(): self.touch(file, contents)", "response": "Initialize self from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresetting all nodes and branches to root.", "response": "def root(self):\n            \"\"\"\n            Reset all nodes and branches to 'root'.\n            \"\"\"\n            str_treeRoot                = '/'\n            self.l_cwd                  = [str_treeRoot]\n            self.snode_current          = self.snode_root\n            self.sbranch_current        = self.sbranch_root"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cwd(self):\n            l_cwd                       = self.l_cwd[:]\n            str_cwd                     = '/'.join(l_cwd)\n            if len(str_cwd)>1: str_cwd  = str_cwd[1:]\n            return str_cwd", "response": "Return a UNIX FS type string of the current working directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the current path has a node specd by kwargs", "response": "def path_has(self, **kwargs):\n            \"\"\"\n            Checks if the current path has a node spec'd by kwargs\n            \"\"\"\n            str_node    = \"/\" # This node will always be \"False\"\n            for key, val in kwargs.items():\n                if key == 'node':   str_node = val\n            if str_node in self.l_cwd:\n                return { 'found':   True,\n                         'indices': [i for i, x in enumerate(self.l_cwd) if x == str_node]}\n            else:\n                return { 'found':   False,\n                         'indices': [-1]}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pwd(self, **kwargs):\n\n            b_node  = False\n            node    = 0\n            for key,val in kwargs.items():\n                if key == 'node':\n                    b_node  = True\n                    node    = int(val)\n\n            str_path = self.cwd()\n            if b_node:\n                l_path      = str_path.split('/')\n                if len(l_path) >= node+1:\n                    str_path    = str_path.split('/')[node]\n            return str_path", "response": "Returns the cwd of the node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef node_mustNotInclude(self, al_mustNotInclude, ab_reset=False):\n            if ab_reset:\n                self.snode_current.l_mustNotInclude = al_mustNotInclude[:]\n            else:\n                l_current   = self.snode_current.l_mustNotInclude[:]\n                l_total     = l_current + al_mustNotInclude\n                self.snode_current.l_mustNotInclude = l_total[:]", "response": "Append or reset the list of snode_current istags depending on ab_reset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending or reset the list of snode_current istags depending on ab_reset.", "response": "def node_mustInclude(self, al_mustInclude, ab_reset=False):\n            \"\"\"\n            Either appends or resets the <mustInclude> list of snode_current\n            depending on <ab_reset>.\n            \"\"\"\n            if ab_reset:\n                self.snode_current.l_mustInclude = al_mustInclude[:]\n            else:\n                l_current   = self.snode_current.l_mustInclude[:]\n                l_total     = l_current + al_mustInclude\n                self.snode_current.l_mustInclude = l_total[:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds each node in <al_branchNodes> to the self.ml_cwd and append the combined list to ml_allPaths. This method is typically not called by a user, but by other methods in this module. Returns the list of all paths.", "response": "def paths_update(self, al_branchNodes):\n            \"\"\"\n            Add each node in <al_branchNodes> to the self.ml_cwd and\n            append the combined list to ml_allPaths. This method is\n            typically not called by a user, but by other methods in\n            this module.\n\n            Returns the list of all paths.\n            \"\"\"\n            for node in al_branchNodes:\n                #print \"appending %s\" % node\n                l_pwd       = self.l_cwd[:]\n                l_pwd.append(node)\n                #print \"l_pwd: %s\" % l_pwd\n                #print \"ml_cwd: %s\" % self.ml_cwd\n                self.l_allPaths.append(l_pwd)\n            return self.l_allPaths"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new path in the internal stree.", "response": "def mkdir(self, astr_dirSpec):\n            \"\"\"\n            Given an <astr_dirSpec> in form '/a/b/c/d/.../f',\n            create that path in the internal stree, creating all\n            intermediate nodes as necessary\n\n            :param astr_dirSpec:\n            :return:\n            \"\"\"\n            if astr_dirSpec != '/' and astr_dirSpec != \"//\":\n                str_currentPath = self.cwd()\n                l_pathSpec = astr_dirSpec.split('/')\n                if not len(l_pathSpec[0]):\n                    self.cd('/')\n                    l_nodesDepth = l_pathSpec[1:]\n                else:\n                    l_nodesDepth = l_pathSpec\n                for d in l_nodesDepth:\n                    self.mkcd(d)\n                self.cd(str_currentPath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mknode(self, al_branchNodes):\n            b_ret = True\n            # First check that none of these nodes already exist in the tree\n            l_branchNodes = []\n            for node in al_branchNodes:\n                l_path      = self.l_cwd[:]\n                l_path.append(node)\n                #print l_path\n                #print self.ml_allPaths\n                #print self.b_pathOK(l_path)\n                if not self.b_pathOK(l_path):\n                    l_branchNodes.append(node)\n            if not len(l_branchNodes):\n                return False\n            snodeBranch   = C_snodeBranch(l_branchNodes)\n            for node in l_branchNodes:\n                depth = self.snode_current.depth()\n                # if (self.msnode_current != self.msnode_root):\n                snodeBranch.dict_branch[node].depth(depth+1)\n                snodeBranch.dict_branch[node].snode_parent = self.snode_current\n            self.snode_current.node_dictBranch(snodeBranch.dict_branch)\n            # Update the ml_allPaths\n            self.paths_update(al_branchNodes)\n            return b_ret", "response": "Create a set of nodes at current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isfile(self, str_path):\n\n            b_isFile            = False\n            if self.isdir(str_path):\n                b_isFile        = False\n            else:\n                str_parentDir   = '/'.join(str_path.split('/')[0:-1])\n                str_fileName    = str_path.split('/')[-1]\n                if self.cd(str_parentDir)['status']:\n                    l_files = self.lsf(str_parentDir)\n                    if any(str_fileName in f for f in l_files):\n                        b_isFile    = True\n            return b_isFile", "response": "A convenience function returns bool if <str_path > is a file in the tree space\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the contents of the named element at this level.", "response": "def cat(self, name):\n            \"\"\"\n            Returns the contents of the 'name'd element at this level.\n\n            If file does not exist, returns a False\n\n            TODO: parse possible path spec in name...\n            \"\"\"\n\n            origDir = self.cwd()\n            # First, parse any path specs...\n            ret     = None\n            path    = '/'.join(name.split('/')[0:-1])\n            if len(path):\n                name    = name.split('/')[-1]\n                ret     = self.cd(path)\n\n            if name in self.snode_current.d_data:\n                ret     = self.snode_current.d_data[name]\n            else:\n                ret     = False\n            self.cd(origDir)\n            return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a file analog called name and put data to the d_data dictionary under key name.", "response": "def touch(self, name, data):\n            \"\"\"\n            Create a 'file' analog called 'name' and put 'data' to the d_data dictionary\n            under key 'name'.\n\n            The 'name' can contain a path specifier.\n            \"\"\"\n            b_OK        = True\n            str_here    = self.cwd()\n            # print(\"here!\")\n            # print(self.snode_current)\n            # print(self.snode_current.d_nodes)\n            l_path = name.split('/')\n            if len(l_path) > 1:\n                self.cd('/'.join(l_path[0:-1]))\n            name = l_path[-1]\n            self.snode_current.d_data[name] = data\n            # print(self.snode_current)\n            self.cd(str_here)\n            return b_OK"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove a data analog called name.", "response": "def rm(self, name):\n            \"\"\"\n            Remove a data analog called 'name'.\n\n            The 'name' can contain a path specifier.\n\n            Warning: see\n\n                http://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary\n\n            deleting from the snode_current changes dictionary contents for any other\n            agents that have references to the same instance.\n\n            This deletes either directories or files.\n\n            \"\"\"\n            b_OK        = False\n            str_here    = self.cwd()\n            l_path = name.split('/')\n            if len(l_path) > 1:\n                self.cd('/'.join(l_path[0:-1]))\n            name = l_path[-1]\n            if name in self.snode_current.d_data:\n                del self.snode_current.d_data[name]\n                b_OK    = True\n            if name in self.snode_current.d_nodes:\n                del self.snode_current.d_nodes[name]\n                b_OK    = True\n            self.cd(str_here)\n            return b_OK"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends data to the current contents of the the key named name.", "response": "def append(self, name, data):\n            \"\"\"Append 'data' to the current node d_data\n\n            This method appends 'data' to the current contents in the\n            key named 'name'. The append assumes that the operation\n            makes sense and that the data types can be appended to\n            each other.\n\n            \"\"\"\n            b_OK = True\n            self.snode_current.d_data[name] = self.snode_current.d_data[name] + data\n            return b_OK"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef b_pathOK(self, al_path):\n            b_OK  = True\n            try:          self.l_allPaths.index(al_path)\n            except:       b_OK    = False\n            return b_OK", "response": "Checks if the absolute path specified in the al_path is valid for current tree\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a string <astr_path> specifier to a list-based *absolute* lookup, i.e. \"/node1/node2/node3\" is converted to ['/' 'node1' 'node2' 'node3']. The method also understands a paths that start with: '..' or combination of '../../..' and is also aware that the root node is its own parent. If the path list conversion is valid (i.e. exists in the space of existing paths, l_allPaths), return True and the destination path list; else return False and the current path list.", "response": "def b_pathInTree(self, astr_path):\n            \"\"\"\n            Converts a string <astr_path> specifier to a list-based\n            *absolute* lookup, i.e. \"/node1/node2/node3\" is converted\n            to ['/' 'node1' 'node2' 'node3'].\n\n            The method also understands a paths that start with: '..' or\n            combination of '../../..' and is also aware that the root\n            node is its own parent.\n\n            If the path list conversion is valid (i.e. exists in the\n            space of existing paths, l_allPaths), return True and the\n            destination path list; else return False and the current\n            path list.\n            \"\"\"\n            if astr_path == '/':  return True, ['/']\n            al_path               = astr_path.split('/')\n            # Do we have a trailing '/' and not doing a '../'? If so, strip it..!\n            if astr_path != '../' and al_path[-1] == '':\n                al_path = al_path[0:-2]\n\n            # Check for absolute path\n            if not len(al_path[0]):\n                al_path[0]          = '/'\n                # print \"returning %s : %s\" % (self.b_pathOK(al_path), al_path)\n                return self.b_pathOK(al_path), al_path\n            # Here we are in relative mode...\n            # First, resolve any leading '..'\n            l_path        = self.l_cwd[:]\n            if al_path[0] == '..':\n                while al_path[0] == '..' and len(al_path):\n                    l_path    = l_path[0:-1]\n                    if len(al_path) >= 2: al_path   = al_path[1:]\n                    else: al_path[0] = ''\n                    # print \"l_path  = %s\" % l_path\n                    # print \"al_path = %s (%d)\" % (al_path, len(al_path[0]))\n                if len(al_path[0]):\n                    # print \"extending %s with %s\" % (l_path, al_path)\n                    l_path.extend(al_path)\n            else:\n                l_path      = self.l_cwd\n                l_path.extend(al_path)\n            # print \"final path list = %s (%d)\" % (l_path, len(l_path))\n            if len(l_path)>=1 and l_path[0] != '/':      l_path.insert(0, '/')\n            if len(l_path)>1:            l_path[0]       = ''\n            if not len(l_path):          l_path          = ['/']\n            str_path      = '/'.join(l_path)\n            # print \"final path str  = %s\" % str_path\n            b_valid, al_path = self.b_pathInTree(str_path)\n            return b_valid, al_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges working node to astr_path.", "response": "def cdnode(self, astr_path):\n            \"\"\"Change working node to astr_path.\n\n            The path is converted to a list, split on '/'. By performing a 'cd'\n            all parent and derived nodes need to be updated relative to\n            new location.\n\n            Args:\n                astr_path (string): The path to cd to.\n\n            Returns:\n                {\"status\" : True/False , \"path\": l_cwd -- the path as list}\n\n            \"\"\"\n\n            # Start at the root and then navigate to the\n            # relevant node\n            l_absPath             = []\n            b_valid, l_absPath    = self.b_pathInTree(astr_path)\n            if b_valid:\n                #print \"got cdpath = %s\" % l_absPath\n                self.l_cwd              = l_absPath[:]\n                self.snode_current      = self.snode_root\n                self.sbranch_current    = self.sbranch_root\n                #print l_absPath\n                for node in l_absPath[1:]:\n                    self.snode_current = self.snode_current.d_nodes[node]\n                self.sbranch_current.dict_branch = self.snode_current.snode_parent.d_nodes\n                return {\"status\": True, \"path\": self.l_cwd}\n            return {\"status\": False, \"path\": []}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting only the files in the astr_path.", "response": "def lsf(self, astr_path=\"\"):\n            \"\"\"\n            List only the \"files\" in the astr_path.\n\n            :param astr_path: path to list\n            :return: \"files\" in astr_path, empty list if no files\n            \"\"\"\n            d_files = self.ls(astr_path, nodes=False, data=True)\n            l_files = d_files.keys()\n            return l_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the set of nodes branching from current node as string", "response": "def str_lsnode(self, astr_path=\"\"):\n            \"\"\"\n            Print/return the set of nodes branching from current node as string\n            \"\"\"\n            self.sCore.reset()\n            str_cwd       = self.cwd()\n            if len(astr_path): self.cdnode(astr_path)\n            for node in self.snode_current.d_nodes.keys():\n                self.sCore.write('%s\\n' % node)\n            str_ls = self.sCore.strget()\n            if len(astr_path): self.cdnode(str_cwd)\n            return str_ls"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of strings that are branching from current node as list of strings", "response": "def lstr_lsnode(self, astr_path=\"\"):\n            \"\"\"\n            Return the string names of the set of nodes branching from\n            current node as list of strings\n            \"\"\"\n            self.sCore.reset()\n            str_cwd       = self.cwd()\n            if len(astr_path): self.cdnode(astr_path)\n            lst = self.snode_current.d_nodes.keys()\n            if len(astr_path): self.cdnode(str_cwd)\n            return lst"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lsbranch(self, astr_path=\"\"):\n            self.sCore.reset()\n            str_cwd       = self.cwd()\n            if len(astr_path): self.cdnode(astr_path)\n            self.sCore.write('%s' % self.sbranch_current.dict_branch.keys())\n            str_ls = self.sCore.strget()\n            if len(astr_path): self.cdnode(str_cwd)\n            return str_ls", "response": "Print and return the set of nodes in current branch"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting the tree from the current node.", "response": "def lstree(self, astr_path=\"\"):\n            \"\"\"\n            Print/return the tree from the current node.\n            \"\"\"\n            self.sCore.reset()\n            str_cwd       = self.cwd()\n            if len(astr_path): self.cdnode(astr_path)\n            str_ls        = '%s' % self.snode_current\n            print(str_ls)\n            if len(astr_path): self.cdnode(str_cwd)\n            return str_ls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting the meta information of the node.", "response": "def lsmeta(self, astr_path=\"\"):\n            \"\"\"\n            Print/return the \"meta\" information of the node, i.e.\n                o mustInclude\n                o mustNotInclude\n                o hitCount\n            \"\"\"\n            self.sCore.reset()\n            str_cwd       = self.cwd()\n            if len(astr_path): self.cdnode(astr_path)\n            b_contentsFlag        = self.snode_current.b_printContents\n            self.snode_current.b_printContents = False\n            str_ls        = '%s' % self.snode_current\n            print(str_ls)\n            if len(astr_path): self.cdnode(str_cwd)\n            self.snode_current.b_printContents  = b_contentsFlag\n            return str_ls"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef treeNode_metaSet(self, astr_path, **kwargs):\n            self.cdnode(astr_path)\n            self.snode_current.metaData_print(self.b_printMetaData)\n            return {'status': True}", "response": "Sets the metaData_print bit on node at astr_path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef node_save(self, astr_pathInTree, **kwargs):\n            str_pathDiskRoot    = '/tmp'\n            str_pathDiskOrig    = os.getcwd()\n            srt_pathDiskFull    = ''\n            str_pathTree        = ''\n            str_pathTreeOrig    = self.pwd()\n            b_failOnDirExist    = True\n            b_saveJSON          = True\n            b_savePickle        = False\n            for key, val in kwargs.items():\n                if key == 'startPath':      str_pathTree        = val\n                if key == 'pathDiskRoot':   str_pathDiskRoot    = val\n                if key == 'failOnDirExist': b_failOnDirExist    = val\n                if key == 'saveJSON':       b_saveJSON          = val\n                if key == 'savePickle':     b_savePickle        = val\n\n            str_pathDiskFull    = str_pathDiskRoot + str_pathTree\n            # print('\\n')\n            # print('In self.node_save():')\n            # print('memTree:  %s' % (str_pathTree))\n            # print('diskRoot: %s' % str_pathDiskRoot)\n            # print('distPath: %s' % str_pathDiskFull)\n            # print(kwargs.keys())\n            # print(kwargs.values())\n            # print('\\n')\n\n            if len(str_pathDiskRoot):\n                if not os.path.isdir(str_pathDiskRoot):\n                    # print('Processing path: %s' % str_pathDiskRoot)\n                    try:\n                        # print('mkdir %s' % str_pathDiskRoot)\n                        os.makedirs(str_pathDiskRoot)\n                    except OSError as exception:\n                        return {'status' :      False,\n                                'continue':     False,\n                                'message':      'unable to create pathDiskRoot: %s' % str_pathDiskRoot,\n                                'exception':    exception}\n                # print('cd to %s' % str_pathDiskRoot)\n                os.chdir(str_pathDiskRoot)\n                if self.cd(str_pathTree)['status']:\n                    if str_pathTree != '/':\n                        # print('mkdir %s' % str_pathDiskFull)\n                        try:\n                            os.makedirs(str_pathDiskFull)\n                        except OSError as exception:\n                            if b_failOnDirExist:\n                                return {'status' :      False,\n                                        'continue':     False,\n                                        'message':      'unable to create pathDiskRoot: %s' % str_pathDiskRoot,\n                                        'exception':    exception}\n\n                    os.chdir(str_pathDiskFull)\n                    for str_filename, contents in self.snode_current.d_data.items():\n                        # print(\"str_filename = %s; contents = %s\" % (str_filename, contents))\n                        if b_saveJSON:\n                            with open(str_filename, 'w')    as f: json.dump(contents,     f)\n                            f.close()\n                        if b_savePickle:\n                            with open(str_filename, 'wb')   as f: json.dump(contents,     f)\n                            f.close()\n                else:\n                    return{'status':    False,\n                           'continue':  False,\n                           'message':   'pathTree invalid'}\n                self.cd(str_pathTreeOrig)\n                os.chdir(str_pathDiskOrig)\n                return {'status':   True,\n                        'continue': True}\n            return {'status':   False,\n                    'continue': False,\n                    'message':  'pathDisk not specified'}", "response": "This method is called by the explore method to save the internal node in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef node_copy(self, astr_pathInTree, **kwargs):\n\n            # Here, 'T' is the target 'disk'.\n            T                   = None\n            str_pathDiskRoot    = ''\n            str_pathDiskFull    = ''\n            str_pathTree        = ''\n            str_pathTreeOrig    = self.pwd()\n            for key, val in kwargs.items():\n                if key == 'startPath':      str_pathTree        = val\n                if key == 'pathDiskRoot':   str_pathDiskRoot    = val\n                if key == 'destination':    T                   = val\n            str_pathDiskOrig    = T.pwd()\n            str_pathDiskFull    = str_pathDiskRoot + str_pathTree\n\n            # self.debug('In node_copy... str_pathDiskfull = %s\\n' % str_pathDiskFull)\n\n            if len(str_pathDiskFull):\n                if not T.isdir(str_pathDiskFull):\n                    try:\n                        T.mkdir(str_pathDiskFull)\n                    except:\n                        return {'status' :      False,\n                                'continue':     False,\n                                'message':      'unable to create pathDiskFull: %s' % str_pathDiskFull,\n                                'exception':    exception}\n                if T.cd(str_pathDiskFull)['status']:\n                    if self.cd(str_pathTree)['status']:\n                        T.cd(str_pathDiskFull)\n                        for str_filename, contents in self.snode_current.d_data.items():\n                            # print(\"str_filename = %s; contents = %s\" % (str_filename, contents))\n                            T.touch(str_filename, contents)\n                    else:\n                        return{'status':    False,\n                               'continue':  False,\n                               'message':   'source pathTree invalid'}\n                    self.cd(str_pathTreeOrig)\n                    T.cd(str_pathDiskOrig)\n                    return {'status':   True,\n                            'continue': True}\n                else:\n                    return{'status':    False,\n                           'continue':  False,\n                           'message':   'target pathDiskFull invalid'}\n            return {'status':   False,\n                    'continue': False,\n                    'message':  'pathDiskFull not specified'}", "response": "This method copies the items and folders in the data tree to the target disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tree_load(**kwargs):\n            str_pathDiskRoot    = ''\n            b_loadJSON          = True\n            b_loadPickle        = False\n            for key, val in kwargs.items():\n                if key == 'pathDiskRoot':   str_pathDiskRoot    = val\n                if key == 'loadJSON':       b_loadJSON          = val\n                if key == 'loadPickle':     b_loadPickle        = val\n\n            l_dir   = []\n            l_file  = []\n            for str_root, l_directories, l_filenames in os.walk(str_pathDiskRoot):\n                for str_dir in l_directories:\n                    l_dir.append(os.path.join(str_root, str_dir))\n                for str_file in l_filenames:\n                    l_file.append(os.path.join(str_root, str_file))\n            stree_dirs  = [d.replace(str_pathDiskRoot, '') for d in l_dir]\n            stree_files = [f.replace(str_pathDiskRoot, '') for f in l_file]\n\n            # Create the tree\n            rtree       = C_stree()\n            # Build the directory structures\n            for d in stree_dirs:\n                # print(d)\n                rtree.mkdir(d)\n            # Now read any files\n            for f in stree_files:\n                dirname     = os.path.dirname(f)\n                filename    = os.path.basename(f)\n                # print(f)\n                if b_loadJSON:\n                    with open(str_pathDiskRoot + '/' + f, 'r') as fp:\n                        contents = json.load(fp)\n                        fp.close()\n                if b_loadPickle:\n                    with open(str_pathDiskRoot + '/' + f, 'rb') as fp:\n                        contents = pickle.load(fp)\n                        fp.close()\n\n                if rtree.cd(dirname)['status']:\n                    rtree.touch(filename, contents)\n\n            return rtree", "response": "Load a tree from disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef treeWalk(self, **kwargs):\n\n            str_recursePath = ''\n            str_startPath   = '/'\n            f               = None\n            ret             = {}\n\n            for key,val in kwargs.items():\n                if key == 'startPath':  str_startPath   = val\n                if key == 'f':          f               = val\n\n            # print 'processing node: %s' % str_startPath\n            if self.cd(str_startPath)['status']:\n                ret = f(str_startPath, **kwargs)\n                if ret['status']:\n                    for node in self.lstr_lsnode(str_startPath):\n                        if str_startPath == '/': str_recursePath = \"/%s\" % node\n                        else: str_recursePath = '%s/%s' % (str_startPath, node)\n                        self.treeWalk(f = f, startPath = str_recursePath)\n            return ret", "response": "This function walks through a C_stree and applies a passed function to each node in the internal path database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lwd(self, astr_startPath, **kwargs):\n            if self.cd(astr_startPath)['status']:\n                self.l_lwd.append(self.cwd())\n\n            return {'status': True, 'cwd': self.cwd()}", "response": "Return the cwd in treeRecurse compatible format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fwd(self, astr_startPath, **kwargs):\n            status = self.cd(astr_startPath)['status']\n            if status:\n                l = self.lsf()\n                if len(l):\n                    lf = [self.cwd() + '/' + f for f in l]\n                    for entry in lf:\n                        self.l_fwd.append(entry)\n\n            return {'status': status, 'cwd': self.cwd()}", "response": "Return the cwd in treeRecurse compatible format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of path to files from here in the stree using the child explore access.", "response": "def filesFromHere_explore(self, astr_startPath = '/'):\n            \"\"\"\n            Return a list of path/files from \"here\" in the stree, using\n            the child explore access.\n\n            :param astr_startPath: path from which to start\n            :return:\n            \"\"\"\n            self.l_fwd  = []\n            self.treeExplore(startPath = astr_startPath, f=self.fwd)\n            self.l_allFiles = [f.split('/') for f in self.l_fwd]\n            for i in range(0, len(self.l_allFiles)):\n                self.l_allFiles[i][0] = '/'\n            return self.l_fwd"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pathFromHere_walk(self, astr_startPath = '/'):\n\n            self.l_lwd  = []\n            self.treeWalk(startPath = astr_startPath, f=self.lwd)\n            return self.l_lwd", "response": "This method returns a list of paths from here in the stree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pathFromHere_explore(self, astr_startPath = '/'):\n\n            self.l_lwd  = []\n            self.treeExplore(startPath = astr_startPath, f=self.lwd)\n            return self.l_lwd", "response": "Return a list of paths from here in the stree using the the\n            child explore access."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_py_script(filename):\n    \"Returns True if a file is a python executable.\"\n    if not os.path.exists(filename) and os.path.isfile(filename):\n        return False\n    elif filename.endswith(\".py\"):\n        return True\n    elif not os.access(filename, os.X_OK):\n        return False\n    else:\n        try:\n            with open(filename, \"r\") as fp:\n                first_line = fp.readline().strip()\n            return \"#!\" in first_line and \"python\" in first_line\n        except StopIteration:\n            return False", "response": "Returns True if a file is a python executable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_bytecode_extension(filename):\n    path, extension = os.path.splitext(filename)\n    if extension == '.pyc':\n        filename = '%s.py' % path\n    return filename", "response": "Removes the. pyc extension from the filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extractRecord(resolver, name, answers, level=10):\n    '''\n    This method is copy-pasted from twisted.names.common.\n    The difference with the original is, that it favors IPv4 responses over\n    IPv6. This is motivated by the problem of resolving \"maps.googleapis.com\"\n    name, which has both types of entries.\n    The logic in twisted.internet.tcp.Connector assumes the IPv4 type of\n    address, and it fails to connect if IPv6 address is given.\n    This problem only occurs with Twisted 10.2. In 12.1 the Connector\n    implementation can already handle both types of addresses.\n    '''\n\n    if not level:\n        return None\n    for r in answers:\n        if r.name == name and r.type == dns.A:\n            return socket.inet_ntop(socket.AF_INET, r.payload.address)\n    for r in answers:\n        if r.name == name and r.type == dns.CNAME:\n            result = extractRecord(\n                resolver, r.payload.name, answers, level - 1)\n            if not result:\n                return resolver.getHostByName(\n                    str(r.payload.name), effort=level - 1)\n            return result\n    if hasattr(socket, 'inet_ntop'):\n        for r in answers:\n            if r.name == name and r.type == dns.A6:\n                return socket.inet_ntop(socket.AF_INET6, r.payload.address)\n        for r in answers:\n            if r.name == name and r.type == dns.AAAA:\n                return socket.inet_ntop(socket.AF_INET6, r.payload.address)\n    # No answers, but maybe there's a hint at who we should be asking about\n    # this\n    for r in answers:\n        if r.type == dns.NS:\n            r = Resolver(servers=[(str(r.payload.name), dns.PORT)])\n            d = r.lookupAddress(str(name))\n            d.addCallback(lambda (ans, auth, add):\n                          extractRecord(r, name, ans + auth + add, level - 1))\n            return d", "response": "Extract a record from a list of DNS records."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lookupAllRecords(self, name, timeout = None):\n        return self._lookup(name, dns.IN, dns.A, timeout)", "response": "Lookup all records for a name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new AnalysisSystem on the server.", "response": "def create(cls, identifier_name, verbose_name, tag_filter_expression=''):\n        \"\"\"\n        Create a new :class:`AnalysisSystem` on the server.\n\n        :param identifier_name: Unique identifier string.\n        :param verbose_name: A descriptive name of the AnalysisSystem.\n        :param tag_filter_expression: Tag filters to automatically select samples for this AnalysisSystem.\n        :return: The created :class:`AnalysisSystem` object.\n        \"\"\"\n        return cls._create(identifier_name=identifier_name, verbose_name=verbose_name, tag_filter_expression=tag_filter_expression)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_markers(f):\n    @click.pass_context\n    def new_func(ctx, *args, **kwargs):\n        command = ctx.info_name\n        assert command is not None\n        command_name = ctx.command_path\n        click_extensions.echo_with_markers(command_name, marker_color='green')\n\n        def print_error(code):\n            click_extensions.echo_with_markers('end of {} (exit code: {code})'.format(\n                command_name, code=code), marker_color='red')\n\n        def print_success():\n            click_extensions.echo_with_markers('end of {}'.format(\n                command_name), marker_color='green')\n        try:\n            ctx.invoke(f, *args, **kwargs)\n        except SystemExit as e:\n            code = e.code if e.code is not None else exit_codes.ABORT\n            if code == 0:\n                print_success()\n            else:\n                print_error(code)\n            raise\n        except click.ClickException as e:\n            code = e.exit_code\n            if code == 0:\n                print_success()\n            else:\n                print_error(code)\n            raise\n        except click.Abort as e:\n            code = exit_codes.ABORT\n            print_error(code)\n            raise\n        except Exception as e:\n            code = -1\n            print_error(code)\n            raise\n        else:\n            print_success()\n            return\n    return update_wrapper(new_func, f)", "response": "A decorator that prints the invoked command\n            before and after the command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef catch_exception(exception, message=None):\n    def decorator(f):\n        @click.pass_context\n        def new_func(ctx, *args, **kwargs):\n            try:\n                return ctx.invoke(f, *args, **kwargs)\n            except exception as e:\n                message1 = message if message is not None else '{}'.format(e)\n                click.echo(message1)\n                ctx.exit(code=exit_codes.OTHER_FAILURE)\n        return update_wrapper(new_func, f)\n    return decorator", "response": "A decorator that gracefully handles exceptions exiting\n    with exit_codes. OTHERFAILURE."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread file by given name and returns array of CallEdge objects", "response": "def get_calls(self, job_name):\n        '''\n        Reads file by given name and returns CallEdge array\n        '''\n\n        config = self.file_index.get_by_name(job_name).yaml\n\n        calls = self.get_calls_from_dict(config, from_name=job_name)\n\n        return calls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing unfolded yaml object to CallEdge array and returns a list of CallEdge objects", "response": "def get_calls_from_dict(self, file_dict, from_name, settings={}):\n        '''\n        Processes unfolded yaml object to CallEdge array\n\n        settings is a dict of settings for keeping information like\n        in what section we are right now (e.g. builders, publishers)\n        '''\n\n        calls = []\n        call_settings = dict(settings)\n\n        # Include all possible sections\n        # The way to draw them is defined in call graph\n        special_sections = {'builders', 'publishers', 'wrappers'}\n\n        # Trigger flags\n        triggers = {'trigger-builds', 'trigger-parameterized-builds'}\n\n        if isinstance(file_dict, dict):\n            for key in file_dict:\n\n                if key in special_sections:\n                    call_settings['section'] = key\n\n                if key in triggers:\n                    calls.extend(self.extract_call(file_dict[key], from_name, settings=call_settings))\n                else:\n                    calls.extend(self.get_calls_from_dict(file_dict[key], from_name, settings=call_settings))\n        elif type(file_dict) == list:\n            for value in file_dict:\n                calls.extend(self.get_calls_from_dict(value, from_name, settings=call_settings))\n\n        return calls"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_call(self, call, from_name, settings):\n        '''\n        Creates CallEdge from call file (i.e. trigger-builds)\n\n        Returns a list of calls\n        '''\n\n        call = defaultdict(lambda: None, call[0])\n\n        try:\n            call['section'] = settings['section']\n        except KeyError:\n            call['section'] = ''\n\n        project = call['project']\n\n        # If there is more than one call in a single file\n        if type(project) == list:\n            calls = []\n\n            for name in project:\n                calls.append(self.create_call(name, call, from_name))\n\n            return calls\n        else:\n            return [self.create_call(project, call, from_name)]", "response": "Creates CallEdge from call file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all includes from a config in a given path", "response": "def get_includes(self, path):\n        \"\"\"\n        Get all includes from a config in a given path\n        \"\"\"\n        config = self.file_index.unfold_yaml(path)\n\n        return self.get_includes_from_dict(config, extract=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef openfile(filename, mode=\"rt\", *args, expanduser=False, expandvars=False,\n             makedirs=False, **kwargs):\n    \"\"\"Open filename and return a corresponding file object.\"\"\"\n    if filename in (\"-\", None):\n        return sys.stdin if \"r\" in mode else sys.stdout\n    if expanduser:\n        filename = os.path.expanduser(filename)\n    if expandvars:\n        filename = os.path.expandvars(filename)\n    if makedirs and (\"a\" in mode or \"w\" in mode):\n        parentdir = os.path.dirname(filename)\n        if not os.path.isdir(parentdir):\n            os.makedirs(parentdir)\n    if filename.endswith(\".gz\"):\n        if gzip is None:\n            raise NotImplementedError\n        _open = gzip.open\n    elif filename.endswith(\".bz2\"):\n        if bz2 is None:\n            raise NotImplementedError\n        _open = bz2.open\n    elif filename.endswith(\".xz\") or filename.endswith(\".lzma\"):\n        if lzma is None:\n            raise NotImplementedError\n        _open = lzma.open\n    else:\n        _open = open\n    return _open(filename, mode, *args, **kwargs)", "response": "Open a file and return a corresponding file object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting or create an analysis system instance with the given uuid.", "response": "def get_or_create_analysis_system_instance(instance_uuid='', identifier='', verbose_name='', tag_filter_exp='', uuid_file='uuid.txt'):\n    \"\"\"Get or create an analysis system instance for the analysis system with the respective identifier.\n\n    This is a function for solving a common problem with implementations of MASS analysis clients.\n    If the analysis system instance already exists, one has either a uuid or a file with the uuid as content.\n    In this case one can retrieve the analysis system instance with the uuid.\n    \n    Otherwise one wants to create an instance for the analysis system with the given identifier.\n    If the analysis system does not yet exists, it is also created.\n    Then an analysis system instance for the analysis system is created and the uuid is saved to the uuid_file.\n\n    :param instance_uuid: If not empty, directly gets the analysis system instance with the given uuid and tries nothing else.\n    :param uuid_file: A filepath. If not empty, tries to read an uuid from the filepath. Otherwise the uuid is later saved to this file.\n    :param identifier: Get an instance for an analysis system with the given identifier as string.\n    :param verbose_name: The verbose name of the respective analysis system.\n    :param tag_filter_exp: The tag filter expression as a string of the respective analysis system.\n    :return: a analysis system instance\n    \"\"\"\n    if instance_uuid:\n        return resources.AnalysisSystemInstance.get(instance_uuid)\n\n    try:\n        with open(uuid_file, 'r') as uuid_fp:\n            instance_uuid = uuid_fp.read().strip()\n            return resources.AnalysisSystemInstance.get(instance_uuid)\n    except IOError:\n        logging.debug('UUID file does not exist.')\n\n    try:\n        analysis_system = resources.AnalysisSystem.get(identifier)\n    except requests.HTTPError:\n        analysis_system = resources.AnalysisSystem.create(identifier, verbose_name, tag_filter_exp)\n    analysis_system_instance = analysis_system.create_analysis_system_instance()\n    with open(uuid_file, 'w') as uuid_fp:\n        uuid_fp.write(analysis_system_instance.uuid)\n    return analysis_system_instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_analyses(analysis_system_instance, analysis_method, sleep_time):\n    try:\n        while True:\n            for analysis_request in analysis_system_instance.get_scheduled_analyses():\n                analysis_method(analysis_request)\n            time.sleep(sleep_time)\n    except KeyboardInterrupt:\n        logging.debug('Shutting down.')\n        return", "response": "Processes all analyses scheduled for the analysis system instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n    empty = False\n    while not empty:\n      try:\n        # Grab fields\n        url = self.genre_urls.get()\n        namestamp = \"{}.csv\".format(str(int(round(time.time() * 1000000))))\n        # GET request\n        self.logger.info('Attempting to request %s', url)\n        self.crawler.set_url(url)\n        series = self.crawler.get_series()\n        self.logger.info('Attempting to write %s', url)\n        # Grab writer -> writes series\n        csv_dir = './{}/{}'.format(self.directory, namestamp)\n        writer = csv.writer(open(csv_dir, 'wb'))\n        writer.writerow(Series.fields)\n        for s in series:\n          writer.writerow(s.to_line())\n        self.logger.info('Wrote %s', namestamp)\n      except Exception, e: # pylint: disable=W0703\n        print e\n      finally:\n        self.genre_urls.task_done()\n        empty = self.genre_urls.empty()", "response": "This function runs the task loop."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef proveGt(x,tTilde,kw,y):\n    # Verify types\n    assertType(x, G1Element)\n    assertType(tTilde, G2Element)\n\n    # Compute the proof.\n    beta = pair(x,tTilde)\n    g = generatorGt()\n    p = g**kw\n    v = randomZ(orderGt())\n    t1 = g**v\n    t2 = beta**v\n\n    c = hashZ(g,p,beta,y,t1,t2)\n    u = (v- (c*kw)) % orderGt()\n    return (p,c,u)", "response": "Generate a zero - knowledge proof that DL ( g^kw == DL ( e x t )^kw where g e x t is a pair of G1Elements and t is a pair of G2Elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a zero - knowledge proof that DL ( Q^kw ) == DL ( e ( x tTilde )^y", "response": "def proveG1(x,tTilde,kw,y):\n    \"\"\"\n    Generate a zero-knowledge proof that DL(Q*kw) == DL(e(x,tTilde)^kw) where\n    <Q> = G1.\n    \"\"\"\n    # Verify types\n    assertType(x, G1Element)\n    assertType(tTilde, G2Element)\n\n    # Compute the proof.\n    beta = pair(x,tTilde)\n    Q = generatorG1()\n    p = Q*kw\n    v = randomZ(orderGt())\n    t1 = Q*v\n    t2 = beta**v\n\n    t1.normalize()\n\n    c = hashZ(Q,p,beta,y,t1,t2)\n    u = (v-(c*kw)) % orderGt()\n    return (p,c,u)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verifyG1(x, tTilde, y, pi, errorOnFail=True):\n    # Unpack the proof\n    p,c,u = pi\n\n    # Verify types\n    assertType(x, G1Element)\n    assertType(tTilde, G2Element)\n    assertType(y, GtElement)\n    assertType(p, G1Element)\n\n    # TODO: beta can be pre-computed while waiting for a server response.\n    Q = generatorG1()\n    beta = pair(x,tTilde)\n\n    # Recompute c'\n    t1 = Q*u + p*c \n    t2 = beta**u * y**c\n\n    t1.normalize()\n\n    cPrime = hashZ(Q,p,beta,y,t1,t2)\n\n    # Check computed @c' against server's value @c\n    if cPrime == c:\n        return True\n\n    if errorOnFail:\n        raise Exception(\"zero-knowledge proof failed verification.\")\n    else:\n        return False", "response": "Verify a zero - knowledge proof where p \\ in G1."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nverifies a zero - knowledge proof.", "response": "def verifyGt(x, tTilde, y, pi, errorOnFail=True):\n    \"\"\"\n    Verifies a zero-knowledge proof. \n    @x: Blinded message, G1Element, x = HG1(m)*r\n    @tTilde: hashed tweak, G2Element, t~ = HG2(t)\n    @y: server response (intermediate result), GtElement\n    @pi:  pi = (p, c, u), zero-knowledge proof from server, \n      p = g^kw, GtElement; c,u integer values\n    @errorOnFail: Rasise an exception if the proof does not hold.\n    \"\"\"\n    # Unpack the proof\n    p,c,u = pi\n\n    # Verify types\n    assertType(x, G1Element)\n    assertType(tTilde, G2Element)\n    assertType(y, GtElement)\n    assertType(p, GtElement)\n\n    # TODO: This can be pre-computed while waiting for a server response.\n    g = generatorGt()\n    beta = pair(x,tTilde)\n\n    # Recompute c'\n    t1 = g**u * p**c \n    t2 = beta**u * y**c\n\n    cPrime = hashZ(g,p,beta,y,t1,t2)\n\n    # Check computed @c' against server's value @c\n    if cPrime == c:\n        return True\n\n    if errorOnFail:\n        raise Exception(\"zero-knowledge proof failed verification.\")\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef blind(m, hashfunc=hashG1):\n    # Find r with a suitable inverse in Gt\n    rInv = None\n    while not rInv:\n        r = randomZ()\n        rInv = inverse(r, orderGt())\n\n    return rInv, hashfunc(m) * r", "response": "Blinds an arbitrary string or byte array or array of bytes using an ephemeral key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunwrap an element x by decoding and then deserializing it.", "response": "def _unwrap(x, deserializeFunc, decodeFunc=base64.urlsafe_b64decode, compress=True):\n    \"\"\"\n    Unwraps an element @x by decoding and then deserializing\n    \"\"\"\n    return deserializeFunc(decodeFunc(x), compress)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating the teaching object.", "response": "def _validate_teaching(cls, belief, teaching, *args, **kwargs):\n        \"\"\"\n        Check to make sure the teaching object which will be used as a dictionary key is hashable\n        \"\"\"\n        # attempt to transform\n        namespaces = kwargs.get('namespaces', None)\n        if not namespaces:\n            for a in args:\n                if isinstance(a, dict): # @TODO check types\n                    namespaces = a\n                    break\n\n        try:\n            return etree.XPath(teaching, namespaces=namespaces or {})\n        except:\n            pass\n\n        try:\n            xml_doc = etree.XML(teaching)\n            return etree.XSLT(xml_doc)\n        except:\n            pass\n\n        raise xml_dogma.XmlDogmaException('The belief \"%s\" does not have a valid teaching. The Teaching must be an xpath string or xslt document. Received teaching: \"%s\" (type: %s)' % (belief, teaching, type(teaching)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(file_name=None, is_encoding=True, ignore_raises=False):\n    if file_name is None:\n        raise Exception(\"File name not provided\")\n    if ignore_raises:\n        try:\n            return read_file(is_encoding=is_encoding,\n                             file_path=path_format(\n                                 file_path=CURR_PATH,\n                                 file_name=file_name,\n                                 ignore_raises=ignore_raises))\n        except Exception:\n            # TODO: not silence like this,\n            # must be on setup.cfg, README path\n            return 'NOTFOUND'\n    return read_file(is_encoding=is_encoding,\n                     file_path=path_format(\n                         file_path=CURR_PATH,\n                         file_name=file_name,\n                         ignore_raises=ignore_raises))", "response": "Read file from file system"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build(sub_parser, cmds):\n\n    res = {}\n    for cmd in cmds:\n        res[cmd.name] = cmd(sub_parser)\n    # end for cmd in cmds\n\n    return res", "response": "build\n    - Builds a list of command objects"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding permission name for model_class.", "response": "def build_permission_name(model_class, prefix):\n    \"\"\" Build permission name for model_class (like 'app.add_model'). \"\"\"\n    model_name = model_class._meta.object_name.lower()\n    app_label = model_class._meta.app_label\n    action_name = prefix\n    perm = '%s.%s_%s' % (app_label, action_name, model_name)\n    return perm"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_permission(self, service, func):\n        if self.permission:\n            perm = self.permission\n\n        elif self.prefix is False:\n            # No permission will be checked\n            perm = False\n\n        elif self.prefix:\n            perm = build_permission_name(service.model_class, self.prefix)\n\n        else:\n            name = func.__name__\n            # check if there is a translation between default permission and method name\n            action_name = METHOD_PERMISSION_TRANSLATION.get(name, name)\n\n            perm = build_permission_name(service.model_class, action_name)\n        return perm", "response": "Build permission required to access function func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nraise PermissionDenied if user has no permission for object.", "response": "def has_perm(self, service, perm_name, obj, call_name):\n        \"\"\"\n        Raise PermissionDenied if user has no permission in object\n        \"\"\"\n        user = service.user\n        if not (perm_name is False):\n            if not user.has_perm(perm_name, obj=obj):\n                LOG_PERM.warn(\n                    u'User %s has no permission %s. Access to %s with obj=%s',\n                    user, perm_name, call_name, obj)\n                raise PermissionDenied(u'User %s has no permission %s for object %s' % (service.user, perm_name, obj))\n\n            LOG_PERM.debug(\n                u'User %s was authorized to access %s with permission %s with obj=%s',\n                user, call_name, perm_name, obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nraises django.core.exceptions.ValidationError if any validation error exists", "response": "def validate(self, obj):\n        \"\"\" Raises django.core.exceptions.ValidationError if any validation error exists \"\"\"\n\n        if not isinstance(obj, self.model_class):\n            raise ValidationError('Invalid object(%s) for service %s' % (type(obj), type(self)))\n        LOG.debug(u'Object %s state: %s', self.model_class, obj.__dict__)\n        obj.full_clean()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_objects(self, objects, perm=None):\n        if perm is None:\n            perm = build_permission_name(self.model_class, 'view')\n        return filter(lambda o: self.user.has_perm(perm, obj=o), objects)", "response": "Return only objects with specified permission in objects list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disconnect(self):\n        '''\n        This is called as part of the agency shutdown.\n        '''\n        self.log(\"Disconnecting broker %r.\", self)\n        d = defer.succeed(None)\n        if self.is_master():\n            if self.listener is not None:\n                d.addCallback(defer.drop_param, self.listener.stopListening)\n                d.addCallback(defer.drop_param, self.factory.disconnect)\n        elif self.is_slave():\n            d = defer.maybeDeferred(self.factory.disconnect)\n        elif self._cmp_state(BrokerRole.disconnected):\n            return defer.succeed(None)\n        d.addCallback(defer.drop_param, self.become_disconnected)\n        return d", "response": "Disconnects the broker from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if we have a slave agency which is not standalone running.", "response": "def has_slave(self):\n        '''Returns True/False wether we have a slave agency which is not\n        standalone running.'''\n        slave = first(x for x in self.slaves.itervalues()\n                      if not x.is_standalone)\n        return slave is not None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef become_slave(self, broker):\n        '''\n        Run as part of the handshake.\n        @param broker: Remote reference to the broker object\n        '''\n        self._set_state(BrokerRole.slave)\n        self._master = broker\n        d = defer.succeed(None)\n        if callable(self.on_slave_cb):\n            d.addCallback(defer.drop_param, self.on_slave_cb)\n\n        d.addCallback(defer.drop_param, self._master.callRemote,\n                      'handshake', self, self.agency, self.agency.agency_id,\n                      self.is_standalone())\n        d.addCallback(defer.inject_param, 1, self.update_state,\n                      'reset_locally')\n\n        for medium in self.agency.iter_agents():\n            d.addCallback(defer.drop_param, self.register_agent, medium)\n\n        return d", "response": "Run as part of the handshake."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nspawning a Deferred that resolves when the master agency is missing a master agency.", "response": "def spawn_missing_master(self):\n        '''\n        Notifies the standalone slave agency that the master agency is missing\n        '''\n        d = defer.succeed(None)\n        if callable(self.on_master_missing_cb):\n            d.addCallback(defer.drop_param, self.on_master_missing_cb)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_controller(cls, config, session, left_menu_items=None):\n        m = config.model\n        Controller = config.defaultCrudRestController\n\n        class ModelController(Controller):\n            model        = m\n            table        = config.table_type(session)\n            table_filler = config.table_filler_type(session)\n            new_form     = config.new_form_type(session)\n            new_filler   = config.new_filler_type(session)\n            edit_form    = config.edit_form_type(session)\n            edit_filler  = config.edit_filler_type(session)\n            allow_only   = config.allow_only\n\n            if hasattr(config.layout, 'crud_resources'):\n                resources = config.layout.crud_resources\n\n            def _before(self, *args, **kw):\n                super(self.__class__, self)._before(*args, **kw)\n\n                tmpl_context.make_pager_args = make_pager_args\n\n                if request.response_type not in ('application/json',):\n                    default_renderer = AdminController._get_default_renderer()\n                    for action in ('get_all', 'new', 'edit'):\n                        for template in config.layout.crud_templates.get(action, []):\n                            if template.startswith(default_renderer):\n                                override_template(getattr(self, action), template)\n\n        return ModelController(session, left_menu_items)", "response": "Create a new CRUD controller using the admin configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_datastreams(self):\n        datastreams = []\n        response = self.http.get('/Datastream')\n        for datastream in response:\n            datastreams.append(Schemas.Datastream(datastream=datastream))\n        return datastreams", "response": "Get list of Datastreams"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a datastream by id", "response": "def get_datastream(self, datastream):\n        \"\"\"\n        To get Datastream by id\n        \"\"\"\n        response = self.http.get('/Datastream/' + str(datastream))\n        datastream = Schemas.Datastream(datastream=response)\n        return datastream"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_datastream(self, datastream):\n        raw_datastream = self.http.post('/Datastream', datastream)\n        return Schemas.Datastream(datastream=raw_datastream)", "response": "Create a new datastream"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget list of Assessments", "response": "def get_assessments(self):\n        \"\"\"\n        To get list of Assessments\n        \"\"\"\n        assessments = []\n        response = self.http.get('/Assessment')\n        for assessment in response:\n            assessments.append(Schemas.Assessment(assessment=assessment))\n        return assessments"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting Assessment by id", "response": "def get_assessment(self, assessment):\n        \"\"\"\n        To get Assessment by id\n        \"\"\"\n        response = self.http.get('/Assessment/' + str(assessment))\n        assessment = Schemas.Assessment(assessment=response)\n        return assessment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_assessment(self, assessment):\n        raw_assessment = self.http.post('/Assessment', assessment)\n        return Schemas.Assessment(assessment=raw_assessment)", "response": "To create Assessment\n        :param assessment: Assessment"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_assessment(self, assessment):\n        response = self.http.delete('/Assessment/' + str(assessment))\n        return response", "response": "To delete a Assessment\n        :param assessment: string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_input_data(self, datastream, data_type, options, data):\n\n        url = self.get_add_input_data_url(datastream, options)\n\n        form_data = {\n            'files': {\n                'data': (\n                    Utils.random_string(10)+('.json' if data_type == 'json' else '.csv'),\n                    StringIO(data),\n                    'text/plain;charset=UTF-8',\n                    {'Expires': '0'}\n                )\n            }\n        }\n        response = self.http.fpost(url, form_data)\n        return response", "response": "This method adds data to a Datastream and returns the response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd facts data to a Assessment", "response": "def add_facts(self, assessment, data_type, options, data):\n        \"\"\"\n        To add facts data to a Assessment\n        :param assessment: string\n        :param data_type: string\n        :param options: dict\n        :param data: string\n        \"\"\"\n\n        url = self.get_fact_url(assessment,options)\n        try:\n            response = self.http.postData(url, data)\n            return response\n        except Exception as e:\n            print(e.message if hasattr(e,'message') else e)\n            return e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a facts data stream to an Assessment", "response": "def add_facts_stream(self, assessment, data_type, options, data):\n        \"\"\"\n        To add  facts data stream to a Assessment\n        :param datastream: string\n        :param data_type: string\n        :param options: dict\n        :param data: Stream\n        \"\"\"\n\n        url = self.get_fact_url(assessment,options)\n\n        form_data = {\n            'files': {\n                'data': (\n                    Utils.random_string(10)+('.json' if data_type == 'json' else '.csv'),\n                    data,\n                    'text/plain;charset=UTF-8',\n                    {'Expires': '0'}\n                )\n            }\n        }\n        response = self.http.upstream(url,form_data)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the output of a Assessment", "response": "def get_output(self, assessment, options):\n        \"\"\"\n        To get output of a Assessment\n        :param assessment: string\n        :param options: dict\n        \"\"\"\n        responseFormat=None\n        if options and 'format' in options and options['format'] is not None:\n            responseFormat = options['format']\n            options['format'] = None\n\n        url = '/assessment/' + str(assessment) + '/output'\n\n        if 'offset' in options:\n            url += '?offset=' + str(options['offset'])\n\n        response = self.http.downstream(url, responseFormat)\n        stream = sseclient.SSEClient(response)\n        return stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_historical_output(self, assessment, options):\n        responseFormat=None\n        if options and 'format' in options and options['format'] is not None:\n            responseFormat = options['format']\n            options['format'] = None\n\n        url = '/assessment/' + str(assessment) + '/output?' + urllib.parse.urlencode(options)\n        response = self.http.downstream(url, responseFormat)\n        return response", "response": "Get the output of a historical Assessment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_entity_meta(self, datastream, options, data):\n        url = '/datastream/' + str(datastream) + '/entityMeta'\n        response = self.http.post(url, data)\n        entityMetaList = []\n        for entityMeta in response:\n            entityMetaList.append(Schemas.EntityMeta(entityMeta=entityMeta))\n        return entityMetaList", "response": "Add entity meta data to a datastream"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the entity meta data for a datastream", "response": "def get_entity_meta(self, datastream):\n        \"\"\"\n        To add entity meta data to a datastream\n        :param datastream: string\n        :param options: dict\n        \"\"\"\n        url = '/datastream/' + str(datastream) + '/entityMeta'\n        response = self.http.get(url)\n        entityMetaList = []\n        for entityMeta in response:\n            entityMetaList.append(Schemas.EntityMeta(entityMeta=entityMeta))\n        return entityMetaList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef off_datastream(self, datastream):\n        url = '/datastream/' + str(datastream) + '/off'\n        response = self.http.post(url,\"\")\n        return response", "response": "Turn off the datastream"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting facts data for the assessment", "response": "def get_facts(self, assessment, options):\n        \"\"\"\n        Get facts data for the assessment\n        :param assessment: string\n        :param options: dict\n        \"\"\"\n\n        response_format=None\n        if options and 'format' in options and options['format'] is not None:\n            response_format = options['format']\n            options['format'] = None\n\n        url = '/assessment/' + str(assessment) + '/facts?' + urllib.parse.urlencode(options)\n        response = self.http.downstream(url, response_format)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget input data for the datastream", "response": "def get_datastream_data(self, datastream, options):\n        \"\"\"\n        Get input data for the datastream\n        :param datastream: string\n        :param options: dict\n        \"\"\"\n\n        response_format=None\n        if options and 'format' in options and options['format'] is not None:\n            response_format = options['format']\n            options['format'] = None\n\n        url = '/datastream/' + str(datastream) + '/data'\n        response = self.http.downstream(url, response_format)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the status of a task in a specific tracker", "response": "def get_status(self, tracker_id):\n        \"\"\"\n        Get status of a task\n        :param tracker_id: string\n        \"\"\"\n\n        url = '/app/track/' + tracker_id\n        response = self.http.get(url)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representation of the tdelta", "response": "def _fmt_tdelta(self, td):\n        \"\"\"todo: Docstring for _fmt_tdelta\n\n        :param td: arg description\n        :type td: type description\n        :return:\n        :rtype:\n        \"\"\"\n\n        rel = dateutil.relativedelta.relativedelta(datetime.datetime.utcnow(), td)\n\n        if rel.years:\n            return \"{} Years and {} Months Ago\".format(rel.years, rel.months)\n        if rel.months:\n            return \"{} Months Ago\".format(rel.months)\n        if rel.days:\n            return \"{} Days Ago\".format(rel.days)\n        if rel.hours:\n            return \"{} Hours Ago\".format(rel.hours)\n\n        return \"{} Minutes Ago\".format(rel.minutes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, *args, **kwargs):\n        # open image from pdf\n        img = Image(filename=self.file.path + '[0]')\n\n        # make new filename\n        filename = os.path.basename(self.file.path).split('.')[:-1]\n        if type(filename) == list:\n            filename = ''.join(filename)\n\n        # TODO: Would be better to compute this path from the upload_to\n        # setting which is already set on the model field\n        image_dir = os.path.join(\n            django_settings.MEDIA_ROOT, UPLOAD_TO_DIR)\n        if not os.path.exists(image_dir):\n            os.makedirs(image_dir)\n\n        image_path = os.path.join(\n            image_dir, '{}.jpg'.format(filename))\n        tmp_image_path = os.path.join(\n            image_dir, '{}.tmp.jpg'.format(filename))\n\n        # we remove the old image befor we save because the cover might have\n        # changed when we upload a new PDF file - even when that file has the\n        # same filename as the old one\n        try:\n            os.remove(image_path)\n        except OSError:\n            # file is already gone\n            pass\n        # and we also remove the thumbnails\n        old_files = glob.glob('{}.*'.format(image_path))\n        for old_file in old_files:\n            try:\n                os.remove(old_file)\n            except OSError:\n                pass\n\n        # save as image under a temporary filename so that we can read it with\n        # File()\n        img.save(filename=tmp_image_path)\n        # attach it to image field\n        with open(tmp_image_path, 'r') as f:\n            self.image.save('{}.jpg'.format(filename), File(f), save=False)\n        super(PDFPluginModel, self).save(*args, **kwargs)\n\n        # remove temp file\n        try:\n            os.remove(tmp_image_path)\n        except OSError:\n            pass", "response": "Customized to generate an image from the pdf file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the strings matching regex whose length is in Ns.", "response": "def generate(regex, Ns):\n    \"Return the strings matching regex whose length is in Ns.\"\n    return sorted(regex_parse(regex)[0](Ns),\n                  key=lambda s: (len(s), s))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a set of matches to xy whose total length is in Ns.", "response": "def genseq(x, y, Ns):\n    \"\"\"Return the set of matches to xy whose total length is in Ns. We\n    ask y only for lengths that are remainders after an x-match in\n    0..max(Ns). (And we call neither x nor y if there are no Ns.)\"\"\"\n    if not Ns:\n        return null\n    xmatches = x(set(range(max(Ns)+1)))\n    Ns_x = set(len(m) for m in xmatches)\n    Ns_y = set(n-m for n in Ns for m in Ns_x if n-m >= 0)\n    ymatches = y(Ns_y)\n    return set(m1+m2 for m1 in xmatches for m2 in ymatches if len(m1+m2) in Ns)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unused_configs(options, **kwargs):\n\n    include_graph = options['include_graph']\n    call_graph = options['call_graph']\n\n    used_configs = get_used_configs(include_graph, call_graph)\n\n    result = _Result()\n\n    for config, edges in include_graph:\n        if config not in used_configs and is_not_hidden(config): \n            result.add(config)\n\n    return result", "response": "Find all configs that are never used and return it as a list\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the badge blueprint.", "response": "def create_badge_blueprint(allowed_types):\n    \"\"\"Create the badge blueprint.\n\n    :param allowed_types: A list of allowed types.\n    :returns: A Flask blueprint.\n    \"\"\"\n    from invenio_formatter.context_processors.badges import \\\n        generate_badge_png, generate_badge_svg\n\n    blueprint = Blueprint(\n        'invenio_formatter_badges',\n        __name__,\n        template_folder='templates',\n    )\n\n    @blueprint.route(\n        '/badge/<any({0}):title>/<path:value>.<any(svg, png):ext>'.format(\n            ', '.join(allowed_types)))\n    def badge(title, value, ext='svg'):\n        \"\"\"Generate a badge response.\"\"\"\n        if ext == 'svg':\n            generator = generate_badge_svg\n            mimetype = 'image/svg+xml'\n        elif ext == 'png':\n            generator = generate_badge_png\n            mimetype = 'image/png'\n\n        badge_title_mapping = \\\n            current_app.config['FORMATTER_BADGES_TITLE_MAPPING'].get(\n                title, title)\n        response = Response(generator(badge_title_mapping, value),\n                            mimetype=mimetype)\n        # Generate Etag from badge title and value.\n        hashable_badge = \"{0}.{1}\".format(badge_title_mapping,\n                                          value).encode('utf-8')\n        response.set_etag(hashlib.sha1(hashable_badge).hexdigest())\n        # Add headers to prevent caching.\n        response.headers[\"Pragma\"] = \"no-cache\"\n        response.cache_control.no_cache = True\n        response.cache_control.max_age = \\\n            current_app.config['FORMATTER_BADGES_MAX_CACHE_AGE']\n        response.last_modified = dt.utcnow()\n        extra = timedelta(\n            seconds=current_app.config['FORMATTER_BADGES_MAX_CACHE_AGE'])\n        response.expires = response.last_modified + extra\n        return response.make_conditional(request)\n\n    return blueprint"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_simple_edge(self, name, edge, edge_settings, label=\"call\"):\n        self.gv_graph.edge(self.get_path_from_name(name), self.get_path_from_name(edge.to), label=label, **edge_settings)", "response": "Render a simple edge"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders edge with label as text", "response": "def render_edge_with_label(self, name, edge, edge_settings):\n        \"\"\"\n        Render edge with label as text\n        \"\"\"\n        props_to_display = self.extract_props(edge.settings)\n\n        label = '<'\n\n        for prop, value in props_to_display.items():\n            label += self.get_label(prop, value)\n            label += \"<BR/>\"\n\n        label += '>'\n\n        self.gv_graph.edge(self.get_path_from_name(name), self.get_path_from_name(edge.to), label=label, **edge_settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering edge with label as separate node", "response": "def render_edge_with_node_label(self, name, edge, edge_settings):\n        \"\"\"\n        Render edge with label as separate node\n        \"\"\"\n        props_to_display = self.extract_props(edge.settings)\n\n        label = '<'\n        label += \"|\".join(self.get_label(prop, value) for prop, value in props_to_display.items()) \n        label += '>'\n\n        edge_node_name = \"{}-{}\".format(name, edge.to)\n\n        self.gv_graph.node(edge_node_name, label=label, shape=\"record\")\n\n        self.gv_graph.edge(self.get_path_from_name(name), edge_node_name, arrowhead=\"none\", **edge_settings)\n        self.gv_graph.edge(edge_node_name, self.get_path_from_name(edge.to), **edge_settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting label If value is missing, label will be colored red", "response": "def get_label(self, prop, value):\n        \"\"\"\n        Format label\n        If value is missing, label will be colored red\n        \"\"\"\n        if value is None:\n            return '{}: <FONT color=\"red\">{}</FONT>'.format(prop, \"not set\")\n        else:\n            return \"{}:{}\".format(prop, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_props(self, settings):\n        '''\n        Extract all valuable properties to be displayed\n        '''\n\n        props = {}\n\n        for param in self.call_parameters:\n            if param in settings:\n                props[param] = settings[param]\n            else:\n                props[param] = None\n\n        return props", "response": "Extract all valuable properties to be displayed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the endpoint of SDC from Keystone Service Catalog", "response": "def get_sdc_endpoint_from_keystone(self, region_name, service_type, endpoint_type):\n        \"\"\"\n        Get the endpoint of SDC from Keystone Service Catalog\n        :param region_name: Name of the region\n        :param service_type: Type of service (Endpoint name)\n        :param endpoint_type: Type of the URL to look for\n        :return:\n        \"\"\"\n\n        logger.debug(\"Getting SDC endpoint\")\n        endpoint = None\n        for service in self.keystone_client.auth_ref['serviceCatalog']:\n            if service['name'] == service_type:\n                for endpoint in service['endpoints']:\n                    if endpoint['region'] == region_name:\n                        endpoint = endpoint[endpoint_type]\n                        break\n                break\n        logger.debug(\"SDC endpoint (Service: %s, Type: %s, Region: %s) is: %s\", service_type, endpoint_type,\n                     region_name, endpoint_type)\n        return endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninitializing the internal keystone headers.", "response": "def init_headers(self, x_auth_token, tenant_id, content_type=HEADER_REPRESENTATION_XML,\n                     transaction_id=generate_transaction_id()):\n        \"\"\"\n        Init header to values (or default values)\n        :param x_auth_token: Token from Keystone for tenant_id (OpenStack)\n        :param tenant_id: TenantId (OpenStack)\n        :param content_type: Content-Type header value. By default application/xml\n        :param transaction_id: txId header value. By default, generated value by generate_transaction_id()\n        :return: None\n        \"\"\"\n\n        logger.debug(\"Init headers\")\n        if content_type is None:\n            if HEADER_CONTENT_TYPE in self.headers:\n                del(self.headers[HEADER_CONTENT_TYPE])\n        else:\n            self.headers.update({HEADER_CONTENT_TYPE: content_type})\n\n        if transaction_id is None:\n            if HEADER_TRANSACTION_ID in self.headers:\n                del(self.headers[HEADER_TRANSACTION_ID])\n        else:\n            self.headers.update({HEADER_TRANSACTION_ID: transaction_id})\n\n        self.headers.update({X_AUTH_TOKEN: x_auth_token})\n\n        self.headers.update({TENANT_ID: tenant_id})\n\n        logger.debug(\"Headers: \" + str(self.headers))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the headers for the current request.", "response": "def set_headers(self, headers):\n        \"\"\"\n        Set header.\n        :param headers: Headers to be used by next request (dict)\n        :return: None\n        \"\"\"\n\n        logger.debug(\"Setting headers: \" + str(headers))\n        self.headers = headers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getProductAndReleaseResourceClient(self):\n        split_regex = \"(.*)://(.*):(\\d*)/(.*)\"\n        regex_matches = re.search(split_regex, self.endpoint_url)\n\n        logger.info(\"Creating ProductAndReleaseResourceClient\")\n\n        return ProductAndReleaseResourceClient(protocol=regex_matches.group(1), host=regex_matches.group(2),\n                                        port=regex_matches.group(3), tenant_id=self.tenant_id,\n                                        resource=regex_matches.group(4), headers=self.headers)", "response": "Create an API resource REST client for Environment API resource"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_cookie(self, name, domain):\n        ''' Return the cookie \"name\" for \"domain\" if found\n            If there are mote than one, only the first is returned\n        '''\n        for c in self.session.cookies:\n            if c.name==name and c.domain==domain:\n                return c\n        return None", "response": "Return the cookie name for domain if found return None if not found"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the hash of a list of hashes from sorted repr of every cookie in jar as LWPCookieJar does not change it s hash when cookies change.", "response": "def _hash_cookies(self):\n        ''' Returns the hash of a list of hashes from sorted repr() of every cookie in jar as\n            LWPCookieJar does not change it's hash when cookies change.\n        '''\n        return hash(frozenset([hash(c) for c in sorted([repr(c) for c in self.session.cookies])]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_rsa_key(self):\n        ''' get steam RSA key, build and return cipher '''\n        url = 'https://steamcommunity.com/mobilelogin/getrsakey/'\n        values = {\n                'username': self._username,\n                'donotcache' : self._get_donotcachetime(),\n        }\n        req = self.post(url, data=values)\n        data = req.json()\n        if not data['success']:\n            raise SteamWebError('Failed to get RSA key', data)\n        # Construct RSA and cipher\n        mod = int(str(data['publickey_mod']), 16)\n        exp = int(str(data['publickey_exp']), 16)\n        rsa = RSA.construct((mod, exp))\n        self.rsa_cipher = PKCS1_v1_5.new(rsa)\n        self.rsa_timestamp = data['timestamp']", "response": "get steam RSA key build and return cipher"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_captcha(captcha_data, message=''): # pylint:disable=unused-argument\n        ''' Called when a captcha must be solved\n        Writes the image to a temporary file and asks the user to enter the code.\n\n        Args:\n            captcha_data: Bytestring of the PNG captcha image.\n            message: Optional. A message from Steam service.\n\n        Returns:\n            A string containing the solved captcha code.\n        '''\n        from tempfile import NamedTemporaryFile\n        tmpf = NamedTemporaryFile(suffix='.png')\n        tmpf.write(captcha_data)\n        tmpf.flush()\n        captcha_text = input('Please take a look at the captcha image \"%s\" and provide the code:' % tmpf.name)\n        tmpf.close()\n        return captcha_text", "response": "Called when a captcha must be solved by the user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_emailauth(maildomain='', message=''): # pylint:disable=unused-argument\n        ''' Called when SteamGuard requires authentication via e-mail.\n        Asks the user to enter the code.\n\n        Args:\n            maildomain: Optional. The mail domain of the e-mail address the SteamGuard\n                code is send to.\n            message: Optional. A message from Steam service.\n\n        Returns:\n            A string containing the code.\n        '''\n        print('SteamGuard requires email authentication...')\n        emailauth = input('Please enter the code sent to your mail address at \"%s\": ' % maildomain)\n        emailauth.upper()\n        return emailauth", "response": "Called when SteamGuard requires authentication via e - mail."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when login is complete to store the oauth_access_token in a seperate cookie for domain steamwebbrowser. tld", "response": "def _store_oauth_access_token(self, oauth_access_token):\n        ''' Called when login is complete to store the oauth access token\n            This implementation stores the oauth_access_token in a seperate cookie for domain steamwebbrowser.tld\n        '''\n        c = Cookie(version=0, name='oauth_access_token', value=oauth_access_token,\n            port=None, port_specified=False,\n            domain='steamwebbrowser.tld', domain_specified=True, domain_initial_dot=False,\n            path='/', path_specified=True,\n            secure=False, expires=None, discard=False, comment=None, comment_url=None, rest={},\n        )\n        self.session.cookies.set_cookie(c)\n        self._save_cookies()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef draw(self, points, can=None):\n        if can == None: can = canvas.default_canvas()\n        assert self.check_integrity()\n        xtip = points[-1][0]\n        ytip = points[-1][1]\n\n        xtail = points[-2][0]\n        ytail = points[-2][1]\n\n        can.newpath()\n        can.set_line_style(self.line_style)\n        if len(points) > 2:\n            can.moveto(points[0][0], points[0][1])\n            for i in range(1, len(points) - 1):\n                can.lineto(points[i][0], points[i][1])\n\n        draw_arrowbody(can, xscale(xtail), yscale(ytail),\n                       yscale(xtip), yscale(ytip),\n                       nscale(self.head_len))\n\n        can.set_fill_color(self.head_color)\n        draw_arrowhead(can, xscale(xtail), yscale(ytail),\n                       xscale(xtip), yscale(ytip),\n                       nscale(self.thickness),\n                       nscale(self.head_len),\n                       self.head_style)\n\n        can.setbb(xtail, ytail)\n        can.setbb(xtip, ytip)", "response": "This method draws the arrow body and arrowhead of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_block(block):\n    '''\n    Format the given block of text, trimming leading/trailing\n    empty lines and any leading whitespace that is common to all lines.\n    The purpose is to let us list a code block as a multiline,\n    triple-quoted Python string, taking care of indentation concerns.\n    '''\n    # separate block into lines\n    lines = str(block).split('\\n')\n    # remove leading/trailing empty lines\n    while lines and not lines[0]:\n        del lines[0]\n    while lines and not lines[-1]:\n        del lines[-1]\n    # look at first line to see how much indentation to trim\n    ws = re.match(r'\\s*', lines[0]).group(0)\n    if ws:\n        lines = map(lambda x: x.replace(ws, '', 1), lines)\n    # remove leading/trailing blank lines (after leading ws removal)\n    # we do this again in case there were pure-whitespace lines\n    while lines and not lines[0]:\n        del lines[0]\n    while lines and not lines[-1]:\n        del lines[-1]\n    return '\\n'.join(lines) + '\\n'", "response": "Format the given block of text trimming leading trailing empty lines and any leading whitespace that is common to all lines."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _capture(self, args, kwargs):\n        '''Store the input to the captured function'''\n        self.called = self.called + 1\n        self.method_args.append(args)\n        self.named_method_args.append(kwargs)\n        self.never_called = False", "response": "Store the input to the captured function"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize the logging module. Construct the LogTee as the default keeper. Initialize the flulog and append it to the tee.", "response": "def init(path=None):\n    '''Initialize the logging module. Construct the LogTee as the default\n    keeper. Initialize the flulog and append it to the tee.'''\n    default = get_default()\n    if default is not None and not isinstance(default, VoidLogKeeper):\n        return default\n    tee = LogTee()\n    set_default(tee)\n    FluLogKeeper.init(path)\n    tee.add_keeper('flulog', FluLogKeeper())\n    return tee"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_hash(self, msg):\n        '''\n        :rettype: string\n        '''\n        msg = msg.encode('utf-8', 'replace')\n        return hashlib.sha1(msg).hexdigest()", "response": "Returns the hash of the message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef content_size_exceeded_max(self, content_bytes):\n        '''\n        `sys.getsizeof` works great for this use case because we have a byte\n        sequence, and not a recursive nested structure. The unit of Memcache\n        `item_size_max` is also bytes.\n\n        :rettype: tuple(bool, int)\n        '''\n        content_size = sys.getsizeof(content_bytes)\n        if content_size > self.item_size_max():\n            return (True, content_size)\n\n        return (False, content_size)", "response": "Returns True if the content_bytes is too big or False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave the bytes under a key derived from path in Memcache.", "response": "def put(self, content_bytes):\n        '''\n        Save the `bytes` under a key derived from `path` in Memcache.\n\n        :return: A string representing the content path if it is stored.\n        :rettype: string or None\n        '''\n        derived_path = self.context.request.url\n        over_max, content_size = self.content_size_exceeded_max(content_bytes)\n\n        logger.debug('[{log_prefix}] content size in bytes: {size}'\n            ' | is over max? {over_max} | skip storage? {skip}'.format(\n            log_prefix=LOG_PREFIX, size=content_size, over_max=over_max,\n            skip=self.skip_storage()))\n\n        if (over_max and self.skip_storage()):\n            # Short-circuit the storage when configured to skip large items\n            logger.debug('[{log_prefix}] skipping storage: {content_size} '\n                           'exceeds item_size_max of {max_size}'.format(\n                           log_prefix=LOG_PREFIX, content_size=content_size,\n                           max_size=self.item_size_max()))\n            return None\n\n        self.storage.set(\n            self.timestamp_key_for(derived_path), datetime.utcnow(),\n            time=self.context.config.RESULT_STORAGE_EXPIRATION_SECONDS\n        )\n        self.storage.set(\n            self.result_key_for(derived_path), content_bytes,\n            time=self.context.config.RESULT_STORAGE_EXPIRATION_SECONDS\n        )\n\n        return derived_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, callback):\n        '''\n        Gets an item based on the path.\n        '''\n        derived_path = self.context.request.url\n        logger.debug('[{log_prefix}]: get.derived_path: {path}'.format(\n            log_prefix=LOG_PREFIX, path=derived_path))\n        callback(self.storage.get(self.result_key_for(derived_path)))", "response": "Gets an item based on the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(EncapsulatedControlMessage, self).sanitize()\n\n        # S: This is the Security bit.  When set to 1 the following\n        # authentication information will be appended to the end of the Map-\n        # Reply.  The detailed format of the Authentication Data Content is\n        # for further study.\n        if not isinstance(self.security, bool):\n            raise ValueError('Security flag must be a boolean')\n\n        if self.security:\n            raise NotImplementedError('Handling security data is not ' +\n                                      'implemented yet')\n\n        # \"D\" is the \"DDT-originated\" flag and is set by a DDT client to\n        # indicate that the receiver can and should return Map-Referral\n        # messages as appropriate.\n        if not isinstance(self.ddt_originated, bool):\n            raise ValueError('DDT originated flag must be a boolean')\n\n        # The 6th bit in the ECM LISP header is allocated as the \"R\"\n        # bit.  The R bit indicates that the encapsulated Map-Register is\n        # to be processed by an RTR.\n        if not isinstance(self.for_rtr, bool):\n            raise ValueError('For-RTR flag must be a boolean')\n\n        # The 7th bit in the ECM header is allocated as the \"N\" bit.  The\n        # N bit indicates that this Map-Register is being relayed by an\n        # RTR.  When an RTR relays the ECM-ed Map-Register to a Map-Server,\n        # the N bit must be set to 1.\n        if not isinstance(self.relayed_by_rtr, bool):\n            raise ValueError('Relayed-by-RTR flag must be a boolean')", "response": "Sanitize the current settings and return a new set of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_bytes(cls, bitstream):\n        r'''\n        Parse the given packet and update properties accordingly\n\n        >>> data_hex = ('80000000'\n        ...             '6e000000004811402a0086400001ffff'\n        ...             '000000000000000a2a02000000000000'\n        ...             '0000000000000000'\n        ...             '10f610f600487396'\n        ...             '10000201ee924adef97a97d700000001'\n        ...             '57c3c44d00015f61535d0002200109e0'\n        ...             '85000b000000000000000001000f0002'\n        ...             '2a020000000000000000000000000000')\n        >>> data = data_hex.decode('hex')\n        >>> message = EncapsulatedControlMessage.from_bytes(data)\n        >>> message.security\n        False\n        >>> message.ddt_originated\n        False\n        >>> bytes(message.payload)\n        ... # doctest: +ELLIPSIS\n        'n\\x00\\x00\\x00\\x00H\\x11...\\x00\\x00'\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the type\n        type_nr = bitstream.read('uint:4')\n        if type_nr != packet.message_type:\n            msg = 'Invalid bitstream for a {0} packet'\n            class_name = packet.__class__.__name__\n            raise ValueError(msg.format(class_name))\n\n        # Read the flags\n        (packet.security,\n         packet.ddt_originated) = bitstream.readlist('2*bool')\n\n        # Read reserved bits\n        packet._reserved1 = bitstream.read(26)\n\n        # If the security flag is set then there should be security data here\n        # TODO: deal with security flag [LISP-Security]\n        if packet.security:\n            raise NotImplementedError('Handling security data is not ' +\n                                      'implemented yet')\n\n        # The rest of the packet is payload\n        remaining = bitstream[bitstream.pos:]\n\n        # Parse IP packet\n        if len(remaining):\n            ip_version = remaining.peek('uint:4')\n            if ip_version == 4:\n                packet.payload = IPv4Packet.from_bytes(remaining)\n            elif ip_version == 6:\n                packet.payload = IPv6Packet.from_bytes(remaining)\n            else:\n                packet.payload = remaining.bytes\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "r Parse a ISO - 8601 ISO - 8601 message from a byte stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_bytes(self):\n        r'''\n        Create bytes from properties\n\n        >>> message = EncapsulatedControlMessage(payload='Dummy')\n        >>> message.to_bytes()\n        '\\x80\\x00\\x00\\x00Dummy'\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the type\n        bitstream = BitArray('uint:4=%d' % self.message_type)\n\n        # Add the flags\n        bitstream += BitArray('bool=%d, bool=%d' % (self.security,\n                                                    self.ddt_originated))\n\n        # Add padding\n        bitstream += self._reserved1\n\n        # Determine payload\n        payload = self.payload\n        if hasattr(payload, 'to_bytes'):\n            payload = payload.to_bytes()\n\n        return bitstream.bytes + payload", "response": "Return the bytes representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef valuegetter(*fieldspecs, **kwargs):\n    combine_subfields = kwargs.get('combine_subfields', False)\n    pattern = r'(?P<field>[^.]+)(.(?P<subfield>[^.]+))?'\n\n    def values(record):\n        for s in fieldspecs:\n            match = re.match(pattern, s)\n            if not match:\n                continue\n            gd = match.groupdict()\n            for field in record.get_fields(gd['field']):\n                if gd['subfield']:\n                    for value in field.get_subfields(gd['subfield']):\n                        yield value\n                else:\n                    if combine_subfields:\n                        yield field.value()\n                    else:\n                        if int(gd['field']) < 10:\n                            yield field.value()\n                        else:\n                            for value in field.subfields[1::2]:\n                                yield value\n    values.__doc__ = 'returns a value generator over %s' % (\n        ', '.join(fieldspecs))\n    return values", "response": "This function is used to get the value of a variable number of specs and returns a function which applies to any record and returns the matching values."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a generator that returns all the fields that match the given fieldspecs.", "response": "def fieldgetter(*fieldspecs):\n    \"\"\"\n    Similar to `valuegetter`, except this returns (`pymarc.Field`, value)\n    tuples. Takes any number of fieldspecs.\n    \"\"\"\n    pattern = r'(?P<field>[^.]+)(.(?P<subfield>[^.]+))?'\n\n    def fields(record):\n        for s in fieldspecs:\n            match = re.match(pattern, s)\n            if not match:\n                continue\n            grp = match.groupdict()\n            for field in record.get_fields(grp['field']):\n                if grp['subfield']:\n                    for value in field.get_subfields(grp['subfield']):\n                        yield field, value\n                else:\n                    if int(grp['field']) < 10:\n                        yield field, field.value()\n                    else:\n                        for value in field.subfields[1::2]:\n                            yield field, value\n    fields.__doc__ = 'returns a field generator over %s' % (\n        ', '.join(fieldspecs))\n    return fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten(struct):\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for key, result in struct.items():\n            flat += flatten(result)\n        return flat\n\n    if isinstance(struct, basestring):\n        return [struct]\n\n    try:\n        # if iterable\n        for result in struct:\n            flat += flatten(result)\n        return flat\n    except TypeError:\n        pass\n\n    return [struct]", "response": "Clears a flat list of all items in structured output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a field to a record.", "response": "def add(self, tag, data=None, indicators=None, **kwargs):\n        \"\"\"\n        Add a field to a record. Example:\n\n        marc.add('020', a='0201657880', z='0201802398')\n        \"\"\"\n        if tag.startswith(\"00\") and (data is None or data == \"\") and not self.strict:\n            return\n\n        if data:\n            if indicators:\n                raise ValueError(Record.E_NO_INDICATORS)\n            if not tag.startswith('00'):\n                raise ValueError(Record.E_NO_DATA)\n        else:\n            if tag.startswith('00'):\n                raise ValueError(Record.E_EMPTY)\n\n        if tag.startswith('00') and kwargs:\n            raise ValueError(Record.E_NO_SUBFIELDS)\n\n        if indicators is None:\n            indicators = [' ', ' ']\n        if isinstance(indicators, basestring):\n            if len(indicators) == 2:\n                indicators = [indicators[0], indicators[1]]\n            else:\n                raise ValueError(Record.E_INVALID_INDICATOR)\n\n        if data:  # == control field (001 -- 009)\n            field = pymarc.Field(tag, data=data)\n        else:     # == non-control field (010 -- 999)\n            if 'subfields' in kwargs:\n                sfs = kwargs['subfields']\n                subfields = [v for sl in [(a, b) for a, b in zip(sfs[::2], sfs[1::2]) if b] for v in sl]\n            else:\n                subfields = []\n                for key, value in kwargs.items():\n                    if value is None:\n                        continue\n                    key = key.replace('_', '')\n                    if isinstance(value, basestring):\n                        if value == \"\":\n                            continue\n                        subfields += [key, value]\n                    elif isinstance(value, collections.Iterable):\n                        for val in value:\n                            if not isinstance(val, basestring):\n                                raise ValueError('subfield values must be strings')\n                            if val:\n                                subfields += [key, val]\n                    else:\n                        raise ValueError('subfield values must be strings')\n\n            if not any(subfields[1::2]):\n                if self.strict:\n                    raise ValueError('none of the subfields contains a value')\n                else:\n                    return\n\n            field = pymarc.Field(tag, indicators, subfields=subfields)\n        self.add_field(field)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving fields or subfields according to fieldspec.", "response": "def remove(self, fieldspec):\n        \"\"\"\n        Removes fields or subfields according to `fieldspec`.\n\n        If a non-control field subfield removal leaves no other subfields,\n        delete the field entirely.\n        \"\"\"\n\n        pattern = r'(?P<field>[^.]+)(.(?P<subfield>[^.]+))?'\n        match = re.match(pattern, fieldspec)\n        if not match:\n            return None\n\n        grp = match.groupdict()\n        for field in self.get_fields(grp['field']):\n            if grp['subfield']:\n                updated = []\n                for code, value in pairwise(field.subfields):\n                    if not code == grp['subfield']:\n                        updated += [code, value]\n                # if we removed the last subfield entry,\n                # remove the whole field, too\n                if not updated:\n                    self.remove_field(field)\n                else:\n                    field.subfields = updated\n            else:\n                # it is a control field\n                self.remove_field(field)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the first value of the given fieldspecs or the default value if none exists.", "response": "def firstvalue(self, *fieldspecs, **kwargs):\n        \"\"\"\n        Return the [first] [v]alue or the value given by the keyword\n        argument `default` if not value exists. `default` defaults to `None`.\n        \"\"\"\n        default = kwargs.get('default', None)\n        values = [val for val in self.itervalues(*fieldspecs, **kwargs)]\n        if values:\n            return values[0]\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_field_if(self, *args):\n        fieldspecs = set()\n        function = lambda val: False\n        for arg in args:\n            if callable(arg):\n                function = arg\n            elif isinstance(arg, basestring):\n                fieldspecs.add(arg)\n            else:\n                raise ValueError('argument must be callable (test function) '\n                                 'or basestring (fieldspec, like 020 '\n                                 'or 856.u, etc.)')\n        removed = []\n        for field, value in fieldgetter(*fieldspecs)(self):\n            if function(value):\n                removed.append(field)\n                self.remove_field(field)\n        return removed", "response": "Remove a field from this record if fun evaluates to True."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flatten(self):\n        d = self.as_dict()\n        del d['leader']\n        return [s for s in [v.strip() for v in flatten(d)] if s]", "response": "Flatten this record to a simple list of values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tag_to_expression(self, tag, prefix=None, index=None):\n        if prefix is None:\n            prefix = self.default_prefix\n        if index is None:\n            index = self.default_index\n        tag = tag.replace('.', '').strip()\n        if 3 > len(tag) > 4:\n            raise ValueError('tag must be of the form 008, 020a or 020.a')\n        if len(tag) == 4:\n            tag, code = tag[:3], tag[3:]\n            return jpath.parse('{prefix}.content[\"{tag}\"]'\n                               '[{index}].[\"{code}\"]'.format(prefix=prefix,\n                                                             tag=tag, index=index, code=code))\n        else:\n            return jpath.parse('{prefix}.content[\"{tag}\"]'.format(prefix=prefix,\n                                                                  tag=tag))", "response": "Return a multivalued parser for the given tag."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_settings(cfg_path=None):\n\n    global settings\n\n    cfg_path = cfg_path or _config['cfg_path']\n\n    cfg_d = _config.copy()\n\n    if os.path.exists(cfg_path):\n        sfl = SourceFileLoader('upkg_cfg', cfg_path)\n        cfg_mod = sfl.load_module()\n\n        for m in inspect.getmembers(cfg_mod):\n            if m[0][0] != '_':\n                cfg_d[m[0]] = m[1]\n        # end for m in inspect.getme\n\n    # Make the paths absolute.\n    cfg_d[\"cfg_path\"] = _clean_path(cfg_d[\"cfg_path\"])\n    cfg_d[\"upkg_destdir\"] = _clean_path(cfg_d[\"upkg_destdir\"])\n\n    settings = Namespace(**cfg_d)", "response": "load_settings - Loads the settings from the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating an object using the CDSTAR API.", "response": "def create_object(self, api, metadata=None):\n        \"\"\"\n        Create an object using the CDSTAR API, with the file content as bitstream.\n\n        :param api:\n        :return:\n        \"\"\"\n        metadata = {k: v for k, v in (metadata or {}).items()}\n        metadata.setdefault('creator', '{0.__name__} {0.__version__}'.format(pycdstar))\n        metadata.setdefault('path', '%s' % self.path)\n        metadata.update(self.add_metadata())\n        bitstream_specs = [self] + self.add_bitstreams()\n        obj = api.get_object()\n        res = {}\n        try:\n            obj.metadata = metadata\n            for file_ in bitstream_specs:\n                res[file_.bitstream_type] = file_.add_as_bitstream(obj)\n        except:  # noqa: E722\n            obj.delete()\n            raise\n        return obj, metadata, res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the NTH barplot of the cluster in area AR.", "response": "def find_bar_plot(ar, nth):\n    \"Find the NTH barplot of the cluster in area AR.\"\n    for plot in ar.plots():\n        if isinstance(plot, T) and plot.cluster[0] == nth:\n            return plot\n    raise Exception(\"The %dth bar plot in the cluster not found.\" % nth)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply(self, cls, originalMemberNameList, memberName, classNamingConvention, getter, setter):\n        accessorDict = self._accessorDict(memberName, classNamingConvention, getter, setter)\n        for accessorName, accessor in accessorDict.items():\n            if accessorName not in originalMemberNameList and accessor is not None:\n                setattr(cls, accessorName, accessor)", "response": "Applies the getter and setter to the class with the given memberName."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the specified memberName from the class.", "response": "def remove(self, cls, originalMemberNameList, memberName, classNamingConvention):\n        \"\"\"\n    :type cls: type\n    :type originalMemberNameList: list(str)\n    :type memberName: str\n    :type classNamingConvention: INamingConvention|None\n\"\"\"\n        accessorDict = self._accessorDict(memberName, classNamingConvention)\n        for accessorName, _ in accessorDict.items():\n            if accessorName not in originalMemberNameList and hasattr(cls, accessorName):\n                delattr(cls, accessorName)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _accessorName(self, memberName, accessorName, classNamingConvention):\n        # Using user's custom getter or setter name.\n        customAccessorName = self._accessorNameDict[accessorName]\n        if customAccessorName is not None:\n            return customAccessorName\n        \n        # If the class has a custom naming convention, we use it. Cf. 'namingConvention' decorator.\n        # Otherwise, we use the member's naming convention, camelCase or underscore depending on the decorator that was used\n        # (respectively synthesizeMember or synthesize_member).\n        namingConvention = self._namingConvention\n        if classNamingConvention is not None:\n            namingConvention = classNamingConvention\n\n        # @hack: I don't much like that...\n        methodName = self._NAMING_CONVENTION_ACCESSOR_NAME_METHOD_DICT[accessorName]\n        # Using naming convention to transform member's name to an accessor name.\n        return getattr(namingConvention, methodName)(memberName)", "response": "Returns the name of the given member name for the given accessor name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the queryset of permissions for the given user.", "response": "def get_user_permissions(user):\n    '''Returns the queryset of permissions for the given user.'''\n    permissions = SeedPermission.objects.all()\n    # User must be on a team that grants the permission\n    permissions = permissions.filter(seedteam__users=user)\n    # The team must be active\n    permissions = permissions.filter(seedteam__archived=False)\n    # The organization of that team must be active\n    permissions = permissions.filter(\n        seedteam__organization__archived=False)\n    return permissions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a queryset of permissions filters depending on the permission type and optionally an object id and namespace.", "response": "def find_permission(\n        permissions, permission_type, object_id=None, namespace=None):\n    '''Given a queryset of permissions, filters depending on the permission\n    type, and optionally an object id and namespace.'''\n    if object_id is not None:\n        return permissions.filter(\n            type=permission_type, object_id=object_id, namespace=namespace)\n    return permissions.filter(type=permission_type)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _skip_char_around(self, string, char='\\n'):\n        starts, ends = '', ''\n        n = len(char)\n        if string.startswith(char):\n            starts = string[:n]\n            string = string[n:]\n        if string.endswith(char):\n            ends = string[-n:]\n            string = string[:-n]\n        string = self._base_compile(string)\n        if starts:\n            string = starts + string\n        if ends:\n            string = string + ends\n        return string", "response": "Custom pseudo method for skipping a given char around a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _val_is_unique(val, field):\n        if val is None:\n            return False\n\n        if not field.unique:\n            return True\n\n        field_name = field.name\n        return field.model.objects.filter(**{field_name: val}).count() == 0", "response": "Checks if the value is unique for the given field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generate_ipaddressfield(self, **kwargs):\n        field = kwargs['field']\n        if field.default != NOT_PROVIDED:\n            return self._generate_field_with_default(**kwargs)\n        num_octets = 4\n        octets = [str(random.randint(0, 255)) for n in range(num_octets)]\n        return '.'.join(octets)", "response": "Generate a random IPv4 field."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode(arg, delimiter=None, encodeseq=None, encoded=tuple()):\n    '''Encode a single argument for the file-system'''\n    arg = coerce_unicode(arg, _c.FSQ_CHARSET)\n    new_arg = sep = u''\n    delimiter, encodeseq = delimiter_encodeseq(\n        _c.FSQ_DELIMITER if delimiter is None else delimiter,\n        _c.FSQ_ENCODE if encodeseq is None else encodeseq,\n        _c.FSQ_CHARSET)\n\n    # validate encoded tuple\n    for enc in encoded:\n        enc = coerce_unicode(enc, _c.FSQ_CHARSET)\n        try:\n            enc = enc.encode('ascii')\n        except UnicodeEncodeError:\n            raise FSQEncodeError(errno.EINVAL, u'invalid encoded value: {0}'\\\n                                 u' non-ascii'.format(enc))\n    # char-wise encode walk\n    for seq in arg:\n        if seq == delimiter or seq == encodeseq or seq in _ENCODED + encoded:\n            h_val = hex(ord(seq))\n            # front-pad with zeroes\n            if 3 == len(h_val):\n                h_val = sep.join([h_val[:2], u'0', h_val[2:]])\n            if 4 != len(h_val):\n                raise FSQEncodeError(errno.EINVAL, u'invalid hex ({0}) for'\\\n                                     ' encode-target: {1}'.format(h_val, seq))\n            seq = sep.join([encodeseq, h_val[2:]])\n\n        new_arg = sep.join([new_arg, seq])\n\n    return new_arg", "response": "Encode a single argument for the file - system."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecodes a single argument from the file - system.", "response": "def decode(arg, delimiter=None, encodeseq=None):\n    '''Decode a single argument from the file-system'''\n    arg = coerce_unicode(arg, _c.FSQ_CHARSET)\n    new_arg = sep = u''\n    delimiter, encodeseq = delimiter_encodeseq(\n        _c.FSQ_DELIMITER if delimiter is None else delimiter,\n        _c.FSQ_ENCODE if encodeseq is None else encodeseq,\n        _c.FSQ_CHARSET)\n\n    # char-wise decode walk -- minimally stateful\n    encoding_trg = sep\n    for c in arg:\n        if len(encoding_trg):\n            encoding_trg = sep.join([encoding_trg, c])\n            if 4 !=  len(encoding_trg):\n                continue\n            try:\n                c = chr(int(encoding_trg, 16))\n            except ValueError:\n                raise FSQEncodeError(errno.EINVAL, u'invalid decode'\\\n                                     u' target: {0}'.format(encoding_trg))\n            c = coerce_unicode(c, _c.FSQ_CHARSET)\n            encoding_trg = sep\n        elif c == encodeseq:\n            encoding_trg = u'0x'\n            continue\n\n        new_arg = sep.join([new_arg, c])\n\n    # edge case, incomplete encoding at end of string\n    if len(encoding_trg):\n        raise FSQEncodeError(errno.EINVAL, u'truncated encoding at end of'\n                             u' argument: {0}'.format(encoding_trg))\n\n    return new_arg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_errors(function):\n\n    def wrapper(*args, **kwargs):\n        try:\n            return function(*args, **kwargs)\n        except BaseException as e:\n            handle_exception(None, e, \"Exception in function %s\",\n                             reflect.canonical_name(function))\n            raise\n\n    return wrapper", "response": "Decorator to log exceptions raised by the decorated function\nislation without interfering. For debugging purpose."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the exceptions raised by the decorated function without interfering. For debugging purpose.", "response": "def print_errors(function):\n    \"\"\"Prints the exceptions raised by the decorated function\n    without interfering. For debugging purpose.\"\"\"\n\n    def wrapper(*args, **kwargs):\n        try:\n            return function(*args, **kwargs)\n        except BaseException as e:\n            print (\"Exception raise calling %s: %s\"\n                   % (reflect.canonical_name(function),\n                      get_exception_message(e)))\n            raise\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfixing up the traceback to remove the from the file paths the part preceeding the project root.", "response": "def clean_traceback(tb):\n    '''Fixes up the traceback to remove the from the file paths the part\n    preceeding the project root.\n    @param tb: C{str}\n    @rtype: C{str}'''\n    prefix = __file__[:__file__.find(\"feat/common/error.py\")]\n    regex = re.compile(\"(\\s*File\\s*\\\")(%s)([a-zA-Z-_\\. \\\\/]*)(\\\".*)\"\n                       % prefix.replace(\"\\\\\", \"\\\\\\\\\"))\n\n    def cleanup(line):\n        m = regex.match(line)\n        if m:\n            return m.group(1) + \".../\" + m.group(3) + m.group(4)\n        else:\n            return line\n\n    return '\\n'.join(map(cleanup, tb.split('\\n')))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_node_destroyable(name, prefixes=DESTROYABLE_PREFIXES):\n\n    \"\"\"Return True if name starts with a destroyable prefix\"\"\"\n\n    return any([name.startswith(p) for p in prefixes])", "response": "Return True if the given node name starts with a destroyable prefix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting the callback optionally passing it parsed and return the corresponding Taxonomy error code.", "response": "def handle_errors(callback, parsed=None, out=sys.stderr):\n\n    \"\"\"Execute the callback, optionally passing it parsed, and return\n    its return value.  If an exception occurs, determine which kind it\n    is, output an appropriate message, and return the corresponding\n    error code.\"\"\"\n\n    try:\n        if parsed:\n            return callback(parsed)\n        else:\n            return callback()\n    except DeploymentError as e:\n        traceback.print_exc(file=out)\n        print(e, file=out)\n        if hasattr(e, 'value') and hasattr(e.value, 'args') and len(e.value.args) > 0 and \\\n                'open_sftp_client' in e.value.args[0]:\n            print('Timeout', file=out)\n            return TIMEOUT\n        return DEPLOYMENT_ERROR\n    except MalformedResponseError as e:\n        traceback.print_exc(file=out)\n        print(e, file=out)\n        if 'Service Unavailable' in e.body:\n            return SERVICE_UNAVAILABLE\n        return MALFORMED_RESPONSE\n    except SystemExit:\n        pass\n    except:\n        traceback.print_exc(file=out)\n        return EXCEPTION"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an OrderedDict which maps filenames coming from a single local source directory to a single common directory.", "response": "def makemap(filenames, sourcedir, targetdir=None):\n\n    \"\"\"Return an OrderedDict (to preserve script run order) which maps\n    filenames coming from a single local source directory to a single\n    target directory.  Most useful for scripts, whose location when\n    run is often unimportant, and so can all be placed in common\n    directory.\"\"\"\n\n    if targetdir is None: targetdir = DEFAULT_TARGETDIR\n    return OrderedDict(\n        (join(targetdir, f),  join(sourcedir, f)) for f in filenames)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_bundle(name, scripts=[], files=[], scriptsdir=SCRIPTSDIR, filesdir=FILESDIR):\n\n    \"\"\"High level, simplified interface for creating a bundle which\n    takes the bundle name, a list of script file names in a common\n    scripts directory, and a list of absolute target file paths, of\n    which the basename is also located in a common files directory.\n    It converts those lists into maps and then calls new_bundle() to\n    actually create the Bundle and add it to BUNDLEMAP\"\"\"\n\n    scriptmap = makemap(scripts, join(PATH, scriptsdir))\n    filemap = dict(zip(files, [join(PATH, filesdir, os.path.basename(f)) for f in files]))\n    new_bundle(name, scriptmap, filemap)", "response": "This function creates a new bundle and adds it to the BUNDLEMAP"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new bundle and add it to the available bundles", "response": "def new_bundle(name, scriptmap, filemap=None):\n\n    \"\"\"Create a bundle and add to available bundles\"\"\"\n\n    #logger.debug('new bundle %s' % name)\n    if name in BUNDLEMAP:\n        logger.warn('overwriting bundle %s' % name)\n    BUNDLEMAP[name] = Bundle(scriptmap, filemap)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport the module with the given path.", "response": "def import_by_path(path):\n\n    \"\"\"Append the path to sys.path, then attempt to import module with\n    path's basename, finally making certain to remove appended path.\n\n    http://stackoverflow.com/questions/1096216/override-namespace-in-python\"\"\"\n\n    sys.path.append(os.path.dirname(path))\n    try:\n        return __import__(os.path.basename(path))\n    except ImportError:\n        logger.warn('unable to import {0}'.format(path))\n    finally:\n        del sys.path[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nattempting to import a Python module located at path and call init on it.", "response": "def init_module(path):\n\n    \"\"\"Attempt to import a Python module located at path.  If\n    successful, and if the newly imported module has an init()\n    function, then set the global PATH in order to simplify the\n    add_bundle() interface and call init() on the module, passing the\n    current global namespace, conveniently converted into a DictObj so\n    that it can be accessed with normal module style dot notation\n    instead of as a dict.\n\n    http://stackoverflow.com/questions/990422/how-to-get-a-reference-to-current-modules-attributes-in-python\"\"\"\n\n    mod = import_by_path(path)\n    if mod is not None and hasattr(mod, 'init'):\n        logger.debug('calling init on {0}'.format(mod))\n        global PATH\n        PATH = path\n        mod.init(DictObj(globals()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_pubkeys(loadpath, pubkeys):\n\n    \"\"\"Append the file contents in loadpath directory onto pubkeys list\"\"\"\n\n    filenames = os.listdir(loadpath)\n    logger.debug('loading authorized pubkeys {0}'.format(filenames))\n    for filename in filenames:\n        pubkeys.append(open(join(loadpath, filename)).read())", "response": "Load authorized pubkeys from loadpath directory into pubkeys list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize_path(path, relative_to=os.getcwd()):\n\n    \"\"\"Return normalized path.  If path is not user-expandable or\n    absolute, treat it relative to relative_to\"\"\"\n\n    path = os.path.expanduser(os.path.normpath(path))\n\n    if os.path.isabs(path):\n        return path\n    else:\n        return join(relative_to, path)", "response": "Return normalized path. If path is not user - expandable treat it relative to relative_to"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates on each configuration path collecting all public keys that are available for the new node s root account s authorized keys.", "response": "def configure(paths, relative_to):\n\n    \"\"\"Iterate on each configuration path, collecting all public keys\n    destined for the new node's root account's authorized keys.\n    Additionally attempt to import path as python module.\"\"\"\n\n    if not paths:\n        return\n    for path in [normalize_path(p, relative_to) for p in paths]:\n        logger.debug('configuration path {0}'.format(path))\n        pubkeys_path = join(path, PUBKEYSDIR)\n        if os.path.exists(pubkeys_path):\n            load_pubkeys(pubkeys_path, PUBKEYS)\n        init_module(path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parser():\n\n    \"\"\"Return a parser for setting one or more configuration paths\"\"\"\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-c', '--config_paths', default=[], action='append',\n                        help='path to a configuration directory')\n    return parser", "response": "Return a parser for setting one or more configuration paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a parser for configuring authentication parameters", "response": "def add_auth_args(parser, config):\n\n    \"\"\"Return a parser for configuring authentication parameters\"\"\"\n\n    parser.add_argument('-p', '--provider', default=config.DEFAULT_PROVIDER)\n    parser.add_argument('-u', '--userid', default=config.DEFAULT_USERID)\n    parser.add_argument('-k', '--secret_key', default=config.DEFAULT_SECRET_KEY)\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reconfig(main_parser, args=sys.argv[1:]):\n\n    \"\"\"Parse any config paths and reconfigure defaults with them\n    http://docs.python.org/library/argparse.html#partial-parsing\n    Return parsed remaining arguments\"\"\"\n\n    parsed, remaining_args = parser().parse_known_args(args)\n    configure(parsed.config_paths, os.getcwd())\n    return main_parser().parse_args(remaining_args)", "response": "Parse any config paths and reconfigure defaults with them\n    http://docs. python. org / library / argparse. html#partial - parsing\n    Return parsed remaining arguments"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all languages stored in HTML tags.", "response": "def get_html_lang_tags(index_page):\n    \"\"\"\n    Return `languages` stored in ``<meta>`` tags.\n\n    ``<meta http-equiv=\"Content-language\" content=\"cs\">`` -> ``cs``\n\n    Args:\n        index_page (str): HTML content of the page you wish to analyze.\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    dom = dhtmlparser.parseString(index_page)\n\n    lang_tag = \"content-language\"\n    lang_tags = dom.find(\n        \"meta\",\n        fn=lambda x: x.params.get(\"http-equiv\", \"\").lower() == lang_tag\n    )\n\n    return [\n        SourceString(tag.params[\"content\"], \"HTML\")\n        for tag in lang_tags\n        if \"content\" in tag.params\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_html_tag_lang_params(index_page):\n    dom = dhtmlparser.parseString(index_page)\n\n    html_tag = dom.find(\"html\")\n\n    if not html_tag:\n        return []\n\n    html_tag = html_tag[0]\n\n    # parse parameters\n    lang = html_tag.params.get(\"lang\")\n    xml_lang = html_tag.params.get(\"xml:lang\")\n\n    if lang and lang == xml_lang:\n        return [SourceString(lang, source=\"<html> tag\")]\n\n    out = []\n\n    if lang:\n        out.append(SourceString(lang, source=\"<html lang=..>\"))\n\n    if xml_lang:\n        out.append(SourceString(xml_lang, source=\"<html xml:lang=..>\"))\n\n    return out", "response": "Parse lang and xml : lang parameters in the html tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetects languages using langdetect library.", "response": "def detect_language(index_page):\n    \"\"\"\n    Detect `languages` using `langdetect` library.\n\n    Args:\n        index_page (str): HTML content of the page you wish to analyze.\n\n    Returns:\n        obj: One :class:`.SourceString` object.\n    \"\"\"\n    dom = dhtmlparser.parseString(index_page)\n\n    clean_content = dhtmlparser.removeTags(dom)\n\n    lang = None\n    try:\n        lang = langdetect.detect(clean_content)\n    except UnicodeDecodeError:\n        lang = langdetect.detect(clean_content.decode(\"utf-8\"))\n\n    return SourceString(\n        lang,\n        source=\"langdetect\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncollects informations about language of the page from HTML and Dublin core tags and langdetect guesses.", "response": "def get_lang_tags(index_page):\n    \"\"\"\n    Collect informations about language of the page from HTML and Dublin core\n    tags and langdetect guesses.\n\n    Args:\n        index_page (str): HTML content of the page you wish to analyze.\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    dom = dhtmlparser.parseString(index_page)\n\n    lang_tags = [\n        get_html_lang_tags(dom),\n        get_dc_lang_tags(dom),\n        [detect_language(dom)],\n        get_html_tag_lang_params(dom),\n    ]\n\n    return list(sorted(set(\n        SourceString(normalize(lang), source=lang.source)\n        for lang in sum(lang_tags, [])\n    )))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verify(x, t, y, pi, errorOnFail=True):\n    # Unpack the proof\n    p,c,u = pi\n\n    # Verify types\n    assertType(x, G1Element)\n    assertType(y, GtElement)\n    assertType(p, G1Element)\n    assertScalarType(c)\n    assertScalarType(u)\n\n    # TODO: beta can be pre-computed while waiting for a server response.\n    Q = generatorG1()\n    beta = pair(x,hashG2(t))\n\n    # Recompute c'\n    t1 = Q*u + p*c \n    t2 = beta**u * y**c\n\n    t1.normalize()\n\n    cPrime = hashZ(Q,p,beta,y,t1,t2)\n\n    # Check computed @c' against server's value @c\n    if cPrime == c:\n        return True\n\n    if errorOnFail:\n        raise Exception(\"zero-knowledge proof failed verification.\")\n    else:\n        return False", "response": "Verify a zero - knowledge proof where p \\ in G1."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove blinding using ephemeral key rInv on ( intermediate result ) y \\ in Gt.", "response": "def deblind(rInv,y):\n    \"\"\"\n    Removes blinding using ephemeral key @rInv on (intermediate result) \n    @y \\in Gt.\n    \"\"\"\n    # Verify types, then deblind using the values provided.\n    assertScalarType(rInv)\n    assertType(y, GtElement)\n    return y ** rInv"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of directories where plugins may be located.", "response": "def _get_plugin_dirs():\n    \"\"\"Return a list of directories where plugins may be located.\n    \"\"\"\n    plugin_dirs = [\n        os.path.expanduser(os.path.join(USER_CONFIG_DIR, \"plugins\")),\n        os.path.join(\"rapport\", \"plugins\")  # Local dev tree\n    ]\n    return plugin_dirs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _path_to_module(path):\n    # Split of preceeding path elements:\n    path = \"rapport\" + path.split(\"rapport\")[1]\n    # Split of ending and replace os.sep with dots:\n    path = path.replace(os.sep, \".\").rsplit(\".\", 1)[0]\n    return path", "response": "Translates paths to. py? files into module paths."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding and load all available plugins.", "response": "def discover():\n    \"\"\"Find and load all available plugins.\n    \"\"\"\n    plugin_files = []\n\n    for plugin_dir in _get_plugin_dirs():\n        if os.path.isdir(plugin_dir):\n            for plugin_file in os.listdir(plugin_dir):\n                if plugin_file.endswith(\".py\") and not plugin_file == \"__init__.py\":\n                    plugin_files.append(os.path.join(plugin_dir, plugin_file))\n\n    if rapport.config.get_int(\"rapport\", \"verbosity\") >= 2:\n        print(\"Found plugin modules: {0}\".format(plugin_files))\n\n    for plugin_file in plugin_files:\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 2:\n            print(\"Importing module {0}\".format(_path_to_module(plugin_file)))\n        __import__(_path_to_module(plugin_file))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering a plugin in the plugin catalog.", "response": "def register(name, klass):\n    \"\"\"Add a plugin to the plugin catalog.\n    \"\"\"\n    if rapport.config.get_int(\"rapport\", \"verbosity\") >= 1:\n        print(\"Registered plugin: {0}\".format(name))\n    _PLUGIN_CATALOG[name] = klass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init(name, *args, **kwargs):\n    if name in _PLUGIN_CATALOG:\n        if rapport.config.get_int(\"rapport\", \"verbosity\") >= 2:\n            print(\"Initialize plugin {0}: {1} {2}\".format(name, args, kwargs))\n        try:\n            return _PLUGIN_CATALOG[name](*args, **kwargs)\n        except (ValueError, TypeError) as e:\n            print(\"Failed to initialize plugin {0}: {1}!\".format(name, e), file=sys.stderr)\n    else:\n        print(\"Failed to initialize plugin {0}: Not in catalog!\".format(name), file=sys.stderr)", "response": "Instantiate a plugin from the catalog."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _results(self, dict={}):\n        results = {\"plugin\": str(self),\n                   \"alias\": self.alias,\n                   \"url\": self.url,\n                   \"login\": self.login}\n        results.update(dict)\n        return results", "response": "Helper to merge a dict with cross - plugin defaults."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to collect the next timeframe.", "response": "def try_collect(self, timeframe):\n        \"\"\"\n        Run the plugin's collect() method, and if an exception was caught,\n        store the traceback before re-raising, in order that it doesn't\n        get lost when concurrent.futures.Future.result() is invoked.\n        \"\"\"\n        try:\n            result = self.collect(timeframe)\n        except Exception as e:\n            exc_type, exc_val, exc_tb = sys.exc_info()\n            e.original_traceback = exc_tb\n            raise\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(MapNotifyMessage, self).sanitize()\n\n        # The first bit after the Type field in a Map-Notify message is\n        # allocated as the \"I\" bit.  I bit indicates that a 128 bit xTR-ID and\n        # 64 bit site-ID field is present at the end of the Map-Notify message,\n        # following the final Record in the Map-Notify.\n        if not isinstance(self.xtr_id, numbers.Integral) \\\n        or self.xtr_id < 0 or self.xtr_id >= 2 ** 128:\n            raise ValueError('Invalid xTR-ID')\n\n        # site-ID is a 64 bit field at the end of the Map-Register message,\n        # following the xTR-ID.\n        if not isinstance(self.site_id, numbers.Integral) \\\n        or self.site_id < 0 or self.site_id >= 2 ** 64:\n            raise ValueError('Invalid site-ID')\n\n        # Nonce:  This 8-octet Nonce field is set to 0 in Map-Register\n        # messages.  Since the Map-Register message is authenticated, the\n        # nonce field is not currently used for any security function but\n        # may be in the future as part of an anti-replay solution.\n        if len(bytes(self.nonce)) != 8:\n            raise ValueError('Invalid nonce')\n\n        # Key ID:  A configured ID to find the configured Message\n        # Authentication Code (MAC) algorithm and key value used for the\n        # authentication function.  See Section 14.4 for codepoint\n        # assignments.\n        if self.key_id not in (KEY_ID_NONE, KEY_ID_HMAC_SHA_1_96,\n                               KEY_ID_HMAC_SHA_256_128):\n            raise ValueError('Invalid Key ID')\n\n        # Authentication Data:  The message digest used from the output of the\n        # Message Authentication Code (MAC) algorithm.  The entire Map-\n        # Register payload is authenticated with this field preset to 0.\n        # After the MAC is computed, it is placed in this field.\n        # Implementations of this specification MUST include support for\n        # HMAC-SHA-1-96 [RFC2404] and support for HMAC-SHA-256-128 [RFC6234]\n        # is RECOMMENDED.\n        if not isinstance(self.authentication_data, bytes):\n            raise ValueError('Invalid authentication data')\n\n        # Map-Reply Record:  When the M bit is set, this field is the size of a\n        # single \"Record\" in the Map-Reply format.  This Map-Reply record\n        # contains the EID-to-RLOC mapping entry associated with the Source\n        # EID.  This allows the ETR which will receive this Map-Request to\n        # cache the data if it chooses to do so.\n        for record in self.records:\n            if not isinstance(record, MapRegisterRecord):\n                raise ValueError('Invalid record')\n\n            record.sanitize()", "response": "Sanitize the Map - Notify message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef beautify(string, *args, **kwargs):\n\n\tparser = Parser(args, kwargs)\n\treturn parser.beautify(string)", "response": "Beautify a string with ecstasy."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_flags(self, args):\n\n\t\t\"\"\"\n\t\tChecks and retrieves positional and 'always' (keyword) flags\n\t\tfrom the many ways in which they may be passed to the\n\t\tconstructor (or the beautify() method on package-level).\n\n\t\tPositional arguments can be passed either:\n\n\t\t* Individually, where each flag-combination is one positional argument.\n\t\t* Packaged inside a list, which is then expanded. There can be\n\t\t  multiple of such lists passed as arguments because it facilitates\n\t\t  interaction with the ecastasy module (one may want to organize\n\t\t  and update styles in certain ways depending on one's program), but\n\t\t  each list will be expanded and all flag-combinations found inside\n\t\t  each list will be interpreted as a single style argument, as if it\n\t\t  had been passed in the way desribed above (individually).\n\n\t\t'Always' arguments can be passed either:\n\n\t\t* Individually, with keyword-argument syntax, i.e. <word>=<style>\n\t\t* In a dictionary, which is expanded exactly like positional\n\t\t  arguments passed in lists (i.e. each key/value pair in the\n\t\t  dictionary is interpreted as if it had been passed individually,\n\t\t  as key=value to the constructor/the external beautify() method).\n\n\t\tNote:\n\t\t\tself.always is set equal to the keyword arguments passed to the\n\t\t\tconstructor and then modified directly (when 'always'-arguments\n\t\t\tare found), while the positional arguments are put into a list\n\t\t\there and returned (i.e. no interaction with self.positional).\n\n\t\tArguments:\n\t\t\targs (list): The positional arguments passed to the constructor.\n\n\t\tReturns:\n\t\t\tThe positional arguments.\n\n\t\tRaises:\n\t\t\terrors.FlagError: If an invalid (out-of-range)\n\t\t\t\t\t\t\t  flag combination was passed.\n\n\t\t\terrors.EcstasyError: If one of the arguments is of invalid type.\n\n\t\t\"\"\"\n\n\t\tpositional = []\n\n\t\tfor argument in args:\n\t\t\t# A flag is an instance of a subclass of\n\t\t\t# flags.Flags if it was passed alone\n\t\t\tif isinstance(argument, flags.Flags):\n\t\t\t\tpositional.append(argument)\n\n\t\t\t# or is an integer if it was (bitwise) OR'd\n\t\t\t# with another flag (a \"flag combination\")\n\t\t\telif isinstance(argument, int):\n\t\t\t\tif argument < 0 or argument >= flags.LIMIT:\n\t\t\t\t\traise errors.FlagError(\"Flag value '{0}' is out of range \"\n\t\t\t\t\t\t\t\t\t\t   \"!\".format(argument))\n\t\t\t\tpositional.append(argument)\n\n\t\t\t# Dictionaries store 'always'-arguments\n\t\t\telif isinstance(argument, dict):\n\t\t\t\tfor key, value in argument.items():\n\t\t\t\t\t# Simple 'always'-argument where one string\n\t\t\t\t\t# is mapped to one formatting flag-combination\n\t\t\t\t\tif isinstance(key, str):\n\t\t\t\t\t\tself.always[key] = value\n\n\t\t\t\t\t# Complex 'always'-argument with a\n\t\t\t\t\t# tuple containing strings, each with the same\n\t\t\t\t\t# flag-combination (same value)\n\t\t\t\t\telif isinstance(key, tuple):\n\t\t\t\t\t\tfor i in key:\n\t\t\t\t\t\t\tself.always[i] = value\n\t\t\t\t\telse:\n\t\t\t\t\t\traise errors.EcstasyError(\"Key '{0}' in dictionary \"\n\t\t\t\t\t\t\t\t\t\t\t\t  \"argument passed is neither \"\n\t\t\t\t\t\t\t\t\t\t\t\t  \"a string nor a tuple \"\n\t\t\t\t\t\t\t\t\t\t\t\t  \"of strings!\".format(key))\n\n\t\t\telif isinstance(argument, collections.Iterable):\n\t\t\t\tpositional += self.get_flags(argument)\n\n\t\t\telse:\n\t\t\t\traise errors.EcstasyError(\"Argument '{0}' is neither a flag, a \"\n\t\t\t\t\t\t\t\t\t\t  \"(bitwise) OR'd flag-combination, a \"\n\t\t\t\t\t\t\t\t\t\t  \"dictionary nor an  iterable of \"\n\t\t\t\t\t\t\t\t\t\t  \"positional arguments \"\n\t\t\t\t\t\t\t\t\t\t  \"!\".format(argument))\n\n\t\treturn positional", "response": "This method returns the flags from the arguments passed to the constructor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef beautify(self, string):\n\n\t\tif not string:\n\t\t\treturn string\n\n\t\t# string may differ because of escaped characters\n\t\tstring, phrases = self.parse(string)\n\n\t\tif not phrases:\n\t\t\treturn string\n\n\t\tif not self.positional and not self.always:\n\t\t\traise errors.ArgumentError(\"Found phrases, but no styles \"\n\t\t\t\t\t\t\t\t\t   \"were supplied!\")\n\n\t\treturn self.stringify(string, phrases)", "response": "Wraps together all actions needed to beautify a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a string to handle escaped tags and retrieve phrases.", "response": "def parse(self, string, root=None):\n\n\t\t\"\"\"\n\t\tParses a string to handle escaped tags and retrieve phrases.\n\n\t\tThis method works recursively to parse nested tags. When escaped\n\t\ttags are found, those are removed from the string. Also argument\n\t\tsequences are removed from the string. The string returned can\n\t\tthus be quite different from the string passed.\n\n\t\tArguments:\n\t\t\tstring (str): The string to parse.\n\t\t\troot (Phrase): If in a recursive call, the root/parent phrase.\n\n\t\tReturns:\n\t\t\tFor one, the escaped string (without escape characters and\n\t\t\tphrase arguments). For the other, it depends on the stack-depth.\n\t\t\tIf this is the lowest recursion depth/level (i.e. the stack\n\t\t\tcall resulting from the first function call in self.beautify()),\n\t\t\tit will return a list of phrases. For higher stack levels (\n\t\t\ti.e. resulting from recursive function calls from with\n\t\t\tself.parse(), for nested phrases), it returns exactly one\n\t\t\tPhrase instance.\n\n\t\tRaises:\n\t\t\terrors.ParseError: If no closing tag could be\n\t\t\t\t\t\t\t   found for an opening tag.\n\t\t\"\"\"\n\n\t\tphrases = []\n\n\t\tmeta = self.meta.search(string)\n\n\t\twhile meta:\n\n\t\t\t# Save some function calls\n\t\t\tpos = meta.start()\n\n\t\t\tif meta.group() == \"<\":\n\t\t\t\tstring, child, meta = self.open_phrase(string, pos)\n\n\t\t\t\tif child and root:\n\t\t\t\t\troot.nested.append(child)\n\t\t\t\telif child:\n\t\t\t\t\tphrases.append(child)\n\n\t\t\t\t# else it was escaped (+ new meta)\n\t\t\t\tcontinue\n\n\t\t\telif root:\n\n\t\t\t\tif meta.group() == \"(\":\n\t\t\t\t\tmeta = self.meta.search(string, pos + 1)\n\t\t\t\t\tif meta.group() == \")\":\n\t\t\t\t\t\tstring, root, meta = self.handle_arguments(string,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   pos,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   meta.start())\n\t\t\t\t\t\tcontinue\n\n\t\t\t\telif meta.group() == \">\":\n\t\t\t\t\tstring, phrase, meta = self.close_phrase(string,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t pos)\n\t\t\t\t\tif phrase:\n\t\t\t\t\t\treturn string, phrase\n\n\t\t\t\t\t# else was escaped (+ new meta)\n\t\t\t\t\tcontinue\n\n\t\t\tstring, meta = self.escape_meta(string, pos)\n\n\t\tif not root:\n\t\t\treturn string, phrases\n\n\t\t# If this is not the first stack-depth the function should\n\t\t# have returned upon finding a closing tag,\n\t\t# i.e. we should never have gotten here.\n\t\tword = re.search(r\"([\\w\\s]+)(?![\\d]*>[\\w\\s]+>)\", string)\n\n\t\twhat = \"No closing tag found for opening tag\"\n\n\t\tif word:\n\t\t\twhat += \" after expression '{0}'\".format(word.group())\n\n\t\traise errors.ParseError(what + \"!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef escape_meta(self, string, pos):\n\n\t\t\"\"\"\n\t\tChecks if a meta character is escaped or else warns about it.\n\n\t\tIf the meta character has an escape character ('\\') preceding it,\n\t\tthe meta character is escaped. If it does not, a warning is emitted\n\t\tthat the user should escape it.\n\n\t\tArguments:\n\t\t\tstring (str): The relevant string in which the character was found.\n\t\t\tpos (int): The index of the meta character within the string.\n\n\t\tReturns:\n\t\t\tThe possibly escaped string and the next meta match.\n\t\t\"\"\"\n\n\t\t# Replace escape character\n\t\tif pos > 0 and string[pos - 1] == \"\\\\\":\n\t\t\tstring = string[:pos - 1] + string[pos:]\n\t\telse:\n\t\t\twarnings.warn(\"Un-escaped meta-character: '{0}' (Escape\"\n\t\t\t\t\t\t  \" it with a '\\\\')\".format(string[pos]),\n\t\t\t\t\t\t  Warning)\n\t\t\tpos += 1\n\n\t\tmeta = self.meta.search(string, pos)\n\n\t\treturn string, meta", "response": "Checks if a meta character is escaped and if it is not warns about it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle phrase - arguments.", "response": "def handle_arguments(self, string, root, opening, closing):\n\n\t\t\"\"\"\n\t\tHandles phrase-arguments.\n\n\t\tSets the override and increment flags if found. Also makes\n\t\tsure that the argument sequence is at the start of the phrase\n\t\tand else warns about the unescaped meta characters. If the\n\t\targuments are indeed at the start but do not match the arguments\n\t\tregular expression, an error is raised.\n\n\t\tArguments:\n\t\t\tstring (str): The string being parsed.\n\t\t\troot (str): The current root phrase.\n\t\t\topening (int): The index of the opening paranthese.\n\t\t\tclosing (int): The index of the closing paranthese.\n\n\t\tReturns:\n\t\t\tThe (possibly escaped) string, the root phrase (if no escaping,\n\t\t\tthen with arguments and flags) and the next meta match.\n\n\t\tRaises:\n\t\t\terrors.ParseError: If the arguments are invalid.\n\t\t\"\"\"\n\n\t\t# The actual argument string (ignore whitespace)\n\t\targs = string[opening + 1 : closing].replace(\" \", \"\")\n\n\t\t# The argument sequence must be at the start of the phrase\n\t\t# and must match the allowed argument regular expression\n\t\tif opening > 0 or not self.arguments.match(args):\n\n\t\t\tif opening == 0:\n\t\t\t\traise errors.ParseError(\"Invalid argument sequence!\")\n\n\t\t\t# If escape_meta does indeed escape a character and removes\n\t\t\t# a backward slash, the positions 'opening' and 'closing' are no\n\t\t\t# longer valid. escape_meta does a search for the next meta\n\t\t\t# character though, which is then the closing parantheses,\n\t\t\t# so we can use its index value (in the now escaped string)\n\t\t\tstring, meta = self.escape_meta(string, opening)\n\t\t\tstring, meta = self.escape_meta(string, meta.start())\n\n\t\t\treturn string, root, meta\n\n\t\tif \"!\" in args:\n\t\t\troot.override = True\n\t\t\targs = args.replace(\"!\", \"\")\n\n\t\tif \"+\" in args:\n\t\t\troot.increment = True\n\t\t\targs = args.replace(\"+\", \"\")\n\n\t\troot.arguments = [int(i) for i in args.split(\",\") if i]\n\n\t\t# Remove the argument string including parantheses\n\t\tstring = string[closing + 1:]\n\n\t\tmeta = self.meta.search(string)\n\n\t\treturn string, root, meta"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stringify(self, string, phrases, parent=None):\n\n\t\t\"\"\"\n\t\tStringifies phrases.\n\n\t\tAfter parsing of the string via self.parse(), this method takes the\n\t\tescaped string and the list of phrases returned by self.parse() and\n\t\treplaces the original phrases (with tags) with the Phrase-objects in\n\t\tthe list and adds the appropriate flag-combinations as determined by\n\t\tthe string or the position of the phrase (the string if it's in\n\t\tself.always, i.e. an 'always' argument). This method also works\n\t\trecursively to handle nested phrases (and resetting of parent-phrase\n\t\tstyles).\n\n\t\tArguments:\n\t\t\tstring (str): The escaped string returned by self.parse().\n\t\t\tphrases (list): The list of Phrase-objects returned by self.parse().\n\t\t\tparent (Phrase): For recursive calls, the current parent Phrase.\n\n\t\tReturns:\n\t\t\tThe finished, beautifully beautified string.\n\n\t\tRaises:\n\t\t\terrors.ArgumentError: If more positional arguments are requested\n\t\t\t\t\t\t\t\t  than were supplied.\n\t\t\"\"\"\n\n\t\tlast_tag = 0\n\n\t\tbeauty = \"\"\n\n\t\tfor phrase in phrases:\n\n\t\t\tbeauty += string[last_tag : phrase.opening]\n\n\t\t\tif phrase.string in self.always and not phrase.override:\n\t\t\t\tphrase.style = self.always[phrase.string]\n\n\t\t\tif phrase.arguments:\n\t\t\t\tcombination = 0\n\t\t\t\tfor i in phrase.arguments:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tcombination |= self.positional[i]\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\traise errors.ArgumentError(\"Positional argument '{0}' \"\n\t\t\t\t\t\t\t \t\t\t\t\t   \"is out of range\"\n\t\t\t\t\t\t\t \t\t\t\t\t   \"!\".format(i))\n\n\t\t\t\tphrase.style |= combination\n\n\t\t\telif (phrase.string not in self.always or\n\t\t\t\t  phrase.increment or phrase.override):\n\t\t\t\ttry:\n\t\t\t\t\tcombination = self.positional[self.counter]\n\n\t\t\t\t\tif phrase.increment or not phrase.override:\n\t\t\t\t\t\tself.counter += 1\n\t\t\t\texcept IndexError:\n\t\t\t\t\tself.raise_not_enough_arguments(phrase.string)\n\n\t\t\t\tphrase.style |= combination\n\n\t\t\tphrase.style = flags.codify(phrase.style)\n\n\t\t\tif phrase.nested:\n\t\t\t\tphrase.string = self.stringify(phrase.string,\n\t\t\t\t\t\t\t\t\t\t\t   phrase.nested,\n\t\t\t\t\t\t\t\t\t\t\t   phrase)\n\n\t\t\t# After a nested phrase is over, we reset the style to the\n\t\t\t# parent style, this gives the notion of nested styles.\n\t\t\treset = parent.style if parent else \"\"\n\n\t\t\t# \\033[ signifies the start of a command-line escape-sequence\n\t\t\tbeauty += \"\\033[{0}m{1}\\033[0;{2}m\".format(phrase.style,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   phrase,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   reset)\n\t\t\tlast_tag = phrase.closing + 1\n\n\t\tbeauty += string[last_tag:]\n\n\t\treturn beauty", "response": "This method will be used to create a string from a list of Phrase objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef raise_not_enough_arguments(self, string):\n\n\t\t\"\"\"\n\t\tRaises an errors.ArgumentError if not enough arguments were supplied.\n\n\t\tTakes care of formatting for detailed error messages.\n\n\t\tArguments:\n\t\t\tstring (str): The string of the phrase for which there weren't enough\n\t\t\t\t\t\t  arguments.\n\n\t\tRaises:\n\t\t\terrors.ArgumentError with a detailed error message.\n\t\t\"\"\"\n\n\t\trequested = errors.number(self.counter + 1)\n\n\t\tnumber = len(self.positional)\n\n\t\tverb = \"was\" if number == 1 else \"were\"\n\n\t\twhat = \"Requested {} formatting argument for \"\\\n\t\t\t   \"'{}' but only {} {} supplied!\"\n\n\t\twhat = what.format(requested, string, number, verb)\n\n\t\traise errors.ArgumentError(what)", "response": "Raises an exception if not enough arguments were supplied."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_entry(key):\n    if type(key) != str:\n        raise TypeError(\"key must be str\")\n    if key not in _config:\n        raise KeyError(\"Nonexistent entry '{key}'\".format(key=key))\n    return _config[key]", "response": "Get a configuration entry by name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets a configuration entry for the current node.", "response": "def set_entry(key, value):\n    \"\"\"\n    Set a configuration entry\n\n    :param key: key name\n    :param value: value for this key\n    :raises KeyError: if key is not str\n    \"\"\"\n    if type(key) != str:\n        raise KeyError('key must be str')\n    _config[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _list_merge(src, dest):\n    for k in src:\n        if type(src[k]) != dict:\n            dest[k] = src[k]\n        else:\n            # ---\n            # src could have a key whose value is a list\n            # and does not yet exist on dest\n            if k not in dest:\n                dest[k] = {}\n            _list_merge(src[k], dest[k])", "response": "Recursively merge the contents coming from src into dest."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_from_file(file_name):\n    if type(file_name) != str:\n        raise TypeError('file_name must be str')\n    global _config_file_name\n    _config_file_name = file_name\n    # Try to open the file and get the json data into a dictionary\n    with open(file_name, \"r\") as file:\n        data = yaml.load(file)\n    # each value found will overwrite the same value in the config\n    _list_merge(data, _config)", "response": "Merge configuration from a file with JSON data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_html_keywords(index_page):\n    keyword_lists = (\n        keyword_list.split(\",\")\n        for keyword_list in parse_meta(index_page, \"keywords\", \"HTML\")\n    )\n\n    # create SourceStrings from the list of keywords\n    return [\n        SourceString(keyword.strip(), source=\"HTML\")\n        for keyword in sum(keyword_lists, [])  # flattern the list\n    ]", "response": "Returns a list of source strings parsed from HTML meta tags."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning list of keywords parsed from Dublin core.", "response": "def get_dc_keywords(index_page):\n    \"\"\"\n    Return list of `keywords` parsed from Dublin core.\n\n    Args:\n        index_page (str): Content of the page as UTF-8 string\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    keyword_lists = (\n        keyword_list.split()\n        for keyword_list in parse_meta(index_page, \"dc.keywords\", \"DC\")\n    )\n\n    return [\n        SourceString(keyword, source=\"DC\")\n        for keyword in sum(keyword_lists, [])  # flattern the list\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning to process text on the index_page deduce the keywords and then try to match them on the Aleph s dataset.", "response": "def extract_keywords_from_text(index_page, no_items=5):\n    \"\"\"\n    Try to process text on the `index_page` deduce the keywords and then try\n    to match them on the Aleph's dataset.\n\n    Function returns maximally `no_items` items, to prevent spamming the user.\n\n    Args:\n        index_page (str): Content of the page as UTF-8 string\n        no_items (int, default 5): Number of items to return.\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    index_page = MLStripper.strip_tags(index_page)\n    tokenized_index = TextBlob(index_page).lower()\n\n    def to_str(key):\n        if isinstance(key, unicode):\n            return key.encode(\"utf-8\")\n\n        return key\n\n    present_keywords = [\n        KEYWORDS_LOWER[key]\n        for key in KEYWORDS_LOWER.keys()\n        if len(key) > 3 and key in tokenized_index\n    ]\n\n    def to_source_string(key):\n        source = \"Keyword analysis\"\n        try:\n            return SourceString(key, source)\n        except UnicodeEncodeError:\n            return SourceString(key.encode(\"utf-8\"), source)\n\n    multi_keywords = [\n        to_source_string(key)\n        for key in present_keywords\n        if tokenized_index.words.count(key) >= 1\n    ]\n\n    multi_keywords = sorted(multi_keywords, key=lambda x: len(x), reverse=True)\n\n    if len(multi_keywords) > no_items:\n        return multi_keywords[:no_items]\n\n    return multi_keywords"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the index page and returns a list of keywords.", "response": "def get_keyword_tags(index_page, map_to_nk_set=True):\n    \"\"\"\n    Parse `keywords` from HTML ``<meta>``, dublin core and from text.\n\n    Args:\n        index_page (str): Content of the page as UTF-8 string.\n        map_to_nk_set (bool): Should the algorithm try to map keywords to\n            keywords used in NK?\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    dom = dhtmlparser.parseString(index_page)\n\n    keywords = [\n        get_html_keywords(dom),\n        get_dc_keywords(dom),\n    ]\n    # do not try to match extracted_keywords, because they are based on Aleph's\n    # dataset\n    extracted_keywords = extract_keywords_from_text(index_page)\n\n    keywords = sum(keywords, [])  # flattern\n\n    if not map_to_nk_set:\n        return keywords + extracted_keywords\n\n    def try_match(keyword):\n        \"\"\"\n        This provides chance to speed up the process a little.\n        \"\"\"\n        kw = KEYWORDS_LOWER.get(keyword.lower())\n        if kw:\n            return kw\n\n        return process.extractOne(str(keyword), KEYWORDS)[0].encode(\"utf-8\")\n\n    keywords = [\n        SourceString(\n            try_match(keyword),\n            source=keyword.source,\n        )\n        for keyword in keywords\n    ]\n\n    return sorted(list(set(keywords + extracted_keywords)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strip_tags(cls, html):\n        s = cls()\n        s.feed(html)\n\n        return s.get_data()", "response": "This function may be used to remove HTML tags from data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a CallDescriptor from the local database given a hash key.", "response": "def fetch( hash ):\n    \"\"\"\n    Fetches CallDescriptor from the local database given a hash key representing the call. If it doesn't exist returns None.\n\n    :param str hash: The sha1 hexdigest to look the CallDescriptor up by.\n\n    :rtype: CallDescriptor corresponding to the hash passed or None if it wasn't found.\n    \"\"\"\n    res = select_io( hash )\n\n    if res:\n      p = { 'methodname': '', 'returnval': '', 'args': '', 'stack': '' }\n      for packet in res:\n        hash, stack, methodname, returnval, args, packet_num = packet\n        p['methodname'] = p['methodname'] + methodname\n        p['returnval']  = p['returnval'] + returnval\n        p['args']       = p['args'] + args\n        p['stack']      = p['stack'] + stack\n                             \n      return CallDescriptor( hash = hash,\n                             stack = p['stack'],\n                             method = p['methodname'],\n                             returnval = pickle.loads( str( p['returnval'] ) ),\n                             args = pickle.loads( str( p['args'] ) ) )\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving the CallDescriptor to the database.", "response": "def save( self ):\n        \"\"\"\n        Save method for the CallDescriptor.\n\n        If the CallDescriptor matches a past CallDescriptor it updates the existing\n        database record corresponding to the hash. If it doesn't already exist it'll\n        be INSERT'd.\n        \"\"\"\n        packets = self.__enumerate_packets( )\n        delete_io( self.hash )\n        for packet in packets:\n            packet['hash'] = self.hash\n            insert_io( packet )\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the internal state of the object.", "response": "def initialize(self, text=None, comment=None, user=None, restricted=None):\n        self.text = none_or(text, bool)\n        \"\"\"\n        Is the text of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.comment = none_or(comment, bool)\n        \"\"\"\n        Is the comment of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.user = none_or(user, bool)\n        \"\"\"\n        Is the user of this revision deleted/suppressed? : `bool`\n        \"\"\"\n\n        self.restricted = none_or(restricted, bool)\n        \"\"\"\n        Is the revision restricted? : `bool`\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_int(cls, integer):\n        bin_string = bin(integer)\n\n        return cls(\n            text=len(bin_string) >= 1 and bin_string[-1] == \"1\",\n            comment=len(bin_string) >= 2 and bin_string[-2] == \"1\",\n            user=len(bin_string) >= 3 and bin_string[-3] == \"1\",\n            restricted=len(bin_string) >= 4 and bin_string[-4] == \"1\"\n        )", "response": "Constructs a Deleted object from an integer value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the object with the given attributes.", "response": "def initialize(self, id, timestamp=None, user=None, page=None, minor=None,\n                   comment=None, text=None, bytes=None, sha1=None,\n                   parent_id=None, model=None, format=None, deleted=None):\n\n        self.id = none_or(id, int)\n        \"\"\"\n        Revision ID : `int`\n        \"\"\"\n\n        self.timestamp = none_or(timestamp, Timestamp)\n        \"\"\"\n        Revision timestamp : :class:`mwtypes.Timestamp`\n        \"\"\"\n\n        self.user = none_or(user, User)\n        \"\"\"\n        Contributing user metadata : :class:`~mwtypes.User`\n        \"\"\"\n\n        self.page = none_or(page, Page)\n        \"\"\"\n        Page metadata : :class:`~mwtypes.Page`\n        \"\"\"\n\n        self.minor = none_or(minor, bool)\n        \"\"\"\n        Is revision a minor change? : `bool`\n        \"\"\"\n\n        self.comment = none_or(comment, str)\n        \"\"\"\n        Comment left with revision : `str`\n        \"\"\"\n\n        self.text = none_or(text, str)\n        \"\"\"\n        Content of text : `str`\n        \"\"\"\n\n        self.bytes = none_or(bytes, int)\n        \"\"\"\n        Number of bytes of content : `int`\n        \"\"\"\n\n        self.sha1 = none_or(sha1, str)\n        \"\"\"\n        sha1 hash of the content : `str`\n        \"\"\"\n\n        self.parent_id = none_or(parent_id, int)\n        \"\"\"\n        Revision ID of preceding revision : `int` | `None`\n        \"\"\"\n\n        self.model = none_or(model, str)\n        \"\"\"\n        TODO: ??? : `str`\n        \"\"\"\n\n        self.format = none_or(format, str)\n        \"\"\"\n        TODO: ??? : `str`\n        \"\"\"\n\n        self.deleted = none_or(deleted, self.Deleted)\n        \"\"\"\n        The deleted/suppressed status of the revision.\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a word returns a list of pieces broken at the possible hyphenation points.", "response": "def hyphenate_word(self, word):\n        \"\"\" Given a word, returns a list of pieces, broken at the possible\n            hyphenation points.\n        \"\"\"\n        # Short words aren't hyphenated.\n        if len(word) <= 4:\n            return [word]\n        # If the word is an exception, get the stored points.\n        if word.lower() in self.exceptions:\n            points = self.exceptions[word.lower()]\n        else:\n            work = '.' + word.lower() + '.'\n            points = [0] * (len(work)+1)\n            for i in range(len(work)):\n                t = self.tree\n                for c in work[i:]:\n                    if c in t:\n                        t = t[c]\n                        if None in t:\n                            p = t[None]\n                            for j in range(len(p)):\n                                points[i+j] = max(points[i+j], p[j])\n                    else:\n                        break\n            # No hyphens in the first two chars or the last two.\n            points[1] = points[2] = points[-2] = points[-3] = 0\n\n        # Examine the points to build the pieces list.\n        pieces = ['']\n        for c, p in zip(word, points[2:]):\n            pieces[-1] += c\n            if p % 2:\n                pieces.append('')\n        return pieces"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_arrow(self, tipLoc, tail=None, arrow=arrow.default):\n        self._arrows.append((tipLoc, tail, arrow))", "response": "This method adds a straight arrow that points to\n        tipLoc which is a tuple of integers."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a string that specifies either a model or a field.", "response": "def parse_model_specifier(specifier):\n    '''\n    Parses a string that specifies either a model or a field.\n    The string should look like ``app.model.[field]``.\n\n    >>> print parse_model_specifier('tests.TestModel')\n    (<class 'tests.models.TestModel'>, None)\n    >>> print parse_model_specifier('tests.TestModel.image')\n    (<class 'tests.models.TestModel'>, 'image')\n\n    :return: model and (optionally) field name\n    :rtype: tuple of :py:class:`~django.db.models.Model` and str or None\n    '''\n    values = specifier.split('.')\n\n    if len(values) == 2:\n        values.append(None)\n    elif len(values) != 3:\n        raise ValueError(\n            'Model specifier must be in app.model.[field] format. It'\n            'has {} parts instead of 2 or 3 (when split on \".\")'.format(\n                len(values)\n            )\n        )\n\n    app_name, model_name, field_name = values\n    model = get_model(app_name, model_name)\n    if not model:\n        raise ValueError(\n            'Model {} on app {} can not be found'.format(\n                model_name,\n                app_name,\n            )\n        )\n    return model, field_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_object(context):\n    object = None\n\n    view = context.get('view')\n    if view:\n        # View is more reliable then an 'object' variable in the context.\n        # Works if this is a SingleObjectMixin\n        object = getattr(view, 'object', None)\n\n    if object is None:\n        object = context.get('object', None)\n\n    return object", "response": "Get an object from the context or view."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all rows as HTML.", "response": "def get_rows(self, request, context):\n        \"\"\"\n        Get all rows as HTML\n        \"\"\"\n        from staff_toolbar.loading import load_toolbar_item\n        rows = []\n        for i, hook in enumerate(self.children):\n            # Allow dotted paths in groups too, loads on demand (get import errors otherwise).\n            if isinstance(hook, (basestring, tuple, list)):\n                hook = load_toolbar_item(hook)\n                self.children[i] = hook\n\n            html = hook(request, context)\n            if not html:\n                continue\n\n            rows.append(html)\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render(self, rows):\n        if not rows:\n            return ''\n\n        li_tags = mark_safe(u\"\\n\".join(format_html(u'<li>{0}</li>', force_text(row)) for row in rows))\n        if self.title:\n            return format_html(u'<div class=\"toolbar-title\">{0}</div>\\n<ul>\\n{1}\\n</ul>', self.title, li_tags)\n        else:\n            return format_html(u'<ul>\\n{0}\\n</ul>', li_tags)", "response": "Render the HTML table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_json(self, json):\n        import time\n\n        if 'access_token' in json:\n            self.access_token = json['access_token']\n            self.refresh_token = json['refresh_token']\n            self.expires_in = json['expires_in']\n\n            if 'authenticated' in json:\n                self.authenticated = json['authenticated']\n            else:\n                self.authenticated = time.time()\n        else:\n            self.access_token = None", "response": "Set all attributes based on JSON response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check(self):\n        import time\n\n        if self.expires_in is None or self.authenticated is None:\n            return False\n\n        current = time.time()\n        expire_time = self.authenticated + self.expires_in\n\n        return expire_time > current", "response": "Check if the access token is expired or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef r_plokamos_proxy(self):\n\n        query = request.data\n\n        if self.is_authorized(query,NemoOauthPlugin.current_user()['uri']):\n            try:\n                resp = requests.post(self.annotation_update_endpoint, data=query, json=None,\n                                     headers={\"content-type\": \"application/sparql-update\",\n                                              \"accept\": \"application/sparql-results+json\"})\n                resp.raise_for_status()\n                return resp.content, resp.status_code\n            except requests.exceptions.HTTPError as err:\n                return str(err), resp.status_code\n        else:\n            return \"Unauthorized request\", 403", "response": "Proxy to write to the annotation store"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the extension to the given application.", "response": "def init_app(self, app):\n        \"\"\"Initialize extension to the given application.\n\n        Extension will be registered to `app.extensions` with lower classname\n        as key and instance as value.\n\n        :param app: Flask application.\n        \"\"\"\n        self.init_extension(app)\n\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        classname = self.__class__.__name__\n        extname = classname.replace('Flask', '').lower()\n        app.extensions[extname] = self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef context(self, key, method):\n        ctx = stack.top\n        if ctx is not None:\n            if not hasattr(ctx, key):\n                setattr(ctx, key, method())\n            return getattr(ctx, key)", "response": "A helper method to attach a value within a context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck cache for rendered html code. returns tuple of cachekey html", "response": "def checkCache(self, cachetype, relpath):\n        \"\"\"checks cache for rendered html code.\n        'cachetype' can be any string (usually the name of a method, e.g. \"Thumbnail\", or \"InTable\")\n        relpath is the relative path, here treated as boolean.\n        If cache is up-to-date, returns tuple of cachekey,html (NB: cachekey is path to cache file)\n        If cache is out of date, calls regenerate() if not already done so, and returns tuple of cachekey,None.\n        \"\"\"\n        cache_ext = self._cacheFileExtension(cachetype, relpath)\n        filename, path = self.subproductPath(cache_ext)\n        cachekey = path\n        # check already read cache\n        content = self.rendercache.get(path, None)\n        if content is not None:\n            return content\n        # if cache file is up-to-date, attempt to read content\n        if self.subproductUpToDate(path):\n            dprintf(3, \"render cache %s is up-to-date, reading in\\n\", path)\n            try:\n                content = open(path).read()\n            except:\n                print(\"Error reading render cache file\", path, \", will regenerate\")\n                traceback.print_exc()\n        else:\n            dprintf(3, \"render cache %s is out of date, will regenerate\\n\", path)\n        # read content? cache and return\n        if content is not None:\n            self.rendercache[path] = content\n            return path, content\n        # else regenerate\n        if not self._regenerated:\n            self.regenerate()\n            self._regenerated = True\n        # and return path,None to indicate no cache\n        return path, None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeCache(self, cachekey, content):\n        self.rendercache[cachekey] = content\n        try:\n            open(cachekey, 'w').write(content)\n        except:\n            print(\"Error writing cache file\", cachekey, \", will regenerate next time\")\n            traceback.print_exc()\n        return content", "response": "stores content in cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main_(*,\n          config: 'c' = 'config.yml',\n          debug: 'd' = False,\n          extra: ('e', str, parameters.multi()) = None,\n          optimistic = False,\n          quiet: 'q' = False,\n          vim_is_fucking_retarded: Parameter.UNDOCUMENTED = False):\n    \"\"\"\n    Run cms7.\n\n    config: Path to project configuration\n\n    debug: Print obnoxious debugging output\n\n    extra: Path to additional configuration (e.g. site local overrides). Can\n           be specified multiple times. Later configurations override.\n\n    optimistic: Try to continue processing after rendering errors\n\n    quiet: Only ever print warnings\n    \"\"\"\n\n    rl = logging.getLogger()\n    h = logging.StreamHandler()\n    try:\n        if not sys.stdin.isatty():\n            raise Exception\n        import colorlog\n        h.setFormatter(colorlog.ColoredFormatter(\n            \"%(log_color)s%(levelname)-8s%(reset)s %(message_log_color)s%(name)s:%(message)s\",\n            secondary_log_colors={\n                'message': {\n                    'WARNING':  'yellow',\n                    'ERROR':    'red',\n                    'CRITICAL': 'red',\n                }\n            }))\n    except:\n        h.setFormatter(logging.Formatter(\n            \"%(levelname)-8s %(name)s:%(message)s\"))\n    rl.addHandler(h)\n\n    if vim_is_fucking_retarded:\n        report_error.quiet = False\n\n    if debug:\n        rl.setLevel(logging.DEBUG)\n    elif quiet:\n        if vim_is_fucking_retarded:\n            rl.setLevel(logging.CRITICAL + 1)\n        else:\n            rl.setLevel(logging.WARNING)\n    else:\n        rl.setLevel(logging.INFO)\n\n    try:\n        cfg = _config.load(config, *extra)\n        if optimistic:\n            cfg.optimistic = True\n        gen = Generator(cfg)\n        for m in cfg.modules():\n            m.prepare()\n        for m in cfg.modules():\n            m.run(gen)\n        gen.run()\n        for r in cfg.resources:\n            r.run()\n    except CMS7Error as e:\n        logger.critical('%s', e.message, exc_info=debug)\n        if not debug:\n            logger.warning('exiting for exception. use --debug to get a traceback')\n        sys.exit(1)\n    except Exception:\n        logger.critical('unexpected exception', exc_info=True)\n        sys.exit(1)", "response": "Main function for cms7."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compile_theme(theme, target, *, zip_=False):\n    from jinja2 import Environment, FileSystemLoader\n    env = Environment(loader=FileSystemLoader(theme))\n    env.compile_templates(target, zip='deflated' if zip_ else None)", "response": "Compile a Jinja2 theme into a single file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsanitize the current settings.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the RFC and fix where possible\n        '''\n        # Check ports\n        if not isinstance(self.source_port, numbers.Integral) \\\n        or self.source_port < 0 \\\n        or self.source_port >= 2 ** 16:\n            raise ValueError('Invalid source port')\n\n        if not isinstance(self.destination_port, numbers.Integral) \\\n        or self.destination_port < 0 \\\n        or self.destination_port >= 2 ** 16:\n            raise ValueError('Invalid destination port')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_bytes(cls, bitstream):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the source and destination ports\n        (packet.source_port,\n         packet.destination_port) = bitstream.readlist('2*uint:16')\n\n        # Store the length\n        length = bitstream.read('uint:16')\n        if length < 8:\n            raise ValueError('Invalid UDP length')\n\n        # Read the checksum\n        packet.checksum = bitstream.read('uint:16')\n\n        # And the rest is payload\n        payload_bytes = length - 8\n        packet.payload = bitstream.read('bytes:%d' % payload_bytes)\n\n        # LISP-specific handling\n        if packet.source_port == 4341 or packet.destination_port == 4341:\n            # Payload is a LISP data packet\n            from pylisp.packet.lisp.data import DataPacket\n            packet.payload = DataPacket.from_bytes(packet.payload)\n        elif packet.source_port == 4342 or packet.destination_port == 4342:\n            # Payload is a LISP control message\n            from pylisp.packet.lisp.control.base import ControlMessage\n            packet.payload = ControlMessage.from_bytes(packet.payload)\n\n        # There should be no remaining bits\n        if bitstream.pos != bitstream.len:\n            raise ValueError('Bits remaining after processing packet')\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet", "response": "Parse the given packet and update properties accordingly\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate bytes from properties", "response": "def to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the source and destination ports\n        bitstream = BitStream('uint:16=%d, '\n                              'uint:16=%d' % (self.source_port,\n                                              self.destination_port))\n\n        # Write the length\n        payload_bytes = bytes(self.payload)\n        length = len(payload_bytes) + 8\n        bitstream += BitStream('uint:16=%d' % length)\n\n        # Write the checksum\n        bitstream += BitStream('uint:16=%d' % self.checksum)\n\n        return bitstream.bytes + payload_bytes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_shell(file_index, to_dir):\n    if not exists(to_dir):\n        makedirs(to_dir)\n\n    for _, file_data in file_index.files.items():\n        export_from_file(file_data, to_dir)", "response": "Export all shell commands from files in the file index into given directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking whether all calls contain a given parameters or their synonyms", "response": "def parameters_present(options, **kwargs):\n    \"\"\"\n    Analysis function\n    Check whether all calls contain a given parameters or their synonyms\n    \"\"\"\n    synonyms = options['synonyms']\n    call_graph = options['call_graph']\n\n    result = _Result()\n\n    for node, edges in call_graph:\n        for edge in edges:\n            call_config = edge.settings\n\n            for req_param, req_value in kwargs.items():\n                found = False\n\n                for param, value in call_config.items():\n                    if synonyms.are_synonyms(param, req_param):\n                        found = True\n                        break\n\n                if not found:\n                    result.add(node, edge, req_param)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall the given function in replay context so that no journal entries are created and no asynchronous task is started.", "response": "def replay(journal_entry, function, *args, **kwargs):\n    '''\n    Calls method in replay context so that no journal entries are created,\n    expected_side_effects are checked, and no asynchronous task is started.\n    The journal entry is only used to fetch side-effects results.\n    '''\n    # Starts the fiber section\n    section = fiber.WovenSection()\n    section.enter()\n\n    # Check if this is the first recording in the fiber section\n    journal_mode = section.state.get(RECMODE_TAG, None)\n    is_first = journal_mode is None\n\n    if is_first:\n        section.state[RECMODE_TAG] = JournalMode.replay\n        section.state[JOURNAL_ENTRY_TAG] = IJournalReplayEntry(journal_entry)\n\n    result = function(*args, **kwargs)\n\n    # We don't want anything asynchronous to be called,\n    # so we abort the fiber section\n    section.abort(result)\n    # side effects are returned in sake of making sure that\n    # all the side effects expected have been consumed (called)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recorded(function, custom_id=None, reentrant=True):\n    '''MUST only be used only with method from child\n    classes of L{{Recorder}}.'''\n    canonical = reflect.class_canonical_name(3)\n    annotate.injectClassCallback(\"recorded\", 4,\n                                 \"_register_recorded_call\",\n                                 function, custom_id=custom_id,\n                                 class_canonical_name=canonical)\n\n    def wrapper(self, *args, **kwargs):\n        recorder = IRecorder(self)\n        return recorder.call(function, args, kwargs, reentrant=reentrant)\n\n    return wrapper", "response": "MUST only be used with method from child\n    classes of L{{Recorder."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_effect(effect_id, *args, **kwargs):\n    '''If inside a side-effect, adds an effect to it.'''\n    effect = fiber.get_stack_var(SIDE_EFFECT_TAG)\n    if effect is None:\n        return False\n    effect.add_effect(effect_id, *args, **kwargs)\n    return True", "response": "If inside a side - effect adds an effect to it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_version(*args, **kwargs):\n    if 'caller_frame' not in kwargs:\n        kwargs['caller_frame'] = inspect.stack()[1][0]\n    return VersionFinder(*args, **kwargs).find_package_version()", "response": "Wrapper around VersionFinder. find_package_version method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tangle(*args, **kwargs):\n\n    class_attrs = {\n        \"_links\": [],\n        \"_dlinks\": [],\n        \"_derived\": {}\n    }\n\n    for value in args:\n        if isinstance(value, function):\n            # we'll just go ahead and assume this was made by `interact`\n            if hasattr(value, \"widget\") and hasattr(value.widget, \"children\"):\n                for child in value.widget.children:\n                    _link_widget(child.description, child, class_attrs)\n\n    for key, value in kwargs.items():\n        traitlet_cls = _get_primitive(value)\n        traitlet_args = [value]\n        traitlet_kwargs = {\n            \"sync\": True\n        }\n\n        handled = False\n\n        if traitlet_cls is not None:\n            pass\n        elif isinstance(value, list):\n            traitlet_cls = Any\n            traitlet_args = [value[0]]\n            class_attrs[\"{}_options\".format(key)] = Tuple(value, sync=True)\n        elif isinstance(value, Widget):\n            _link_widget(key, value, class_attrs)\n            handled = True\n        elif isinstance(value, tuple):\n            if isinstance(value[0], Widget):\n                widget, traitlet = value\n                widget_cls = widget.__class__\n                traitlet_args = []\n                traitlet_cls = getattr(widget_cls, traitlet).__class__\n                class_attrs[\"_links\"].append((key, value))\n            elif hasattr(value[1], \"__call__\"):\n                example, fn = value\n                traitlet_args = [example]\n                traitlet_cls = _get_primitive(example)\n\n                subscribed = inspect.getargspec(fn).args\n\n                class_attrs[\"_derived\"][key] = (fn, subscribed)\n\n        if not handled:\n            if traitlet_cls is None:\n                raise ValueError(\"Didn't understand {}: {}\".format(key, value))\n            class_attrs[key] = traitlet_cls(*traitlet_args, **traitlet_kwargs)\n\n    new_class = type(\n        'DynamicAutoTangle{}'.format(id(class_attrs)),\n        (AutoTangle,),\n        class_attrs\n    )\n\n    inst = new_class()\n    return inst._refresh()", "response": "Shortcut to create a new Tangle model. Use instead of directly - defined Tangle subclassing Tangle."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _EndRecData64(fpin, offset, endrec):\n    try:\n        fpin.seek(offset - sizeEndCentDir64Locator, 2)\n    except IOError:\n        # If the seek fails, the file is not large enough to contain a ZIP64\n        # end-of-archive record, so just return the end record we were given.\n        return endrec\n\n    data = fpin.read(sizeEndCentDir64Locator)\n    sig, diskno, reloff, disks = struct.unpack(structEndArchive64Locator, data)\n    if sig != stringEndArchive64Locator:\n        return endrec\n\n    if diskno != 0 or disks != 1:\n        raise BadZipfile(\"zipfiles that span multiple disks are not supported\")\n\n    # Assume no 'zip64 extensible data'\n    fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)\n    data = fpin.read(sizeEndCentDir64)\n    sig, sz, create_version, read_version, disk_num, disk_dir, \\\n            dircount, dircount2, dirsize, diroffset = \\\n            struct.unpack(structEndArchive64, data)\n    if sig != stringEndArchive64:\n        return endrec\n\n    # Update the original endrec using data from the ZIP64 record\n    endrec[_ECD_SIGNATURE] = sig\n    endrec[_ECD_DISK_NUMBER] = disk_num\n    endrec[_ECD_DISK_START] = disk_dir\n    endrec[_ECD_ENTRIES_THIS_DISK] = dircount\n    endrec[_ECD_ENTRIES_TOTAL] = dircount2\n    endrec[_ECD_SIZE] = dirsize\n    endrec[_ECD_OFFSET] = diroffset\n    return endrec", "response": "Read the ZIP64 end - of - archive record and update the endrec dict with the data from the ZIP64 record."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, n=-1):\n        buf = ''\n        if n is None:\n            n = -1\n        while True:\n            if n < 0:\n                data = self.read1(n)\n            elif n > len(buf):\n                data = self.read1(n - len(buf))\n            else:\n                return buf\n            if len(data) == 0:\n                return buf\n            buf += data", "response": "Read and return up to n bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read1(self, n):\n\n        # Simplify algorithm (branching) by transforming negative n to large n.\n        if n < 0 or n is None:\n            n = self.MAX_N\n\n        # Bytes available in read buffer.\n        len_readbuffer = len(self._readbuffer) - self._offset\n\n        # Read from file.\n        if self._compress_left > 0 and n > len_readbuffer + len(self._unconsumed):\n            nbytes = n - len_readbuffer - len(self._unconsumed)\n            nbytes = max(nbytes, self.MIN_READ_SIZE)\n            nbytes = min(nbytes, self._compress_left)\n\n            data = self._fileobj.read(nbytes)\n            self._compress_left -= len(data)\n\n            if data and self._decrypter is not None:\n                data = ''.join(map(self._decrypter, data))\n\n            if self._compress_type == ZIP_STORED:\n                self._update_crc(data, eof=(self._compress_left==0))\n                self._readbuffer = self._readbuffer[self._offset:] + data\n                self._offset = 0\n            else:\n                # Prepare deflated bytes for decompression.\n                self._unconsumed += data\n\n        # Handle unconsumed data.\n        if (len(self._unconsumed) > 0 and n > len_readbuffer and\n            self._compress_type == ZIP_DEFLATED):\n            data = self._decompressor.decompress(\n                self._unconsumed,\n                max(n - len_readbuffer, self.MIN_READ_SIZE)\n            )\n\n            self._unconsumed = self._decompressor.unconsumed_tail\n            eof = len(self._unconsumed) == 0 and self._compress_left == 0\n            if eof:\n                data += self._decompressor.flush()\n\n            self._update_crc(data, eof=eof)\n            self._readbuffer = self._readbuffer[self._offset:] + data\n            self._offset = 0\n\n        # Read from buffer.\n        data = self._readbuffer[self._offset: self._offset + n]\n        self._offset += len(data)\n        return data", "response": "Read up to n bytes with at most one read system call."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncloses the file and for mode w and a write the ending records.", "response": "def close(self):\n        \"\"\"Close the file, and for mode \"w\" and \"a\" write the ending\n        records.\"\"\"\n        if self.fp is None:\n            return\n\n        if self.mode in (\"w\", \"a\") and self._didModify: # write ending records\n            count = 0\n            pos1 = self.fp.tell()\n            for zinfo in self.filelist:         # write central directory\n                count = count + 1\n                dt = zinfo.date_time\n                dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]\n                dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)\n                extra = []\n                if zinfo.file_size > ZIP64_LIMIT \\\n                        or zinfo.compress_size > ZIP64_LIMIT:\n                    extra.append(zinfo.file_size)\n                    extra.append(zinfo.compress_size)\n                    file_size = 0xffffffff\n                    compress_size = 0xffffffff\n                else:\n                    file_size = zinfo.file_size\n                    compress_size = zinfo.compress_size\n\n                if zinfo.header_offset > ZIP64_LIMIT:\n                    extra.append(zinfo.header_offset)\n                    header_offset = 0xffffffff\n                else:\n                    header_offset = zinfo.header_offset\n\n                extra_data = zinfo.extra\n                if extra:\n                    # Append a ZIP64 field to the extra's\n                    extra_data = struct.pack(\n                            '<HH' + 'Q'*len(extra),\n                            1, 8*len(extra), *extra) + extra_data\n\n                    extract_version = max(45, zinfo.extract_version)\n                    create_version = max(45, zinfo.create_version)\n                else:\n                    extract_version = zinfo.extract_version\n                    create_version = zinfo.create_version\n\n                try:\n                    filename, flag_bits = zinfo._encodeFilenameFlags()\n                    centdir = struct.pack(structCentralDir,\n                     stringCentralDir, create_version,\n                     zinfo.create_system, extract_version, zinfo.reserved,\n                     flag_bits, zinfo.compress_type, dostime, dosdate,\n                     zinfo.CRC, compress_size, file_size,\n                     len(filename), len(extra_data), len(zinfo.comment),\n                     0, zinfo.internal_attr, zinfo.external_attr,\n                     header_offset)\n                except DeprecationWarning:\n                    print((structCentralDir,\n                     stringCentralDir, create_version,\n                     zinfo.create_system, extract_version, zinfo.reserved,\n                     zinfo.flag_bits, zinfo.compress_type, dostime, dosdate,\n                     zinfo.CRC, compress_size, file_size,\n                     len(zinfo.filename), len(extra_data), len(zinfo.comment),\n                     0, zinfo.internal_attr, zinfo.external_attr,\n                     header_offset), file=sys.stderr)\n                    raise\n                self.fp.write(centdir)\n                self.fp.write(filename)\n                self.fp.write(extra_data)\n                self.fp.write(zinfo.comment)\n\n            pos2 = self.fp.tell()\n            # Write end-of-zip-archive record\n            centDirCount = count\n            centDirSize = pos2 - pos1\n            centDirOffset = pos1\n            if (centDirCount >= ZIP_FILECOUNT_LIMIT or\n                centDirOffset > ZIP64_LIMIT or\n                centDirSize > ZIP64_LIMIT):\n                # Need to write the ZIP64 end-of-archive records\n                zip64endrec = struct.pack(\n                        structEndArchive64, stringEndArchive64,\n                        44, 45, 45, 0, 0, centDirCount, centDirCount,\n                        centDirSize, centDirOffset)\n                self.fp.write(zip64endrec)\n\n                zip64locrec = struct.pack(\n                        structEndArchive64Locator,\n                        stringEndArchive64Locator, 0, pos2, 1)\n                self.fp.write(zip64locrec)\n                centDirCount = min(centDirCount, 0xFFFF)\n                centDirSize = min(centDirSize, 0xFFFFFFFF)\n                centDirOffset = min(centDirOffset, 0xFFFFFFFF)\n\n            # check for valid comment length\n            if len(self.comment) >= ZIP_MAX_COMMENT:\n                if self.debug > 0:\n                    msg = 'Archive comment is too long; truncating to %d bytes' \\\n                          % ZIP_MAX_COMMENT\n                self.comment = self.comment[:ZIP_MAX_COMMENT]\n\n            endrec = struct.pack(structEndArchive, stringEndArchive,\n                                 0, 0, centDirCount, centDirCount,\n                                 centDirSize, centDirOffset, len(self.comment))\n            self.fp.write(endrec)\n            self.fp.write(self.comment)\n            self.fp.flush()\n\n        if not self._filePassed:\n            self.fp.close()\n        self.fp = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list of descriptions parsed from html tags and dublin core inlined in the HTML tags.", "response": "def get_annotation_tags(index_page):\n    \"\"\"\n    Return list of descriptions parsed from ``<meta>`` tags and dublin core\n    inlined in ``<meta>`` tags.\n\n    Args:\n        index_page (str): HTML content of the page you wisht to analyze.\n\n    Returns:\n        list: List of ``SourceString`` objects.\n    \"\"\"\n    dom = dhtmlparser.parseString(index_page)\n\n    descriptions = [\n        get_html_annotations(dom),\n        get_dc_annotations(dom),\n    ]\n\n    return sum(descriptions, [])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user(self, base_dn, samaccountname, attributes=(), explicit_membership_only=False):\n\n        users = self.users(base_dn, samaccountnames=[samaccountname],\n                           attributes=attributes, explicit_membership_only=explicit_membership_only)\n\n        try:\n            # Usually we will find a match, but perhaps not always\n            return users[0]\n        except IndexError:\n            logging.info(\"%s - unable to retrieve object from AD by sAMAccountName\", samaccountname)", "response": "Returns a single populated ADUser object for the given base DN and attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of ADUser objects for the users in the base DN.", "response": "def users(self, base_dn, samaccountnames=(), attributes=(), explicit_membership_only=False):\n        \"\"\"Gathers a list of ADUser objects\n\n        :param str base_dn: The base DN to search within\n        :param list attributes: Object attributes to populate, defaults to all\n        :param list samaccountnames: A list of usernames for which objects will be\n            created, defaults to all users if unspecified\n        :param bool explicit_membership_only: If set True, memberof will only\n            list groups for which users are directly referenced members\n\n        :return: A list of populated ADUser objects\n        :rtype: list\n        \"\"\"\n        ad_users = []\n\n        search_filter = '(&(objectClass=user)(!(objectClass=group))(!(objectClass=computer)){0})'\n        # If no samaccountnames specified, filter will pull all user objects under\n        # base_dn\n        if not samaccountnames:\n            search_filter = search_filter.format('(sAMAccountName=*)')\n        else:\n            # Extensible filter: http://bit.ly/1Qh4eyV\n            if len(samaccountnames) == 1:\n                account_names = '(sAMAccountName={0})'.format(samaccountnames[0])\n            else:\n                account_names = '(|{0})'.format(''.join(['(sAMAccountName={0})'.format(username) \\\n                                                for username in samaccountnames]))\n\n            search_filter = search_filter.format(account_names)\n\n\n        logging.debug('%s Search filter: %s', self.__class__.__name__, search_filter)\n\n        results = self.adq.search(base_dn, search_filter, attributes)\n\n        for search_result in results:\n            adu = self._object_factory(search_result)\n            # Each results index 0 of the tuple is the DN\n            if not explicit_membership_only and 'memberof' in dir(adu):\n                memberof = [g[0] for g in self.adq.search(base_dn,\n                                                          '(member:1.2.840.113556.1.4.1941:={0})'.\\\n                                                          format(search_result[0]),\n                                                          attributes=['memberof'])]\n                adu.memberof = memberof\n            ad_users.append(adu)\n\n\n        return ad_users"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines if the current user is a member of a specific group.", "response": "def is_member(self, group_distinguishedname):\n        \"\"\"For the current ADUser instance, determine if\n        the user is a member of a specific group (the group DN is used).\n        The result may not be accurate if explicit_membership_only was set to\n        True when the object factory method (user() or users()) was\n        called.\n\n        :param str group_distinguishedname: The group DistinguishedName\n\n        :return: A boolean indicating whether or not the user is a member of the group\n        :rtype: bool\n        \"\"\"\n        #pylint: disable=no-member\n        if group_distinguishedname.lower() in [dn.lower() for dn in self.memberof]:\n        #pylint: enable=no-member\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef group_samaccountnames(self, base_dn):\n        #pylint: disable=no-member\n        mappings = self.samaccountnames(base_dn, self.memberof)\n        #pylint: enable=no-member\n        groups = [samaccountname for samaccountname in mappings.values()]\n        if not groups:\n            logging.info(\"%s - unable to retrieve any groups for the current ADUser instance\",\n                         self.samaccountname)\n        return groups", "response": "Returns a list of sAMAccountNames for which the current ADUser instance is a member of and which the base DN is base_dn."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mutable(function):\n    '''Add the instance internal state as the second parameter\n    of the decorated function.'''\n\n    def wrapper(self, *args, **kwargs):\n        state = self._get_state()\n        return function(self, state, *args, **kwargs)\n\n    return wrapper", "response": "Decorator to add the instance internal state as the second parameter\n    of the decorated function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef immutable(function):\n    '''Add the instance internal state as the second parameter\n    of the decorated function.'''\n\n    def wrapper(self, *args, **kwargs):\n        state = freeze(self._get_state())\n        return function(self, state, *args, **kwargs)\n\n    return wrapper", "response": "Decorator to add the instance internal state as the second parameter\n    of the decorated function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef canonizePath(path):\n    return os.path.abspath(os.path.normpath(os.path.realpath(path)))", "response": "Returns the absolute normalized real path of something."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef signal(sig, action):\n    assert callable(action), (\"Second argument of signal() needs to be a \"\n                              \"callable, got %r instead\" % (action, ))\n    global _handlers\n    _install_handler(sig)\n\n    if action in _handlers[sig]:\n        log.debug('signal',\n                  \"Handler for signal %s already registered. %r\", sig, action)\n        return SIG_DFL\n    _handlers[sig][1].append(action)\n    return SIG_DFL", "response": "This method is used to register a handler for a signal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the global data and remove the handlers.", "response": "def reset():\n    \"\"\"\n    Clear global data and remove the handlers.\n    CAUSION! This method sets as a signal handlers the ones which it has\n    noticed on initialization time. If there has been another handler installed\n    on top of us it will get removed by this method call.\n    \"\"\"\n    global _handlers, python_signal\n    for sig, (previous, _) in _handlers.iteritems():\n        if not previous:\n            previous = SIG_DFL\n        python_signal.signal(sig, previous)\n    _handlers = dict()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef safe_mkdir(self, d):\n\n        if os.path.isfile(d):\n            raise FileExistsError(\n                \"Cannont create directory %s, a file by that name already exists.\" % d)\n\n        if os.path.isdir(d):\n            logger.warning(\"%s already exists, using existing directory.\", d)\n            return\n\n        os.makedirs(d)", "response": "Create a directory if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a file from a template if it doesn t already exist.", "response": "def mk_tmpl(self, path, tmpl, ctx, mode=None):\n        \"\"\"Create a file from a template if it doesn't already exist.\n        \"\"\"\n\n        path = os.path.abspath(path)\n\n        if os.path.isfile(path):\n            logger.warning(\"File %s already exists, not creating it.\", tmpl)\n\n        with open(path, 'w') as fd:\n            fd.write(\n                tmpl.format(**ctx)\n            )\n            if mode:\n                os.chmod(path, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_repo(self, name):\n\n        name = os.path.abspath(name)\n        logger.debug(\"create_repo %s\", name)\n\n        self.safe_mkdir(name)\n\n        udir = os.path.join(name, '_upkg')\n        self.safe_mkdir(udir)\n\n        ctx = {\n            'pkg_name': os.path.basename(name),\n        }\n\n        for t in TMPLS:\n            self.mk_tmpl(\n                os.path.join(udir, t['name']),\n                t['tmpl'],\n                ctx,\n                t.get('mode')\n            )", "response": "todo create_repo - create a repository of all the TMPLS that are in the TMPLS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nforcing recalculate all ImageCountField and UserImageCountField fields in object obj.", "response": "def force_recalculate(obj):\n    ''' Recalculate all ImageCountField and UserImageCountField fields\n        in object ``obj``. \n        \n        This should be used if auto-updating of these fields was disabled for\n        some reason.\n        \n        To disable auto-update when saving AttachedImage instance \n        (for example when you need to save a lot of images and want to \n        recalculate denormalised values only after all images are saved) use \n        this pattern::\n        \n            image = AttachedImage(...)\n            image.send_signal = False\n            image.save()\n\n    '''        \n    class Stub(object):\n        content_object = obj    \n    img = Stub()\n    image_saved.send(sender = obj.__class__, instance = img)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef until(self, condition, is_true=None, message=\"\"):\n\n        rv = None\n        last_exc = None\n        until = is_true or until_pred\n        start = self.clock.now\n\n        while not until(self.clock, self.end):\n            try:\n                rv = condition()\n            except (KeyboardInterrupt, SystemExit) as e:\n                raise e\n            except self.exceptions as e:\n                last_exc = sys.exc_info()\n\n            if isinstance(rv, bool) and not rv:\n                time.sleep(self.interval)\n                continue\n\n            if rv is not None:\n                return rv\n\n            self.clock.sleep(self.interval)\n\n        if message:\n            message = \" with message: %s\" % message\n\n        raise TimeoutException(\n            \"Timed out after %s seconds%s\" %\n            ((self.clock.now - start), message), cause=last_exc)", "response": "Repeatedly runs condition until the given time expires or the given predicate evaluates to true."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacking data to GZIP and write them to out.", "response": "def to_gzipped_file(data, out=None):\n    \"\"\"\n    Pack `data` to GZIP and write them to `out`. If `out` is not defined,\n    :mod:`stringio` is used.\n\n    Args:\n        data (obj): Any packable data (str / unicode / whatever).\n        out (file, default None): Optional opened file handler.\n\n    Returns:\n        obj: File handler with packed data seeked at the beginning.\n    \"\"\"\n    if not out:\n        out = StringIO.StringIO()\n\n    with gzip.GzipFile(fileobj=out, mode=\"w\") as f:\n        f.write(data)\n\n    out.seek(0)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gzipped(fn):\n    def gzipped_wrapper(*args, **kwargs):\n        accepted_encoding = request.get_header(\"Accept-Encoding\")\n\n        if not accepted_encoding or \"gzip\" not in accepted_encoding:\n            return fn(*args, **kwargs)\n\n        response.set_header(\"Content-Encoding\", \"gzip\")\n\n        return to_gzipped_file(fn(*args, **kwargs))\n\n    return gzipped_wrapper", "response": "Decorator used to pack data returned from Bottle function to GZIP."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning fn in template context or in other words add fn to template path manually.", "response": "def in_template_path(fn):\n    \"\"\"\n    Return `fn` in template context, or in other words add `fn` to template\n    path, so you don't need to write absolute path of `fn` in template\n    directory manually.\n\n    Args:\n        fn (str): Name of the file in template dir.\n\n    Return:\n        str: Absolute path to the file.\n    \"\"\"\n    return os.path.join(\n        os.path.abspath(os.path.dirname(__file__)),\n        \"../templates\",\n        fn,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nturn optional color string spec into an array.", "response": "def getcolor(spec):\n    \"\"\"\n    Turn optional color string spec into an array.\n    \"\"\"\n    if isinstance(spec, str):\n        from matplotlib import colors\n        return asarray(colors.hex2color(colors.cnames[spec]))\n    else:\n        return spec"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getcolors(spec, n, cmap=None, value=None):\n    if cmap is not None and spec is not None:\n        from matplotlib.colors import LinearSegmentedColormap\n        from matplotlib.cm import get_cmap\n        if isinstance(cmap, LinearSegmentedColormap):\n            return cmap(value)[:, 0:3]\n        if isinstance(cmap, str):\n            return get_cmap(cmap, n)(value)[:, 0:3]\n    if isinstance(spec, str):\n        return [getcolor(spec) for i in range(n)]\n    elif isinstance(spec, list) and isinstance(spec[0], str):\n        return [getcolor(s) for s in spec]\n    elif (isinstance(spec, list) or isinstance(spec, ndarray)) and asarray(spec).shape == (3,):\n        return [spec for i in range(n)]\n    else:\n        return spec", "response": "Turn list of color specs into list of arrays."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a base array from optional arguments.", "response": "def getbase(base=None, dims=None, extent=None, background=None):\n    \"\"\"\n    Construct a base array from optional arguments.\n    \"\"\"\n    if dims is not None:\n        extent = dims\n    if base is None and background is None:\n        return ones(tuple(extent) + (3,))\n    elif base is None and background is not None:\n        base = zeros(tuple(extent) + (3,))\n        for channel in range(3):\n            base[:, :, channel] = background[channel]\n        return base\n    elif base is not None and base.ndim < 3:\n        return tile(expand_dims(base, 2),[1, 1, 3])\n    else:\n        return base"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hull(self):\n        from scipy.spatial import ConvexHull\n        if len(self.coordinates) >= 4:\n            inds = ConvexHull(self.coordinates).vertices\n            return self.coordinates[inds]\n        else:\n            return self.coordinates", "response": "Returns the convex hull of the polygon."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the bounding box of the current object as a list of integers.", "response": "def bbox(self):\n        \"\"\"\n        Bounding box as minimum and maximum coordinates.\n        \"\"\"\n        mn = amin(self.coordinates, axis=0)\n        mx = amax(self.coordinates, axis=0)\n        return concatenate((mn, mx))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef distance(self, other):\n        from numpy.linalg import norm\n        if isinstance(other, one):\n            other = other.center\n        return norm(self.center - asarray(other), ord=2)", "response": "Distance between the center of this region and another."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge(self, other):\n        if not isinstance(other, one):\n            other = one(other)\n        new = concatenate((self.coordinates, other.coordinates))\n        unique = set([tuple(x) for x in new.tolist()])\n        final = asarray([list(x) for x in unique])\n        return one(final)", "response": "Combine this region with other."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncropping a region by removing coordinates outside bounds.", "response": "def crop(self, min, max):\n        \"\"\"\n        Crop a region by removing coordinates outside bounds.\n\n        Follows normal slice indexing conventions.\n\n        Parameters\n        ----------\n        min : tuple\n            Minimum or starting bounds for each axis.\n\n        max : tuple\n            Maximum or ending bounds for each axis.\n        \"\"\"\n        new = [c for c in self.coordinates if all(c >= min) and all(c < max)]\n        return one(new)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a region falls entirely inside bounds.", "response": "def inbounds(self, min, max):\n        \"\"\"\n        Check if a region falls entirely inside bounds.\n\n        Parameters\n        ----------\n        min : tuple\n            Minimum bound to check for each axis.\n\n        max : tuple\n            Maximum bound to check for each axis.\n        \"\"\"\n        mincheck = sum(self.coordinates >= min, axis=1) == 0\n        maxcheck = sum(self.coordinates < max, axis=1) == 0\n        return True if (mincheck.sum() + maxcheck.sum()) == 0 else False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef overlap(self, other, method='fraction'):\n        checkopts(method, ['fraction', 'rates'])\n\n        coords_self = self.coordinates.tolist()\n        coords_other = other.coordinates.tolist()\n\n        intersection = [a for a in coords_self if a in coords_other]\n        nhit = float(len(intersection))\n        ntotal = float(len(set([tuple(x) for x in coords_self] + \n            [tuple(x) for x in coords_other])))\n\n        if method == 'rates':\n            recall = nhit / len(coords_self)\n            precision = nhit / len(coords_other)\n            return recall, precision\n\n        if method == 'fraction':\n            return nhit / float(ntotal)", "response": "Compute the overlap between this region and another region."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dilate(self, size):\n        if size > 0:\n            from scipy.ndimage.morphology import binary_dilation\n            size = (size * 2) + 1\n            coords = self.coordinates\n            tmp = zeros(self.extent + size * 2)\n            coords = (coords - self.bbox[0:len(self.center)] + size)\n            tmp[coords.T.tolist()] = 1\n            tmp = binary_dilation(tmp, ones((size, size)))\n            new = asarray(where(tmp)).T + self.bbox[0:len(self.center)] - size\n            new = [c for c in new if all(c >= 0)]\n        else:\n            return self\n        \n        return one(new)", "response": "Dilate a region using morphological operators."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exclude(self, other):\n        if isinstance(other, list) or isinstance(other, ndarray):\n            other = asarray(other)\n            coords_other = asarray(where(other)).T.tolist()\n        else:\n            coords_other = other.coordinates.tolist()\n\n        coords_self = self.coordinates.tolist()\n\n        complement = [a for a in coords_self if a not in coords_other]\n\n        return one(complement)", "response": "Returns a new region with only the elements in self that are not in other."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing region outline by differencing two dilations.", "response": "def outline(self, inner, outer):\n        \"\"\"\n        Compute region outline by differencing two dilations.\n\n        Parameters\n        ----------\n        inner : int\n            Size of inner outline boundary (in pixels)\n\n        outer : int\n            Size of outer outline boundary (in pixels)\n        \"\"\"\n        return self.dilate(outer).exclude(self.dilate(inner))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mask(self, dims=None, base=None, fill='deeppink', stroke='black', background=None):\n        fill = getcolor(fill)\n        stroke = getcolor(stroke)\n        background = getcolor(background)\n\n        if dims is None and base is None:\n            region = one(self.coordinates - self.bbox[0:2])\n        else:\n            region = self\n\n        base = getbase(base=base, dims=dims, extent=self.extent, background=background)\n\n        if fill is not None:\n            for channel in range(3):\n                inds = asarray([[c[0], c[1], channel] for c in region.coordinates])\n                base[inds.T.tolist()] = fill[channel]\n\n        if stroke is not None:\n            mn = [0, 0]\n            mx = [base.shape[0], base.shape[1]]\n            edge = region.outline(0, 1).coordinates\n            edge = [e for e in edge if all(e >= mn) and all(e < mx)]\n            if len(edge) > 0:\n                for channel in range(3):\n                    inds = asarray([[c[0], c[1], channel] for c in edge])\n                    base[inds.T.tolist()] = stroke[channel]\n\n        return base", "response": "Create a mask image with colored regions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a mask image with colored regions.", "response": "def mask(self, dims=None, base=None, fill='deeppink', stroke='black', background=None, \n             cmap=None, cmap_stroke=None, value=None):\n        \"\"\"\n        Create a mask image with colored regions.\n\n        Parameters\n        ----------\n        dims : tuple, optional, default = None\n            Dimensions of embedding image,\n            will be ignored if background image is provided.\n\n        base : array-like, optional, default = None\n            Array to use as base image, can be 2d (BW) or 3d (RGB).\n\n        fill : str or array-like, optional, default = 'pink'\n            String color specifier, or RGB values,\n            or a list of either.\n\n        stroke : str or array-like, optional, default = None\n            String color specifier, or RGB values,\n            or a list of either.\n\n        background : str or array-like, optional, default = None\n            String color specifier, or RGB values.\n\n        cmap : str or colormap, optional, deafult = None\n            String specifier for colormap, or colormap. Will control\n            both fill and stroke. Use cmap_stroke to\n            set stroke independently.\n\n        cmap_stroke : str or colormap, optional, deafult = None\n            String specifier for colormap, or colormap, for stroke only.\n\n        value : array-like, optional, default = None\n            Value per region for use with colormap.\n            If None and cmap is specified, will use the range\n            from 0 to the number of regions.\n        \"\"\"\n        if (cmap is not None or cmap_stroke is not None) and value is None:\n            value = arange(self.count)\n        background = getcolor(background)\n        stroke = getcolors(stroke, self.count, cmap_stroke, value)\n        fill = getcolors(fill, self.count, cmap, value)\n\n        minbound = asarray([b[0:2] for b in self.bbox]).min(axis=0)\n        maxbound = asarray([b[2:] for b in self.bbox]).max(axis=0)\n        extent = maxbound - minbound + 1\n\n        if dims is None and base is None:\n            regions = [one(r.coordinates - minbound) for r in self.regions]\n        else:\n            regions = self.regions\n\n        base = getbase(base=base, dims=dims, extent=extent, background=background)\n\n        for i, r in enumerate(regions):\n            f = fill[i] if fill is not None else None\n            s = stroke[i] if stroke is not None else None\n            base = r.mask(base=base, fill=f, stroke=s)\n\n        return base"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_placeholder_dropdown(cls, input_el):\n        text = cls.get_placeholder_text(input_el)\n        cls.set_placeholder_text(\n            input_el=input_el,\n            text=text + cls._dropdown_text\n        )", "response": "Set the element to show the multiple choice text."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_placeholder_dropdown(cls, input_el):\n        text = cls.get_placeholder_text(input_el)\n        cls.set_placeholder_text(\n            input_el=input_el,\n            text=text.replace(cls._dropdown_text, \"\")\n        )", "response": "Reset the element to default."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of renderer ids giving the renderers that support the source file type", "response": "def getRenderers(filename):\n    \"\"\"For a given DP, returns a list of renderer ids giving\n    the renderers that support the source file type\"\"\"\n    global available_renderers\n    renderers = []\n    for rdrid, (renderer, module) in available_renderers.items():\n        try:\n            priority = renderer.canRender(filename)\n        except:\n            print(\"\"\"Error in renderer: %s.canRender(\"%s\"):\"\"\" % (rdrid, filename))\n            traceback.print_exc()\n            priority = None\n        if priority:\n            renderers.append((priority, rdrid))\n    # sort by priority\n    renderers.sort(lambda a, b: cmp(a[0], b[0]))\n    # return list of IDs. Note that \"none\" should always be available and working\n    return [a[1] for a in renderers] or [\"link\"]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef makeRenderer(rdrid, dp, refresh=False):\n    try:\n        return available_renderers[rdrid][0](dp, refresh=refresh)\n    except:\n        print(\"\"\"Error creating renderer %s for %s:\"\"\" % (rdrid, dp.fullpath))\n        traceback.print_exc()\n        return DefaultRenderer(dp)", "response": "Creates a renderer object with the given rdrid and attaches it to the given DP."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subproductPath(self, ext):\n        ext = ext.lstrip(\"-\")\n        basename = os.path.join(os.path.basename(self.dp.subproduct_dir()), ext)\n        fullpath = os.path.join(self.dp.subproduct_dir(), ext)\n        return basename, fullpath", "response": "Makes a subproduct filename by appending ext to the subproduct directory. Returns a tuple containing the basename and fullpath of the subproduct directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the path is up - to - date w. r. t. our data product.", "response": "def subproductUpToDate(self, fpath):\n        \"\"\"Returns True if the path is up-to-date w.r.t. our data product: i.e. exists, and is no older\n        than the DP itself, or the module itself (the last check ensures that subproducts are remade\n        if the rendering code changes.)\"\"\"\n        # subproduct is up-to-date if it is older than the file mtime\n        if not os.path.exists(self.dp.subproduct_dir()):\n            os.mkdir(self.dp.subproduct_dir())\n        ## This caused many re-rendering whenever a plugin got recompiled, so I disabled it.\n        ## Need to add a control for re-rendering.\n        ##    if os.path.exists(fpath) and os.path.getmtime(fpath) >= max(self.file_mtime,self.module_mtime):\n        if os.path.exists(fpath) and os.path.getmtime(fpath) >= self.file_mtime:\n            dprintf(3, \"subproduct %s is up-to-date, no need to regenerate\\n\", fpath)\n            return True\n        else:\n            if not os.path.exists(fpath):\n                dprintf(3, \"subproduct %s does not yet exist, will generate\\n\", fpath)\n            else:\n                dprintf(4, \"subproduct %s is out of date (timestamp %s, file %s, module %s), will regenerate\\n\", fpath,\n                        time.strftime(\"%x %X\", time.localtime(os.path.getmtime(fpath))),\n                        time.strftime(\"%x %X\", time.localtime(self.file_mtime)),\n                        time.strftime(\"%x %X\", time.localtime(self.module_mtime)))\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a subproduct filename by calling subproductPath then calls subproductUpToDate to determine if it is up - to - date. Returns tuple of basename path uptime", "response": "def subproduct(self, ext):\n        \"\"\"Makes a subproduct filename by calling subproductPath(), then calls\n        subproductUpToDate() to determine if it is up-to-date.\n        Returns tuple of basename,path,uptodate\n        \"\"\"\n        fname, fpath = self.subproductPath(ext)\n        return fname, fpath, self.subproductUpToDate(fpath)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a renderer option named name with the given default value.", "response": "def addOption(classobj, name, default, dtype=str, doc=None):\n        \"\"\"Adds a renderer option named 'name', with the given default value.\n        'dtype' must be a callable to convert a string to an option.\n        'doc' is a doc string.\n        Options will be initialized from config file here.\n        \"\"\"\n        # make a config object\n        if not hasattr(classobj, '_config'):\n            classobj._config = Kittens.config.SectionParser(ConfigFile, \"render-\" + classobj.renderer_id)\n        # make a class-specific copy of the current option set\n        if classobj._options_owner is not classobj:\n            classobj.options = dict(DefaultRenderer.options)\n            classobj._options_owner = classobj\n        # overrid default value from config file\n        if dtype is bool:\n            value = classobj._config.getbool(name, default)\n        else:\n            value = dtype(classobj._config.get(name, default))\n        # insert into dict\n        classobj.options[name] = (value, default, dtype, doc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef renderLinkComment(self, relpath=\"\"):\n        items = []\n        link = self.renderLink(relpath) or \"\"\n        if link:\n            items.append(link)\n        comment = self.dp.comment or \"\"\n        if comment:\n            comment = comment.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n            items.append(comment)\n        if items:\n            return \"<P>\" + \": \".join((items)) + \"</P>\"\n        else:\n            return \"\"", "response": "Render the link comment as a separate paragraph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender a data product in a table in three table cells.", "response": "def renderInTable(self, relpath=\"\"):\n        \"\"\"renderInTable() is called to render a data product in a table\n        relpath is as for renderLink() above.\n        Return value should be empty, or a valid HTML string (usually delimited by <TR></TR> tags).\n        Default implementation renders thumbnail,comment and link in three table cells.\"\"\"\n        thumb = self.renderThumbnail(relpath) or \"\"\n        comment = self.renderLinkComment(relpath) or \"\"\n        if thumb:\n            return \"\\n\".join(\n                [\"    <TR>\"] +\n                [\"      <TD>%s</TD>\" % element for element in (thumb, comment)] +\n                [\"    </TR>\\n\"])\n        else:\n            return \"\"\"\n        <TR><TD COLSPAN=2>%s</TD></TR>\\n\"\"\" % comment"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new : class : ScheduledAnalysis on the server.", "response": "def create(cls, analysis_system_instance, sample):\n        \"\"\"\n        Create a new :class:`ScheduledAnalysis` on the server.\n\n        For convenience\n        :func:`~mass_api_client.resources.analysis_system_instance.AnalysisSystemInstance.schedule_analysis`\n        of class :class:`.AnalysisSystemInstance` can be used instead.\n\n        :param analysis_system_instance: The :class:`.AnalysisSystemInstance` for which the sample should be scheduled.\n        :param sample: The class:`.Sample` object to be scheduled.\n        :return: The created :class:`ScheduledAnalysis` object.\n        \"\"\"\n        return cls._create(analysis_system_instance=analysis_system_instance.url, sample=sample.url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a report object and remove the ScheduledAnalysis from the server.", "response": "def create_report(self, additional_metadata=None, json_report_objects=None, raw_report_objects=None, tags=None, analysis_date=None):\n        \"\"\"\n        Create a :class:`.Report` and remove the :class:`ScheduledAnalysis` from the server.\n\n        :param additional_metadata: A dictionary of additional metadata.\n        :param json_report_objects: A dictionary of JSON reports, where the key is the object name.\n        :param raw_report_objects: A dictionary of binary file reports, where the key is the file name.\n        :param tags: A list of strings.\n        :param analysis_date: :py:mod:`datetime` object of the time the report was generated. Defaults to current time.\n        :return: The created :class:`.Report` object.\n        \"\"\"\n        return Report.create(self, json_report_objects=json_report_objects, raw_report_objects=raw_report_objects, additional_metadata=additional_metadata, tags=tags, analysis_date=analysis_date)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sample(self):\n        sample_url = self.sample\n        sample = Sample._get_detail_from_url(sample_url, append_base_url=False)\n        return sample", "response": "Retrieve the scheduled : class :. Sample object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef simple_getter(queryset, object_regex=None, lookup_field=None):\n    ''' Returns simple object_getter function for use with PluggableSite.\n    It takes 'queryset' with QuerySet or Model instance, 'object_regex' with\n    url regex and 'lookup_field' with lookup field.\n    '''\n    object_regex = object_regex or r'\\d+'\n    lookup_field = lookup_field or 'pk'\n\n    if isinstance(queryset, models.Model):\n        qs = queryset._default_manager.all()\n    elif isinstance(queryset, QuerySet) or isinstance(queryset, models.Manager):\n        qs = queryset\n\n    def object_getter(object_id):\n        return qs.get(**{lookup_field: object_id})\n    object_getter.regex = \"(?P<object_id>%s)\" % object_regex\n\n    return object_getter", "response": "Returns a simple object_getter function for use with PluggableSite.\n    It takes a queryset with object_regex with object_id regex and lookup_field with lookup field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreverse an url taking self. app_name in account", "response": "def reverse(self, url, args=None, kwargs=None):\n        ''' Reverse an url taking self.app_name in account '''\n        return reverse(\"%s:%s\" % (self.instance_name, url,),\n                        args=args,\n                        kwargs=kwargs,\n                        current_app = self.app_name)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_regex(self, url):\n        '''\n            Make regex string for ``PluggableSite`` urlpatterns: prepend url\n            with parent object's url and app name.\n\n            See also: http://code.djangoproject.com/ticket/11559.\n        '''\n        return r\"^%s/%s%s$\" % (self.object_getter.regex, self.app_name, url)", "response": "Make regex string for PluggableSite urlpatterns"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_comp_by_target(self, target):\n        '''Finds a component using a TargetComponent or one of its subclasses.\n\n        @param A @ref TargetComponent object or subclass of @ref\n        TargetComponent.\n        @return A Component object matching the target.\n        @raises MissingComponentError\n\n        '''\n        for comp in self._components:\n            if comp.id == target.component_id and \\\n                    comp.instance_name == target.instance_name:\n                return comp\n        raise MissingComponentError", "response": "Finds a component using a TargetComponent or one of its subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all data connections in which one or more components are not required.", "response": "def optional_data_connections(self):\n        '''Finds all data connections in which one or more components are not\n        required.\n\n        If all the components involved in a connection are required, that\n        connection is also required. If one or more are not required, that\n        connection is optional.\n\n        Example:\n        >>> s = RtsProfile(xml_spec=open('test/rtsystem.xml').read())\n        >>> len(s.optional_data_connections())\n        0\n        '''\n        result = []\n        for conn in self._data_port_connectors:\n            source_comp = self.find_comp_by_target(conn.source_data_port)\n            target_comp = self.find_comp_by_target(conn.target_data_port)\n            if not source_comp.is_required or not target_comp.is_required:\n                result.append(conn)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all optional service connections in which one or more components are not required.", "response": "def optional_service_connections(self):\n        '''Finds all service connections in which one or more components are\n        not required.\n\n        If all the components involved in a connection are required, that\n        connection is also required. If one or more are not required, that\n        connection is optional.\n\n        Example:\n        >>> s = RtsProfile(xml_spec=open('test/rtsystem.xml').read())\n        >>> len(s.optional_service_connections())\n        0\n        '''\n        result = []\n        for conn in self._service_port_connectors:\n            source_comp = self.find_comp_by_target(conn.source_service_port)\n            target_comp = self.find_comp_by_target(conn.target_service_port)\n            if not source_comp.is_required or not target_comp.is_required:\n                result.append(conn)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a string or file containing an XML specification.", "response": "def parse_from_xml(self, xml_spec):\n        '''Parse a string or file containing an XML specification.\n\n        Example:\n        >>> s = RtsProfile()\n        >>> s.parse_from_xml(open('test/rtsystem.xml'))\n        >>> len(s.components)\n        3\n\n        Load of invalid data should throw exception:\n        >>> s.parse_from_xml('non-XML string')\n        Traceback (most recent call last):\n        ...\n        ExpatError: syntax error: line 1, column 0\n        '''\n        if type(xml_spec) in string_types():\n            dom = xml.dom.minidom.parseString(xml_spec)\n        else:\n            dom = xml.dom.minidom.parse(xml_spec)\n        self._parse_xml(dom)\n        dom.unlink()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef help(self):\n        '''Prints exposed methods and their docstrings.'''\n        cmds = self.get_exposed_cmds()\n        t = text_helper.Table(fields=['command', 'doc'],\n                              lengths=[50, 85])\n        return t.render((reflect.formatted_function_name(x), x.__doc__, )\n                        for x in cmds.values())", "response": "Prints exposed methods and their docstrings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit the text with function arguments into the array with first class citizens separated. See the unit tests for clarificatin.", "response": "def split(self, text):\n        '''\n        Splits the text with function arguments into the array with first\n        class citizens separated. See the unit tests for clarificatin.\n        '''\n        # nesting character -> count\n        counters = {\"'\": False, '(': 0}\n\n        def reverse(char):\n\n            def wrapped():\n                counters[char] = not counters[char]\n            return wrapped\n\n        def increase(char):\n\n            def wrapped():\n                counters[char] += 1\n            return wrapped\n\n        def decrease(char):\n\n            def wrapped():\n                counters[char] -= 1\n            return wrapped\n\n        def is_top_level():\n            return all([not x for x in counters.values()])\n\n        def fail():\n            raise BadSyntax('Syntax error processing line: %s' %\\\n                            self._last_line)\n\n\n        temp = \"\"\n        # end of field flag indicates that we expect next character to be\n        # either whitespace of split\n        eof_flag = False\n\n        def append_char(temp, char):\n            if eof_flag:\n                fail()\n            temp += char\n            return temp\n\n        # dictionary char -> handler\n        nesters = {\"'\": reverse(\"'\"), \"(\": increase('('), \")\": decrease('(')}\n        # chars to split on\n        split = (',', )\n        # chars to swallow\n        consume = (' ', '\\n')\n\n        result = list()\n\n        self.log(\"spliting: %s\", text)\n\n        for char in text:\n            if char in nesters:\n                nesters[char]()\n                temp = append_char(temp, char)\n            elif not is_top_level():\n                temp = append_char(temp, char)\n            elif char in consume:\n                if len(temp) > 0:\n                    eof_flag = True\n                continue\n            elif char in split:\n                result.append(temp)\n                temp = \"\"\n                eof_flag = False\n            else:\n                temp = append_char(temp, char)\n        if len(temp) > 0:\n            result.append(temp)\n\n        if not is_top_level():\n            fail()\n        self.log('Split returns %r', result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_result(self, (result_array, result_keywords, )):\n        '''\n        Check that the result is a list with a single element, and return it.\n        If we had more than one element it would mean that the line processed\n        looked somewhat like this:\n        call1(), \"blah blah blah\"\n        '''\n        if len(result_array) != 1 or len(result_keywords) > 0:\n            raise BadSyntax('Syntax error processing line: %s' %\\\n                            self._last_line)\n        return result_array[0]", "response": "Validate the result of a command."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign a local variable to the current object.", "response": "def set_local(self, value, variable_name):\n        '''\n        Assign local variable. The line processed looked somewhat like this:\n        variable = some_call()\n        '''\n        self.log('assigning %s = %r', variable_name, value)\n        self._locals[variable_name] = value\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_local(self, variable_name):\n        '''\n        Return the value of the local variable. Raises UnknownVariable is\n        the name is not known.\n        '''\n        if variable_name not in self._locals:\n            raise UnknownVariable('Unknown variable %s' % variable_name)\n        return self._locals[variable_name]", "response": "Returns the value of the local variable with the given name. Raises UnknownVariable is the name is not known."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate urls from base path and additional parts.", "response": "def join_path(base, *parts: str):\n    \"\"\"Creates urls from base path and additional parts.\"\"\"\n    _parts = \"/\".join((_part.strip(\"/\") for _part in parts))\n    # _parts = '/'.join(parts)\n    if base.endswith(\"/\"):\n        url = base + _parts\n    else:\n        url = base + \"/\" + _parts\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the index of the first tabs in the line.", "response": "def tabs_obsolete(physical_line):\n    \"\"\"\n    For new projects, spaces-only are strongly recommended over tabs.  Most\n    editors have features that make this easy to do.\n    \"\"\"\n    indent = indent_match(physical_line).group(1)\n    if indent.count('\\t'):\n        return indent.index('\\t'), \"W191 indentation contains tabs\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blank_lines(logical_line, blank_lines, indent_level, line_number,\n                previous_logical):\n    \"\"\"\n    Separate top-level function and class definitions with two blank lines.\n\n    Method definitions inside a class are separated by a single blank line.\n\n    Extra blank lines may be used (sparingly) to separate groups of related\n    functions.  Blank lines may be omitted between a bunch of related\n    one-liners (e.g. a set of dummy implementations).\n\n    Use blank lines in functions, sparingly, to indicate logical sections.\n    \"\"\"\n    if line_number == 1:\n        return # Don't expect blank lines before the first line\n    if previous_logical.startswith('@'):\n        return # Don't expect blank lines after function decorator\n    if (logical_line.startswith('def ') or\n        logical_line.startswith('class ') or\n        logical_line.startswith('@')):\n        if indent_level > 0 and blank_lines != 1:\n            return 0, \"E301 expected 1 blank line, found %d\" % blank_lines\n        if indent_level == 0 and blank_lines != 2:\n            return 0, \"E302 expected 2 blank lines, found %d\" % blank_lines\n    if blank_lines > 2:\n        return 0, \"E303 too many blank lines (%d)\" % blank_lines", "response": "Return 0 if the given line number is not blank."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\navoid extraneous whitespace in the following situations.", "response": "def extraneous_whitespace(logical_line):\n    \"\"\"\n    Avoid extraneous whitespace in the following situations:\n\n    - Immediately inside parentheses, brackets or braces.\n\n    - Immediately before a comma, semicolon, or colon.\n    \"\"\"\n    line = logical_line\n    for char in '([{':\n        found = line.find(char + ' ')\n        if found > -1:\n            return found + 1, \"E201 whitespace after '%s'\" % char\n    for char in '}])':\n        found = line.find(' ' + char)\n        if found > -1 and line[found - 1] != ',':\n            return found, \"E202 whitespace before '%s'\" % char\n    for char in ',;:':\n        found = line.find(' ' + char)\n        if found > -1:\n            return found, \"E203 whitespace before '%s'\" % char"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse 4 spaces per indentation level. For really old code that you don't want to mess up, you can continue to use 8-space tabs.", "response": "def indentation(logical_line, previous_logical, indent_char,\n                indent_level, previous_indent_level):\n    \"\"\"\n    Use 4 spaces per indentation level.\n\n    For really old code that you don't want to mess up, you can continue to\n    use 8-space tabs.\n    \"\"\"\n    if indent_char == ' ' and indent_level % 4:\n        return 0, \"E111 indentation is not a multiple of four\"\n    indent_expect = previous_logical.endswith(':')\n    if indent_expect and indent_level <= previous_indent_level:\n        return 0, \"E112 expected an indented block\"\n    if indent_level > previous_indent_level and not indent_expect:\n        return 0, \"E113 unexpected indentation\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef whitespace_around_operator(logical_line):\n    line = logical_line\n    for operator in operators:\n        found = line.find('  ' + operator)\n        if found > -1:\n            return found, \"E221 multiple spaces before operator\"\n        found = line.find(operator + '  ')\n        if found > -1:\n            return found, \"E222 multiple spaces after operator\"\n        found = line.find('\\t' + operator)\n        if found > -1:\n            return found, \"E223 tab before operator\"\n        found = line.find(operator + '\\t')\n        if found > -1:\n            return found, \"E224 tab after operator\"", "response": "Avoids extraneous whitespace around an assignment operator to\n      align it with another."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\navoid extraneous whitespace around a comma.", "response": "def whitespace_around_comma(logical_line):\n    \"\"\"\n    Avoid extraneous whitespace in the following situations:\n\n    - More than one space around an assignment (or other) operator to\n      align it with another.\n\n    JCR: This should also be applied around comma etc.\n    \"\"\"\n    line = logical_line\n    for separator in ',;:':\n        found = line.find(separator + '  ')\n        if found > -1:\n            return found + 1, \"E241 multiple spaces after '%s'\" % separator\n        found = line.find(separator + '\\t')\n        if found > -1:\n            return found + 1, \"E242 tab after '%s'\" % separator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompounding statements on the same line are generally discouraged.", "response": "def compound_statements(logical_line):\n    \"\"\"\n    Compound statements (multiple statements on the same line) are\n    generally discouraged.\n    \"\"\"\n    line = logical_line\n    found = line.find(':')\n    if -1 < found < len(line) - 1:\n        before = line[:found]\n        if (before.count('{') <= before.count('}') and # {'a': 1} (dict)\n            before.count('[') <= before.count(']') and # [1:2] (slice)\n            not re.search(r'\\blambda\\b', before)):     # lambda x: x\n            return found, \"E701 multiple statements on one line (colon)\"\n    found = line.find(';')\n    if -1 < found:\n        return found, \"E702 multiple statements on one line (semicolon)\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexpanding the amount of indentation.", "response": "def expand_indent(line):\n    \"\"\"\n    Return the amount of indentation.\n    Tabs are expanded to the next multiple of 8.\n\n    >>> expand_indent('    ')\n    4\n    >>> expand_indent('\\\\t')\n    8\n    >>> expand_indent('    \\\\t')\n    8\n    >>> expand_indent('       \\\\t')\n    8\n    >>> expand_indent('        \\\\t')\n    16\n    \"\"\"\n    result = 0\n    for char in line:\n        if char == '\\t':\n            result = result / 8 * 8 + 8\n        elif char == ' ':\n            result += 1\n        else:\n            break\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds all globally visible functions where the first argument name starts with argument_name.", "response": "def find_checks(argument_name):\n    \"\"\"\n    Find all globally visible functions where the first argument name\n    starts with argument_name.\n    \"\"\"\n    checks = []\n    function_type = type(find_checks)\n    for name, function in globals().iteritems():\n        if type(function) is function_type:\n            args = inspect.getargspec(function)[0]\n            if len(args) >= 1 and args[0].startswith(argument_name):\n                checks.append((name, function, args))\n    checks.sort()\n    return checks"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mute_string(text):\n    start = 1\n    end = len(text) - 1\n    # String modifiers (e.g. u or r)\n    if text.endswith('\"'):\n        start += text.index('\"')\n    elif text.endswith(\"'\"):\n        start += text.index(\"'\")\n    # Triple quotes\n    if text.endswith('\"\"\"') or text.endswith(\"'''\"):\n        start += 2\n        end -= 2\n    return text[:start] + 'x' * (end - start) + text[end:]", "response": "Mute a string in the alphabetical order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef input_file(filename):\n    if excluded(filename) or not filename_match(filename):\n        return {}\n    if options.verbose:\n        message('checking ' + filename)\n    options.counters['files'] = options.counters.get('files', 0) + 1\n    errors = Checker(filename).check_all()\n    if options.testsuite and not errors:\n        message(\"%s: %s\" % (filename, \"no errors found\"))\n    return errors", "response": "Run all checks on a Python source file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef input_dir(dirname):\n    dirname = dirname.rstrip('/')\n    if excluded(dirname):\n        return 0\n    errors = 0\n    for root, dirs, files in os.walk(dirname):\n        if options.verbose:\n            message('directory ' + root)\n        options.counters['directories'] = \\\n            options.counters.get('directories', 0) + 1\n        dirs.sort()\n        for subdir in dirs:\n            if excluded(subdir):\n                dirs.remove(subdir)\n        files.sort()\n        for filename in files:\n            errors += input_file(os.path.join(root, filename))\n    return errors", "response": "Check all Python source files in this directory and all subdirectories."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if filename is excluded by options. exclude", "response": "def excluded(filename):\n    \"\"\"\n    Check if options.exclude contains a pattern that matches filename.\n    \"\"\"\n    basename = os.path.basename(filename)\n    for pattern in options.exclude:\n        if fnmatch(basename, pattern):\n            # print basename, 'excluded because it matches', pattern\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filename_match(filename):\n    if not options.filename:\n        return True\n    for pattern in options.filename:\n        if fnmatch(filename, pattern):\n            return True", "response": "Check if options. filename contains a pattern that matches filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget statistics for all the message codes that start with the prefix.", "response": "def get_statistics(prefix=''):\n    \"\"\"\n    Get statistics for message codes that start with the prefix.\n\n    prefix='' matches all errors and warnings\n    prefix='E' matches all errors\n    prefix='W' matches all warnings\n    prefix='E4' matches all errors that have to do with imports\n    \"\"\"\n    stats = []\n    keys = options.messages.keys()\n    keys.sort()\n    for key in keys:\n        if key.startswith(prefix):\n            stats.append('%-7s %s %s' %\n                         (options.counters[key], key, options.messages[key]))\n    return stats"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_options(arglist=None):\n    global options, args\n    usage = \"%prog [options] input ...\"\n    parser = OptionParser(usage)\n    parser.add_option('-v', '--verbose', default=0, action='count',\n                      help=\"print status messages, or debug with -vv\")\n    parser.add_option('-q', '--quiet', default=0, action='count',\n                      help=\"report only file names, or nothing with -qq\")\n    parser.add_option('--exclude', metavar='patterns', default=default_exclude,\n                      help=\"skip matches (default %s)\" % default_exclude)\n    parser.add_option('--filename', metavar='patterns',\n                      help=\"only check matching files (e.g. *.py)\")\n    parser.add_option('--ignore', metavar='errors', default='',\n                      help=\"skip errors and warnings (e.g. E4,W)\")\n    parser.add_option('--repeat', action='store_true',\n                      help=\"show all occurrences of the same error\")\n    parser.add_option('--show-source', action='store_true',\n                      help=\"show source code for each error\")\n    parser.add_option('--show-pep8', action='store_true',\n                      help=\"show text of PEP 8 for each error\")\n    parser.add_option('--statistics', action='store_true',\n                      help=\"count errors and warnings\")\n    parser.add_option('--benchmark', action='store_true',\n                      help=\"measure processing speed\")\n    parser.add_option('--testsuite', metavar='dir',\n                      help=\"run regression tests from dir\")\n    parser.add_option('--doctest', action='store_true',\n                      help=\"run doctest on myself\")\n    options, args = parser.parse_args(arglist)\n    if options.testsuite:\n        args.append(options.testsuite)\n    if len(args) == 0:\n        parser.error('input not specified')\n    options.prog = os.path.basename(sys.argv[0])\n    options.exclude = options.exclude.split(',')\n    for index in range(len(options.exclude)):\n        options.exclude[index] = options.exclude[index].rstrip('/')\n    if options.filename:\n        options.filename = options.filename.split(',')\n    if options.ignore:\n        options.ignore = options.ignore.split(',')\n    else:\n        options.ignore = []\n    options.counters = {}\n    options.messages = {}\n\n    return options, args", "response": "Process options passed via command line args."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _main():\n    options, args = process_options()\n    if options.doctest:\n        import doctest\n        return doctest.testmod()\n    start_time = time.time()\n    errors = 0\n    for path in args:\n        if os.path.isdir(path):\n            errors += input_dir(path)\n        else:\n            errors += input_file(path)\n    elapsed = time.time() - start_time\n    if options.statistics:\n        print_statistics()\n    if options.benchmark:\n        print_benchmark(elapsed)\n    return errors > 0", "response": "Main function for the main function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a line from the input buffer.", "response": "def readline(self):\n        \"\"\"\n        Get the next line from the input buffer.\n        \"\"\"\n        self.line_number += 1\n        if self.line_number > len(self.lines):\n            return ''\n        return self.lines[self.line_number - 1]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a line from the file and check if it is a physical line.", "response": "def readline_check_physical(self):\n        \"\"\"\n        Check and return the next physical line. This method can be\n        used to feed tokenize.generate_tokens.\n        \"\"\"\n        line = self.readline()\n        if line:\n            self.check_physical(line)\n        return line"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning all physical checks on a raw input line.", "response": "def check_physical(self, line):\n        \"\"\"\n        Run all physical checks on a raw input line.\n        \"\"\"\n        self.physical_line = line\n        if self.indent_char is None and len(line) and line[0] in ' \\t':\n            self.indent_char = line[0]\n        for name, check, argument_names in self.physical_checks:\n            result = self.run_check(check, argument_names)\n            if result is not None:\n                offset, text = result\n                self.report_error(self.line_number, offset, text, check)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_tokens_line(self):\n        self.mapping = []\n        logical = []\n        length = 0\n        previous = None\n        for token in self.tokens:\n            token_type, text = token[0:2]\n            if token_type in (tokenize.COMMENT, tokenize.NL,\n                              tokenize.INDENT, tokenize.DEDENT,\n                              tokenize.NEWLINE):\n                continue\n            if token_type == tokenize.STRING:\n                text = mute_string(text)\n            if previous:\n                end_line, end = previous[3]\n                start_line, start = token[2]\n                if end_line != start_line: # different row\n                    if self.lines[end_line - 1][end - 1] not in '{[(':\n                        logical.append(' ')\n                        length += 1\n                elif end != start: # different column\n                    fill = self.lines[end_line - 1][end:start]\n                    logical.append(fill)\n                    length += len(fill)\n            self.mapping.append((length, token))\n            logical.append(text)\n            length += len(text)\n            previous = token\n        self.logical_line = ''.join(logical)\n        assert self.logical_line.lstrip() == self.logical_line\n        assert self.logical_line.rstrip() == self.logical_line", "response": "Build a logical line from tokens."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun all logical checks on the current line.", "response": "def check_logical(self):\n        \"\"\"\n        Build a line from tokens and run all logical checks on it.\n        \"\"\"\n        options.counters['logical lines'] = \\\n            options.counters.get('logical lines', 0) + 1\n        self.build_tokens_line()\n        first_line = self.lines[self.mapping[0][1][2][0] - 1]\n        indent = first_line[:self.mapping[0][1][2][1]]\n        self.previous_indent_level = self.indent_level\n        self.indent_level = expand_indent(indent)\n        if options.verbose >= 2:\n            print self.logical_line[:80].rstrip()\n        for name, check, argument_names in self.logical_checks:\n            if options.verbose >= 3:\n                print '   ', name\n            result = self.run_check(check, argument_names)\n            if result is not None:\n                offset, text = result\n                if type(offset) is tuple:\n                    original_number, original_offset = offset\n                else:\n                    for token_offset, token in self.mapping:\n                        if offset >= token_offset:\n                            original_number = token[2][0]\n                            original_offset = (token[2][1]\n                                               + offset - token_offset)\n                self.report_error(original_number, original_offset,\n                                  text, check)\n        self.previous_logical = self.logical_line"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun all checks on the input file.", "response": "def check_all(self):\n        \"\"\"\n        Run all checks on the input file.\n        \"\"\"\n        self.file_errors = 0\n        self.line_number = 0\n        self.indent_char = None\n        self.indent_level = 0\n        self.previous_logical = ''\n        self.blank_lines = 0\n        self.tokens = []\n        parens = 0\n        for token in tokenize.generate_tokens(self.readline_check_physical):\n            # print tokenize.tok_name[token[0]], repr(token)\n            self.tokens.append(token)\n            token_type, text = token[0:2]\n            if token_type == tokenize.OP and text in '([{':\n                parens += 1\n            if token_type == tokenize.OP and text in '}])':\n                parens -= 1\n            if token_type == tokenize.NEWLINE and not parens:\n                self.check_logical()\n                self.blank_lines = 0\n                self.tokens = []\n            if token_type == tokenize.NL and not parens:\n                if len(self.tokens) <= 1:\n                    # The physical line contains only this token.\n                    self.blank_lines += 1\n                self.tokens = []\n            if token_type == tokenize.COMMENT:\n                source_line = token[4]\n                token_start = token[2][1]\n                if source_line[:token_start].strip() == '':\n                    self.blank_lines = 0\n                if text.endswith('\\n') and not parens:\n                    # The comment also ends a physical line.  This works around\n                    # Python < 2.6 behaviour, which does not generate NL after\n                    # a comment which is on a line by itself.\n                    self.tokens = []\n        return self.file_errors"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef report_error(self, line_number, offset, text, check):\n        if options.quiet == 1 and not self.file_errors:\n            message(self.filename)\n        self.file_errors += 1\n        code = text[:4]\n        options.counters[code] = options.counters.get(code, 0) + 1\n        options.messages[code] = text[5:]\n        if options.quiet:\n            return\n        if options.testsuite:\n            base = os.path.basename(self.filename)[:4]\n            if base == code:\n                return\n            if base[0] == 'E' and code[0] == 'W':\n                return\n        if ignore_code(code):\n            return\n        if options.counters[code] == 1 or options.repeat:\n            message(\"%s:%s:%d: %s\" %\n                    (self.filename, line_number, offset + 1, text))\n            if options.show_source:\n                line = self.lines[line_number - 1]\n                message(line.rstrip())\n                message(' ' * offset + '^')\n            if options.show_pep8:\n                message(check.__doc__.lstrip('\\n').rstrip())", "response": "Report an error according to options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix where possible.\n        '''\n        # WARNING: http://tools.ietf.org/html/draft-ietf-lisp-ddt-00\n        # does not define this field so the description is taken from\n        # http://tools.ietf.org/html/draft-ietf-lisp-24\n        #\n        # Record TTL:  The time in minutes the recipient of the Map-Reply will\n        # store the mapping.  If the TTL is 0, the entry SHOULD be removed\n        # from the cache immediately.  If the value is 0xffffffff, the\n        # recipient can decide locally how long to store the mapping.\n        if not isinstance(self.ttl, numbers.Integral) \\\n        or self.ttl < 0 or self.ttl > 0xffffffff:\n            raise ValueError('Invalid TTL')\n\n        # ACT: The \"action\" field of the mapping record in a Map-Referral\n        # message encodes 6 action types.  The values for the action types are:\n        #\n        # NODE-REFERRAL (0):  Sent by a DDT node with a child delegation which\n        #   is authoritative for the EID.\n        #\n        # MS-REFERRAL (1):  Sent by a DDT node that has information about Map\n        #   Server(s) for the EID but it is not one of the Map Servers listed,\n        #   i.e. the DDT-Node sending the referral is not a Map Server.\n        #\n        # MS-ACK (2):  Sent by a DDT Map Server that has one or more ETR\n        #   registered for the EID.\n        #\n        # MS-NOT-REGISTERED (3):  Sent by a DDT Map Server that is configured\n        #   for the EID-prefix but for which no ETRs are registered.\n        #\n        # DELEGATION-HOLE (4):  Sent by an intermediate DDT node with\n        #   authoritative configuration covering the requested EID but without\n        #   any child delegation for the EID.  Also sent by a DDT Map Server\n        #   with authoritative configuration covering the requested EID but\n        #   for which no specific site ETR is configured.\n        #\n        # NOT-AUTHORITATIVE (5):  Sent by a DDT node that does not have\n        #   authoritative configuration for the requested EID.  The EID-prefix\n        #   returned MUST be the original requested EID and the TTL MUST be\n        #   set to 0.  However, if such a DDT node has a child delegation\n        #   covering the requested EID, it may choose to return NODE-REFERRAL\n        #   or MS-REFERRAL as appropriate.  A DDT Map Server with site\n        #   information may choose to return of type MS-ACK or MS-NOT-\n        #   REGISTERED as appropriate.\n        if self.action not in (self.ACT_NODE_REFERRAL,\n                               self.ACT_MS_REFERRAL,\n                               self.ACT_MS_ACK,\n                               self.ACT_MS_NOT_REGISTERED,\n                               self.ACT_DELEGATION_HOLE,\n                               self.ACT_NOT_AUTHORITATIVE):\n            raise ValueError('Invalid action')\n\n        # WARNING: http://tools.ietf.org/html/draft-ietf-lisp-ddt-00\n        # does not define this field so the description is taken from\n        # http://tools.ietf.org/html/draft-ietf-lisp-24\n        #\n        # A: The Authoritative bit, when sent is always set to 1 by an ETR.\n        # When a Map-Server is proxy Map-Replying [LISP-MS] for a LISP site,\n        # the Authoritative bit is set to 0.  This indicates to requesting\n        # ITRs that the Map-Reply was not originated by a LISP node managed\n        # at the site that owns the EID-prefix.\n        if not isinstance(self.authoritative, bool):\n            raise ValueError('Authoritative flag must be a boolean')\n\n        # Incomplete: The \"I\" bit indicates that a DDT node's referral-set of\n        # locators is incomplete and the receiver of this message should not\n        # cache the referral\n        if not isinstance(self.incomplete, bool):\n            raise ValueError('Incomplete flag must be a boolean')\n\n        # A DDT sets the \"incomplete\" flag, the TTL, and the Action Type field\n        # as follows:\n        #\n        # -------------------------------------------------------------------\n        #  Type (Action field)          Incomplete Referral-set   TTL values\n        # -------------------------------------------------------------------\n        #   0    NODE-REFERRAL              NO         YES           1440\n        #   1    MS-REFERRAL                NO         YES           1440\n        #   2    MS-ACK                     *          *             1440\n        #   3    MS-NOT-REGISTERED          *          *             1\n        #   4    DELEGATION-HOLE            NO         NO            15\n        #   5    NOT-AUTHORITATIVE          YES        NO            0\n        # -------------------------------------------------------------------\n        #\n        # *: The \"Incomplete\" flag setting on Map Server originated referral of\n        #   MS-REFERRAL and MS-NOT-REGISTERED types depend on whether the Map\n        #   Server has the full peer Map Server configuration for the same\n        #   prefix and has encoded the information in the mapping record.\n        #   Incomplete bit is not set when the Map Server has encoded the\n        #   information, which means the referral-set includes all the RLOCs\n        #   of all Map Servers that serve the prefix.  It is set when the Map\n        #   Server has not encoded the Map Server set information.\n        if self.action == self.ACT_NODE_REFERRAL:\n            if self.incomplete:\n                raise ValueError('NODE-REFERRAL messages cannot be incomplete')\n\n            if not self.locator_records:\n                raise ValueError('NODE-REFERRAL messages must have locators')\n\n            if self.ttl != 1440:\n                raise ValueError('NODE-REFERRAL messages must have TTL=1440')\n\n        elif self.action == self.ACT_MS_REFERRAL:\n            if self.incomplete:\n                raise ValueError('MS-REFERRAL messages cannot be incomplete')\n\n            if not self.locator_records:\n                raise ValueError('MS-REFERRAL messages must have locators')\n\n            if self.ttl != 1440:\n                raise ValueError('MS-REFERRAL messages must have TTL=1440')\n\n        elif self.action == self.ACT_MS_ACK:\n            if self.ttl != 1440:\n                raise ValueError('MS-ACK messages must have TTL=1440')\n\n        elif self.action == self.ACT_MS_NOT_REGISTERED:\n            if self.ttl != 1:\n                raise ValueError('MS-NOT-REGISTERED messages must have '\n                                 'TTL=1')\n\n        elif self.action == self.ACT_DELEGATION_HOLE:\n            if self.incomplete:\n                raise ValueError('DELEGATION-HOLE messages cannot be '\n                                 'incomplete')\n\n            if self.locator_records:\n                raise ValueError('DELEGATION-HOLE messages can not have '\n                                 'locators')\n\n            if self.ttl != 15:\n                raise ValueError('DELEGATION-HOLE messages must have TTL=15')\n\n        elif self.action == self.ACT_NOT_AUTHORITATIVE:\n            if not self.incomplete:\n                raise ValueError('NOT-AUTHORITATIVE messages must be '\n                                 'incomplete')\n\n            if self.locator_records:\n                raise ValueError('NOT-AUTHORITATIVE messages can not have '\n                                 'locators')\n\n            if self.ttl != 0:\n                raise ValueError('NOT-AUTHORITATIVE messages must have TTL=0')\n\n        # WARNING: http://tools.ietf.org/html/draft-ietf-lisp-ddt-00\n        # does not define this field so the description is taken from\n        # http://tools.ietf.org/html/draft-ietf-lisp-24\n        #\n        # Map-Version Number:  When this 12-bit value is non-zero the Map-Reply\n        # sender is informing the ITR what the version number is for the\n        # EID-record contained in the Map-Reply.  The ETR can allocate this\n        # number internally but MUST coordinate this value with other ETRs\n        # for the site.  When this value is 0, there is no versioning\n        # information conveyed.  The Map-Version Number can be included in\n        # Map-Request and Map-Register messages.  See Section 6.6.3 for more\n        # details.\n        if not isinstance(self.map_version, numbers.Integral) \\\n        or self.map_version < 0 \\\n        or self.map_version >= 2 ** 12:\n            raise ValueError('Invalid map version')\n\n        # EID-prefix: 4 octets if an IPv4 address-family, 16 octets if an IPv6\n        # address-family.\n        if not isinstance(self.eid_prefix, LCAFInstanceAddress):\n            if not isinstance(self.eid_prefix, (IPv4Network, IPv6Network)):\n                raise ValueError(\"Unexpected EID prefix %r\", self.eid_prefix)\n\n            # Wrap in LCAF address with Instance ID\n            self.eid_prefix = LCAFInstanceAddress(instance_id=0,\n                                                  address=self.eid_prefix)\n\n        # Check locator records\n        # The probed_locator bits aren't used in this context\n        for locator_record in self.locator_records:\n            if not isinstance(locator_record, LocatorRecord) \\\n            or locator_record.probed_locator:\n                raise ValueError('Invalid Locator record')\n\n            locator_record.sanitize()\n\n        # For each Map-Reply record, the list of Locators in a Locator-Set MUST\n        # appear in the same order for each ETR that originates a Map-Reply\n        # message.  The Locator-Set MUST be sorted in order of ascending IP\n        # address where an IPv4 locator address is considered numerically 'less\n        # than' an IPv6 locator address.\n        self.locator_records.sort(key=LocatorRecord.sort_key)\n\n        # Check signatures\n        for dummy in self.signatures:\n            # TODO: Implement signatures [LISP-Security]\n            pass", "response": "Sanitize the current mapping record fields."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pyobj_role(make_node, name, rawtext, text, lineno, inliner, options=None, content=None):\n    if options is None:\n        options = {}\n\n    if content is None:\n        content = []\n\n    try:\n        prefixed_name, obj, parent, modname = import_by_name(text)\n    except ImportError:\n        msg = inliner.reporter.error(\"Could not locate Python object {}\".format(text), line=lineno)\n        prb = inliner.problematic(rawtext, rawtext, msg)\n        return [prb], [msg]\n    app = inliner.document.settings.env.app\n    node = make_node(rawtext, app, prefixed_name, obj, parent, modname, options)\n    return [node], []", "response": "Include Python object value rendering it to text using str."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload items from the aleph and store them in db.", "response": "def _download_items(db, last_id):\n    \"\"\"\n    Download items from the aleph and store them in `db`. Start from `last_id`\n    if specified.\n\n    Args:\n        db (obj): Dictionary-like object used as DB.\n        last_id (int): Start from this id.\n    \"\"\"\n    MAX_RETRY = 20  # how many times to try till decision that this is an end\n    MAX_DOC_ID = 10000000  # this is used for download iterator\n\n    not_found_cnt = 0  # circuit breaker\n    for doc_id in xrange(last_id, MAX_DOC_ID):\n        doc_id += 1\n        print \"Downloading %d..\" % (doc_id)\n\n        if not_found_cnt >= MAX_RETRY:\n            print \"It looks like this is an end:\", doc_id - MAX_RETRY\n            break\n\n        try:\n            record = _download(doc_id)\n        except (DocumentNotFoundException, InvalidAlephBaseException):\n            print \"\\tnot found, skipping\"\n            not_found_cnt += 1\n            continue\n\n        not_found_cnt = 0\n        db[\"item_%d\" % doc_id] = record\n        db[\"last_id\"] = doc_id - MAX_RETRY if doc_id > MAX_RETRY else 1\n\n        if doc_id % 100 == 0:\n            db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads all items from cache_fn.", "response": "def download_items(cache_fn, start=None):\n    \"\"\"\n    Open the `cache_fn` as database and download all not-yet downloaded items.\n\n    Args:\n        cache_fn (str): Path to the sqlite database. If not exists, it will be\n            created.\n        start (int, default None): If set, start from this sysno.\n    \"\"\"\n    with SqliteDict(cache_fn) as db:\n        last_id = db.get(\"last_id\", 0) if not start else start\n        _download_items(db, last_id)\n        db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield KeywordInfo instances for all the keywords in the database.", "response": "def _pick_keywords(db):\n    \"\"\"\n    Go thru downloaded data stored in `db` and filter keywords, which are\n    parsed and then yielded.\n\n    Shows nice progress bar.\n\n    Args:\n        db (obj): Opened database connection.\n\n    Yields:\n        obj: :class:`KeywordInfo` instances for yeach keyword.\n    \"\"\"\n    for key, val in tqdm(db.iteritems(), total=len(db)):\n        # skip counter of the last downloaded document\n        if key == \"last_id\":\n            continue\n\n        # this is optimization to speed up skipping of the unwanted elements\n        # by the factor of ~20\n        piece = val[:500] if len(val) > 500 else val\n        if '<fixfield id=\"001\">ph' not in piece.lower():\n            continue\n\n        parsed = MARCXMLRecord(val)\n\n        code = parsed.get(\"001\")\n        if not code:\n            continue\n\n        # record was disabled\n        if parsed[\"682i\"]:\n            continue\n\n        if code.lower().startswith(\"ph\"):\n            yield KeywordInfo.from_marc(\n                sysno=int(key.split(\"_\")[-1]),  # item_xxx -> int(xxx)\n                marc=parsed,\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngoing thru `cache_fn` and filter keywords. Store them in `keyword_list.json`. Args: cache_fn (str): Path to the file with cache. Returns: list: List of :class:`KeywordInfo` objects.", "response": "def generate(cache_fn):\n    \"\"\"\n    Go thru `cache_fn` and filter keywords. Store them in `keyword_list.json`.\n\n    Args:\n        cache_fn (str): Path to the file with cache.\n\n    Returns:\n        list: List of :class:`KeywordInfo` objects.\n    \"\"\"\n    if not os.path.exists(cache_fn):\n        print >> sys.stderr, \"Can't access `%s`!\" % cache_fn\n        sys.exit(1)\n\n    with SqliteDict(cache_fn) as db:\n        for item in _pick_keywords(db):\n            yield item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsanitizing the current settings of the Map - Reply message.", "response": "def sanitize(self):\n        '''\n        Check if the current settings conform to the LISP specifications and\n        fix them where possible.\n        '''\n        super(MapReplyMessage, self).sanitize()\n\n        # P: This is the probe-bit which indicates that the Map-Reply is in\n        # response to a locator reachability probe Map-Request.  The nonce\n        # field MUST contain a copy of the nonce value from the original\n        # Map-Request.  See Section 6.3.2 for more details.\n        if not isinstance(self.probe, bool):\n            raise ValueError('Probe flag must be a boolean')\n\n        # E: Indicates that the ETR which sends this Map-Reply message is\n        # advertising that the site is enabled for the Echo-Nonce locator\n        # reachability algorithm.  See Section 6.3.1 for more details.\n        if not isinstance(self.enlra_enabled, bool):\n            raise ValueError('Echo-Nonce Locator Reachability algorithm ' +\n                             'enabled flag must be a boolean')\n\n        # S: This is the Security bit.  When set to 1 the following\n        # authentication information will be appended to the end of the Map-\n        # Reply.  The detailed format of the Authentication Data Content is\n        # for further study.\n        if not isinstance(self.security, bool):\n            raise ValueError('Security flag must be a boolean')\n\n        if self.security:\n            raise NotImplementedError('Handling security data is not ' +\n                                      'implemented yet')\n\n        # Nonce:  A 24-bit value set in a Data-Probe packet or a 64-bit value\n        # from the Map-Request is echoed in this Nonce field of the Map-\n        # Reply.  When a 24-bit value is supplied, it resides in the low-\n        # order 64 bits of the nonce field.\n        if len(bytes(self.nonce)) not in (3, 8):\n            raise ValueError('Invalid nonce')\n\n        # Map-Reply Record:  When the M bit is set, this field is the size of a\n        # single \"Record\" in the Map-Reply format.  This Map-Reply record\n        # contains the EID-to-RLOC mapping entry associated with the Source\n        # EID.  This allows the ETR which will receive this Map-Request to\n        # cache the data if it chooses to do so.\n        for record in self.records:\n            if not isinstance(record, MapReplyRecord):\n                raise ValueError('Invalid record')\n\n            record.sanitize()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the given packet and update properties accordingly", "response": "def from_bytes(cls, bitstream):\n        '''\n        Parse the given packet and update properties accordingly\n        '''\n        packet = cls()\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Read the type\n        type_nr = bitstream.read('uint:4')\n        if type_nr != packet.message_type:\n            msg = 'Invalid bitstream for a {0} packet'\n            class_name = packet.__class__.__name__\n            raise ValueError(msg.format(class_name))\n\n        # Read the flags\n        (packet.probe,\n         packet.enlra_enabled,\n         packet.security) = bitstream.readlist('3*bool')\n\n        # Skip reserved bits\n        packet._reserved1 = bitstream.read(17)\n\n        # Store the record count until we need it\n        record_count = bitstream.read('uint:8')\n\n        # Read the nonce\n        packet.nonce = bitstream.read('bytes:8')\n\n        # Read the records\n        for dummy in range(record_count):\n            record = MapReplyRecord.from_bytes(bitstream)\n            packet.records.append(record)\n\n        # If the security flag is set then there should be security data left\n        # TODO: deal with security flag [LISP-Security]\n        if packet.security:\n            raise NotImplementedError('Handling security data is not ' +\n                                      'implemented yet')\n\n        # Verify that the properties make sense\n        packet.sanitize()\n\n        return packet"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that properties make sense\n        self.sanitize()\n\n        # Start with the type\n        bitstream = BitArray('uint:4=%d' % self.message_type)\n\n        # Add the flags\n        bitstream += BitArray('bool=%d, bool=%d, bool=%d'\n                              % (self.probe,\n                                 self.enlra_enabled,\n                                 self.security))\n\n        # Add padding\n        bitstream += self._reserved1\n\n        # Add record count\n        bitstream += BitArray('uint:8=%d' % len(self.records))\n\n        # Add the nonce\n        nonce = bytes(self.nonce)\n        if len(nonce) < 8:\n            padding_len = 8 - len(nonce)\n            bitstream += BitArray(8 * padding_len)\n\n        bitstream += BitArray(bytes=nonce)\n\n        # Add the map-reply records\n        for record in self.records:\n            bitstream += record.to_bitstream()\n\n        # If the security flag is set then there should be security data here\n        # TODO: deal with security flag [LISP-Security]\n        if self.security:\n            raise NotImplementedError('Handling security data is not ' +\n                                      'implemented yet')\n\n        return bitstream.bytes", "response": "Create bytes from properties and message"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds two elements a and b into a new object.", "response": "def _add(a, b, relicAdd):\n    \"\"\"\n    Adds two elements @a,@b of the same type into @result using @relicAddFunc.\n    \"\"\"\n    # Check types, create a result object of the same type, and call the relic\n    # function.\n    assertSameType(a,b)\n    result = type(a)()\n    relicAdd(byref(result), byref(a), byref(b))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms scalar multiplication between point P and scalar a.", "response": "def _scalarMultiply(P, a, n, relicScalarMult):\n    \"\"\"\n    Performs scalar multiplication between point P \\in G, scalar a \\in Z, \n    using the function @relicScalarMult. @n is the order of the group G.\n    \"\"\"\n    # Ensure the scalar is a BigInt\n    a = coerceBigInt(a)\n    if not a:\n        return NotImplemented\n\n    # Shrink large scalars.\n    a %= n\n\n    # Create a point to hold the result and multiply.\n    result = type(P)()\n    relicScalarMult(byref(result), byref(P), byref(a))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmultiply scalar a by the group generator using the group generator using the relicGenMultiplyFunc . Returns the result of type element.", "response": "def _genMultiply(a, element, n, relicGenMultiplyFunc):\n    \"\"\"\n    Multiplies scalar @a by the group generator using @relicGenMultiplyFunc\n    and returns the result of type @element.\n    \"\"\"\n    # Ensure the scalar is a BigInt\n    a = coerceBigInt(a)\n    if not a:\n        return NotImplemented\n\n    # Shrink large scalars.\n    a %= n\n\n    result = element()\n    relicGenMultiplyFunc(byref(result), byref(a))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deserializeG2(x, compressed=True):\n    return _deserialize(x, G2Element, compressed, librelic.g2_read_bin_abi)", "response": "Deserializes an array of bytes x into a G2 element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deserializeGt(x, compressed=True):\n    return _deserialize(x, GtElement, compressed, librelic.gt_read_bin_abi)", "response": "Deserializes an array of bytes x into a Gt element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getBuffer(x):\n    b = bytes(x)\n    return (c_ubyte * len(b)).from_buffer_copy(bytes(x))", "response": "Copy @x into a (modifiable ) ctypes byte array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _hash(x, elementType, relicHashFunc):\n    # Combine all inputs into a single bytearray\n    barray = bytearray()\n    map(barray.extend, bytes(x))\n\n    # Create an element of the correct type to hold the hash result\n    result = elementType()\n\n    # Convert barray into a modifiable ctypes buffer, hash using the provided\n    # function, and return the result.\n    buf = getBuffer(barray)\n    relicHashFunc(byref(result), byref(buf), sizeof(buf))\n    return result", "response": "Hash an array of bytes x using the provided hash function. Returns the result of the element type."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pair(p,q):\n    # Check types\n    assertType(p, G1Element)\n    assertType(q, G2Element)\n\n    result = GtElement()\n    librelic.pc_map_abi(byref(result), byref(p), byref(q))\n    return result", "response": "Computes the bilinear pairing e."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes G1 element x into a byte array of bytes.", "response": "def serializeG1(x, compress=True):\n    \"\"\"\n    Converts G1 element @x into an array of bytes. If @compress is True, \n    the point will be compressed resulting in a much shorter string of bytes.\n    \"\"\"\n    assertType(x, G1Element)\n    return _serialize(x, compress, librelic.g1_size_bin_abi,\n        librelic.g1_write_bin_abi)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serializeG2(x, compress=True):\n    assertType(x, G2Element)\n    return _serialize(x, compress, librelic.g2_size_bin_abi,\n        librelic.g2_write_bin_abi)", "response": "Serializes G2 element x into a byte array of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serializeGt(x, compress=True):\n    assertType(x, GtElement)\n    return _serialize(x, compress, librelic.gt_size_bin_abi,\n        librelic.gt_write_bin_abi)", "response": "Serializes Gt element x into a string of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inverse(self):\n        result = G1Element()\n        librelic.g1_neg_abi(byref(result), byref(self))\n        return result", "response": "Returns the inverse of a G1 element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the inverse of a G1 element.", "response": "def inverse(self):\n        \"\"\"\n        Retrieves the inverse of a G1 element.\n        \"\"\"\n        result = G2Element()\n        librelic.g2_neg_abi(byref(result), byref(self))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfasting multiplication using a the LWNAF precomputation table.", "response": "def mul_table(self, other):\n        \"\"\"\n        Fast multiplication using a the LWNAF precomputation table.\n        \"\"\"\n        # Get a BigInt\n        other = coerceBigInt(other)\n        if not other:\n            return NotImplemented\n        other %= orderG2()\n\n        # Building the precomputation table, if there is not one already.\n        if not self._table:\n            self._table = lwnafTable()\n            librelic.ep2_mul_pre_lwnaf(byref(self._table), byref(self))\n\n\n        result = G2Element()\n        librelic.ep2_mul_fix_lwnaf(byref(result), byref(self._table), \n            byref(other))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntranslate keywords to full keyword records as they are used in Aleph.", "response": "def compile_keywords(keywords):\n    \"\"\"\n    Translate `keywords` to full keyword records as they are used in Aleph.\n\n    Returns tuple with three lists, each of which is later used in different\n    part of the MRC/MARC record.\n\n    Args:\n        keywords (list): List of keyword strings.\n\n    Returns:\n        tuple: (mdt_list, cz_keyword_list, en_keyword_list)\n    \"\"\"\n    mdt = []\n    cz_keywords = []\n    en_keywords = []\n    for keyword in keywords:\n        keyword = keyword_to_info(keyword.encode(\"utf-8\"))\n\n        if not keyword:\n            continue\n\n        cz_keywords.append({\n            \"uid\": keyword[\"uid\"],\n            \"zahlavi\": keyword[\"zahlavi\"],\n            \"zdroj\": \"czenas\",\n        })\n\n        if keyword.get(\"mdt\"):\n            mdt.append({\n                \"mdt\": keyword[\"mdt\"],\n                \"mrf\": keyword[\"mrf\"],\n            })\n\n        angl_ekvivalent = keyword.get(\"angl_ekvivalent\")\n        if angl_ekvivalent:\n            en_keywords.append({\n                \"zahlavi\": angl_ekvivalent,\n                \"zdroj\": keyword.get(\"zdroj_angl_ekvivalentu\") or \"eczenas\",\n            })\n\n    return mdt, cz_keywords, en_keywords"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_to_fn(url):\n    url = url.replace(\"http://\", \"\").replace(\"https://\", \"\")\n    url = url.split(\"?\")[0]\n\n    return url.replace(\"%\", \"_\").replace(\"/\", \"_\")", "response": "Convert url to filename used to download the datasets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse input date string in free - text format for four - digit long groups.", "response": "def parse_date_range(date, alt_end_date=None):\n    \"\"\"\n    Parse input `date` string in free-text format for four-digit long groups.\n\n    Args:\n        date (str): Input containing years.\n\n    Returns:\n        tuple: ``(from, to)`` as four-digit strings.\n    \"\"\"\n    NOT_ENDED = \"9999\"\n    all_years = re.findall(r\"\\d{4}\", date)\n\n    if alt_end_date:\n        NOT_ENDED = alt_end_date\n\n    if not all_years:\n        return \"****\", NOT_ENDED\n\n    elif len(all_years) == 1:\n        return all_years[0], NOT_ENDED\n\n    return all_years[0], all_years[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef serialize_author(author_data):\n    record = author_data[\"record\"]\n    i1 = record[\"i1\"]\n    i2 = record[\"i2\"]\n\n    # make sure that all required fields will be created\n    if \"a\" not in record:\n        record[\"a\"] = \" \"\n\n    if author_data[\"is_corporation\"]:\n        code = \"110\"\n        if \"b\" not in record:\n            record[\"b\"] = \" \"\n    else:\n        code = \"100\"\n        if \"d\" not in record:\n            record[\"d\"] = \" \"\n        if \"4\" not in record:\n            record[\"4\"] = \" \"\n\n    out = \"%s%s%s L \" % (code, i1, i2)\n    for key in resorted(key for key in record if len(key) == 1):\n        for item in record[key]:\n            out += \"$$%s%s\" % (key, item)\n\n    return out", "response": "This function takes a dictionary with parsed and raw data and creates a new MRC record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting date in the format ala 03. 02. 2017 to 3. 2. 2017.", "response": "def _to_date_in_588(date_str):\n    \"\"\"\n    Convert date in the format ala 03.02.2017 to 3.2.2017.\n\n    Viz #100 for details.\n    \"\"\"\n    try:\n        date_tokens = (int(x) for x in date_str.split(\".\"))\n    except ValueError:\n        return date_str\n\n    return \".\".join(str(x) for x in date_tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert WA - KAT frontend dataset to three output datasets.", "response": "def to_output(data):\n    \"\"\"\n    Convert WA-KAT frontend dataset to three output datasets - `MRC`, `MARC`\n    and `Dublin core`.\n\n    Conversion is implemented as filling ofthe MRC template, which is then\n    converted to MARC record. Dublin core is converted standalone from the\n    input dataset.\n    \"\"\"\n    data = json.loads(data)\n\n    # postprocessing\n    if \"keywords\" in data:\n        mdt, cz_keywords, en_keywords = compile_keywords(data[\"keywords\"])\n        del data[\"keywords\"]\n\n        data[\"mdt\"] = mdt\n        data[\"cz_keywords\"] = cz_keywords\n        data[\"en_keywords\"] = en_keywords\n\n    data[\"annotation\"] = data[\"annotation\"].replace(\"\\n\", \" \")\n    data[\"time\"] = time  # for date generation\n\n    # convert additional info values to MRC\n    ai_key = \"additional_info\"\n    if data.get(ai_key) is None:\n        data[ai_key] = {}\n\n    # parse regularity - see https://github.com/WebArchivCZ/WA-KAT/issues/66\n    # for details\n    fld_008 = data[ai_key].get(\"008\")\n    data[\"regularity\"] = fld_008[18] if fld_008 and len(fld_008) > 18 else \"-\"\n\n    # put lang code to 008\n    data[\"lang_code_008\"] = get_008_lang_code(data.get(\"language\"))\n\n    # special format of date - viz #100\n    data[\"date_of_generation\"] = _to_date_in_588(time.strftime(\"%d.%m.%Y\"))\n\n    data[ai_key] = {\n        key: \"\\n\".join(item_to_mrc(key, val))\n        for key, val in data[ai_key].iteritems()\n        if val\n    }\n\n    alt_end_date = data[ai_key].get(\"alt_end_date\", None)\n\n    # handle date range in the 008\n    from_year, to_year = parse_date_range(data[\"creation_date\"], alt_end_date)\n    data[\"from_year\"] = from_year\n    data[\"to_year\"] = to_year\n\n    # serialize author\n    if data[\"author\"]:\n        data[\"serialized_author\"] = serialize_author(data[\"author\"])\n\n    # send data to seeder\n    if data.get(\"url_id\"):\n        send_update(data[\"url_id\"], data)\n\n    # convert to MRC format\n    mrc = render_mrc(data).encode(\"utf-8\")\n\n    # create all output formats\n    out = {\n        \"fn\": url_to_fn(data[\"url\"]),\n        \"mrc\": mrc,\n        \"oai\": mrc_to_marc(mrc),\n        \"dc\": to_dc(data),\n    }\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_ipv4(ip: str) -> bool:\n    try:\n        socket.inet_aton(ip)\n    except socket.error:\n        return False\n    return True", "response": "Returns True if the IPv4 address ia valid otherwise returns False."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist out the boards for our client", "response": "def main(api_key, token):\n    \"\"\"List out the boards for our client\"\"\"\n    trello_client = TrelloClient(\n        api_key=api_key,\n        token=token,\n    )\n    print('Boards')\n    print('-----')\n    print('Name: Id')\n    for board in trello_client.list_boards():\n        print('{board.name}: {board.id}'.format(board=board))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize(self, timestamp=None, user=None, comment=None,\n                   filename=None, source=None, size=None):\n\n        self.timestamp = none_or(timestamp, Timestamp)\n        \"\"\"\n        Upload timestamp : mwtypes.Timestamp | None\n        \"\"\"\n\n        self.user = none_or(user, User)\n        \"\"\"\n        Contributing user metadata : :class:`~mwtypes.User`\n        \"\"\"\n\n        self.comment = none_or(comment, str)\n        \"\"\"\n        Comment left with upload : str | None\n        \"\"\"\n\n        self.filename = none_or(filename, str)\n        \"\"\"\n        File name without \"File:\" prefix and \"_\" instead of spaces : str | None\n        \"\"\"\n\n        self.source = none_or(source, str)\n        \"\"\"\n        A URI : str | None\n        \"\"\"\n\n        self.size = none_or(size, int)\n        \"\"\"\n        Number of bytes of content : int | None\n        \"\"\"", "response": "Initializes the object with the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def main():\n    async with aiohttp.ClientSession() as session:\n        data = Glances(loop, session, version=VERSION)\n\n        # Get the metrics for the memory\n        await data.get_metrics('mem')\n\n        # Print the values\n        print(\"Memory values:\", data.values)\n\n        # Get the metrics about the disks\n        await data.get_metrics('diskio')\n\n        # Print the values\n        print(\"Disk values:\", data.values)", "response": "The main part of the example script."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _req(self, path, method='get', json=True, assert_status=200, **kw):\n        method = getattr(self.session, method.lower())\n        res = method(self.url(path), **kw)\n\n        status_code = res.status_code\n        if json:\n            try:\n                res = res.json()\n            except ValueError:\n                log.error(res.text[:1000])\n                raise\n        if assert_status:\n            if not isinstance(assert_status, (list, tuple)):\n                assert_status = [assert_status]\n            if status_code not in assert_status:\n                log.error(\n                    'got HTTP %s, expected HTTP %s' % (status_code, assert_status))\n                log.error(res.text[:1000] if hasattr(res, 'text') else res)\n                raise CdstarError('Unexpected HTTP status code', res, status_code)\n        return res", "response": "Make a request to the API of an existing cdstar instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching the bigsearch service.", "response": "def search(self, query, limit=15, offset=0, index=None):\n        \"\"\"\n        Query the search service.\n\n        :param query: The query.\n        :param limit: The maximal number of results to return (at most 500).\n        :param offset: Use to page through big search result sets.\n        :param index: Name of the index to search in (metadata|fulltext) or `None`.\n        :return:\n        \"\"\"\n        params = dict(limit=limit, offset=offset)\n        if index:\n            assert index in ['metadata', 'fulltext']\n            params['indexselection'] = index\n        if isinstance(query, string_types):\n            query = {\"query_string\": {\"query\": query}}\n        # elif isinstance(query, ElasticQuery):\n        #    query = query.dict()\n        assert isinstance(query, dict)\n        return resource.SearchResults(self, self._req(\n            '/search/',\n            method='post',\n            params=params,\n            headers={'content-type': 'application/json'},\n            data=json.dumps(query)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _copy_update(sourcepath, destname):\n    if sys.platform.startswith('linux'):\n        return os.system(\"/bin/cp -ua '%s' '%s'\" % (sourcepath, destname))\n    else:\n        return os.system(\"rsync -ua '%s' '%s'\" % (sourcepath, destname))", "response": "Copy source to dest only if source is newer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmove source to dest only if source is newer.", "response": "def _move_update(sourcepath, destname):\n    \"\"\"Move source to dest only if source is newer.\"\"\"\n    if sys.platform.startswith('linux'):\n        return os.system(\"/bin/mv -fu '%s' '%s'\" % (sourcepath, destname))\n    else:\n        return os.system(\"rsync -ua --remove-source-files '%s' '%s'\" % (sourcepath, destname))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_file(self):\n        if not self.fullpath or not self.archived:\n            raise RuntimeError(\"\"\"Can't remove a non-archived data product\"\"\")\n        try:\n            os.remove(self.fullpath)\n        except:\n            print(\"Error removing %s: %s\" % (self.fullpath, sys.exc_info()[1]))", "response": "Removes the archived file associated with this DP"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_subproducts(self):\n        if not self.fullpath or not self.archived:\n            raise RuntimeError(\"\"\"Can't remove a non-archived data product\"\"\")\n        for root, dirs, files in os.walk(self.subproduct_dir(), topdown=False):\n            for name in files:\n                try:\n                    os.remove(os.path.join(root, name))\n                except:\n                    pass\n            for name in dirs:\n                try:\n                    os.remove(os.path.join(root, name))\n                except:\n                    pass", "response": "Removes all archived files subproducts associated with this DP."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction to restore a DP from archived copy", "response": "def restore_from_archive(self, parent=None):\n        \"\"\"Function to restore a DP from archived copy\n        Asks for confirmation along the way if parent is not None\n        (in which case it will be the parent widget for confirmation dialogs)\n        \"\"\"\n        from PyQt4.Qt import QMessageBox\n        exists = os.path.exists(self.sourcepath)\n        if parent:\n            msg = \"\"\"<P>Do you really want to restore <tt>%s</tt> from\n            this entry's copy of <tt>%s</tt>?</P>\"\"\" % (self.sourcepath, self.filename)\n            exists = os.path.exists(self.sourcepath)\n            if exists:\n                msg += \"\"\"<P>Current file exists, and will be overwritten.</P>\"\"\"\n                if QMessageBox.warning(parent, \"Restoring from archive\", msg,\n                                       QMessageBox.Yes, QMessageBox.No) != QMessageBox.Yes:\n                    return False\n            else:\n                if QMessageBox.question(parent, \"Restoring from archive\", msg,\n                                        QMessageBox.Yes, QMessageBox.No) != QMessageBox.Yes:\n                    return False\n        busy = Purr.BusyIndicator()\n        # remove file if in the way\n        if exists:\n            if os.system(\"/bin/rm -fr '%s'\" % self.sourcepath):\n                busy = None\n                if parent:\n                    QMessageBox.warning(parent, \"Error removing file\", \"\"\"<P>\n            There was an error removing %s. Archived copy was not restored.\n            The text console may have more information.</P>\"\"\" % self.sourcepath,\n                                        QMessageBox.Ok, 0)\n                return False\n        # unpack archived file\n        if self.fullpath.endswith('.tgz'):\n            parent_dir = os.path.dirname(self.sourcepath.rstrip('/'))\n            os.system(\"/bin/rm -fr %s\" % self.sourcepath)\n            if os.system(\"tar zxf '%s' -C '%s'\" % (self.fullpath, parent_dir)):\n                busy = None\n                if parent:\n                    QMessageBox.warning(parent, \"Error unpacking file\", \"\"\"<P>\n            There was an error unpacking the archived version to %s. The text console may have more information.</P>\"\"\" % self.sourcepath,\n                                        QMessageBox.Ok, 0)\n                return False\n        # else simply copy over\n        else:\n            if os.system(\"/bin/cp -a '%s' '%s'\" % (self.fullpath, self.sourcepath)):\n                busy = None\n                if parent:\n                    QMessageBox.warning(parent, \"Error copying file\", \"\"\"<P>\n            There was an error copying the archived version to %s. The text console may have more information.</P>\"\"\" % self.sourcepath,\n                                        QMessageBox.Ok, 0)\n                return False\n        busy = None\n        if parent:\n            QMessageBox.information(parent, \"Restored file\", \"\"\"<P>Restored %s from this entry's\n          archived copy.</P>\"\"\" % self.sourcepath,\n                                    QMessageBox.Ok, 0)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(self, pathname):\n        match = self._entry_re.match(pathname)\n        if not match:\n            return None\n        self.ignore = (match.group(1) == \"ignore\")\n        if not os.path.isdir(pathname):\n            raise ValueError(\"%s: not a directory\" % pathname)\n        if not os.access(pathname, os.R_OK | os.W_OK):\n            raise ValueError(\"%s: insufficient access privileges\" % pathname)\n        # parse index.html file\n        parser = Purr.Parsers.LogEntryIndexParser(pathname)\n        self.index_file = os.path.join(pathname, 'index.html')\n        for i, line in enumerate(open(self.index_file)):\n            try:\n                parser.feed(line)\n            except:\n                dprintf(0, \"parse error at line %d of %s\\n\", i, self.index_file)\n                raise\n        # set things up from parser\n        try:\n            self.timestamp = int(float(parser.timestamp))\n        except:\n            self.timestamp = int(time.time())\n        self.title = getattr(parser, 'title', None)\n        if self.title is None:\n            self.title = \"Malformed entry, probably needs to be deleted\"\n        self.comment = getattr(parser, 'comments', None) or \"\"\n        self.dps = getattr(parser, 'dps', [])\n        self.pathname = pathname\n        # see if any data products have been removed on us\n        self.dps = [dp for dp in self.dps if os.path.exists(dp.fullpath)]\n        # see if the cached include file is up-to-date\n        self.cached_include = cache = os.path.join(pathname, 'index.include.html')\n        mtime = (os.path.exists(cache) or 0) and os.path.getmtime(cache)\n        if mtime >= max(Purr.Render.youngest_renderer, os.path.getmtime(self.index_file)):\n            dprintf(2, \"entry %s has a valid include cache\\n\", pathname)\n            self.cached_include_valid = True\n        else:\n            dprintf(2, \"entry %s does not have a valid include cache\\n\", pathname)\n            self.cached_include_valid = False\n        # mark entry as unchanged, if renderers are older than index\n        self.updated = (Purr.Render.youngest_renderer > os.path.getmtime(self.index_file))", "response": "Loads the entry from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, dirname=None, refresh=0, refresh_index=True, emit_message=True):\n        if not refresh and not self.updated:\n            return\n        timestr = time.strftime(\"%Y%m%d-%H%M%S\", time.localtime(self.timestamp))\n        Purr.progressMessage(\"Rendering entry for %s\" % timestr)\n        if dirname:\n            self.pathname = pathname = os.path.join(dirname, \"%s-%s\" %\n                                                    ((\"ignore\" if self.ignore else \"entry\"), timestr))\n        elif not self.pathname:\n            raise ValueError(\"Cannot save entry: pathname not specified\")\n        else:\n            pathname = self.pathname\n        # set timestamp\n        if not self.timestamp:\n            self.timestamp = int(time.time())\n        # get canonized path to output directory\n        pathname = Purr.canonizePath(pathname)\n        if not os.path.exists(pathname):\n            os.mkdir(pathname)\n        # now save content\n        # get device of pathname -- need to know whether we move or copy\n        devnum = os.stat(pathname).st_dev\n        # copy data products as needed\n        dprintf(2, \"saving entry %s, %d data products\\n\", pathname, len(self.dps))\n        dps = []\n        for dp in self.dps:\n            # if archived, this indicates a previously saved data product, so ignore it\n            # if ignored, no need to save the DP -- but keep it in list\n            if dp.archived or dp.ignored:\n                dprintf(3, \"dp %s is archived or ignored, skipping\\n\", dp.sourcepath)\n                dps.append(dp)\n                continue\n            # file missing for some reason (perhaps it got removed on us?) skip data product entirely\n            if not os.path.exists(dp.sourcepath):\n                dprintf(2, \"data product %s missing, ignoring\\n\", dp.sourcepath)\n                continue\n            Purr.progressMessage(\"archiving %s\" % dp.filename, sub=True)\n            # get normalized source and destination paths\n            dprintf(2, \"data product: %s, rename %s, policy %s\\n\", dp.sourcepath, dp.filename, dp.policy)\n            sourcepath = Purr.canonizePath(dp.sourcepath)\n            destname = dp.fullpath = os.path.join(pathname, dp.filename)\n            dprintf(2, \"data product: %s -> %s\\n\", sourcepath, destname)\n            # does the destination product already exist? skip if same file, else remove\n            if os.path.exists(destname):\n                if os.path.samefile(destname, sourcepath):\n                    dprintf(2, \"same file, skipping\\n\")\n                    dp.timestamp = os.path.getmtime(destname)\n                    dps.append(dp)\n                    continue\n                if os.system(\"/bin/rm -fr '%s'\" % destname):\n                    print(\"Error removing %s, which is in the way of %s\" % (destname, sourcepath))\n                    print(\"This data product is not saved.\")\n                    continue\n            # for directories, compress with tar\n            if os.path.isdir(sourcepath):\n                sourcepath = sourcepath.rstrip('/')\n                if dp.policy == \"copy\" or dp.policy.startswith(\"move\"):\n                    dprintf(2, \"archiving to tgz\\n\")\n                    if os.system(\"tar zcf '%s' -C '%s' '%s'\" % (destname,\n                                                                os.path.dirname(sourcepath),\n                                                                os.path.basename(sourcepath))):\n                        print(\"Error archiving %s to %s\" % (sourcepath, destname))\n                        print(\"This data product is not saved.\")\n                        continue\n                    if dp.policy.startswith(\"move\"):\n                        os.system(\"/bin/rm -fr '%s'\" % sourcepath)\n            # else just a file\n            else:\n                # now copy/move it over\n                if dp.policy == \"copy\":\n                    dprintf(2, \"copying\\n\")\n                    if _copy_update(sourcepath, destname):\n                        print(\"Error copying %s to %s\" % (sourcepath, destname))\n                        print(\"This data product is not saved.\")\n                        continue\n                elif dp.policy.startswith('move'):\n                    if _move_update(sourcepath, destname):\n                        print(\"Error moving %s to %s\" % (sourcepath, destname))\n                        print(\"This data product is not saved.\")\n                        continue\n            # success, set timestamp and append\n            dp.timestamp = os.path.getmtime(destname)\n            dp.archived = True\n            dps.append(dp)\n        # reset list of data products\n        self.dps = dps\n        # now write out content\n        self.cached_include = os.path.join(pathname, 'index.include.html')\n        self.cached_include_valid = False\n        self.index_file = os.path.join(pathname, \"index.html\")\n        self.generateIndex(refresh=refresh, refresh_index=refresh_index and time.time())\n        self.updated = False", "response": "Saves the entry in the given directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setPrevUpNextLinks(self, prev=None, up=None, next=None):\n        if prev is not None:\n            if prev:\n                self._prev_link = quote_url(prev._relIndexLink())\n                prev._next_link = quote_url(self._relIndexLink())\n            else:\n                self._prev_link = None\n        if up is not None:\n            self._up_link = up and quote_url(up)\n        if next is not None:\n            self._next_link = next and quote_url(next._relIndexLink())", "response": "Sets the Prev link to point to the LogEntry object prev. Set that object s Next link to point to us."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the index file", "response": "def generateIndex(self, refresh=0, refresh_index=0):\n        \"\"\"Writes the index file\"\"\"\n        open(self.index_file, \"wt\").write(self.renderIndex(refresh=refresh, refresh_index=refresh_index))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering the index. html file for this entry.", "response": "def renderIndex(self, relpath=\"\", refresh=0, refresh_index=0):\n        \"\"\"Returns HTML index code for this entry.\n        If 'relpath' is empty, renders complete index.html file.\n        If 'relpath' is not empty, then index is being included into a top-level log, and\n        relpath should be passed to all sub-renderers.\n        In this case the entry may make use of its cached_include file, if that is valid.\n        If 'refresh' is set to a timestamp, then any subproducts (thumbnails, HTML caches, etc.) older than the timestamp will need to be regenerated.\n        If 'refresh_index' is set to a timestamp, then any index files older than the timestamp will need to be regenerated.\n        If 'relpath' is empty and 'prev', 'next' and/or 'up' is set, then Prev/Next/Up links will be inserted\n        \"\"\"\n        # check if cache can be used\n        refresh_index = max(refresh, refresh_index)\n        dprintf(2, \"%s: rendering HTML index with relpath='%s', refresh=%s refresh_index=%s\\n\", self.pathname, relpath,\n                time.strftime(\"%x %X\", time.localtime(refresh)),\n                time.strftime(\"%x %X\", time.localtime(refresh_index)))\n        if relpath and self.cached_include_valid:\n            try:\n                if os.path.getmtime(self.cached_include) >= refresh_index:\n                    dprintf(2, \"using include cache %s\\n\", self.cached_include)\n                    return open(self.cached_include).read()\n                else:\n                    dprintf(2, \"include cache %s out of date, will regenerate\\n\", self.cached_include)\n                    self.cached_include_valid = False\n            except:\n                print(\"Error reading cached include code from %s, will regenerate\" % self.cached_include)\n                if verbosity.get_verbose() > 0:\n                    dprint(1, \"Error traceback follows:\")\n                    traceback.print_exc()\n                self.cached_include_valid = False\n        # form up attributes for % operator\n        attrs = dict(self.__dict__)\n        attrs['timestr'] = time.strftime(\"%x %X\", time.localtime(self.timestamp))\n        attrs['relpath'] = relpath\n        html = \"\"\n        # replace title and comments for ignored entries\n        if self.ignore:\n            attrs['title'] = \"This is not a real log entry\"\n            attrs['comment'] = \"\"\"This entry was saved by PURR because the user\n      chose to ignore and/or banish some data products. PURR has stored this\n      information here for its opwn internal and highly nefarious purposes.\n      This entry is will not appear in the log.\"\"\"\n        # replace < and > in title and comments\n        attrs['title'] = attrs['title'].replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n        # write header if asked\n        if not relpath:\n            icon = Purr.RenderIndex.renderIcon(24, \"..\")\n            html += \"\"\"<HTML><BODY>\n      <TITLE>%(title)s</TITLE>\"\"\" % attrs\n            if self._prev_link or self._next_link or self._up_link:\n                html += \"\"\"<DIV ALIGN=right><P>%s %s %s</P></DIV>\"\"\" % (\n                    (self._prev_link and \"<A HREF=\\\"%s\\\">&lt;&lt;Previous</A>\" % self._prev_link) or \"\",\n                    (self._up_link and \"<A HREF=\\\"%s\\\">Up</A>\" % self._up_link) or \"\",\n                    (self._next_link and \"<A HREF=\\\"%s\\\">Next&gt;&gt;</A>\" % self._next_link) or \"\"\n                )\n            html += (\"<H2>\" + icon + \"\"\" <A CLASS=\"TITLE\" TIMESTAMP=%(timestamp)d>%(title)s</A></H2>\"\"\") % attrs\n        else:\n            icon = Purr.RenderIndex.renderIcon(24)\n            html += \"\"\"\n        <HR WIDTH=100%%>\n        <H2>\"\"\" + icon + \"\"\" %(title)s</H2>\"\"\" % attrs\n        # write comments\n        html += \"\"\"\n        <DIV ALIGN=right><P><SMALL>Logged on %(timestr)s</SMALL></P></DIV>\\n\n\n        <A CLASS=\"COMMENTS\">\\n\"\"\" % attrs\n        # add comments\n        logmode = False\n        for cmt in self.comment.split(\"\\n\"):\n            cmt = cmt.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"&lt;BR&gt;\", \"<BR>\")\n            html += \"\"\"      <P>%s</P>\\n\"\"\" % cmt\n        html += \"\"\"    </A>\\n\"\"\"\n        # add data products\n        if self.dps:\n            have_real_dps = bool([dp for dp in self.dps if not dp.ignored])\n            if have_real_dps:\n                html += \"\"\"\n        <H3>Data products</H3>\n        <TABLE BORDER=1 FRAME=box RULES=all CELLPADDING=5>\\n\"\"\"\n            for dp in self.dps:\n                dpattrs = dict(dp.__dict__)\n                dpattrs['comment'] = dpattrs['comment'].replace(\"<\", \"&lt;\"). \\\n                    replace(\">\", \"&gt;\").replace('\"', \"''\")\n                # if generating complete index, write empty anchor for each DP\n                if not relpath:\n                    if dp.ignored:\n                        html += \"\"\"\n            <A CLASS=\"DP\" SRC=\"%(sourcepath)s\" POLICY=\"%(policy)s\" COMMENT=\"%(comment)s\"></A>\\n\"\"\" % dpattrs\n                    # write normal anchor for normal products\n                    else:\n                        dpattrs['relpath'] = relpath\n                        dpattrs['basename'] = os.path.basename(dp.filename)\n                        html += \"\"\"\n            <A CLASS=\"DP\" FILENAME=\"%(filename)s\" SRC=\"%(sourcepath)s\" POLICY=\"%(policy)s\" QUIET=%(quiet)d TIMESTAMP=%(timestamp).6f RENDER=\"%(render)s\" COMMENT=\"%(comment)s\"></A>\\n\"\"\" % dpattrs\n                # render a table row\n                if not dp.ignored:\n                    renderer = Purr.Render.makeRenderer(dp.render, dp, refresh=refresh)\n                    html += Purr.Render.renderInTable(renderer, relpath)\n            if have_real_dps:\n                html += \"\"\"\n        </TABLE>\"\"\"\n        # write footer\n        if not relpath:\n            html += \"</BODY></HTML>\\n\"\n        else:\n            # now, write to include cache, if being included\n            open(self.cached_include, 'w').write(html)\n            self.cached_include_valid = True\n        return html"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nforce all digits in a list to become integers.", "response": "def juggle_types(data):\n    \"\"\"Force all digits in a list to become integers.\"\"\"\n    # Data is a list of lists (2D) and not a single column table (1D)\n    if isinstance(data[0], list):\n        return [[force_int(col) for col in row] for row in data]\n\n    # Data is 1D\n    elif isinstance(data, list):\n        return [force_int(i) for i in data]\n    else:\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve_path(file_path, calling_function):\n    # No file_path is provided\n    if not file_path:\n        resolved = os.path.join(os.getcwd(), calling_function)\n\n    # String provided that does not a '/', we can assume this is not a path\n    elif file_path.count(os.sep) == 0:\n        resolved = os.path.join(os.getcwd(), file_path)\n\n    # Valid file_path is provided\n    else:\n        resolved = file_path\n\n    # Add .csv file extension\n    if not resolved.endswith('.csv'):\n        resolved = resolved + '.csv'\n    return resolved", "response": "Conditionally set a path to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_calling_file(file_path=None, result='name'):\n    # Get full path of calling python script\n    if file_path is None:\n        path = inspect.stack()[1][1]\n    else:\n        path = file_path\n\n    name = path.split('/')[-1].split('.')[0]\n    if result == 'name':\n        return name\n    elif result == 'path':\n        return path\n    else:\n        return path, name", "response": "Retrieve file_name or file_path of calling Python script\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports data to CSV file.", "response": "def write(self, data, method='w'):\n        \"\"\"\n        Export data to CSV file.\n\n        :param data: Either a list of tuples or a list of lists.\n        :param method: File opening method.\n        \"\"\"\n        # Create list of lists from flat list\n        data = data if isinstance(data[0], (list, set, tuple)) else [[d] for d in data]\n\n        # Open file and write rows\n        with open(self.file_path, method) as write:\n            wr = csv_builtin.writer(write)\n            wr.writerows(data)\n        return self.file_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending rows to an existing CSV file.", "response": "def append(self, data):\n        \"\"\"Append rows to an existing CSV file.\"\"\"\n        # CSV file exists, append rows\n        if os.path.exists(self.file_path):\n            return self.write(data, method='a')\n        # CSV file does NOT exist, create new file and write rows\n        else:\n            return self.write(data, method='w')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading CSV file and returns list of contents", "response": "def read(self):\n        \"\"\"Reads CSV file and returns list of contents\"\"\"\n        # Validate file path\n        assert os.path.isfile(self.file_path), 'No such file exists: ' + str(self.file_path)\n\n        # Open CSV file and read contents\n        with open(self.file_path, 'r') as f:\n            reader = csv_builtin.reader(f)\n            loaded_data = list(reader)\n\n        # Force digits to become integers\n        return juggle_types(loaded_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsort values subject to dependency constraints", "response": "def topological_sort(dependency_pairs):\n    \"Sort values subject to dependency constraints\"\n    num_heads = defaultdict(int)  # num arrows pointing in\n    tails = defaultdict(list)  # list of arrows going out\n    heads = []  # unique list of heads in order first seen\n    for h, t in dependency_pairs:\n        num_heads[t] += 1\n        if h in tails:\n            tails[h].append(t)\n        else:\n            tails[h] = [t]\n            heads.append(h)\n\n    ordered = [h for h in heads if h not in num_heads]\n    for h in ordered:\n        for t in tails[h]:\n            num_heads[t] -= 1\n            if not num_heads[t]:\n                ordered.append(t)\n    cyclic = [n for n, heads in num_heads.items() if heads]\n    return Results(ordered, cyclic)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dmp_to_mdiff(diffs):\n    def yield_buffer(lineno_left, lineno_right):\n        while left_buffer or right_buffer:\n            if left_buffer:\n                left = lineno_left, '\\0-{0}\\1'.format(left_buffer.pop(0))\n                lineno_left += 1\n            else:\n                left = '', '\\n'\n            if right_buffer:\n                right = lineno_right, '\\0+{0}\\1'.format(right_buffer.pop(0))\n                lineno_right += 1\n            else:\n                right = '', '\\n'\n            yield (left, right, True), lineno_left, lineno_right\n\n    lineno_left = lineno_right = 1\n    left_buffer = []\n    right_buffer = []\n\n    for op, data in diffs:\n        for line in data.splitlines(True):\n            if op == DMP.DIFF_EQUAL:\n                for item, lleft, llright in yield_buffer(lineno_left,\n                                                         lineno_right):\n                    lineno_left = lleft\n                    lineno_right = llright\n                    yield item\n                yield (lineno_left, line), (lineno_right, line), False\n                lineno_left += 1\n                lineno_right += 1\n            elif op == DMP.DIFF_DELETE:\n                left_buffer.append(line)\n            elif op == DMP.DIFF_INSERT:\n                right_buffer.append(line)\n\n    for item, _, _ in yield_buffer(lineno_left, lineno_right):\n        yield item", "response": "Convert from diff_match_patch format to _mdiff format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _make_diff(self, correct, given):\n        dmp = DMP()\n        dmp.Diff_Timeout = 4\n        text1, text2, array = dmp.diff_linesToChars(correct, given)\n        diffs = dmp.diff_main(text1, text2)\n        dmp.diff_cleanupSemantic(diffs)\n        dmp.diff_charsToLines(diffs, array)\n        return list(dmp_to_mdiff(diffs))", "response": "Return the intermediate representation of the diff."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next_splitter_or_func(string, splitters, func, pseudo_type):\n    if splitters:\n        return splitters[0](string, splitters[1:])(func)(pseudo_type,\n            string)\n    else:\n        return func(pseudo_type, string)", "response": "Helper for doing the next splitter check."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef precondition(self):\n        return self.tlang.nplurals == self.slang.nplurals and \\\n                super(PrintfValidator, self).precondition()", "response": "Check if the number of plurals in the two languages is the same."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a path to a normalized format", "response": "def convert_path(path):\n    \"\"\"\n    Convert path to a normalized format\n    \"\"\"\n    if os.path.isabs(path):\n        raise Exception(\"Cannot include file with absolute path {}. Please use relative path instead\".format((path)))\n\n    path = os.path.normpath(path)\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_job_config(config):\n    try:\n        # Every job has name\n        if config['config']['job']['name'] is not None:\n            return True\n    except KeyError:\n        return False\n    except TypeError:\n        return False\n    except IndexError:\n        return False\n\n    return False", "response": "Check whether given dict of config is job config"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclusters user sessions from a sequence of user events. Note that, `event` data will simply be returned in the case of a revert. This function serves as a convenience wrapper around calls to :class:`~mw.lib.sessions.Cache`'s :meth:`~mw.lib.sessions.Cache.process` method. :Parameters: user_events : iter( (user, timestamp, event) ) an iterable over tuples of user, timestamp and event data. * user : `hashable` * timestamp : :class:`mw.Timestamp` * event : `mixed` cutoff : int the maximum time between events within a user session :Returns: a iterator over :class:`~mw.lib.sessions.Session` :Example: >>> import mwsessions >>> >>> user_events = [ ... (\"Willy on wheels\", 20150101000000, {'rev_id': 1}), ... (\"Walter\", 20150101000001, {'rev_id': 2}), ... (\"Willy on wheels\", 20150101000001, {'rev_id': 3}), ... (\"Walter\", 100035, {'rev_id': 4}), ... (\"Willy on wheels\", 103602, {'rev_id': 5}) ... ] >>> >>> for user, events in mwsessions.sessionize(user_events): ... (user, events) ... ('Willy on wheels', [{'rev_id': 1}, {'rev_id': 3}]) ('Walter', [{'rev_id': 2}, {'rev_id': 4}]) ('Willy on wheels', [{'rev_id': 5}])", "response": "def sessionize(user_events, cutoff=defaults.CUTOFF):\n    \"\"\"\n    Clusters user sessions from a sequence of user events.  Note that,\n    `event` data will simply be returned in the case of a revert.\n\n    This function serves as a convenience wrapper around calls to\n    :class:`~mw.lib.sessions.Cache`'s :meth:`~mw.lib.sessions.Cache.process`\n    method.\n\n    :Parameters:\n        user_events : iter( (user, timestamp, event) )\n            an iterable over tuples of user, timestamp and event data.\n\n            * user : `hashable`\n            * timestamp : :class:`mw.Timestamp`\n            * event : `mixed`\n\n        cutoff : int\n            the maximum time between events within a user session\n\n    :Returns:\n        a iterator over :class:`~mw.lib.sessions.Session`\n\n    :Example:\n        >>> import mwsessions\n        >>>\n        >>> user_events = [\n        ...     (\"Willy on wheels\", 20150101000000, {'rev_id': 1}),\n        ...     (\"Walter\", 20150101000001, {'rev_id': 2}),\n        ...     (\"Willy on wheels\", 20150101000001, {'rev_id': 3}),\n        ...     (\"Walter\", 100035, {'rev_id': 4}),\n        ...     (\"Willy on wheels\", 103602, {'rev_id': 5})\n        ... ]\n        >>>\n        >>> for user, events in mwsessions.sessionize(user_events):\n        ...     (user, events)\n        ...\n        ('Willy on wheels', [{'rev_id': 1}, {'rev_id': 3}])\n        ('Walter', [{'rev_id': 2}, {'rev_id': 4}])\n        ('Willy on wheels', [{'rev_id': 5}])\n\n\n    \"\"\"\n\n    # Construct the session manager\n    sessionizer = Sessionizer(cutoff)\n\n    # Apply the events\n    for user, timestamp, event in user_events:\n\n        for session in sessionizer.process(user, timestamp, event):\n            yield session\n\n    # Yield the left-overs\n    for session in sessionizer.get_active_sessions():\n        yield session"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xml_import(self,\n                   filepath=\"\",\n                   xml_content=None,\n                   markings=None,\n                   identifier_ns_uri=None,\n                   **kwargs):\n        \"\"\"\n         Import a STIX or CybOX xml  from file <filepath> or a string passed as ``xml_content``\n\n         You can furhter provide:\n\n         - a list of InfoObjects as markings with which all generated Information Objects\n            will be associated (e.g., in order to provide provenance function)\n         - a default identifier namespace URI.\n\n         The kwargs are not read -- they are present to allow the use of the\n         DingoImportCommand class for easy definition of commandline import commands\n         (the class passes all command line arguments to the xml_import function, so\n         without the **kwargs parameter, an error would occur.\n         \"\"\"\n\n        # Clear internal state such that same object can be reused for\n        # multiple imports.\n\n\n        if 'default_timestamp' in kwargs and kwargs['default_timestamp']:\n\n            if isinstance(kwargs['default_timestamp'],basestring):\n                naive = parse_datetime(kwargs['default_timestamp'])\n            else:\n                naive = kwargs['default_timestamp']\n            if not timezone.is_aware(naive):\n                aware = timezone.make_aware(naive,timezone.utc)\n            else:\n                aware = naive\n            self.default_timestamp = aware\n\n\n        self.namespace_dict = {None: DINGOS_NAMESPACE_URI}\n\n        self.default_identifier_ns_uri = None\n\n        self.default_identifier_ns_uri = identifier_ns_uri\n\n        if not markings:\n            markings = []\n\n\n\n\n\n        # Use the generic XML import customized for STIX/CybOX import\n        # to turn XML into DingoObjDicts\n\n        import_result = MantisImporter.xml_import(xml_fname=filepath,\n                                                  xml_content=xml_content,\n                                                  ns_mapping=self.namespace_dict,\n                                                  embedded_predicate=self.stix_embedding_pred,\n                                                  id_and_revision_extractor=self.id_and_revision_extractor)\n\n\n\n\n\n        # The MANTIS/DINGOS xml importer returns then the following structure::\n        #\n        #\n        #    {'id_and_rev_info': Id and revision info of top-level element of the form\n        #        {'id': ... , 'timestamp': ...}\n        #    'elt_name': Element name of top-level element\n        #    'dict_repr': Dictionary representation of XML, minus the embedded objects -- for\n        #                 those, an 'idref' reference has been generated\n        #    'embedded_objects': List of embedded objects, as dictionary\n        #                       {\"id_and_revision_info\": id and revision info of extracted object,\n        #                        \"elt_name\": Element name,\n        #                        \"dict_repr\" :  dictionary representation of XML of embedded object\n        #                       }\n        #    'unprocessed' : List of unprocessed embedded objects (as libxml2 Node object)\n        #                    (e.g. for handover to other importer\n        #    'file_content': Content of imported file (or, if content was passed instead of a file name,\n        #                                                                                         the original content)}\n\n\n        # Extract information from import result\n\n        top_level_id_and_rev_info = import_result['id_and_rev_info']\n        top_level_elt_name = import_result['elt_name']\n        top_level_elt_dict = import_result['dict_repr']\n        file_content = import_result['file_content']\n        embedded_objects = import_result['embedded_objects']\n        unprocessed_list = import_result['unprocessed']\n\n\n        if not 'id' in top_level_id_and_rev_info or not top_level_id_and_rev_info['id']:\n            if self.default_identifier_ns_uri:\n                # Top-level element had no identifier. If a default namespace has been provided,\n                # then an identifier is generated\n                top_level_id_and_rev_info['id_ns'] = self.default_identifier_ns_uri\n                top_level_id_and_rev_info['id_uid'] = hashlib.md5(file_content).hexdigest()\n                logger.info(\"Top level element had no identifier: \"\n                            \"identifier %s has been generated \" % top_level_id_and_rev_info['id_uid'])\n\n            else:\n                logger.warning(\"Top level element had no identifier. \"\n                    \"No identifier was generated, because no default namespace had been provided \"\n                    \"(you can provide a namespace with the '-n' commandline parameter\")\n\n        # We now have the top-level object, the list of embedded objects,\n        # and possibly a list of hitherto unprocessed XML nodes.\n        # As we shall see below, we have configured the DINGOS\n        # XML  importer such that it extracts marking structures\n        # as separate objects and tags them with a label\n        # 'import_first'. So, what we need to do is to go through\n        # the embedded objects and collect all markings (along with\n        # information, in which STIX_Package each marking was defined).\n        # This allows us to first create all marking objects and\n        # then mark the subsequently created objects with the\n        # appropriate markings.\n        # Note, that currently,\n        # - we only extract and treat markings defined in the header of STIX_Package\n        # - we do not care about the XPATH-expression and treat every marking as if\n        #   it was defined for the whole STIX-Package\n\n        marking_dict = {}\n\n        # We use queues rather than lists, since we have no need\n        # to access elements somewhere in the list, but rather\n        # always pop from the end\n\n        import_first_queue = deque()\n\n        pending_queue = deque()\n\n        # The top-level object is certainly no marking, so we\n        # put it on the pending queue\n\n        pending_queue.append((top_level_id_and_rev_info, top_level_elt_name, top_level_elt_dict))\n\n        while embedded_objects:\n            # We go through the embedded objects and look for the 'import_first' label\n            embedded_object = embedded_objects.pop()\n            id_and_rev_info = embedded_object['id_and_rev_info']\n            elt_name = embedded_object['elt_name']\n            elt_dict = embedded_object['dict_repr']\n            if 'import_first' in id_and_rev_info:\n                import_first_queue.append((id_and_rev_info, elt_name, elt_dict))\n            else:\n                pending_queue.append((id_and_rev_info, elt_name, elt_dict))\n\n\n        while import_first_queue:\n            # We go through the import_first queue, import all markings,\n            # and collect information about the STIX_Package in which the marking\n            # was defined in the marking_dict (some organizations use a format\n            # in which several STIX Packages are bundled into a single XML file).\n\n            (id_and_rev_info, elt_name, elt_dict) = import_first_queue.pop()\n\n\n            (info_obj, existed) = self.iobject_import(id_and_rev_info,\n                                                      elt_name,\n                                                      elt_dict)\n\n            # id_and_rev_info can carries additional information other than the identifier\n            # and timestamp that has been extracted: the MANTIS XML importer carries\n            # along information inherited from ancestor objects: this allows us\n            # to propagate information down to children, grandchildren etc. As we\n            # see below, we use this mechanism to propagate information about\n            # the STIX_Package in which an object was defined.\n\n            if id_and_rev_info['inherited']['embedding_STIX_Package'] in marking_dict:\n                marking_dict[id_and_rev_info['inherited']['embedding_STIX_Package']].append(info_obj)\n            else:\n                marking_dict[id_and_rev_info['inherited']['embedding_STIX_Package']] = [info_obj]\n\n\n        while pending_queue:\n            # Now we start the import of the remaining embedded objects (plus the top-level object)\n\n            (id_and_rev_info, elt_name, elt_dict) = pending_queue.pop()\n\n            if 'embedding_STIX_Package' in id_and_rev_info:\n                embedding_STIX_Package = id_and_rev_info['embedding_STIX_Package']\n            else:\n                embedding_STIX_Package = id_and_rev_info.get('inherited',{}).get('embedding_STIX_Package')\n\n            logger.debug(\"%s embedded in %s\" % (id_and_rev_info['id'], embedding_STIX_Package))\n\n\n            if elt_name in ['Kill_Chain','Kill_Chain_Phase']:\n                # We chose not to attach markings to Kill_Chain information\n                object_markings = []\n            else:\n                # We mark the object with markings passed to the xml_import command\n                # and markings defined in the STIX_Package in which the object was defined.\n\n                object_markings = markings + marking_dict.get(embedding_STIX_Package,[])\n\n            self.iobject_import(id_and_rev_info,\n                                elt_name,\n                                elt_dict,\n                                markings=object_markings)\n\n        # As we shall see below, we have configured the xml_importer such that\n        # it recognizes OpenIOC structures embedded as test mechanism and\n        # leaves them unprocessed. These unprocessed elements we now hand\n        # over to the MANTIS OpenIOC importer.\n\n        for unprocessed_elt in unprocessed_list:\n            (id_and_rev_info,typeinfo,xml_node) = unprocessed_elt\n            processor_class = self.processors.get(id_and_rev_info['defer_processing']['processor'],None)\n\n\n            if 'embedding_STIX_Package' in id_and_rev_info:\n                embedding_STIX_Package = id_and_rev_info['embedding_STIX_Package']\n            else:\n                embedding_STIX_Package = id_and_rev_info.get('inherited',{}).get('embedding_STIX_Package')\n\n            logger.debug(\"%s embedded in %s\" % (id_and_rev_info['id'], embedding_STIX_Package))\n\n            object_markings = markings + marking_dict.get(embedding_STIX_Package,[])\n\n            if processor_class:\n\n                processor = processor_class(namespace_dict=self.namespace_dict)\n\n                processor.xml_import(self,\n                                     xml_content=xml_node,\n                                     markings=object_markings,\n                                     identifier_ns_uri=self.namespace_dict[id_and_rev_info['id'].split(':')[0]],\n                                     initialize_importer=False\n                )\n            else:\n                logger.error(\"Did not find a processor for %s\" % id_and_rev_info['defer_processing']['processor'])", "response": "This function imports a STIX or CybOX XML file into a DingoObjDicts object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions for determining an identifier and revision for extracted embedded content ; id_and_revision_extractor is called by the xml - import hook id_and_revision_extractor.", "response": "def id_and_revision_extractor(self, xml_elt):\n        \"\"\"\n        Function for determining an identifier (and, where applicable, timestamp/revision\n        information) for extracted embedded content;\n        to be used for DINGO's xml-import hook 'id_and_revision_extractor'.\n\n        This function is called\n\n        - for the top-level node of the XML to be imported.\n\n        - for each node at which an embedded object is extracted from the XML\n          (when this occurs is governed by the following function, the\n          embedding_pred\n\n        It must return an identifier and, where applicable, a revision and or timestamp;\n        in the form of a dictionary {'id':<identifier>, 'timestamp': <timestamp>}.\n        How you format the identifier is up to you, because you will have to adopt\n        the code in function xml_import such that the Information Objects\n        are created with the proper identifier (consisting of qualifying namespace\n        and uri.)\n\n        Note: the xml_elt is an XMLNode defined by the Python libxml2 bindings. If you\n        have never worked with these, have a look at\n\n        - Mike Kneller's brief intro: http://mikekneller.com/kb/python/libxml2python/part1\n        - the functions in django-dingos core.xml_utils module\n\n        \"\"\"\n        result = {'id': None,\n                  'timestamp': None,\n        }\n\n\n        if xml_elt.properties:\n            attributes = extract_attributes(xml_elt, prefix_key_char='@')\n            # Extract identifier:\n            if '@id' in attributes:\n                result['id'] = attributes['@id']\n            elif '@object_reference' in attributes:\n                # 'object_reference' is used as follows::\n                #\n                #     (...)\n                #     <EmailMessageObj:Attachments>\n                #           <EmailMessageObj:File xsi:type=\"FileObj:FileObjectType\"\n                #              object_reference=\"cybox:object-3cf6a958-5c3f-11e2-a06c-0050569761d3\"/>\n                #     </EmailMessageObj:Attachments>\n                #     (...)\n                result['id'] = attributes['@object_reference']\n\n            elif '@phase_id' in attributes:\n                result['id'] = attributes['@phase_id']\n                result['extract_empty_embedded'] = True\n\n\n            # Unfortunately, STIX/Cybox do not allow for addition of revision/timestamp information\n            # along with the identifier of an object. If that does not change, we might start to use\n            # a modified version of STIX/CybOX,\n            # that allows 'revision_timestamp' information in an attribute whereever an 'id' or 'idref' attribute\n            # is allowed.\n            # We use a modified version of STIX/CybOX, in which each identifyable object can also carry\n            # an attribute 'revision_timestamp'. We cannot use 'timestamp', because there\n            # are CybOX elements such as 'Action' that carry a timestamp attribute with a different\n            # semantic (the timestamp refers to the action, not the CybOX document)\n\n            #if '@revision_timestamp' in attributes:\n            #    result['timestamp'] = attributes['@revision_timestamp']\n\n        if xml_elt.name == 'STIX_Package':\n\n            result['embedding_STIX_Package'] = result['id']\n\n            #setContextNode(node)\n            #ctxt = xml_elt.xpathNewContext()\n            timestamp_text = xml_elt.xpathEval(\"./*[contains(name(),'STIX_Header')]/*[contains(name(),'Information_Source')]\"\n                                      \"/*[contains(name(),'Time')]/*[contains(name(),'Produced_Time')]/text()\") #[id=%s]/Information_Source\" % result['id'])\n            #ctxt.xpathFreeContext()\n\n\n            if timestamp_text:\n                timestamp_string = timestamp_text[0].getContent().strip()\n                naive = parse_datetime(timestamp_string)\n                if naive:\n                    # Make sure that information regarding the timezone is\n                    # included in the time stamp. If it is not, we chose\n                    # utc as default timezone: if we assume that the same\n                    # producer of OpenIOC data always uses the same timezone\n                    # for filling in the 'last-modified' attribute, then\n                    # this serves the main purpose of time stamps for our\n                    # means: we can find out the latest revision of a\n                    # given piece of data.\n                    if not timezone.is_aware(naive):\n                        aware = timezone.make_aware(naive,timezone.utc)\n                    else:\n                        aware = naive\n                    result['timestamp']= aware\n\n\n\n\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stix_embedding_pred(self, parent, child, ns_mapping):\n\n        def extract_typeinfo(child):\n            \"\"\"\n            When recognizing an embedding object, we try to find out what\n            kind of object it is\n            \"\"\"\n\n            # Let's try to find a grandchild and return the namespace of this grandchild:\n            # This can be used as indicator for the object type that is referenced here.\n\n            # Let's further try to find a grandchild (if there is one)\n\n            grandchild = child.children\n            type_info = None\n\n            while grandchild is not None:\n                try:\n                    grandchild_attrs = extract_attributes(grandchild, prefix_key_char='')\n                    if 'xsi:type' in grandchild_attrs and grandchild.name=='Properties':\n                        type_info = grandchild_attrs['xsi:type'].split(':')[0]\n                    else:\n                        type_info = grandchild.ns().name\n                    break\n\n                except:\n                    # This catches if the grandchild does not have a namespace\n                    grandchild = grandchild.next\n            if type_info:\n                logger.debug(\"Found type info %s\" % type_info)\n                return type_info\n            else:\n                logger.debug(\"Embedding, but did not find type info\")\n                return True\n\n        child_attributes = extract_attributes(child, prefix_key_char='')\n\n        parent_attrs = extract_attributes(parent, prefix_key_char='')\n\n\n        # We start with some special cases. If we find\n        # OpenIOC content in a test mechanism, we use the embedded-predicate\n        # to pass along additional information: by setting the key 'defer_processing'\n        # in the 'id_and_revision_info', we tell the DINGOS xml_importer to\n        # return the child element unprocessed.\n\n        if parent.name=='Test_Mechanism':\n            if 'xsi:type' in parent_attrs:\n                if 'OpenIOC2010TestMechanismType' in parent_attrs['xsi:type']:\n                    # We have an embedded OpenIOC document.\n\n                    # We extract id and revision info and tag it for deferred treatement\n                    id_and_revision_info = OpenIOC_Importer.id_and_revision_extractor(child)\n                    id_and_revision_info['defer_processing'] = {'processor': 'OpenIOC2010'}\n                    logger.debug(\"XXX: Found OpenIOC with %s\" % id_and_revision_info)\n                    return {'embedded_ns':child.ns().name,\n                            'id_and_revision_info':id_and_revision_info}\n\n\n\n        if parent.name=='Kill_Chain' and child.name=='Kill_Chain_Phase':\n            # We also extract kill-chain phases. Not sure whether that\n            # is the best idea, though.\n            logger.debug(\"Found killchain phase %s\" % extract_typeinfo(child))\n            return extract_typeinfo(child)\n\n\n        if parent.name=='Handling' and child.name=='Marking' and parent.get_parent().name =='STIX_Header':\n\n            # We also cut out Markings, because we need an InfoObject with the Marking\n            # contents in order to create markings for the import.\n            # We seed the id_and_revision info for this object with a tag 'import_first',\n            # which will be read later below in the xml_import function: marking objects\n            # will be imported first and a marking dictionary will provide information on\n            # which STIX Package provided which marking.\n\n            # Markings do not carry identifiers. The xml_importer will automagically create\n            # an identifier derived from the identifier of the encompassing object.\n\n            return {'embedded_ns': extract_typeinfo(child),\n                    'id_and_revision_info' : {'import_first': True}}\n\n        # Finally, the standard case: an 'id' attribute signifies\n        # an embedded object that we want to extract.\n        if ('id' in child_attributes):\n            return extract_typeinfo(child)\n\n        # 'object_reference' is used in Cybox as follows::\n        #\n        #     (...)\n        #     <EmailMessageObj:Attachments>\n        #           <EmailMessageObj:File xsi:type=\"FileObj:FileObjectType\"\n        #              object_reference=\"cybox:object-3cf6a958-5c3f-11e2-a06c-0050569761d3\"/>\n        #     </EmailMessageObj:Attachments>\n        #     (...)\n        #\n        # That is actually a reference, but we need to turn it into an '@idref'-reference.\n        # By treating the 'File' object-reference as an embedded object, this is done\n        # automatically, because the xml_importer replaces embedded content with\n        # '@idref'-based references.\n\n        if 'object_reference' in child_attributes:\n            return extract_typeinfo(child)\n\n        if child.name=='Object' and not 'idref' in child_attributes:\n            # Unfortunately, e.g., the example files created by MITRE from Mandiant reports\n            # and OpenIOCs give an identifier to an observable, but not to the\n            # object embedded in the observable. We, however, need an identifier for\n            # the object, because otherwise the whole machinery that infers an object's\n            # type does not work. So, if we find an object without identifier that\n            # is embedded in an observable with identifier, we also want to extract\n            # the object ... and need to derive the object identifier from the\n            # observable identifier. This is done automagically by the xml_import\n            # function itself.\n\n            return extract_typeinfo(child)\n        return False", "response": "Predicate for recognizing inlined content in an XML object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attr_ignore_predicate(self, fact_dict):\n        if not fact_dict['attribute']:\n            return False\n\n        if '@' in fact_dict['attribute']: # and not fact_dict['attribute'] == '@ns':\n            # We remove all attributes added by Dingo during import\n\n            #if (fact_dict['attribute']=='@ns'\n            #    and\n            #        (('extension' in fact_dict['value']\n            #         or\n            #         ((not 'stix' in fact_dict['value'])\n            #         and\n            #         (not 'cybox' in fact_dict['value'])\n            #         )\n            #         )\n            #        )\n            #):\n            #    return False\n            #else:\n            #    return True\n\n            return True\n\n        attr_key = fact_dict['attribute']\n\n        cybox_attr_ignore_list = [# we drop id-attributes:\n                                  # everything that has an identifier gives rise to a new object and\n                                  # the identifier is used then and there,\n                                  'id' ,\n                                  'object_reference',\n                                  'idref',\n                                  # Type information we have already read and treated,\n                                  # so no need to keep it around\n\n                                  'datatype',\n                                  'type',\n                                  # value_set attributes are treated by a special handler\n                                  'value_set',\n                                  # no need to retain the schemaLocation info on top-level.\n                                  'xsi:schemaLocation'\n        ]\n\n        if attr_key in cybox_attr_ignore_list:\n            return True\n\n        if attr_key == 'xsi:type':\n\n            if fact_dict['term']== 'Properties':\n                # We only keep xsi:type information that is not on top-level of an object\n                # (if it was on top-level, we have integrated the information into\n                # the namespace of the InfoObject anyhow).\n                return True\n            if fact_dict.get('number_of_attributed_elements',0) == 0 and not 'Marking_Structure' in fact_dict['term']:\n                # We only keep xsi_type info in a node that has children: otherwise, the xsi:type\n                # refers to the type of the value in the element, and that we are already treating\n                # in the datatype_extractor. Exception: the Marking_Structures defined by MITRE\n                # do not contain subelements, but we want to keep the xsi:type information around.\n\n                return True\n\n        if 'Kill_Chain_Phases' in fact_dict['term'] and not fact_dict['attribute'] in ['phase_id','kill_chain_id']:\n            return True\n\n\n        return False", "response": "This function returns True if the attribute is not present in the attribute_dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nseparate the namespace from the identifier in a qualified name and lookup the namespace URI associated with the given namespace.", "response": "def split_qname(self, cybox_id):\n        \"\"\"\n        Separate the namespace from the identifier in a qualified name and lookup the namespace URI associated\n        with the given namespace.\n        \"\"\"\n        if ':' in cybox_id:\n            (namespace, uid) = cybox_id.split(':', 1)\n        else:\n            namespace = None\n            uid = cybox_id\n\n        if namespace and namespace in self.namespace_dict:\n            namespace_uri = self.namespace_dict[namespace]\n        else:\n            logger.warning(\"Could not retrieve namespace for identifier %s\" % (cybox_id))\n            # TODO: Introduce configurable URI\n            namespace_uri = None\n\n        if not namespace_uri:\n            if self.default_identifier_ns_uri:\n                namespace_uri = self.default_identifier_ns_uri\n            else:\n                namespace_uri = \"%s/%s\" % (DINGOS_MISSING_ID_NAMESPACE_URI_PREFIX, namespace)\n\n        return (namespace, namespace_uri, uid)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nderive type of information object from an embedded element.", "response": "def derive_iobject_type(self, embedding_ns, embedded_ns, elt_name):\n        \"\"\"\n        Derive type of information object stemming from an embedded element\n        based on namespace information of embedding element, the embedded\n        element itself, and the name of the element.\n\n        \"\"\"\n\n\n        # Extract namespace-information\n\n        ns_info = search_by_re_list(self.RE_LIST_NS_TYPE_FROM_NS_URL, self.namespace_dict.get(embedding_ns, \"\"))\n\n        if not ns_info:\n            ns_info = {}\n\n        # This should yield the following information:\n        # - For namespace of an Cybox Object such as http://cybox.mitre.org/objects#AddressObject-2:\n        #   - iotype_ns = http://cybox.mitre.org/objects#AddressObject\n        #   - family = cybox.mitre.org\n        #   - family_tag = cybox\n        #   - type = AddressObject\n        #   - revision = 2\n        # - For a base namespace such as http://cybox.mitre.org/common-2:\n        #   - iotype_ns = http://cybox.mitre.org/common\n        #   - family = cybox.mitre.org\n        #   - family_tag = cybox\n        #   - type = common\n        #   - revision = 2\n\n        iobject_family_name = ns_info.get('family',None)\n        if not iobject_family_name:\n            iobject_family_name = \"\"\n        family_info = {}\n\n        if ns_info.get('family_tag',None) in ['stix', 'cybox']:\n            family_info = search_by_re_list(self.RE_LIST_NS_TYPE_FROM_NS_URL,\n                                            self.namespace_dict.get(ns_info['family_tag'], \"\"))\n            if family_info:\n                iobject_family_revision_name = family_info[\"revision\"]\n            else:\n                iobject_family_revision_name = None\n\n        else:\n            iobject_family_revision_name = ns_info.get(\"revision\",None)\n        if not iobject_family_revision_name:\n            iobject_family_revision_name = ''\n\n        # We take the object type from the ``xsi:type`` attribute\n        # given as in the following example::\n        #    <cybox:Properties xsi:type=\"EmailMessageObj:EmailMessageObjectType\">\n        #    <cybox:Properties xsi:type=\"AddrObj:AddressObjectType\" category=\"ipv4-addr\">\n        #\n        if embedded_ns:\n            namespace_uri = self.namespace_dict.get(embedded_ns, \"\")\n            type_info = search_by_re_list(self.RE_LIST_NS_TYPE_FROM_NS_URL, namespace_uri)\n            if not type_info:\n                type_info = {}\n            if type_info and type_info.get('type',None) in ['common', 'cybox', 'stix']:\n                iobject_type_name = elt_name\n                iobject_type_namespace_uri = ns_info['iotype_ns']\n                iobject_type_revision_name = ns_info['revision']\n            else:\n                iobject_type_namespace_uri = type_info.get('iotype_ns',\"%s/%s\" % (dingos.DINGOS_MISSING_ID_NAMESPACE_URI_PREFIX,embedded_ns))\n                iobject_type_name = type_info.get('type',embedded_ns)#.split('Object')[0]\n                iobject_type_revision_name = type_info.get('revision','')\n\n        else:\n            iobject_type_name = elt_name\n            iobject_type_revision_name = iobject_family_revision_name\n            iobject_type_namespace_uri = ns_info.get(\"iotype_ns\", \"%s/%s\" % (dingos.DINGOS_MISSING_ID_NAMESPACE_URI_PREFIX,elt_name))\n\n\n        if not iobject_type_revision_name:\n            iobject_type_revision_name = ''\n\n        logger.debug(\"Results of datatype extraction for ns %s, embedded ns %s and element name %s\" % (\n        embedding_ns, embedded_ns, elt_name))\n        logger.debug(\"Family Name: %s\" % iobject_family_name)\n        logger.debug(\"Family Revision %s\" % iobject_family_revision_name)\n        logger.debug(\"Type Name %s\" % iobject_type_name)\n        logger.debug(\"Type NS URI %s\" % iobject_type_namespace_uri)\n        logger.debug(\"Type Revision %s\" % iobject_type_revision_name)\n\n        return {'iobject_type_name': iobject_type_name,\n                'iobject_type_revision_name': iobject_type_revision_name,\n                'iobject_type_namespace_uri': iobject_type_namespace_uri,\n                'iobject_family_name': iobject_family_name,\n                'iobject_family_revision_name': iobject_family_revision_name}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iobject_import(self,\n                       id_and_rev_info,\n                       elt_name,\n                       obj_dict,\n                       markings=None,\n                       cybox_id=None):\n        \"\"\"\n        Derives InfoObjectType and import InfoObjectType\n\n        \"\"\"\n\n        iobject_type_ns = None\n\n        # Derive the namespace information\n        if ('@xsi:type' in obj_dict or\n                    '@@embedded_type_info' in obj_dict or\n                    '@xsi:type' in obj_dict.get('Properties', {}) or\n                    '@xsi:type' in obj_dict.get('Defined_Object', {}) ):\n            if '@xsi:type' in obj_dict:\n                iobject_type_ns = obj_dict['@xsi:type'].split(':')[0]\n            elif '@xsi:type' in obj_dict.get('Properties', {}):\n                iobject_type_ns = obj_dict['Properties']['@xsi:type'].split(':')[0]\n            elif '@xsi:type' in obj_dict.get('Defined_Object', {}):\n                iobject_type_ns = obj_dict['Defined_Object']['@xsi:type'].split(':')[0]\n            else:\n                iobject_type_ns = obj_dict['@@embedded_type_info']\n\n        # Find out what the type of the Information Object to be created should be\n        type_info = self.derive_iobject_type(obj_dict['@@ns'], iobject_type_ns, elt_name)\n\n        if (not 'id' in id_and_rev_info or not id_and_rev_info['id']) and (not 'id_ns' in id_and_rev_info):\n            logger.info(\"Object of type %s without id information encountered, skipping\" % elt_name)\n            return\n        if 'id_ns' in id_and_rev_info:\n            namespace_uri = id_and_rev_info['id_ns']\n            uid = id_and_rev_info['id_uid']\n        else:\n            (namespace, namespace_uri, uid) = self.split_qname(id_and_rev_info['id'])\n\n        object_timestamp = id_and_rev_info.get('timestamp',None)\n        if not object_timestamp:\n            object_timestamp = self.default_timestamp\n\n        (info_obj, existed) = MantisImporter.create_iobject(iobject_family_name=type_info['iobject_family_name'],\n                                                            iobject_family_revision_name=type_info[\n                                                                'iobject_family_revision_name'],\n                                                            iobject_type_name=type_info['iobject_type_name'],\n                                                            iobject_type_namespace_uri=type_info[\n                                                                'iobject_type_namespace_uri'],\n                                                            iobject_type_revision_name=type_info[\n                                                                'iobject_type_revision_name'],\n                                                            iobject_data=obj_dict,\n                                                            uid=uid,\n                                                            identifier_ns_uri=namespace_uri,\n                                                            timestamp= object_timestamp,\n                                                            create_timestamp=self.create_timestamp,\n                                                            markings=markings,\n                                                            config_hooks={\n                                                            'special_ft_handler': self.fact_handler_list(),\n                                                            'datatype_extractor': self.cybox_datatype_extractor,\n                                                            'attr_ignore_predicate': self.attr_ignore_predicate,\n                                                            'force_nonleaf_fact_predicate': self.force_nonleaf_fact_predicate},\n                                                            namespace_dict=self.namespace_dict,\n        )\n\n        return (info_obj, existed)", "response": "This function takes an info object and imports it into the InfoObject object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_radl(data):\n\n    if data is None:\n        return None\n    elif os.path.isfile(data):\n        f = open(data)\n        data = \"\".join(f.readlines())\n        f.close()\n    elif data.strip() == \"\":\n        return RADL()\n    data = data + \"\\n\"\n\n    parser = RADLParser(lextab='radl')\n    return parser.parse(data)", "response": "Parse a RADL document."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef t_NUMBER(self, t):\n        r'\\d+\\.?\\d*'\n        if t.value.find(\".\") != -1:\n            t.value = float(t.value)\n        else:\n            t.value = int(t.value)\n        return t", "response": "r \\ d + \\. \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d + \\ d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef p_contextualize_item(self, t):\n\n        if len(t) == 5:\n            t[0] = contextualize_item(t[2], t[4], line=t.lineno(1))\n        elif t[5] == \"with\":\n            t[0] = contextualize_item(t[2], t[4], ctxt_tool=t[6], line=t.lineno(1))\n        else:\n            t[0] = contextualize_item(t[2], t[4], num=t[6], line=t.lineno(1))", "response": "P - contextualize_item | Contextualize the item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_ansible_sentence(self, t):\n\n        t[0] = ansible(t[2], t[4], line=t.lineno(1))", "response": "A token is a set of ansible identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_system_sentence(self, t):\n\n        if len(t) == 3:\n            t[0] = system(t[2], reference=True, line=t.lineno(1))\n        else:\n            t[0] = system(t[2], t[4], line=t.lineno(1))", "response": "P - system - sentence parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfeature = features AND feature = feature | empty", "response": "def p_features(self, t):\n        \"\"\"features : features AND feature\n                    | feature\n                    | empty\"\"\"\n\n        if len(t) == 4:\n            t[0] = t[1]\n            t[0].append(t[3])\n        elif t[1]:\n            t[0] = [t[1]]\n        else:\n            t[0] = []"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_feature_soft(self, t):\n\n        t[0] = SoftFeatures(t[2], t[4], line=t.lineno(1))", "response": "P FEATURE SOFT NUMBER LPAREN features RPAREN"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_feature_simple(self, t):\n\n        if len(t) == 6:\n            t[0] = Feature(t[1], t[2], t[4], line=t.lineno(1))\n        elif len(t) == 5:\n            t[0] = Feature(t[1], t[2], t[3], unit=t[4], line=t.lineno(1))\n        elif len(t) == 4:\n            t[0] = Feature(t[1], t[2], t[3], line=t.lineno(1))", "response": "p_feature_simple - Parses the feature_simple section of the grammar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef p_string_list(self, t):\n\n        if len(t) == 4:\n            t[0] = t[1]\n            t[0].append(t[3])\n        elif t[1]:\n            t[0] = [t[1]]\n        else:\n            t[0] = []", "response": "p_string_list : string_list COMMA STRING\n                       | empty STRING\n                       | empty"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a Seeder s structure to the internal structure used at frontend.", "response": "def _convert_to_wakat_format(seeder_struct):\n    \"\"\"\n    Convert Seeder's structure to the internal structure used at frontend.\n\n    Args:,\n        seeder_struct (dict): Dictionary with Seeder data.\n\n    Returns:\n        obj: :class:`Model`.\n    \"\"\"\n    def pick_active(seeder_struct, what):\n        \"\"\"\n        From the list of dicts, choose only first of such, that contains\n        ``\"active\": True`` item.\n\n        If not found, just pick the first.\n\n        Args:\n            seeder_struct (dict): Dict with bunch of data.\n            what (str): What key to use in `seeder_struct` to identify the\n                list of dicts.\n\n        Returns:\n            dict: Active or first dict.\n        \"\"\"\n        items = seeder_struct.get(what)\n\n        if not items:\n            return None\n\n        if not (isinstance(items, list) or isinstance(items, tuple)):\n            items = [items]\n\n        active_items = [item for item in items if item.get(\"active\")]\n\n        if not active_items:\n            return items[0]\n\n        return active_items[0]\n\n    if not seeder_struct:\n        return None\n\n    # pick active seed and active publisher\n    active_seed = pick_active(seeder_struct, \"seeds\")\n    publisher_contact = pick_active(\n        seeder_struct.get(\"publisher\", {}),\n        \"contacts\"\n    )\n\n    # seed contains `url`, which is used as primary key - if no seed is found,\n    # it is meaningless to continue\n    if not active_seed:\n        active_seed = pick_active(seeder_struct, \"seed\")  # alt naming\n        if not active_seed:\n            return None\n\n    # create the model and fill it with data\n    model = Model()\n    model.url = active_seed[\"url\"]\n    model.issn = seeder_struct.get(\"issn\")\n    model.title_tags = seeder_struct.get(\"name\")\n    model.publisher_tags = seeder_struct.get(\"publisher\", {}).get(\"name\")\n    model.annotation_tags = seeder_struct.get(\"comment\")  # annotation?\n\n    # conspect = None  # TODO: !\n\n    if publisher_contact:\n        model.place_tags = publisher_contact.get(\"address\")\n\n    # rules are stored in custom subdictionary\n    rules = {}\n    rules[\"frequency\"] = str(seeder_struct.get(\"frequency\"))\n\n    _add_if_set(rules, \"budget\", active_seed.get(\"budget\"))\n    _add_if_set(rules, \"youtube\", active_seed.get(\"youtube\"))\n    _add_if_set(rules, \"calendars\", active_seed.get(\"calendars\"))\n    _add_if_set(rules, \"javascript\", active_seed.get(\"javascript\"))\n    _add_if_set(rules, \"local_traps\", active_seed.get(\"local_traps\"))\n    _add_if_set(rules, \"gentle_fetch\", active_seed.get(\"gentle_fetch\"))\n    _add_if_set(rules, \"global_reject\", active_seed.get(\"global_reject\"))\n\n    model.rules = rules\n\n    # add source info\n    for key in model.keys():\n        val = getattr(model, key)\n        if val and \"tags\" in key:\n            setattr(model, key, [{\"val\": val, \"source\": \"Seeder\"}])\n\n    return model.get_mapping()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _send_request(url_id, data=None, json=None, req_type=None):\n    url = settings.SEEDER_INFO_URL % url_id\n\n    if not req_type:\n        req_type = requests.get\n\n    resp = req_type(\n        url,\n        data=data,\n        json=json,\n        timeout=settings.SEEDER_TIMEOUT,\n        headers={\n            \"User-Agent\": settings.USER_AGENT,\n            \"Authorization\": settings.SEEDER_TOKEN,\n        }\n    )\n    resp.raise_for_status()\n    data = resp.json()\n\n    return data", "response": "Send request to Seeder s API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading data and convert them to dict used in frontend.", "response": "def get_remote_info(url_id):\n    \"\"\"\n    Download data and convert them to dict used in frontend.\n\n    Args:\n        url_id (str): ID used as identification in Seeder.\n\n    Returns:\n        dict: Dict with data for frontend or None in case of error.\n    \"\"\"\n    try:\n        data = _send_request(url_id)\n    except Exception as e:\n        sys.stderr.write(\"Seeder GET error: \")  # TODO: better!\n        sys.stderr.write(str(e.message))\n        return None\n\n    return _convert_to_wakat_format(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a Seeder dataset to Seeder format.", "response": "def _convert_to_seeder_format(dataset):\n    \"\"\"\n    WA KAT dataset has different structure from Seeder. This is convertor\n    which converts WA-KAT -> Seeder data format.\n\n    Args:\n        dataset (dict): WA-KAT dataset sent from frontend.\n\n    Returns:\n        dict: Dict with converted data.\n    \"\"\"\n    data = {}\n    seed = {}\n\n    _add_if_set(data, \"name\", dataset.get(\"title\"))\n    _add_if_set(data, \"issn\", dataset.get(\"issn\"))\n    _add_if_set(data, \"annotation\", dataset.get(\"annotation\"))\n\n    rules = dataset.get(\"rules\", {})\n    if rules:\n        _add_if_set(data, \"frequency\", rules.get(\"frequency\"))\n\n        # set seed info\n        _add_if_set(seed, \"budget\", rules.get(\"budget\"))\n        _add_if_set(seed, \"calendars\", rules.get(\"calendars\"))\n        _add_if_set(seed, \"global_reject\", rules.get(\"global_reject\"))\n        _add_if_set(seed, \"gentle_fetch\", rules.get(\"gentle_fetch\"))\n        _add_if_set(seed, \"javascript\", rules.get(\"javascript\"))\n        _add_if_set(seed, \"local_traps\", rules.get(\"local_traps\"))\n        _add_if_set(seed, \"youtube\", rules.get(\"youtube\"))\n\n        _add_if_set(seed, \"url\", dataset.get(\"url\"))\n\n    if seed:\n        data[\"seed\"] = seed\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend update request to Seeder s API with data changed by user.", "response": "def send_update(url_id, dataset):\n    \"\"\"\n    Send request to Seeder's API with data changed by user.\n\n    Args:\n        url_id (str): ID used as identification in Seeder.\n        dataset (dict): WA-KAT dataset sent from frontend.\n    \"\"\"\n    data = _convert_to_seeder_format(dataset)\n\n    if not data:\n        return\n\n    try:\n        _send_request(url_id, json=data, req_type=requests.patch)\n    except Exception as e:\n        sys.stderr.write(\"Seeder PATCH error: \")  # TODO: better!\n        sys.stderr.write(str(e.message))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _delay(self):\n        if not self.next_scheduled:\n            self.next_scheduled = self.clock_func() + self.interval\n            return\n        while True:\n            current = self.clock_func()\n            if current >= self.next_scheduled:\n                extratime = current - self.next_scheduled\n                self.next_scheduled = current + self.interval - extratime\n                return\n            delay_amt = self.next_scheduled - current\n            #Call for 0, because that might be meaningful to sleep_func.\n            if self.allow_negative_sleep or delay_amt >= 0: \n                self.sleep_func(self.next_scheduled - current)", "response": "Delay for between zero and self. interval time units"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a lambda function which converts an external ( constained ) parameter to an internal ( uncontrained ) parameter.", "response": "def _external2internal_lambda(bound):\n    \"\"\" \n    Make a lambda function which converts an single external (constained)\n    parameter to a internal (uncontrained) parameter.\n    \"\"\"\n    lower, upper = bound\n    \n    if lower is None and upper is None: # no constraints\n        return lambda x: x\n    elif upper is None:     # only lower bound\n        return lambda x: sqrt((x - lower + 1.)**2 - 1)\n    elif lower is None:     # only upper bound\n        return lambda x: sqrt((x - upper + 1.)**2 - 1)\n    else:\n        return lambda x: arcsin((2. * (x - lower) / (upper - lower)) - 1.)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef leastsqbound(func, x0, args=(), bounds=None, Dfun=None, full_output=0,\n            col_deriv=0, ftol=1.49012e-8, xtol=1.49012e-8,\n            gtol=0.0, maxfev=0, epsfcn=0.0, factor=100, diag=None):\n    \"\"\"\n    Bounded minimization of the sum of squares of a set of equations.\n\n    ::\n\n        x = arg min(sum(func(y)**2,axis=0))\n                 y\n\n    Parameters\n    ----------\n    func : callable\n        should take at least one (possibly length N vector) argument and\n        returns M floating point numbers.\n    x0 : ndarray\n        The starting estimate for the minimization.\n    args : tuple\n        Any extra arguments to func are placed in this tuple.\n    bounds : list\n        ``(min, max)`` pairs for each element in ``x``, defining\n        the bounds on that parameter. Use None for one of ``min`` or\n        ``max`` when there is no bound in that direction.\n    Dfun : callable\n        A function or method to compute the Jacobian of func with derivatives\n        across the rows. If this is None, the Jacobian will be estimated.\n    full_output : bool\n        non-zero to return all optional outputs.\n    col_deriv : bool\n        non-zero to specify that the Jacobian function computes derivatives\n        down the columns (faster, because there is no transpose operation).\n    ftol : float\n        Relative error desired in the sum of squares.\n    xtol : float\n        Relative error desired in the approximate solution.\n    gtol : float\n        Orthogonality desired between the function vector and the columns of\n        the Jacobian.\n    maxfev : int\n        The maximum number of calls to the function. If zero, then 100*(N+1) is\n        the maximum where N is the number of elements in x0.\n    epsfcn : float\n        A suitable step length for the forward-difference approximation of the\n        Jacobian (for Dfun=None). If epsfcn is less than the machine precision,\n        it is assumed that the relative errors in the functions are of the\n        order of the machine precision.\n    factor : float\n        A parameter determining the initial step bound\n        (``factor * || diag * x||``). Should be in interval ``(0.1, 100)``.\n    diag : sequence\n        N positive entries that serve as a scale factors for the variables.\n\n    Returns\n    -------\n    x : ndarray\n        The solution (or the result of the last iteration for an unsuccessful\n        call).\n    cov_x : ndarray\n        Uses the fjac and ipvt optional outputs to construct an\n        estimate of the jacobian around the solution.  ``None`` if a\n        singular matrix encountered (indicates very flat curvature in\n        some direction).  This matrix must be multiplied by the\n        residual standard deviation to get the covariance of the\n        parameter estimates -- see curve_fit.\n    infodict : dict\n        a dictionary of optional outputs with the key s::\n\n            - 'nfev' : the number of function calls\n            - 'fvec' : the function evaluated at the output\n            - 'fjac' : A permutation of the R matrix of a QR\n                     factorization of the final approximate\n                     Jacobian matrix, stored column wise.\n                     Together with ipvt, the covariance of the\n                     estimate can be approximated.\n            - 'ipvt' : an integer array of length N which defines\n                     a permutation matrix, p, such that\n                     fjac*p = q*r, where r is upper triangular\n                     with diagonal elements of nonincreasing\n                     magnitude. Column j of p is column ipvt(j)\n                     of the identity matrix.\n            - 'qtf'  : the vector (transpose(q) * fvec).\n\n    mesg : str\n        A string message giving information about the cause of failure.\n    ier : int\n        An integer flag.  If it is equal to 1, 2, 3 or 4, the solution was\n        found.  Otherwise, the solution was not found. In either case, the\n        optional output variable 'mesg' gives more information.\n\n    Notes\n    -----\n    \"leastsq\" is a wrapper around MINPACK's lmdif and lmder algorithms.\n\n    cov_x is a Jacobian approximation to the Hessian of the least squares\n    objective function.\n    This approximation assumes that the objective function is based on the\n    difference between some observed target data (ydata) and a (non-linear)\n    function of the parameters `f(xdata, params)` ::\n\n           func(params) = ydata - f(xdata, params)\n\n    so that the objective function is ::\n\n           min   sum((ydata - f(xdata, params))**2, axis=0)\n         params\n\n    Contraints on the parameters are enforced using an internal parameter list \n    with appropiate transformations such that these internal parameters can be\n    optimized without constraints. The transfomation between a given internal \n    parameter, p_i, and a external parameter, p_e, are as follows:\n\n    With ``min`` and ``max`` bounds defined ::\n\n        p_i = arcsin((2 * (p_e - min) / (max - min)) - 1.)\n        p_e = min + ((max - min) / 2.) * (sin(p_i) + 1.)\n\n    With only ``max`` defined ::\n\n        p_i = sqrt((p_e - max + 1.)**2 - 1.)\n        p_e = max + 1. - sqrt(p_i**2 + 1.)\n\n    With only ``min`` defined ::\n\n        p_i = sqrt((p_e - min + 1.)**2 - 1.)\n        p_e = min - 1. + sqrt(p_i**2 + 1.)\n\n    These transfomations are used in the MINUIT package, and described in \n    detail in the section 1.3.1 of the MINUIT User's Guide.\n\n    To Do\n    -----\n    Currently the ``factor`` and ``diag`` parameters scale the \n    internal parameter list, but should scale the external parameter list.\n\n    The `qtf` vector in the infodic dictionary reflects internal parameter \n    list, it should be correct to reflect the external parameter list.\n\n    References\n    ----------\n    * F. James and M. Winkler. MINUIT User's Guide, July 16, 2004.\n\n    \"\"\"\n    # use leastsq if no bounds are present\n    if bounds is None:\n        return leastsq(func, x0, args, Dfun, full_output, col_deriv, \n                        ftol, xtol, gtol, maxfev, epsfcn, factor, diag)\n    \n    # create function which convert between internal and external parameters\n    i2e = _internal2external_func(bounds)\n    e2i = _external2internal_func(bounds)\n\n    x0 = array(x0, ndmin=1)\n    i0 = e2i(x0)\n    n = len(x0)\n    if len(bounds) != n:\n        raise ValueError('length of x0 != length of bounds')\n    if type(args) != type(()):\n        args = (args,)\n    m = _check_func('leastsq', 'func', func, x0, args, n)[0]\n    if n > m:\n        raise TypeError('Improper input: N=%s must not exceed M=%s' % (n,m))\n    \n    # define a wrapped func which accept internal parameters, converts them\n    # to external parameters and calls func\n    def wfunc(x, *args): return func(i2e(x), *args)\n    \n    if Dfun is None:\n        if (maxfev == 0):\n            maxfev = 200*(n + 1)\n        retval = _minpack._lmdif(wfunc, i0, args, full_output, ftol, xtol,\n                gtol, maxfev, epsfcn, factor, diag)\n    else:\n        if col_deriv:\n            _check_func('leastsq', 'Dfun', Dfun, x0, args, n, (n,m))\n        else:\n            _check_func('leastsq', 'Dfun', Dfun, x0, args, n, (m,n))\n        if (maxfev == 0):\n            maxfev = 100*(n + 1)\n        def wDfun(x, *args): return Dfun(i2e(x), *args) # wrapped Dfun\n        retval = _minpack._lmder(func, wDfun, i0, args, full_output, \n                col_deriv, ftol, xtol, gtol, maxfev, factor, diag)\n\n    errors = {0:[\"Improper input parameters.\", TypeError],\n              1:[\"Both actual and predicted relative reductions \"\n                 \"in the sum of squares\\n  are at most %f\" % ftol, None],\n              2:[\"The relative error between two consecutive \"\n                 \"iterates is at most %f\" % xtol, None],\n              3:[\"Both actual and predicted relative reductions in \"\n                 \"the sum of squares\\n  are at most %f and the \"\n                 \"relative error between two consecutive \"\n                 \"iterates is at \\n  most %f\" % (ftol,xtol), None],\n              4:[\"The cosine of the angle between func(x) and any \"\n                 \"column of the\\n  Jacobian is at most %f in \"\n                 \"absolute value\" % gtol, None],\n              5:[\"Number of calls to function has reached \"\n                 \"maxfev = %d.\" % maxfev, ValueError],\n              6:[\"ftol=%f is too small, no further reduction \"\n                 \"in the sum of squares\\n  is possible.\"\"\" % ftol, ValueError],\n              7:[\"xtol=%f is too small, no further improvement in \"\n                 \"the approximate\\n  solution is possible.\" % xtol, ValueError],\n              8:[\"gtol=%f is too small, func(x) is orthogonal to the \"\n                 \"columns of\\n  the Jacobian to machine \"\n                 \"precision.\" % gtol, ValueError],\n              'unknown':[\"Unknown error.\", TypeError]}\n\n    info = retval[-1]    # The FORTRAN return value\n\n    if (info not in [1,2,3,4] and not full_output):\n        if info in [5,6,7,8]:\n            warnings.warn(errors[info][0], RuntimeWarning)\n        else:\n            try:\n                raise errors[info][1](errors[info][0])\n            except KeyError:\n                raise errors['unknown'][1](errors['unknown'][0])\n\n    mesg = errors[info][0]\n    x = i2e(retval[0])  # internal params to external params\n    \n    if full_output:\n        # convert fjac from internal params to external\n        grad = _internal2external_grad(retval[0], bounds)\n        retval[1]['fjac'] = (retval[1]['fjac'].T / take(grad, \n                            retval[1]['ipvt'] - 1)).T\n        cov_x = None\n        if info in [1,2,3,4]:\n            from numpy.dual import inv\n            from numpy.linalg import LinAlgError\n            perm = take(eye(n),retval[1]['ipvt']-1,0)\n            r = triu(transpose(retval[1]['fjac'])[:n,:])\n            R = dot(r, perm)\n            try:\n                cov_x = inv(dot(transpose(R),R))\n            except LinAlgError:\n                pass\n        return (x, cov_x) + retval[1:-1] + (mesg, info)\n    else:\n        return (x, info)", "response": "Returns the least squared bound of a function on a set of entries."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_badge_svg(title, value, color='#007ec6'):\n    (title_length, value_length) = get_text_length(title, value)\n    return '''<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"{width}\" height=\"20\">\n        <linearGradient id=\"b\" x2=\"0\" y2=\"100%\">\n            <stop offset=\"0\" stop-color=\"#bbb\" stop-opacity=\".1\"/>\n            <stop offset=\"1\" stop-opacity=\".1\"/>\n        </linearGradient>\n        <mask id=\"a\" width=\"{width}\" height=\"20\">\n            <rect width=\"{width}\" height=\"20\" rx=\"3\"\n            fill=\"#fff\"/>\n        </mask>\n        <g mask=\"url(#a)\">\n            <path fill=\"#555\" d=\"M0 0h{title_width}v20H0z\" />\n            <path fill=\"{color}\"\n            d=\"M{title_width} 0h{value_width}v20H{title_width}z\"\n            />\n            <path fill=\"url(#b)\" d=\"M0 0h{width}v20H0z\" />\n        </g>\n        <g fill=\"#fff\" text-anchor=\"middle\" font-family=\"DejaVu Sans,\n        Verdana,Geneva,sans-serif\" font-size=\"11\">\n            <text x=\"{title_position}\" y=\"15\" fill=\"#010101\"\n            fill-opacity=\".3\">\n                {title}\n            </text>\n            <text x=\"{title_position}\" y=\"14\">\n                {title}\n            </text>\n            <text x=\"{value_position}\"\n            y=\"15\" fill=\"#010101\" fill-opacity=\".3\">\n                {value}\n            </text>\n            <text x=\"{value_position}\" y=\"14\">\n                {value}\n            </text>\n        </g>\n    </svg>'''.format(\n        title_width=title_length + 11,\n        value_width=value_length + 11,\n        width=title_length + value_length + 22,\n        title_position=title_length / 2 + 6,\n        value_position=title_length + value_length / 2 + 16,\n        title=title,\n        value=value,\n        color=color,\n    )", "response": "Generates the SVG for the current badge."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_badge_png(title, value, color='#007ec6'):\n    badge = generate_badge_svg(title, value, color)\n    return cairosvg.svg2png(badge)", "response": "Generate the badge in PNG format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef badges_processor():\n    def badge_svg(title, value, color='#007ec6'):\n        \"\"\"Context processor function to generate SVG badges.\"\"\"\n        return generate_badge_svg(title, value, color)\n\n    def badge_png(title, value, color='#007ec6'):\n        \"\"\"Context processor function to generate SVG badges.\"\"\"\n        png = generate_badge_png(title, value, color)\n        png_base64 = b64encode(png)\n        return 'data:image/png;base64,{0}'.format(png_base64)\n\n    return dict(\n        badge_svg=badge_svg,\n        badge_png=badge_png\n    )", "response": "Return a dict of badges."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_same_starting_points(flaglist):\n\n    change_points = []\n    same_points = []\n    in_change = False\n\n    if flaglist and not flaglist[0]:\n        same_points.append(0)\n\n    for x, flag in enumerate(flaglist):\n        if flag and not in_change:\n            change_points.append(x)\n            in_change = True\n        elif not flag and in_change:\n            same_points.append(x)\n            in_change = False\n\n    return (change_points, same_points)", "response": "Gets points at which changes begin"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a table of the contents of the current object.", "response": "def make_table(self, renderable):\n        \"\"\"Makes unique anchor prefixes so that multiple tables may exist\n        on the same page without conflict.\"\"\"\n        self._make_prefix()\n        diffs = renderable.diff._diff\n\n        # set up iterator to wrap lines that exceed desired width\n        if self._wrapcolumn:\n            diffs = self._line_wrapper(diffs, renderable.diff.hide_expected)\n\n        # collect up from/to lines and flags into lists (also format the lines)\n        fromlist, tolist, flaglist = self._collect_lines(diffs)\n\n        # process change flags, generating middle column of next anchors/links\n        fromlist, tolist, flaglist, next_href, next_id = self._convert_flags(\n            fromlist, tolist, flaglist, False, 5)\n\n        s = []\n        fmt = '            <tr><td class=\"diff_next\"%s>%s</td>%s' + \\\n              '<td class=\"diff_next\">%s</td>%s</tr>\\n'\n        for i in range(len(flaglist)):\n            if flaglist[i] is None:\n                # mdiff yields None on separator lines skip the bogus ones\n                # generated for the first line\n                if i > 0:\n                    s.append('        </tbody>        \\n        <tbody>\\n')\n            else:\n                s.append(fmt % (next_id[i], next_href[i], fromlist[i],\n                                next_href[i], tolist[i]))\n        header_row = '<thead><tr>%s%s%s%s</tr></thead>' % (\n            '<th class=\"diff_next\"><br /></th>',\n            '<th colspan=\"2\" class=\"diff_header\">%s</th>' % self.FROM_DESC,\n            '<th class=\"diff_next\"><br /></th>',\n            '<th colspan=\"2\" class=\"diff_header\">%s</th>' % self.TO_DESC)\n\n        table = self._table_template % dict(\n            data_rows=''.join(s),\n            header_row=header_row,\n            prefix=self._prefix[1])\n\n        return table.replace('\\0+', '<span class=\"diff_add\">'). \\\n            replace('\\0-', '<span class=\"diff_sub\">'). \\\n            replace('\\0^', '<span class=\"diff_chg\">'). \\\n            replace('\\1', '</span>'). \\\n            replace('\\t', '&nbsp;')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the HTML markup of a single line.", "response": "def _format_line(self, side, flag, linenum, text):\n        \"\"\"Returns HTML markup of \"from\" / \"to\" text lines\n\n        side -- 0 or 1 indicating \"from\" or \"to\" text\n        flag -- indicates if difference on line\n        linenum -- line number (used for line number column)\n        text -- line text to be marked up\n        \"\"\"\n        try:\n            linenum = '%d' % linenum\n            id = ' id=\"%s%s\"' % (self._prefix[side], linenum)\n        except TypeError:\n            # handle blank lines where linenum is '>' or ''\n            id = ''\n        # replace those things that would get confused with HTML symbols\n        text = text.replace(\"&\", \"&amp;\"). \\\n            replace(\">\", \"&gt;\"). \\\n            replace(\"<\", \"&lt;\")\n\n        # make space non-breakable so they don't get compressed or line wrapped\n        text = text.replace(' ', '&nbsp;').rstrip()\n\n        color = ''\n        if '\\0^' in text or '\\0+' in text or '\\0-' in text:\n            color = ';background-color:{0}'\n            if side == 0:\n                color = color.format('#ffe6e6')\n            else:\n                color = color.format('#e3ffe3')\n        return self.TD_DIFF_HEADER.format(id, linenum, color, text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle making inline links in the document.", "response": "def _convert_flags(self, fromlist, tolist, flaglist, context, numlines):\n        \"\"\"Handles making inline links in the document.\"\"\"\n\n        # all anchor names will be generated using the unique \"to\" prefix\n        toprefix = self._prefix[1]\n        sameprefix = self._prefix[2]\n\n        # process change flags, generating middle column of next anchors/links\n        next_id = [''] * len(flaglist)\n        next_href = [''] * len(flaglist)\n        (change_positions, same_positions) = \\\n            change_same_starting_points(flaglist)\n        change_positions_set = set(change_positions)\n\n        for numChange, changePos in enumerate(change_positions[: -1]):\n            next_id[changePos] = self.NEXT_ID_CHANGE.format(\n                toprefix, numChange)\n            next_href[changePos] = self.NEXT_HREF.format(\n                toprefix, numChange + 1)\n\n        for same_block, same_start_pos in enumerate(same_positions):\n            same_pos = same_start_pos\n            while same_pos < len(flaglist) and \\\n                    same_pos not in change_positions_set:\n                next_id[same_pos] = self.NEXT_ID_SAME.format(\n                    sameprefix, same_block,\n                    same_pos - same_start_pos + 1)\n                same_pos += 1\n            num_same_lines = same_pos - same_start_pos\n            if num_same_lines > self.MAX_SAME_LINES_BEFORE_SHOW_HIDE:\n                next_href[same_start_pos + 2] = self.SHOW_HIDE_ROWS\n                self._last_collapsed = True\n\n        # check for cases where there is no content to avoid exceptions\n        if not flaglist:\n            flaglist = [False]\n            next_id = ['']\n            next_href = ['']\n            if context:\n                fromlist = [self.NO_DIFFERENCES]\n                tolist = fromlist\n            else:\n                fromlist = tolist = [self.EMPTY_FILE]\n\n        # redo the last link to link to the top\n        if change_positions:\n            pos = change_positions[-1]\n            next_id[pos] = self.NEXT_ID_CHANGE.format(\n                toprefix, len(change_positions) - 1)\n            next_href[pos] = self.NEXT_HREF_TOP.format(toprefix)\n\n        return fromlist, tolist, flaglist, next_href, next_id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_analyzer_arguments(arguments):\n\n    rets = []\n\n    for argument in arguments:\n        args = argument.split(argument_splitter)\n\n        # The first one is the function name\n        func_name = args[0]\n\n        # The rest is the args\n        func_args = {}\n\n        for arg in args[1:]:\n            key, value = parse_arg(arg)\n\n            func_args[key] = value\n\n        rets.append(FunctionArguments(function=func_name, arguments=func_args))\n\n    return rets", "response": "Parse string in format function_1 param1 = value param2 function_2 param... into array of FunctionArguments\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_doc(self, doc, doc_id=None, following_attachments=None):\n        '''Imitate sending HTTP request to CouchDB server'''\n\n        self.log(\"save_document called for doc: %r\", doc)\n\n        d = defer.Deferred()\n\n        try:\n            if not isinstance(doc, (str, unicode, )):\n                raise ValueError('Doc should be either str or unicode')\n            doc = json.loads(doc)\n            doc = self._set_id_and_revision(doc, doc_id)\n\n            self.increase_stat('save_doc')\n\n            self._documents[doc['_id']] = doc\n            if doc['_id'] not in self._attachments:\n                self._attachments[doc['_id']] = dict()\n            attachments = doc.get('_attachments', dict())\n            for name in attachments:\n                if attachments[name].get('follows'):\n                    if name not in following_attachments:\n                        raise ValueError(\"Document id %s had attachment name\"\n                                         \" %s marked with follows=True, but\"\n                                         \" it was not passed to save_doc() \"\n                                         % (doc['_id'], name))\n\n                    del attachments[name]['follows']\n                    attachments[name]['stub'] = True\n                    b = following_attachments[name].get_body()\n                    self._attachments[doc['_id']][name] = b\n\n                elif name not in self._attachments[doc['_id']]:\n                    raise ValueError(\"Document id %s body has attachment \"\n                                     \"named %s \"\n                                     \"but it is not in our cache \" %\n                                     (doc['_id'], name))\n            for name in self._attachments[doc['_id']].keys():\n                if name not in attachments:\n                    del self._attachments[doc['_id']][name]\n                    self.log('Deleted attachment %s of the doc: %s because '\n                             'its not in the _attachments key' %\n                             (name, doc['_id']))\n\n            self._expire_cache(doc['_id'])\n\n            r = Response(ok=True, id=doc['_id'], rev=doc['_rev'])\n            self._analize_changes(doc)\n            d.callback(r)\n        except (ConflictError, ValueError, ) as e:\n            d.errback(e)\n\n        return d", "response": "Imitate sending HTTP request to CouchDB server"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open_doc(self, doc_id):\n        '''Imitated fetching the document from the database.\n        Doesnt implement options from paisley to get the old revision or\n        get the list of revision.\n        '''\n        d = defer.Deferred()\n        self.increase_stat('open_doc')\n        try:\n            doc = self._get_doc(doc_id)\n            doc = copy.deepcopy(doc)\n            if doc.get('_deleted', None):\n                raise NotFoundError('%s deleted' % doc_id)\n            d.callback(Response(doc))\n        except NotFoundError as e:\n            d.errback(e)\n\n        return d", "response": "Imitated fetching the document from the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_doc(self, doc_id, revision):\n        '''Imitates sending DELETE request to CouchDB server'''\n        d = defer.Deferred()\n\n        self.increase_stat('delete_doc')\n\n        try:\n            doc = self._get_doc(doc_id)\n            if doc['_rev'] != revision:\n                raise ConflictError(\"Document update conflict.\")\n            if doc.get('_deleted', None):\n                raise NotFoundError('%s deleted' % doc_id)\n            doc['_deleted'] = True\n            self._expire_cache(doc['_id'])\n            for key in doc.keys():\n                if key in ['_rev', '_deleted', '_id']:\n                    continue\n                del(doc[key])\n            self.log('Marking document %r as deleted', doc_id)\n            del self._attachments[doc['_id']]\n            self._update_rev(doc)\n            self._analize_changes(doc)\n            d.callback(Response(ok=True, id=doc_id, rev=doc['_rev']))\n        except (ConflictError, NotFoundError, ) as e:\n            d.errback(e)\n\n        return d", "response": "Imitates sending DELETE request to CouchDB server"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_fixture(self, body, attachment_bodies={}):\n        '''\n        Loads the document into the database from json string. Fakes the\n        attachments if necessary.'''\n        doc = json.loads(body)\n        self._documents[doc['_id']] = doc\n        self._attachments[doc['_id']] = dict()\n        for name in doc.get('_attachments', list()):\n            attachment_body = attachment_bodies.get(name, 'stub')\n            self._attachments[doc['_id']][name] = attachment_body", "response": "Loads the document into the database from json string. Fakes the\n        attachments if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _include_docs(self, rows):\n        '''rows here are tuples (key, value, id), returns a list of tuples\n        (key, value, id, doc)'''\n        resp = list()\n        for row in rows:\n            if isinstance(row[1], dict) and '_id' in row[1]:\n                d_id = row[1]['_id']\n            else:\n                d_id = row[2]\n            try:\n                doc = self._get_doc(d_id)\n                doc = copy.deepcopy(doc)\n                if doc.get('_deleted', None):\n                    raise NotFoundError('%s deleted' % d_id)\n            except NotFoundError:\n                # FIXME: this just returns None instead of dict if the\n                # document is not there/was deleted.\n                # I'm not sure if this is how couchdb would behave\n                # check it!\n                doc = None\n            resp.append(row + (doc, ))\n        return resp", "response": "include_docs returns a list of tuples"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flatten(self, iterator, **filter_options):\n        '''\n        iterator here gives as lists of tuples. Method flattens the structure\n        to a single list of tuples.\n        '''\n        resp = list()\n        for entry in iterator:\n            for tup in entry:\n                if self._matches_filter(tup, **filter_options):\n                    resp.append(tup)\n        return resp", "response": "Method flattens the structure\n            to a single list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a reduce operation on the cache.", "response": "def _perform_reduce(self, map_results, factory, group=False,\n                        group_level=None):\n        '''\n        map_results here is a list of tuples (key, value, id)\n        '''\n\n        def get_group_key(key, group, group_level):\n            if group:\n                return key\n            return key[0:group_level]\n\n        if not group and group_level is None:\n            keys = map(operator.itemgetter(0), map_results)\n            values = map(operator.itemgetter(1), map_results)\n            return self._reduce_values(factory, None, keys, values)\n        else:\n            groups = dict()\n            for row in map_results:\n                key, value = row[:2]\n                group_key = get_group_key(key, group, group_level)\n                if group_key not in groups:\n                    groups[group_key] = list()\n                groups[group_key].append((key, value))\n            resp = list()\n            for group_key, results in groups.iteritems():\n                keys = map(operator.itemgetter(0), results)\n                values = map(operator.itemgetter(1), results)\n                resp.extend(\n                    self._reduce_values(factory, group_key, keys, values))\n            return resp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsee <Singleton> design pattern for detail: http://www.oodesign.com/singleton-pattern.html Python <Singleton> reference: http://stackoverflow.com/questions/6760685/creating-a-singleton-in-python Recommend use Singleton as a metaclass Usage: @singleton class MyClass(object): pass", "response": "def singleton(cls):\n    \"\"\"\n    See <Singleton> design pattern for detail: http://www.oodesign.com/singleton-pattern.html\n    Python <Singleton> reference: http://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    Recommend use Singleton as a metaclass\n\n    Usage:\n        @singleton\n        class MyClass(object):\n            pass\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef indent_string(string, num_spaces=2):\n    '''Add indentation to a string.\n\n    Replaces all new lines in the string with a new line followed by the\n    specified number of spaces, and adds the specified number of spaces to the\n    start of the string.\n\n    '''\n    indent = ' '.ljust(num_spaces)\n    return indent + re.sub('\\n', '\\n' + indent, string)", "response": "Add indentation to a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_attribute(attr, name, expected_type=None, required=False):\n    '''Validates that an attribute meets expectations.\n\n    This function will check if the given attribute value matches a necessary\n    type and/or is not None, an empty string, an empty list, etc. It will raise\n    suitable exceptions on validation failure.\n\n    @param attr The value to validate.\n    @param name The attribute name to use in exceptions.\n    @param expected_type The type the value must be. If None, no check is\n    performed. If a list, attr must match one type in the list.\n    @param required If the value must not be empty, e.g. not an empty string.\n    @raises InvalidTypeError\n    @raises RequiredAttributeError\n\n    '''\n    if expected_type:\n        if type(expected_type) == list:\n            if not _check_type(attr, expected_type):\n                raise InvalidTypeError(name, type(attr), expected_type)\n        else:\n            if not _check_type(attr, [expected_type]):\n                raise InvalidTypeError(name, type(attr), expected_type)\n    if required and not attr:\n        raise RequiredAttributeError(name)", "response": "Validates that an attribute value meets expectations."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nintercept method for writing data.", "response": "def write(self, data):\n        \"\"\"\n        Intercepted method for writing data.\n\n        :param data:\n            Data to write\n        :returns:\n            Whatever the original method returns\n        :raises:\n            Whatever the original method raises\n\n        This method updates the internal digest object with with the new data\n        and then proceeds to call the original write method.\n        \"\"\"\n        # Intercept the write method (that's what @direct does) and both write\n        # the data using the original write method (using proxiee(self).write)\n        # and update the hash of the data written so far (using\n        # proxy.state(self).digest).\n        proxy.state(self).digest.update(data)\n        return proxy.original(self).write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the version of the current code set.", "response": "def get_version (pkg = __name__, public = False):\n  \"\"\"\n  Uses `git describe` to dynamically generate a version for the\n  current code.  The version is effecvtively a traditional tri-tuple\n  ala (major, minor, patch), with the addenda that in this case the\n  patch string is a combination of the number of commits since the\n  tag, plus the ID of the last commit.  Further, the patch will be\n  extended with \"-dirty\" if there are uncommitted changes in the\n  current codeset.\n\n    eg 1.0.1-gd5aa65e-dirty\n\n  Assumes that the tags fit the regex [0-9]*.[0-9]*\n  \"\"\"\n  try:\n    cwd = os.getcwd ()\n  except: # pylint: disable=W0702\n    cwd = None\n  try:\n    try:\n      mod = __import__ (pkg)\n      path = os.path.dirname (mod.__file__)\n      os.chdir (path)\n    except: # pylint: disable=W0702\n      pass\n    o = subprocess.check_output (\n      DEFAULT_GITCMD.split (),\n      stderr = subprocess.PIPE,\n      shell = False).decode ().strip ()\n    s = o.replace (\"-\", \".\", 1).replace (\"-\", \"+\", 1).replace (\"-\", \".\", 1)\n  except: # pylint: disable=W0702\n    s = pkg_resources.get_distribution (pkg.split (\".\")[0]).version\n  if cwd is not None:\n    os.chdir (cwd)\n  if public:\n    vals = s.split (\".\")\n    patch = ((vals[2][:vals[2].find (\"+\")])\n             if vals[2].find (\"+\") != -1 else vals[2])\n    info = ((vals[0], vals[1], patch, \"dev1\")\n            if len (vals) == 4 else (vals[0], vals[1], patch))\n    return \".\".join (info), info\n  else:\n    return s, s.split (\".\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef author_tokenize(name):\n    phrases = scan_author_string_for_phrases(name)\n    res = {'lastnames': [], 'nonlastnames': []}\n    for key, tokens in phrases.items():\n        lst = res.get(key)\n        if lst is None:\n            continue\n        for token in tokens:\n            if len(token) == 1:\n                lst.append(NameInitial(token))\n            else:\n                lst.append(NameToken(token))\n    return res", "response": "This is how the name should be tokenized for the matcher."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_scheduled_analyses(self):\n        url = '{}scheduled_analyses/'.format(self.url)\n        return ScheduledAnalysis._get_list_from_url(url, append_base_url=False)", "response": "Retrieve all scheduled analyses for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_template_source(name):\n    for loader_path in settings.TEMPLATE_LOADERS:\n        template_loader = loader.find_template_loader(loader_path)\n        try:\n            source, origin = template_loader.load_template_source(name)\n        except TemplateDoesNotExist:\n            continue\n        break\n    return source, origin", "response": "Load the source code and origin of the first template that matches the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_parents(name, parents=None):\n    template = loader.get_template(name)\n    source, origin = find_template_source(name)\n    if parents is None:\n        parents = []\n    else:\n        parents.append({'name': name, 'file': origin})\n    for node in template:\n        if isinstance(node, ExtendsNode):\n            parent_name = node.parent_name.token.strip('\"')\n            return find_parents(parent_name, parents)\n    return parents", "response": "Recursively find all of this template s parents and return them as a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef makeThumb(self, imagepath, thumbpath, tsize, img=None):\n        try:\n            # open image if needed\n            if not img:\n                img = PIL.Image.open(imagepath)\n            # do we need a thumbnail at all, or can the image be inlined?\n            width, height = img.size\n            factor = max(width / float(tsize[0]), height / float(tsize[1]))\n            if factor <= 1:\n                return imagepath\n            # generate the thumbnail\n            img = img.resize((int(width / factor), int(height / factor)), PIL.Image.ANTIALIAS)\n            img.save(thumbpath, \"PNG\")\n            return thumbpath\n        except:\n            print(\"Error rendering thumbnail %s\" % thumbpath)\n            traceback.print_exc()\n            return None", "response": "makes a thumbnail for the given image"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders a link to the DP", "response": "def renderLink(self, relpath=\"\"):\n        \"\"\"renderLink() is called to render a link to the DP\n        \"\"\"\n        # return from cache if available\n        cachekey, html = self.checkCache('Link', relpath)\n        if html is not None:\n            return html\n        # else regenerate\n        html = CachingRenderer.renderLink(self, relpath)\n        if self.headerfile is not None:\n            html += \"\"\" (<A HREF=\"%s\">header</A>)\"\"\" % quote_url(relpath + self.headerfile)\n        # save to cache\n        return self.writeCache(cachekey, html)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef renderInTable(self, relpath=\"\"):\n        # return from cache if available\n        cachekey, html = self.checkCache('InTable', relpath)\n        if html is not None:\n            return html\n        # else regenerate\n        # single image: render as standard cells\n        if len(self.imgrec) == 1:\n            rec = self.imgrec[0]\n            # add header\n            html = \"    <TR><TD COLSPAN=2>\"\n            html += self.renderLinkComment(relpath) or \"\"\n            html += \"</TD></TR>\\n\"\n            html_img, comment = self._renderImageRec(rec, relpath, include_size=True)\n            html += \"\\n\".join([\n                \"    <TR>\",\n                \"      <TD>%s</TD>\" % html_img,\n                \"      <TD>%s</TD>\" % comment,\n                \"    </TR>\\n\"])\n        # multiple images: render a single header row, followed by one row per image\n        else:\n            # add header\n            html = \"    <TR><TD COLSPAN=2>\"\n            html += self.renderLinkComment(relpath)\n            # append information on image and end the table row\n            html += \"\\n      <DIV ALIGN=right><P>%s FITS cube, %d planes are given below.</P></DIV></TD></TR>\\n\" % (\n            self.cubesize, len(self.imgrec))\n            # now loop over images and generate a table row for each\n            for irec, rec in enumerate(self.imgrec):\n                html_img, comment = self._renderImageRec(rec, relpath)\n                comment = \"<P>Image plane #%d.</P>%s\" % (irec, comment)\n                html += \"\\n\".join([\n                    \"    <TR>\",\n                    \"      <TD>%s</TD>\" % html_img,\n                    \"      <TD>%s</TD>\" % comment,\n                    \"    </TR>\\n\"])\n        return self.writeCache(cachekey, html)", "response": "renderInTable - renders the FITS images in a table"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef renderThumbnail(self, relpath=\"\"):\n        # return from cache if available\n        cachekey, html = self.checkCache('Thumbnail', relpath)\n        if html is not None:\n            return html\n        # else regenerate\n        rec = self.imgrec[0]\n        html = self._renderSingleImage(rec.fullimage, rec.thumbnail, relpath)\n        # save to cache\n        return self.writeCache(cachekey, html)", "response": "renderThumbnail - Render a thumbnail of the DP."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pipe(p1, p2):\n    if isinstance(p1, Pipeable) or isinstance(p2, Pipeable):\n        return p1 | p2\n    return Pipe([p1, p2])", "response": "Joins two pipes together."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef perform_transformation(instance, field_names_to_transform=None):\n    '''\n    Transforms a model based on the fields specified in the\n    ``transformed_fields`` attribute. This should map source image\n    field names to dictionaries mapping destination field name to\n    their transformations. For instance::\n\n        {\n            'image': {\n                'thumbnail': scale(width=10),\n            }\n        }\n\n    If ``field_names_to_transform`` is None, then it will transform\n    all fields. Otherwise it will only transform\n    from those fields specified in ``field_names_to_transform``.\n\n    :param instance: model instance to perform transformations on\n    :type instance: instance of :py:class:`django.db.models.Model`\n\n    :param field_names_to_transform: field names on model to perform transformations on\n    :type field_names_to_transform: iterable of strings or None\n    '''\n    for source_field_name, destination_dict in instance.transformed_fields.items():\n        if field_names_to_transform is None or source_field_name in field_names_to_transform:\n            for destination_field_name, transformation in destination_dict.items():\n                arguments = [instance, source_field_name, destination_field_name, transformation]\n                get_caller()(transform_field, *arguments)", "response": "This function transforms a model based on the fields specified in the field_names_to_transform attribute of the object instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndoes an image transformation on a instance. It will get the image from the source field attribute of the instnace, then call the transformation function with that instance, and finally save that transformed image into the destination field attribute of the instance. .. note:: If the source field is blank or the transformation returns a false value then the destination field image will be deleted, if it exists. .. warning:: When the model instance is saved with the new transformed image, it uses the ``update_fields`` argument for :py:meth:`~django.db.models.Model.save`, to tell the model to only update the destination field and, if set in the destination field, the :py:attr:`~django.db.models.ImageField.height_field` and :py:attr:`~django.db.models.ImageField.width_field`. This means that if the saving code for the model sets any other fields, in the saving field process, it will not save those fields to the database. This would only happen if you introduce custom logic to the saving process of destination field, like the dimension fields do, that updates another field on that module. In that case, when the model is saved for the transformation, that other field will not be saved to the database. :param instance: model instance to perform transformations on :type instance: instance of :py:class:`django.db.models.Model` :param source_field_name: field name on model to find source image :type source_field_name: string :param destination_field_name: field name on model save transformed image to :type destination_field_name: string :param transformation: function, such as :py:func:`~.transforms.scale`, that takes an image files and returns a transformed image :type transformation: function", "response": "def transform_field(instance, source_field_name, destination_field_name, transformation):\n    '''\n    Does an image transformation on a instance. It will get the image\n    from the source field attribute of the instnace, then call\n    the transformation function with that instance, and finally\n    save that transformed image into the destination field attribute\n    of the instance.\n\n    .. note::\n\n        If the source field is blank or the transformation returns\n        a false value then the destination field image will be deleted, if it\n        exists.\n\n    .. warning::\n\n        When the model instance is saved with the new transformed image, it uses\n        the ``update_fields`` argument for\n        :py:meth:`~django.db.models.Model.save`, to tell the model to only update\n        the destination field and, if set in the destination field, the\n        :py:attr:`~django.db.models.ImageField.height_field` and\n        :py:attr:`~django.db.models.ImageField.width_field`. This means that\n        if the saving code for the model sets any other fields, in the saving\n        field process, it will not save those fields to the database. This would\n        only happen if you introduce custom logic to the saving process of\n        destination field, like the dimension fields do, that updates another field\n        on that module. In that case, when the model is saved for the\n        transformation, that other field will not be saved to the database.\n\n\n    :param instance: model instance to perform transformations on\n    :type instance: instance of :py:class:`django.db.models.Model`\n\n    :param source_field_name: field name on model to find source image\n    :type source_field_name: string\n\n    :param destination_field_name: field name on model save transformed image to\n    :type destination_field_name: string\n\n    :param transformation: function, such as :py:func:`~.transforms.scale`, that takes an image files and returns a transformed image\n    :type transformation: function\n    '''\n\n    source_field = getattr(instance, source_field_name)\n    destination_field = getattr(instance, destination_field_name)\n    update_fields = [destination_field_name]\n    transformed_image = get_transformed_image(source_field, transformation)\n    if transformed_image:\n        destination_name = os.path.basename(source_field.name)\n        dimension_field_names = [\n            destination_field.field.height_field,\n            destination_field.field.width_field]\n        update_fields += filter(None, dimension_field_names)\n        destination_field.save(\n            destination_name,\n            transformed_image,\n            save=False\n        )\n    elif destination_field:\n        destination_field.delete()\n    else:\n        return\n    instance.save(update_fields=update_fields)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jsonify(obj, status=200, headers=None, refs=False, encoder=JSONEncoder):\n    if encoder is JSONEncoder:\n        data = encoder(refs=refs).encode(obj)\n    else:\n        data = encoder().encode(obj)\n    if 'callback' in request.args:\n        cb = request.args.get('callback')\n        data = '%s && %s(%s)' % (cb, cb, data)\n    return Response(data, headers=headers,\n                    status=status,\n                    mimetype='application/json')", "response": "Custom JSONificaton to support obj. to_dict protocol."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_mutiple_items(f, container_type, item_type, separator=\" \"):\n\n    \"\"\" Extract an iterable from the current line of a file-like object.\n\n    Args:\n        f (file): the file-like object to read from\n        container_type (type): type of the iterable that will be returned\n        item_type (type): type of the values that will be elements of the returned iterable\n        separator (str): the separator between two consecutive items\n\n    Returns:\n        The extracted iterable\n\n    Example:\n        The file \"a.input\" contains three lines and three comma-separated digits on each::\n\n            >>> with open(\"a.input\") as f:\n            ...     print(utools.files.read_multiple_items(f, list, int, separator=\",\"))\n            ...     print(utools.files.read_multiple_items(f, set, str, separator=\",\"))\n            ...     print(utools.files.read_multiple_items(f, tuple, float, separator=\",\"))\n            ...\n            [1, 2, 3]\n            {\"4\", \"5\", \"6\"}\n            (7.0, 8.0, 9.0)\n    \"\"\"\n\n    return __read(f, lambda line: container_type(item_type(item) for item in line.split(separator)))", "response": "Read a file - like object containing multiple items."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef install(trg_queue, is_down=False, is_triggered=False, user=None,\n            group=None, mode=None, item_user=None, item_group=None,\n            item_mode=None, hosts=None, is_host_triggered=False):\n    '''Atomically install a queue'''\n    mode, user, group, item_user, item_group, item_mode =\\\n        _def_mode(mode, user, group, item_user, item_group, item_mode)\n    if hosts and not hasattr(hosts, '__iter__'):\n        raise TypeError('Hosts must be an interable')\n    # validate here, so that we don't throw an odd exception on the tmp name\n    trg_queue = fsq_path.valid_name(trg_queue)\n    # uid_gid makes calls to the pw db and|or gr db, in addition to\n    # potentially stat'ing, as such, we want to avoid calling it unless we\n    # absoultely have to\n    uid, gid = uid_gid(user, group)\n    tmp_full, tmp_queue = _tmp_trg(trg_queue, _c.FSQ_ROOT)\n    try:\n        # open once to cut down on stat/open for chown/chmod combo\n        fd = os.open(tmp_full, os.O_RDONLY)\n        try:\n            # always fchmod here as mkdtemp is different than normal mkdir\n            os.fchmod(fd, mode)\n            if -1 != uid or -1 != gid:\n                os.fchown(fd, uid, gid)\n        finally:\n            os.close(fd)\n\n        # bless our queue with its children\n        _instdir(fsq_path.tmp(tmp_queue), mode, uid, gid)\n        _instdir(fsq_path.queue(tmp_queue), mode, uid, gid)\n        _instdir(fsq_path.done(tmp_queue), mode, uid, gid)\n        _instdir(fsq_path.fail(tmp_queue), mode, uid, gid)\n\n        # down via configure.down if necessary\n        if is_down:\n            down(tmp_queue, user=item_user, group=item_group, mode=item_mode)\n        if is_triggered or _c.FSQ_USE_TRIGGER:\n            trigger(tmp_queue, user=item_user, group=item_group,\n                    mode=item_mode)\n\n        # atomic commit -- by rename\n        os.rename(tmp_full, fsq_path.base(trg_queue))\n    except (OSError, IOError, ), e:\n        shutil.rmtree(tmp_full)\n        if e.errno == errno.ENOTEMPTY:\n            raise FSQInstallError(e.errno, u'queue exists: {0}'.format(\n                                  trg_queue))\n        if isinstance(e, FSQError):\n            raise e\n        raise FSQInstallError(e.errno, wrap_io_os_err(e))\n\n    if hosts:\n        install_host(trg_queue, *hosts, is_down=is_down, user=user,\n                     group=group, mode=mode, item_user=item_user,\n                     item_group=item_group, item_mode=item_mode)\n    if is_host_triggered:\n       host_trigger(trg_queue, user=user, group=group, mode=mode)", "response": "Atomically install a queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef uninstall(trg_queue, item_user=None, item_group=None, item_mode=None):\n    '''Idempotently uninstall a queue, should you want to subvert FSQ_ROOT\n       settings, merely pass in an abolute path'''\n    # immediately down the queue\n    try:\n        down(trg_queue, user=item_user, group=item_group,\n             mode=(_c.FSQ_ITEM_MODE if item_mode is None else item_mode))\n    except FSQError, e:\n        raise FSQInstallError(e.errno, wrap_io_os_err(e))\n    tmp_full, tmp_queue = _tmp_trg(trg_queue, _c.FSQ_ROOT)\n    _remove_dir(fsq_path.base(trg_queue), tmp_full, trg_queue)", "response": "Idempotently uninstall a queue"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef uninstall_host(trg_queue, *hosts, **kwargs):\n    '''Idempotently uninstall a host queue, should you want to subvert FSQ_ROOT\n       settings, merely pass in an abolute path'''\n    # immediately down the queue\n    item_user = kwargs.pop('item_user', None)\n    item_group = kwargs.pop('item_group', None)\n    item_mode = kwargs.pop('item_mode', None)\n    for host in hosts:\n    # immediately down the queue\n        try:\n            down_host(trg_queue, host, user=item_user, group=item_group,\n                 mode=(_c.FSQ_ITEM_MODE if item_mode is None else item_mode))\n        except FSQError, e:\n            raise FSQInstallError(e.errno, wrap_io_os_err(e))\n        tmp_full, tmp_queue = _tmp_trg(host, fsq_path.hosts(trg_queue))\n        _remove_dir(fsq_path.base(trg_queue, host), tmp_full, trg_queue)", "response": "Idempotently uninstall a host queue"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the correct constant for a given string.", "response": "def from_string(type_string):\n    '''Returns the correct constant for a given string.\n\n    @raises InvalidCompositeTypeError\n\n    '''\n    if type_string == NONE:\n        return NONE\n    elif type_string == PERIODIC_EC_SHARED:\n        return PERIODC_EC_SHARED\n    elif type_string == PERIODIC_STATE_SHARED:\n        return PERIODIC_STATE_SHARED\n    elif type_string == GROUPING:\n        return GROUPING\n    elif type_string == FSM_EC_SHARED:\n        return FSM_EC_SHARED\n    elif type_string == FSM_STATE_SHARED:\n        return FSM_STATE_SHARED\n    else:\n        raise InvalidCompositeTypeError(type_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_string(comp_type):\n    '''Returns the correct string for a given composite type.\n\n    @raises InvalidCompositeTypeError\n\n    '''\n    if comp_type == NONE:\n        return NONE\n    elif comp_type== PERIODIC_EC_SHARED:\n        return PERIODC_EC_SHARED\n    elif comp_type == PERIODIC_STATE_SHARED:\n        return PERIODIC_STATE_SHARED\n    elif comp_type == GROUPING:\n        return GROUPING\n    elif comp_type == FSM_EC_SHARED:\n        return FSM_EC_SHARED\n    elif comp_type == FSM_STATE_SHARED:\n        return FSM_STATE_SHARED\n    else:\n        raise InvalidCompositeTypeError(type_string)", "response": "Returns the correct string for a given composite type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _replace_old_image(self):\n        ''' Override this in subclass if you don't want\n            image replacing or want to customize image replacing\n        '''\n        try:\n            old_obj = self.__class__.objects.get(pk=self.pk)\n            if old_obj.image.path != self.image.path:\n                path = old_obj.image.path\n                default_storage.delete(path)\n        except self.__class__.DoesNotExist:\n            pass", "response": "Override this in subclass if you don t want\n            image replacing or customize image replacing\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next(self):\n        ''' Returns next image for same content_object and None if image is\n        the last. '''\n        try:\n            return self.__class__.objects.for_model(self.content_object,\n                                                    self.content_type).\\\n                            filter(order__lt=self.order).order_by('-order')[0]\n        except IndexError:\n            return None", "response": "Returns next image for same content_object and None if no more image is found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn previous image for same content_object and None if no image is found.", "response": "def previous(self):\n        ''' Returns previous image for same content_object and None if image\n        is the first. '''\n        try:\n            return self.__class__.objects.for_model(self.content_object,\n                                                    self.content_type).\\\n                            filter(order__gt=self.order).order_by('order')[0]\n        except IndexError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_order_in_album(self, reversed_ordering=True):\n        ''' Returns image order number. It is calculated as (number+1) of images\n        attached to the same content_object whose order is greater\n        (if 'reverse_ordering' is True) or lesser (if 'reverse_ordering' is\n        False) than image's order.\n        '''\n        lookup = 'order__gt' if reversed_ordering else 'order__lt'\n        return self.__class__.objects.\\\n                        for_model(self.content_object, self.content_type).\\\n                        filter(**{lookup: self.order}).count() + 1", "response": "Returns the number of images in the album."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the path to upload the file.", "response": "def get_upload_path(self, filename):\n        ''' Override this in proxy subclass to customize upload path.\n            Default upload path is\n            :file:`/media/images/<user.id>/<filename>.<ext>`\n            or :file:`/media/images/common/<filename>.<ext>` if user is not set.\n\n            ``<filename>`` is returned by\n            :meth:`~generic_images.models.AbstractAttachedImage.get_file_name`\n            method. By default it is probable id of new image (it is\n            predicted as it is unknown at this stage).\n        '''\n        user_folder = str(self.user.pk) if self.user else 'common'\n\n        root, ext = os.path.splitext(filename)\n        return os.path.join('media', 'images', user_folder,\n                            self.get_file_name(filename) + ext)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a function like f but caching its results. Its arguments must be hashable.", "response": "def _memo(f):\n    \"\"\"Return a function like f but caching its results. Its arguments\n    must be hashable.\"\"\"\n    memos = {}\n    def memoized(*args):\n        try: return memos[args]\n        except KeyError:\n            result = memos[args] = f(*args)\n            return result\n    return memoized"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Parser(grammar, **actions):\n    parts = re.split(' ('+_identifier+') += ',\n                     ' '+re.sub(r'\\s', ' ', grammar))\n    if len(parts) == 1 or parts[0].strip():\n        raise BadGrammar(\"Missing left hand side\", parts[0])\n    if len(set(parts[1::2])) != len(parts[1::2]):\n        raise BadGrammar(\"Multiply-defined rule(s)\", grammar)\n    rules = dict((lhs, [alt.split() for alt in (' '+rhs+' ').split(' | ')])\n                 for lhs, rhs in zip(parts[1::2], parts[2::2]))\n    return lambda text, rule=parts[1]: _parse(rules, actions, rule, text)", "response": "r Make a parsing function from a peglet grammar defining the grammar s semantic actions with keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse like parser but return exactly one result not a tuple.", "response": "def OneResult(parser):\n    \"Parse like parser, but return exactly one result, not a tuple.\"\n    def parse(text):\n        results = parser(text)\n        assert len(results) == 1, \"Expected one result but got %r\" % (results,)\n        return results[0]\n    return parse"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a formula into a dictionary containing the encoding and the number of non - interaction terms.", "response": "def _parse_formula(formula):\n    \"\"\"\n    Parse formula into a dictionary\n    formula_dict[variable_name] = [encoding, dropped_name]\n    Parse interactions into a list\n    inter_list = [[A,B], [A,C], [A,B,C]]\n\n    formula = \"A + beta + A*beta | Dev(A,drop=1), Poly(beta,degree=3)\"\n    \"\"\"\n    #TODO: DEAL WITH BSPLINE HAS MULTIPLE ARGUEMENTS (NOT JUST ONE)\n\n    # break formula apart from encoding instructions\n    formula,instr = formula.replace(' ','').split('|')\n    # break formula apart at + sign\n    formula_terms = formula.split('+') \n    # examine the instructions term, first split by ),\n    instr = instr.split('),')\n    # elements in the instr list will match the number of non interaction \n    #      elements in formula\n    # go through each formula term, making a dictionary whose key is variable name\n    formula_dict = {}\n    encoding     = []\n    other_arg    = []\n    inter_list   = []\n    for term in formula_terms:\n        if \"*\" in term:\n            # then this is an interaction term, make 'list of lists'\n            term = term.split('*')\n            inter_list.append(term)\n        else:\n            # then this is not an interaction term, make blank dictionary\n            formula_dict[term] = [encoding, other_arg]\n    # loop through instructions, parse each term\n    for term in instr:\n        # remove punctuation in term\n        term = re.sub('[()]','',term)\n        # check for each encoding type\n        if \"Dev\" in term:\n            # remove first three letters (Dev)\n            term = term[3:]\n            # split on comma\n            var_name,arg = term.split(',')\n            # split on equals sign in arg, take part after\n            drop_name = arg.split('=')[1]\n            # put var_name and drop_name into proper key in formula_dict\n            formula_dict[var_name] = [\"Dev\",drop_name]\n        elif \"Dum\" in term:\n            # remove first three letters (Dum)\n            term = term[3:]\n            # split on comma\n            var_name,arg = term.split(',')\n            # split on equals sign in arg, take part after\n            ref_name = arg.split('=')[1]\n            # put var_name and drop_name into proper key in formula_dict\n            formula_dict[var_name] = [\"Dum\",ref_name]\n        elif \"Poly\" in term:\n            # remove first four letters (Poly)\n            term = term[4:]\n            # split on comma\n            var_name,arg = term.split(',')\n            # split on equals sign in arg, take part after\n            degree = arg.split('=')[1]\n            # put var_name and drop_name into proper key in formula_dict\n            formula_dict[var_name] = [\"Poly\",degree]\n        else:\n            raise Exception(\"Unknown Encoding\")\n    return formula_dict,inter_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntrim the specified columns to the first column in the design matrix", "response": "def trim_columns(self, columns_to_trim):\n        \"\"\"\n        remove column in design matrix\n        \"\"\"\n        # TODO check if trimmed column is actually one of the columns\n        if len(self._trimmed_columns) == 0:\n            self._trimmed_columns.append(columns_to_trim)\n        else:\n            self._trimmed_columns.extend(columns_to_trim)\n        self._trimmed_columns = self._trimmed_columns[0]\n        self.encoder['trimmed_columns'] = self._trimmed_columns"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes param dict from a file on disk", "response": "def make_param_dict_from_file(self,path_to_params):\n        \"\"\"\n        make param dict from a file on disk\n        \"\"\"\n        # then we were given a path to a parameter file\n        param_list = list(csv.reader(open(path_to_params,\"rb\")))\n        # delete empty elements (if any)\n        param_file = [x for x in param_list if x != []]\n        # make dict of [wavenames] = raw_params\n        name_list = []\n        param_list = []\n        # get header names for each param (names of param_list columns)\n        param_colnames = param_file[0][1:] # 0th element is \"Name\" or \"Wavename\"\n        # start from 1.  (row 0 is the header)\n        for i in np.arange(1, len(param_file)):\n            name_list.append(param_file[i][0])\n            param_list.append(param_file[i][1:])\n        # remove ' ' blank spaces from param_list\n        param_list = [[x.strip() for x in y] for y in param_list]\n        param_dict = {}\n        # i loops through param_colnames, j loops thru param values per wave\n        for i in np.arange(0, len(param_colnames)):\n            param_dict[param_colnames[i]] = []\n            for j in np.arange(0,len(name_list)):\n                param_dict[param_colnames[i]].append(param_list[j][i])\n        # now we have param_dict, and name_list\n        self._param_dict = param_dict\n        self._row_names = name_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes the encoder function for the current object", "response": "def make_encoder(self,formula_dict,inter_list,param_dict):\n        \"\"\"\n        make the encoder function\n        \"\"\"\n        X_dict = {}\n        Xcol_dict = {}\n        encoder_dict = {}\n        # first, replace param_dict[key] = values, with param_dict[key] = dmatrix\n        for key in formula_dict:\n            encoding,arg = formula_dict[key]\n            if 'Dev' in encoding:\n                # make deviation encoded design matrix\n                drop_name = arg\n                # encode\n                deviation_encoder,X_sub,colnames_sub = _dev_encode(param_dict,drop_name,key)\n                # additionally, store in dictionary for use by interactions\n                X_dict[key] = X_sub\n                Xcol_dict[key] = colnames_sub\n                # store dictionary of encoder functions to keep for prediction\n                encoder_dict[key] = deviation_encoder\n            elif 'Dum' in encoding:\n                # make dummy variable encoding design mat\n                ref_name = arg\n                dummy_encoder,X_sub,colnames_sub = _dum_encode(param_dict,ref_name,key)\n                # additionally, store in dictionary for use by interactions\n                X_dict[key] = X_sub\n                Xcol_dict[key] = colnames_sub\n                # store dictionary of encoder functions to keep for prediction\n                encoder_dict[key] = dummy_encoder\n            elif 'Poly' in encoding:\n                # make polynomial encoding design mat\n                degree = arg\n                polynomial_encoder,X_sub,colnames_sub = _poly_encode(param_dict,degree,key)\n                # additionally, store in dictionary for use by interactions\n                X_dict[key] = X_sub\n                Xcol_dict[key] = colnames_sub\n                # store dictionary of encoder functions to keep for prediction\n                encoder_dict[key] = polynomial_encoder\n            else:\n                print encoding\n                raise Exception(\"Encoding name error\")\n        # now compute interaction designmatrices\n        for interaction in inter_list:\n            if len(interaction) >= 3:\n                raise Exception(\"Doesn't allow 4-way or higher interaction terms\")\n            elif len(interaction) == 3:\n\n                param_name1 = interaction[0]\n                param_name2 = interaction[1]\n                param_name3 = interaction[2]\n                col_names1 = Xcol_dict[param_name1]\n                col_names2 = Xcol_dict[param_name2]\n                col_names3 = Xcol_dict[param_name3]\n\n                # make 3-way encoder function\n                def threeway_encoder(param_name1,param_name2,param_name3, \\\n                                     col_names1, col_names2, col_names3, X_dict):\n                    \"\"\"\n                    needs the three names of the parameters to be encoded, as well as\n                    a dictionary containing the already encoded single parameter \n                    design matrices, keyed by name\n                    \"\"\"\n                    X1 = X_dict[param_name1]\n                    X2 = X_dict[param_name2]\n                    X3 = X_dict[param_name3]\n\n                    X_int = []\n                    names_int = []\n                    for i in np.arange(0,X1.shape[1]):\n                        for j in np.arange(0,X2.shape[1]):\n                            for k in np.arange(0,X3.shape[1]):\n                                X_int.append(X1[:,i]*X2[:,j]*X3[:,k])\n                                names_int.append(col_names1[i] + \"*\" + \\\n                                                 col_names2[j] + \"*\" + col_names3[k])\n                    # make X_int from lists to np array\n                    X_int = np.array(X_int).T\n                    return X_int, names_int\n                encoder_dict['threeway'] = threeway_encoder\n\n            elif len(interaction) == 2:\n                # there are two interaction terms (A*B)\n\n                param_name1 = interaction[0]\n                param_name2 = interaction[1]\n                col_names1  = Xcol_dict[param_name1]\n                col_names2  = Xcol_dict[param_name2]\n\n                # make twoway_encoder function\n                def twoway_encoder(param_name1,param_name2, col_names1, col_names2, X_dict):\n                    X1 = X_dict[param_name1]\n                    X2 = X_dict[param_name2]\n\n                    X_int = []\n                    names_int = []\n                    for i in np.arange(0,X1.shape[1]):\n                        for j in np.arange(0,X2.shape[1]):\n                            X_int.append(X1[:,i]*X2[:,j])\n                            names_int.append(col_names1[i] + \"*\" + col_names2[j])\n                    X_int = np.array(X_int).T\n                    return X_int, names_int\n                encoder_dict['twoway'] = twoway_encoder\n            else:\n                raise Exception(\"Error while evaluating meaning of interaction term\")\n\n        # make key in encoder to specify which columns are active\n        encoder_dict['trimmed_columns'] = self._trimmed_columns\n        return encoder_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the encoder on a supplied param_dict", "response": "def run_encoder(self,param_dict, encoder_dict):\n        \"\"\"\n        run the encoder on a supplied param_dict\n        \"\"\"\n        X_dict = {}\n        Xcol_dict = {}\n        # put each column of X in Xbycol_dict\n        Xbycol_dict = {}\n        for key in encoder_dict:\n            if (key != 'twoway') and (key != 'threeway') and (key != 'trimmed_columns'):\n                encoder = encoder_dict[key]\n                param_values = param_dict[key]\n                Xsub,names = encoder(key,param_values)\n                X_dict[key] = Xsub\n                Xcol_dict[key] = names\n                for i in np.arange(0,len(names)):\n                    Xbycol_dict[names[i]] = Xsub[:,i]\n\n        # now do interactions\n        inter_list = self._inter_list\n        for interaction in inter_list:\n            if 'twoway' in encoder_dict.keys():\n                encoder = encoder_dict['twoway']\n                param_name1 = interaction[0]\n                param_name2 = interaction[1]\n                col_names1 = Xcol_dict[param_name1]\n                col_names2 = Xcol_dict[param_name2]\n                X_int, names = encoder(param_name1,param_name2, \\\n                                       col_names1,col_names2, X_dict)\n\n                # put columns into Xbycol_dict\n                for i in np.arange(0,len(names)):\n                    Xbycol_dict[names[i]] = X_int[:,i]\n\n            if 'threeway' in encoder_dict.keys():\n                encoder = encoder_dict['threeway']\n                param_name1 = interaction[0]\n                param_name2 = interaction[1]\n                param_name3 = interaction[2]\n                col_names1 = Xcol_dict[param_name1]\n                col_names2 = Xcol_dict[param_name2]\n                col_names3 = Xcol_dict[param_name3]\n                X_int, names = encoder(param_name1,param_name2,param_name3, \\\n                                       col_names1,col_names2,col_names3, X_dict)\n\n                # put columns into Xbycol_dict\n                for i in np.arange(0,len(names)):\n                    Xbycol_dict[names[i]] = X_int[:,i]\n\n        # remove columns that were trimmed (if any)\n        trimmed_columns = encoder_dict['trimmed_columns']\n        full_columns = Xbycol_dict.keys()\n        used_columns = [x for x in full_columns if x not in trimmed_columns]\n        # make design matrix array\n        X = []\n        for name in used_columns:\n            X.append(Xbycol_dict[name])\n        # always add intercept column last\n        X.insert(0,np.ones(np.shape(X[0])))\n        used_columns.insert(0,'Intercept')\n        # final design matrix\n        X = np.vstack(X).T\n        return X, used_columns"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef interpret_obj(\n        self,\n        obj,\n        v_level_indexes,\n        h_level_indexes,\n        v_level_visibility,\n        h_level_visibility,\n        v_level_sort_keys,\n        h_level_sort_keys,\n        v_level_titles,\n        h_level_titles,\n    ):\n        \"\"\"Interpret the given Python object as a table.\n\n        Args:\n            obj: A sequence (later a mapping, too)\n\n        Returns:\n            A list of lists represents rows of cells.\n\n        Raises:\n            TypeError: If the type couldn't be interpreted as a table.\n        \"\"\"\n        if not isinstance(obj, NonStringIterable):\n            raise self.error(\"Cannot make a table from object {!r}\".format(obj))\n\n        rectangular_rows = tabulate(\n            obj,\n            v_level_indexes=v_level_indexes,\n            h_level_indexes=h_level_indexes,\n            v_level_visibility=v_level_visibility,\n            h_level_visibility=h_level_visibility,\n            v_level_sort_keys=v_level_sort_keys,\n            h_level_sort_keys=h_level_sort_keys,\n            v_level_titles=v_level_titles,\n            h_level_titles=h_level_titles,\n        )\n        assert is_rectangular(rectangular_rows)\n        num_rows, num_cols = size(rectangular_rows)\n        return rectangular_rows, num_cols", "response": "Interprets the given Python object as a table."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts each cell into a tuple suitable for consumption by build_table.", "response": "def augment_cells_no_span(self, rows, source):\n        \"\"\"Convert each cell into a tuple suitable for consumption by build_table.\n        \"\"\"\n        # TODO: Hardwired str transform.\n        # 4-tuple: morerows, morecols, offset, cellblock\n        # - morerows: The number of additional rows this cells spans\n        # - morecols: The number of additional columns this cell spans\n        # - offset: Offset from the line-number at the start of the table\n        # - cellblock: The contents of the cell\n        return [\n            [(0, 0, 0, StringList(str(cell).splitlines(), source=source)) for cell in row]\n            for row in rows\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _save_to_database(url, property_name, data):\n    data = json.dumps([\n        d.to_dict() if hasattr(d, \"to_dict\") else d\n        for d in data\n    ])\n\n    logger.debug(\"_save_to_database() data: %s\" % repr(data))\n\n    requests.post(\n        _WEB_URL + _REQUEST_DB_SAVE,\n        timeout=REQUEST_TIMEOUT,\n        allow_redirects=True,\n        verify=False,\n        data={\n            \"url\": url,\n            \"value\": data,\n            \"property_name\": property_name,\n        }\n    )\n\n    logger.info(\n        \"`%s` for `%s` sent to REST DB.\" % (\n            property_name,\n            url,\n        )\n    )", "response": "Saves data under property_name in REST API DB."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef worker(url_key, property_name, function, function_arguments):\n    # this may take some time, hence outside transaction manager\n    error_msg = None\n    try:\n        data = function(*function_arguments)\n    except Exception as e:\n        data = []\n        error_msg = \"Error: \" + traceback.format_exc().strip()\n        error_msg += \"\\n\" + str(e.message)\n\n    # handle logging of possible error message\n    if error_msg:\n        logger.error(error_msg)\n        error_msg = None\n\n    func_name = str(function.__name__)\n    logger.info(\n        \"Attempting to save output from `%s`.\" % func_name\n    )\n\n    # save `data` into RequestInfo object property\n    return _save_to_database(\n        url=url_key,\n        property_name=property_name,\n        data=data\n    )", "response": "This function is a worker function which will run the function and stores the data into REST API\n            storage. It will run the function and then saves it into REST API\n            storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_ip_address(domain):\n    if \"://\" not in domain:\n        domain = \"http://\" + domain\n\n    hostname = urlparse(domain).netloc\n\n    if not hostname:\n        raise ValueError(\"Can't parse hostname!\")\n\n    return socket.gethostbyname(hostname)", "response": "Try to parse the hostname of the given domain."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_whois_tags(ip_address):\n    whois = IPWhois(ip_address).lookup_whois()\n    nets = whois.get(\"nets\", None)\n\n    if not nets:\n        return []\n\n    # parse cities\n    cities = [\n        net[\"city\"]\n        for net in nets\n        if net.get(\"city\", None)\n    ]\n\n    # parse address tags\n    address_list = []\n    for net in nets:\n        address = net.get(\"address\", None)\n        if not address:\n            continue\n\n        # filter company name\n        if \"description\" in net and net[\"description\"]:\n            address = address.replace(net[\"description\"], \"\").strip()\n\n        if \"\\n\" in address:\n            address = \", \".join(address.splitlines())\n\n        address_list.append(address)\n\n    return [\n        SourceString(val, source=\"Whois\")\n        for val in set(cities + address_list)\n    ]", "response": "Get list of tags with address for given ip_address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning list of place tags parsed from meta and whois.", "response": "def get_place_tags(index_page, domain):  #: TODO geoip to docstring\n    \"\"\"\n    Return list of `place` tags parsed from `meta` and `whois`.\n\n    Args:\n        index_page (str): HTML content of the page you wisht to analyze.\n        domain (str): Domain of the web, without ``http://`` or other parts.\n\n    Returns:\n        list: List of :class:`.SourceString` objects.\n    \"\"\"\n    ip_address = get_ip_address(domain)\n    dom = dhtmlparser.parseString(index_page)\n\n    place_tags = [\n        get_html_geo_place_tags(dom),\n        get_whois_tags(ip_address),\n        # [_get_geo_place_tag(ip_address)],  # TODO: implement geoip\n    ]\n\n    return sum(place_tags, [])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_str_node(rawtext, app, prefixed_name, obj, parent, modname, options):\n    text = str(obj)\n    node = nodes.Text(text, rawsource=rawtext)\n    return node", "response": "Render a Python object to text using the repr function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nnaming of the resource.", "response": "def name(self):\n        \"\"\"Name of the resource. If conversion to unicode somehow\n        didn't go well value is returned in base64 encoding.\"\"\"\n        return (\n            self._raw_data.get(ATTR_NAME_UNICODE)\n            or self._raw_data.get(ATTR_NAME)\n            or \"\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloops over incoming data looking for base64 encoded data and converts them to readable format.", "response": "def _sanitize_resources(cls, resources):\n        \"\"\"Loops over incoming data looking for base64 encoded data and\n        converts them to a readable format.\"\"\"\n\n        try:\n            for resource in cls._loop_raw(resources):\n                cls._sanitize_resource(resource)\n        except (KeyError, TypeError):\n            _LOGGER.debug(\"no shade data available\")\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def get_resources(self, **kwargs) -> dict:\n        resources = await self.request.get(self._base_path, **kwargs)\n        self._sanitize_resources(resources)\n        return resources", "response": "Get a list of resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def get_resource(self, resource_id: int) -> dict:\n        resource = await self.request.get(\n            join_path(self._base_path, str(resource_id))\n        )\n        self._sanitize_resource(self._get_to_actual_data(resource))\n        return resource", "response": "Get a single resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of resource instances.", "response": "async def get_instances(self, **kwargs) -> List[ApiResource]:\n        \"\"\"Returns a list of resource instances.\n\n        :raises PvApiError when a hub problem occurs.\"\"\"\n        raw_resources = await self.get_resources(**kwargs)\n        _instances = [\n            self._resource_factory(_raw)\n            for _raw in self._loop_raw(raw_resources)\n        ]\n        return _instances"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a single instance of a pv resource.", "response": "async def get_instance(self, resource_id) -> ApiResource:\n        \"\"\"Gets a single instance of a pv resource\n\n        :raises PvApiError when a hub problem occurs.\"\"\"\n        raw = await self.get_resource(resource_id)\n        return self._resource_factory(self._get_to_actual_data(raw))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multisorted(items, *keys):\n    if len(keys) == 0:\n        keys = [asc()]\n    for key in reversed(keys):\n        items = sorted(items, key=key.func, reverse=key.reverse)\n    return items", "response": "Sort by multiple attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsort by tuples with a different key for each item.", "response": "def tuplesorted(items, *keys):\n    \"\"\"Sort by tuples with a different key for each item.\n\n    Args:\n        items: An iterable series of sequences (typically tuples)\n\n        *keys: Key objects which transform individual elements of\n           each tuple into sort keys. The zeroth object\n           transforms the zeroth element of each tuple, the first\n           key object transforms the first element of each tuple,\n           and so on.\n    Returns:\n        A list of items sorted according to keys.\n    \"\"\"\n    # Transform the keys so each works on one item of the tuple\n    tuple_keys = [\n        Key(func=lambda t, i=index, k=key: k.func(t[i]), reverse=key.reverse)\n        for index, key in enumerate(keys)\n    ]\n    return multisorted(items, *tuple_keys)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show(cls):\n        cls.div_el.style.display = \"block\"\n        cls.hide_errors()\n\n        cls.overlay.show()\n        cls.overlay.el.bind(\"click\", lambda x: cls.hide())", "response": "Show the author picker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_errors(cls):\n        cls.select_el.style.border = \"0\"\n        cls.input_el.style.border = \"0\"", "response": "Hide errors shown by validators."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npick selected option from select_el", "response": "def _pick_selected_option(cls):\n        \"\"\"\n        Select handler for authors.\n        \"\"\"\n        for option in cls.select_el:\n            # if the select is empty\n            if not hasattr(option, \"selected\"):\n                return None\n\n            if option.selected:\n                return option.value\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_pick_button_pressed(cls, ev):\n        cls.hide_errors()\n\n        selected_code = cls._pick_selected_option()\n        if not selected_code:\n            cls.select_el.style.border = \"2px solid red\"\n            return\n\n        cls.selected_code = selected_code\n        cls.code = str(selected_code)\n        cls.original_author_el.value = cls.code_to_data[selected_code].get(\n            \"alt_name\",\n            str(cls.code_to_data[selected_code])\n        )\n        cls.hide()", "response": "Callback called when the user presses the pick button for accepting the pickedCOOKIE."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_select(cls, authors):\n        cls.select_el.html = \"\"\n\n        if not authors:\n            cls.select_el.disabled = True\n            cls.select_el <= html.OPTION(\"Nic nenalezeno!\")\n            return\n\n        cls.select_el.disabled = False\n        for author_dict in authors:\n            name = author_dict.get(\"name\")\n            code = author_dict.get(\"code\")\n            alt_name = author_dict.get(\"alt_name\", name)\n\n            if not (name and code):\n                continue\n\n            cls.code_to_data[code] = author_dict\n            cls.select_el <= html.OPTION(alt_name, value=code)", "response": "Put data into ``<select>`` element.\n\n        Args:\n            authors (dict): Dictionary with author informations returned from\n                aleph REST API. Format:\n                ``{\"name\": .., \"code\": .., \"linked_forms\": [\"..\",]}``."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbind the callbacks to the buttons.", "response": "def bind(cls):\n        \"\"\"\n        Bind the callbacks to the buttons.\n        \"\"\"\n        document[\"show_author_picker\"].bind(\"click\", lambda x: cls.show())\n\n        cls.storno_btn_el.bind(\"click\", lambda x: cls.hide())\n        cls.pick_btn_el.bind(\"click\", cls.on_pick_button_pressed)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind(cls):\n        super(cls, cls).bind()\n\n        cls.search_btn_el.bind(\"click\", cls.start)\n        cls.input_el.bind(\"keypress\", func_on_enter(cls.start))", "response": "Bind the buttons to adapter s event handler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw a horizontal zapping symbol on the canvas that shows the graph in the middle.", "response": "def zap_horizontally(can, style, pat, x1, y1, x2, y2, xsize, ysize):\n    \"\"\"Draw a horizontal \"zapping\" symbol on the canvas that shows\n    that a graph is ripped in the middle.\n\n    Parameter <fill_style> specifies the style for the zig-zag lines.\n    PAT specifies the pattern with which the area is filled.\n    The symbol is drawn in the rectangle (<x1>, <y1>) - (<x2>, <y2>).\n    Each \"zigzag\" has the width <xsize>, height <ysize>.\"\"\"\n\n    assert isinstance(style, line_style.T)\n    assert isinstance(pat, fill_style.T)\n\n    points = []\n    points2 = []\n    x = x1\n    y = y1\n    while x < x2:\n        points.append((x, y))\n        points2.append((x, y + (y2 - y1)))\n        x += xsize\n        if y == y1:\n            y += ysize\n        else:\n            y -= ysize\n\n    points2.reverse()\n    _draw_zap(can, points, points2, style, pat)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw a vertical zapping symbol on the canvas that shows the graph in the middle.", "response": "def zap_vertically(can, style, pat, x1, y1, x2, y2, xsize, ysize):\n    \"\"\"Draw a vertical \"zapping\" symbol on the canvas that shows\n    that a graph is ripped in the middle.\n\n    Parameter <fill_style> specifies the style for the zig-zag lines.\n    PAT specifies the pattern with which the area is filled.\n    The symbol is drawn in the rectangle (<x1>, <y1>) - (<x2>, <y2>).\n    Each \"zigzag\" has the width <xsize>, height <ysize>.\"\"\"\n\n    points = []\n    points2 = []\n    x = x1\n    y = y1\n    while y < y2:\n        points.append((x, y))\n        points2.append((x + (x2 - x1), y))\n        y += ysize\n        if x == x1:\n            x += xsize\n        else:\n            x -= xsize\n\n    points2.reverse()\n    _draw_zap(can, points, points2, style, pat)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the log module and creates the syslog handler and the standard output stream.", "response": "def init(*, threshold_lvl=1, quiet_stdout=False, log_file):\n    \"\"\"\n    Initiate the log module\n\n    :param threshold_lvl: messages under this level won't be issued/logged\n    :param to_stdout: activate stdout log stream\n    \"\"\"\n    global _logger, _log_lvl\n\n    # translate lvl to those used by 'logging' module\n    _log_lvl = _set_lvl(threshold_lvl)\n\n    # logger Creation\n    _logger = logging.getLogger(PKG_NAME)\n    _logger.setLevel(_log_lvl)\n\n    # create syslog handler and set level to info\n    log_h = logging.FileHandler(log_file)\n\n    # Base message format\n    base_fmt = '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n\n    # set formatter\n    log_fmt = logging.Formatter(base_fmt)\n    log_h.setFormatter(log_fmt)\n    # add Handler\n    _logger.addHandler(log_h)\n\n    # create stout handler\n    if not quiet_stdout:\n        global _stdout\n        _stdout = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging a regular message", "response": "def msg(message):\n    \"\"\"\n    Log a regular message\n\n    :param message: the message to be logged\n    \"\"\"\n    to_stdout(\" --- {message}\".format(message=message))\n    if _logger:\n        _logger.info(message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef msg_warn(message):\n    to_stdout(\" (!) {message}\".format(message=message),\n              colorf=yellow, bold=True)\n    if _logger:\n        _logger.warn(message)", "response": "Log a warning message"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs an error message", "response": "def msg_err(message):\n    \"\"\"\n    Log an error message\n\n    :param message: the message to be logged\n    \"\"\"\n    to_stdout(\" !!! {message}\".format(message=message), colorf=red, bold=True)\n    if _logger:\n        _logger.error(message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlog a debug message", "response": "def msg_debug(message):\n    \"\"\"\n    Log a debug message\n\n    :param message: the message to be logged\n    \"\"\"\n    if _log_lvl == logging.DEBUG:\n        to_stdout(\" (*) {message}\".format(message=message), colorf=cyan)\n        if _logger:\n            _logger.debug(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a message from a byte stream.", "response": "def from_bytes(cls, bitstream):\n        '''\n        Look at the type of the message, instantiate the correct class and\n        let it parse the message.\n        '''\n        from pylisp.packet.lisp.control import type_registry\n\n        # Convert to ConstBitStream (if not already provided)\n        if not isinstance(bitstream, ConstBitStream):\n            if isinstance(bitstream, Bits):\n                bitstream = ConstBitStream(auto=bitstream)\n            else:\n                bitstream = ConstBitStream(bytes=bitstream)\n\n        # Peek at the bitstream to see which type it is\n        type_nr = bitstream.peek('uint:4')\n\n        # Look for the right class\n        type_class = type_registry.get_type_class(type_nr)\n        if not type_class:\n            raise ValueError(\"Can't handle message type {0}\".format(type_nr))\n\n        # Let the specific class handle it from now on\n        return type_class.from_bytes(bitstream)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index(request, template_name='staffmembers/index.html'):\n    return render_to_response(template_name,\n                              {'staff': StaffMember.objects.active()},\n                              context_instance=RequestContext(request))", "response": "Returns the list of employees or staff members."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef userinfo_json(request, user_id):\n    data = {'first_name': '',\n            'last_name': '',\n            'email': '',\n            'slug': '',\n            'bio': '',\n            'phone': '',\n            'is_active': False}\n\n    try:\n        member = StaffMember.objects.get(pk=user_id)\n        for key in data.keys():\n            if hasattr(member, key):\n                data[key] = getattr(member, key, '')\n\n    except StaffMember.DoesNotExist:\n        pass\n\n    return HttpResponse(json.dumps(data),\n                        mimetype='application/json')", "response": "Return the user s information in a json object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef contact(request, slug, template_name='staffmembers/contact.html',\n            success_url='/staff/contact/done/',\n            email_subject_template='staffmembers/emails/subject.txt',\n            email_body_template='staffmembers/emails/body.txt'):\n    \"\"\"\n    Handle a contact request\n    \"\"\"\n    member = get_object_or_404(StaffMember, slug__iexact=slug, is_active=True)\n\n    if request.method == 'POST':\n        form = ContactForm(request.POST)\n        if form.is_valid():\n            subject = render_to_string(\n                email_subject_template,\n                {'member': member}\n            )\n            subject = ''.join(subject.splitlines())\n\n            message = render_to_string(\n                email_body_template,\n                {'name': form.cleaned_data['name'],\n                'email': form.cleaned_data['email'],\n                'message': form.cleaned_data['message']}\n            )\n\n            EmailMessage(subject, message, settings.DEFAULT_FROM_EMAIL,\n                [member.email], headers={\n                    'Reply-To': form.cleaned_data['email']\n                }).send()\n\n            return HttpResponseRedirect(success_url)\n    else:\n        initial = {}\n        if not request.user.is_anonymous():\n            initial = {'name': '%s %s' % (request.user.first_name,\n                                          request.user.last_name),\n                        'email': request.user.email}\n        form = ContactForm(initial=initial)\n\n    return render_to_response(template_name,\n                              {'form': form,\n                               'member': member},\n                              context_instance=RequestContext(request))", "response": "Handle a contact request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of stories written by this staff member", "response": "def story_archive(request, slug, template_name='staffmembers/story_archive.html'):\n    \"\"\"\n    Return the list of stories written by this staff member\n    \"\"\"\n    member = get_object_or_404(StaffMember, slug__iexact=slug, is_active=True)\n\n    stories = []\n    if hasattr(member, 'story_set'):\n        from story.settings import PUBLISHED_STATUS\n        stories = member.story_set.filter(publish_date__lte=datetime.now()\n            ).filter(status__exact=PUBLISHED_STATUS\n            ).order_by('-publish_date')\n\n    return render_to_response(template_name,\n                              {'member': member,\n                               'stories': stories},\n                              context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse an application section.", "response": "def _parse_application_section(cfg, parser, section):\n    '''\n    Example of application section:\n    [application:flt]\n    import: flt.application\n    name: flt\n    # pythonpath is optional\n    pythonpath: /etc/flt/python\n    '''\n    try:\n        sys.path.append(cfg.get(section, 'pythonpath'))\n    except ConfigParser.NoOptionError:\n        pass\n\n    module = cfg.get(section, 'import')\n    name = cfg.get(section, 'name')\n    try:\n        applications.load(module, name)\n    except ImportError as e:\n        raise error.FeatError(\n            \"Loading application %s.%s failed, requested from section %s\" %\n            (module, name, section, ), cause=e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the agent section.", "response": "def _parse_agent_section(cfg, parser, section):\n    '''\n    Example of agent section:\n    [agent:dns_production]\n    application: feat\n    agent_type: dns_agent\n    descriptor.some_integer: 5\n    descriptor.some_string: \"hello\"\n    initiate.suffix: \"service.lan\"\n    initiate.array_of_strings: [\"string1\", \"string2\"]\n    '''\n    agent_type = cfg.get(section, 'agent_type')\n    desc_keywords = dict()\n    initiate_keywords = dict()\n    for name, value in cfg.items(section):\n        if name.startswith('descriptor'):\n            key = name.split('.')[1]\n            desc_keywords[key] = _unserialize_json_field(\n                section, name, value)\n        elif name.startswith('initiate'):\n            key = name.split('.')[1]\n            initiate_keywords[key] = _unserialize_json_field(\n                section, name, value)\n    name = section.split(':', 2)[1]\n    append_agent(parser, agent_type, desc_keywords, initiate_keywords, name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch( call_hash ):\n    res = select_expected_value(call_hash)\n    if not res:\n        return None\n\n    last_packet_number = -1\n    expected_value = \"\"\n    for packet in res:\n        call_hash, expected_value_fragment, packet_num = packet\n        expected_value += expected_value_fragment\n        if packet_num <= last_packet_number:\n            raise Exception(\"Received expected_value data out of order!\")\n\n        last_packet_number = packet_num\n\n    return ExpectedValue( call_hash      = call_hash,\n                          expected_value = pickle.loads(str(expected_value)) )", "response": "Fetches the CallDescriptor corresponding to the given hash key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the ExpectedValue of a call.", "response": "def save( self ):\n        \"\"\"\n        Save method for the ExpectedValue of a call.\n\n        \"\"\"\n        packets = self.__enumerate_packets()\n        delete_expected_value(self.call_hash)\n        for packet in packets:\n            packet['call_hash'] = self.call_hash\n            insert_expected_value(packet)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the inputdict for the current object.", "response": "def _validate_inputs(self, inputdict):\n        \"\"\" Validate input links.\n        \"\"\"\n        # Check inputdict\n        try:\n            parameters = inputdict.pop(self.get_linkname('parameters'))\n        except KeyError:\n            raise InputValidationError(\"No parameters specified for this \"\n                                       \"calculation\")\n        if not isinstance(parameters, ParameterData):\n            raise InputValidationError(\"parameters not of type \"\n                                       \"ParameterData\")\n        # Check code\n        try:\n            code = inputdict.pop(self.get_linkname('code'))\n        except KeyError:\n            raise InputValidationError(\"No code specified for this \"\n                                       \"calculation\")\n\n        # Check input files\n        try:\n            structure = inputdict.pop(self.get_linkname('structure'))\n            if not isinstance(structure, SinglefileData):\n                raise InputValidationError(\n                    \"structure not of type SinglefileData\")\n        except KeyError:\n            raise InputValidationError(\n                \"No input structure specified for calculation\")\n\n        try:\n            surface_sample = inputdict.pop(self.get_linkname('surface_sample'))\n            if not isinstance(surface_sample, SinglefileData):\n                raise InputValidationError(\n                    \"surface_sample not of type SinglefileData\")\n        except KeyError:\n            raise InputValidationError(\n                \"No surface sample specified for calculation\")\n\n        # Check that nothing is left unparsed\n        if inputdict:\n            raise ValidationError(\"Unrecognized inputs: {}\".format(inputdict))\n\n        return parameters, code, structure, surface_sample"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare the CalcInfo object to be returned to the plugin.", "response": "def _prepare_for_submission(self, tempfolder, inputdict):\n        \"\"\"\n        Create input files.\n\n            :param tempfolder: aiida.common.folders.Folder subclass where\n                the plugin should put all its files.\n            :param inputdict: dictionary of the input nodes as they would\n                be returned by get_inputs_dict\n        \"\"\"\n        parameters, code, structure, surface_sample = \\\n                self._validate_inputs(inputdict)\n\n        # Prepare CalcInfo to be returned to aiida\n        calcinfo = CalcInfo()\n        calcinfo.uuid = self.uuid\n        calcinfo.local_copy_list = [\n            [structure.get_file_abs_path(), structure.filename],\n            [surface_sample.get_file_abs_path(), surface_sample.filename],\n        ]\n        calcinfo.remote_copy_list = []\n        calcinfo.retrieve_list = parameters.output_files\n\n        codeinfo = CodeInfo()\n        # will call ./code.py in.json out.json\n        codeinfo.cmdline_params = parameters.cmdline_params(\n            structure_file_name=structure.filename,\n            surface_sample_file_name=surface_sample.filename)\n        codeinfo.code_uuid = code.uuid\n        calcinfo.codes_info = [codeinfo]\n\n        return calcinfo"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck and optionally fix properties", "response": "def sanitize(self):\n        '''\n        Check and optionally fix properties\n        '''\n        # Let the parent do its stuff\n        super(Protocol, self).sanitize()\n\n        # Check if the next header is of the right type, and fix this header\n        # if we know better (i.e. the payload is a ProtocolElement so we know\n        # the header_type)\n        if isinstance(self.payload, Protocol):\n            self.next_header = self.payload.header_type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the ~. datadog. ini section and returns a dictionary of all properties that are allowed in the section.", "response": "def read(section: str = 'DEFAULT'):\n    \"\"\"\n    reads the ~/.datadog.ini `section` with the following allowed properties\n\n    :param section identifying a specific datadog account\n\n\n    api_key: Datadog API key\n    type api_key: string\n\n    app_key: Datadog application key\n    type app_key: string\n\n    proxies: Proxy to use to connect to Datadog API\n    type proxies: dictionary mapping protocol to the URL of the proxy.\n\n    api_host: Datadog API endpoint\n    type api_host: url\n\n    statsd_host: Host of DogStatsd server or statsd daemon\n    type statsd_host: address\n\n    statsd_port: Port of DogStatsd server or statsd daemon\n    type statsd_port: port\n\n    statsd_use_default_route: Dynamically set the statsd host to the default route\n    (Useful when running the client in a container)\n    type statsd_use_default_route: boolean\n\n    statsd_socket_path: path to the DogStatsd UNIX socket. Supersedes statsd_host\n    and stats_port if provided.\n\n    cacert: Path to local certificate file used to verify SSL \\\n        certificates. Can also be set to True (default) to use the systems \\\n        certificate store, or False to skip SSL verification\n    type cacert: path or boolean\n\n    mute: Mute any ApiError or ClientError before they escape \\\n        from datadog.api.HTTPClient (default: True).\n    type mute: boolean\n    \"\"\"\n    parser = ConfigParser()\n    parser.read(path.expanduser('~/.datadog.ini'))\n    return {\n        k: v\n        for (k, v) in parser.items(section) if k in allowed_properties\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure Flask/Celery application. * Rio will find environment variable `RIO_SETTINGS` first:: $ export RIO_SETTINGS=/path/to/settings.cfg $ rio worker * If `RIO_SETTINGS` is missing, Rio will try to load configuration module in `rio.settings` according to another environment variable `RIO_ENV`. Default load `rio.settings.dev`. $ export RIO_ENV=prod $ rio worker", "response": "def configure_app(app):\n    \"\"\"Configure Flask/Celery application.\n\n    * Rio will find environment variable `RIO_SETTINGS` first::\n\n        $ export RIO_SETTINGS=/path/to/settings.cfg\n        $ rio worker\n\n    * If `RIO_SETTINGS` is missing, Rio will try to load configuration\n      module in `rio.settings` according to another environment\n      variable `RIO_ENV`. Default load `rio.settings.dev`.\n\n        $ export RIO_ENV=prod\n        $ rio worker\n    \"\"\"\n    app.config_from_object('rio.settings.default')\n\n    if environ.get('RIO_SETTINGS'):\n        app.config_from_envvar('RIO_SETTINGS')\n        return\n\n    config_map = {\n        'dev': 'rio.settings.dev',\n        'stag': 'rio.settings.stag',\n        'prod': 'rio.settings.prod',\n        'test': 'rio.settings.test',\n    }\n\n    rio_env = environ.get('RIO_ENV', 'dev')\n    config = config_map.get(rio_env, config_map['dev'])\n    app.config_from_object(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister blueprints to application.", "response": "def register_blueprints(app):\n    \"\"\"Register blueprints to application.\n\n    Currently, Rio registered:\n\n    * /api/1\n    * /dashboard\n    \"\"\"\n\n    from .blueprints.event import bp as event_bp\n    app.register_blueprint(event_bp, url_prefix='/event')\n\n    from .blueprints.api_1 import bp as api_1_bp\n    app.register_blueprint(api_1_bp, url_prefix='/api/1')\n\n    from .blueprints.dashboard import bp as dashboard_bp\n    app.register_blueprint(dashboard_bp, url_prefix='/dashboard')\n\n    from .blueprints.health import bp as health_bp\n    app.register_blueprint(health_bp, url_prefix='/health')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_image(name, exts=None):\n\n    default = ['jpg', 'png', 'gif', 'jpeg']\n    if exts:\n        default += exts\n\n    flag = False\n    for ext in default:\n        if name.lower().endswith(ext):\n            flag = True\n            break\n    return flag", "response": "return True if the name or path is endswith jpg png gif or jpeg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_empty_dir(path):\n    try:\n        if not os.path.isdir(path):\n            return\n\n        files = os.listdir(path)\n\n        # if folder empty, delete it\n        if len(files) == 0:\n            os.rmdir(path)\n\n        # remove empty subdirectory\n        elif len(files) > 0:\n            for f in files:\n                abspath = os.path.join(path, f)\n                if os.path.isdir(abspath):\n                    remove_empty_dir(abspath)\n    except OSError as e:\n        if e.errno == errno.ENOTEMPTY:\n            pass", "response": "Function to remove empty folders"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a human readable size in a number of units.", "response": "def human_size(s, factor):\n    \"\"\"\n    :s: size\n    :factor: 1000 or 1024\n    \"\"\"\n    unit = 'B'\n    if s > factor:\n        s /= factor\n        unit = 'KB'\n    if s > factor:\n        s /= factor\n        unit = 'MB'\n    if s > factor:\n        s /= factor\n        unit = 'GB'\n    if s > factor:\n        s /= factor\n        unit = 'TB'\n    return '%.2f %s' % (s, unit)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_soup_tag(tag):\n        \"Returns a new Period instance from the given beautifulsoup tag.\"\n        days = []\n        for elem in tag.findAll(recursive=False):\n            if elem.name != 'day':\n                raise TypeError(\"Unknown tag found: \" + str(elem))\n            days.append(elem.string)\n        return Period(\n            tag['type'], tag['instructor'], tag['start'], tag['end'],\n            tag['location'], days\n        )", "response": "Returns a new Period instance from the given beautifulsoup tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks this period conflicts with another period.", "response": "def conflicts_with(self, period):\n        \"Checks this period conflicts with another period.\"\n        if self.tba or period.tba:\n            return False\n        same_day = False\n        for i in self.int_days:\n            if i in period.int_days:\n                same_day = True\n\n        if not same_day:\n            return False\n\n        return self.start <= period.start <= self.end or \\\n            period.start <= self.start <= period.end or \\\n            self.start <= period.end <= self.end or \\\n            period.start <= self.end <= period.end"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an instance from a given soup tag.", "response": "def from_soup_tag(tag):\n        \"Returns an instance from a given soup tag.\"\n        periods = []\n        notes = []\n        for elem in tag.findAll(recursive=False):\n            if elem.name not in ('period', 'note'):\n                raise TypeError(\"Unknown tag found: \" + str(elem))\n            if elem.name == 'note':\n                notes.append(elem.string.strip())\n            elif elem.name == 'period':\n                periods.append(Period.from_soup_tag(elem))\n        return Section(\n            tag['crn'], tag['num'], tag['students'], tag['seats'],\n            periods, notes\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef credits(self):\n        if self.cred[0] == self.cred[1]:\n            return self.cred[0]\n        return self.cred", "response": "Returns either a tuple representing the credit range or a single integer representing the credit range."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_soup_tag(tag):\n        \"Creates an instance from a given soup tag.\"\n        sections = [Section.from_soup_tag(s) for s in tag.findAll('section')]\n        return Course(\n            tag['name'], tag['dept'], int(tag['num']), tag['credmin'],\n            tag['credmax'], tag['gradetype'], [s for s in sections if s.is_valid]\n        )", "response": "Creates an instance from a given soup tag."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a random password.", "response": "def password_generator(length):\n    \"\"\"Generate a random password.\n\n    :param length: integer.\n    \"\"\"\n    return ''.join(random.choice(string.ascii_lowercase + string.digits)\n                   for _ in range(length))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_bytes(self):\n        '''\n        Create bytes from properties\n        '''\n        # Verify that the properties make sense\n        self.sanitize()\n\n        # Write the next header type\n        bitstream = BitStream('uint:8=%d' % self.next_header)\n\n        # Write the header length\n        header_length_unpadded = len(self.data) + 4\n        header_length = math.ceil(header_length_unpadded / 8.0)\n        bitstream += BitStream('uint:8=%d' % (header_length - 1))\n\n        # Add the routing type\n        bitstream += BitStream('uint:8=%d' % self.routing_type)\n\n        # Add the segments left\n        bitstream += BitStream('uint:8=%d' % self.segments_left)\n\n        # Add the data\n        bitstream += BitStream(bytes=self.data)\n        padding_len = (8 - (header_length_unpadded % 8)) % 8\n        bitstream += BitStream(padding_len * 8)\n\n        return bitstream.bytes + bytes(self.payload)", "response": "Create bytes from properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all instructions from a basic block.", "response": "def get_instructions(self):\n        \"\"\"\n        Get all instructions from a basic block.\n\n        :rtype: Return all instructions in the current basic block\n      \"\"\"\n        tmp_ins = []\n        idx = 0\n        for i in self.method.get_instructions():\n            if idx >= self.start and idx < self.end:\n                tmp_ins.append(i)\n\n            idx += i.get_length()\n        return tmp_ins"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving all reports submitted for this Sample.", "response": "def get_reports(self):\n        \"\"\"\n        Retrieve all reports submitted for this Sample.\n\n        :return: A list of :class:`.Report`\n        \"\"\"\n        url = '{}reports/'.format(self.url)\n        return Report._get_list_from_url(url, append_base_url=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all SampleRelation s in the relation graph of the sample.", "response": "def get_relation_graph(self, depth=None):\n        \"\"\"\n        Get all `SampleRelation`s in the relation graph of the sample.\n\n        :param depth: max depth of the returned graph. None retrieves the complete graph.\n        :return: An iterator over the relations\n        \"\"\"\n        url = '{}relation_graph/'.format(self.url)\n        if depth is not None:\n            params = {'depth': depth}\n        else:\n            params = {}\n\n        from .sample_relation import SampleRelation\n        return SampleRelation._get_iter_from_url(url, params=params, append_base_url=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(cls, domain, tlp_level=0, tags=[]):\n        return cls._create(domain=domain, tlp_level=tlp_level, tags=tags)", "response": "Create a new : class : DomainSample on the server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new entry on the server.", "response": "def create(cls, uri, tlp_level=0, tags=[]):\n        \"\"\"\n        Create a new :class:`URISample` on the server.\n\n        :param uri: The uri as a string.\n        :param tlp_level: The TLP-Level\n        :param tags: Tags to add to the sample.\n        :return: The created sample.\n        \"\"\"\n        return cls._create(uri=uri, tlp_level=tlp_level, tags=tags)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(cls, ip_address, tlp_level=0, tags=[]):\n        return cls._create(ip_address=ip_address, tlp_level=tlp_level, tags=tags)", "response": "Create a new : class : IPSample on the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(cls, filename, file, tlp_level=0, tags=[]):\n        return cls._create(additional_binary_files={'file': (filename, file)}, tlp_level=tlp_level, tags=tags)", "response": "Create a new file sample on the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_to_file(self, file):\n        con = ConnectionManager().get_connection(self._connection_alias)\n        return con.download_to_file(self.file, file, append_base_url=False)", "response": "Download and store the file of the sample."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef git_remote(self):\n        if self._git_remotes is None or len(self._git_remotes) < 1:\n            return None\n        if 'origin' in self._git_remotes:\n            return self._git_remotes['origin']\n        k = sorted(self._git_remotes.keys())[0]\n        return self._git_remotes[k]", "response": "Returns the first URL of the git remote that is configured for the repo or None if there is no git remote."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string describing the git repo remote and state of the git repo.", "response": "def git_str(self):\n        \"\"\"\n        If the distribution is not installed via git, return an empty string.\n\n        If the distribution is installed via git and pip recognizes the git\n        source, return the pip requirement string specifying the git URL and\n        commit, with an '*' appended if :py:attr:`~.git_is_dirty` is True.\n\n        Otherwise, return a string of the form:\n\n            url@ref[*]\n\n        Where URL is the remote URL, ref is the tag name if the repo is checked\n        out to a commit that matches a tag or else the commit hex SHA, and '*'\n        is appended if :py:attr:`~.git_is_dirty` is True.\n\n        :return: description of the git repo remote and state\n        :rtype: str\n        \"\"\"\n        dirty = '*' if self._git_is_dirty else ''\n        if 'git' in self._pip_requirement:\n            return self._pip_requirement + dirty\n        if self._git_commit is None and self._git_remotes is None:\n            return ''\n        ref = self._git_tag if self._git_tag is not None else self._git_commit\n        return '%s@%s%s' % (self.git_remote, ref, dirty)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string of the form ver <url > where ver is the distribution Hom - Page version and url is the distribution Home - Page url or an empty string if neither of the attributes are set.", "response": "def short_str(self):\n        \"\"\"\n        Return a string of the form \"ver <url>\" where ver is the distribution\n        version and URL is the distribution Home-Page url, or '' if neither\n        can be found.\n\n        :return: version and URL\n        :rtype: str\n        \"\"\"\n        if self.version is None and self.url is None:\n            return ''\n        return '%s <%s>' % (self.version, self.url)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef long_str(self):\n        gs = self.git_str\n        if gs == '':\n            return self.short_str\n        return self.short_str + ' (' + gs + ')'", "response": "Return a long version and installation specifier string of the form SHORT_STR or GIT_STR."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_dict(self):\n        return {\n            'pip_version': self._pip_version,\n            'pip_url': self._pip_url,\n            'pip_requirement': self._pip_requirement,\n            'pkg_resources_version': self._pkg_resources_version,\n            'pkg_resources_url': self._pkg_resources_url,\n            'git_tag': self._git_tag,\n            'git_commit': self._git_commit,\n            'git_remotes': self._git_remotes,\n            'git_is_dirty': self._git_is_dirty,\n        }", "response": "Return the constructor arguments as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling the method in the agent side.", "response": "def call_agent_side(self, method, *args, **kwargs):\n        '''\n        Call the method, wrap it in Deferred and bind error handler.\n        '''\n        assert not self._finalize_called, (\"Attempt to call agent side code \"\n                                           \"after finalize() method has been \"\n                                           \"called. Method: %r\" % (method, ))\n\n        ensure_state = kwargs.pop('ensure_state', None)\n\n\n        d = defer.Deferred(canceller=self._cancel_agent_side_call)\n        self._agent_jobs.append(d)\n        if ensure_state:\n            # call method only if state check is checks in\n            d.addCallback(\n                lambda _: (self._ensure_state(ensure_state) and\n                           method(*args, **kwargs)))\n        else:\n            d.addCallback(defer.drop_param, method, *args, **kwargs)\n        d.addErrback(self._error_handler, method)\n        d.addBoth(defer.bridge_param, self._remove_agent_job, d)\n        time.call_next(d.callback, None)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats a role in a new language.", "response": "def format_role(name, rawtext, text, lineno, inliner, options=None, content=None):\n    \"\"\"Include Python object value, rendering it to text using str.\n\n    Returns 2 part tuple containing list of nodes to insert into the\n    document and a list of system messages.  Both are allowed to be\n    empty.\n\n    :param make_node: A callable which accepts (rawtext, app, prefixed_name, obj, parent, modname, options) and which returns a node\n    :param name: The role name used in the document.\n    :param rawtext: The entire markup snippet, with role.\n    :param text: The text marked with the role.\n    :param lineno: The line number where rawtext appears in the input.\n    :param inliner: The inliner instance that called us.\n    :param options: Directive options for customization.\n    :param content: The directive content for customization.\n    \"\"\"\n    if options is None:\n        options = {}\n\n    if content is None:\n        content = []\n\n    name, _, format_spec = tuple(field.strip() for field in text.partition(\",\"))\n\n    try:\n        prefixed_name, obj, parent, modname = import_by_name(name)\n    except ImportError:\n        msg = inliner.reporter.error(\"Could not locate Python object {}\".format(text), line=lineno)\n        prb = inliner.problematic(rawtext, rawtext, msg)\n        return [prb], [msg]\n    app = inliner.document.settings.env.app\n\n    try:\n        formatted_value = format(obj, format_spec)\n    except ValueError as value_error:\n        msg = inliner.reporter.error(\n            \"Format error in {}: {}\".format(text, value_error), line=lineno\n        )\n        prb = inliner.problematic(rawtext, rawtext, msg)\n        return [prb], [msg]\n\n    node = nodes.Text(formatted_value, rawsource=rawtext)\n    return [node], []"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfilters out any objects that do not have attributes with values matching all regular expressions present in grep.", "response": "def object_filter(objects, grep):\n    \"\"\"Filter out any objects that do not have attributes with values matching\n    *all* regular expressions present in grep (AND, essentially)\n\n    :param objects ADObject: A list of ADObjects\n    :param grep list: A list of regular expressions that must match for filtering\n\n    :return: A list of filtered ADObjects\n    :rtype: list\n    \"\"\"\n    filtered = []\n    if grep:\n        for ad_object in objects:\n            o_string = ' '.join([value for value in ad_object.to_dict().values()\n                                 if isinstance(value, str)])\n            skip = False\n            for regex in grep:\n                if not re.search(regex, o_string, re.M|re.S|re.I):\n                    skip = True\n                    break\n            if not skip:\n                filtered.append(ad_object)\n\n        return filtered\n    else:\n        return objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nserializes the list of ADObjects to the specified format", "response": "def serialize(ad_objects, output_format='json', indent=2, attributes_only=False):\n    \"\"\"Serialize the object to the specified format\n\n    :param ad_objects list: A list of ADObjects to serialize\n    :param output_format str: The output format, json or yaml.  Defaults to json\n    :param indent int: The number of spaces to indent, defaults to 2\n    :param attributes only: Only serialize the attributes found in the first record of the list\n        of ADObjects\n\n    :return: A serialized, formatted representation of the list of ADObjects\n    :rtype: str\n    \"\"\"\n\n    # If the request is to only show attributes for objects returned\n    # in the query, overwrite ad_objects with only those attributes present in\n    # the first object in the list\n    if attributes_only:\n        ad_objects = [key for key in sorted(ad_objects[0].keys())]\n\n    if output_format == 'json':\n        return json.dumps(ad_objects, indent=indent, ensure_ascii=False, sort_keys=True)\n    elif output_format == 'yaml':\n        return yaml.dump(sorted(ad_objects), indent=indent)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_url_parameters(url, parameters):\n        scheme, netloc, path, query_string, fragment = urlsplit(url)\n        query = parse_qs(query_string)\n        query.update(parameters)\n        return urlunsplit((scheme, netloc, path, urlencode(query), fragment))", "response": "Add url parameters to URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all the objects in the given entity.", "response": "def get(self, entity, id=None, sub_entity=None, offset=0, limit=20,\n            search_terms=None, sync=True):\n        \"\"\"\n        Get all entities that fufill the given filtering if provided.\n\n        :todo: Rename search_terms\n        \"\"\"\n        url = urljoin(self.host, entity.value + '/')\n        url = urljoin(url, id + '/') if id else url\n        url = urljoin(url, sub_entity.value + '/') if sub_entity else url\n        terms = {'sync': str(sync).lower()}\n        if search_terms:\n            terms.update(search_terms)\n        if not id:\n            terms.update({'limit': limit, 'offset': offset})\n        url = Utils.add_url_parameters(url, terms)\n        r = requests.get(url, auth=self.auth, headers=self.headers)\n        if sub_entity == Entity.Content:\n            return r.content\n        elif r.ok:\n            j = r.json()\n\n            if 'meta' not in j:\n                # TODO: Fix error in API. No meta data returned when getting a\n                # single object.\n                return {'objects': [j]}\n\n            next_path = j['meta']['next']\n\n            while next_path:\n                offset += limit\n                url = urljoin(self.host, entity.value + '/')\n                url = urljoin(url, id + '/') if id else url\n                url = urljoin(\n                    url, sub_entity.value + '/') if sub_entity else url\n                terms = {'offset': offset}\n                url = Utils.add_url_parameters(\n                    url, {'offset': offset})\n                r = requests.get(url, auth=self.auth, headers=self.headers)\n                j['objects'].extend(r.json()['objects'])\n                next_path = r.json()['meta']['next']\n\n            return j['objects']\n        else:\n            raise CoredataError(\n                'Error occured! Status code is {code} for {url}'.format(\n                    code=r.status_code, url=url))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncarries out Freesurfer's reconall on T1 nifti file WARNING: Reconall takes very long to run!! http://nipy.sourceforge.net/nipype/users/examples/smri_freesurfer.html Parameters ---------- subjfile: nifti file Path to subject's T1 nifti file subjID: string optional name for subject's output folder subjdir: string The directory to where segmentation results should be saved. Defaults to same directory as subjfile. runreconall: boolean If set to true, runs reconall, otherwise just converts assorted mgz files to nii", "response": "def reconall(subjfile, subjID=None, subjdir=None, runreconall=True): \n    \"\"\"\n    Carries out Freesurfer's reconall on T1 nifti file\n    \n    WARNING: Reconall takes very long to run!!\n\n    http://nipy.sourceforge.net/nipype/users/examples/smri_freesurfer.html\n\n    Parameters\n    ----------\n    subjfile: nifti file\n        Path to subject's T1 nifti file\n    \n    subjID: string\n        optional name for subject's output folder\n\n    subjdir: string\n\n        The directory to where segmentation results should be saved. Defaults\n        to same directory as subjfile.\n\n    runreconall: boolean\n        If set to true, runs reconall, otherwise just converts assorted mgz\n        files to nii \n    \"\"\"  \n    T1dir = os.path.dirname(subjfile)\n    filename = os.path.basename(subjfile)\n\n    # subject ID\n    if subjID==None:\n        m=re.search('(\\w+?)_*_', subjfile)\n        subjID=m.group(0) + 'seg'        \n\n    # Tell freesurfer what subjects directory to use\n    if subjdir==None:\n        subjdir=T1dir\n    fs.FSCommand.set_default_subjects_dir(subjdir)\n    segdir=subjdir+'/'+subjID+'/'\n    print('saving to ' + subjdir)\n\n    # check if file exists\n    if os.path.isfile(subjfile):\n        print('running recon-all on ' + filename)\n    else:\n        raise ValueError(\"File: %s does not exist!\"%filename)\n\n    # check if nifti format\n    ext=filename.split('.')[1].lower()\n    if ext != \"nii\":\n        raise ValueError(\"File: %s is not a nifti file!\"%filename)\n\n\n    wf = pe.Workflow(name=\"segment\")\n    wf.base_dir = T1dir\n\n    if runreconall:\n        # run recon-all\n        reconall = pe.Node(interface=fs.ReconAll(), name='reconall')\n        reconall.inputs.subject_id = subjID \n        reconall.inputs.directive = 'all'\n        reconall.inputs.subjects_dir = subjdir\n        reconall.inputs.T1_files = subjfile\n    \n        wf.add_nodes([reconall])\n        result = wf.run()\n\n    # convert mgz to nii\n    wf2 = pe.Workflow(name=\"convertmgz\")\n    wf2.base_dir = T1dir\n\n    convertmgz = pe.Node(interface=fs.MRIConvert(), name='convertmgz')\n    convertmgz.inputs.in_file = segdir+'mri/aseg.auto.mgz'\n    convertmgz.inputs.out_orientation='LPS'\n    convertmgz.inputs.resample_type= 'nearest'\n    convertmgz.inputs.reslice_like= subjfile\n    convertmgz.inputs.out_file=segdir+subjID+'_aseg.nii.gz'\n\n    wf2.add_nodes([convertmgz])\n    result2 = wf2.run()\n    if runreconall:\n        return (result, result2)\n    else:\n        return (result2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns grey white and csf content within MRS voxel.", "response": "def MRSvoxelStats(segfile, MRSfile=None, center=None, dim=None, subjID=None,\n                  gareas=GAREAS,wareas=WAREAS,csfareas=CSFAREAS):\n    \"\"\"\n    returns grey/white/CSF content within MRS voxel\n\n    Parameters\n    ----------\n    segfile:  nifti file\n        path to segmentation file with grey/white matter labels (freesurfer\n        aseg file converted from mgz). \n\n    MRSfile: nifti file\n        path to MRSfile of MRS voxel. provide either this or center + dim\n\n    center : integer array\n        [x,y,z] where x, y and z are the coordinates of the point of\n        interest. Provide either MRSfile or center+dim \n    \n    dim : float array\n        dimensions of voxel in mm. Provide either MRSfile or center+dim\n\n    subjID: string\n        optional subject identifier. Defaults to nims scan number\n\n    gareas, wareas, csfareas: arrays of integers\n        arrays of freesurfer labels for gray, white, and csf areas\n        respectively. Determines which areas are considered\n        grey/white/csf. Some areas like brainstem were lumped with grey\n        matter. Did not include hypointensities. \n   \n    Returns\n    -------\n\n    raw number of voxels and proportions of grey, white, csf and\n    non-grey-or-white-matter \n\n    Notes\n    -----\n    See http://miykael.github.io/nipype-beginner-s-guide/regionOfInterest.html\n\n    \"\"\"\n    # subject ID\n    if subjID==None:\n        m=re.search('(\\w+?)_*_',segfile)\n        subjID=m.group(0)[:-1] \n\n    # get segmentation file\n    aseg = nib.load(segfile)\n    aseg_data = aseg.get_data().squeeze()\n    aseg_aff = aseg.get_affine()\n    segdir = os.path.dirname(segfile)\n    segvoxdim=np.diagonal(aseg_aff)[:3]\n\n    # get nifti file of MRS voxel if one is provided\n    if MRSfile is not None:\n        if center is not None or dim is not None:\n            msg = 'provide EITHER MRSfile OR center and dim, not both!'\n            raise ValueError(msg)\n\n        mrs = nib.load(MRSfile)\n        mrs_data = mrs.get_data().squeeze()\n        mrs_aff = mrs.get_affine()        \n        # This applies the concatenation of the transforms from mrs space to\n        # the T1 space. [0,0,0] is the center of the MRS voxel:\n        center = np.round(np.dot(np.dot(np.linalg.pinv(aseg_aff), mrs_aff),\n                                 [0,0,0,1]))[:3].astype(int)\n        \n        dim=np.diagonal(mrs_aff)[:3]\n    else: # no MRSfile\n        if center==None or dim==None:\n            msg = 'if no MRSfile is provided, provide center and '\n            msg += 'dimensions of voxel'\n            raise ValueError()    \n\n    # calculate beginning corner of MRS voxel\n    print('Creating mask with center: [%s, %s, %s]'%(center[0],\n                                                    center[1],\n                                                    str(center[2])))\n\n    print('and dimensions: [%s, %s, %s] mm'%(dim[0], dim[1], dim[2]))\n    \n    # calculate roi mask with numpy\n    # round up to nearest number of voxel units\n    voxdim=np.zeros(3)\n    voxdim[0]=np.ceil(np.abs(dim[0] / segvoxdim[0]))\n    voxdim[1]=np.ceil(np.abs(dim[1] / segvoxdim[1]))\n    voxdim[2]=np.ceil(np.abs(dim[2] / segvoxdim[2]))\n\n    print ('MRS voxel dimensions in T1 voxel units: [%s, %s, %s]'%(voxdim[0],\n                                                                  voxdim[1],\n                                                                  voxdim[2]))\n\n    # corners\n    lcorner = [center[0] - voxdim[0] / 2,\n               center[1] - voxdim[1] / 2,\n               center[2] - voxdim[2] / 2]\n\n    ucorner = [center[0] + voxdim[0] / 2,\n               center[1] + voxdim[1] / 2,\n               center[2] + voxdim[2] / 2]\n    # create mask\n    mdata = np.zeros(aseg_data.shape)\n    for i in range(int(lcorner[0]),int(ucorner[0])):\n        for j in range(int(lcorner[1]),int(ucorner[1])):\n            for k in range(int(lcorner[2]),int(ucorner[2])):\n                mdata[i,j,k]=1\n\n\n    # calculate grey/white/csf from freesurfer labels\n    gdata = np.zeros(aseg_data.shape)\n    wdata = np.zeros(aseg_data.shape)\n    csfdata = np.zeros(aseg_data.shape)\n\n    for data, areas in zip([gdata, wdata, csfdata], [gareas, wareas, csfareas]):\n        for area in areas:\n            data[np.where(aseg_data==area)] = 1\n\n    # multiply voxel ROI with seg data\n    gmasked= mdata * gdata\n    wmasked= mdata * wdata\n    csfmasked= mdata * csfdata\n    \n    # extract stats from a given segmentation\n    total = np.sum(mdata)\n    white = np.sum(wmasked)\n    grey = np.sum(gmasked)\n    csf = np.sum(csfmasked)\n    nongmwm = total - grey - white\n\n    # proportions\n    pWhite = float(white) / total\n    pGrey = float(grey) / total\n    pCSF = float(csf) / total \n    pNongmwm = float(nongmwm) / total\n\n    return (total, grey, white, csf,nongmwm, pGrey, pWhite,pCSF, pNongmwm)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecorates your decorator with this to allow it to always receive *args and **kwargs, making @deco equivalent to @deco()", "response": "def optional_argument_decorator(_decorator):\n    \"\"\"Decorate your decorator with this to allow it to always receive *args and **kwargs, making @deco equivalent to\n    @deco()\"\"\"\n\n    @functools.wraps(_decorator)\n    def inner_decorator_make(*args, **kwargs):\n        if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n            func = args[0]\n            args = tuple()\n            kwargs = dict()\n        else:\n            func = None\n\n        decorator = _decorator(*args, **kwargs)\n\n        if func:\n            return decorator(func)\n        else:\n            return decorator\n\n    return inner_decorator_make"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef operate_on_bulb(self, method, params=None):\n        # Get the message\n        self.command = YeelightCommand(self.next_cmd_id(), method, params)\n        # Send with socket\n        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        tcp_socket.connect((self.ip, int(self.port)))\n        tcp_socket.send(self.command.get_message().encode())\n        data = tcp_socket.recv(4096)\n        tcp_socket.close()\n        # Process the response\n        self.response = YeelightResponse(data.decode(), self.command)", "response": "Send command to bulb through it\n            and process response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __register_font(self, name):\n        \"Assign an ID to the font NAME. Return its ID.\"\n        if name not in self.__registered_fonts:\n            self.__registered_fonts[name] = self.__next_font_id\n            self.__next_font_id += 1\n        return self.__registered_fonts[name]", "response": "Assign an ID to the font NAME. Return its ID."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exception_translation(func):\n    @wraps(func)\n    def decorator(*arg, **kwargs):\n        try:\n            return func(*arg, **kwargs)\n        except InvalidOperationException, e:\n            return Response(status=status.HTTP_412_PRECONDITION_FAILED, data={'detail': e.message}, headers={'Content-Type': 'application/json'})\n    return decorator", "response": "Decorator that handles exceptions and build correct api response for it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getattr_in_cls_list(cls_list, attr, default):\n    for cls in cls_list:\n        if hasattr(cls, attr):\n            return getattr(cls, attr)\n    return default", "response": "Search for an attribute in class list. Returns default if no attribute exists."}
