{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget object from generic date_based. detail view", "response": "def get_object_from_date_based_view(request, *args, **kwargs):  # noqa\n    \"\"\"\n    Get object from generic date_based.detail view\n\n    Parameters\n    ----------\n    request : instance\n        An instance of HttpRequest\n\n    Returns\n    -------\n    instance\n        An instance of model object or None\n    \"\"\"\n    import time\n    import datetime\n    from django.http import Http404\n    from django.db.models.fields import DateTimeField\n    try:\n        from django.utils import timezone\n        datetime_now = timezone.now\n    except ImportError:\n        datetime_now = datetime.datetime.now\n    year, month, day = kwargs['year'], kwargs['month'], kwargs['day']\n    month_format = kwargs.get('month_format', '%b')\n    day_format = kwargs.get('day_format', '%d')\n    date_field = kwargs['date_field']\n    queryset = kwargs['queryset']\n    object_id = kwargs.get('object_id', None)\n    slug = kwargs.get('slug', None)\n    slug_field = kwargs.get('slug_field', 'slug')\n\n    try:\n        tt = time.strptime(\n                '%s-%s-%s' % (year, month, day),\n                '%s-%s-%s' % ('%Y', month_format, day_format)\n            )\n        date = datetime.date(*tt[:3])\n    except ValueError:\n        raise Http404\n\n    model = queryset.model\n\n    if isinstance(model._meta.get_field(date_field), DateTimeField):\n        lookup_kwargs = {\n                '%s__range' % date_field: (\n                    datetime.datetime.combine(date, datetime.time.min),\n                    datetime.datetime.combine(date, datetime.time.max),\n                )}\n    else:\n        lookup_kwargs = {date_field: date}\n\n    now = datetime_now()\n    if date >= now.date() and not kwargs.get('allow_future', False):\n        lookup_kwargs['%s__lte' % date_field] = now\n    if object_id:\n        lookup_kwargs['pk'] = object_id\n    elif slug and slug_field:\n        lookup_kwargs['%s__exact' % slug_field] = slug\n    else:\n        raise AttributeError(\n                \"Generic detail view must be called with either an \"\n                \"object_id or a slug/slug_field.\"\n            )\n    return get_object_or_404(queryset, **lookup_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self, model, handler=None):\n        from permission.handlers import PermissionHandler\n        if model._meta.abstract:\n            raise ImproperlyConfigured(\n                    'The model %s is abstract, so it cannot be registered '\n                    'with permission.' % model)\n        if model in self._registry:\n            raise KeyError(\"A permission handler class is already \"\n                            \"registered for '%s'\" % model)\n        if handler is None:\n            handler = settings.PERMISSION_DEFAULT_PERMISSION_HANDLER\n        if isstr(handler):\n            handler = import_string(handler)\n        if not inspect.isclass(handler):\n            raise AttributeError(\n                    \"`handler` attribute must be a class. \"\n                    \"An instance was specified.\")\n        if not issubclass(handler, PermissionHandler):\n            raise AttributeError(\n                    \"`handler` attribute must be a subclass of \"\n                    \"`permission.handlers.PermissionHandler`\")\n\n        # Instantiate the handler to save in the registry\n        instance = handler(model)\n        self._registry[model] = instance", "response": "Registers a permission handler for a django model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unregister(self, model):\n        if model not in self._registry:\n            raise KeyError(\"A permission handler class have not been \"\n                           \"registered for '%s' yet\" % model)\n        # remove from registry\n        del self._registry[model]", "response": "Unregister a permission handler from the registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget permissions related to the application specified in constructor Returns ------- self. _app_perms_cache", "response": "def _get_app_perms(self, *args):\n        \"\"\"\n        Get permissions related to the application specified in constructor\n\n        Returns\n        -------\n        set\n            A set instance of `app_label.codename` formatted permission strings\n        \"\"\"\n        if not hasattr(self, '_app_perms_cache'):\n            self._app_perms_cache = get_app_perms(self.app_label)\n        return self._app_perms_cache"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_model_perms(self, *args):\n        if not hasattr(self, '_model_perms_cache'):\n            if self.model is None:\n                self._model_perms_cache = set()\n            else:\n                self._model_perms_cache = get_model_perms(self.model)\n        return self._model_perms_cache", "response": "Get permissions related to the model specified in constructor. Returns ------- set A set instance of string formatted permission strings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of permissions which this handler can treat.", "response": "def get_supported_permissions(self):\n        \"\"\"\n        Get permissions which this handler can treat.\n        Specified with :attr:`includes` and :attr:`excludes` of this instance.\n\n        Returns\n        -------\n        set\n            A set instance of `app_label.codename` formatted permission strings\n        \"\"\"\n        if not hasattr(self, '_perms_cache'):\n            if (self.includes and\n                    isinstance(self.includes, collections.Callable)):\n                includes = self.includes(self)\n            else:\n                includes = self.includes or []\n            if (self.excludes and\n                    isinstance(self.excludes, collections.Callable)):\n                excludes = self.excludes(self)\n            else:\n                excludes = self.excludes or []\n            includes = set(includes)\n            excludes = set(excludes)\n            includes = includes.difference(excludes)\n            self._perms_cache = includes\n        return self._perms_cache"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_supported_app_labels(self):\n        get_app_label = lambda x: x.split(\".\", 1)[0]\n        if not hasattr(self, '_app_labels_cache'):\n            perms = self.get_supported_permissions()\n            self._app_labels_cache = set([get_app_label(x) for x in perms])\n        return self._app_labels_cache", "response": "Returns a set of app labels which this handler can treat."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if user has permission of specified app_label.", "response": "def has_module_perms(self, user_obj, app_label):\n        \"\"\"\n        Check if user have permission of specified app\n\n        Parameters\n        ----------\n        user_obj : django user model instance\n            A django user model instance which be checked\n        app_label : string\n            Django application name\n\n        Returns\n        -------\n        boolean\n            Whether the specified user have any permissions of specified app\n\n        \"\"\"\n        cache_name = \"_has_module_perms_%s_%s_cache\" % (app_label, user_obj.pk)\n        if hasattr(self, cache_name):\n            return getattr(self, cache_name)\n        if self.app_label != app_label:\n            setattr(self, cache_name, False)\n        else:\n            for permission in self.get_supported_permissions():\n                if user_obj.has_perm(permission):\n                    setattr(self, cache_name, True)\n                    return True\n        setattr(self, cache_name, False)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_perm(self, user_obj, perm, obj=None):\n        if perm not in self.get_supported_permissions():\n            return False\n        # use cache to reduce method call\n        CACHE_NAME = '_logical_perms_cache'\n        if not hasattr(user_obj, CACHE_NAME):\n            setattr(user_obj, CACHE_NAME, {})\n        cache = getattr(user_obj, CACHE_NAME)\n        cachekey = \"%s %s\" % (perm, hash(obj))\n        if cachekey not in cache:\n            cache[cachekey] = self._has_perm(user_obj, perm, obj)\n        return cache[cachekey]", "response": "Check if user has permission of object perm."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef permission_required(perm, queryset_or_model=None,\n                        login_url=None, raise_exception=False):\n    \"\"\"\n    Permission check decorator for classbased/functional generic view\n\n    This decorator works as class, method or function decorator without any\n    modification.\n    DO NOT use ``method_decorator`` or whatever while this decorator will use\n    ``self`` argument for method of classbased generic view.\n\n    Parameters\n    ----------\n    perm : string\n        A permission string\n    queryset_or_model : queryset or model\n        A queryset or model for finding object.\n        With classbased generic view, ``None`` for using view default queryset.\n        When the view does not define ``get_queryset``, ``queryset``,\n        ``get_object``, or ``object`` then ``obj=None`` is used to check\n        permission.\n        With functional generic view, ``None`` for using passed queryset.\n        When non queryset was passed then ``obj=None`` is used to check\n        permission.\n\n    Examples\n    --------\n    >>> # As class decorator\n    >>> @permission_required('auth.change_user')\n    >>> class UpdateAuthUserView(UpdateView):\n    ...     pass\n    >>> # As method decorator\n    >>> class UpdateAuthUserView(UpdateView):\n    ...     @permission_required('auth.change_user')\n    ...     def dispatch(self, request, *args, **kwargs):\n    ...         pass\n    >>> # As function decorator\n    >>> @permission_required('auth.change_user')\n    >>> def update_auth_user(request, *args, **kwargs):\n    ...     pass\n\n    .. Note::\n        Classbased generic view is recommended while you can regulate the queryset\n        with ``get_queryset()`` method.\n        Detecting object from passed kwargs may not work correctly.\n    \"\"\"\n    # convert model to queryset\n    if queryset_or_model and issubclass(queryset_or_model, Model):\n        queryset_or_model = queryset_or_model._default_manager.all()\n\n    def wrapper(class_or_method):\n        if inspect.isclass(class_or_method):\n            from permission.decorators.classbase import \\\n                    permission_required as decorator\n        else:\n            # method_permission_required can handle method or function\n            # correctly.\n            from permission.decorators.methodbase import \\\n                    permission_required as decorator\n        return decorator(perm, queryset_or_model,\n                         login_url, raise_exception)(class_or_method)\n    return wrapper", "response": "Permission check decorator for classbased generic view."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_perm_codename(perm, fail_silently=True):\n    try:\n        perm = perm.split('.', 1)[1]\n    except IndexError as e:\n        if not fail_silently:\n            raise e\n    return perm", "response": "Get permission codename from permission - string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a permission instance to a permission - string.", "response": "def permission_to_perm(permission):\n    \"\"\"\n    Convert a permission instance to a permission-string.\n\n    Examples\n    --------\n    >>> permission = Permission.objects.get(\n    ...     content_type__app_label='auth',\n    ...     codename='add_user',\n    ... )\n    >>> permission_to_perm(permission)\n    'auth.add_user'\n    \"\"\"\n    app_label = permission.content_type.app_label\n    codename = permission.codename\n    return '%s.%s' % (app_label, codename)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef perm_to_permission(perm):\n    from django.contrib.auth.models import Permission\n    try:\n        app_label, codename = perm.split('.', 1)\n    except (ValueError, IndexError):\n        raise AttributeError(\n            'The format of identifier string permission (perm) is wrong. '\n            \"It should be in 'app_label.codename'.\"\n        )\n    else:\n        permission = Permission.objects.get(\n            content_type__app_label=app_label,\n            codename=codename\n        )\n        return permission", "response": "Converts a permission - string to a permission instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_app_perms(model_or_app_label):\n    from django.contrib.auth.models import Permission\n    if isinstance(model_or_app_label, string_types):\n        app_label = model_or_app_label\n    else:\n        # assume model_or_app_label is model class\n        app_label = model_or_app_label._meta.app_label\n    qs = Permission.objects.filter(content_type__app_label=app_label)\n    perms = ('%s.%s' % (app_label, p.codename) for p in qs.iterator())\n    return set(perms)", "response": "Get permission - string list of the specified django application."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_model_perms(model):\n    from django.contrib.auth.models import Permission\n    app_label = model._meta.app_label\n    model_name = model._meta.object_name.lower()\n    qs = Permission.objects.filter(content_type__app_label=app_label,\n                                   content_type__model=model_name)\n    perms = ('%s.%s' % (app_label, p.codename) for p in qs.iterator())\n    return set(perms)", "response": "Returns a list of permission - string list of a given django model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a user has permission of a specified object.", "response": "def has_perm(self, user_obj, perm, obj=None):\n        \"\"\"\n        Check if user have permission (of object)\n\n        If the user_obj is not authenticated, it return ``False``.\n\n        If no object is specified, it return ``True`` when the corresponding\n        permission was specified to ``True`` (changed from v0.7.0).\n        This behavior is based on the django system.\n        https://code.djangoproject.com/wiki/RowLevelPermissions\n\n\n        If an object is specified, it will return ``True`` if the user is\n        found in ``field_name`` of the object (e.g. ``obj.collaborators``).\n        So once the object store the user as a collaborator in\n        ``field_name`` attribute (default: ``collaborators``), the collaborator\n        can change or delete the object (you can change this behavior to set\n        ``any_permission``, ``change_permission`` or ``delete_permission``\n        attributes of this instance).\n\n        Parameters\n        ----------\n        user_obj : django user model instance\n            A django user model instance which be checked\n        perm : string\n            `app_label.codename` formatted permission string\n        obj : None or django model instance\n            None or django model instance for object permission\n\n        Returns\n        -------\n        boolean\n            Whether the specified user have specified permission (of specified\n            object).\n        \"\"\"\n        if not is_authenticated(user_obj):\n            return False\n        # construct the permission full name\n        change_permission = self.get_full_permission_string('change')\n        delete_permission = self.get_full_permission_string('delete')\n        if obj is None:\n            # object permission without obj should return True\n            # Ref: https://code.djangoproject.com/wiki/RowLevelPermissions\n            if self.any_permission:\n                return True\n            if self.change_permission and perm == change_permission:\n                return True\n            if self.delete_permission and perm == delete_permission:\n                return True\n            return False\n        elif user_obj.is_active:\n            # get collaborator queryset\n            collaborators = field_lookup(obj, self.field_name)\n            if hasattr(collaborators, 'all'):\n                collaborators = collaborators.all()\n            if user_obj in collaborators:\n                if self.any_permission:\n                    # have any kind of permissions to the obj\n                    return True\n                if (self.change_permission and\n                        perm == change_permission):\n                    return True\n                if (self.delete_permission and\n                        perm == delete_permission):\n                    return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a permission logic to the specified django model.", "response": "def add_permission_logic(model, permission_logic):\n    \"\"\"\n    Add permission logic to the model\n\n    Parameters\n    ----------\n    model : django model class\n        A django model class which will be treated by the specified permission\n        logic\n    permission_logic : permission logic instance\n        A permission logic instance which will be used to determine permission\n        of the model\n\n    Examples\n    --------\n    >>> from django.db import models\n    >>> from permission.logics import PermissionLogic\n    >>> class Mock(models.Model):\n    ...     name = models.CharField('name', max_length=120)\n    >>> add_permission_logic(Mock, PermissionLogic())\n    \"\"\"\n    if not isinstance(permission_logic, PermissionLogic):\n        raise AttributeError(\n        '`permission_logic` must be an instance of PermissionLogic')\n    if not hasattr(model, '_permission_logics'):\n        model._permission_logics = set()\n    if not hasattr(model, '_permission_handler'):\n        from permission.utils.handlers import registry\n        # register default permission handler\n        registry.register(model, handler=None)\n    model._permission_logics.add(permission_logic)\n    # store target model to the permission_logic instance\n    permission_logic.model = model"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the specified permission logic from the specified model.", "response": "def remove_permission_logic(model, permission_logic, fail_silently=True):\n    \"\"\"\n    Remove permission logic to the model\n\n    Parameters\n    ----------\n    model : django model class\n        A django model class which will be treated by the specified permission\n        logic\n    permission_logic : permission logic class or instance\n        A permission logic class or instance which will be used to determine\n        permission of the model\n    fail_silently : boolean\n        If `True` then do not raise KeyError even the specified permission logic\n        have not registered.\n\n    Examples\n    --------\n    >>> from django.db import models\n    >>> from permission.logics import PermissionLogic\n    >>> class Mock(models.Model):\n    ...     name = models.CharField('name', max_length=120)\n    >>> logic = PermissionLogic()\n    >>> add_permission_logic(Mock, logic)\n    >>> remove_permission_logic(Mock, logic)\n    \"\"\"\n    if not hasattr(model, '_permission_logics'):\n        model._permission_logics = set()\n    if not isinstance(permission_logic, PermissionLogic):\n        # remove all permission logic of related\n        remove_set = set()\n        for _permission_logic in model._permission_logics:\n            if _permission_logic.__class__ == permission_logic:\n                remove_set.add(_permission_logic)\n        # difference\n        model._permission_logics = model._permission_logics.difference(remove_set)\n    else:\n        if fail_silently and permission_logic not in model._permission_logics:\n            pass\n        else:\n            model._permission_logics.remove(permission_logic)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef autodiscover(module_name=None):\n    from django.utils.module_loading import module_has_submodule\n    from permission.compat import import_module\n    from permission.conf import settings\n\n    module_name = module_name or settings.PERMISSION_AUTODISCOVER_MODULE_NAME\n    app_names = (app.name for app in apps.app_configs.values())\n\n    for app in app_names:\n        mod = import_module(app)\n        # Attempt to import the app's perms module\n        try:\n            # discover the permission module\n            discover(app, module_name=module_name)\n        except:\n            # Decide whether to bubble up this error. If the app just doesn't\n            # have an perms module, we can just ignore the error attempting\n            # to import it, otherwise we want it to bubble up.\n            if module_has_submodule(mod, module_name):\n                raise", "response": "Autodiscover INSTALLED_APPS perms. py modules and fail silently when not\n    present."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discover(app, module_name=None):\n    from permission.compat import import_module\n    from permission.compat import get_model\n    from permission.conf import settings\n    from permission.utils.logics import add_permission_logic\n\n    variable_name = settings.PERMISSION_AUTODISCOVER_VARIABLE_NAME\n    module_name = module_name or settings.PERMISSION_AUTODISCOVER_MODULE_NAME\n\n    # import the module\n    m = import_module('%s.%s' % (app, module_name))\n\n    # check if the module have PERMISSION_LOGICS variable\n    if hasattr(m, variable_name):\n        # apply permission logics automatically\n        permission_logic_set = getattr(m, variable_name)\n        for model, permission_logic in permission_logic_set:\n            if isinstance(model, six.string_types):\n                # convert model string to model instance\n                model = get_model(*model.split('.', 1))\n            add_permission_logic(model, permission_logic)", "response": "Discovers the modules and adds the permission logics to the specified module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if user has permission of himself and permission of object.", "response": "def has_perm(self, user_obj, perm, obj=None):\n        \"\"\"\n        Check if user have permission of himself\n\n        If the user_obj is not authenticated, it return ``False``.\n\n        If no object is specified, it return ``True`` when the corresponding\n        permission was specified to ``True`` (changed from v0.7.0).\n        This behavior is based on the django system.\n        https://code.djangoproject.com/wiki/RowLevelPermissions\n\n        If an object is specified, it will return ``True`` if the object is the\n        user.\n        So users can change or delete themselves (you can change this behavior\n        to set ``any_permission``, ``change_permissino`` or\n        ``delete_permission`` attributes of this instance).\n\n        Parameters\n        ----------\n        user_obj : django user model instance\n            A django user model instance which be checked\n        perm : string\n            `app_label.codename` formatted permission string\n        obj : None or django model instance\n            None or django model instance for object permission\n\n        Returns\n        -------\n        boolean\n            Whether the specified user have specified permission (of specified\n            object).\n        \"\"\"\n        if not is_authenticated(user_obj):\n            return False\n        # construct the permission full name\n        change_permission = self.get_full_permission_string('change')\n        delete_permission = self.get_full_permission_string('delete')\n        # check if the user is authenticated\n        if obj is None:\n            # object permission without obj should return True\n            # Ref: https://code.djangoproject.com/wiki/RowLevelPermissions\n            if self.any_permission:\n                return True\n            if self.change_permission and perm == change_permission:\n                return True\n            if self.delete_permission and perm == delete_permission:\n                return True\n            return False\n        elif user_obj.is_active:\n            # check if the user trying to interact with himself\n            if obj == user_obj:\n                if self.any_permission:\n                    # have any kind of permissions to himself\n                    return True\n                if (self.change_permission and\n                        perm == change_permission):\n                    return True\n                if (self.delete_permission and\n                        perm == delete_permission):\n                    return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning full permission string for the current object.", "response": "def get_full_permission_string(self, perm):\n        \"\"\"\n        Return full permission string (app_label.perm_model)\n        \"\"\"\n        if not getattr(self, 'model', None):\n            raise AttributeError(\"You need to use `add_permission_logic` to \"\n                                 \"register the instance to the model class \"\n                                 \"before calling this method.\")\n        app_label = self.model._meta.app_label\n        model_name = self.model._meta.object_name.lower()\n        return \"%s.%s_%s\" % (app_label, perm, model_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if user has permission of object.", "response": "def has_perm(self, user_obj, perm, obj=None):\n        \"\"\"\n        Check if user have permission (of object) based on registered handlers.\n\n        It will raise ``ObjectDoesNotExist`` exception when the specified\n        string permission does not exist and\n        ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``\n        module.\n\n        Parameters\n        ----------\n        user_obj : django user model instance\n            A django user model instance which be checked\n        perm : string\n            `app_label.codename` formatted permission string\n        obj : None or django model instance\n            None or django model instance for object permission\n\n        Returns\n        -------\n        boolean\n            Whether the specified user have specified permission (of specified\n            object).\n\n        Raises\n        ------\n        django.core.exceptions.ObjectDoesNotExist\n            If the specified string permission does not exist and\n            ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``\n            module.\n        \"\"\"\n        if settings.PERMISSION_CHECK_PERMISSION_PRESENCE:\n            # get permission instance from string permission (perm)\n            # it raise ObjectDoesNotExists when the permission is not exists\n            try:\n                perm_to_permission(perm)\n            except AttributeError:\n                # Django 1.2 internally use wrong permission string thus ignore\n                pass\n\n        # get permission handlers fot this perm\n        cache_name = '_%s_cache' % perm\n        if hasattr(self, cache_name):\n            handlers = getattr(self, cache_name)\n        else:\n            handlers = [h for h in registry.get_handlers()\n                        if perm in h.get_supported_permissions()]\n            setattr(self, cache_name, handlers)\n        for handler in handlers:\n            if handler.has_perm(user_obj, perm, obj=obj):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_module_perms(self, user_obj, app_label):\n        # get permission handlers fot this perm\n        cache_name = '_%s_cache' % app_label\n        if hasattr(self, cache_name):\n            handlers = getattr(self, cache_name)\n        else:\n            handlers = [h for h in registry.get_handlers()\n                        if app_label in h.get_supported_app_labels()]\n            setattr(self, cache_name, handlers)\n        for handler in handlers:\n            if handler.has_module_perms(user_obj, app_label):\n                return True\n        return False", "response": "Check if user has permission of specified app based on registered modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches the body from a message.", "response": "def get_body_from_message(message, maintype, subtype):\n    \"\"\"\n    Fetchs the body message matching main/sub content type.\n    \"\"\"\n    body = six.text_type('')\n    for part in message.walk():\n        if part.get('content-disposition', '').startswith('attachment;'):\n            continue\n        if part.get_content_maintype() == maintype and \\\n                part.get_content_subtype() == subtype:\n            charset = part.get_content_charset()\n            this_part = part.get_payload(decode=True)\n            if charset:\n                try:\n                    this_part = this_part.decode(charset, 'replace')\n                except LookupError:\n                    this_part = this_part.decode('ascii', 'replace')\n                    logger.warning(\n                        'Unknown encoding %s encountered while decoding '\n                        'text payload.  Interpreting as ASCII with '\n                        'replacement, but some data may not be '\n                        'represented as the sender intended.',\n                        charset\n                    )\n                except ValueError:\n                    this_part = this_part.decode('ascii', 'replace')\n                    logger.warning(\n                        'Error encountered while decoding text '\n                        'payload from an incorrectly-constructed '\n                        'e-mail; payload was converted to ASCII with '\n                        'replacement, but some data may not be '\n                        'represented as the sender intended.'\n                    )\n            else:\n                this_part = this_part.decode('ascii', 'replace')\n\n            body += this_part\n\n    return body"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the diameter of a circle.", "response": "def diam_circle(AreaCircle):\n    \"\"\"Return the diameter of a circle.\"\"\"\n    ut.check_range([AreaCircle, \">0\", \"AreaCircle\"])\n    return np.sqrt(4 * AreaCircle / np.pi)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the density of water at a given temperature.", "response": "def density_water(temp):\n    \"\"\"Return the density of water at a given temperature.\n\n    If given units, the function will automatically convert to Kelvin.\n    If not given units, the function will assume Kelvin.\n    \"\"\"\n    ut.check_range([temp, \">0\", \"Temperature in Kelvin\"])\n    rhointerpolated = interpolate.CubicSpline(WATER_DENSITY_TABLE[0],\n                                                    WATER_DENSITY_TABLE[1])\n    return np.asscalar(rhointerpolated(temp))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef viscosity_kinematic(temp):\n    ut.check_range([temp, \">0\", \"Temperature in Kelvin\"])\n    return (viscosity_dynamic(temp).magnitude\n            / density_water(temp).magnitude)", "response": "Return the kinematic viscosity of water at a given temperature."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef re_pipe(FlowRate, Diam, Nu):\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Diam, \">0\", \"Diameter\"],\n                   [Nu, \">0\", \"Nu\"])\n    return (4 * FlowRate) / (np.pi * Diam * Nu)", "response": "Return the Reynolds Number for a pipe."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the hydraulic radius.", "response": "def radius_hydraulic(Width, DistCenter, openchannel):\n    \"\"\"Return the hydraulic radius.\n\n    Width and DistCenter are length values and openchannel is a boolean.\n    \"\"\"\n    ut.check_range([Width, \">0\", \"Width\"], [DistCenter, \">0\", \"DistCenter\"],\n                   [openchannel, \"boolean\", \"openchannel\"])\n    if openchannel:\n        return (Width*DistCenter) / (Width + 2*DistCenter)\n        # if openchannel is True, the channel is open. Otherwise, the channel\n        # is assumed to have a top.\n    else:\n        return (Width*DistCenter) / (2 * (Width+DistCenter))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the Reynolds Number for a rectangular channel.", "response": "def re_rect(FlowRate, Width, DistCenter, Nu, openchannel):\n    \"\"\"Return the Reynolds Number for a rectangular channel.\"\"\"\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Nu, \">0\", \"Nu\"])\n    return (4 * FlowRate\n            * radius_hydraulic(Width, DistCenter, openchannel).magnitude\n            / (Width * DistCenter * Nu))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the Reynolds Number for a general cross section.", "response": "def re_general(Vel, Area, PerimWetted, Nu):\n    \"\"\"Return the Reynolds Number for a general cross section.\"\"\"\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([Vel, \">=0\", \"Velocity\"], [Nu, \">0\", \"Nu\"])\n    return 4 * radius_hydraulic_general(Area, PerimWetted).magnitude * Vel / Nu"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fric(FlowRate, Diam, Nu, PipeRough):\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([PipeRough, \"0-1\", \"Pipe roughness\"])\n    if re_pipe(FlowRate, Diam, Nu) >= RE_TRANSITION_PIPE:\n        #Swamee-Jain friction factor for turbulent flow; best for\n        #Re>3000 and \u03b5/Diam < 0.02\n        f = (0.25 / (np.log10(PipeRough / (3.7 * Diam)\n                              + 5.74 / re_pipe(FlowRate, Diam, Nu) ** 0.9\n                              )\n                     ) ** 2\n             )\n    else:\n        f = 64 / re_pipe(FlowRate, Diam, Nu)\n    return f", "response": "Return the friction factor for a pipe flow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the friction factor for a rectangular channel.", "response": "def fric_rect(FlowRate, Width, DistCenter, Nu, PipeRough, openchannel):\n    \"\"\"Return the friction factor for a rectangular channel.\"\"\"\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([PipeRough, \"0-1\", \"Pipe roughness\"])\n    if re_rect(FlowRate,Width,DistCenter,Nu,openchannel) >= RE_TRANSITION_PIPE:\n        #Swamee-Jain friction factor adapted for rectangular channel.\n        #Diam = 4*R_h in this case.\n        return (0.25\n                / (np.log10((PipeRough\n                             / (3.7 * 4\n                                * radius_hydraulic(Width, DistCenter,\n                                                   openchannel).magnitude\n                                )\n                             )\n                            + (5.74 / (re_rect(FlowRate, Width, DistCenter,\n                                               Nu, openchannel) ** 0.9)\n                               )\n                            )\n                    ) ** 2\n                )\n    else:\n        return 64 / re_rect(FlowRate, Width, DistCenter, Nu, openchannel)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the friction factor for a general channel.", "response": "def fric_general(Area, PerimWetted, Vel, Nu, PipeRough):\n    \"\"\"Return the friction factor for a general channel.\"\"\"\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([PipeRough, \"0-1\", \"Pipe roughness\"])\n    if re_general(Vel, Area, PerimWetted, Nu) >= RE_TRANSITION_PIPE:\n        #Swamee-Jain friction factor adapted for any cross-section.\n        #Diam = 4*R*h\n        f= (0.25 /\n            (np.log10((PipeRough\n                       / (3.7 * 4\n                          * radius_hydraulic_general(Area, PerimWetted).magnitude\n                          )\n                       )\n                      + (5.74\n                         / re_general(Vel, Area, PerimWetted, Nu) ** 0.9\n                         )\n                      )\n             ) ** 2\n            )\n    else:\n        f = 64 / re_general(Vel, Area, PerimWetted, Nu)\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef headloss_fric(FlowRate, Diam, Length, Nu, PipeRough):\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([Length, \">0\", \"Length\"])\n    return (fric(FlowRate, Diam, Nu, PipeRough)\n            * 8 / (gravity.magnitude * np.pi**2)\n            * (Length * FlowRate**2) / Diam**5\n            )", "response": "Return the major head loss in a single object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the minor head loss due to expansions in a flow.", "response": "def headloss_exp(FlowRate, Diam, KMinor):\n    \"\"\"Return the minor head loss (due to expansions) in a pipe.\n\n    This equation applies to both laminar and turbulent flows.\n    \"\"\"\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Diam, \">0\", \"Diameter\"],\n                   [KMinor, \">=0\", \"K minor\"])\n    return KMinor * 8 / (gravity.magnitude * np.pi**2) * FlowRate**2 / Diam**4"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef headloss(FlowRate, Diam, Length, Nu, PipeRough, KMinor):\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    return (headloss_fric(FlowRate, Diam, Length, Nu, PipeRough).magnitude\n            + headloss_exp(FlowRate, Diam, KMinor).magnitude)", "response": "Return the total head loss from major and minor losses in a single flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the major head loss due to wall shear in a rectangular channel.", "response": "def headloss_fric_rect(FlowRate, Width, DistCenter, Length, Nu, PipeRough, openchannel):\n    \"\"\"Return the major head loss due to wall shear in a rectangular channel.\n\n    This equation applies to both laminar and turbulent flows.\n    \"\"\"\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([Length, \">0\", \"Length\"])\n    return (fric_rect(FlowRate, Width, DistCenter, Nu,\n                      PipeRough, openchannel)\n            * Length\n            / (4 * radius_hydraulic(Width, DistCenter, openchannel).magnitude)\n            * FlowRate**2\n            / (2 * gravity.magnitude * (Width*DistCenter)**2)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef headloss_exp_rect(FlowRate, Width, DistCenter, KMinor):\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Width, \">0\", \"Width\"],\n                   [DistCenter, \">0\", \"DistCenter\"], [KMinor, \">=0\", \"K minor\"])\n    return (KMinor * FlowRate**2\n            / (2 * gravity.magnitude * (Width*DistCenter)**2)\n            )", "response": "Return the minor head loss due to expansion in a rectangular channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef headloss_rect(FlowRate, Width, DistCenter, Length,\n                  KMinor, Nu, PipeRough, openchannel):\n    \"\"\"Return the total head loss in a rectangular channel.\n\n    Total head loss is a combination of the major and minor losses.\n    This equation applies to both laminar and turbulent flows.\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    return (headloss_exp_rect(FlowRate, Width, DistCenter, KMinor).magnitude\n              + headloss_fric_rect(FlowRate, Width, DistCenter, Length,\n                                   Nu, PipeRough, openchannel).magnitude)", "response": "Return the total head loss in a rectangular channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef headloss_fric_general(Area, PerimWetted, Vel, Length, Nu, PipeRough):\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([Length, \">0\", \"Length\"])\n    return (fric_general(Area, PerimWetted, Vel, Nu, PipeRough) * Length\n            / (4 * radius_hydraulic_general(Area, PerimWetted).magnitude)\n            * Vel**2 / (2*gravity.magnitude)\n            )", "response": "Return the major head loss due to wall shear in the general case."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the minor head loss due to expansion in the general case.", "response": "def headloss_exp_general(Vel, KMinor):\n    \"\"\"Return the minor head loss due to expansion in the general case.\n\n    This equation applies to both laminar and turbulent flows.\n    \"\"\"\n    #Checking input validity\n    ut.check_range([Vel, \">0\", \"Velocity\"], [KMinor, '>=0', 'K minor'])\n    return KMinor * Vel**2 / (2*gravity.magnitude)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the total head lossin the general case.", "response": "def headloss_gen(Area, Vel, PerimWetted, Length, KMinor, Nu, PipeRough):\n    \"\"\"Return the total head lossin the general case.\n\n    Total head loss is a combination of major and minor losses.\n    This equation applies to both laminar and turbulent flows.\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    return (headloss_exp_general(Vel, KMinor).magnitude\n            + headloss_fric_general(Area, PerimWetted, Vel,\n                                     Length, Nu, PipeRough).magnitude)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef headloss_manifold(FlowRate, Diam, Length, KMinor, Nu, PipeRough, NumOutlets):\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([NumOutlets, \">0, int\", 'Number of outlets'])\n    return (headloss(FlowRate, Diam, Length, Nu, PipeRough, KMinor).magnitude\n            * ((1/3 )\n               + (1 / (2*NumOutlets))\n               + (1 / (6*NumOutlets**2))\n               )\n            )", "response": "Return the total head loss through the manifold."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flow_orifice(Diam, Height, RatioVCOrifice):\n    #Checking input validity\n    ut.check_range([Diam, \">0\", \"Diameter\"],\n                   [RatioVCOrifice, \"0-1\", \"VC orifice ratio\"])\n    if Height > 0:\n        return (RatioVCOrifice * area_circle(Diam).magnitude\n                * np.sqrt(2 * gravity.magnitude * Height))\n    else:\n        return 0", "response": "Return the flow rate of the orifice."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the vertical flow rate of the orifice.", "response": "def flow_orifice_vert(Diam, Height, RatioVCOrifice):\n    \"\"\"Return the vertical flow rate of the orifice.\"\"\"\n    #Checking input validity\n    ut.check_range([RatioVCOrifice, \"0-1\", \"VC orifice ratio\"])\n    if Height > -Diam / 2:\n        flow_vert = integrate.quad(lambda z: (Diam * np.sin(np.arccos(z/(Diam/2)))\n                                                   * np.sqrt(Height - z)\n                                                   ),\n                                                   - Diam / 2,\n                                                   min(Diam/2, Height))\n        return flow_vert[0] * RatioVCOrifice * np.sqrt(2 * gravity.magnitude)\n    else:\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the head of the orifice.", "response": "def head_orifice(Diam, RatioVCOrifice, FlowRate):\n    \"\"\"Return the head of the orifice.\"\"\"\n    #Checking input validity\n    ut.check_range([Diam, \">0\", \"Diameter\"], [FlowRate, \">0\", \"Flow rate\"],\n                   [RatioVCOrifice, \"0-1\", \"VC orifice ratio\"])\n    return ((FlowRate\n             / (RatioVCOrifice * area_circle(Diam).magnitude)\n             )**2\n            / (2*gravity.magnitude)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef area_orifice(Height, RatioVCOrifice, FlowRate):\n    #Checking input validity\n    ut.check_range([Height, \">0\", \"Height\"], [FlowRate, \">0\", \"Flow rate\"],\n                   [RatioVCOrifice, \"0-1, >0\", \"VC orifice ratio\"])\n    return FlowRate / (RatioVCOrifice * np.sqrt(2 * gravity.magnitude * Height))", "response": "Return the area of the orifice."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef num_orifices(FlowPlant, RatioVCOrifice, HeadLossOrifice, DiamOrifice):\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    return np.ceil(area_orifice(HeadLossOrifice, RatioVCOrifice,\n                                 FlowPlant).magnitude\n                    / area_circle(DiamOrifice).magnitude)", "response": "Return the number of orifices in a single orifile."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the flow rate for the laminar and turbulent transition.", "response": "def flow_transition(Diam, Nu):\n    \"\"\"Return the flow rate for the laminar/turbulent transition.\n\n    This equation is used in some of the other equations for flow.\n    \"\"\"\n    #Checking input validity\n    ut.check_range([Diam, \">0\", \"Diameter\"], [Nu, \">0\", \"Nu\"])\n    return np.pi * Diam * RE_TRANSITION_PIPE * Nu / 4"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flow_hagen(Diam, HeadLossFric, Length, Nu):\n    #Checking input validity\n    ut.check_range([Diam, \">0\", \"Diameter\"], [Length, \">0\", \"Length\"],\n                   [HeadLossFric, \">=0\", \"Headloss due to friction\"],\n                   [Nu, \">0\", \"Nu\"])\n    return (np.pi*Diam**4) / (128*Nu) * gravity.magnitude * HeadLossFric / Length", "response": "Return the flow rate for laminar flow with only major losses."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the flow rate for turbulent flow with only major losses.", "response": "def flow_swamee(Diam, HeadLossFric, Length, Nu, PipeRough):\n    \"\"\"Return the flow rate for turbulent flow with only major losses.\"\"\"\n    #Checking input validity\n    ut.check_range([Diam, \">0\", \"Diameter\"], [Length, \">0\", \"Length\"],\n                   [HeadLossFric, \">0\", \"Headloss due to friction\"],\n                   [Nu, \">0\", \"Nu\"], [PipeRough, \"0-1\", \"Pipe roughness\"])\n    logterm = np.log10(PipeRough / (3.7 * Diam)\n                       + 2.51 * Nu * np.sqrt(Length / (2 * gravity.magnitude\n                                                         * HeadLossFric\n                                                         * Diam**3)\n                                              )\n                       )\n    return ((-np.pi / np.sqrt(2)) * Diam**(5/2) * logterm\n            * np.sqrt(gravity.magnitude * HeadLossFric / Length)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flow_pipemajor(Diam, HeadLossFric, Length, Nu, PipeRough):\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    FlowHagen = flow_hagen(Diam, HeadLossFric, Length, Nu).magnitude\n    if FlowHagen < flow_transition(Diam, Nu).magnitude:\n        return FlowHagen\n    else:\n        return flow_swamee(Diam, HeadLossFric, Length, Nu, PipeRough).magnitude", "response": "Return the flow rate with only major losses."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flow_pipeminor(Diam, HeadLossExpans, KMinor):\n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([HeadLossExpans, \">=0\", \"Headloss due to expansion\"],\n                   [KMinor, \">0\", \"K minor\"])\n    return (area_circle(Diam).magnitude * np.sqrt(2 * gravity.magnitude\n                                                  * HeadLossExpans\n                                                  / KMinor)\n            )", "response": "Return the flow rate with only minor losses."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the flow in a straight pipe.", "response": "def flow_pipe(Diam, HeadLoss, Length, Nu, PipeRough, KMinor):\n    \"\"\"Return the the flow in a straight pipe.\n\n    This function works for both major and minor losses and\n    works whether the flow is laminar or turbulent.\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    if KMinor == 0:\n        FlowRate = flow_pipemajor(Diam, HeadLoss, Length, Nu,\n                                  PipeRough).magnitude\n    else:\n        FlowRatePrev = 0\n        err = 1.0\n        FlowRate = min(flow_pipemajor(Diam, HeadLoss, Length,\n                                      Nu, PipeRough).magnitude,\n                       flow_pipeminor(Diam, HeadLoss, KMinor).magnitude\n                       )\n        while err > 0.01:\n            FlowRatePrev = FlowRate\n            HLFricNew = (HeadLoss * headloss_fric(FlowRate, Diam, Length,\n                                                  Nu, PipeRough).magnitude\n                         / (headloss_fric(FlowRate, Diam, Length,\n                                          Nu, PipeRough).magnitude\n                            + headloss_exp(FlowRate, Diam, KMinor).magnitude\n                            )\n                         )\n            FlowRate = flow_pipemajor(Diam, HLFricNew, Length,\n                                      Nu, PipeRough).magnitude\n            if FlowRate == 0:\n                err = 0.0\n            else:\n                err = (abs(FlowRate - FlowRatePrev)\n                       / ((FlowRate + FlowRatePrev) / 2)\n                       )\n    return FlowRate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diam_swamee(FlowRate, HeadLossFric, Length, Nu, PipeRough):\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Length, \">0\", \"Length\"],\n                   [HeadLossFric, \">0\", \"Headloss due to friction\"],\n                   [Nu, \">0\", \"Nu\"], [PipeRough, \"0-1\", \"Pipe roughness\"])\n    a = ((PipeRough ** 1.25)\n         * ((Length * FlowRate**2)\n            / (gravity.magnitude * HeadLossFric)\n            )**4.75\n         )\n    b = (Nu * FlowRate**9.4\n         * (Length / (gravity.magnitude *  HeadLossFric)) ** 5.2\n         )\n    return 0.66 * (a+b)**0.04", "response": "Return the inner diameter of a Swamee Jain flow."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the pipe IDiam that would result in given major losses.", "response": "def diam_pipemajor(FlowRate, HeadLossFric, Length, Nu, PipeRough):\n    \"\"\"Return the pipe IDiam that would result in given major losses.\n    This function applies to both laminar and turbulent flow.\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    DiamLaminar = diam_hagen(FlowRate, HeadLossFric, Length, Nu).magnitude\n    if re_pipe(FlowRate, DiamLaminar, Nu) <= RE_TRANSITION_PIPE:\n        return DiamLaminar\n    else:\n        return diam_swamee(FlowRate, HeadLossFric, Length,\n                           Nu, PipeRough).magnitude"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef diam_pipeminor(FlowRate, HeadLossExpans, KMinor):\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [KMinor, \">=0\", \"K minor\"],\n                   [HeadLossExpans, \">0\", \"Headloss due to expansion\"])\n    return (np.sqrt(4 * FlowRate / np.pi)\n            * (KMinor / (2 * gravity.magnitude * HeadLossExpans)) ** (1/4)\n            )", "response": "Return the pipe ID that would result in the given minor losses."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the pipe ID that would result in the given total head loss. This function applies to both laminar and turbulent flow and incorporates both minor and major losses.", "response": "def diam_pipe(FlowRate, HeadLoss, Length, Nu, PipeRough, KMinor):\n    \"\"\"Return the pipe ID that would result in the given total head loss.\n\n    This function applies to both laminar and turbulent flow and\n    incorporates both minor and major losses.\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    if KMinor == 0:\n        Diam = diam_pipemajor(FlowRate, HeadLoss, Length, Nu,\n                              PipeRough).magnitude\n    else:\n        Diam = max(diam_pipemajor(FlowRate, HeadLoss,\n                                  Length, Nu, PipeRough).magnitude,\n                   diam_pipeminor(FlowRate, HeadLoss, KMinor).magnitude)\n        err = 1.00\n        while err > 0.001:\n            DiamPrev = Diam\n            HLFricNew = (HeadLoss * headloss_fric(FlowRate, Diam, Length,\n                                                  Nu, PipeRough\n                                                  ).magnitude\n                         / (headloss_fric(FlowRate, Diam, Length,\n                                          Nu, PipeRough\n                                          ).magnitude\n                                          + headloss_exp(FlowRate,\n                                                         Diam, KMinor\n                                                         ).magnitude\n                            )\n                         )\n            Diam = diam_pipemajor(FlowRate, HLFricNew, Length, Nu, PipeRough\n                                  ).magnitude\n            err = abs(Diam - DiamPrev) / ((Diam + DiamPrev) / 2)\n    return Diam"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the width of a rectangular weir.", "response": "def width_rect_weir(FlowRate, Height):\n    \"\"\"Return the width of a rectangular weir.\"\"\"\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Height, \">0\", \"Height\"])\n    return ((3 / 2) * FlowRate\n            / (con.VC_ORIFICE_RATIO * np.sqrt(2 * gravity.magnitude) * Height ** (3 / 2))\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the headloss of a weir.", "response": "def headloss_weir(FlowRate, Width):\n    \"\"\"Return the headloss of a weir.\"\"\"\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Width, \">0\", \"Width\"])\n    return (((3/2) * FlowRate\n             / (con.VC_ORIFICE_RATIO * np.sqrt(2 * gravity.magnitude) * Width)\n             ) ** (2/3))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flow_rect_weir(Height, Width):\n    #Checking input validity\n    ut.check_range([Height, \">0\", \"Height\"], [Width, \">0\", \"Width\"])\n    return ((2/3) * con.VC_ORIFICE_RATIO\n            * (np.sqrt(2*gravity.magnitude) * Height**(3/2))\n            * Width)", "response": "Return the flow of a rectangular weir."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef height_water_critical(FlowRate, Width):\n    #Checking input validity\n    ut.check_range([FlowRate, \">0\", \"Flow rate\"], [Width, \">0\", \"Width\"])\n    return (FlowRate / (Width * np.sqrt(gravity.magnitude))) ** (2/3)", "response": "Return the critical local water depth."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the horizontal velocity.", "response": "def vel_horizontal(HeightWaterCritical):\n    \"\"\"Return the horizontal velocity.\"\"\"\n    #Checking input validity\n    ut.check_range([HeightWaterCritical, \">0\", \"Critical height of water\"])\n    return np.sqrt(gravity.magnitude * HeightWaterCritical)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef headloss_kozeny(Length, Diam, Vel, Porosity, Nu):\n    #Checking input validity\n    ut.check_range([Length, \">0\", \"Length\"], [Diam, \">0\", \"Diam\"],\n                   [Vel, \">0\", \"Velocity\"], [Nu, \">0\", \"Nu\"],\n                   [Porosity, \"0-1\", \"Porosity\"])\n    return (K_KOZENY * Length * Nu\n            / gravity.magnitude * (1-Porosity)**2\n            / Porosity**3 * 36 * Vel\n            / Diam ** 2)", "response": "Return the Carmen Kozeny Sand Bed head loss."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vol_per_rev_3_stop(color=\"\", inner_diameter=0):\n    if color != \"\":\n        inner_diameter = ID_colored_tube(color)\n    term1 = (R_pump * 2 * np.pi - k_nonlinear * inner_diameter) / u.rev\n    term2 = np.pi * (inner_diameter ** 2) / 4\n    return (term1 * term2).to(u.mL/u.rev)", "response": "Return the volume per revolution of an Ismatec 6 roller pump on a 3 - stop tubing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ID_colored_tube(color):\n    tubing_data_path = os.path.join(os.path.dirname(__file__), \"data\",\n        \"3_stop_tubing.txt\")\n    df = pd.read_csv(tubing_data_path, delimiter='\\t')\n    idx = df[\"Color\"] == color\n    return df[idx]['Diameter (mm)'].values[0] * u.mm", "response": "Look up the inner diameter of Ismatec 3 - stop tubing given its color code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlooking up the volume per revolution output by a Masterflex L / S pump through the L / S tubing of the given ID number.", "response": "def vol_per_rev_LS(id_number):\n    \"\"\"Look up the volume per revolution output by a Masterflex L/S pump\n    through L/S tubing of the given ID number.\n\n    :param id_number: Identification number of the L/S tubing. Valid numbers are 13-18, 24, 35, and 36.\n    :type id_number: int\n\n    :return: Volume per revolution output by a Masterflex L/S pump through the L/S tubing\n    :rtype: float\n\n    :Examples:\n\n    >>> from aguaclara.research.peristaltic_pump import vol_per_rev_LS\n    >>> from aguaclara.core.units import unit_registry as u\n    >>> vol_per_rev_LS(13)\n    <Quantity(0.06, 'milliliter / turn')>\n    >>> vol_per_rev_LS(18)\n    <Quantity(3.8, 'milliliter / turn')>\n    \"\"\"\n    tubing_data_path = os.path.join(os.path.dirname(__file__), \"data\",\n        \"LS_tubing.txt\")\n    df = pd.read_csv(tubing_data_path, delimiter='\\t')\n    idx = df[\"Number\"] == id_number\n    return df[idx]['Flow (mL/rev)'].values[0] * u.mL/u.turn"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flow_rate(vol_per_rev, rpm):\n    return (vol_per_rev * rpm).to(u.mL/u.s)", "response": "Return the flow rate of a pump given the volume of fluid pumped per\n    revolution and the desired pump speed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef k_value_expansion(ent_pipe_id, exit_pipe_id, q,\n                      fitting_angle=180, rounded=False,\n                      nu=con.WATER_NU, pipe_rough=mats.PVC_PIPE_ROUGH):\n    \"\"\"Calculates the minor loss coefficient (k-value) of a square,\n    tapered, or rounded expansion in a pipe. Defaults to square.\n\n    To use tapered, set angle to something that isn't 180.\n\n    To use rounded, set rounded to True.\n\n    Parameters:\n        ent_pipe_id: Entrance pipe's inner diameter from which fluid flows.\n        exit_pipe_id: Exit pipe's inner diameter to which fluid flows.\n        q: Fluid's flow rate.\n\n        fitting_angle: Fitting angle. Default: square (180 degrees).\n        rounded: Rounded fitting. Default: square (False).\n\n        nu: Fluid's dynamic viscosity of the fluid. Default: room\n            temperature water (1 * 10**-6 * m**2/s)\n        pipe_rough: Pipe roughness. Default: PVC pipe roughness\n\n    Returns:\n        k-value of expansion.\n    \"\"\"\n\n    if ent_pipe_id > exit_pipe_id:\n        print('k_value_expansion: Entrance pipe\\'s inner diameter is larger '\n              'than exit pipe\\'s inner diameter, using reduction instead.')\n        return k_value_reduction(ent_pipe_id, exit_pipe_id, q,\n                                 fitting_angle, rounded,\n                                 nu, pipe_rough)\n\n    f = pc.fric(q, ent_pipe_id, nu, pipe_rough)  # Darcy friction factor.\n    re = pc.re_pipe(q, ent_pipe_id, nu)          # Entrance pipe's Reynolds number.\n\n    fitting_type = _get_fitting_type(fitting_angle, rounded)\n\n    if fitting_type == 'square':\n        return _k_value_square_expansion(ent_pipe_id, exit_pipe_id, re, f)\n    elif fitting_type == 'tapered':\n        return _k_value_tapered_expansion(ent_pipe_id, exit_pipe_id, re, f)\n    elif fitting_type == 'rounded':\n        return _k_value_rounded_expansion(ent_pipe_id, exit_pipe_id, re)\n    elif fitting_type == 'ambiguous':\n        raise ValueError('The fitting is ambiguously both tapered and rounded. '\n                         'Please set only either fitting_angle or rounded.')", "response": "Calculates the minor loss coefficient of an expansion in a pipe."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the minor loss coefficient of a square or rounded reduction in a pipe.", "response": "def k_value_reduction(ent_pipe_id, exit_pipe_id, q,\n                      fitting_angle=180, rounded=False,\n                      nu=con.WATER_NU, pipe_rough=mats.PVC_PIPE_ROUGH):\n    \"\"\"Calculates the minor loss coefficient (k-value) of a square,\n    tapered, or rounded reduction in a pipe. Defaults to square.\n\n    To use tapered, set angle to something that isn't 180.\n\n    To use rounded, set rounded to True.\n\n    Parameters:\n        ent_pipe_id: Entrance pipe's inner diameter from which fluid flows.\n        exit_pipe_id: Exit pipe's inner diameter to which fluid flows.\n        q: Fluid's q rate.\n\n        fitting_angle: Fitting angle. Default: square (180 degrees).\n        rounded: Rounded fitting. Default: square (False).\n\n        nu: Fluid's dynamic viscosity of the fluid. Default: room\n            temperature water (1 * 10**-6 * m**2/s)\n        pipe_rough: Pipe roughness. Default: PVC pipe roughness\n\n    Returns:\n        k-value of reduction.\n    \"\"\"\n\n    if ent_pipe_id < exit_pipe_id:\n        print('k_value_reduction: Entrance pipe\\'s inner diameter is less than '\n              'exit pipe\\'s inner diameter, using expansion instead.')\n        return k_value_expansion(ent_pipe_id, exit_pipe_id, q,\n                                 fitting_angle, rounded,\n                                 nu, pipe_rough)\n\n    f = pc.fric(q, ent_pipe_id, nu, pipe_rough)     # Darcy friction factor.\n    re = pc.re_pipe(q, ent_pipe_id, nu)             # Entrance pipe's Reynolds number.\n\n    fitting_type = _get_fitting_type(fitting_angle, rounded)\n\n    if fitting_type == 'square':\n        return _k_value_square_reduction(ent_pipe_id, exit_pipe_id, re, f)\n    elif fitting_type == 'tapered':\n        return _k_value_tapered_reduction(ent_pipe_id, exit_pipe_id, fitting_angle, re, f)\n    elif fitting_type == 'rounded':\n        return _k_value_rounded_reduction(ent_pipe_id, exit_pipe_id, re)\n    elif fitting_type == 'ambiguous':\n        raise ValueError('The fitting is ambiguously both tapered and rounded.'\n                         'Please set only either fitting_angle or rounded.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef k_value_orifice(pipe_id, orifice_id, orifice_l, q,\n                    nu=con.WATER_NU):\n    \"\"\"Calculates the minor loss coefficient of an orifice plate in a\n    pipe.\n\n    Parameters:\n        pipe_id: Entrance pipe's inner diameter from which fluid flows.\n        orifice_id: Orifice's inner diameter.\n        orifice_l: Orifice's length from start to end.\n        q: Fluid's q rate.\n\n        nu: Fluid's dynamic viscosity of the fluid. Default: room\n            temperature water (1 * 10**-6 * m**2/s)\n\n    Returns:\n        k-value at the orifice.\n    \"\"\"\n\n    if orifice_id > pipe_id:\n        raise ValueError('The orifice\\'s inner diameter cannot be larger than'\n                         'that of the entrance pipe.')\n\n    re = pc.re_pipe(q, pipe_id, nu)  # Entrance pipe's Reynolds number.\n\n    orifice_type = _get_orifice_type(orifice_l, orifice_id)\n\n    if orifice_type == 'thin':\n        return _k_value_thin_sharp_orifice(pipe_id, orifice_id, re)\n    elif orifice_type == 'thick':\n        return _k_value_thick_orifice(pipe_id, orifice_id, orifice_l, re)\n    elif orifice_type == 'oversize':\n        return k_value_reduction(pipe_id, orifice_id, q) \\\n               + k_value_expansion(orifice_id, pipe_id, q)", "response": "Calculates the minor loss coefficient of an orifice plate in a pipe."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _k_value_square_reduction(ent_pipe_id, exit_pipe_id, re, f):\n\n    if re < 2500:\n        return (1.2 + (160 / re)) * ((ent_pipe_id / exit_pipe_id) ** 4)\n    else:\n        return (0.6 + 0.48 * f) * (ent_pipe_id / exit_pipe_id) ** 2\\\n            * ((ent_pipe_id / exit_pipe_id) ** 2 - 1)", "response": "Returns the minor loss coefficient for a square reducer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the minor loss coefficient for a tapered reducer.", "response": "def _k_value_tapered_reduction(ent_pipe_id, exit_pipe_id, fitting_angle, re, f):\n    \"\"\"Returns the minor loss coefficient for a tapered reducer.\n\n    Parameters:\n        ent_pipe_id: Entrance pipe's inner diameter.\n        exit_pipe_id: Exit pipe's inner diameter.\n        fitting_angle: Fitting angle between entrance and exit pipes.\n        re: Reynold's number.\n        f: Darcy friction factor.\n    \"\"\"\n\n    k_value_square_reduction = _k_value_square_reduction(ent_pipe_id, exit_pipe_id,\n                                                         re, f)\n\n    if 45 < fitting_angle <= 180:\n        return k_value_square_reduction * np.sqrt(np.sin(fitting_angle / 2))\n    elif 0 < fitting_angle <= 45:\n        return k_value_square_reduction * 1.6 * np.sin(fitting_angle / 2)\n    else:\n        raise ValueError('k_value_tapered_reduction: The reducer angle ('\n                         + fitting_angle + ') cannot be outside of [0,180].')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drain_OD(q_plant, T, depth_end, SDR):\n    nu = pc.viscosity_kinematic(T)\n    K_minor = con.PIPE_ENTRANCE_K_MINOR + con.PIPE_EXIT_K_MINOR + con.EL90_K_MINOR\n    drain_ID = pc.diam_pipe(q_plant, depth_end, depth_end, nu, mat.PVC_PIPE_ROUGH, K_minor)\n    drain_ND = pipe.SDR_available_ND(drain_ID, SDR)\n    return pipe.OD(drain_ND).magnitude", "response": "Return the nominal diameter of the entrance tank drain pipe."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef num_plates_ET(q_plant, W_chan):\n    num_plates = np.ceil(np.sqrt(q_plant / (design.ent_tank.CENTER_PLATE_DIST.magnitude\n                                            * W_chan * design.ent_tank.CAPTURE_BOD_VEL.magnitude * np.sin(\n                design.ent_tank.PLATE_ANGLE.to(u.rad).magnitude))))\n    return num_plates", "response": "Return the number of plates in the entrance tank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the length of the plates in the entrance tank.", "response": "def L_plate_ET(q_plant, W_chan):\n    \"\"\"Return the length of the plates in the entrance tank.\n\n    Parameters\n    ----------\n    q_plant: float\n        Plant flow rate\n\n    W_chan: float\n        Width of channel\n\n    Returns\n    -------\n    float\n        ?\n\n    Examples\n    --------\n    >>> from aguaclara.play import*\n    >>> L_plate_ET(20*u.L/u.s,2*u.m)\n    0.00194\n    \"\"\"\n    L_plate = (q_plant / (num_plates_ET(q_plant, W_chan) * W_chan *\n                          design.ent_tank.CAPTURE_BOD_VEL.magnitude * np.cos(\n                design.ent_tank.PLATE_ANGLE.to(u.rad).magnitude)))\n    - (design.ent_tank.PLATE_S.magnitude * np.tan(design.ent_tank.PLATE_ANGLE.to(u.rad).magnitude))\n    return L_plate"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef alpha0_carbonate(pH):\n    alpha0_carbonate = 1/(1+(K1_carbonate/invpH(pH)) *\n                            (1+(K2_carbonate/invpH(pH))))\n    return alpha0_carbonate", "response": "Calculates the fraction of total carbonates in carbonic acid form."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef alpha1_carbonate(pH):\n    alpha1_carbonate = 1/((invpH(pH)/K1_carbonate) + 1 +\n                          (K2_carbonate/invpH(pH)))\n    return alpha1_carbonate", "response": "Calculates the fraction of total carbonates in bicarbonate form."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the fraction of total carbonates in carbonate form ( CO3 - 2", "response": "def alpha2_carbonate(pH):\n    \"\"\"Calculate the fraction of total carbonates in carbonate form (CO3-2)\n\n    :param pH: pH of the system\n    :type pH: float\n\n    :return: Fraction of carbonates in carbonate form (CO3-2)\n    :rtype: float\n\n    :Examples:\n\n    >>> from aguaclara.research.environmental_processes_analysis import alpha2_carbonate\n    >>> round(alpha2_carbonate(10), 7)\n    <Quantity(0.359881, 'dimensionless')>\n    \"\"\"\n    alpha2_carbonate = 1/(1+(invpH(pH)/K2_carbonate) *\n                            (1+(invpH(pH)/K1_carbonate)))\n    return alpha2_carbonate"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ANC_closed(pH, total_carbonates):\n    return (total_carbonates * (u.eq/u.mol * alpha1_carbonate(pH) +\n            2 * u.eq/u.mol * alpha2_carbonate(pH)) +\n            1 * u.eq/u.mol * Kw/invpH(pH) - 1 * u.eq/u.mol * invpH(pH))", "response": "Calculates the acid neutralizing capacity under a closed system\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef aeration_data(DO_column, dirpath):\n    #return the list of files in the directory\n    filenames = os.listdir(dirpath)\n    #extract the flowrates from the filenames and apply units\n    airflows = ((np.array([i.split('.', 1)[0] for i in filenames])).astype(np.float32))\n    #sort airflows and filenames so that they are in ascending order of flow rates\n    idx = np.argsort(airflows)\n    airflows = (np.array(airflows)[idx])*u.umole/u.s\n    filenames = np.array(filenames)[idx]\n\n    filepaths = [os.path.join(dirpath, i) for i in filenames]\n    #DO_data is a list of numpy arrays. Thus each of the numpy data arrays can have different lengths to accommodate short and long experiments\n    # cycle through all of the files and extract the column of data with oxygen concentrations and the times\n    DO_data=[column_of_data(i,0,DO_column,-1,'mg/L') for i in filepaths]\n    time_data=[(column_of_time(i,0,-1)).to(u.s) for i in filepaths]\n    aeration_collection = collections.namedtuple('aeration_results','filepaths airflows DO_data time_data')\n    aeration_results = aeration_collection(filepaths, airflows, DO_data, time_data)\n    return aeration_results", "response": "This function extracts the data from the folder containing tab delimited aeration data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef O2_sat(P_air, temp):\n    fraction_O2 = 0.21\n    P_O2 = P_air * fraction_O2\n    return ((P_O2.to(u.atm).magnitude) *\n            u.mg/u.L*np.exp(1727 / temp.to(u.K).magnitude - 2.105))", "response": "Calculate satured oxygen concentration in mg / L for 278 K < T < 318 K"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the data from a ProCoDA Gran plot file.", "response": "def Gran(data_file_path):\n    \"\"\"Extract the data from a ProCoDA Gran plot file. The file must be the original tab delimited file.\n\n    :param data_file_path: The path to the file. If the file is in the working directory, then the file name is sufficient.\n\n    :return: collection of\n\n        * **V_titrant** (*float*) - Volume of titrant in mL\n        * **ph_data** (*numpy.array*) - pH of the sample\n        * **V_sample** (*float*) - Volume of the original sample that was titrated in mL\n        * **Normality_titrant** (*float*) - Normality of the acid used to titrate the sample in mole/L\n        * **V_equivalent** (*float*) - Volume of acid required to consume all of the ANC in mL\n        * **ANC** (*float*) - Acid Neutralizing Capacity of the sample in mole/L\n    \"\"\"\n    df = pd.read_csv(data_file_path, delimiter='\\t', header=5)\n    V_t = np.array(pd.to_numeric(df.iloc[0:, 0]))*u.mL\n    pH = np.array(pd.to_numeric(df.iloc[0:, 1]))\n    df = pd.read_csv(data_file_path, delimiter='\\t', header=-1, nrows=5)\n    V_S = pd.to_numeric(df.iloc[0, 1])*u.mL\n    N_t = pd.to_numeric(df.iloc[1, 1])*u.mole/u.L\n    V_eq = pd.to_numeric(df.iloc[2, 1])*u.mL\n    ANC_sample = pd.to_numeric(df.iloc[3, 1])*u.mole/u.L\n    Gran_collection = collections.namedtuple('Gran_results', 'V_titrant ph_data V_sample Normality_titrant V_equivalent ANC')\n    Gran = Gran_collection(V_titrant=V_t, ph_data=pH, V_sample=V_S,\n                           Normality_titrant=N_t, V_equivalent=V_eq,\n                           ANC=ANC_sample)\n    return Gran"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the effluent concentration of a conversative non - reacting CMFR at time t.", "response": "def CMFR(t, C_initial, C_influent):\n    \"\"\"Calculate the effluent concentration of a conversative (non-reacting)\n    material with continuous input to a completely mixed flow reactor.\n\n    Note: time t=0 is the time at which the material starts to flow into the\n    reactor.\n\n    :param C_initial: The concentration in the CMFR at time t=0.\n    :type C_initial: float\n    :param C_influent: The concentration entering the CMFR.\n    :type C_influent: float\n    :param t: The time(s) at which to calculate the effluent concentration. Time can be made dimensionless by dividing by the residence time of the CMFR.\n    :type t: float or numpy.array\n\n    :return: Effluent concentration\n    :rtype: float\n\n    :Examples:\n\n    >>> from aguaclara.research.environmental_processes_analysis import CMFR\n    >>> from aguaclara.core.units import unit_registry as u\n    >>> round(CMFR(0.1, 0*u.mg/u.L, 10*u.mg/u.L), 7)\n    <Quantity(0.9516258, 'milligram / liter')>\n    >>> round(CMFR(0.9, 5*u.mg/u.L, 10*u.mg/u.L), 7)\n    <Quantity(7.9671517, 'milligram / liter')>\n    \"\"\"\n    return C_influent * (1-np.exp(-t)) + C_initial*np.exp(-t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef E_CMFR_N(t, N):\n    return (N**N)/special.gamma(N) * (t**(N-1))*np.exp(-N*t)", "response": "Calculates a dimensionless measure of the output tracer concentration from a spike input to a series of completely mixed flow reactors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating a dimensionless measure of the output tracer concentration from a spike input to reactor with advection and dispersion.", "response": "def E_Advective_Dispersion(t, Pe):\n    \"\"\"Calculate a dimensionless measure of the output tracer concentration from\n    a spike input to reactor with advection and dispersion.\n\n    :param t: The time(s) at which to calculate the effluent concentration. Time can be made dimensionless by dividing by the residence time of the CMFR.\n    :type t: float or numpy.array\n    :param Pe: The ratio of advection to dispersion ((mean fluid velocity)/(Dispersion*flow path length))\n    :type Pe: float\n\n    :return: dimensionless measure of the output tracer concentration (concentration * volume of reactor) / (mass of tracer)\n    :rtype: float\n\n    :Examples:\n\n    >>> from aguaclara.research.environmental_processes_analysis import E_Advective_Dispersion\n    >>> round(E_Advective_Dispersion(0.5, 5), 7)\n    0.4774864\n    \"\"\"\n    # replace any times at zero with a number VERY close to zero to avoid\n    # divide by zero errors\n    if isinstance(t, list):\n        t[t == 0] = 10**(-10)\n    return (Pe/(4*np.pi*t))**(0.5)*np.exp((-Pe*((1-t)**2))/(4*t))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing by Solver_CMFR_N. All inputs and outputs are unitless. This is The model function, f(x, ...). It takes the independent variable as the first argument and the parameters to fit as separate remaining arguments. :param t_seconds: List of times :type t_seconds: float list :param t_bar: Average time spent in the reactor :type t_bar: float :param C_bar: Average concentration (mass of tracer)/(volume of the reactor) :type C_bar: float :param N: Number of completely mixed flow reactors (CMFRs) in series, must be greater than 1 :type N: int :return: The model concentration as a function of time :rtype: float list :Examples: >>> from aguaclara.research.environmental_processes_analysis import Tracer_CMFR_N >>> from aguaclara.core.units import unit_registry as u >>> Tracer_CMFR_N([1, 2, 3, 4, 5]*u.s, 5*u.s, 10*u.mg/u.L, 3) <Quantity([2.96358283 6.50579498 8.03352597 7.83803116 6.72125423], 'milligram / liter')>", "response": "def Tracer_CMFR_N(t_seconds, t_bar, C_bar, N):\n    \"\"\"Used by Solver_CMFR_N. All inputs and outputs are unitless. This is\n    The model function, f(x, ...). It takes the independent variable as the\n    first argument and the parameters to fit as separate remaining arguments.\n\n    :param t_seconds: List of times\n    :type t_seconds: float list\n    :param t_bar: Average time spent in the reactor\n    :type t_bar: float\n    :param C_bar: Average concentration (mass of tracer)/(volume of the reactor)\n    :type C_bar: float\n    :param N: Number of completely mixed flow reactors (CMFRs) in series, must be greater than 1\n    :type N: int\n\n    :return: The model concentration as a function of time\n    :rtype: float list\n\n    :Examples:\n\n    >>> from aguaclara.research.environmental_processes_analysis import Tracer_CMFR_N\n    >>> from aguaclara.core.units import unit_registry as u\n    >>> Tracer_CMFR_N([1, 2, 3, 4, 5]*u.s, 5*u.s, 10*u.mg/u.L, 3)\n    <Quantity([2.96358283 6.50579498 8.03352597 7.83803116 6.72125423], 'milligram / liter')>\n    \"\"\"\n    return C_bar*E_CMFR_N(t_seconds/t_bar, N)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Solver_CMFR_N(t_data, C_data, theta_guess, C_bar_guess):\n    C_unitless = C_data.magnitude\n    C_units = str(C_bar_guess.units)\n    t_seconds = (t_data.to(u.s)).magnitude\n    # assume that a guess of 1 reactor in series is close enough to get a solution\n    p0 = [theta_guess.to(u.s).magnitude, C_bar_guess.magnitude,1]\n    popt, pcov = curve_fit(Tracer_CMFR_N, t_seconds, C_unitless, p0)\n    Solver_theta = popt[0]*u.s\n    Solver_C_bar = popt[1]*u(C_units)\n    Solver_N = popt[2]\n    Reactor_results = collections.namedtuple('Reactor_results','theta C_bar N')\n    CMFR = Reactor_results(theta=Solver_theta, C_bar=Solver_C_bar, N=Solver_N)\n    return CMFR", "response": "Use non - linear least squares to fit the function\n Tracer_CMFR_N t_seconds C_data C_bar_guess N to reactor data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing by Solver_AD_Pe. All inputs and outputs are unitless. This is the model function, f(x, ...). It takes the independent variable as the first argument and the parameters to fit as separate remaining arguments. :param t_seconds: List of times :type t_seconds: float list :param t_bar: Average time spent in the reactor :type t_bar: float :param C_bar: Average concentration ((mass of tracer)/(volume of the reactor)) :type C_bar: float :param Pe: The Peclet number for the reactor. :type Pe: float :return: The model concentration as a function of time :rtype: float list :Examples: >>> from aguaclara.research.environmental_processes_analysis import Tracer_AD_Pe >>> from aguaclara.core.units import unit_registry as u >>> Tracer_AD_Pe([1, 2, 3, 4, 5]*u.s, 5*u.s, 10*u.mg/u.L, 5) <Quantity([0.25833732 3.23793989 5.8349833 6.62508831 6.30783131], 'milligram / liter')>", "response": "def Tracer_AD_Pe(t_seconds, t_bar, C_bar, Pe):\n    \"\"\"Used by Solver_AD_Pe. All inputs and outputs are unitless. This is the\n    model function, f(x, ...). It takes the independent variable as the\n    first argument and the parameters to fit as separate remaining arguments.\n\n    :param t_seconds: List of times\n    :type t_seconds: float list\n    :param t_bar: Average time spent in the reactor\n    :type t_bar: float\n    :param C_bar: Average concentration ((mass of tracer)/(volume of the reactor))\n    :type C_bar: float\n    :param Pe: The Peclet number for the reactor.\n    :type Pe: float\n\n    :return: The model concentration as a function of time\n    :rtype: float list\n\n    :Examples:\n\n    >>> from aguaclara.research.environmental_processes_analysis import Tracer_AD_Pe\n    >>> from aguaclara.core.units import unit_registry as u\n    >>> Tracer_AD_Pe([1, 2, 3, 4, 5]*u.s, 5*u.s, 10*u.mg/u.L, 5)\n    <Quantity([0.25833732 3.23793989 5.8349833  6.62508831 6.30783131], 'milligram / liter')>\n\n    \"\"\"\n    return C_bar*E_Advective_Dispersion(t_seconds/t_bar, Pe)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuses non - linear least squares to fit the functionTracer_AD_Pe to get a solution for a given set of time spent in one CMFR with units theta_guess and C_bar_guess.", "response": "def Solver_AD_Pe(t_data, C_data, theta_guess, C_bar_guess):\n    \"\"\"Use non-linear least squares to fit the function\n    Tracer_AD_Pe(t_seconds, t_bar, C_bar, Pe) to reactor data.\n\n    :param t_data: Array of times with units\n    :type t_data: float list\n    :param C_data: Array of tracer concentration data with units\n    :type C_data: float list\n    :param theta_guess: Estimate of time spent in one CMFR with units.\n    :type theta_guess: float\n    :param C_bar_guess: Estimate of average concentration with units ((mass of tracer)/(volume of one CMFR))\n    :type C_bar_guess: float\n\n    :return: tuple of\n\n        * **theta** (*float*)- Residence time in seconds\n        * **C_bar** (*float*) - Average concentration with same units as C_bar_guess\n        * **Pe** (*float*) - Peclet number that best fits the data\n    \"\"\"\n    #remove time=0 data to eliminate divide by zero error\n    t_data = t_data[1:-1]\n    C_data = C_data[1:-1]\n    C_unitless = C_data.magnitude\n    C_units = str(C_bar_guess.units)\n    t_seconds = (t_data.to(u.s)).magnitude\n    # assume that a guess of 1 reactor in series is close enough to get a solution\n    p0 = [theta_guess.to(u.s).magnitude, C_bar_guess.magnitude,5]\n    popt, pcov = curve_fit(Tracer_AD_Pe, t_seconds, C_unitless, p0, bounds=(0.01,np.inf))\n    Solver_theta = popt[0]*u.s\n    Solver_C_bar = popt[1]*u(C_units)\n    Solver_Pe = popt[2]\n    Reactor_results = collections.namedtuple('Reactor_results', 'theta C_bar Pe')\n    AD = Reactor_results(theta=Solver_theta, C_bar=Solver_C_bar, Pe=Solver_Pe)\n    return AD"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the number of significant figures used to print Pint Pandas and NumPy quantities.", "response": "def set_sig_figs(n=4):\n    \"\"\"Set the number of significant figures used to print Pint, Pandas, and\n    NumPy quantities.\n\n    Args:\n        n (int): Number of significant figures to display.\n    \"\"\"\n    u.default_format = '.' + str(n) + 'g'\n    pd.options.display.float_format = ('{:,.' + str(n) + '}').format"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract columns of data from a ProCoDA datalog based on date and time.", "response": "def get_data_by_time(path, columns, dates, start_time='00:00', end_time='23:59'):\n    \"\"\"Extract columns of data from a ProCoDA datalog based on date(s) and time(s)\n\n    Note: Column 0 is time. The first data column is column 1.\n\n    :param path: The path to the folder containing the ProCoDA data file(s)\n    :type path: string\n    :param columns: A single index of a column OR a list of indices of columns of data to extract.\n    :type columns: int or int list\n    :param dates: A single date or list of dates for which data was recorded, formatted \"M-D-YYYY\"\n    :type dates: string or string list\n    :param start_time: Starting time of data to extract, formatted 'HH:MM' (24-hour time)\n    :type start_time: string, optional\n    :param end_time: Ending time of data to extract, formatted 'HH:MM' (24-hour time)\n    :type end_time: string, optional\n\n    :return: a list containing the single column of data to extract, OR a list of lists containing the columns to extract, in order of the indices given in the columns variable\n    :rtype: list or list list\n\n    :Examples:\n\n    .. code-block:: python\n\n        data = get_data_by_time(path='/Users/.../ProCoDA Data/', columns=4, dates=['6-14-2018', '6-15-2018'], start_time='12:20', end_time='10:50')\n        data = get_data_by_time(path='/Users/.../ProCoDA Data/', columns=[0,4], dates='6-14-2018', start_time='12:20', end_time='23:59')\n        data = get_data_by_time(path='/Users/.../ProCoDA Data/', columns=[0,3,4], dates='6-14-2018')\n    \"\"\"\n    data = data_from_dates(path, dates)\n\n    first_time_column = pd.to_numeric(data[0].iloc[:, 0])\n    start = max(day_fraction(start_time), first_time_column[0])\n    start_idx = time_column_index(start, first_time_column)\n    end_idx = time_column_index(day_fraction(end_time),\n        pd.to_numeric(data[-1].iloc[:, 0])) + 1\n\n    if isinstance(columns, int):\n        return column_start_to_end(data, columns, start_idx, end_idx)\n    else:\n        result = []\n        for c in columns:\n            result.append(column_start_to_end(data, c, start_idx, end_idx))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nomit notes from a DataFrame object where notes are identified as rows with non - numerical entries in the first column.", "response": "def remove_notes(data):\n    \"\"\"Omit notes from a DataFrame object, where notes are identified as rows with non-numerical entries in the first column.\n\n    :param data: DataFrame object to remove notes from\n    :type data: Pandas.DataFrame\n\n    :return: DataFrame object with no notes\n    :rtype: Pandas.DataFrame\n    \"\"\"\n    has_text = data.iloc[:, 0].astype(str).str.contains('(?!e-)[a-zA-Z]')\n    text_rows = list(has_text.index[has_text])\n    return data.drop(text_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a 24 - hour time to a fraction of a day.", "response": "def day_fraction(time):\n    \"\"\"Convert a 24-hour time to a fraction of a day.\n\n    For example, midnight corresponds to 0.0, and noon to 0.5.\n\n    :param time: Time in the form of 'HH:MM' (24-hour time)\n    :type time: string\n\n    :return: A day fraction\n    :rtype: float\n\n    :Examples:\n\n    .. code-block:: python\n\n        day_fraction(\"18:30\")\n    \"\"\"\n    hour = int(time.split(\":\")[0])\n    minute = int(time.split(\":\")[1])\n    return hour/24 + minute/1440"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef time_column_index(time, time_column):\n    interval = time_column[1]-time_column[0]\n    return int(round((time - time_column[0])/interval + .5))", "response": "Return the index of the lowest time in the column that is greater\n    than or equal to the given time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list DataFrames representing the ProCoDA datalogs stored in the given path and recorded on the given dates.", "response": "def data_from_dates(path, dates):\n    \"\"\"Return list DataFrames representing the ProCoDA datalogs stored in\n    the given path and recorded on the given dates.\n\n    :param path: The path to the folder containing the ProCoDA data file(s)\n    :type path: string\n    :param dates: A single date or list of dates for which data was recorded, formatted \"M-D-YYYY\"\n    :type dates: string or string list\n\n    :return: a list DataFrame objects representing the ProCoDA datalogs corresponding with the given dates\n    :rtype: pandas.DataFrame list\n    \"\"\"\n    if path[-1] != os.path.sep:\n        path += os.path.sep\n\n    if not isinstance(dates, list):\n        dates = [dates]\n\n    data = []\n    for d in dates:\n        filepath = path + 'datalog ' + d + '.xls'\n        data.append(remove_notes(pd.read_csv(filepath, delimiter='\\t')))\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of numeric data entries in the given column from the starting index to the ending index.", "response": "def column_start_to_end(data, column, start_idx, end_idx):\n    \"\"\"Return a list of numeric data entries in the given column from the starting\n    index to the ending index. This can list can be compiled over one or more\n    DataFrames.\n\n    :param data: a list of DataFrames to extract data in one column from\n    :type data: Pandas.DataFrame list\n    :param column: a column index\n    :type column: int\n    :param start_idx: the index of the starting row\n    :type start_idx: int\n    :param start_idx: the index of the ending row\n    :type start_idx: int\n\n    :return: a list of data from the given column\n    :rtype: float list\n    \"\"\"\n    if len(data) == 1:\n        result = list(pd.to_numeric(data[0].iloc[start_idx:end_idx, column]))\n    else:\n        result = list(pd.to_numeric(data[0].iloc[start_idx:, column]))\n        for i in range(1, len(data)-1):\n            data[i].iloc[0, 0] = 0\n            result += list(pd.to_numeric(data[i].iloc[:, column]) +\n                      (i if column == 0 else 0))\n        data[-1].iloc[0, 0] = 0\n        result += list(pd.to_numeric(data[-1].iloc[:end_idx, column]) +\n                  (len(data)-1 if column == 0 else 0))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a ProCoDA file and extracts the time and data column for each iteration of the given state.", "response": "def get_data_by_state(path, dates, state, column):\n    \"\"\"Reads a ProCoDA file and extracts the time and data column for each\n    iteration ofthe given state.\n\n    Note: column 0 is time, the first data column is column 1.\n\n    :param path: The path to the folder containing the ProCoDA data file(s), defaults to the current directory\n    :type path: string\n    :param dates: A single date or list of dates for which data was recorded, formatted \"M-D-YYYY\"\n    :type dates: string or string list\n    :param state: The state ID number for which data should be plotted\n    :type state: int\n    :param column: The integer index of the column that you want to extract OR the header of the column that you want to extract\n    :type column: int or string\n\n    :return: A list of lists of the time and data columns extracted for each iteration of the state. For example, if \"data\" is the output, data[i][:,0] gives the time column and data[i][:,1] gives the data column for the ith iteration of the given state and column. data[i][0] would give the first [time, data] pair.\n    :type: list of lists of lists\n\n    :Examples:\n\n    .. code-block:: python\n\n        data = get_data_by_state(path='/Users/.../ProCoDA Data/', dates=[\"6-19-2013\", \"6-20-2013\"], state=1, column=28)\n    \"\"\"\n    data_agg = []\n    day = 0\n    first_day = True\n    overnight = False\n    extension = \".xls\"\n    if path[-1] != '/':\n        path += '/'\n\n    if not isinstance(dates, list):\n        dates = [dates]\n\n    for d in dates:\n        state_file = path + \"statelog \" + d + extension\n        data_file = path + \"datalog \" + d + extension\n\n        states = pd.read_csv(state_file, delimiter='\\t')\n        data = pd.read_csv(data_file, delimiter='\\t')\n\n        states = np.array(states)\n        data = np.array(data)\n\n        # get the start and end times for the state\n        state_start_idx = states[:, 1] == state\n        state_start = states[state_start_idx, 0]\n        state_end_idx = np.append([False], state_start_idx[0:-1])\n        state_end = states[state_end_idx, 0]\n\n        if overnight:\n            state_start = np.insert(state_start, 0, 0)\n            state_end = np.insert(state_end, 0, states[0, 0])\n\n        if state_start_idx[-1]:\n            np.append(state_end, data[0, -1])\n\n        # get the corresponding indices in the data array\n        data_start = []\n        data_end = []\n        for i in range(np.size(state_start)):\n            add_start = True\n            for j in range(np.size(data[:, 0])):\n                if (data[j, 0] > state_start[i]) and add_start:\n                    data_start.append(j)\n                    add_start = False\n                if data[j, 0] > state_end[i]:\n                    data_end.append(j-1)\n                    break\n\n        if first_day:\n            start_time = data[0, 0]\n\n        # extract data at those times\n        for i in range(np.size(data_start)):\n            t = data[data_start[i]:data_end[i], 0] + day - start_time\n            if isinstance(column, int):\n                c = data[data_start[i]:data_end[i], column]\n            else:\n                c = data[column][data_start[i]:data_end[i]]\n            if overnight and i == 0:\n                data_agg = np.insert(data_agg[-1], np.size(data_agg[-1][:, 0]),\n                                     np.vstack((t, c)).T)\n            else:\n                data_agg.append(np.vstack((t, c)).T)\n\n        day += 1\n        if first_day:\n            first_day = False\n        if state_start_idx[-1]:\n            overnight = True\n\n    return data_agg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef column_of_time(path, start, end=-1):\n    df = pd.read_csv(path, delimiter='\\t')\n    start_time = pd.to_numeric(df.iloc[start, 0])*u.day\n    day_times = pd.to_numeric(df.iloc[start:end, 0])\n    time_data = np.subtract((np.array(day_times)*u.day), start_time)\n    return time_data", "response": "This function extracts the column of times from a ProCoDA data file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_state_with_metafile(func, state, column, path, metaids=[],\n                             extension=\".xls\", units=\"\"):\n    \"\"\"Takes in a ProCoDA meta file and performs a function for all data of a\n    certain state in each of the experiments (denoted by file paths in then\n    metafile)\n\n    Note: Column 0 is time. The first data column is column 1.\n\n    :param func: A function that will be applied to data from each instance of the state\n    :type func: function\n    :param state: The state ID number for which data should be extracted\n    :type state: int\n    :param column: Index of the column that you want to extract OR header of the column that you want to extract\n    :type column: int or string\n    :param path: The file path of the ProCoDA data file (must be tab-delimited)\n    :type path: string\n    :param metaids: a list of the experiment IDs you'd like to analyze from the metafile\n    :type metaids: string list, optional\n    :param extension: The file extension of the tab delimited file. Defaults to \".xls\" if no argument is passed in\n    :type extension: string, optional\n    :param units: The units you want to apply to the data, e.g. 'mg/L'. Defaults to \"\" (dimensionless)\n    :type units: string, optional\n\n    :return: ids (string list) - The list of experiment ids given in the metafile\n    :return: outputs (list) - The outputs of the given function for each experiment\n\n    :Examples:\n\n    .. code-block:: python\n\n        def avg_with_units(lst):\n            num = np.size(lst)\n            acc = 0\n            for i in lst:\n                acc = i + acc\n\n            return acc / num\n\n        path = \"../tests/data/Test Meta File.txt\"\n        ids, answer = read_state_with_metafile(avg_with_units, 1, 28, path, [], \".xls\", \"mg/L\")\n    \"\"\"\n    outputs = []\n\n    metafile = pd.read_csv(path, delimiter='\\t', header=None)\n    metafile = np.array(metafile)\n\n    ids = metafile[1:, 0]\n\n    if not isinstance(ids[0], str):\n        ids = list(map(str, ids))\n\n    if metaids:\n        paths = []\n        for i in range(len(ids)):\n            if ids[i] in metaids:\n                paths.append(metafile[i, 4])\n    else:\n        paths = metafile[1:, 4]\n\n    basepath = os.path.join(os.path.split(path)[0], metafile[0, 4])\n\n    # use a loop to evaluate each experiment in the metafile\n    for i in range(len(paths)):\n        # get the range of dates for experiment i\n        day1 = metafile[i+1, 1]\n\n        # modify the metafile date so that it works with datetime format\n        if not (day1[2] == \"-\" or day1[2] == \"/\"):\n            day1 = \"0\" + day1\n        if not (day1[5] == \"-\" or day1[5] == \"/\"):\n            day1 = day1[:3] + \"0\" + day1[3:]\n\n        if day1[2] == \"-\":\n            dt = datetime.strptime(day1, \"%m-%d-%Y\")\n        else:\n            dt = datetime.strptime(day1, \"%m/%d/%y\")\n        duration = metafile[i+1, 3]\n\n        if not isinstance(duration, int):\n            duration = int(duration)\n\n        date_list = []\n        for j in range(duration):\n            curr_day = dt.strftime(\"%m-%d-%Y\")\n            if curr_day[3] == \"0\":\n                curr_day = curr_day[:3] + curr_day[4:]\n            if curr_day[0] == \"0\":\n                curr_day = curr_day[1:]\n\n            date_list.append(curr_day)\n\n            dt = dt + timedelta(days=1)\n\n        path = str(Path(os.path.join(basepath, paths[i]))) + os.sep\n        _, data = read_state(date_list, state, column, units, path, extension)\n\n        outputs.append(func(data))\n\n    return ids, outputs", "response": "Takes in a ProCoDA meta file and performs a function for all data in each of the experiments and returns the state ID and the outputs of the function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_calculations_to_csv(funcs, states, columns, path, headers, out_name,\n                              metaids=[], extension=\".xls\"):\n    \"\"\"Writes each output of the given functions on the given states and data\n    columns to a new column in the specified output file.\n\n    Note: Column 0 is time. The first data column is column 1.\n\n    :param funcs: A function or list of functions which will be applied in order to the data. If only one function is given it is applied to all the states/columns\n    :type funcs: function or function list\n    :param states: The state ID numbers for which data should be extracted. List should be in order of calculation or if only one state is given then it will be used for all the calculations\n    :type states: string or string list\n    :param columns: The index of a column, the header of a column, a list of indexes, OR a list of headers of the column(s) that you want to apply calculations to\n    :type columns: int, string, int list, or string list\n    :param path: Path to your ProCoDA metafile (must be tab-delimited)\n    :type path: string\n    :param headers: List of the desired header for each calculation, in order\n    :type headers: string list\n    :param out_name: Desired name for the output file. Can include a relative path\n    :type out_name: string\n    :param metaids: A list of the experiment IDs you'd like to analyze from the metafile\n    :type metaids: string list, optional\n    :param extension: The file extension of the tab delimited file. Defaults to \".xls\" if no argument is passed in\n    :type extension: string, optional\n\n    :requires: funcs, states, columns, and headers are all of the same length if they are lists. Some being lists and some single values are okay.\n\n    :return: out_name.csv (CVS file) - A CSV file with the each column being a new calcuation and each row being a new experiment on which the calcuations were performed\n    :return: output (Pandas.DataFrame)- Pandas DataFrame holding the same data that was written to the output file\n    \"\"\"\n    if not isinstance(funcs, list):\n        funcs = [funcs] * len(headers)\n\n    if not isinstance(states, list):\n        states = [states] * len(headers)\n\n    if not isinstance(columns, list):\n        columns = [columns] * len(headers)\n\n    data_agg = []\n    for i in range(len(headers)):\n        ids, data = read_state_with_metafile(funcs[i], states[i], columns[i],\n                                             path, metaids, extension)\n        data_agg = np.append(data_agg, [data])\n\n    output = pd.DataFrame(data=np.vstack((ids, data_agg)).T,\n                          columns=[\"ID\"]+headers)\n    output.to_csv(out_name, sep='\\t')\n\n    return output", "response": "Writes each output of the given functions on the given states and data columns to a new column in the specified output file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the maximum possible number of plates in a module given a set of sed plates.", "response": "def n_sed_plates_max(sed_inputs=sed_dict):\n    \"\"\"Return the maximum possible number of plate settlers in a module given\n    plate spacing, thickness, angle, and unsupported length of plate settler.\n    Parameters\n    ----------\n    S_plate : float\n        Edge to edge distance between plate settlers\n    thickness_plate : float\n        Thickness of PVC sheet used to make plate settlers\n    L_sed_plate_cantilevered : float\n        Maximum length of sed plate sticking out past module pipes without any\n        additional support. The goal is to prevent floppy modules that don't\n        maintain constant distances between the plates\n    angle_plate : float\n        Angle of plate settlers\n    Returns\n    -------\n    int\n        Maximum number of plates\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    B_plate = sed_inputs['plate_settlers']['S'] + sed_inputs['plate_settlers']['thickness']\n    return math.floor((sed_inputs['plate_settlers']['L_cantilevered'].magnitude / B_plate.magnitude\n                      * np.tan(sed_inputs['plate_settlers']['angle'].to(u.rad).magnitude)) + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the minimum inner width of each diffuser in the sedimentation tank.", "response": "def w_diffuser_inner_min(sed_inputs=sed_dict):\n    \"\"\"Return the minimum inner width of each diffuser in the sedimentation tank.\n    Parameters\n    ----------\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations. Can be found in sed.yaml\n    Returns\n    -------\n    float\n        Minimum inner width of each diffuser in the sedimentation tank\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    return ((sed_inputs['tank']['vel_up'].to(u.inch/u.s).magnitude /\n             sed_inputs['manifold']['diffuser']['vel_max'].to(u.inch/u.s).magnitude)\n             * sed_inputs['tank']['W'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the inner width of each diffuser in the sedimentation tank.", "response": "def w_diffuser_inner(sed_inputs=sed_dict):\n    \"\"\"Return the inner width of each diffuser in the sedimentation tank.\n    Parameters\n    ----------\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Inner width of each diffuser in the sedimentation tank\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    return ut.ceil_nearest(w_diffuser_inner_min(sed_inputs).magnitude,\n                           (np.arange(1/16,1/4,1/16)*u.inch).magnitude)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef w_diffuser_outer(sed_inputs=sed_dict):\n    return (w_diffuser_inner_min(sed_inputs['tank']['W']) +\n            (2 * sed_inputs['manifold']['diffuser']['thickness_wall'])).to(u.m).magnitude", "response": "Return the outer width of each diffuser in the sedimentation tank."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef L_diffuser_outer(sed_inputs=sed_dict):\n    return ((sed_inputs['manifold']['diffuser']['A'] /\n           (2 * sed_inputs['manifold']['diffuser']['thickness_wall']))\n           - w_diffuser_inner(sed_inputs).to(u.inch)).to(u.m).magnitude", "response": "Return the outer length of each diffuser in the sedimentation tank."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the inner length of each diffuser in the sedimentation tank.", "response": "def L_diffuser_inner(sed_inputs=sed_dict):\n    \"\"\"Return the inner length of each diffuser in the sedimentation tank.\n    Parameters\n    ----------\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Inner length of each diffuser in the sedimentation tank\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    return L_diffuser_outer(sed_inputs['tank']['W']) -\n            (2 * (sed_inputs['manifold']['diffuser']['thickness_wall']).to(u.m)).magnitude)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef q_diffuser(sed_inputs=sed_dict):\n    return (sed_inputs['tank']['vel_up'].to(u.m/u.s) *\n             sed_inputs['tank']['W'].to(u.m) *\n             L_diffuser_outer(sed_inputs)).magnitude", "response": "Return the flow through each diffuser in the sedimentation tank."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vel_sed_diffuser(sed_inputs=sed_dict):\n    return (q_diffuser(sed_inputs).magnitude\n            / (w_diffuser_inner(w_tank) * L_diffuser_inner(w_tank)).magnitude)", "response": "Return the velocity through each diffuser in the sedimentation tank."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef q_tank(sed_inputs=sed_dict):\n    return (sed_inputs['tank']['L'] * sed_inputs['tank']['vel_up'].to(u.m/u.s) *\n            sed_inputs['tank']['W'].to(u.m)).magnitude", "response": "Return the maximum flow through one sedimentation tank."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the maximum velocity through the manifold.", "response": "def vel_inlet_man_max(sed_inputs=sed_dict):\n    \"\"\"Return the maximum velocity through the manifold.\n    Parameters\n    ----------\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Maximum velocity through the manifold.\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    vel_manifold_max = (sed_inputs['diffuser']['vel_max'].to(u.m/u.s).magnitude *\n        sqrt(2*((1-(sed_inputs['manifold']['ratio_Q_man_orifice'])**2)) /\n        (((sed_inputs['manifold']['ratio_Q_man_orifice'])**2)+1)))\n    return vel_manifold_max"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the number of tanks required for a given flow rate.", "response": "def n_tanks(Q_plant, sed_inputs=sed_dict):\n    \"\"\"Return the number of sedimentation tanks required for a given flow rate.\n    Parameters\n    ----------\n    Q_plant : float\n        Total plant flow rate\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    int\n        Number of sedimentation tanks required for a given flow rate.\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    q = q_tank(sed_inputs).magnitude\n    return (int(np.ceil(Q_plant / q)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the length of the inlet and exit channels for the sedimentation tank.", "response": "def L_channel(Q_plant, sed_inputs=sed_dict):\n    \"\"\"Return the length of the inlet and exit channels for the sedimentation tank.\n    Parameters\n    ----------\n    Q_plant : float\n        Total plant flow rate\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Length of the inlet and exit channels for the sedimentation tank.\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    n_tanks = n_tanks(Q_plant, sed_inputs)\n    return ((n_tanks * sed_inputs['tank']['W']) + sed_inputs['thickness_wall'] +\n            ((n_tanks-1) * sed_inputs['thickness_wall']))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the inner diameter of the exit manifold by guessing an initial diameter of the exit manifold.", "response": "def ID_exit_man(Q_plant, temp, sed_inputs=sed_dict):\n    \"\"\"Return the inner diameter of the exit manifold by guessing an initial\n    diameter then iterating through pipe flow calculations until the answer\n    converges within 1%% error\n    Parameters\n    ----------\n    Q_plant : float\n        Total plant flow rate\n    temp : float\n        Design temperature\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Inner diameter of the exit manifold\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    #Inputs do not need to be checked here because they are checked by\n    #functions this function calls.\n    nu = pc.viscosity_dynamic(temp)\n    hl = sed_input['manifold']['exit_man']['hl_orifice'].to(u.m)\n    L = sed_ipnut['manifold']['tank']['L']\n    N_orifices = sed_inputs['manifold']['exit_man']['N_orifices']\n    K_minor = con.K_MINOR_PIPE_EXIT\n    pipe_rough = mat.PIPE_ROUGH_PVC.to(u.m)\n\n    D = max(diam_pipemajor(Q_plant, hl, L, nu, pipe_rough).magnitude,\n                   diam_pipeminor(Q_plant, hl, K_minor).magnitude)\n    err = 1.00\n    while err > 0.01:\n            D_prev = D\n            f = pc.fric(Q_plant, D_prev, nu, pipe_rough)\n            D = ((8*Q_plant**2 / pc.GRAVITY.magnitude * np.pi**2 * hl) *\n                    (((f*L/D_prev + K_minor) * (1/3 * 1/) *\n                    (1/3 + 1/(2 * N_orifices) + 1/(6 * N_orifices**2)))\n                    / (1 - sed_inputs['manifold']['ratio_Q_orifice']**2)))**0.25\n            err = abs(D_prev - D) / ((D + D_prev) / 2)\n    return D"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the diameter of the orifices in the exit manifold for the sedimentation tank.", "response": "def D_exit_man_orifice(Q_plant, drill_bits, sed_inputs=sed_dict):\n    \"\"\"Return the diameter of the orifices in the exit manifold for the sedimentation tank.\n    Parameters\n    ----------\n    Q_plant : float\n        Total plant flow rate\n    drill_bits : list\n        List of possible drill bit sizes\n    sed_inputs : dict\n        A dictionary of all of the constant inputs needed for sedimentation tank\n        calculations can be found in sed.yaml\n    Returns\n    -------\n    float\n        Diameter of the orifices in the exit manifold for the sedimentation tank.\n    Examples\n    --------\n    >>> from aide_design.play import*\n    >>>\n    \"\"\"\n    Q_orifice = Q_plant/sed_input['exit_man']['N_orifices']\n    D_orifice = np.sqrt(Q_orifice**4)/(np.pi * con.RATIO_VC_ORIFICE * np.sqrt(2 * pc.GRAVITY.magnitude * sed_input['exit_man']['hl_orifice'].magnitude))\n    return ut.ceil_nearest(D_orifice, drill_bits)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef L_sed_plate(sed_inputs=sed_dict):\n    L_sed_plate = ((sed_input['plate_settlers']['S'] * ((sed_input['tank']['vel_up']/sed_input['plate_settlers']['vel_capture'])-1)\n                  + sed_input['plate_settlers']['thickness'] * (sed_input['tank']['vel_up']/sed_input['plate_settlers']['vel_capture']))\n                 / (np.sin(sed_input['plate_settlers']['angle']) * np.cos(sed_input['plate_settlers']['angle']))\n                 ).to(u.m)\n    return L_sed_plate", "response": "Return the length of a single plate in the plate settler module based on the desired capture velocity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef OD(ND):\n    index = (np.abs(np.array(pipedb['NDinch']) - (ND))).argmin()\n    return pipedb.iloc[index, 1]", "response": "Return a pipe s outer diameter according to its nominal diameter."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the inner diameter for schedule 40 pipes.", "response": "def ID_sch40(ND):\n    \"\"\"Return the inner diameter for schedule 40 pipes.\n\n    The wall thickness for these pipes is in the pipedb.\n\n    Take the values of the array, subtract the ND, take the absolute\n    value, find the index of the minimium value.\n    \"\"\"\n    myindex = (np.abs(np.array(pipedb['NDinch']) - (ND))).argmin()\n    return (pipedb.iloc[myindex, 1] - 2*(pipedb.iloc[myindex, 5]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ND_all_available():\n    ND_all_available = []\n    for i in range(len(pipedb['NDinch'])):\n        if pipedb.iloc[i, 4] == 1:\n            ND_all_available.append((pipedb['NDinch'][i]))\n    return ND_all_available * u.inch", "response": "Return an array of nominal diameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ID_SDR_all_available(SDR):\n    ID = []\n    ND = ND_all_available()\n    for i in range(len(ND)):\n        ID.append(ID_SDR(ND[i], SDR).magnitude)\n    return ID * u.inch", "response": "Return an array of inner diameters with a given SDR."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ND_SDR_available(ID, SDR):\n    for i in range(len(np.array(ID_SDR_all_available(SDR)))):\n        if np.array(ID_SDR_all_available(SDR))[i] >= (ID.to(u.inch)).magnitude:\n            return ND_all_available()[i]", "response": "Return an available ND given an ID and a schedule."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flow_pipeline(diameters, lengths, k_minors, target_headloss,\n                  nu=con.WATER_NU, pipe_rough=mats.PVC_PIPE_ROUGH):\n    \"\"\"\n    This function takes a single pipeline with multiple sections, each potentially with different diameters,\n    lengths and minor loss coefficients and determines the flow rate for a given headloss.\n\n    :param diameters: list of diameters, where the i_th diameter corresponds to the i_th pipe section\n    :type diameters: numpy.ndarray\n    :param lengths: list of diameters, where the i_th diameter corresponds to the i_th pipe section\n    :type lengths: numpy.ndarray\n    :param k_minors: list of diameters, where the i_th diameter corresponds to the i_th pipe section\n    :type k_minors: numpy.ndarray\n    :param target_headloss: a single headloss describing the total headloss through the system\n    :type target_headloss: float\n    :param nu: The fluid dynamic viscosity of the fluid. Defaults to water at room temperature (1 * 10**-6 * m**2/s)\n    :type nu: float\n    :param pipe_rough:  The pipe roughness. Defaults to PVC roughness.\n    :type pipe_rough: float\n\n    :return: the total flow through the system\n    :rtype: float\n    \"\"\"\n\n    # Ensure all the arguments except total headloss are the same length\n    #TODO\n\n    # Total number of pipe lengths\n    n = diameters.size\n\n    # Start with a flow rate guess based on the flow through a single pipe section\n    flow = pc.flow_pipe(diameters[0], target_headloss, lengths[0], nu, pipe_rough, k_minors[0])\n    err = 1.0\n\n    # Add all the pipe length headlosses together to test the error\n    while abs(err) > 0.01 :\n        headloss = sum([pc.headloss(flow, diameters[i], lengths[i], nu, pipe_rough,\n                                    k_minors[i]).to(u.m).magnitude for i in range(n)])\n        # Test the error. This is always less than one.\n        err = (target_headloss - headloss) / (target_headloss + headloss)\n        # Adjust the total flow in the direction of the error. If there is more headloss than target headloss,\n        # The flow should be reduced, and vice-versa.\n        flow = flow + err * flow\n\n    return flow", "response": "This function takes a single pipeline with multiple sections each potentially with different diameters lengths and minor loss coefficients and determines the flow rate for a given headloss."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the width of a Stout weir at elevation z. More info LFOM + sutro + weir + research >", "response": "def stout_w_per_flow(self, z):\n        \"\"\"Return the width of a Stout weir at elevation z. More info\n        here. <https://confluence.cornell.edu/display/AGUACLARA/\n        LFOM+sutro+weir+research>\n        \"\"\"\n        w_per_flow = 2 / ((2 * pc.gravity * z) ** (1 / 2) *\n                          con.VC_ORIFICE_RATIO * np.pi * self.hl)\n        return w_per_flow.to_base_units()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nom_diam_pipe(self):\n        ID = pc.diam_circle(self.area_pipe_min)\n        return pipe.ND_SDR_available(ID, self.sdr)", "response": "The nominal diameter of the LFOM pipe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nestimate the area of the top orifice for the given set of orifices.", "response": "def area_top_orifice(self):\n        \"\"\"Estimate the orifice area corresponding to the top row of orifices.\n        Another solution method is to use integration to solve this problem.\n        Here we use the width of the stout weir in the center of the top row\n        to estimate the area of the top orifice\n        \"\"\"\n        # Calculate the center of the top row:\n        z = self.hl - 0.5 * self.b_rows\n        # Multiply the stout weir width by the height of one row.\n        return self.stout_w_per_flow(z) * self.q * self.b_rows"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flow_ramp(self):\n        return np.linspace(1 / self.n_rows, 1, self.n_rows)*self.q", "response": "An equally spaced array representing flow at each row."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the height of the center of each row of orifices.", "response": "def height_orifices(self):\n        \"\"\"Calculates the height of the center of each row of orifices.\n        The bottom of the bottom row orifices is at the zero elevation\n        point of the LFOM so that the flow goes to zero when the water height\n        is at zero.\n        \"\"\"\n\n        return (np.linspace(0, self.n_rows-1, self.n_rows))*self.b_rows + 0.5 * self.orifice_diameter"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flow_actual(self, Row_Index_Submerged, N_LFOM_Orifices):\n\n        flow = 0\n        for i in range(Row_Index_Submerged + 1):\n            flow = flow + (N_LFOM_Orifices[i] * (\n               pc.flow_orifice_vert(self.orifice_diameter,\n                                    self.b_rows*(Row_Index_Submerged + 1)\n                                    - self.height_orifices[i],\n                                    con.VC_ORIFICE_RATIO)))\n        return flow", "response": "Calculates the flow for a given number of submerged rows of orifices."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef n_orifices_per_row(self):\n        # H is distance from the bottom of the next row of orifices to the\n        # center of the current row of orifices\n        H = self.b_rows - 0.5*self.orifice_diameter\n        flow_per_orifice = pc.flow_orifice_vert(self.orifice_diameter, H, con.VC_ORIFICE_RATIO)\n        n = np.zeros(self.n_rows)\n        for i in range(self.n_rows):\n            # calculate the ideal number of orifices at the current row without\n            # constraining to an integer\n            flow_needed = self.flow_ramp[i] - self.flow_actual(i, n)\n            n_orifices_real = (flow_needed / flow_per_orifice).to(u.dimensionless)\n            # constrain number of orifices to be less than the max per row and\n            # greater or equal to 0\n            n[i] = min((max(0, round(n_orifices_real))), self.n_orifices_per_row_max)\n        return n", "response": "Calculate number of orifices at each level given an orifice magnitude."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef error_per_row(self):\n        FLOW_lfom_error = np.zeros(self.n_rows)\n        for i in range(self.n_rows):\n            actual_flow = self.flow_actual(i, self.n_orifices_per_row)\n            FLOW_lfom_error[i] = (((actual_flow - self.flow_ramp[i]) / self.flow_ramp[i]).to(u.dimensionless)).magnitude\n        return FLOW_lfom_error", "response": "This function calculates the error of the design based on the predicted flow rate\n        and the actual flow rate through the LFOM."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns array of possible drill diameters in imperial.", "response": "def get_drill_bits_d_imperial():\n    \"\"\"Return array of possible drill diameters in imperial.\"\"\"\n    step_32nd = np.arange(0.03125, 0.25, 0.03125)\n    step_8th = np.arange(0.25, 1.0, 0.125)\n    step_4th = np.arange(1.0, 2.0, 0.25)\n    maximum = [2.0]\n\n    return np.concatenate((step_32nd,\n                           step_8th,\n                           step_4th,\n                           maximum)) * u.inch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn array of possible drill diameters in metric.", "response": "def get_drill_bits_d_metric():\n    \"\"\"Return array of possible drill diameters in metric.\"\"\"\n    return np.concatenate((np.arange(1.0, 10.0, 0.1),\n                           np.arange(10.0, 18.0, 0.5),\n                           np.arange(18.0, 36.0, 1.0),\n                           np.arange(40.0, 55.0, 5.0))) * u.mm"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef C_stock(self):\n        return self._C_sys * (self._Q_sys / self._Q_stock).to(u.dimensionless)", "response": "Return the required concentration of material in the stock given the system concentration and flow rate."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the amount of time at which the materal will be depleted.", "response": "def T_stock(self, V_stock):\n        \"\"\"Return the amount of time at which the stock of materal will be\n        depleted.\n\n        :param V_stock: Volume of the stock of material\n        :type V_stock: float\n\n        :return: Time at which the stock will be depleted\n        :rtype: float\n        \"\"\"\n        return Stock.T_stock(self, V_stock, self._Q_stock).to(u.hr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the volume of super ( more concentrated ) stock that must be diluted for the desired stock volume and required concentration.", "response": "def V_super_stock(self, V_stock, C_super_stock):\n        \"\"\"Return the volume of super (more concentrated) stock that must be\n        diluted for the desired stock volume and required stock concentration.\n\n        :param V_stock: Volume of the stock of material\n        :type V_stock: float\n        :param C_super_stock: Concentration of the super stock\n        :type C_super_stock: float\n\n        :return: Volume of super stock to dilute\n        :rtype: float\n        \"\"\"\n        return Stock.V_super_stock(self, V_stock, self.C_stock(), C_super_stock)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the required flow rate given a reactor s desired system flow rate system concentration and stock concentration and stock concentration.", "response": "def Q_stock(self):\n        \"\"\"Return the required flow rate from the stock of material given\n        a reactor's desired system flow rate, system concentration, and stock\n        concentration.\n\n        :return: Flow rate from the stock of material\n        :rtype: float\n        \"\"\"\n        return self._Q_sys * (self._C_sys / self._C_stock).to(u.dimensionless)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rpm(self, vol_per_rev):\n        return Stock.rpm(self, vol_per_rev, self.Q_stock()).to(u.rev/u.min)", "response": "Return the pump speed required for the reactor s stock of material\n        given the volume of fluid output per revolution by the stock s pump."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef T_stock(self, V_stock):\n        return Stock.T_stock(self, V_stock, self.Q_stock()).to(u.hr)", "response": "Return the amount of time at which the materal will be depleted."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef V_super_stock(self, V_stock, C_super_stock):\n        return Stock.V_super_stock(self, V_stock, self._C_stock, C_super_stock)", "response": "Returns the volume of super ( more concentrated ) stock that must be\n        diluted for the desired volume and stock concentration."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vel_grad_avg(self):\n        return ((u.standard_gravity * self.HL) /\n               (pc.viscosity_kinematic(self.temp) * self.Gt)).to(u.s ** -1)", "response": "Calculate the average velocity gradient of water flowing\n        through the flocculator."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the minimum flocculator channel width given the minimum H_e and S ratio between expansion height H and baffle spacing S.", "response": "def W_min_HS_ratio(self):\n        \"\"\"Calculate the minimum flocculator channel width, given the minimum\n        ratio between expansion height (H) and baffle spacing (S).\n        :returns: Minimum channel width given H_e/S\n        :rtype: float * centimeter\n        \"\"\"\n        return ((self.HS_RATIO_MIN * self.Q / self.downstream_H) *\n               (self.BAFFLE_K /\n                (2 * self.downstream_H * pc.viscosity_kinematic(self.temp) * self.vel_grad_avg ** 2)) ** (1/3)\n               ).to(u.cm)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef channel_n(self):\n        min_hydraulic_W =\\\n            np.amax(np.array([1, (self.max_W/self.W_min_HS_ratio).to(u.dimensionless)])) * self.W_min_HS_ratio\n        return 2*np.ceil(((self.vol / (min_hydraulic_W * self.downstream_H) +\n                           self.ent_tank_L) / (2 * self.max_L)).to(u.dimensionless))", "response": "Calculates the minimum number of channels based on the maximum possible channel width and the maximum length of the channels."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef channel_L(self):\n        channel_L = ((self.vol / (self.channel_W * self.downstream_H) + self.ent_tank_L) / self.channel_n).to(u.m)\n        return channel_L", "response": "The channel length of the flocculator."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the maximum distance between expansions for the largest allowable H / S ratio.", "response": "def expansion_max_H(self):\n        \"\"\"\"Return the maximum distance between expansions for the largest\n        allowable H/S ratio.\n        :returns: Maximum expansion distance\n        :rtype: float * meter\n        Examples\n        --------\n        exp_dist_max(20*u.L/u.s, 40*u.cm, 37000, 25*u.degC, 2*u.m)\n        0.375 meter\n        \"\"\"\n        return (((self.BAFFLE_K / (2 * pc.viscosity_kinematic(self.temp) * (self.vel_grad_avg ** 2))) *\n                (self.Q * self.RATIO_MAX_HS / self.channel_W) ** 3) ** (1/4)).to(u.m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the spacing between baffles.", "response": "def baffle_S(self):\n        \"\"\"Return the spacing between baffles.\n        :returns: Spacing between baffles\n        :rtype: int\n        \"\"\"\n        return ((self.BAFFLE_K /\n                ((2 * self.expansion_H * (self.vel_grad_avg ** 2) *\n                 pc.viscosity_kinematic(self.temp))).to_base_units()) ** (1/3) *\n               self.Q / self.channel_W).to(u.cm)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef drain_K(self):\n        drain_K = minorloss.PIPE_ENTRANCE_K_MINOR + minorloss.PIPE_ENTRANCE_K_MINOR + minorloss.PIPE_EXIT_K_MINOR\n        return drain_K", "response": "Return the minor loss coefficient of the drain pipe."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drain_D(self):\n        tank_A = 2 * self.channel_L * self.channel_W\n        drain_D = (np.sqrt(8 * tank_A / (np.pi * self.drain_t) * np.sqrt(\n           self.downstream_H * self.drain_K / (2 * u.standard_gravity)))).to_base_units()\n        return drain_D", "response": "Returns depth of drain pipe."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the diameter of the drain pipe.", "response": "def drain_ND(self):\n        \"\"\"Returns the diameter of the drain pipe.\n        Each drain pipe will drain two channels because channels are connected by\n        a port at the far end and the first channel can't have a drain because\n        of the entrance tank. Need to review the design to see if this is a good\n        assumption.\n        D_{Pipe} = \\sqrt{ \\frac{8 A_{Tank}}{\\pi t_{Drain}} \\sqrt{ \\frac{h_0 \\sum K}{2g} } }\n        :returns: list of designed values\n        :rtype: float * centimeter\n        \"\"\"\n        drain_ND = pipes.ND_SDR_available(self.drain_D, self.SDR)\n        return drain_ND"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the designed values.", "response": "def design(self):\n        \"\"\"Returns the designed values.\n        :returns: list of designed values (G, t, channel_W, obstacle_n)\n        :rtype: int\n        \"\"\"\n        floc_dict = {'channel_n': self.channel_n,\n                     'channel_L': self.channel_L,\n                     'channel_W': self.channel_W,\n                     'baffle_S': self.baffle_S,\n                     'obstacle_n': self.obstacle_n,\n                     'G': self.vel_grad_avg,\n                     't': self.retention_time,\n                     'expansion_max_H': self.expansion_max_H,\n                     'drain_ND': self.drain_ND}\n        return floc_dict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndraw the Onshape flocculator model based off of this object.", "response": "def draw(self):\n        \"\"\"Draw the Onshape flocculator model based off of this object.\"\"\"\n        from onshapepy import Part\n        CAD = Part(\n            'https://cad.onshape.com/documents/b4cfd328713460beeb3125ac/w/3928b5c91bb0a0be7858d99e/e/6f2eeada21e494cebb49515f'\n        )\n        CAD.params = {\n            'channel_L': self.channel_L,\n            'channel_W': self.channel_W,\n            'channel_H': self.downstream_H,\n            'channel_pairs': self.channel_n/2,\n            'baffle_S': self.baffle_S,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef viscosity_kinematic_alum(conc_alum, temp):\n    nu = (1 + (4.255 * 10**-6) * conc_alum**2.289) * pc.viscosity_kinematic(temp).magnitude\n    return nu", "response": "Return the dynamic viscosity of water at a given temperature."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef viscosity_kinematic_pacl(conc_pacl, temp):\n    nu = (1 + (2.383 * 10**-5) * conc_pacl**1.893) * pc.viscosity_kinematic(temp).magnitude\n    return nu", "response": "Return the dynamic viscosity of water at a given temperature."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the dynamic viscosity of water at a given temperature.", "response": "def viscosity_kinematic_chem(conc_chem, temp, en_chem):\n     \"\"\"Return the dynamic viscosity of water at a given temperature.\n\n    If given units, the function will automatically convert to Kelvin.\n    If not given units, the function will assume Kelvin.\n    \"\"\"\n     if en_chem == 0:\n         nu = viscosity_kinematic_alum(conc_chem, temp).magnitude\n     if en_chem == 1:\n         nu =  viscosity_kinematic_pacl(conc_chem, temp).magnitude\n     if en_chem not in [0,1]:\n         nu =  pc.viscosity_kinematic(temp).magnitude\n     return nu"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef max_linear_flow(Diam, HeadlossCDC, Ratio_Error, KMinor):\n    flow = (pc.area_circle(Diam)).magnitude * np.sqrt((2 * Ratio_Error * HeadlossCDC * pc.gravity)/ KMinor)\n    return flow.magnitude", "response": "Return the maximum flow that can be put through a tube of a given diameter with a linear head loss."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the length of each tube given the corresponding flow rate and coagulant.", "response": "def _length_cdc_tube_array(FlowPlant, ConcDoseMax, ConcStock,\n                           DiamTubeAvail, HeadlossCDC, temp, en_chem, KMinor):\n    \"\"\"Calculate the length of each diameter tube given the corresponding flow rate\n    and coagulant. Choose the tube that is shorter than the maximum length tube.\"\"\"\n\n    Flow = _flow_cdc_tube(FlowPlant, ConcDoseMax, ConcStock, DiamTubeAvail, HeadlossCDC,Ratio_Error, KMinor).magnitude\n\n\n    return _len_tube(Flow, DiamTubeAvail, HeadlossCDC, ConcStock, temp, en_chem, KMinor).magnitude"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the length of the tubing in the specified order.", "response": "def len_cdc_tube(FlowPlant, ConcDoseMax, ConcStock,\n                 DiamTubeAvail, HeadlossCDC, LenCDCTubeMax, temp,\n                 en_chem, KMinor):\n   \"\"\"The length of tubing may be longer than the max specified if the stock\n   concentration is too high to give a viable solution with the specified\n   length of tubing.\"\"\"\n   index = i_cdc(FlowPlant, ConcDoseMax, ConcStock,\n                DiamTubeAvail, HeadlossCDC, LenCDCTubeMax, temp,\n                en_chem, KMinor)\n   len_cdc_tube = (_length_cdc_tube_array(FlowPlant, ConcDoseMax, ConcStock,\n                                        DiamTubeAvail, HeadlossCDC, temp, en_chem,\n                                        KMinor))[index].magnitude\n\n   return len_cdc_tube"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the density of the aluminum in the nanocluster.", "response": "def dens_alum_nanocluster(coag):\n    \"\"\"Return the density of the aluminum in the nanocluster.\n\n    This is useful for determining the volume of nanoclusters\n    given a concentration of aluminum.\n    \"\"\"\n    density = (coag.PrecipDensity * MOLEC_WEIGHT_ALUMINUM\n               * coag.PrecipAluminumMPM / coag.PrecipMolecWeight)\n    return density"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the density of the PACl solution.", "response": "def dens_pacl_solution(ConcAluminum, temp):\n    \"\"\"Return the density of the PACl solution.\n\n    From Stock Tank Mixing report Fall 2013:\n    https://confluence.cornell.edu/download/attachments/137953883/20131213_Research_Report.pdf\n    \"\"\"\n    return ((0.492 * ConcAluminum * PACl.MolecWeight\n             / (PACl.AluminumMPM * MOLEC_WEIGHT_ALUMINUM)\n             ) + pc.density_water(temp).magnitude\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef particle_number_concentration(ConcMat, material):\n    return ConcMat.to(material.Density.units) / ((material.Density * np.pi * material.Diameter**3) / 6)", "response": "Return the number of particles in the suspension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sep_dist_clay(ConcClay, material):\n    return ((material.Density/ConcClay)*((np.pi\n                            * material.Diameter ** 3)/6))**(1/3)", "response": "Return the separation distance between clay particles."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the number of nanoclusters in a given Aluminum.", "response": "def num_nanoclusters(ConcAluminum, coag):\n    \"\"\"Return the number of Aluminum nanoclusters.\"\"\"\n    return (ConcAluminum / (dens_alum_nanocluster(coag).magnitude\n                            * np.pi * coag.Diameter**3))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef frac_vol_floc_initial(ConcAluminum, ConcClay, coag, material):\n    return ((conc_precipitate(ConcAluminum, coag).magnitude/coag.PrecipDensity)\n            + (ConcClay / material.Density))", "response": "Return the volume fraction of flocs initially present in a single particle system."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the number of doubling collisions required to produce a single doubling .", "response": "def num_coll_reqd(DIM_FRACTAL, material, DiamTarget):\n    \"\"\"Return the number of doubling collisions required.\n\n    Calculates the number of doubling collisions required to produce\n    a floc of diameter DiamTarget.\n    \"\"\"\n    return DIM_FRACTAL * np.log2(DiamTarget/material.Diameter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sep_dist_floc(ConcAluminum, ConcClay, coag, material,\n                  DIM_FRACTAL, DiamTarget):\n    \"\"\"Return separation distance as a function of floc size.\"\"\"\n    return (material.Diameter\n            * (np.pi/(6\n                      * frac_vol_floc_initial(ConcAluminum, ConcClay,\n                                              coag, material)\n                      ))**(1/3)\n            * (DiamTarget / material.Diameter)**(DIM_FRACTAL / 3)\n            )", "response": "Return separation distance as a function of floc size."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the floc volume fraction.", "response": "def frac_vol_floc(ConcAluminum, ConcClay, coag, DIM_FRACTAL,\n                  material, DiamTarget):\n    \"\"\"Return the floc volume fraction.\"\"\"\n    return (frac_vol_floc_initial(ConcAluminum, ConcClay, coag, material)\n            * (DiamTarget / material.Diameter)**(3-DIM_FRACTAL)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dens_floc_init(ConcAluminum, ConcClay, coag, material):\n    return (conc_floc(ConcAluminum, ConcClay, coag).magnitude\n            / frac_vol_floc_initial(ConcAluminum, ConcClay, coag, material)\n            )", "response": "Return the density of the initial floc."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ratio_area_clay_total(ConcClay, material, DiamTube, RatioHeightDiameter):\n    return (1\n            / (1\n               + (2 * material.Diameter\n                  / (3 * DiamTube * ratio_clay_sphere(RatioHeightDiameter)\n                     * (ConcClay / material.Density)\n                     )\n                  )\n               )\n            )", "response": "Calculates the total surface area of clay in suspension with the given concentration and material."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the coverage of a coagulant with the given clay.", "response": "def gamma_coag(ConcClay, ConcAluminum, coag, material,\n               DiamTube, RatioHeightDiameter):\n    \"\"\"Return the coverage of clay with nanoglobs.\n\n    This function accounts for loss to the tube flocculator walls\n    and a poisson distribution on the clay given random hits by the\n    nanoglobs. The poisson distribution results in the coverage only\n    gradually approaching full coverage as coagulant dose increases.\n\n    :param ConcClay: Concentration of clay in suspension\n    :type ConcClay: float\n    :param ConcAluminum: Concentration of aluminum in solution\n    :type ConcAluminum: float\n    :param coag: Type of coagulant in solution, e.g. floc_model.PACl\n    :type coag: floc_model.Material\n    :param material: Type of clay in suspension, e.g. floc_model.Clay\n    :type material: floc_model.Material\n    :param DiamTube: Diameter of flocculator tube (assumes tube flocculator for calculation of reactor surface area)\n    :type DiamTube: float\n    :param RatioHeightDiameter: Dimensionless ratio of clay height to clay diameter\n    :type RatioHeightDiameter: float\n\n    :return: Fraction of the clay surface area that is coated with coagulant precipitates\n    :rtype: float\n    \"\"\"\n    return (1 - np.exp((\n                       (-frac_vol_floc_initial(ConcAluminum, 0*u.kg/u.m**3, coag, material)\n                         * material.Diameter)\n                        / (frac_vol_floc_initial(0*u.kg/u.m**3, ConcClay, coag, material)\n                           * coag.Diameter))\n                       * (1 / np.pi)\n                       * (ratio_area_clay_total(ConcClay, material,\n                                                DiamTube, RatioHeightDiameter)\n                          / ratio_clay_sphere(RatioHeightDiameter))\n                       ))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the fraction of the coagulant that is coated with humic acid.", "response": "def gamma_humic_acid_to_coag(ConcAl, ConcNatOrgMat, NatOrgMat, coag):\n    \"\"\"Return the fraction of the coagulant that is coated with humic acid.\n\n    :param ConcAl: Concentration of alumninum in solution\n    :type ConcAl: float\n    :param ConcNatOrgMat: Concentration of natural organic matter in solution\n    :type ConcNatOrgMat: float\n    :param NatOrgMat: type of natural organic matter, e.g. floc_model.HumicAcid\n    :type NatOrgMat: floc_model.Material\n    :param coag: Type of coagulant in solution, e.g. floc_model.PACl\n    :type coag: floc_model.Material\n\n    :return: fraction of the coagulant that is coated with humic acid\n    :rtype: float\n    \"\"\"\n    return min(((ConcNatOrgMat / conc_precipitate(ConcAl, coag).magnitude)\n                * (coag.Density / NatOrgMat.Density)\n                * (coag.Diameter / (4 * NatOrgMat.Diameter))\n                ),\n               1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pacl_term(DiamTube, ConcClay, ConcAl, ConcNatOrgMat, NatOrgMat,\n               coag, material, RatioHeightDiameter):\n    \"\"\"Return the fraction of the surface area that is covered with coagulant\n    that is not covered with humic acid.\n\n    :param DiamTube: Diameter of the dosing tube\n    :type Diamtube: float\n    :param ConcClay: Concentration of clay in solution\n    :type ConcClay: float\n    :param ConcAl: Concentration of alumninum in solution\n    :type ConcAl: float\n    :param ConcNatOrgMat: Concentration of natural organic matter in solution\n    :type ConcNatOrgMat: float\n    :param NatOrgMat: type of natural organic matter, e.g. floc_model.HumicAcid\n    :type NatOrgMat: floc_model.Material\n    :param coag: Type of coagulant in solution, e.g. floc_model.PACl\n    :type coag: floc_model.Material\n    :param material: Type of clay in suspension, e.g. floc_model.Clay\n    :type material: floc_model.Material\n    :param RatioHeightDiameter: Dimensionless ratio of clay height to clay diameter\n    :type RatioHeightDiameter: float\n\n    :return: fraction of the surface area that is covered with coagulant that is not covered with humic acid\n    :rtype: float\n    \"\"\"\n    return (gamma_coag(ConcClay, ConcAl, coag, material, DiamTube,\n                       RatioHeightDiameter)\n            * (1 - gamma_humic_acid_to_coag(ConcAl, ConcNatOrgMat,\n                                            NatOrgMat, coag))\n            )", "response": "Returns the fraction of the coagulant that is not covered with humic acid."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating floc density as a function of size.", "response": "def dens_floc(ConcAl, ConcClay, DIM_FRACTAL, DiamTarget, coag, material, Temp):\n    \"\"\"Calculate floc density as a function of size.\"\"\"\n    WaterDensity = pc.density_water(Temp).magnitude\n    return ((dens_floc_init(ConcAl, ConcClay, coag, material).magnitude\n             - WaterDensity\n             )\n            * (material.Diameter / DiamTarget)**(3 - DIM_FRACTAL)\n            + WaterDensity\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef vel_term_floc(ConcAl, ConcClay, coag, material, DIM_FRACTAL,\n                  DiamTarget, Temp):\n    \"\"\"Calculate floc terminal velocity.\"\"\"\n    WaterDensity = pc.density_water(Temp).magnitude\n    return (((pc.gravity.magnitude * material.Diameter**2)\n             / (18 * PHI_FLOC * pc.viscosity_kinematic(Temp).magnitude)\n             )\n            * ((dens_floc_init(ConcAl, ConcClay, coag, material).magnitude\n                - WaterDensity\n                )\n               / WaterDensity\n               )\n            * (DiamTarget / material.Diameter) ** (DIM_FRACTAL - 1)\n            )", "response": "Calculate floc terminal velocity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef diam_floc_vel_term(ConcAl, ConcClay, coag, material,\n                       DIM_FRACTAL, VelTerm, Temp):\n    \"\"\"Calculate floc diamter as a function of terminal velocity.\"\"\"\n    WaterDensity = pc.density_water(Temp).magnitude\n    return (material.Diameter * (((18 * VelTerm * PHI_FLOC\n                          * pc.viscosity_kinematic(Temp).magnitude\n                          )\n                         / (pc.gravity.magnitude * material.Diameter**2)\n                         )\n                         * (WaterDensity\n                            / (dens_floc_init(ConcAl, ConcClay, coag,\n                                              material).magnitude\n                               - WaterDensity\n                               )\n                            )\n                        ) ** (1 / (DIM_FRACTAL - 1))\n            )", "response": "Calculate floc diamter as a function of terminal velocity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time_col_laminar(EnergyDis, Temp, ConcAl, ConcClay, coag, material,\n                     DiamTarget, DiamTube, DIM_FRACTAL, RatioHeightDiameter):\n    \"\"\"Calculate single collision time for laminar flow mediated collisions.\n\n    Calculated as a function of floc size.\n    \"\"\"\n    return (((1/6) * ((6/np.pi)**(1/3))\n             * frac_vol_floc_initial(ConcAl, ConcClay, coag, material) ** (-2/3)\n             * (pc.viscosity_kinematic(Temp).magnitude / EnergyDis) ** (1 / 2)\n             * (DiamTarget / material.Diameter) ** (2*DIM_FRACTAL/3 - 2)\n             )  # End of the numerator\n            / (gamma_coag(ConcClay, ConcAl, coag, material, DiamTube,\n                          RatioHeightDiameter)\n               )  # End of the denominator\n            )", "response": "Calculate single collision time for laminar flow mediated collisions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates single collision time for turbulent flow mediated collisions.", "response": "def time_col_turbulent(EnergyDis, ConcAl, ConcClay, coag, material,\n                       DiamTarget, DIM_FRACTAL):\n    \"\"\"Calculate single collision time for turbulent flow mediated collisions.\n\n    Calculated as a function of floc size.\n    \"\"\"\n    return((1/6) * (6/np.pi)**(1/9) * EnergyDis**(-1/3) * DiamTarget**(2/3)\n           * frac_vol_floc_initial(ConcAl, ConcClay, coag, material)**(-8/9)\n           * (DiamTarget / material.Diameter)**((8*(DIM_FRACTAL-3)) / 9)\n           )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the total diam of the Kolmogorov.", "response": "def diam_kolmogorov(EnergyDis, Temp, ConcAl, ConcClay, coag, material,\n                    DIM_FRACTAL):\n    \"\"\"Return the size of the floc with separation distances equal to\n    the Kolmogorov length and the inner viscous length scale.\n    \"\"\"\n    return (material.Diameter\n            * ((eta_kolmogorov(EnergyDis, Temp).magnitude / material.Diameter)\n               * ((6 * frac_vol_floc_initial(ConcAl, ConcClay, coag, material))\n                  / np.pi\n                  )**(1/3)\n               )**(3 / DIM_FRACTAL)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the Dean Number.", "response": "def dean_number(PlantFlow, IDTube, RadiusCoil, Temp):\n    \"\"\"Return the Dean Number.\n\n    The Dean Number is a dimensionless parameter that is the unfortunate\n    combination of Reynolds and tube curvature. It would have been better\n    to keep the Reynolds number and define a simple dimensionless geometric\n    parameter.\n    \"\"\"\n    return (reynolds_rapid_mix(PlantFlow, IDTube, Temp)\n            * (IDTube / (2 * RadiusCoil))**(1/2)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the coil of a given coil.", "response": "def g_coil(FlowPlant, IDTube, RadiusCoil, Temp):\n    \"\"\"We need a reference for this.\n\n    Karen's thesis likely has this equation and the reference.\n    \"\"\"\n    return (g_straight(FlowPlant, IDTube).magnitude\n            * (1 + 0.033 *\n                np.log10(dean_number(FlowPlant, IDTube, RadiusCoil, Temp)\n                        ) ** 4\n               ) ** (1/2)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the G Residence Time for a coiled tube flocculator.", "response": "def g_time_res(FlowPlant, IDTube, RadiusCoil, LengthTube, Temp):\n    \"\"\"G Residence Time calculated for a coiled tube flocculator.\"\"\"\n    return (g_coil(FlowPlant, IDTube, RadiusCoil, Temp).magnitude\n            * time_res_tube(IDTube, LengthTube, FlowPlant).magnitude\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef define_Precip(self, diameter, density, molecweight, alumMPM):\n        self.PrecipDiameter = diameter\n        self.PrecipDensity = density\n        self.PrecipMolecWeight = molecweight\n        self.PrecipAluminumMPM = alumMPM", "response": "Define a precipitate for the chemical."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ent_tank_a(self):\n        # first guess planview area\n        a_new = 1 * u.m**2\n        a_ratio = 2  # set to >1+tolerance to start while loop\n        tolerance = 0.01\n        a_floc_pv = (\n            self.floc.vol /\n            (self.floc.downstream_H + (self.floc.HL / 2))\n        )\n        while a_ratio > (1 + tolerance):\n            a_et_pv = a_new\n            a_etf_pv = a_et_pv + a_floc_pv\n            w_tot = a_etf_pv / self.floc.max_L\n            w_chan = w_tot / self.floc.channel_n\n\n            a_new = self.floc.max_L * w_chan\n            a_ratio = a_new / a_et_pv\n        return a_new", "response": "Calculate the planview area of the entrance tank given the volume of the flocculator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef area_lfom_orifices_top(FLOW,HL_LFOM):\n    return ((FLOW*width_stout(HL_LFOM*u.m,HL_LFOM*u.m-0.5*dist_center_lfom_rows(FLOW,HL_LFOM)).magnitude *\n        dist_center_lfom_rows(FLOW,HL_LFOM).magnitude))", "response": "Estimate the area of the top row of orifices."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef n_lfom_orifices_per_row_max(FLOW,HL_LFOM,drill_bits):\n    return math.floor(math.pi * (pipe.ID_SDR(\n        nom_diam_lfom_pipe(FLOW, HL_LFOM), design.lfom.SDR_LFOM).magnitude)\n                      / (orifice_diameter(FLOW, HL_LFOM, drill_bits).magnitude +\n                         aguaclara.design.lfom.ORIFICE_S.magnitude))", "response": "A bound on the number of orifices allowed in each row."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef height_lfom_orifices(FLOW,HL_LFOM,drill_bits):\n    return (np.arange((orifice_diameter(FLOW,HL_LFOM,drill_bits)*0.5),\n                      HL_LFOM,\n                      (dist_center_lfom_rows(FLOW,HL_LFOM))))", "response": "Calculates the height of the center of each row of orifices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the flow for a given number of submerged rows of orifices HL_LFOM and drill_bits.", "response": "def flow_lfom_actual(FLOW,HL_LFOM,drill_bits,Row_Index_Submerged,N_LFOM_Orifices):\n    \"\"\"Calculates the flow for a given number of submerged rows of orifices\n    harray is the distance from the water level to the center of the orifices\n    when the water is at the max level\n    \"\"\"\n    D_LFOM_Orifices=orifice_diameter(FLOW, HL_LFOM, drill_bits).magnitude\n    row_height=dist_center_lfom_rows(FLOW, HL_LFOM).magnitude\n    harray = (np.linspace(row_height, HL_LFOM, n_lfom_rows(FLOW, HL_LFOM))) - 0.5 * D_LFOM_Orifices\n    FLOW_new = 0\n    for i in range(Row_Index_Submerged+1):\n        FLOW_new = FLOW_new + (N_LFOM_Orifices[i] * (\n            pc.flow_orifice_vert(D_LFOM_Orifices, harray[Row_Index_Submerged-i],\n                                 con.VC_ORIFICE_RATIO).magnitude))\n    return FLOW_new"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef round_sf(number, digits):\n    units = None\n    try:\n        num = number.magnitude\n        units = number.units\n    except AttributeError:\n        num = number\n\n    try:\n        if (units != None):\n            rounded_num = round(num, digits - int(floor(log10(abs(num)))) - 1) * units\n        else:\n            rounded_num = round(num, digits - int(floor(log10(abs(num)))) - 1)\n        return rounded_num\n    except ValueError:  # Prevents an error with log10(0)\n        if (units != None):\n            return 0 * units\n        else:\n            return 0", "response": "Returns inputted value rounded to number of significant figures desired."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stepceil_with_units(param, step, unit):\n    counter = 0 * unit\n    while counter < param.to(unit):\n        counter += step * unit\n    return counter", "response": "This function returns the smallest multiple of step greater than param greater than or\n    equal to unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps a function to handle list inputs.", "response": "def list_handler(HandlerResult=\"nparray\"):\n    \"\"\"Wraps a function to handle list inputs.\"\"\"\n    def decorate(func):\n        def wrapper(*args, **kwargs):\n            \"\"\"Run through the wrapped function once for each array element.\n\n            :param HandlerResult: output type. Defaults to numpy arrays.\n            \"\"\"\n            sequences = []\n            enumsUnitCheck = enumerate(args)\n            argsList = list(args)\n            #This for loop identifies pint unit objects and strips them\n            #of their units.\n            for num, arg in enumsUnitCheck:\n                if type(arg) == type(1 * u.m):\n                    argsList[num] = arg.to_base_units().magnitude\n            enumsUnitless = enumerate(argsList)\n            #This for loop identifies arguments that are sequences and\n            #adds their index location to the list 'sequences'.\n            for num, arg in enumsUnitless:\n                if isinstance(arg, (list, tuple, np.ndarray)):\n                    sequences.append(num)\n            #If there are no sequences to iterate through, simply return\n            #the function.\n            if len(sequences) == 0:\n                result = func(*args, **kwargs)\n            else:\n                #iterant keeps track of how many times we've iterated and\n                #limiter stops the loop once we've iterated as many times\n                #as there are list elements. Without this check, a few\n                #erroneous runs will occur, appending the last couple values\n                #to the end of the list multiple times.\n                #\n                #We only care about the length of sequences[0] because this\n                #function is recursive, and sequences[0] is always the relevant\n                #sequences for any given run.\n                limiter = len(argsList[sequences[0]])\n                iterant = 0\n                result = []\n                for num in sequences:\n                    for arg in argsList[num]:\n                        if iterant >= limiter:\n                            break\n                        #We can safely replace the entire list argument\n                        #with a single element from it because of the looping\n                        #we're doing. We redefine the object, but that\n                        #definition remains within this namespace and does\n                        #not penetrate further up the function.\n                        argsList[num] = arg\n                        #Here we dive down the rabbit hole. This ends up\n                        #creating a multi-dimensional array shaped by the\n                        #sizes and shapes of the lists passed.\n                        result.append(wrapper(*argsList,\n                                              HandlerResult=HandlerResult, **kwargs))\n                        iterant += 1\n                #HandlerResult allows the user to specify what type to\n                #return the generated sequence as. It defaults to numpy\n                #arrays because functions tend to handle them better, but if\n                #the user does not wish to import numpy the base Python options\n                #are available to them.\n                if HandlerResult == \"nparray\":\n                    result = np.array(result)\n                elif HandlerResult == \"tuple\":\n                    result = tuple(result)\n                elif HandlerResult == \"list\":\n                    result == list(result)\n            return result\n        return wrapper\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether passed parameter values fall within approved ranges.", "response": "def check_range(*args):\n    \"\"\"\n    Check whether passed paramters fall within approved ranges.\n\n    Does not return anything, but will raise an error if a parameter falls\n    outside of its defined range.\n\n    Input should be passed as an array of sequences, with each sequence\n    having three elements:\n        [0] is the value being checked,\n        [1] is the range parameter(s) within which the value should fall, and\n        [2] is the name of the parameter, for better error messages.\n    If [2] is not supplied, \"Input\" will be appended as a generic name.\n\n    Range requests that this function understands are listed in the\n    knownChecks sequence.\n    \"\"\"\n    knownChecks = ('>0', '>=0', '0-1', '<0', '<=0', 'int', 'boolean')\n    for arg in args:\n        #Converts arg to a mutable list\n        arg = [*arg]\n        if len(arg) == 1:\n            #arg[1] details what range the parameter should fall within; if\n            #len(arg) is 1 that means a validity was not specified and the\n            #parameter should not have been passed in its current form\n            raise TypeError(\"No range-validity parameter provided.\")\n        elif len(arg) == 2:\n            #Appending 'Input\" to the end allows us to give more descriptive\n            #error messages that do not fail if no description was supplied.\n            arg.append(\"Input\")\n        #This ensures that all whitespace is removed before checking if the\n        #request is understood\n        arg[1] = \"\".join(arg[1].lower().split())\n        #This block checks that each range request is understood.\n        #If the request is a compound one, it must be separated into individual\n        #requests for validity comprehension\n        for i in arg[1].split(\",\"):\n            if i not in knownChecks:\n                raise RuntimeError(\"Unknown parameter validation \"\n                                       \"request: {0}.\".format(i))\n        if not isinstance(arg[0], (list, tuple, np.ndarray)):\n            arg[0] = [arg[0]]\n        for i in arg[0]:\n            if '>0' in arg[1] and i <= 0:\n                raise ValueError(\"{1} is {0} but must be greater than \"\n                                 \"0.\".format(i, arg[2]))\n            if '>=0' in arg[1] and i <0:\n                raise ValueError(\"{1} is {0} but must be 0 or \"\n                                 \"greater.\".format(i, arg[2]))\n            if '0-1' in arg[1] and not 0 <= i <= 1:\n                raise ValueError(\"{1} is {0} but must be between 0 and \"\n                                 \"1.\".format(i, arg[2]))\n            if '<0' in arg[1] and i >= 0:\n                raise ValueError(\"{1} is {0} but must be less than \"\n                                 \"0.\".format(i, arg[2]))\n            if '<=0' in arg[1] and i >0:\n                raise ValueError(\"{1} is {0} but must be 0 or \"\n                                 \"less.\".format(i, arg[2]))\n            if 'int' in arg[1] and int(i) != i:\n                raise TypeError(\"{1} is {0} but must be a numeric \"\n                                \"integer.\".format(i, arg[2]))\n            if 'boolean' in arg[1] and type(i) != bool:\n                raise TypeError(\"{1} is {0} but must be a \"\n                                \"boolean.\".format(i, arg[2]))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Performs clustering from the command-line. Calls JVM start/stop automatically.')\n    parser.add_argument(\"-j\", metavar=\"classpath\", dest=\"classpath\", help=\"additional classpath, jars/directories\")\n    parser.add_argument(\"-X\", metavar=\"heap\", dest=\"heap\", help=\"max heap size for jvm, e.g., 512m\")\n    parser.add_argument(\"-t\", metavar=\"train\", dest=\"train\", required=True, help=\"training set file\")\n    parser.add_argument(\"-T\", metavar=\"test\", dest=\"test\", help=\"test set file\")\n    parser.add_argument(\"-d\", metavar=\"outmodel\", dest=\"outmodel\", help=\"model output file name\")\n    parser.add_argument(\"-l\", metavar=\"inmodel\", dest=\"inmodel\", help=\"model input file name\")\n    parser.add_argument(\"-p\", metavar=\"attributes\", dest=\"attributes\", help=\"attribute range\")\n    parser.add_argument(\"-x\", metavar=\"num folds\", dest=\"numfolds\", help=\"number of folds\")\n    parser.add_argument(\"-s\", metavar=\"seed\", dest=\"seed\", help=\"seed value for randomization\")\n    parser.add_argument(\"-c\", metavar=\"class index\", dest=\"classindex\", help=\"1-based class attribute index\")\n    parser.add_argument(\"-g\", metavar=\"graph\", dest=\"graph\", help=\"graph output file (if supported)\")\n    parser.add_argument(\"clusterer\", help=\"clusterer classname, e.g., weka.clusterers.SimpleKMeans\")\n    parser.add_argument(\"option\", nargs=argparse.REMAINDER, help=\"additional clusterer options\")\n    parsed = parser.parse_args()\n    jars = []\n    if parsed.classpath is not None:\n        jars = parsed.classpath.split(os.pathsep)\n    params = []\n    if parsed.train is not None:\n        params.extend([\"-t\", parsed.train])\n    if parsed.test is not None:\n        params.extend([\"-T\", parsed.test])\n    if parsed.outmodel is not None:\n        params.extend([\"-d\", parsed.outmodel])\n    if parsed.inmodel is not None:\n        params.extend([\"-l\", parsed.inmodel])\n    if parsed.attributes is not None:\n        params.extend([\"-p\", parsed.attributes])\n    if parsed.numfolds is not None:\n        params.extend([\"-x\", parsed.numfolds])\n    if parsed.seed is not None:\n        params.extend([\"-s\", parsed.seed])\n    if parsed.classindex is not None:\n        params.extend([\"-c\", parsed.classindex])\n    if parsed.graph is not None:\n        params.extend([\"-g\", parsed.graph])\n\n    jvm.start(jars, max_heap_size=parsed.heap, packages=True)\n\n    logger.debug(\"Commandline: \" + join_options(sys.argv[1:]))\n\n    try:\n        clusterer = Clusterer(classname=parsed.clusterer)\n        if len(parsed.option) > 0:\n            clusterer.options = parsed.option\n        print(ClusterEvaluation.evaluate_clusterer(clusterer, params))\n    except Exception as e:\n        print(e)\n    finally:\n        jvm.stop()", "response": "Main function for the clusterer command line tool."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_clusterer(self, inst):\n        if self.is_updateable:\n            javabridge.call(self.jobject, \"updateClusterer\", \"(Lweka/core/Instance;)V\", inst.jobject)\n        else:\n            logger.critical(classes.get_classname(self.jobject) + \" is not updateable!\")", "response": "Updates the clusterer with the instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsignal the clusterer that updating with new data has finished.", "response": "def update_finished(self):\n        \"\"\"\n        Signals the clusterer that updating with new data has finished.\n        \"\"\"\n        if self.is_updateable:\n            javabridge.call(self.jobject, \"updateFinished\", \"()V\")\n        else:\n            logger.critical(classes.get_classname(self.jobject) + \" is not updateable!\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef distribution_for_instance(self, inst):\n        pred = self.__distribution(inst.jobject)\n        return javabridge.get_env().get_double_array_elements(pred)", "response": "Peforms a prediction returning the cluster distribution for the given Instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cluster_assignments(self):\n        array = javabridge.call(self.jobject, \"getClusterAssignments\", \"()[D\")\n        if array is None:\n            return None\n        else:\n            return javabridge.get_env().get_double_array_elements(array)", "response": "Returns an array of cluster assignments corresponding to the most recent set of instances clustered."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef classes_to_clusters(self):\n        array = javabridge.call(self.jobject, \"getClassesToClusters\", \"()[I\")\n        if array is None:\n            return None\n        else:\n            return javabridge.get_env().get_int_array_elements(array)", "response": "Returns the array of minimum error class to cluster mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crossvalidate_model(cls, clusterer, data, num_folds, rnd):\n        return javabridge.static_call(\n            \"Lweka/clusterers/ClusterEvaluation;\", \"crossValidateModel\",\n            \"(Lweka/clusterers/DensityBasedClusterer;Lweka/core/Instances;ILjava/util/Random;)D\",\n            clusterer.jobject, data.jobject, num_folds, rnd.jobject)", "response": "Cross - validates the clusterer and returns the loglikelihood."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deepcopy(obj):\n    if isinstance(obj, JavaObject):\n        wrapped = True\n        jobject = obj.jobject\n    else:\n        wrapped = False\n        jobject = obj\n    try:\n        serialized = javabridge.make_instance(\"weka/core/SerializedObject\", \"(Ljava/lang/Object;)V\", jobject)\n        jcopy = javabridge.call(serialized, \"getObject\", \"()Ljava/lang/Object;\")\n        if wrapped:\n            jcopy = obj.__class__(jobject=jcopy)\n        return jcopy\n    except JavaException as e:\n        print(\"Failed to create copy of \" + classes.get_classname(obj) + \": \" + str(e))\n        return None", "response": "Creates a deep copy of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the serialized objects from disk.", "response": "def read_all(filename):\n    \"\"\"\n    Reads the serialized objects from disk. Caller must wrap objects in appropriate Python wrapper classes.\n\n    :param filename: the file with the serialized objects\n    :type filename: str\n    :return: the list of JB_OBjects\n    :rtype: list\n    \"\"\"\n    array = javabridge.static_call(\n        \"Lweka/core/SerializationHelper;\", \"readAll\",\n        \"(Ljava/lang/String;)[Ljava/lang/Object;\",\n        filename)\n    if array is None:\n        return None\n    else:\n        return javabridge.get_env().get_object_array_elements(array)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write(filename, jobject):\n    if isinstance(jobject, JavaObject):\n        jobject = jobject.jobject\n    javabridge.static_call(\n        \"Lweka/core/SerializationHelper;\", \"write\",\n        \"(Ljava/lang/String;Ljava/lang/Object;)V\",\n        filename, jobject)", "response": "Writes the object to disk."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decrease_frequency(self, frequency=None):\n        if frequency is None:\n            javabridge.call(self.jobject, \"decreaseFrequency\", \"()V\")\n        else:\n            javabridge.call(self.jobject, \"decreaseFrequency\", \"(I)V\", frequency)", "response": "Decreases the frequency of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nincrease the frequency. :param frequency: the frequency to increase by, 1 if None :type frequency: int", "response": "def increase_frequency(self, frequency=None):\n        \"\"\"\n        Increases the frequency.\n\n        :param frequency: the frequency to increase by, 1 if None\n        :type frequency: int\n        \"\"\"\n        if frequency is None:\n            javabridge.call(self.jobject, \"increaseFrequency\", \"()V\")\n        else:\n            javabridge.call(self.jobject, \"increaseFrequency\", \"(I)V\", frequency)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef consequence(self):\n        items = javabridge.get_collection_wrapper(\n            javabridge.call(self.jobject, \"getConsequence\", \"()Ljava/util/Collection;\"))\n        result = []\n        for item in items:\n            result.append(Item(item))\n        return result", "response": "Get the the consequence.\n\n        :return: the consequence, list of Item objects\n        :rtype: list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether association rules can be generated.", "response": "def can_produce_rules(self):\n        \"\"\"\n        Checks whether association rules can be generated.\n\n        :return: whether scheme implements AssociationRulesProducer interface and\n        association rules can be generated\n        :rtype: bool\n        \"\"\"\n        if not self.check_type(self.jobject, \"weka.associations.AssociationRulesProducer\"):\n            return False\n        return javabridge.call(self.jobject, \"canProduceRules\", \"()Z\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the association rules that were generated. Only if implements AssociationRulesProducer.", "response": "def association_rules(self):\n        \"\"\"\n        Returns association rules that were generated. Only if implements AssociationRulesProducer.\n\n        :return: the association rules that were generated\n        :rtype: AssociationRules\n        \"\"\"\n        if not self.check_type(self.jobject, \"weka.associations.AssociationRulesProducer\"):\n            return None\n        return AssociationRules(\n            javabridge.call(self.jobject, \"getAssociationRules\", \"()Lweka/associations/AssociationRules;\"))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the rule metric names of the association rules. Only if implements AssociationRulesProducer.", "response": "def rule_metric_names(self):\n        \"\"\"\n        Returns the rule metric names of the association rules. Only if implements AssociationRulesProducer.\n\n        :return: the metric names\n        :rtype: list\n        \"\"\"\n        if not self.check_type(self.jobject, \"weka.associations.AssociationRulesProducer\"):\n            return None\n        return string_array_to_list(\n            javabridge.call(self.jobject, \"getRuleMetricNames\", \"()[Ljava/lang/String;\"))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Loader that can load the specified file.", "response": "def loader_for_file(filename):\n    \"\"\"\n    Returns a Loader that can load the specified file, based on the file extension. None if failed to determine.\n\n    :param filename: the filename to get the loader for\n    :type filename: str\n    :return: the assoicated loader instance or None if none found\n    :rtype: Loader\n    \"\"\"\n    loader = javabridge.static_call(\n        \"weka/core/converters/ConverterUtils\", \"getLoaderForFile\",\n        \"(Ljava/lang/String;)Lweka/core/converters/AbstractFileLoader;\", filename)\n    if loader is None:\n        return None\n    else:\n        return Loader(jobject=loader)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef saver_for_file(filename):\n    saver = javabridge.static_call(\n        \"weka/core/converters/ConverterUtils\", \"getSaverForFile\",\n        \"(Ljava/lang/String;)Lweka/core/converters/AbstractFileSaver;\", filename)\n    if saver is None:\n        return None\n    else:\n        return Saver(jobject=saver)", "response": "Returns a Saver that can load the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the data to the file specified by filename. Returns whether successfully saved.", "response": "def save_any_file(data, filename):\n    \"\"\"\n    Determines a Saver based on the the file extension. Returns whether successfully saved.\n\n    :param filename: the name of the file to save\n    :type filename: str\n    :param data: the data to save\n    :type data: Instances\n    :return: whether successfully saved\n    :rtype: bool\n    \"\"\"\n    saver = saver_for_file(filename)\n    if saver is None:\n        return False\n    else:\n        saver.save_file(data, filename)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ndarray_to_instances(array, relation, att_template=\"Att-#\", att_list=None):\n    if len(numpy.shape(array)) != 2:\n        raise Exception(\"Number of array dimensions must be 2!\")\n    rows, cols = numpy.shape(array)\n\n    # header\n    atts = []\n    if att_list is not None:\n        if len(att_list) != cols:\n            raise Exception(\n                \"Number columns and provided attribute names differ: \" + str(cols) + \" != \" + len(att_list))\n        for name in att_list:\n            att = Attribute.create_numeric(name)\n            atts.append(att)\n    else:\n        for i in range(cols):\n            name = att_template.replace(\"#\", str(i+1)).replace(\"!\", str(i)).replace(\"@\", relation)\n            att = Attribute.create_numeric(name)\n            atts.append(att)\n    result = Instances.create_instances(relation, atts, rows)\n\n    # data\n    for i in range(rows):\n        inst = Instance.create_instance(array[i])\n        result.add_instance(inst)\n\n    return result", "response": "Converts the numpy array into an Instances object and returns it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the specified file and returns the Instances object.", "response": "def load_file(self, dfile, incremental=False):\n        \"\"\"\n        Loads the specified file and returns the Instances object.\n        In case of incremental loading, only the structure.\n\n        :param dfile: the file to load\n        :type dfile: str\n        :param incremental: whether to load the dataset incrementally\n        :type incremental: bool\n        :return: the full dataset or the header (if incremental)\n        :rtype: Instances\n        :raises Exception: if the file does not exist\n        \"\"\"\n        self.enforce_type(self.jobject, \"weka.core.converters.FileSourcedConverter\")\n        self.incremental = incremental\n        if not javabridge.is_instance_of(dfile, \"Ljava/io/File;\"):\n            dfile = javabridge.make_instance(\n                \"Ljava/io/File;\", \"(Ljava/lang/String;)V\", javabridge.get_env().new_string_utf(str(dfile)))\n        javabridge.call(self.jobject, \"reset\", \"()V\")\n        # check whether file exists, otherwise previously set file gets loaded again\n        sfile = javabridge.to_string(dfile)\n        if not os.path.exists(sfile):\n            raise Exception(\"Dataset file does not exist: \" + str(sfile))\n        javabridge.call(self.jobject, \"setFile\", \"(Ljava/io/File;)V\", dfile)\n        if incremental:\n            self.structure = Instances(javabridge.call(self.jobject, \"getStructure\", \"()Lweka/core/Instances;\"))\n            return self.structure\n        else:\n            return Instances(javabridge.call(self.jobject, \"getDataSet\", \"()Lweka/core/Instances;\"))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the specified URL and returns the Instances object.", "response": "def load_url(self, url, incremental=False):\n        \"\"\"\n        Loads the specified URL and returns the Instances object.\n        In case of incremental loading, only the structure.\n\n        :param url: the URL to load the data from\n        :type url: str\n        :param incremental: whether to load the dataset incrementally\n        :type incremental: bool\n        :return: the full dataset or the header (if incremental)\n        :rtype: Instances\n        \"\"\"\n        self.enforce_type(self.jobject, \"weka.core.converters.URLSourcedLoader\")\n        self.incremental = incremental\n        javabridge.call(self.jobject, \"reset\", \"()V\")\n        javabridge.call(self.jobject, \"setURL\", \"(Ljava/lang/String;)V\", str(url))\n        if incremental:\n            self.structure = Instances(javabridge.call(self.jobject, \"getStructure\", \"()Lweka/core/Instances;\"))\n            return self.structure\n        else:\n            return Instances(javabridge.call(self.jobject, \"getDataSet\", \"()Lweka/core/Instances;\"))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the Instances object from the specified directory and returns the Instances object.", "response": "def load(self):\n        \"\"\"\n        Loads the text files from the specified directory and returns the Instances object.\n        In case of incremental loading, only the structure.\n\n        :return: the full dataset or the header (if incremental)\n        :rtype: Instances\n        \"\"\"\n        javabridge.call(self.jobject, \"reset\", \"()V\")\n        return Instances(javabridge.call(self.jobject, \"getDataSet\", \"()Lweka/core/Instances;\"))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave the Instances object in the specified file.", "response": "def save_file(self, data, dfile):\n        \"\"\"\n        Saves the Instances object in the specified file.\n\n        :param data: the data to save\n        :type data: Instances\n        :param dfile: the file to save the data to\n        :type dfile: str\n        \"\"\"\n        self.enforce_type(self.jobject, \"weka.core.converters.FileSourcedConverter\")\n        if not javabridge.is_instance_of(dfile, \"Ljava/io/File;\"):\n            dfile = javabridge.make_instance(\n                \"Ljava/io/File;\", \"(Ljava/lang/String;)V\", javabridge.get_env().new_string_utf(str(dfile)))\n        javabridge.call(self.jobject, \"setFile\", \"(Ljava/io/File;)V\", dfile)\n        javabridge.call(self.jobject, \"setInstances\", \"(Lweka/core/Instances;)V\", data.jobject)\n        javabridge.call(self.jobject, \"writeBatch\", \"()V\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef string_array_to_list(a):\n    result = []\n    length = javabridge.get_env().get_array_length(a)\n    wrapped = javabridge.get_env().get_object_array_elements(a)\n    for i in range(length):\n        result.append(javabridge.get_env().get_string(wrapped[i]))\n    return result", "response": "Converts the Java string array into Python unicode string list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef string_list_to_array(l):\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "response": "Turns a Python unicode string list into a Java String array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the Java matrix of doubles into a Numpy array.", "response": "def double_matrix_to_ndarray(m):\n    \"\"\"\n    Turns the Java matrix (2-dim array) of doubles into a numpy 2-dim array.\n\n    :param m: the double matrix\n    :type: JB_Object\n    :return: Numpy array\n    :rtype: numpy.darray\n    \"\"\"\n    rows = javabridge.get_env().get_object_array_elements(m)\n    num_rows = len(rows)\n    num_cols = javabridge.get_env().get_array_length(rows[0])\n    result = numpy.zeros(num_rows * num_cols).reshape((num_rows, num_cols))\n    i = 0\n    for row in rows:\n        elements = javabridge.get_env().get_double_array_elements(row)\n        n = 0\n        for element in elements:\n            result[i][n] = element\n            n += 1\n        i += 1\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the java. util. Enumeration into a list.", "response": "def enumeration_to_list(enm):\n    \"\"\"\n    Turns the java.util.Enumeration into a list.\n\n    :param enm: the enumeration to convert\n    :type enm: JB_Object\n    :return: the list\n    :rtype: list\n    \"\"\"\n    result = []\n    while javabridge.call(enm, \"hasMoreElements\", \"()Z\"):\n        result.append(javabridge.call(enm, \"nextElement\", \"()Ljava/lang/Object;\"))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning attribute selection from the command-line. Calls JVM start/stop automatically. Use -h to see all options.", "response": "def main():\n    \"\"\"\n    Runs attribute selection from the command-line. Calls JVM start/stop automatically.\n    Use -h to see all options.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Performs attribute selection from the command-line. Calls JVM start/stop automatically.')\n    parser.add_argument(\"-j\", metavar=\"classpath\", dest=\"classpath\", help=\"additional classpath, jars/directories\")\n    parser.add_argument(\"-X\", metavar=\"heap\", dest=\"heap\", help=\"max heap size for jvm, e.g., 512m\")\n    parser.add_argument(\"-i\", metavar=\"input\", dest=\"input\", required=True, help=\"input file\")\n    parser.add_argument(\"-c\", metavar=\"class index\", dest=\"classindex\", help=\"1-based class attribute index\")\n    parser.add_argument(\"-s\", metavar=\"search\", dest=\"search\", help=\"search method, classname and options\")\n    parser.add_argument(\"-x\", metavar=\"num folds\", dest=\"numfolds\", help=\"number of folds\")\n    parser.add_argument(\"-n\", metavar=\"seed\", dest=\"seed\", help=\"the seed value for randomization\")\n    parser.add_argument(\"evaluator\", help=\"evaluator classname, e.g., weka.attributeSelection.CfsSubsetEval\")\n    parser.add_argument(\"option\", nargs=argparse.REMAINDER, help=\"additional evaluator options\")\n    parsed = parser.parse_args()\n    jars = []\n    if parsed.classpath is not None:\n        jars = parsed.classpath.split(os.pathsep)\n    params = []\n    if parsed.input is not None:\n        params.extend([\"-i\", parsed.input])\n    if parsed.classindex is not None:\n        params.extend([\"-c\", parsed.classindex])\n    if parsed.search is not None:\n        params.extend([\"-s\", parsed.search])\n    if parsed.numfolds is not None:\n        params.extend([\"-x\", parsed.numfolds])\n    if parsed.seed is not None:\n        params.extend([\"-n\", parsed.seed])\n\n    jvm.start(jars, max_heap_size=parsed.heap, packages=True)\n\n    logger.debug(\"Commandline: \" + join_options(sys.argv[1:]))\n\n    try:\n        evaluation = ASEvaluation(classname=parsed.evaluator)\n        if len(parsed.option) > 0:\n            evaluation.options = parsed.option\n        print(AttributeSelection.attribute_selection(evaluation, params))\n    except Exception as e:\n        print(e)\n    finally:\n        jvm.stop()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search(self, evaluation, data):\n        array = javabridge.call(\n            self.jobject, \"search\", \"(Lweka/attributeSelection/ASEvaluation;Lweka/core/Instances;)[I\",\n            evaluation.jobject, data.jobject)\n        if array is None:\n            return None\n        else:\n            javabridge.get_env().get_int_array_elements(array)", "response": "Performs the search and returns the indices of the selected attributes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef post_process(self, indices):\n        array = javabridge.call(self.jobject, \"postProcess\", \"([I)[I\", indices)\n        if array is None:\n            return None\n        else:\n            return javabridge.get_env().get_int_array_elements(array)", "response": "Post - processes the evaluator with the selected attribute indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the selected attributes from the last run.", "response": "def selected_attributes(self):\n        \"\"\"\n        Returns the selected attributes from the last run.\n\n        :return: the Numpy array of 0-based indices\n        :rtype: ndarray\n        \"\"\"\n        array = javabridge.call(self.jobject, \"selectedAttributes\", \"()[I\")\n        if array is None:\n            return None\n        else:\n            return javabridge.get_env().get_int_array_elements(array)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ranked_attributes(self):\n        matrix = javabridge.call(self.jobject, \"rankedAttributes\", \"()[[D\")\n        if matrix is None:\n            return None\n        else:\n            return typeconv.double_matrix_to_ndarray(matrix)", "response": "Returns the matrix of ranked attributes from the last run."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreducing the dimensionality of the provided Instances or Instance object.", "response": "def reduce_dimensionality(self, data):\n        \"\"\"\n        Reduces the dimensionality of the provided Instance or Instances object.\n\n        :param data: the data to process\n        :type data: Instances\n        :return: the reduced dataset\n        :rtype: Instances\n        \"\"\"\n        if type(data) is Instance:\n            return Instance(\n                javabridge.call(\n                    self.jobject, \"reduceDimensionality\",\n                    \"(Lweka/core/Instance;)Lweka/core/Instance;\", data.jobject))\n        else:\n            return Instances(\n                javabridge.call(\n                    self.jobject, \"reduceDimensionality\",\n                    \"(Lweka/core/Instances;)Lweka/core/Instances;\", data.jobject))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates the threshold curve data from the evaluation object s predictions and the class - label.", "response": "def generate_thresholdcurve_data(evaluation, class_index):\n    \"\"\"\n    Generates the threshold curve data from the evaluation object's predictions.\n\n    :param evaluation: the evaluation to obtain the predictions from\n    :type evaluation: Evaluation\n    :param class_index: the 0-based index of the class-label to create the plot for\n    :type class_index: int\n    :return: the generated threshold curve data\n    :rtype: Instances\n    \"\"\"\n    jtc = JavaObject.new_instance(\"weka.classifiers.evaluation.ThresholdCurve\")\n    pred = javabridge.call(evaluation.jobject, \"predictions\", \"()Ljava/util/ArrayList;\")\n    result = Instances(\n        javabridge.call(jtc, \"getCurve\", \"(Ljava/util/ArrayList;I)Lweka/core/Instances;\", pred, class_index))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves x and y columns from the data generated by the weka. classifiers. evaluator. ThresholdCurve class.", "response": "def get_thresholdcurve_data(data, xname, yname):\n    \"\"\"\n    Retrieves x and y columns from  of the data generated by the weka.classifiers.evaluation.ThresholdCurve\n    class.\n\n    :param data: the threshold curve data\n    :type data: Instances\n    :param xname: the name of the X column\n    :type xname: str\n    :param yname: the name of the Y column\n    :type yname: str\n    :return: tuple of x and y arrays\n    :rtype: tuple\n    \"\"\"\n    xi = data.attribute_by_name(xname).index\n    yi = data.attribute_by_name(yname).index\n    x = []\n    y = []\n    for i in range(data.num_instances):\n        inst = data.get_instance(i)\n        x.append(inst.get_value(xi))\n        y.append(inst.get_value(yi))\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot the ROC curve for the given class_index.", "response": "def plot_roc(evaluation, class_index=None, title=None, key_loc=\"lower right\", outfile=None, wait=True):\n    \"\"\"\n    Plots the ROC (receiver operator characteristics) curve for the given predictions.\n\n    TODO: click events http://matplotlib.org/examples/event_handling/data_browser.html\n\n    :param evaluation: the evaluation to obtain the predictions from\n    :type evaluation: Evaluation\n    :param class_index: the list of 0-based indices of the class-labels to create the plot for\n    :type class_index: list\n    :param title: an optional title\n    :type title: str\n    :param key_loc: the position string for the key\n    :type key_loc: str\n    :param outfile: the output file, ignored if None\n    :type outfile: str\n    :param wait: whether to wait for the user to close the plot\n    :type wait: bool\n    \"\"\"\n    if not plot.matplotlib_available:\n        logger.error(\"Matplotlib is not installed, plotting unavailable!\")\n        return\n    if class_index is None:\n        class_index = [0]\n    ax = None\n    for cindex in class_index:\n        data = generate_thresholdcurve_data(evaluation, cindex)\n        head = evaluation.header\n        area = get_auc(data)\n        x, y = get_thresholdcurve_data(data, \"False Positive Rate\", \"True Positive Rate\")\n        if ax is None:\n            fig, ax = plt.subplots()\n            ax.set_xlabel(\"False Positive Rate\")\n            ax.set_ylabel(\"True Positive Rate\")\n            if title is None:\n                title = \"ROC\"\n            ax.set_title(title)\n            ax.grid(True)\n            fig.canvas.set_window_title(title)\n            plt.xlim([-0.05, 1.05])\n            plt.ylim([-0.05, 1.05])\n        plot_label = head.class_attribute.value(cindex) + \" (AUC: %0.4f)\" % area\n        ax.plot(x, y, label=plot_label)\n        ax.plot(ax.get_xlim(), ax.get_ylim(), ls=\"--\", c=\"0.3\")\n    plt.draw()\n    plt.legend(loc=key_loc, shadow=True)\n    if outfile is not None:\n        plt.savefig(outfile)\n    if wait:\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting a learning curve.", "response": "def plot_learning_curve(classifiers, train, test=None, increments=100, metric=\"percent_correct\",\n                        title=\"Learning curve\", label_template=\"[#] @ $\", key_loc=\"lower right\",\n                        outfile=None, wait=True):\n    \"\"\"\n    Plots a learning curve.\n\n    :param classifiers: list of Classifier template objects\n    :type classifiers: list of Classifier\n    :param train: dataset to use for the building the classifier, used for evaluating it test set None\n    :type train: Instances\n    :param test: optional dataset (or list of datasets) to use for the testing the built classifiers\n    :type test: list or Instances\n    :param increments: the increments (>= 1: # of instances, <1: percentage of dataset)\n    :type increments: float\n    :param metric: the name of the numeric metric to plot (Evaluation.<metric>)\n    :type metric: str\n    :param title: the title for the plot\n    :type title: str\n    :param label_template: the template for the label in the plot\n                           (#: 1-based index of classifier, @: full classname, !: simple classname,\n                           $: options, *: 1-based index of test set)\n    :type label_template: str\n    :param key_loc: the location string for the key\n    :type key_loc: str\n    :param outfile: the output file, ignored if None\n    :type outfile: str\n    :param wait: whether to wait for the user to close the plot\n    :type wait: bool\n    \"\"\"\n\n    if not plot.matplotlib_available:\n        logger.error(\"Matplotlib is not installed, plotting unavailable!\")\n        return\n    if not train.has_class():\n        logger.error(\"Training set has no class attribute set!\")\n        return\n\n    if increments >= 1:\n        inc = increments\n    else:\n        inc = round(train.num_instances * increments)\n\n    if test is None:\n        tst = [train]\n    elif isinstance(test, list):\n        tst = test\n    elif isinstance(test, Instances):\n        tst = [test]\n    else:\n        logger.error(\"Expected list or Instances object, instead: \" + type(test))\n        return\n    for t in tst:\n        if train.equal_headers(t) is not None:\n            logger.error(\"Training and test set are not compatible: \" + train.equal_headers(t))\n            return\n\n    steps = []\n    cls = []\n    evls = {}\n    for classifier in classifiers:\n        cl = Classifier.make_copy(classifier)\n        cls.append(cl)\n        evls[cl] = {}\n        for t in tst:\n            evls[cl][t] = []\n\n    for i in range(train.num_instances):\n        if (i > 0) and (i % inc == 0):\n            steps.append(i+1)\n        for cl in cls:\n            # train\n            if cl.is_updateable:\n                if i == 0:\n                    tr = Instances.copy_instances(train, 0, 1)\n                    cl.build_classifier(tr)\n                else:\n                    cl.update_classifier(train.get_instance(i))\n            else:\n                if (i > 0) and (i % inc == 0):\n                    tr = Instances.copy_instances(train, 0, i + 1)\n                    cl.build_classifier(tr)\n            # evaluate\n            if (i > 0) and (i % inc == 0):\n                for t in tst:\n                    evl = Evaluation(t)\n                    evl.test_model(cl, t)\n                    evls[cl][t].append(getattr(evl, metric))\n\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"# of instances\")\n    ax.set_ylabel(metric)\n    ax.set_title(title)\n    fig.canvas.set_window_title(title)\n    ax.grid(True)\n    i = 0\n    for cl in cls:\n        evlpertest = evls[cl]\n        i += 1\n        n = 0\n        for t in tst:\n            evl = evlpertest[t]\n            n += 1\n            plot_label = label_template.\\\n                replace(\"#\", str(i)).\\\n                replace(\"*\", str(n)).\\\n                replace(\"@\", cl.classname).\\\n                replace(\"!\", cl.classname[cl.classname.rfind(\".\") + 1:]).\\\n                replace(\"$\", join_options(cl.config))\n            ax.plot(steps, evl, label=plot_label)\n    plt.draw()\n    plt.legend(loc=key_loc, shadow=True)\n    if outfile is not None:\n        plt.savefig(outfile)\n    if wait:\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_packages():\n    establish_cache()\n    result = []\n    pkgs = javabridge.get_collection_wrapper(\n        javabridge.static_call(\n            \"weka/core/WekaPackageManager\", \"getAllPackages\", \"()Ljava/util/List;\"))\n    for pkge in pkgs:\n        result.append(Package(pkge))\n    return result", "response": "Returns a list of all packages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling a package from a repository or archive.", "response": "def install_package(pkge, version=\"Latest\"):\n    \"\"\"\n    The list of packages to install.\n\n    :param pkge: the name of the repository package, a URL (http/https) or a zip file\n    :type pkge: str\n    :param version: in case of the repository packages, the version\n    :type version: str\n    :return: whether successfully installed\n    :rtype: bool\n    \"\"\"\n    establish_cache()\n    if pkge.startswith(\"http://\") or pkge.startswith(\"https://\"):\n        url = javabridge.make_instance(\n            \"java/net/URL\", \"(Ljava/lang/String;)V\", javabridge.get_env().new_string_utf(pkge))\n        return not javabridge.static_call(\n            \"weka/core/WekaPackageManager\", \"installPackageFromURL\",\n            \"(Ljava/net/URL;[Ljava/io/PrintStream;)Ljava/lang/String;\", url, []) is None\n    elif pkge.lower().endswith(\".zip\"):\n        return not javabridge.static_call(\n            \"weka/core/WekaPackageManager\", \"installPackageFromArchive\",\n            \"(Ljava/lang/String;[Ljava/io/PrintStream;)Ljava/lang/String;\", pkge, []) is None\n    else:\n        return javabridge.static_call(\n            \"weka/core/WekaPackageManager\", \"installPackageFromRepository\",\n            \"(Ljava/lang/String;Ljava/lang/String;[Ljava/io/PrintStream;)Z\", pkge, version, [])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_installed(name):\n    pkgs = installed_packages()\n    for pkge in pkgs:\n        if pkge.name == name:\n            return True\n    return False", "response": "Checks whether a package with the given name is already installed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the dependencies of the package.", "response": "def dependencies(self):\n        \"\"\"\n        Returns the dependencies of the package.\n\n        :return: the list of Dependency objects\n        :rtype: list of Dependency\n        \"\"\"\n        result = []\n        dependencies = javabridge.get_collection_wrapper(\n            javabridge.call(self.jobject, \"getDependencies\", \"()Ljava/util/List;\"))\n        for dependency in dependencies:\n            result.append(Dependency(dependency))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_constraint(self, pkge=None, constr=None):\n        if not pkge is None:\n            return javabridge.call(\n                self.jobject, \"checkConstraint\", \"(Lweka/core/packageManagement/Package;)Z\", pkge.jobject)\n        if not constr is None:\n            return javabridge.call(\n                self.jobject, \"checkConstraint\", \"(Lweka/core/packageManagement/PackageConstraint;)Z\", pkge.jobject)\n        raise Exception(\"Either package or package constraing must be provided!\")", "response": "Checks the constraints.\n\n        :param pkge: the package to check\n        :type pkge: Package\n        :param constr: the package constraint to check\n        :type constr: PackageConstraint"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the custom properties file to use.", "response": "def custom_properties(self, props):\n        \"\"\"\n        Sets the custom properties file to use.\n\n        :param props: the props file\n        :type props: str\n        \"\"\"\n        fprops = javabridge.make_instance(\"java/io/File\", \"(Ljava/lang/String;)V\", props)\n        javabridge.call(self.jobject, \"setCustomPropsFile\", \"(Ljava/io/File;)V\", fprops)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the Instances from the specified query.", "response": "def retrieve_instances(self, query=None):\n        \"\"\"\n        Executes either the supplied query or the one set via options (or the 'query' property).\n\n        :param query: query to execute if not the currently set one\n        :type query: str\n        :return: the generated dataq\n        :rtype: Instances\n        \"\"\"\n        if query is None:\n            data = javabridge.call(self.jobject, \"retrieveInstances\", \"()Lweka/core/Instances;\")\n        else:\n            data = javabridge.call(self.jobject, \"retrieveInstances\", \"(Ljava/lang/String;)Lweka/core/Instances;\")\n        return Instances(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the owner of these capabilities if any.", "response": "def owner(self):\n        \"\"\"\n        Returns the owner of these capabilities, if any.\n\n        :return: the owner, can be None\n        :rtype: JavaObject\n        \"\"\"\n        obj = javabridge.call(self.jobject, \"getOwner\", \"()Lweka/core/CapabilitiesHandler;\")\n        if obj is None:\n            return None\n        else:\n            return JavaObject(jobject=obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all the dependencies.", "response": "def dependencies(self):\n        \"\"\"\n        Returns all the dependencies.\n\n        :return: the dependency list\n        :rtype: list\n        \"\"\"\n        result = []\n        iterator = javabridge.iterate_java(javabridge.call(self.jobject, \"dependencies\", \"()Ljava/util/Iterator;\"))\n        for c in iterator:\n            result.append(Capability(c))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef for_instances(cls, data, multi=None):\n        if multi is None:\n            return Capabilities(javabridge.static_call(\n                \"weka/core/Capabilities\", \"forInstances\",\n                \"(Lweka/core/Instances;)Lweka/core/Capabilities;\", data.jobject))\n        else:\n            return Capabilities(javabridge.static_call(\n                \"weka/core/Capabilities\", \"forInstances\",\n                \"(Lweka/core/Instances;Z)Lweka/core/Capabilities;\", data.jobject, multi))", "response": "Returns a Capabilities object specific for the given data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scatter_plot(data, index_x, index_y, percent=100.0, seed=1, size=50, title=None, outfile=None, wait=True):\n    if not plot.matplotlib_available:\n        logger.error(\"Matplotlib is not installed, plotting unavailable!\")\n        return\n\n    # create subsample\n    data = plot.create_subsample(data, percent=percent, seed=seed)\n\n    # collect data\n    x = []\n    y = []\n    if data.class_index == -1:\n        c = None\n    else:\n        c = []\n    for i in range(data.num_instances):\n        inst = data.get_instance(i)\n        x.append(inst.get_value(index_x))\n        y.append(inst.get_value(index_y))\n        if c is not None:\n            c.append(inst.get_value(inst.class_index))\n\n    # plot data\n    fig, ax = plt.subplots()\n    if c is None:\n        ax.scatter(x, y, s=size, alpha=0.5)\n    else:\n        ax.scatter(x, y, c=c, s=size, alpha=0.5)\n    ax.set_xlabel(data.attribute(index_x).name)\n    ax.set_ylabel(data.attribute(index_y).name)\n    if title is None:\n        title = \"Attribute scatter plot\"\n        if percent != 100:\n            title += \" (%0.1f%%)\" % percent\n    ax.set_title(title)\n    ax.plot(ax.get_xlim(), ax.get_ylim(), ls=\"--\", c=\"0.3\")\n    ax.grid(True)\n    fig.canvas.set_window_title(data.relationname)\n    plt.draw()\n    if outfile is not None:\n        plt.savefig(outfile)\n    if wait:\n        plt.show()", "response": "Plots two attributes against each other."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef line_plot(data, atts=None, percent=100.0, seed=1, title=None, outfile=None, wait=True):\n    if not plot.matplotlib_available:\n        logger.error(\"Matplotlib is not installed, plotting unavailable!\")\n        return\n\n    # create subsample\n    data = plot.create_subsample(data, percent=percent, seed=seed)\n\n    fig = plt.figure()\n\n    if atts is None:\n        x = []\n        for i in range(data.num_attributes):\n            x.append(i)\n    else:\n        x = atts\n\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(\"attributes\")\n    ax.set_ylabel(\"value\")\n    ax.grid(True)\n    for index_y in range(data.num_instances):\n        y = []\n        for index_x in x:\n            y.append(data.get_instance(index_y).get_value(index_x))\n        ax.plot(x, y, \"o-\", alpha=0.5)\n    if title is None:\n        title = data.relationname\n    if percent != 100:\n        title += \" (%0.1f%%)\" % percent\n    fig.canvas.set_window_title(title)\n    plt.draw()\n    if outfile is not None:\n        plt.savefig(outfile)\n    if wait:\n        plt.show()", "response": "Plots the dataset in one line per instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter(self, data):\n        if isinstance(data, list):\n            result = []\n            for d in data:\n                result.append(Instances(javabridge.static_call(\n                    \"Lweka/filters/Filter;\", \"useFilter\",\n                    \"(Lweka/core/Instances;Lweka/filters/Filter;)Lweka/core/Instances;\",\n                    d.jobject, self.jobject)))\n            return result\n        else:\n            return Instances(javabridge.static_call(\n                \"Lweka/filters/Filter;\", \"useFilter\",\n                \"(Lweka/core/Instances;Lweka/filters/Filter;)Lweka/core/Instances;\",\n                data.jobject, self.jobject))", "response": "Filters the dataset. When providing a list returns a list of Instances objects. When providing a list returns a list of Instances objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filters(self):\n        objects = javabridge.get_env().get_object_array_elements(\n            javabridge.call(self.jobject, \"getFilters\", \"()[Lweka/filters/Filter;\"))\n        result = []\n        for obj in objects:\n            result.append(Filter(jobject=obj))\n        return result", "response": "Returns the list of base filters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filters(self, filters):\n        obj = []\n        for fltr in filters:\n            obj.append(fltr.jobject)\n        javabridge.call(self.jobject, \"setFilters\", \"([Lweka/filters/Filter;)V\", obj)", "response": "Sets the base filters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a help string for this container.", "response": "def generate_help(self):\n        \"\"\"\n        Generates a help string for this container.\n\n        :return: the help string\n        :rtype: str\n        \"\"\"\n        result = []\n        result.append(self.__class__.__name__)\n        result.append(re.sub(r'.', '=', self.__class__.__name__))\n        result.append(\"\")\n        result.append(\"Supported value names:\")\n        for a in self.allowed:\n            result.append(a)\n        return '\\n'.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall after the actual execution of the transformer.", "response": "def post_execute(self):\n        \"\"\"\n        Gets executed after the actual execution.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        result = super(Transformer, self).post_execute()\n        if result is None:\n            self._input = None\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef quickinfo(self):\n        return \"incremental: \" + str(self.config[\"incremental\"]) \\\n               + \", custom: \" + str(self.config[\"use_custom_loader\"]) \\\n               + \", loader: \" + base.to_commandline(self.config[\"custom_loader\"])", "response": "Returns a short string describing some of the options of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_config(self, options):\n        opt = \"incremental\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to load the dataset incrementally (bool).\"\n\n        opt = \"use_custom_loader\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to use a custom loader.\"\n\n        opt = \"custom_loader\"\n        if opt not in options:\n            options[opt] = converters.Loader(classname=\"weka.core.converters.ArffLoader\")\n        if opt not in self.help:\n            self.help[opt] = \"The custom loader to use (Loader).\"\n\n        return super(LoadDataset, self).fix_config(options)", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the input token for unsupported classes. Raises an exception if unsupported.", "response": "def check_input(self, token):\n        \"\"\"\n        Performs checks on the input token. Raises an exception if unsupported.\n\n        :param token: the token to check\n        :type token: Token\n        \"\"\"\n        if token is None:\n            raise Exception(self.full_name + \": No token provided!\")\n        if isinstance(token.payload, str):\n            return\n        raise Exception(self.full_name + \": Unhandled class: \" + classes.get_classname(token.payload))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_execute(self):\n        fname = str(self.input.payload)\n        if not os.path.exists(fname):\n            return \"File '\" + fname + \"' does not exist!\"\n        if not os.path.isfile(fname):\n            return \"Location '\" + fname + \"' is not a file!\"\n        if self.resolve_option(\"use_custom_loader\"):\n            self._loader = self.resolve_option(\"custom_loader\")\n        else:\n            self._loader = converters.loader_for_file(fname)\n        dataset = self._loader.load_file(fname, incremental=bool(self.resolve_option(\"incremental\")))\n        if not self.resolve_option(\"incremental\"):\n            self._output.append(Token(dataset))\n        else:\n            self._iterator = self._loader.__iter__()\n        return None", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the next available output token.", "response": "def output(self):\n        \"\"\"\n        Returns the next available output token.\n\n        :return: the next token, None if none available\n        :rtype: Token\n        \"\"\"\n        if self._iterator is not None:\n            try:\n                inst = self._iterator.next()\n                result = Token(inst)\n            except Exception as e:\n                self._iterator = None\n                result = None\n        else:\n            result = super(LoadDataset, self).output()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstops execution of the object.", "response": "def stop_execution(self):\n        \"\"\"\n        Triggers the stopping of the object.\n        \"\"\"\n        super(LoadDataset, self).stop_execution()\n        self._loader = None\n        self._iterator = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrapup(self):\n        self._loader = None\n        self._iterator = None\n        super(LoadDataset, self).wrapup()", "response": "Removes any graphical output from the loader and iterator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_config(self, options):\n        options = super(SetStorageValue, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The storage value name for storing the payload under (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_execute(self):\n        if self.storagehandler is None:\n            return \"No storage handler available!\"\n        self.storagehandler.storage[self.resolve_option(\"storage_name\")] = self.input.payload\n        self._output.append(self.input)\n        return None", "response": "The actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fix_config(self, options):\n        options = super(DeleteStorageValue, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the storage value to delete (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfix the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(InitStorageValue, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the storage value to delete (string).\"\n\n        opt = \"value\"\n        if opt not in options:\n            options[opt] = \"1\"\n        if opt not in self.help:\n            self.help[opt] = \"The initial value (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_config(self, options):\n        options = super(UpdateStorageValue, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the storage value to update (string).\"\n\n        opt = \"expression\"\n        if opt not in options:\n            options[opt] = \"int({X} + 1)\"\n        if opt not in self.help:\n            self.help[opt] = \"The expression for updating the storage value; use {X} for current value (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_execute(self):\n        if self.storagehandler is None:\n            return \"No storage handler available!\"\n        expr = str(self.resolve_option(\"expression\")).replace(\n            \"{X}\", str(self.storagehandler.storage[str(self.resolve_option(\"storage_name\"))]))\n        expr = self.storagehandler.expand(expr)\n        self.storagehandler.storage[self.resolve_option(\"storage_name\")] = eval(expr)\n        self._output.append(self.input)\n        return None", "response": "Execute the actor s execution."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(MathExpression, self).fix_config(options)\n\n        opt = \"expression\"\n        if opt not in options:\n            options[opt] = \"{X}\"\n        if opt not in self.help:\n            self.help[opt] = \"The mathematical expression to evaluate (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the actor s execution.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        expr = str(self.resolve_option(\"expression\"))\n        expr = expr.replace(\"{X}\", str(self.input.payload))\n        self._output.append(Token(eval(expr)))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(ClassSelector, self).fix_config(options)\n\n        opt = \"index\"\n        if opt not in options:\n            options[opt] = \"last\"\n        if opt not in self.help:\n            self.help[opt] = \"The class index (1-based number); 'first' and 'last' are accepted as well (string).\"\n\n        opt = \"unset\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to unset the class index (bool).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_execute(self):\n        if isinstance(self.input.payload, Instances):\n            inst = None\n            data = self.input.payload\n        elif isinstance(self.input.payload, Instance):\n            inst = self.input.payload\n            data = inst.dataset\n\n        index = str(self.resolve_option(\"index\"))\n        unset = bool(self.resolve_option(\"unset\"))\n        if unset:\n            data.no_class()\n        else:\n            if index == \"first\":\n                data.class_is_first()\n            elif index == \"last\":\n                data.class_is_last()\n            else:\n                data.class_index = int(index) - 1\n\n        if inst is None:\n            self._output.append(Token(data))\n        else:\n            self._output.append(Token(inst))\n\n        return None", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(Train, self).fix_config(options)\n\n        opt = \"setup\"\n        if opt not in options:\n            options[opt] = Classifier(classname=\"weka.classifiers.rules.ZeroR\")\n        if opt not in self.help:\n            self.help[opt] = \"The classifier/clusterer/associator to train (Classifier/Clusterer/Associator).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_execute(self):\n        if isinstance(self.input.payload, Instances):\n            inst = None\n            data = self.input.payload\n        else:\n            inst = self.input.payload\n            data = inst.dataset\n\n        retrain = False\n        if (self._header is None) or (self._header.equal_headers(data) is not None) or (inst is None):\n            retrain = True\n            self._header = Instances.template_instances(data, 0)\n\n        if retrain or (self._model is None):\n            cls = self.resolve_option(\"setup\")\n            if isinstance(cls, Classifier):\n                self._model = Classifier.make_copy(cls)\n            elif isinstance(cls, Clusterer):\n                self._model = Clusterer.make_copy(cls)\n            elif isinstance(cls, Associator):\n                self._model = Associator.make_copy(cls)\n            else:\n                return \"Unhandled class: \" + classes.get_classname(cls)\n\n        if retrain:\n            if inst is not None:\n                data = Instances.template_instances(data, 1)\n                data.add_instance(inst)\n            if isinstance(self._model, Classifier):\n                self._model.build_classifier(data)\n            elif isinstance(self._model, Clusterer):\n                self._model.build_clusterer(data)\n            elif isinstance(self._model, Associator):\n                self._model.build_associations(data)\n        else:\n            if isinstance(self._model, Classifier):\n                self._model.update_classifier(inst)\n            elif isinstance(self._model, Clusterer):\n                self._model.update_clusterer(inst)\n            else:\n                return \"Cannot train incrementally: \" + classes.get_classname(self._model)\n\n        cont = ModelContainer(model=self._model, header=self._header)\n        self._output.append(Token(cont))\n        return None", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        opt = \"setup\"\n        if opt not in options:\n            options[opt] = filters.Filter(classname=\"weka.filters.AllFilter\")\n        if opt not in self.help:\n            self.help[opt] = \"The filter to apply to the dataset (Filter).\"\n\n        opt = \"keep_relationname\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to keep the original relation name (bool).\"\n\n        return super(Filter, self).fix_config(options)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_input(self, token):\n        if token is None:\n            raise Exception(self.full_name + \": No token provided!\")\n        if isinstance(token.payload, Instances):\n            return\n        if isinstance(token.payload, Instance):\n            return\n        raise Exception(self.full_name + \": Unhandled class: \" + classes.get_classname(token.payload))", "response": "Checks the input token for unsupported classes. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute the actor s action.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        if isinstance(self.input.payload, Instance):\n            inst = self.input.payload\n            data = Instances.template_instances(inst.dataset, 1)\n            data.add_instance(inst)\n        else:\n            inst = None\n            data = self.input.payload\n        relname = data.relationname\n        keep = self.resolve_option(\"keep_relationname\")\n\n        if inst is None:\n            if (self._filter is None) or self._header.equal_headers(data) is not None:\n                self._header = Instances.template_instances(data)\n                self._filter = filters.Filter.make_copy(self.resolve_option(\"setup\"))\n                self._filter.inputformat(data)\n            filtered = self._filter.filter(data)\n            if keep:\n                filtered.relationname = relname\n            self._output.append(Token(filtered))\n        else:\n            if (self._filter is None) or self._header.equal_headers(data) is not None:\n                self._header = Instances.template_instances(data)\n                self._filter = filters.Filter.make_copy(self.resolve_option(\"setup\"))\n                self._filter.inputformat(data)\n                filtered = self._filter.filter(data)\n                if keep:\n                    filtered.relationname = relname\n                self._output.append(Token(filtered.get_instance(0)))\n            else:\n                self._filter.input(inst)\n                self._filter.batch_finished()\n                filtered = self._filter.output()\n                if keep:\n                    filtered.dataset.relationname = relname\n                self._output.append(Token(filtered))\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(DeleteFile, self).fix_config(options)\n\n        opt = \"regexp\"\n        if opt not in options:\n            options[opt] = \".*\"\n        if opt not in self.help:\n            self.help[opt] = \"The regular expression that the files must match (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fix_config(self, options):\n        options = super(CrossValidate, self).fix_config(options)\n\n        opt = \"setup\"\n        if opt not in options:\n            options[opt] = Classifier(classname=\"weka.classifiers.rules.ZeroR\")\n        if opt not in self.help:\n            self.help[opt] = \"The classifier/clusterer to train (Classifier/Clusterer).\"\n\n        opt = \"folds\"\n        if opt not in options:\n            options[opt] = 10\n        if opt not in self.help:\n            self.help[opt] = \"The number of folds for CV (int).\"\n\n        opt = \"seed\"\n        if opt not in options:\n            options[opt] = 1\n        if opt not in self.help:\n            self.help[opt] = \"The seed value for randomizing the data (int).\"\n\n        opt = \"discard_predictions\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Discard classifier predictions to save memory (bool).\"\n\n        opt = \"output\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"For capturing the classifier's prediction output (PredictionOutput).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the actual execution of the actor.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        data = self.input.payload\n        cls = self.resolve_option(\"setup\")\n        if isinstance(cls, Classifier):\n            cls = Classifier.make_copy(cls)\n            evl = Evaluation(data)\n            evl.discard_predictions = bool(self.resolve_option(\"discard_predictions\"))\n            evl.crossvalidate_model(\n                cls,\n                data,\n                int(self.resolve_option(\"folds\")),\n                Random(int(self.resolve_option(\"seed\"))),\n                self.resolve_option(\"output\"))\n            self._output.append(Token(evl))\n        elif isinstance(cls, Clusterer):\n            cls = Clusterer.make_copy(cls)\n            evl = ClusterEvaluation()\n            llh = evl.crossvalidate_model(\n                cls,\n                data,\n                int(self.resolve_option(\"folds\")),\n                Random(int(self.resolve_option(\"seed\"))))\n            self._output.append(Token(llh))\n        else:\n            return \"Unhandled class: \" + classes.get_classname(cls)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fix_config(self, options):\n        options = super(Evaluate, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the classifier model in storage (string).\"\n\n        opt = \"discard_predictions\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Discard classifier predictions to save memory (bool).\"\n\n        opt = \"output\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"For capturing the classifier's prediction output (PredictionOutput).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_execute(self):\n        data = self.input.payload\n        if self.storagehandler is None:\n            return \"No storage handler available!\"\n        sname = str(self.resolve_option(\"storage_name\"))\n        if sname not in self.storagehandler.storage:\n            return \"No storage item called '\" + sname + \"' present!\"\n        cls = self.storagehandler.storage[sname]\n        if isinstance(cls, Classifier):\n            evl = Evaluation(data)\n            evl.discard_predictions = bool(self.resolve_option(\"discard_predictions\"))\n            evl.test_model(\n                cls,\n                data,\n                self.resolve_option(\"output\"))\n        elif isinstance(cls, Clusterer):\n            evl = ClusterEvaluation()\n            evl.set_model(cls)\n            evl.test_model(data)\n        else:\n            return \"Unhandled class: \" + classes.get_classname(cls)\n        self._output.append(Token(evl))\n        return None", "response": "Executes the actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_config(self, options):\n        options = super(EvaluationSummary, self).fix_config(options)\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the output (string).\"\n\n        opt = \"complexity\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to output classifier complexity information (bool).\"\n\n        opt = \"matrix\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to output the classifier confusion matrix (bool).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the input token is a supported Evaluation object. Raises an exception if unsupported.", "response": "def check_input(self, token):\n        \"\"\"\n        Performs checks on the input token. Raises an exception if unsupported.\n\n        :param token: the token to check\n        :type token: Token\n        \"\"\"\n        if isinstance(token.payload, Evaluation):\n            return None\n        if isinstance(token.payload, ClusterEvaluation):\n            return None\n        raise Exception(\n            self.full_name + \": Input token is not a supported Evaluation object - \"\n            + classes.get_classname(token.payload))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the actual execution of the actor.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        evl = self.input.payload\n        if isinstance(evl, Evaluation):\n            summary = evl.summary(title=self.resolve_option(\"title\"), complexity=bool(self.resolve_option(\"complexity\")))\n            if bool(self.resolve_option(\"matrix\")):\n                summary += \"\\n\" + evl.matrix(title=self.resolve_option(\"title\"))\n        else:\n            summary = evl.cluster_results\n        self._output.append(Token(summary))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_execute(self):\n        fname = self.input.payload\n        data = serialization.read_all(fname)\n        if len(data) == 1:\n            if is_instance_of(data[0], \"weka.classifiers.Classifier\"):\n                cont = ModelContainer(model=Classifier(jobject=data[0]))\n            elif is_instance_of(data[0], \"weka.clusterers.Clusterer\"):\n                cont = ModelContainer(model=Clusterer(jobject=data[0]))\n            else:\n                return \"Unhandled class: \" + classes.get_classname(data[0])\n        elif len(data) == 2:\n            if is_instance_of(data[0], \"weka.classifiers.Classifier\"):\n                cont = ModelContainer(model=Classifier(jobject=data[0]), header=Instances(data[1]))\n            elif is_instance_of(data[0], \"weka.clusterers.Clusterer\"):\n                cont = ModelContainer(model=Clusterer(jobject=data[0]), header=Instances(data[1]))\n            else:\n                return \"Unhandled class: \" + classes.get_classname(data[0])\n        else:\n            return \"Expected 1 or 2 objects, but got \" + str(len(data)) + \" instead reading: \" + fname\n        self._output.append(Token(cont))\n        return None", "response": "This method is called by the actor s do_execute method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fix_config(self, options):\n        opt = \"setup\"\n        if opt not in options:\n            options[opt] = conversion.PassThrough()\n        if opt not in self.help:\n            self.help[opt] = \"The conversion to apply to the input data (Conversion).\"\n\n        return super(Convert, self).fix_config(options)", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_input(self, token):\n        if token is None:\n            raise Exception(self.full_name + \": No token provided!\")\n        self.config[\"setup\"].check_input(token.payload)", "response": "Checks the input token for unsupported input. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_execute(self):\n        conv = self.config[\"setup\"].shallow_copy()\n        conv.input = self._input.payload\n        result = conv.convert()\n        if result is None:\n            if conv.output is not None:\n                self._output.append(Token(conv.output))\n        return None", "response": "Execute the actor s execution."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef quickinfo(self):\n        return \"search: \" + base.to_commandline(self.config[\"search\"]) + \", eval: \" \\\n               + base.to_commandline(self.config[\"eval\"])", "response": "Returns a short string describing some of the options of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_config(self, options):\n        opt = \"search\"\n        if opt not in options:\n            options[opt] = attsel.ASSearch(classname=\"weka.attributeSelection.BestFirst\")\n        if opt not in self.help:\n            self.help[opt] = \"The search algorithm to use (ASSearch).\"\n\n        opt = \"eval\"\n        if opt not in options:\n            options[opt] = attsel.ASEvaluation(classname=\"weka.attributeSelection.CfsSubsetEval\")\n        if opt not in self.help:\n            self.help[opt] = \"The evaluation algorithm to use (ASEvaluation).\"\n\n        return super(AttributeSelection, self).fix_config(options)", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_input(self, token):\n        if token is None:\n            raise Exception(self.full_name + \": No token provided!\")\n        if not isinstance(token.payload, Instances):\n            raise Exception(self.full_name + \": Not an Instances object!\")", "response": "Checks that the input token is a valid token. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_execute(self):\n        data = self.input.payload\n        search = self.config[\"search\"].shallow_copy()\n        evl = self.config[\"eval\"].shallow_copy()\n        asel = attsel.AttributeSelection()\n        asel.search(search)\n        asel.evaluator(evl)\n        asel.select_attributes(data)\n        cont = AttributeSelectionContainer(\n            original=data,\n            reduced=asel.reduce_dimensionality(data),\n            num_atts=asel.number_attributes_selected,\n            selected=asel.selected_attributes,\n            results=asel.results_string)\n        self._output.append(Token(cont))\n        return None", "response": "The actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_config(self, options):\n        options = super(RenameRelation, self).fix_config(options)\n\n        opt = \"name\"\n        if opt not in options:\n            options[opt] = \"newname\"\n        if opt not in self.help:\n            self.help[opt] = \"The new relation name to use (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_execute(self):\n        relname = self.resolve_option(\"name\")\n        if isinstance(self.input.payload, Instance):\n            self.input.payload.dataset.relationname = relname\n        else:\n            self.input.payload.relationname = relname\n        self._output.append(self.input)\n        return None", "response": "The actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_execute(self):\n        if isinstance(self.input.payload, classes.JavaObject) and self.input.payload.is_serializable:\n            copy = serialization.deepcopy(self.input.payload)\n            if copy is not None:\n                self._output.append(Token(copy))\n        else:\n            self._output.append(self.input)\n        return None", "response": "Executes the actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(Predict, self).fix_config(options)\n\n        opt = \"model\"\n        if opt not in options:\n            options[opt] = \".\"\n        if opt not in self.help:\n            self.help[opt] = \"The serialized model to use for making predictions (string).\"\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the model (or ModelContainer) in storage to use (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_input(self, token):\n        if isinstance(token.payload, Instance):\n            return\n        raise Exception(self.full_name + \": Unhandled data type: \" + str(token.payload.__class__.__name__))", "response": "Checks the input token for unsupported data types. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_dot_graph(graph, filename=None):\n    if not plot.pygraphviz_available:\n        logger.error(\"Pygraphviz is not installed, cannot generate graph plot!\")\n        return\n    if not plot.PIL_available:\n        logger.error(\"PIL is not installed, cannot display graph plot!\")\n        return\n\n    agraph = AGraph(graph)\n    agraph.layout(prog='dot')\n    if filename is None:\n        filename = tempfile.mktemp(suffix=\".png\")\n    agraph.draw(filename)\n    image = Image.open(filename)\n    image.show()", "response": "Plots a graph in graphviz dot notation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the stemmed version of the string s.", "response": "def stem(self, s):\n        \"\"\"\n        Performs stemming on the string.\n\n        :param s: the string to stem\n        :type s: str\n        :return: the stemmed string\n        :rtype: str\n        \"\"\"\n        return javabridge.get_env().get_string(self.__stem(javabridge.get_env().new_string_utf(s)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_instances_from_matrices(x, y=None, name=\"data\"):\n    if y is not None:\n        if len(x) != len(y):\n            raise Exception(\"Dimensions of x and y differ: \" + str(len(x)) + \" != \" + str(len(y)))\n    # create header\n    atts = []\n    for i in range(len(x[0])):\n        atts.append(Attribute.create_numeric(\"x\" + str(i+1)))\n    if y is not None:\n        atts.append(Attribute.create_numeric(\"y\"))\n    result = Instances.create_instances(name, atts, len(x))\n    # add data\n    for i in range(len(x)):\n        values = list(x[i])\n        if y is not None:\n            values.append(y[i])\n        result.add_instance(Instance.create_instance(values))\n    return result", "response": "Allows the generation of an Instances object from a 2 - dimensional matrix for X and a\n    1 - dimensional matrix for Y."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the specified attribute or None if not found.", "response": "def attribute_by_name(self, name):\n        \"\"\"\n        Returns the specified attribute, None if not found.\n\n        :param name: the name of the attribute\n        :type name: str\n        :return: the attribute or None\n        :rtype: Attribute\n        \"\"\"\n        att = self.__attribute_by_name(javabridge.get_env().new_string(name))\n        if att is None:\n            return None\n        else:\n            return Attribute(att)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_instance(self, inst, index=None):\n        if index is None:\n            self.__append_instance(inst.jobject)\n        else:\n            self.__insert_instance(index, inst.jobject)", "response": "Adds the specified instance to the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the instance at the specified location in the dataset.", "response": "def set_instance(self, index, inst):\n        \"\"\"\n        Sets the Instance at the specified location in the dataset.\n\n        :param index: the 0-based index of the instance to replace\n        :type index: int\n        :param inst: the Instance to set\n        :type inst: Instance\n        :return: the instance\n        :rtype: Instance\n        \"\"\"\n        return Instance(\n            self.__set_instance(index, inst.jobject))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, index=None):\n        if index is None:\n            javabridge.call(self.jobject, \"delete\", \"()V\")\n        else:\n            javabridge.call(self.jobject, \"delete\", \"(I)V\", index)", "response": "Removes either the specified Instance or all Instance objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_attribute(self, att, index):\n        javabridge.call(self.jobject, \"insertAttributeAt\", \"(Lweka/core/Attribute;I)V\", att.jobject, index)", "response": "Inserts the specified attribute at the specified location."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef train_cv(self, num_folds, fold, random=None):\n        if random is None:\n            return Instances(\n                javabridge.call(self.jobject, \"trainCV\", \"(II)Lweka/core/Instances;\",\n                                num_folds, fold))\n        else:\n            return Instances(\n                javabridge.call(self.jobject, \"trainCV\", \"(IILjava/util/Random;)Lweka/core/Instances;\",\n                                num_folds, fold, random.jobject))", "response": "Generates a training fold for cross - validation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a copy of the Instances.", "response": "def copy_instances(cls, dataset, from_row=None, num_rows=None):\n        \"\"\"\n        Creates a copy of the Instances. If either from_row or num_rows are None, then all of\n        the data is being copied.\n\n        :param dataset: the original dataset\n        :type dataset: Instances\n        :param from_row: the 0-based start index of the rows to copy\n        :type from_row: int\n        :param num_rows: the number of rows to copy\n        :type num_rows: int\n        :return: the copy of the data\n        :rtype: Instances\n        \"\"\"\n        if from_row is None or num_rows is None:\n            return Instances(\n                javabridge.make_instance(\n                    \"weka/core/Instances\", \"(Lweka/core/Instances;)V\",\n                    dataset.jobject))\n        else:\n            dataset = cls.copy_instances(dataset)\n            return Instances(\n                javabridge.make_instance(\n                    \"weka/core/Instances\", \"(Lweka/core/Instances;II)V\",\n                    dataset.jobject, from_row, num_rows))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse the Instances as template to create an empty dataset.", "response": "def template_instances(cls, dataset, capacity=0):\n        \"\"\"\n        Uses the Instances as template to create an empty dataset.\n\n        :param dataset: the original dataset\n        :type dataset: Instances\n        :param capacity: how many data rows to reserve initially (see compactify)\n        :type capacity: int\n        :return: the empty dataset\n        :rtype: Instances\n        \"\"\"\n        return Instances(\n            javabridge.make_instance(\n                \"weka/core/Instances\", \"(Lweka/core/Instances;I)V\", dataset.jobject, capacity))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new Instances.", "response": "def create_instances(cls, name, atts, capacity):\n        \"\"\"\n        Creates a new Instances.\n\n        :param name: the relation name\n        :type name: str\n        :param atts: the list of attributes to use for the dataset\n        :type atts: list of Attribute\n        :param capacity: how many data rows to reserve initially (see compactify)\n        :type capacity: int\n        :return: the dataset\n        :rtype: Instances\n        \"\"\"\n        attributes = []\n        for att in atts:\n            attributes.append(att.jobject)\n        return Instances(\n            javabridge.make_instance(\n                \"weka/core/Instances\", \"(Ljava/lang/String;Ljava/util/ArrayList;I)V\",\n                name, javabridge.make_list(attributes), capacity))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_instances(cls, inst1, inst2):\n        return Instances(javabridge.static_call(\n            \"weka/core/Instances\", \"mergeInstances\",\n            \"(Lweka/core/Instances;Lweka/core/Instances;)Lweka/core/Instances;\", inst1.jobject, inst2.jobject))", "response": "Merges two Instances or str into one Instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dataset(self):\n        dataset = javabridge.call(self.jobject, \"dataset\", \"()Lweka/core/Instances;\")\n        if dataset is None:\n            return None\n        else:\n            return Instances(dataset)", "response": "Returns the dataset that this instance belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the string value at the specified index.", "response": "def set_string_value(self, index, s):\n        \"\"\"\n        Sets the string value at the specified position (0-based).\n\n        :param index: the 0-based index of the inernal value\n        :type index: int\n        :param s: the string value\n        :type s: str\n        \"\"\"\n        return self.__set_string_value(index, javabridge.get_env().new_string(s))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_instance(cls, values, classname=\"weka.core.DenseInstance\", weight=1.0):\n        jni_classname = classname.replace(\".\", \"/\")\n        if type(values) is list:\n            for i in range(len(values)):\n                values[i] = float(values[i])\n            values = numpy.array(values)\n        return Instance(\n            javabridge.make_instance(\n                jni_classname, \"(D[D)V\",\n                weight, javabridge.get_env().make_double_array(values)))", "response": "Creates a new instance of the class specified by classname and values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_sparse_instance(cls, values, max_values, classname=\"weka.core.SparseInstance\", weight=1.0):\n        jni_classname = classname.replace(\".\", \"/\")\n        indices = []\n        vals = []\n        for (i, v) in values:\n            indices.append(i)\n            vals.append(float(v))\n        indices = numpy.array(indices, dtype=numpy.int32)\n        vals = numpy.array(vals)\n        return Instance(\n            javabridge.make_instance(\n                jni_classname, \"(D[D[II)V\",\n                weight, javabridge.get_env().make_double_array(vals),\n                javabridge.get_env().make_int_array(indices), max_values))", "response": "Creates a new sparse instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef values(self):\n        enm = javabridge.call(self.jobject, \"enumerateValues\", \"()Ljava/util/Enumeration;\")\n        if enm is None:\n            return None\n        else:\n            return typeconv.enumeration_to_list(enm)", "response": "Returns the labels strings or relation - values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the type of the attribute as string.", "response": "def type_str(self, short=False):\n        \"\"\"\n        Returns the type of the attribute as string.\n\n        :return: the type\n        :rtype: str\n        \"\"\"\n        if short:\n            return javabridge.static_call(\n                \"weka/core/Attribute\", \"typeToStringShort\", \"(Lweka/core/Attribute;)Ljava/lang/String;\",\n                self.jobject)\n        else:\n            return javabridge.static_call(\n                \"weka/core/Attribute\", \"typeToString\", \"(Lweka/core/Attribute;)Ljava/lang/String;\",\n                self.jobject)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy(self, name=None):\n        if name is None:\n            return Attribute(\n                javabridge.call(self.jobject, \"copy\", \"()Ljava/lang/Object;\"))\n        else:\n            return Attribute(\n                javabridge.call(self.jobject, \"copy\", \"(Ljava/lang/String;)Lweka/core/Attribute;\", name))", "response": "Creates a copy of this attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_nominal(cls, name, labels):\n        return Attribute(\n            javabridge.make_instance(\n                \"weka/core/Attribute\", \"(Ljava/lang/String;Ljava/util/List;)V\", name, javabridge.make_list(labels)))", "response": "Creates a nominal attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_relational(cls, name, inst):\n        return Attribute(\n            javabridge.make_instance(\n                \"weka/core/Attribute\", \"(Ljava/lang/String;Lweka/core/Instances;)V\", name, inst.jobject))", "response": "Creates a relational attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the bundled jars to the JVM s classpath.", "response": "def add_bundled_jars():\n    \"\"\"\n    Adds the bundled jars to the JVM's classpath.\n    \"\"\"\n    # determine lib directory with jars\n    rootdir = os.path.split(os.path.dirname(__file__))[0]\n    libdir = rootdir + os.sep + \"lib\"\n\n    # add jars from lib directory\n    for l in glob.glob(libdir + os.sep + \"*.jar\"):\n        if l.lower().find(\"-src.\") == -1:\n            javabridge.JARS.append(str(l))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_system_classpath():\n    if 'CLASSPATH' in os.environ:\n        parts = os.environ['CLASSPATH'].split(os.pathsep)\n        for part in parts:\n            javabridge.JARS.append(part)", "response": "Adds the system s classpath to the JVM s classpath."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the javabridge connection (starts up the JVM). :param class_path: the additional classpath elements to add :type class_path: list :param bundled: whether to add jars from the \"lib\" directory :type bundled: bool :param packages: whether to add jars from Weka packages as well (bool) or an alternative Weka home directory (str) :type packages: bool or str :param system_cp: whether to add the system classpath as well :type system_cp: bool :param max_heap_size: the maximum heap size (-Xmx parameter, eg 512m or 4g) :type max_heap_size: str", "response": "def start(class_path=None, bundled=True, packages=False, system_cp=False, max_heap_size=None):\n    \"\"\"\n    Initializes the javabridge connection (starts up the JVM).\n\n    :param class_path: the additional classpath elements to add\n    :type class_path: list\n    :param bundled: whether to add jars from the \"lib\" directory\n    :type bundled: bool\n    :param packages: whether to add jars from Weka packages as well (bool) or an alternative Weka home directory (str)\n    :type packages: bool or str\n    :param system_cp: whether to add the system classpath as well\n    :type system_cp: bool\n    :param max_heap_size: the maximum heap size (-Xmx parameter, eg 512m or 4g)\n    :type max_heap_size: str\n    \"\"\"\n    global started\n\n    if started is not None:\n        logger.info(\"JVM already running, call jvm.stop() first\")\n        return\n\n    # add user-defined jars first\n    if class_path is not None:\n        for cp in class_path:\n            logger.debug(\"Adding user-supplied classpath=\" + cp)\n            javabridge.JARS.append(cp)\n\n    if bundled:\n        logger.debug(\"Adding bundled jars\")\n        add_bundled_jars()\n\n    if system_cp:\n        logger.debug(\"Adding system classpath\")\n        add_system_classpath()\n\n    logger.debug(\"Classpath=\" + str(javabridge.JARS))\n    logger.debug(\"MaxHeapSize=\" + (\"default\" if (max_heap_size is None) else max_heap_size))\n\n    args = []\n    weka_home = None\n    if packages is not None:\n        if isinstance(packages, bool):\n            if packages:\n                logger.debug(\"Package support enabled\")\n            else:\n                logger.debug(\"Package support disabled\")\n                args.append(\"-Dweka.packageManager.loadPackages=false\")\n        if isinstance(packages, str):\n            if os.path.exists(packages) and os.path.isdir(packages):\n                logger.debug(\"Using alternative Weka home directory: \" + packages)\n                weka_home = packages\n            else:\n                logger.warning(\"Invalid Weka home: \" + packages)\n\n    javabridge.start_vm(args=args, run_headless=True, max_heap_size=max_heap_size)\n    javabridge.attach()\n    started = True\n\n    if weka_home is not None:\n        from weka.core.classes import Environment\n        env = Environment.system_wide()\n        logger.debug(\"Using alternative Weka home directory: \" + packages)\n        env.add_variable(\"WEKA_HOME\", weka_home)\n\n    # initialize package manager\n    javabridge.static_call(\n        \"Lweka/core/WekaPackageManager;\", \"loadPackages\",\n        \"(Z)V\",\n        False)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the class object associated with the dot - notation classname.", "response": "def get_class(classname):\n    \"\"\"\n    Returns the class object associated with the dot-notation classname.\n\n    Taken from here: http://stackoverflow.com/a/452981\n\n    :param classname: the classname\n    :type classname: str\n    :return: the class object\n    :rtype: object\n    \"\"\"\n    parts = classname.split('.')\n    module = \".\".join(parts[:-1])\n    m = __import__(module)\n    for comp in parts[1:]:\n        m = getattr(m, comp)\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_jclass(classname):\n    try:\n        return javabridge.class_for_name(classname)\n    except:\n        return javabridge.static_call(\n            \"Lweka/core/ClassHelper;\", \"forName\",\n            \"(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Class;\",\n            javabridge.class_for_name(\"java.lang.Object\"), classname)", "response": "Returns the Java class object associated with the dot - notation classname."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Java object associated with the specified static field.", "response": "def get_static_field(classname, fieldname, signature):\n    \"\"\"\n    Returns the Java object associated with the static field of the specified class.\n\n    :param classname: the classname of the class to get the field from\n    :type classname: str\n    :param fieldname: the name of the field to retriev\n    :type fieldname: str\n    :return: the object\n    :rtype: JB_Object\n    \"\"\"\n    try:\n        return javabridge.get_static_field(classname, fieldname, signature)\n    except:\n        return javabridge.static_call(\n            \"Lweka/core/ClassHelper;\", \"getStaticField\",\n            \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;\",\n            classname, fieldname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_classname(obj):\n    if isinstance(obj, javabridge.JB_Object):\n        cls = javabridge.call(obj, \"getClass\", \"()Ljava/lang/Class;\")\n        return javabridge.call(cls, \"getName\", \"()Ljava/lang/String;\")\n    elif inspect.isclass(obj):\n        return obj.__module__ + \".\" + obj.__name__\n    else:\n        return get_classname(obj.__class__)", "response": "Returns the classname of the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_instance_of(obj, class_or_intf_name):\n    class_or_intf_name = class_or_intf_name.replace(\"/\", \".\")\n    classname = get_classname(obj)\n    # array? retrieve component type and check that\n    if is_array(obj):\n        jarray = JavaArray(jobject=obj)\n        classname = jarray.component_type()\n    result = javabridge.static_call(\n        \"Lweka/core/InheritanceUtils;\", \"isSubclass\",\n        \"(Ljava/lang/String;Ljava/lang/String;)Z\",\n        class_or_intf_name, classname)\n    if result:\n        return True\n    return javabridge.static_call(\n        \"Lweka/core/InheritanceUtils;\", \"hasInterface\",\n        \"(Ljava/lang/String;Ljava/lang/String;)Z\",\n        class_or_intf_name, classname)", "response": "Checks whether the object is an instance of the specified interface or is a subclass of the superclass."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_commandline(cmdline, classname=None):\n    params = split_options(cmdline)\n    cls = params[0]\n    params = params[1:]\n    handler = OptionHandler(javabridge.static_call(\n        \"Lweka/core/Utils;\", \"forName\",\n        \"(Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Object;\",\n        javabridge.class_for_name(\"java.lang.Object\"), cls, params))\n    if classname is None:\n        return handler\n    else:\n        c = get_class(classname)\n        return c(jobject=handler.jobject)", "response": "Creates an OptionHandler instance based on the provided commandline string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef complete_classname(classname):\n\n    result = javabridge.get_collection_wrapper(\n        javabridge.static_call(\n            \"Lweka/Run;\", \"findSchemeMatch\",\n            \"(Ljava/lang/String;Z)Ljava/util/List;\",\n            classname, True))\n    if len(result) == 1:\n        return str(result[0])\n    elif len(result) == 0:\n        raise Exception(\"No classname matches found for: \" + classname)\n    else:\n        matches = []\n        for i in range(len(result)):\n            matches.append(str(result[i]))\n        raise Exception(\"Found multiple matches for '\" + classname + \"':\\n\" + '\\n'.join(matches))", "response": "Attempts to complete a partial classname like. J48 and returns the full classname if a single match was found otherwise an exception is raised."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Performs option handling operations from the command-line. Calls JVM start/stop automatically.')\n    parser.add_argument(\"-j\", metavar=\"classpath\", dest=\"classpath\", help=\"additional classpath, jars/directories\")\n    parser.add_argument(\"-action\", metavar=\"action\", dest=\"action\", required=True,\n                        help=\"The action to perform on the options: join=create single string, \"\\\n                             \"split=create array from quoted option, code=generate code from options\")\n    parser.add_argument(\"option\", nargs=argparse.REMAINDER, help=\"The option(s) to process\")\n    parsed = parser.parse_args()\n    jars = []\n    if parsed.classpath is not None:\n        jars = parsed.classpath.split(os.pathsep)\n\n    jvm.start(jars, packages=True)\n\n    try:\n        if parsed.action == \"join\":\n            output = \"cmdline = \\\"\" + backquote(join_options(parsed.option)) + \"\\\"\"\n        elif parsed.action == \"split\" and len(parsed.option) == 1:\n            output = \"options = [\\n\"\n            opts = split_options(parsed.option[0])\n            for idx, opt in enumerate(opts):\n                if idx > 0:\n                    output += \",\\n\"\n                output += \"    \\\"\" + backquote(opt) + \"\\\"\"\n            output += \"]\"\n        elif parsed.action == \"code\":\n            options = parsed.option[:]\n            cname = None\n            # classname + options?\n            if options[0].find(\".\") > -1:\n                cname = options[0]\n                options = options[1:]\n            output = \"options = [ \\n\"\n            for idx, opt in enumerate(options):\n                if idx > 0:\n                    output += \",\\n\"\n                output += \"    \\\"\" + backquote(opt) + \"\\\"\"\n            output += \"]\\n\"\n            if cname is not None:\n                output += 'handler = OptionHandler(JavaObject.new_instance(\"' + cname + '\"))\\n'\n                output += 'handler.options = options\\n'\n        else:\n            raise Exception(\"Unsupported action: \" + parsed.action)\n        if output is not None:\n            print(output)\n    except Exception as e:\n        print(e)\n    finally:\n        jvm.stop()", "response": "Main entry point for the\nelf command - line interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the options as JSON.", "response": "def to_json(self):\n        \"\"\"\n        Returns the options as JSON.\n\n        :return: the object as string\n        :rtype: str\n        \"\"\"\n        return json.dumps(self.to_dict(), sort_keys=True, indent=2, separators=(',', ': '))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_json(cls, s):\n        d = json.loads(s)\n        return get_dict_handler(d[\"type\"])(d)", "response": "Restores the object from the given JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        result = {}\n        result[\"type\"] = \"Configurable\"\n        result[\"class\"] = get_classname(self)\n        result[\"config\"] = {}\n        for k in self._config:\n            v = self._config[k]\n            if isinstance(v, JSONObject):\n                result[\"config\"][k] = v.to_dict()\n            else:\n                result[\"config\"][k] = v\n        return result", "response": "Returns a dictionary that represents this object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrestoring its state from a dictionary used in de - JSONification.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Restores its state from a dictionary, used in de-JSONification.\n\n        :param d: the object dictionary\n        :type d: dict\n        \"\"\"\n        conf = {}\n        for k in d[\"config\"]:\n            v = d[\"config\"][k]\n            if isinstance(v, dict):\n                conf[str(k)] = get_dict_handler(d[\"config\"][\"type\"])(v)\n            else:\n                conf[str(k)] = v\n        return get_class(str(d[\"class\"]))(config=conf)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the logger object.", "response": "def logger(self):\n        \"\"\"\n        Returns the logger object.\n\n        :return: the logger\n        :rtype: logger\n        \"\"\"\n        if self._logger is None:\n            self._logger = self.new_logger()\n        return self._logger"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a help string for this actor.", "response": "def generate_help(self):\n        \"\"\"\n        Generates a help string for this actor.\n\n        :return: the help string\n        :rtype: str\n        \"\"\"\n        result = []\n        result.append(self.__class__.__name__)\n        result.append(re.sub(r'.', '=', self.__class__.__name__))\n        result.append(\"\")\n        result.append(\"DESCRIPTION\")\n        result.append(self.description())\n        result.append(\"\")\n        result.append(\"OPTIONS\")\n        opts = sorted(self.config.keys())\n        for opt in opts:\n            result.append(opt)\n            helpstr = self.help[opt]\n            if helpstr is None:\n                helpstr = \"-missing help-\"\n            result.append(\"\\t\" + helpstr)\n            result.append(\"\")\n        return '\\n'.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef classname(self):\n        cls = javabridge.call(self.jobject, \"getClass\", \"()Ljava/lang/Class;\")\n        return javabridge.call(cls, \"getName\", \"()Ljava/lang/String;\")", "response": "Returns the Java classname in dot - notation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_property(self, path, jobject):\n        # unwrap?\n        if isinstance(jobject, JavaObject):\n            jobject = jobject.jobject\n\n        javabridge.static_call(\n            \"Lweka/core/PropertyPath;\", \"setValue\",\n            \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V\",\n            self.jobject, path, jobject)", "response": "Sets the value of the property at the given path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nraise an exception if the object does not implement the specified interface or is not a subclass of the specified class.", "response": "def enforce_type(cls, jobject, intf_or_class):\n        \"\"\"\n        Raises an exception if the object does not implement the specified interface or is not a subclass. \n\n        :param jobject: the Java object to check\n        :type jobject: JB_Object\n        :param intf_or_class: the classname in Java notation (eg \"weka.core.DenseInstance\")\n        :type intf_or_class: str\n        \"\"\"\n        if not cls.check_type(jobject, intf_or_class):\n            raise TypeError(\"Object does not implement or subclass \" + intf_or_class + \": \" + get_classname(jobject))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_instance(cls, classname):\n        try:\n            return javabridge.static_call(\n                \"Lweka/core/Utils;\", \"forName\",\n                \"(Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Object;\",\n                javabridge.class_for_name(\"java.lang.Object\"), classname, [])\n        except JavaException as e:\n            print(\"Failed to instantiate \" + classname + \": \" + str(e))\n            return None", "response": "Creates a new object from the given classname using the default constructor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_variable(self, key, value, system_wide=False):\n        if system_wide:\n            javabridge.call(self.jobject, \"addVariableSystemWide\", \"(Ljava/lang/String;Ljava/lang/String;)V\", key, value)\n        else:\n            javabridge.call(self.jobject, \"addVariable\", \"(Ljava/lang/String;Ljava/lang/String;)V\", key, value)", "response": "Adds the environment variable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the names of all environment variables.", "response": "def variable_names(self):\n        \"\"\"\n        Returns the names of all environment variables.\n\n        :return: the names of the variables\n        :rtype: list\n        \"\"\"\n        result = []\n        names = javabridge.call(self.jobject, \"getVariableNames\", \"()Ljava/util/Set;\")\n        for name in javabridge.iterate_collection(names):\n            result.append(javabridge.to_string(name))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef component_type(self):\n        cls = javabridge.call(self.jobject, \"getClass\", \"()Ljava/lang/Class;\")\n        comptype = javabridge.call(cls, \"getComponentType\", \"()Ljava/lang/Class;\")\n        return javabridge.call(comptype, \"getName\", \"()Ljava/lang/String;\")", "response": "Returns the classname of the elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef new_instance(cls, classname, length):\n        return javabridge.static_call(\n            \"Ljava/lang/reflect/Array;\",\n            \"newInstance\",\n            \"(Ljava/lang/Class;I)Ljava/lang/Object;\",\n            get_jclass(classname=classname), length)", "response": "Creates a new array with the given classname and length."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef values(self):\n        cls = javabridge.call(self.jobject, \"getClass\", \"()Ljava/lang/Class;\")\n        clsname = javabridge.call(cls, \"getName\", \"()Ljava/lang/String;\")\n        l = javabridge.static_call(clsname.replace(\".\", \"/\"), \"values\", \"()[L\" + clsname.replace(\".\", \"/\") + \";\")\n        l = javabridge.get_env().get_object_array_elements(l)\n        result = []\n        for item in l:\n            result.append(Enum(jobject=item))\n        return result", "response": "Returns list of all enum members."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the next random integer.", "response": "def next_int(self, n=None):\n        \"\"\"\n        Next random integer. if n is provided, then between 0 and n-1.\n\n        :param n: the upper limit (minus 1) for the random integer\n        :type n: int\n        :return: the next random integer\n        :rtype: int\n        \"\"\"\n        if n is None:\n            return javabridge.call(self.jobject, \"nextInt\", \"()I\")\n        else:\n            return javabridge.call(self.jobject, \"nextInt\", \"(I)I\", n)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef options(self):\n        if self.is_optionhandler:\n            return typeconv.string_array_to_list(javabridge.call(self.jobject, \"getOptions\", \"()[Ljava/lang/String;\"))\n        else:\n            return []", "response": "Gets the currently set options as list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef options(self, options):\n        if self.is_optionhandler:\n            javabridge.call(self.jobject, \"setOptions\", \"([Ljava/lang/String;)V\", typeconv.string_list_to_array(options))", "response": "Sets the command - line options."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_help(self):\n        result = []\n        result.append(self.classname)\n        result.append(\"=\" * len(self.classname))\n        result.append(\"\")\n        result.append(\"DESCRIPTION\")\n        result.append(\"\")\n        result.append(self.global_info())\n        result.append(\"\")\n        result.append(\"OPTIONS\")\n        result.append(\"\")\n        options = javabridge.call(self.jobject, \"listOptions\", \"()Ljava/util/Enumeration;\")\n        enum = javabridge.get_enumeration_wrapper(options)\n        while enum.hasMoreElements():\n            opt = Option(enum.nextElement())\n            result.append(opt.synopsis)\n            result.append(opt.description)\n            result.append(\"\")\n        return '\\n'.join(result)", "response": "Returns the generated help string for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self):\n        result = super(OptionHandler, self).to_dict()\n        result[\"type\"] = \"OptionHandler\"\n        result[\"options\"] = join_options(self.options)\n        return result", "response": "Returns a dictionary that represents this object to be used for JSONification."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_dict(cls, d):\n        result = OptionHandler(cls.new_instance(d[\"class\"]))\n        result.options = split_options(d[\"options\"])\n        return result", "response": "Restores an object state from a dictionary used in de - JSONification."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Tag that matches the name.", "response": "def find(self, name):\n        \"\"\"\n        Returns the Tag that matches the name.\n\n        :param name: the string representation of the tag\n        :type name: str\n        :return: the tag, None if not found\n        :rtype: Tag\n        \"\"\"\n        result = None\n        for t in self.array:\n            if str(t) == name:\n                result = Tag(t.jobject)\n                break\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Tag array obtained from the object using the specified method name.", "response": "def get_object_tags(cls, javaobject, methodname):\n        \"\"\"\n        Instantiates the Tag array obtained from the object using the specified method name.\n\n        Example:\n        cls = Classifier(classname=\"weka.classifiers.meta.MultiSearch\")\n        tags = Tags.get_object_tags(cls, \"getMetricsTags\")\n\n        :param javaobject: the javaobject to obtain the tags from\n        :type javaobject: JavaObject\n        :param methodname: the method name returning the Tag array\n        :type methodname: str\n        :return: the Tags objects\n        :rtype: Tags\n        \"\"\"\n        return Tags(jobject=javabridge.call(javaobject.jobject, methodname, \"()[Lweka/core/Tag;\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tags(self):\n        result = []\n        a = javabridge.call(self.jobject, \"getTags\", \"()Lweka/core/Tag;]\")\n        length = javabridge.get_env().get_array_length(a)\n        wrapped = javabridge.get_env().get_object_array_elements(a)\n        for i in range(length):\n            result.append(Tag(javabridge.get_env().get_string(wrapped[i])))\n        return result", "response": "Returns the associated tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef base_object(self):\n        jobj = javabridge.call(self.jobject, \"getBaseObject\", \"()Ljava/io/Serializable;\")\n        if OptionHandler.check_type(jobj, \"weka.core.OptionHandler\"):\n            return OptionHandler(jobj)\n        else:\n            return JavaObject(jobj)", "response": "Returns the base object to apply the setups to."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef base_object(self, obj):\n        if not obj.is_serializable:\n            raise Exception(\"Base object must be serializable: \" + obj.classname)\n        javabridge.call(self.jobject, \"setBaseObject\", \"(Ljava/io/Serializable;)V\", obj.jobject)", "response": "Sets the base object to apply the setups to."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parameters(self):\n        array = JavaArray(javabridge.call(self.jobject, \"getParameters\", \"()[Lweka/core/setupgenerator/AbstractParameter;\"))\n        result = []\n        for item in array:\n            result.append(AbstractParameter(jobject=item.jobject))\n        return result", "response": "Returns the list of currently set search parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the list of search parameters to use.", "response": "def parameters(self, params):\n        \"\"\"\n        Sets the list of search parameters to use.\n\n        :param params: list of AbstractSearchParameter objects\n        :type params: list\n        \"\"\"\n        array = JavaArray(jobject=JavaArray.new_instance(\"weka.core.setupgenerator.AbstractParameter\", len(params)))\n        for idx, obj in enumerate(params):\n            array[idx] = obj.jobject\n        javabridge.call(self.jobject, \"setParameters\", \"([Lweka/core/setupgenerator/AbstractParameter;)V\", array.jobject)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setups(self):\n        result = []\n        has_options = self.base_object.is_optionhandler\n        enm = javabridge.get_enumeration_wrapper(javabridge.call(self.jobject, \"setups\", \"()Ljava/util/Enumeration;\"))\n        while enm.hasMoreElements():\n            if has_options:\n                result.append(OptionHandler(enm.nextElement()))\n            else:\n                result.append(JavaObject(enm.nextElement()))\n        return result", "response": "Generates and returns all the setups according to the parameter search space."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the object into a commandline string.", "response": "def to_commandline(o):\n    \"\"\"\n    Turns the object into a commandline string. However, first checks whether a string represents\n    a internal value placeholder (@{...}).\n\n    :param o: the object to turn into commandline\n    :type o: object\n    :return: the commandline\n    :rtype: str\n    \"\"\"\n    if isinstance(o, str) and o.startswith(\"@{\") and o.endswith(\"}\"):\n        return o\n    else:\n        return classes.to_commandline(o)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unique_name(self, name):\n        result = name\n\n        if self.parent is not None:\n            index = self.index\n            bname = re.sub(r'-[0-9]+$', '', name)\n            names = []\n            for idx, actor in enumerate(self.parent.actors):\n                if idx != index:\n                    names.append(actor.name)\n            result = bname\n            count = 0\n            while result in names:\n                count += 1\n                result = bname + \"-\" + str(count)\n\n        return result", "response": "Generates a unique name for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parent(self, parent):\n        self._name = self.unique_name(self._name)\n        self._full_name = None\n        self._logger = None\n        self._parent = parent", "response": "Sets the parent of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef full_name(self):\n        if self._full_name is None:\n            fn = self.name.replace(\".\", \"\\\\.\")\n            parent = self._parent\n            if parent is not None:\n                fn = parent.full_name + \".\" + fn\n            self._full_name = fn\n\n        return self._full_name", "response": "Gets the full name of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        opt = \"annotation\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The (optional) annotation for this actor (string).\"\n\n        opt = \"skip\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to skip (disable) this actor (bool).\"\n\n        return super(Actor, self).fix_config(options)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary that represents this object to be used for JSONification.", "response": "def to_dict(self):\n        \"\"\"\n        Returns a dictionary that represents this object, to be used for JSONification.\n\n        :return: the object dictionary\n        :rtype: dict\n        \"\"\"\n        result = super(Actor, self).to_dict()\n        result[\"type\"] = \"Actor\"\n        result[\"name\"] = self.name\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestores an object state from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Restores an object state from a dictionary, used in de-JSONification.\n\n        :param d: the object dictionary\n        :type d: dict\n        :return: the object\n        :rtype: object\n        \"\"\"\n        conf = {}\n        for k in d[\"config\"]:\n            v = d[\"config\"][k]\n            if isinstance(v, dict):\n                if u\"type\" in v:\n                    typestr = v[u\"type\"]\n                else:\n                    typestr = v[\"type\"]\n                conf[str(k)] = classes.get_dict_handler(typestr)(v)\n            else:\n                conf[str(k)] = v\n        return classes.get_class(d[\"class\"])(name=d[\"name\"], config=conf)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves the option name in internal storage.", "response": "def resolve_option(self, name, default=None):\n        \"\"\"\n        Resolves the option, i.e., interprets \"@{...}\" values and retrievs them instead from internal\n        storage.\n\n        :param name: the name of the option\n        :type name: str\n        :param default: the optional default value\n        :type default: object\n        :return: the resolved value\n        :rtype: object\n        \"\"\"\n        value = self.config[name]\n        if value is None:\n            return default\n        elif isinstance(value, str) \\\n                and value.startswith(\"@{\") \\\n                and value.endswith(\"}\") \\\n                and (value.find(\"@{\", 1) == -1):\n            stname = value[2:len(value)-1]\n            if (self.storagehandler is not None) and (stname in self.storagehandler.storage):\n                return self.storagehandler.storage[stname]\n            else:\n                return default\n        else:\n            return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the storage handler available to thise actor.", "response": "def storagehandler(self):\n        \"\"\"\n        Returns the storage handler available to thise actor.\n\n        :return: the storage handler, None if not available\n        \"\"\"\n        if isinstance(self, StorageHandler):\n            return self\n        elif self.parent is not None:\n            return self.parent.storagehandler\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the actor. :return: None if successful, otherwise error message :rtype: str", "response": "def execute(self):\n        \"\"\"\n        Executes the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        if self.skip:\n            return None\n\n        result = self.pre_execute()\n        if result is None:\n            try:\n                result = self.do_execute()\n            except Exception as e:\n                result = traceback.format_exc()\n                print(self.full_name + \"\\n\" + result)\n        if result is None:\n            result = self.post_execute()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef output(self):\n        if (self._output is None) or (len(self._output) == 0):\n            result = None\n        else:\n            result = self._output.pop(0)\n        return result", "response": "Returns the next available output token."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expand(self, s):\n        result = s\n        while result.find(\"@{\") > -1:\n            start = result.index(\"@{\")\n            end = result.index(\"}\", start)\n            name = result[start + 2:end]\n            value = self.storage[name]\n            if value is None:\n                raise(\"Storage value '\" + name + \"' not present, failed to expand string: \" + s)\n            else:\n                result = result[0:start] + str(value) + result[end + 1:]\n        return result", "response": "Expands all occurrences of \"@{...}\" within the string with the actual values currently stored\n        in internal storage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract(cls, padded):\n        if padded.startswith(\"@{\") and padded.endswith(\"}\"):\n            return padded[2:len(padded)-1]\n        else:\n            return padded", "response": "Extracts the name from the padded string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(ActorHandler, self).fix_config(options)\n\n        opt = \"actors\"\n        if opt not in options:\n            options[opt] = self.default_actors()\n        if opt not in self.help:\n            self.help[opt] = \"The list of sub-actors that this actor manages.\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary that represents this object to be used for JSONification.", "response": "def to_dict(self):\n        \"\"\"\n        Returns a dictionary that represents this object, to be used for JSONification.\n\n        :return: the object dictionary\n        :rtype: dict\n        \"\"\"\n        result = super(ActorHandler, self).to_dict()\n        result[\"type\"] = \"ActorHandler\"\n        del result[\"config\"][\"actors\"]\n        result[\"actors\"] = []\n        for actor in self.actors:\n            result[\"actors\"].append(actor.to_dict())\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrestore an object state from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Restores an object state from a dictionary, used in de-JSONification.\n\n        :param d: the object dictionary\n        :type d: dict\n        :return: the object\n        :rtype: object\n        \"\"\"\n        result = super(ActorHandler, cls).from_dict(d)\n        if \"actors\" in d:\n            l = d[\"actors\"]\n            for e in l:\n                if u\"type\" in e:\n                    typestr = e[u\"type\"]\n                else:\n                    typestr = e[\"type\"]\n                result.actors.append(classes.get_dict_handler(typestr)(e))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef actors(self, actors):\n        if actors is None:\n            actors = self.default_actors()\n        self.check_actors(actors)\n        self.config[\"actors\"] = actors", "response": "Sets the sub - actors of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the count of active actors.", "response": "def active(self):\n        \"\"\"\n        Returns the count of non-skipped actors.\n\n        :return: the count\n        :rtype: int\n        \"\"\"\n        result = 0\n        for actor in self.actors:\n            if not actor.skip:\n                result += 1\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef first_active(self):\n        result = None\n        for actor in self.actors:\n            if not actor.skip:\n                result = actor\n                break\n        return result", "response": "Returns the first non - skipped actor."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the last non - skipped actor.", "response": "def last_active(self):\n        \"\"\"\n        Returns the last non-skipped actor.\n\n        :return: the last active actor, None if not available\n        :rtype: Actor\n        \"\"\"\n        result = None\n        for actor in reversed(self.actors):\n            if not actor.skip:\n                result = actor\n                break\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef index_of(self, name):\n        result = -1\n        for index, actor in enumerate(self.actors):\n            if actor.name == name:\n                result = index\n                break\n        return result", "response": "Returns the index of the actor with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup(self):\n        result = super(ActorHandler, self).setup()\n        if result is None:\n            self.update_parent()\n            try:\n                self.check_actors(self.actors)\n            except Exception as e:\n                result = str(e)\n        if result is None:\n            for actor in self.actors:\n                name = actor.name\n                newname = actor.unique_name(actor.name)\n                if name != newname:\n                    actor.name = newname\n        if result is None:\n            for actor in self.actors:\n                if actor.skip:\n                    continue\n                result = actor.setup()\n                if result is not None:\n                    break\n        if result is None:\n            result = self._director.setup()\n        return result", "response": "Sets up the actor before execution."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps up the actor handler.", "response": "def wrapup(self):\n        \"\"\"\n        Finishes up after execution finishes, does not remove any graphical output.\n        \"\"\"\n        for actor in self.actors:\n            if actor.skip:\n                continue\n            actor.wrapup()\n        super(ActorHandler, self).wrapup()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cleanup(self):\n        for actor in self.actors:\n            if actor.skip:\n                continue\n            actor.cleanup()\n        super(ActorHandler, self).cleanup()", "response": "Cleanup all resources that were created by the actor handler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop execution of the object.", "response": "def stop_execution(self):\n        \"\"\"\n        Triggers the stopping of the object.\n        \"\"\"\n        if not (self._stopping or self._stopped):\n            for actor in self.owner.actors:\n                actor.stop_execution()\n            self._stopping = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_actors(self, actors):\n        super(Flow, self).check_actors(actors)\n        actor = self.first_active\n        if (actor is not None) and not base.is_source(actor):\n            raise Exception(\"First active actor is not a source: \" + actor.full_name)", "response": "Checks that the given actors are valid. Raises an exception if invalid setup."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the flow from a JSON file.", "response": "def load(cls, fname):\n        \"\"\"\n        Loads the flow from a JSON file.\n\n        :param fname: the file to load\n        :type fname: str\n        :return: the flow\n        :rtype: Flow\n        \"\"\"\n        with open(fname) as f:\n            content = f.readlines()\n        return Flow.from_json(''.join(content))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new director instance for handling the sub - actors.", "response": "def new_director(self):\n        \"\"\"\n        Creates the director to use for handling the sub-actors.\n\n        :return: the director instance\n        :rtype: Director\n        \"\"\"\n        result = SequentialDirector(self)\n        result.record_output = False\n        result.allow_source = False\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking that the given list of actors are valid. Raises an exception if invalid setup.", "response": "def check_actors(self, actors):\n        \"\"\"\n        Performs checks on the actors that are to be used. Raises an exception if invalid setup.\n\n        :param actors: the actors to check\n        :type actors: list\n        \"\"\"\n        super(Sequence, self).check_actors(actors)\n        actor = self.first_active\n        if (actor is not None) and not isinstance(actor, InputConsumer):\n            raise Exception(\"First active actor does not accept input: \" + actor.full_name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_execute(self):\n        self.first_active.input = self.input\n        result = self._director.execute()\n        if result is None:\n            self._output.append(self.input)\n        return result", "response": "Execute the actor s director and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_config(self, options):\n        options = super(Tee, self).fix_config(options)\n\n        opt = \"condition\"\n        if opt not in options:\n            options[opt] = \"True\"\n        if opt not in self.help:\n            self.help[opt] = \"The (optional) condition for teeing off the tokens; uses the 'eval' method, \"\\\n                             \"ie the expression must evaluate to a boolean value; storage values placeholders \"\\\n                             \"'@{...}' get replaced with their string representations before evaluating the \"\\\n                             \"expression (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_actors(self, actors):\n        super(Tee, self).check_actors(actors)\n        actor = self.first_active\n        if actor is None:\n            if self._requires_active_actors:\n                raise Exception(\"No active actor!\")\n        elif not isinstance(actor, InputConsumer):\n            raise Exception(\"First active actor does not accept input: \" + actor.full_name)", "response": "Checks that the given actors are valid. Raises an exception if invalid setup."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(Trigger, self).fix_config(options)\n\n        opt = \"condition\"\n        if opt not in options:\n            options[opt] = \"True\"\n        if opt not in self.help:\n            self.help[opt] = \"The (optional) condition for teeing off the tokens; uses the 'eval' method, \"\\\n                             \"ie the expression must evaluate to a boolean value; storage values placeholders \"\\\n                             \"'@{...}' get replaced with their string representations before evaluating the \"\\\n                             \"expression (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_actors(self):\n        actors = []\n        for actor in self.owner.actors:\n            if actor.skip:\n                continue\n            actors.append(actor)\n        if len(actors) == 0:\n            return\n        for actor in actors:\n            if not isinstance(actor, InputConsumer):\n                raise Exception(\"Actor does not accept any input: \" + actor.full_name)", "response": "Checks the actors of the owner. Raises an exception if invalid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_execute(self):\n\n        result = None\n        self._stopped = False\n        self._stopping = False\n\n        for actor in self.owner.actors:\n            if self.is_stopping() or self.is_stopped():\n                break\n            actor.input = self.owner.input\n            result = actor.execute()\n            if result is not None:\n                break\n\n        return result", "response": "Actual execution of the director.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfix the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(ContainerValuePicker, self).fix_config(options)\n\n        opt = \"value\"\n        if opt not in options:\n            options[opt] = \"Model\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the container value to pick from the container (string).\"\n\n        opt = \"switch\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to switch the ouputs, i.e., forward the container to the sub-flow and the \" \\\n                             + \"container value to the following actor instead (bool).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_config(self, options):\n        options = super(CommandlineToAny, self).fix_config(options)\n\n        opt = \"wrapper\"\n        if opt not in options:\n            options[opt] = \"weka.core.classes.OptionHandler\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the wrapper class to use (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the input object is a valid ISO 3166 - 1 version of the object. Raises an exception if unsupported.", "response": "def check_input(self, obj):\n        \"\"\"\n        Performs checks on the input object. Raises an exception if unsupported.\n\n        :param obj: the object to check\n        :type obj: object\n        \"\"\"\n        if isinstance(obj, str):\n            return\n        if isinstance(obj, unicode):\n            return\n        raise Exception(\"Unsupported class: \" + self._input.__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert(self):\n        cname = str(self.config[\"wrapper\"])\n        self._output = classes.from_commandline(self._input, classname=cname)\n        return None", "response": "Performs the actual conversion."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_experiment(mat, title=\"Experiment\", axes_swapped=False, measure=\"Statistic\", show_stdev=False,\n                    key_loc=\"lower right\", outfile=None, wait=True):\n    \"\"\"\n    Plots the results from an experiment.\n\n    :param mat: the result matrix to plot\n    :type mat: ResultMatrix\n    :param title: the title for the experiment\n    :type title: str\n    :param axes_swapped: whether the axes whether swapped (\"sets x cls\" or \"cls x sets\")\n    :type axes_swapped: bool\n    :param measure: the measure that is being displayed\n    :type measure: str\n    :param show_stdev: whether to show the standard deviation as error bar\n    :type show_stdev: bool\n    :param key_loc: the location string for the key\n    :type key_loc: str\n    :param outfile: the output file, ignored if None\n    :type outfile: str\n    :param wait: whether to wait for the user to close the plot\n    :type wait: bool\n    \"\"\"\n\n    if not plot.matplotlib_available:\n        logger.error(\"Matplotlib is not installed, plotting unavailable!\")\n        return\n\n    if not isinstance(mat, ResultMatrix):\n        logger.error(\"Need to supply a result matrix!\")\n        return\n\n    fig, ax = plt.subplots()\n    if axes_swapped:\n        ax.set_xlabel(measure)\n        ax.set_ylabel(\"Classifiers\")\n    else:\n        ax.set_xlabel(\"Classifiers\")\n        ax.set_ylabel(measure)\n    ax.set_title(title)\n    fig.canvas.set_window_title(title)\n    ax.grid(True)\n    ticksx = []\n    ticks = []\n    inc = 1.0 / float(mat.columns)\n    for i in range(mat.columns):\n        ticksx.append((i + 0.5) * inc)\n        ticks.append(\"[\" + str(i+1) + \"]\")\n    plt.xticks(ticksx, ticks)\n    plt.xlim([0.0, 1.0])\n    for r in range(mat.rows):\n        x = []\n        means = []\n        stdevs = []\n        for c in range(mat.columns):\n            mean = mat.get_mean(c, r)\n            stdev = mat.get_stdev(c, r)\n            if not math.isnan(mean):\n                x.append((c + 0.5) * inc)\n                means.append(mean)\n                if not math.isnan(stdev):\n                    stdevs.append(stdev)\n        plot_label = mat.get_row_name(r)\n        if show_stdev:\n            ax.errorbar(x, means, yerr=stdevs, fmt='-o', ls=\"-\", label=plot_label)\n        else:\n            ax.plot(x, means, \"o-\", label=plot_label)\n    plt.draw()\n    plt.legend(loc=key_loc, shadow=True)\n    if outfile is not None:\n        plt.savefig(outfile)\n    if wait:\n        plt.show()", "response": "Plots the results from an experiment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_subsample(data, percent, seed=1):\n    if percent <= 0 or percent >= 100:\n        return data\n    data = Instances.copy_instances(data)\n    data.randomize(Random(seed))\n    data = Instances.copy_instances(data, 0, int(round(data.num_instances * percent / 100.0)))\n    return data", "response": "Generates a subsample of the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef predictions_to_instances(data, preds):\n    if len(preds) == 0:\n        return None\n\n    is_numeric = isinstance(preds[0], NumericPrediction)\n\n    # create header\n    atts = []\n    if is_numeric:\n        atts.append(Attribute.create_numeric(\"index\"))\n        atts.append(Attribute.create_numeric(\"weight\"))\n        atts.append(Attribute.create_numeric(\"actual\"))\n        atts.append(Attribute.create_numeric(\"predicted\"))\n        atts.append(Attribute.create_numeric(\"error\"))\n    else:\n        atts.append(Attribute.create_numeric(\"index\"))\n        atts.append(Attribute.create_numeric(\"weight\"))\n        atts.append(data.class_attribute.copy(name=\"actual\"))\n        atts.append(data.class_attribute.copy(name=\"predicted\"))\n        atts.append(Attribute.create_nominal(\"error\", [\"no\", \"yes\"]))\n        atts.append(Attribute.create_numeric(\"classification\"))\n        for i in range(data.class_attribute.num_values):\n            atts.append(Attribute.create_numeric(\"distribution-\" + data.class_attribute.value(i)))\n\n    result = Instances.create_instances(\"Predictions\", atts, len(preds))\n\n    count = 0\n    for pred in preds:\n        count += 1\n        if is_numeric:\n            values = array([count, pred.weight, pred.actual, pred.predicted, pred.error])\n        else:\n            if pred.actual == pred.predicted:\n                error = 0.0\n            else:\n                error = 1.0\n            l = [count, pred.weight, pred.actual, pred.predicted, error, max(pred.distribution)]\n            for i in range(data.class_attribute.num_values):\n                l.append(pred.distribution[i])\n            values = array(l)\n        inst = Instance.create_instance(values)\n        result.add_instance(inst)\n\n    return result", "response": "Converts the predictions to Instances object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the class distributions for the Instances object.", "response": "def distributions_for_instances(self, data):\n        \"\"\"\n        Peforms predictions, returning the class distributions.\n\n        :param data: the Instances to get the class distributions for\n        :type data: Instances\n        :return: the class distribution matrix, None if not a batch predictor\n        :rtype: ndarray\n        \"\"\"\n        if self.is_batchpredictor:\n            return typeconv.double_matrix_to_ndarray(self.__distributions(data.jobject))\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the batch size in case this classifier is a batch predictor.", "response": "def batch_size(self, size):\n        \"\"\"\n        Sets the batch size, in case this classifier is a batch predictor.\n\n        :param size: the size of the batch\n        :type size: str\n        \"\"\"\n        if self.is_batchpredictor:\n            javabridge.call(self.jobject, \"setBatchSize\", \"(Ljava/lang/String;)V\", size)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_source(self, classname):\n        if not self.check_type(self.jobject, \"weka.classifiers.Sourcable\"):\n            return None\n        return javabridge.call(self.jobject, \"toSource\", \"(Ljava/lang/String;)Ljava/lang/String;\", classname)", "response": "Returns the model as Java source code if the classifier implements weka. classifiers. Sourcable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the statistic to use for evaluation.", "response": "def evaluation(self, evl):\n        \"\"\"\n        Sets the statistic to use for evaluation.\n\n        :param evl: the statistic\n        :type evl: SelectedTag, Tag or str\n        \"\"\"\n        if isinstance(evl, str):\n            evl = self.tags_evaluation.find(evl)\n        if isinstance(evl, Tag):\n            evl = SelectedTag(tag_id=evl.ident, tags=self.tags_evaluation)\n        javabridge.call(self.jobject, \"setEvaluation\", \"(Lweka/core/SelectedTag;)V\", evl.jobject)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the current values for the X of the grid.", "response": "def x(self):\n        \"\"\"\n        Returns a dictionary with all the current values for the X of the grid.\n        Keys for the dictionary: property, min, max, step, base, expression\n        Types: property=str, min=float, max=float, step=float, base=float, expression=str\n\n        :return: the dictionary with the parameters\n        :rtype: dict\n        \"\"\"\n        result = {}\n        result[\"property\"] = javabridge.call(self.jobject, \"getXProperty\", \"()Ljava/lang/String;\")\n        result[\"min\"] = javabridge.call(self.jobject, \"getXMin\", \"()D\")\n        result[\"max\"] = javabridge.call(self.jobject, \"getXMax\", \"()D\")\n        result[\"step\"] = javabridge.call(self.jobject, \"getXStep\", \"()D\")\n        result[\"base\"] = javabridge.call(self.jobject, \"getXBase\", \"()D\")\n        result[\"expression\"] = javabridge.call(self.jobject, \"getXExpression\", \"()Ljava/lang/String;\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the X property of the grid with one method call.", "response": "def x(self, d):\n        \"\"\"\n        Allows to configure the X of the grid with one method call.\n        Keys for the dictionary: property, min, max, step, base, expression\n        Types: property=str, min=float, max=float, step=float, base=float, expression=str\n\n        :param d: the dictionary with the parameters\n        :type d: dict\n        \"\"\"\n        if \"property\" in d:\n            javabridge.call(self.jobject, \"setXProperty\", \"(Ljava/lang/String;)V\", d[\"property\"])\n        if \"min\" in d:\n            javabridge.call(self.jobject, \"setXMin\", \"(D)V\", d[\"min\"])\n        if \"max\" in d:\n            javabridge.call(self.jobject, \"setXMax\", \"(D)V\", d[\"max\"])\n        if \"step\" in d:\n            javabridge.call(self.jobject, \"setXStep\", \"(D)V\", d[\"step\"])\n        if \"base\" in d:\n            javabridge.call(self.jobject, \"setXBase\", \"(D)V\", d[\"base\"])\n        if \"expression\" in d:\n            javabridge.call(self.jobject, \"setXExpression\", \"(Ljava/lang/String;)V\", d[\"expression\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef y(self):\n        result = {}\n        result[\"property\"] = javabridge.call(self.jobject, \"getYProperty\", \"()Ljava/lang/String;\")\n        result[\"min\"] = javabridge.call(self.jobject, \"getYMin\", \"()D\")\n        result[\"max\"] = javabridge.call(self.jobject, \"getYMax\", \"()D\")\n        result[\"step\"] = javabridge.call(self.jobject, \"getYStep\", \"()D\")\n        result[\"base\"] = javabridge.call(self.jobject, \"getYBase\", \"()D\")\n        result[\"expression\"] = javabridge.call(self.jobject, \"getYExpression\", \"()Ljava/lang/String;\")\n        return result", "response": "Returns the current values for the Y of the grid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef y(self, d):\n        if \"property\" in d:\n            javabridge.call(self.jobject, \"setYProperty\", \"(Ljava/lang/String;)V\", d[\"property\"])\n        if \"min\" in d:\n            javabridge.call(self.jobject, \"setYMin\", \"(D)V\", d[\"min\"])\n        if \"max\" in d:\n            javabridge.call(self.jobject, \"setYMax\", \"(D)V\", d[\"max\"])\n        if \"step\" in d:\n            javabridge.call(self.jobject, \"setYStep\", \"(D)V\", d[\"step\"])\n        if \"base\" in d:\n            javabridge.call(self.jobject, \"setYBase\", \"(D)V\", d[\"base\"])\n        if \"expression\" in d:\n            javabridge.call(self.jobject, \"setYExpression\", \"(Ljava/lang/String;)V\", d[\"expression\"])", "response": "Sets the Y property of the current grid with one method call."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef classifiers(self):\n        objects = javabridge.get_env().get_object_array_elements(\n            javabridge.call(self.jobject, \"getClassifiers\", \"()[Lweka/classifiers/Classifier;\"))\n        result = []\n        for obj in objects:\n            result.append(Classifier(jobject=obj))\n        return result", "response": "Returns the list of base classifiers."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the base classifiers.", "response": "def classifiers(self, classifiers):\n        \"\"\"\n        Sets the base classifiers.\n\n        :param classifiers: the list of base classifiers to use\n        :type classifiers: list\n        \"\"\"\n        obj = []\n        for classifier in classifiers:\n            obj.append(classifier.jobject)\n        javabridge.call(self.jobject, \"setClassifiers\", \"([Lweka/classifiers/Classifier;)V\", obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eval(self, id1, id2, inst1):\n        jinst1 = None\n        if inst1 is not None:\n            jinst1 = inst1.jobject\n        return javabridge.call(self.jobject, \"eval\", \"(IILweka/core/Instance;)D\", id1, id2, jinst1)", "response": "Computes the kernel function for two instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the current kernel.", "response": "def kernel(self):\n        \"\"\"\n        Returns the current kernel.\n\n        :return: the kernel or None if none found\n        :rtype: Kernel\n        \"\"\"\n        result = javabridge.static_call(\n            \"weka/classifiers/KernelHelper\", \"getKernel\",\n            \"(Ljava/lang/Object;)Lweka/classifiers/functions/supportVector/Kernel;\",\n            self.jobject)\n        if result is None:\n            return None\n        else:\n            return Kernel(jobject=result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the kernel. :param kernel: the kernel to set :type kernel: Kernel", "response": "def kernel(self, kernel):\n        \"\"\"\n        Sets the kernel.\n\n        :param kernel: the kernel to set\n        :type kernel: Kernel\n        \"\"\"\n        result = javabridge.static_call(\n            \"weka/classifiers/KernelHelper\", \"setKernel\",\n            \"(Ljava/lang/Object;Lweka/classifiers/functions/supportVector/Kernel;)Z\",\n            self.jobject, kernel.jobject)\n        if not result:\n            raise Exception(\"Failed to set kernel!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\napply the cost matrix to the data.", "response": "def apply_cost_matrix(self, data, rnd):\n        \"\"\"\n        Applies the cost matrix to the data.\n\n        :param data: the data to apply to\n        :type data: Instances\n        :param rnd: the random number generator\n        :type rnd: Random\n        \"\"\"\n        return Instances(\n            javabridge.call(\n                self.jobject, \"applyCostMatrix\", \"(Lweka/core/Instances;Ljava/util/Random;)Lweka/core/Instances;\",\n                data.jobject, rnd.jobject))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the expected misclassification cost for each possible class value given class probability estimates.", "response": "def expected_costs(self, class_probs, inst=None):\n        \"\"\"\n        Calculates the expected misclassification cost for each possible class value, given class probability\n        estimates.\n\n        :param class_probs: the class probabilities\n        :type class_probs: ndarray\n        :return: the calculated costs\n        :rtype: ndarray\n        \"\"\"\n        if inst is None:\n            costs = javabridge.call(\n                self.jobject, \"expectedCosts\", \"([D)[D\", javabridge.get_env().make_double_array(class_probs))\n            return javabridge.get_env().get_double_array_elements(costs)\n        else:\n            costs = javabridge.call(\n                self.jobject, \"expectedCosts\", \"([DLweka/core/Instance;)[D\",\n                javabridge.get_env().make_double_array(class_probs), inst.jobject)\n            return javabridge.get_env().get_double_array_elements(costs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the JB_Object at the specified location.", "response": "def get_cell(self, row, col):\n        \"\"\"\n        Returns the JB_Object at the specified location.\n\n        :param row: the 0-based index of the row\n        :type row: int\n        :param col: the 0-based index of the column\n        :type col: int\n        :return: the object in that cell\n        :rtype: JB_Object\n        \"\"\"\n        return javabridge.call(\n            self.jobject, \"getCell\", \"(II)Ljava/lang/Object;\", row, col)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the JB_Object at the specified location. Automatically unwraps JavaObject.", "response": "def set_cell(self, row, col, obj):\n        \"\"\"\n        Sets the JB_Object at the specified location. Automatically unwraps JavaObject.\n\n        :param row: the 0-based index of the row\n        :type row: int\n        :param col: the 0-based index of the column\n        :type col: int\n        :param obj: the object for that cell\n        :type obj: object\n        \"\"\"\n        if isinstance(obj, JavaObject):\n            obj = obj.jobject\n        javabridge.call(\n            self.jobject, \"setCell\", \"(IILjava/lang/Object;)V\", row, col, obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the value at the specified location.", "response": "def get_element(self, row, col, inst=None):\n        \"\"\"\n        Returns the value at the specified location.\n\n        :param row: the 0-based index of the row\n        :type row: int\n        :param col: the 0-based index of the column\n        :type col: int\n        :param inst: the Instace\n        :type inst: Instance\n        :return: the value in that cell\n        :rtype: float\n        \"\"\"\n        if inst is None:\n            return javabridge.call(\n                self.jobject, \"getElement\", \"(II)D\", row, col)\n        else:\n            return javabridge.call(\n                self.jobject, \"getElement\", \"(IILweka/core/Instance;)D\", row, col, inst.jobject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the value at the specified location.", "response": "def set_element(self, row, col, value):\n        \"\"\"\n        Sets the float value at the specified location.\n\n        :param row: the 0-based index of the row\n        :type row: int\n        :param col: the 0-based index of the column\n        :type col: int\n        :param value: the float value for that cell\n        :type value: float\n        \"\"\"\n        javabridge.call(\n            self.jobject, \"setElement\", \"(IID)V\", row, col, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the maximum cost for a particular class value.", "response": "def get_max_cost(self, class_value, inst=None):\n        \"\"\"\n        Gets the maximum cost for a particular class value.\n\n        :param class_value: the class value to get the maximum cost for\n        :type class_value: int\n        :param inst: the Instance\n        :type inst: Instance\n        :return: the cost\n        :rtype: float\n        \"\"\"\n        if inst is None:\n            return javabridge.call(\n                self.jobject, \"getMaxCost\", \"(I)D\", class_value)\n        else:\n            return javabridge.call(\n                self.jobject, \"getElement\", \"(ILweka/core/Instance;)D\", class_value, inst.jobject)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a summary. :param title: optional title :type title: str :param complexity: whether to print the complexity information as well :type complexity: bool :return: the summary :rtype: str", "response": "def summary(self, title=None, complexity=False):\n        \"\"\"\n        Generates a summary.\n\n        :param title: optional title\n        :type title: str\n        :param complexity: whether to print the complexity information as well\n        :type complexity: bool\n        :return: the summary\n        :rtype: str\n        \"\"\"\n        if title is None:\n            return javabridge.call(\n                self.jobject, \"toSummaryString\", \"()Ljava/lang/String;\")\n        else:\n            return javabridge.call(\n                self.jobject, \"toSummaryString\", \"(Ljava/lang/String;Z)Ljava/lang/String;\", title, complexity)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef class_details(self, title=None):\n        if title is None:\n            return javabridge.call(\n                self.jobject, \"toClassDetailsString\", \"()Ljava/lang/String;\")\n        else:\n            return javabridge.call(\n                self.jobject, \"toClassDetailsString\", \"(Ljava/lang/String;)Ljava/lang/String;\", title)", "response": "Generates the class details."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate the confusion matrix.", "response": "def matrix(self, title=None):\n        \"\"\"\n        Generates the confusion matrix.\n\n        :param title: optional title\n        :type title: str\n        :return: the matrix\n        :rtype: str\n        \"\"\"\n        if title is None:\n            return javabridge.call(self.jobject, \"toMatrixString\", \"()Ljava/lang/String;\")\n        else:\n            return javabridge.call(self.jobject, \"toMatrixString\", \"(Ljava/lang/String;)Ljava/lang/String;\", title)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef predictions(self):\n        preds = javabridge.get_collection_wrapper(\n            javabridge.call(self.jobject, \"predictions\", \"()Ljava/util/ArrayList;\"))\n        if self.discard_predictions:\n            result = None\n        else:\n            result = []\n            for pred in preds:\n                if is_instance_of(pred, \"weka.classifiers.evaluation.NominalPrediction\"):\n                    result.append(NominalPrediction(pred))\n                elif is_instance_of(pred, \"weka.classifiers.evaluation.NumericPrediction\"):\n                    result.append(NumericPrediction(pred))\n                else:\n                    result.append(Prediction(pred))\n        return result", "response": "Returns the predictions.\n\n        :return: the predictions. None if not available\n        :rtype: list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_all(self, cls, data):\n        javabridge.call(\n            self.jobject, \"print\", \"(Lweka/classifiers/Classifier;Lweka/core/Instances;)V\",\n            cls.jobject, data.jobject)", "response": "Prints the header classifications and footer to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_classifications(self, cls, data):\n        javabridge.call(\n            self.jobject, \"printClassifications\", \"(Lweka/classifiers/Classifier;Lweka/core/Instances;)V\",\n            cls.jobject, data.jobject)", "response": "Prints the classifications to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_classification(self, cls, inst, index):\n        javabridge.call(\n            self.jobject, \"printClassification\", \"(Lweka/classifiers/Classifier;Lweka/core/Instance;I)V\",\n            cls.jobject, inst.jobject, index)", "response": "Prints the classification to the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a datagenerator from the command-line. Calls JVM start/stop automatically. Use -h to see all options.", "response": "def main():\n    \"\"\"\n    Runs a datagenerator from the command-line. Calls JVM start/stop automatically.\n    Use -h to see all options.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Executes a data generator from the command-line. Calls JVM start/stop automatically.')\n    parser.add_argument(\"-j\", metavar=\"classpath\", dest=\"classpath\", help=\"additional classpath, jars/directories\")\n    parser.add_argument(\"-X\", metavar=\"heap\", dest=\"heap\", help=\"max heap size for jvm, e.g., 512m\")\n    parser.add_argument(\"datagenerator\", help=\"data generator classname, e.g., \"\n                                              + \"weka.datagenerators.classifiers.classification.LED24\")\n    parser.add_argument(\"option\", nargs=argparse.REMAINDER, help=\"additional data generator options\")\n    parsed = parser.parse_args()\n    jars = []\n    if parsed.classpath is not None:\n        jars = parsed.classpath.split(os.pathsep)\n\n    jvm.start(jars, max_heap_size=parsed.heap, packages=True)\n\n    logger.debug(\"Commandline: \" + join_options(sys.argv[1:]))\n\n    try:\n        generator = DataGenerator(classname=parsed.datagenerator)\n        if len(parsed.option) > 0:\n            generator.options = parsed.option\n        DataGenerator.make_data(generator, parsed.option)\n    except Exception as e:\n        print(e)\n    finally:\n        jvm.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef define_data_format(self):\n        data = javabridge.call(self.jobject, \"defineDataFormat\", \"()Lweka/core/Instances;\")\n        if data is None:\n            return None\n        else:\n            return Instances(data)", "response": "Returns the data format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataset_format(self):\n        data = javabridge.call(self.jobject, \"getDatasetFormat\", \"()Lweka/core/Instances;\")\n        if data is None:\n            return None\n        else:\n            return Instances(data)", "response": "Returns the dataset format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a single instance.", "response": "def generate_example(self):\n        \"\"\"\n        Returns a single Instance.\n\n        :return: the next example\n        :rtype: Instance\n        \"\"\"\n        data = javabridge.call(self.jobject, \"generateExample\", \"()Lweka/core/Instance;\")\n        if data is None:\n            return None\n        else:\n            return Instance(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_examples(self):\n        data = javabridge.call(self.jobject, \"generateExamples\", \"()Lweka/core/Instances;\")\n        if data is None:\n            return None\n        else:\n            return Instances(data)", "response": "Generates the complete dataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a copy of the generator.", "response": "def make_copy(cls, generator):\n        \"\"\"\n        Creates a copy of the generator.\n\n        :param generator: the generator to copy\n        :type generator: DataGenerator\n        :return: the copy of the generator\n        :rtype: DataGenerator\n        \"\"\"\n        return from_commandline(\n            to_commandline(generator), classname=classes.get_classname(DataGenerator()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfix the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(FileSupplier, self).fix_config(options)\n\n        opt = \"files\"\n        if opt not in options:\n            options[opt] = []\n        if opt not in self.help:\n            self.help[opt] = \"The files to output (list of string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_execute(self):\n        for f in self.resolve_option(\"files\"):\n            self._output.append(Token(f))\n        return None", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a short string describing some of the options of the actor.", "response": "def quickinfo(self):\n        \"\"\"\n        Returns a short string describing some of the options of the actor.\n\n        :return: the info, None if not available\n        :rtype: str\n        \"\"\"\n        return \"dir: \" + str(self.config[\"dir\"]) \\\n               + \", files: \" + str(self.config[\"list_files\"]) \\\n               + \", dirs: \" + str(self.resolve_option(\"list_dirs\")) \\\n               + \", recursive: \" + str(self.config[\"recursive\"])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_config(self, options):\n        options = super(ListFiles, self).fix_config(options)\n\n        opt = \"dir\"\n        if opt not in options:\n            options[opt] = \".\"\n        if opt not in self.help:\n            self.help[opt] = \"The directory to search (string).\"\n\n        opt = \"recursive\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to search recursively (bool).\"\n\n        opt = \"list_files\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to include files (bool).\"\n\n        opt = \"list_dirs\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to include directories (bool).\"\n\n        opt = \"regexp\"\n        if opt not in options:\n            options[opt] = \".*\"\n        if opt not in self.help:\n            self.help[opt] = \"The regular expression that files/dirs must match (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all the files and directories in the specified directory.", "response": "def _list(self, path, collected):\n        \"\"\"\n        Lists all the files/dirs in directory that match the pattern.\n\n        :param path: the directory to search\n        :type path: str\n        :param collected: the files/dirs collected so far (full path)\n        :type collected: list\n        :return: None if successful, error otherwise\n        :rtype: str\n        \"\"\"\n        list_files = self.resolve_option(\"list_files\")\n        list_dirs = self.resolve_option(\"list_dirs\")\n        recursive = self.resolve_option(\"recursive\")\n        spattern = str(self.resolve_option(\"regexp\"))\n        pattern = None\n        if (spattern is not None) and (spattern != \".*\"):\n            pattern = re.compile(spattern)\n\n        try:\n            items = os.listdir(path)\n            for item in items:\n                fp = path + os.sep + item\n                if list_files and os.path.isfile(fp):\n                    if (pattern is None) or pattern.match(item):\n                        collected.append(fp)\n                if list_dirs and os.path.isdir(fp):\n                    if (pattern is None) or pattern.match(item):\n                        collected.append(fp)\n                if recursive and os.path.isdir(fp):\n                    self._list(fp, collected)\n        except Exception as e:\n            return \"Error listing '\" + path + \"': \" + str(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the actor s command.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        directory = str(self.resolve_option(\"dir\"))\n        if not os.path.exists(directory):\n            return \"Directory '\" + directory + \"' does not exist!\"\n        if not os.path.isdir(directory):\n            return \"Location '\" + directory + \"' is not a directory!\"\n        collected = []\n        result = self._list(directory, collected)\n        if result is None:\n            for c in collected:\n                self._output.append(Token(c))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_config(self, options):\n        options = super(GetStorageValue, self).fix_config(options)\n\n        opt = \"storage_name\"\n        if opt not in options:\n            options[opt] = \"unknown\"\n        if opt not in self.help:\n            self.help[opt] = \"The name of the storage value to retrieve (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfix the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(ForLoop, self).fix_config(options)\n\n        opt = \"min\"\n        if opt not in options:\n            options[opt] = 1\n        if opt not in self.help:\n            self.help[opt] = \"The minimum for the loop (included, int).\"\n\n        opt = \"max\"\n        if opt not in options:\n            options[opt] = 10\n        if opt not in self.help:\n            self.help[opt] = \"The maximum for the loop (included, int).\"\n\n        opt = \"step\"\n        if opt not in options:\n            options[opt] = 1\n        if opt not in self.help:\n            self.help[opt] = \"The step size (int).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_execute(self):\n        for i in range(\n                int(self.resolve_option(\"min\")),\n                int(self.resolve_option(\"max\")) + 1,\n                int(self.resolve_option(\"step\"))):\n            self._output.append(Token(i))\n        return None", "response": "Execute the actor s execution."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fix_config(self, options):\n        opt = \"db_url\"\n        if opt not in options:\n            options[opt] = \"jdbc:mysql://somehost:3306/somedatabase\"\n        if opt not in self.help:\n            self.help[opt] = \"The JDBC database URL to connect to (str).\"\n\n        opt = \"user\"\n        if opt not in options:\n            options[opt] = \"user\"\n        if opt not in self.help:\n            self.help[opt] = \"The database user to use for connecting (str).\"\n\n        opt = \"password\"\n        if opt not in options:\n            options[opt] = \"secret\"\n        if opt not in self.help:\n            self.help[opt] = \"The password for the database user (str).\"\n\n        opt = \"query\"\n        if opt not in options:\n            options[opt] = \"SELECT * FROM table\"\n        if opt not in self.help:\n            self.help[opt] = \"The SQL query for generating the dataset (str).\"\n\n        opt = \"sparse\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to return the data in sparse format (bool).\"\n\n        opt = \"custom_props\"\n        if opt not in options:\n            options[opt] = \"\"\n        if opt not in self.help:\n            self.help[opt] = \"Custom properties filename (str).\"\n\n        return super(LoadDatabase, self).fix_config(options)", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting the actor s command and returns the result of the actor s command.", "response": "def do_execute(self):\n        \"\"\"\n        The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        iquery = InstanceQuery()\n        iquery.db_url = str(self.resolve_option(\"db_url\"))\n        iquery.user = str(self.resolve_option(\"user\"))\n        iquery.password = str(self.resolve_option(\"password\"))\n        props = str(self.resolve_option(\"custom_props\"))\n        if (len(props) > 0) and os.path.isfile(props):\n            iquery.custom_properties = props\n        iquery.query = str(self.resolve_option(\"query\"))\n        data = iquery.retrieve_instances()\n        self._output.append(Token(data))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_config(self, options):\n        opt = \"setup\"\n        if opt not in options:\n            options[opt] = datagen.DataGenerator(classname=\"weka.datagenerators.classifiers.classification.Agrawal\")\n        if opt not in self.help:\n            self.help[opt] = \"The data generator to use (DataGenerator).\"\n\n        opt = \"incremental\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to output the data incrementally, in case the generator supports that (bool).\"\n\n        return super(DataGenerator, self).fix_config(options)", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhooking method that allows conversion of individual options to config objects.", "response": "def to_config(self, k, v):\n        \"\"\"\n        Hook method that allows conversion of individual options.\n\n        :param k: the key of the option\n        :type k: str\n        :param v: the value\n        :type v: object\n        :return: the potentially processed value\n        :rtype: object\n        \"\"\"\n        if k == \"setup\":\n            return base.to_commandline(v)\n        return super(DataGenerator, self).to_config(k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_config(self, k, v):\n        if k == \"setup\":\n            return from_commandline(v, classname=to_commandline(datagen.DataGenerator()))\n        return super(DataGenerator, self).from_config(k, v)", "response": "Hook method that allows converting values from the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_execute(self):\n        generator = datagen.DataGenerator.make_copy(self.resolve_option(\"setup\"))\n        generator.dataset_format = generator.define_data_format()\n        if bool(self.resolve_option(\"incremental\")) and generator.single_mode_flag:\n            for i in range(generator.num_examples_act):\n                self._output.append(Token(generator.generate_example()))\n        else:\n            data = generator.generate_examples()\n            self._output.append(Token(data))\n        return None", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(CombineStorage, self).fix_config(options)\n\n        opt = \"format\"\n        if opt not in options:\n            options[opt] = \"\"\n        if opt not in self.help:\n            self.help[opt] = \"The format to use for generating the combined string; use '@{blah}' for accessing \"\\\n                             \"storage item 'blah' (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_execute(self):\n        formatstr = str(self.resolve_option(\"format\"))\n        expanded = self.storagehandler.expand(formatstr)\n        self._output.append(Token(expanded))\n        return None", "response": "The actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfix the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(StringConstants, self).fix_config(options)\n\n        opt = \"strings\"\n        if opt not in options:\n            options[opt] = []\n        if opt not in self.help:\n            self.help[opt] = \"The strings to output (list of string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_execute(self):\n        for s in self.resolve_option(\"strings\"):\n            self._output.append(Token(s))\n        return None", "response": "Execute the actual execution of the actor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall after the actual execution of the sink.", "response": "def post_execute(self):\n        \"\"\"\n        Gets executed after the actual execution.\n\n        :return: None if successful, otherwise error message\n        :rtype: str\n        \"\"\"\n        result = super(Sink, self).post_execute()\n        if result is None:\n            self._input = None\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfixing the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(Console, self).fix_config(options)\n\n        opt = \"prefix\"\n        if opt not in options:\n            options[opt] = \"\"\n        if opt not in self.help:\n            self.help[opt] = \"The prefix for the output (string).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fix_config(self, options):\n        options = super(FileOutputSink, self).fix_config(options)\n\n        opt = \"output\"\n        if opt not in options:\n            options[opt] = \".\"\n        if opt not in self.help:\n            self.help[opt] = \"The file to write to (string).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_config(self, options):\n        options = super(DumpFile, self).fix_config(options)\n\n        opt = \"append\"\n        if opt not in options:\n            options[opt] = False\n        if opt not in self.help:\n            self.help[opt] = \"Whether to append to the file or overwrite (bool).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the file or overwrite ( bool )."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_input(self, token):\n        if not isinstance(token.payload, ModelContainer):\n            raise Exception(self.full_name + \": Input token is not a ModelContainer!\")", "response": "Checks that the input token is a ModelContainer. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_execute(self):\n        result = None\n        cont = self.input.payload\n        serialization.write_all(\n            str(self.resolve_option(\"output\")),\n            [cont.get(\"Model\").jobject, cont.get(\"Header\").jobject])\n        return result", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_config(self, options):\n        options = super(MatrixPlot, self).fix_config(options)\n\n        opt = \"percent\"\n        if opt not in options:\n            options[opt] = 100.0\n        if opt not in self.help:\n            self.help[opt] = \"The percentage of the data to display (0-100, float).\"\n\n        opt = \"seed\"\n        if opt not in options:\n            options[opt] = 1\n        if opt not in self.help:\n            self.help[opt] = \"The seed value for randomizing the plot when viewing a subset (int).\"\n\n        opt = \"size\"\n        if opt not in options:\n            options[opt] = 10\n        if opt not in self.help:\n            self.help[opt] = \"The size of the circles in the plot (int).\"\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the plot (str).\"\n\n        opt = \"outfile\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The file to store the plot in (str).\"\n\n        opt = \"wait\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to wait for user to close the plot window (bool).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(LinePlot, self).fix_config(options)\n\n        opt = \"attributes\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The list of 0-based attribute indices to print; None for all (int).\"\n\n        opt = \"percent\"\n        if opt not in options:\n            options[opt] = 100.0\n        if opt not in self.help:\n            self.help[opt] = \"The percentage of the data to display (0-100, float).\"\n\n        opt = \"seed\"\n        if opt not in options:\n            options[opt] = 1\n        if opt not in self.help:\n            self.help[opt] = \"The seed value for randomizing the plot when viewing a subset (int).\"\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the plot (str).\"\n\n        opt = \"outfile\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The file to store the plot in (str).\"\n\n        opt = \"wait\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to wait for user to close the plot window (bool).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_execute(self):\n        result = None\n        data = self.input.payload\n        pltdataset.line_plot(\n            data,\n            atts=self.resolve_option(\"attributes\"),\n            percent=float(self.resolve_option(\"percent\")),\n            seed=int(self.resolve_option(\"seed\")),\n            title=self.resolve_option(\"title\"),\n            outfile=self.resolve_option(\"outfile\"),\n            wait=bool(self.resolve_option(\"wait\")))\n        return result", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(ClassifierErrors, self).fix_config(options)\n\n        opt = \"absolute\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to use absolute errors as size or relative ones (bool).\"\n\n        opt = \"max_relative_size\"\n        if opt not in options:\n            options[opt] = 50\n        if opt not in self.help:\n            self.help[opt] = \"The maximum size in point in case of relative mode (int).\"\n\n        opt = \"absolute_size\"\n        if opt not in options:\n            options[opt] = 50\n        if opt not in self.help:\n            self.help[opt] = \"The size in point in case of absolute mode (int).\"\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the plot (str).\"\n\n        opt = \"outfile\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The file to store the plot in (str).\"\n\n        opt = \"wait\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to wait for user to close the plot window (bool).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_input(self, token):\n        if not isinstance(token.payload, Evaluation):\n            raise Exception(self.full_name + \": Input token is not an Evaluation object!\")", "response": "Checks that the input token is an Evaluation object. Raises an exception if unsupported."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fix_config(self, options):\n        options = super(ROC, self).fix_config(options)\n\n        opt = \"class_index\"\n        if opt not in options:\n            options[opt] = [0]\n        if opt not in self.help:\n            self.help[opt] = \"The list of 0-based class-label indices to display (list).\"\n\n        opt = \"key_loc\"\n        if opt not in options:\n            options[opt] = \"lower right\"\n        if opt not in self.help:\n            self.help[opt] = \"The location of the key in the plot (str).\"\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the plot (str).\"\n\n        opt = \"outfile\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The file to store the plot in (str).\"\n\n        opt = \"wait\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to wait for user to close the plot window (bool).\"\n\n        return options", "response": "Fixes the options if necessary. I. e. it adds all required elements to the dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the options if necessary. I. e. it adds all required elements to the dictionary.", "response": "def fix_config(self, options):\n        \"\"\"\n        Fixes the options, if necessary. I.e., it adds all required elements to the dictionary.\n\n        :param options: the options to fix\n        :type options: dict\n        :return: the (potentially) fixed options\n        :rtype: dict\n        \"\"\"\n        options = super(PRC, self).fix_config(options)\n\n        opt = \"class_index\"\n        if opt not in options:\n            options[opt] = [0]\n        if opt not in self.help:\n            self.help[opt] = \"The list of 0-based class-label indices to display (list).\"\n\n        opt = \"key_loc\"\n        if opt not in options:\n            options[opt] = \"lower center\"\n        if opt not in self.help:\n            self.help[opt] = \"The location of the key in the plot (str).\"\n\n        opt = \"title\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The title for the plot (str).\"\n\n        opt = \"outfile\"\n        if opt not in options:\n            options[opt] = None\n        if opt not in self.help:\n            self.help[opt] = \"The file to store the plot in (str).\"\n\n        opt = \"wait\"\n        if opt not in options:\n            options[opt] = True\n        if opt not in self.help:\n            self.help[opt] = \"Whether to wait for user to close the plot window (bool).\"\n\n        return options"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_execute(self):\n        result = None\n        evl = self.input.payload\n        pltclassifier.plot_prc(\n            evl,\n            class_index=self.resolve_option(\"class_index\"),\n            title=self.resolve_option(\"title\"),\n            key_loc=self.resolve_option(\"key_loc\"),\n            outfile=self.resolve_option(\"outfile\"),\n            wait=bool(self.resolve_option(\"wait\")))\n        return result", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_execute(self):\n        result = None\n\n        data = self.input.payload\n        if isinstance(self._input.payload, Instance):\n            inst = self.input.payload\n            data = inst.dataset\n        elif isinstance(self.input.payload, Instances):\n            data = self.input.payload\n            inst = None\n\n        append = True\n        if self._header is None or (self._header.equal_headers(data) is not None):\n            self._header = Instances.template_instances(data, 0)\n            outstr = str(data)\n            append = False\n        elif inst is not None:\n            outstr = str(inst)\n        else:\n            outstr = str(data)\n\n        f = None\n        try:\n            if append:\n                f = open(str(self.resolve_option(\"output\")), \"a\")\n            else:\n                f = open(str(self.resolve_option(\"output\")), \"w\")\n            f.write(outstr)\n            f.write(\"\\n\")\n        except Exception as e:\n            result = self.full_name + \"\\n\" + traceback.format_exc()\n        finally:\n            if f is not None:\n                f.close()\n        return result", "response": "The actual execution of the actor.\n\n        :return: None if successful, otherwise error message\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure_splitevaluator(self):\n        if self.classification:\n            speval = javabridge.make_instance(\"weka/experiment/ClassifierSplitEvaluator\", \"()V\")\n        else:\n            speval = javabridge.make_instance(\"weka/experiment/RegressionSplitEvaluator\", \"()V\")\n        classifier = javabridge.call(speval, \"getClassifier\", \"()Lweka/classifiers/Classifier;\")\n        return speval, classifier", "response": "Configures and returns the SplitEvaluator and Classifier instance as tuple."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(cls, filename):\n        jobject = javabridge.static_call(\n            \"weka/experiment/Experiment\", \"read\", \"(Ljava/lang/String;)Lweka/experiment/Experiment;\",\n            filename)\n        return Experiment(jobject=jobject)", "response": "Loads the experiment from disk."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_resultproducer(self):\n        rproducer = javabridge.make_instance(\"weka/experiment/RandomSplitResultProducer\", \"()V\")\n        javabridge.call(rproducer, \"setRandomizeData\", \"(Z)V\", not self.preserve_order)\n        javabridge.call(rproducer, \"setTrainPercent\", \"(D)V\", self.percentage)\n        speval, classifier = self.configure_splitevaluator()\n        javabridge.call(rproducer, \"setSplitEvaluator\", \"(Lweka/experiment/SplitEvaluator;)V\", speval)\n        prop_path = javabridge.get_env().make_object_array(\n            2, javabridge.get_env().find_class(\"weka/experiment/PropertyNode\"))\n        cls = javabridge.get_env().find_class(\"weka/experiment/RandomSplitResultProducer\")\n        desc = javabridge.make_instance(\n            \"java/beans/PropertyDescriptor\", \"(Ljava/lang/String;Ljava/lang/Class;)V\", \"splitEvaluator\", cls)\n        node = javabridge.make_instance(\n            \"weka/experiment/PropertyNode\", \"(Ljava/lang/Object;Ljava/beans/PropertyDescriptor;Ljava/lang/Class;)V\",\n            speval, desc, cls)\n        javabridge.get_env().set_object_array_element(prop_path, 0, node)\n        cls = javabridge.get_env().get_object_class(speval)\n        desc = javabridge.make_instance(\n            \"java/beans/PropertyDescriptor\", \"(Ljava/lang/String;Ljava/lang/Class;)V\", \"classifier\", cls)\n        node = javabridge.make_instance(\n            \"weka/experiment/PropertyNode\", \"(Ljava/lang/Object;Ljava/beans/PropertyDescriptor;Ljava/lang/Class;)V\",\n            javabridge.call(speval, \"getClass\", \"()Ljava/lang/Class;\"), desc, cls)\n        javabridge.get_env().set_object_array_element(prop_path, 1, node)\n\n        return rproducer, prop_path", "response": "Configures and returns the ResultProducer and PropertyPath as tuple."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_row_name(self, index, name):\n        javabridge.call(self.jobject, \"setRowName\", \"(ILjava/lang/String;)V\", index, name)", "response": "Sets the row name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_col_name(self, index, name):\n        javabridge.call(self.jobject, \"setColName\", \"(ILjava/lang/String;)V\", index, name)", "response": "Sets the column name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the mean value at this location.", "response": "def get_mean(self, col, row):\n        \"\"\"\n        Returns the mean at this location (if valid location).\n\n        :param col: the 0-based column index\n        :type col: int\n        :param row: the 0-based row index\n        :type row: int\n        :return: the mean\n        :rtype: float\n        \"\"\"\n        return javabridge.call(self.jobject, \"getMean\", \"(II)D\", col, row)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the mean value at this location.", "response": "def set_mean(self, col, row, mean):\n        \"\"\"\n        Sets the mean at this location (if valid location).\n\n        :param col: the 0-based column index\n        :type col: int\n        :param row: the 0-based row index\n        :type row: int\n        :param mean: the mean to set\n        :type mean: float\n        \"\"\"\n        javabridge.call(self.jobject, \"setMean\", \"(IID)V\", col, row, mean)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the standard deviation at this location.", "response": "def get_stdev(self, col, row):\n        \"\"\"\n        Returns the standard deviation at this location (if valid location).\n\n        :param col: the 0-based column index\n        :type col: int\n        :param row: the 0-based row index\n        :type row: int\n        :return: the standard deviation\n        :rtype: float\n        \"\"\"\n        return javabridge.call(self.jobject, \"getStdDev\", \"(II)D\", col, row)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_stdev(self, col, row, stdev):\n        javabridge.call(self.jobject, \"setStdDev\", \"(IID)V\", col, row, stdev)", "response": "Sets the standard deviation at this location."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self):\n        required = ['token', 'content']\n        valid_data = {\n            'exp_record': (['type', 'format'], 'record',\n                'Exporting record but content is not record'),\n            'imp_record': (['type', 'overwriteBehavior', 'data', 'format'],\n                'record', 'Importing record but content is not record'),\n            'metadata': (['format'], 'metadata',\n                'Requesting metadata but content != metadata'),\n            'exp_file': (['action', 'record', 'field'], 'file',\n                'Exporting file but content is not file'),\n            'imp_file': (['action', 'record', 'field'], 'file',\n                'Importing file but content is not file'),\n            'del_file': (['action', 'record', 'field'], 'file',\n                'Deleteing file but content is not file'),\n            'exp_event': (['format'], 'event',\n                'Exporting events but content is not event'),\n            'exp_arm': (['format'], 'arm',\n                'Exporting arms but content is not arm'),\n            'exp_fem': (['format'], 'formEventMapping',\n                'Exporting form-event mappings but content != formEventMapping'),\n            'exp_user': (['format'], 'user',\n                'Exporting users but content is not user'),\n            'exp_survey_participant_list': (['instrument'], 'participantList',\n                'Exporting Survey Participant List but content != participantList'),\n            'version': (['format'], 'version',\n                'Requesting version but content != version')\n        }\n        extra, req_content, err_msg = valid_data[self.type]\n        required.extend(extra)\n        required = set(required)\n        pl_keys = set(self.payload.keys())\n        # if req is not subset of payload keys, this call is wrong\n        if not set(required) <= pl_keys:\n            # what is not in pl_keys?\n            not_pre = required - pl_keys\n            raise RCAPIError(\"Required keys: %s\" % ', '.join(not_pre))\n        # Check content, raise with err_msg if not good\n        try:\n            if self.payload['content'] != req_content:\n                raise RCAPIError(err_msg)\n        except KeyError:\n            raise RCAPIError('content not in payload')", "response": "Checks that at least required params exist and that all required params exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, **kwargs):\n        r = post(self.url, data=self.payload, **kwargs)\n        # Raise if we need to\n        self.raise_for_status(r)\n        content = self.get_content(r)\n        return content, r.headers", "response": "Execute the API request and return the response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nraising for certain actions and types", "response": "def raise_for_status(self, r):\n        \"\"\"Given a response, raise for bad status for certain actions\n\n        Some redcap api methods don't return error messages\n        that the user could test for or otherwise use. Therefore, we\n        need to do the testing ourself\n\n        Raising for everything wouldn't let the user see the\n        (hopefully helpful) error message\"\"\"\n        if self.type in ('metadata', 'exp_file', 'imp_file', 'del_file'):\n            r.raise_for_status()\n        # see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n        # specifically 10.5\n        if 500 <= r.status_code < 600:\n            raise RedcapError(r.content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary which can be used as is or added to for payloads", "response": "def __basepl(self, content, rec_type='flat', format='json'):\n        \"\"\"Return a dictionary which can be used as is or added to for\n        payloads\"\"\"\n        d = {'token': self.token, 'content': content, 'format': format}\n        if content not in ['metadata', 'file']:\n            d['type'] = rec_type\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the project is longitudinal.", "response": "def is_longitudinal(self):\n        \"\"\"\n        Returns\n        -------\n        boolean :\n            longitudinal status of this project\n        \"\"\"\n        return len(self.events) > 0 and \\\n            len(self.arm_nums) > 0 and \\\n            len(self.arm_names) > 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of values for the metadata key from each field in the project s metadata.", "response": "def filter_metadata(self, key):\n        \"\"\"\n        Return a list of values for the metadata key from each field\n        of the project's metadata.\n\n        Parameters\n        ----------\n        key: str\n            A known key in the metadata structure\n\n        Returns\n        -------\n        filtered :\n            attribute list from each field\n        \"\"\"\n        filtered = [field[key] for field in self.metadata if key in field]\n        if len(filtered) == 0:\n            raise KeyError(\"Key not found in metadata\")\n        return filtered"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef export_fem(self, arms=None, format='json', df_kwargs=None):\n        ret_format = format\n        if format == 'df':\n            from pandas import read_csv\n            ret_format = 'csv'\n        pl = self.__basepl('formEventMapping', format=ret_format)\n        to_add = [arms]\n        str_add = ['arms']\n        for key, data in zip(str_add, to_add):\n            if data:\n                pl[key] = ','.join(data)\n        response, _ = self._call_api(pl, 'exp_fem')\n        if format in ('json', 'csv', 'xml'):\n            return response\n        elif format == 'df':\n            if not df_kwargs:\n                return read_csv(StringIO(response))\n            else:\n                return read_csv(StringIO(response), **df_kwargs)", "response": "Export the form to event mapping for the project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexport the project s metadata in native objects csv or xml format.", "response": "def export_metadata(self, fields=None, forms=None, format='json',\n            df_kwargs=None):\n        \"\"\"\n        Export the project's metadata\n\n        Parameters\n        ----------\n        fields : list\n            Limit exported metadata to these fields\n        forms : list\n            Limit exported metadata to these forms\n        format : (``'json'``), ``'csv'``, ``'xml'``, ``'df'``\n            Return the metadata in native objects, csv or xml.\n            ``'df'`` will return a ``pandas.DataFrame``.\n        df_kwargs : dict\n            Passed to ``pandas.read_csv`` to control construction of\n            returned DataFrame.\n            by default ``{'index_col': 'field_name'}``\n\n        Returns\n        -------\n        metadata : list, str, ``pandas.DataFrame``\n            metadata sttructure for the project.\n        \"\"\"\n        ret_format = format\n        if format == 'df':\n            from pandas import read_csv\n            ret_format = 'csv'\n        pl = self.__basepl('metadata', format=ret_format)\n        to_add = [fields, forms]\n        str_add = ['fields', 'forms']\n        for key, data in zip(str_add, to_add):\n            if data:\n                pl[key] = ','.join(data)\n        response, _ = self._call_api(pl, 'metadata')\n        if format in ('json', 'csv', 'xml'):\n            return response\n        elif format == 'df':\n            if not df_kwargs:\n                df_kwargs = {'index_col': 'field_name'}\n            return read_csv(StringIO(response), **df_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports data from the REDCap project.", "response": "def export_records(self, records=None, fields=None, forms=None,\n    events=None, raw_or_label='raw', event_name='label',\n    format='json', export_survey_fields=False,\n    export_data_access_groups=False, df_kwargs=None,\n    export_checkbox_labels=False, filter_logic=None):\n        \"\"\"\n        Export data from the REDCap project.\n\n        Parameters\n        ----------\n        records : list\n            array of record names specifying specific records to export.\n            by default, all records are exported\n        fields : list\n            array of field names specifying specific fields to pull\n            by default, all fields are exported\n        forms : list\n            array of form names to export. If in the web UI, the form\n            name has a space in it, replace the space with an underscore\n            by default, all forms are exported\n        events : list\n            an array of unique event names from which to export records\n\n            :note: this only applies to longitudinal projects\n        raw_or_label : (``'raw'``), ``'label'``, ``'both'``\n            export the raw coded values or labels for the options of\n            multiple choice fields, or both\n        event_name : (``'label'``), ``'unique'``\n             export the unique event name or the event label\n        format : (``'json'``), ``'csv'``, ``'xml'``, ``'df'``\n            Format of returned data. ``'json'`` returns json-decoded\n            objects while ``'csv'`` and ``'xml'`` return other formats.\n            ``'df'`` will attempt to return a ``pandas.DataFrame``.\n        export_survey_fields : (``False``), True\n            specifies whether or not to export the survey identifier\n            field (e.g., \"redcap_survey_identifier\") or survey timestamp\n            fields (e.g., form_name+\"_timestamp\") when surveys are\n            utilized in the project.\n        export_data_access_groups : (``False``), ``True``\n            specifies whether or not to export the\n            ``\"redcap_data_access_group\"`` field when data access groups\n            are utilized in the project.\n\n            :note: This flag is only viable if the user whose token is\n                being used to make the API request is *not* in a data\n                access group. If the user is in a group, then this flag\n                will revert to its default value.\n        df_kwargs : dict\n            Passed to ``pandas.read_csv`` to control construction of\n            returned DataFrame.\n            by default, ``{'index_col': self.def_field}``\n        export_checkbox_labels : (``False``), ``True``\n            specify whether to export checkbox values as their label on\n            export.\n        filter_logic : string\n            specify the filterLogic to be sent to the API.\n\n        Returns\n        -------\n        data : list, str, ``pandas.DataFrame``\n            exported data\n        \"\"\"\n        ret_format = format\n        if format == 'df':\n            from pandas import read_csv\n            ret_format = 'csv'\n        pl = self.__basepl('record', format=ret_format)\n        fields = self.backfill_fields(fields, forms)\n        keys_to_add = (records, fields, forms, events,\n        raw_or_label, event_name, export_survey_fields,\n        export_data_access_groups, export_checkbox_labels)\n        str_keys = ('records', 'fields', 'forms', 'events', 'rawOrLabel',\n        'eventName', 'exportSurveyFields', 'exportDataAccessGroups',\n        'exportCheckboxLabel')\n        for key, data in zip(str_keys, keys_to_add):\n            if data:\n                #  Make a url-ok string\n                if key in ('fields', 'records', 'forms', 'events'):\n                    pl[key] = ','.join(data)\n                else:\n                    pl[key] = data\n\n        if filter_logic:\n            pl[\"filterLogic\"] = filter_logic\n        response, _ = self._call_api(pl, 'exp_record')\n        if format in ('json', 'csv', 'xml'):\n            return response\n        elif format == 'df':\n            if not df_kwargs:\n                if self.is_longitudinal():\n                    df_kwargs = {'index_col': [self.def_field,\n                                               'redcap_event_name']}\n                else:\n                    df_kwargs = {'index_col': self.def_field}\n            buf = StringIO(response)\n            df = read_csv(buf, **df_kwargs)\n            buf.close()\n            return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the value for the key for the field in the metadata", "response": "def __meta_metadata(self, field, key):\n        \"\"\"Return the value for key for the field in the metadata\"\"\"\n        mf = ''\n        try:\n            mf = str([f[key] for f in self.metadata\n                     if f['field_name'] == field][0])\n        except IndexError:\n            print(\"%s not in metadata field:%s\" % (key, field))\n            return mf\n        else:\n            return mf"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery the database and return subject information for those who match the query logic", "response": "def filter(self, query, output_fields=None):\n        \"\"\"Query the database and return subject information for those\n        who match the query logic\n\n        Parameters\n        ----------\n        query: Query or QueryGroup\n            Query(Group) object to process\n        output_fields: list\n            The fields desired for matching subjects\n\n        Returns\n        -------\n        A list of dictionaries whose keys contains at least the default field\n        and at most each key passed in with output_fields, each dictionary\n        representing a surviving row in the database.\n        \"\"\"\n        query_keys = query.fields()\n        if not set(query_keys).issubset(set(self.field_names)):\n            raise ValueError(\"One or more query keys not in project keys\")\n        query_keys.append(self.def_field)\n        data = self.export_records(fields=query_keys)\n        matches = query.filter(data, self.def_field)\n        if matches:\n            # if output_fields is empty, we'll download all fields, which is\n            # not desired, so we limit download to def_field\n            if not output_fields:\n                output_fields = [self.def_field]\n            #  But if caller passed a string and not list, we need to listify\n            if isinstance(output_fields, basestring):\n                output_fields = [output_fields]\n            return self.export_records(records=matches, fields=output_fields)\n        else:\n            #  If there are no matches, then sending an empty list to\n            #  export_records will actually return all rows, which is not\n            #  what we want\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef names_labels(self, do_print=False):\n        if do_print:\n            for name, label in zip(self.field_names, self.field_labels):\n                print('%s --> %s' % (str(name), str(label)))\n        return self.field_names, self.field_labels", "response": "Simple helper function to get all field names and labels"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_records(self, to_import, overwrite='normal', format='json',\n        return_format='json', return_content='count',\n        date_format='YMD', force_auto_number=False):\n        \"\"\"\n        Import data into the RedCap Project\n\n        Parameters\n        ----------\n        to_import : array of dicts, csv/xml string, ``pandas.DataFrame``\n            :note:\n                If you pass a csv or xml string, you should use the\n                ``format`` parameter appropriately.\n            :note:\n                Keys of the dictionaries should be subset of project's,\n                fields, but this isn't a requirement. If you provide keys\n                that aren't defined fields, the returned response will\n                contain an ``'error'`` key.\n        overwrite : ('normal'), 'overwrite'\n            ``'overwrite'`` will erase values previously stored in the\n            database if not specified in the to_import dictionaries.\n        format : ('json'),  'xml', 'csv'\n            Format of incoming data. By default, to_import will be json-encoded\n        return_format : ('json'), 'csv', 'xml'\n            Response format. By default, response will be json-decoded.\n        return_content : ('count'), 'ids', 'nothing'\n            By default, the response contains a 'count' key with the number of\n            records just imported. By specifying 'ids', a list of ids\n            imported will be returned. 'nothing' will only return\n            the HTTP status code and no message.\n        date_format : ('YMD'), 'DMY', 'MDY'\n            Describes the formatting of dates. By default, date strings\n            are formatted as 'YYYY-MM-DD' corresponding to 'YMD'. If date\n            strings are formatted as 'MM/DD/YYYY' set this parameter as\n            'MDY' and if formatted as 'DD/MM/YYYY' set as 'DMY'. No\n            other formattings are allowed.\n        force_auto_number : ('False') Enables automatic assignment of record IDs\n            of imported records by REDCap. If this is set to true, and auto-numbering\n            for records is enabled for the project, auto-numbering of imported records\n            will be enabled.\n\n        Returns\n        -------\n        response : dict, str\n            response from REDCap API, json-decoded if ``return_format`` == ``'json'``\n        \"\"\"\n        pl = self.__basepl('record')\n        if hasattr(to_import, 'to_csv'):\n            # We'll assume it's a df\n            buf = StringIO()\n            if self.is_longitudinal():\n                csv_kwargs = {'index_label': [self.def_field,\n                                              'redcap_event_name']}\n            else:\n                csv_kwargs = {'index_label': self.def_field}\n            to_import.to_csv(buf, **csv_kwargs)\n            pl['data'] = buf.getvalue()\n            buf.close()\n            format = 'csv'\n        elif format == 'json':\n            pl['data'] = json.dumps(to_import, separators=(',', ':'))\n        else:\n            # don't do anything to csv/xml\n            pl['data'] = to_import\n        pl['overwriteBehavior'] = overwrite\n        pl['format'] = format\n        pl['returnFormat'] = return_format\n        pl['returnContent'] = return_content\n        pl['dateFormat'] = date_format\n        pl['forceAutoNumber'] = force_auto_number\n        response = self._call_api(pl, 'imp_record')[0]\n        if 'error' in response:\n            raise RedcapError(str(response))\n        return response", "response": "This function imports data into the RedCap Project and returns a dict containing the number of records imported."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_file(self, record, field, event=None, return_format='json'):\n        self._check_file_field(field)\n        # load up payload\n        pl = self.__basepl(content='file', format=return_format)\n        # there's no format field in this call\n        del pl['format']\n        pl['returnFormat'] = return_format\n        pl['action'] = 'export'\n        pl['field'] = field\n        pl['record'] = record\n        if event:\n            pl['event'] = event\n        content, headers = self._call_api(pl, 'exp_file')\n        #REDCap adds some useful things in content-type\n        if 'content-type' in headers:\n            splat = [kv.strip() for kv in headers['content-type'].split(';')]\n            kv = [(kv.split('=')[0], kv.split('=')[1].replace('\"', '')) for kv\n                  in splat if '=' in kv]\n            content_map = dict(kv)\n        else:\n            content_map = {}\n        return content, content_map", "response": "This method returns the contents of a file stored for a particular record and field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nimport the contents of a file represented by fobj into a specific record.", "response": "def import_file(self, record, field, fname, fobj, event=None,\n            return_format='json'):\n        \"\"\"\n        Import the contents of a file represented by fobj to a\n        particular records field\n\n        Parameters\n        ----------\n        record : str\n            record ID\n        field : str\n            field name where the file will go\n        fname : str\n            file name visible in REDCap UI\n        fobj : file object\n            file object as returned by `open`\n        event : str\n            for longitudinal projects, specify the unique event here\n        return_format : ('json'), 'csv', 'xml'\n            format of error message\n\n        Returns\n        -------\n        response :\n            response from server as specified by ``return_format``\n        \"\"\"\n        self._check_file_field(field)\n        # load up payload\n        pl = self.__basepl(content='file', format=return_format)\n        # no format in this call\n        del pl['format']\n        pl['returnFormat'] = return_format\n        pl['action'] = 'import'\n        pl['field'] = field\n        pl['record'] = record\n        if event:\n            pl['event'] = event\n        file_kwargs = {'files': {'file': (fname, fobj)}}\n        return self._call_api(pl, 'imp_file', **file_kwargs)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting a file from REDCap", "response": "def delete_file(self, record, field, return_format='json', event=None):\n        \"\"\"\n        Delete a file from REDCap\n\n        Notes\n        -----\n        There is no undo button to this.\n\n        Parameters\n        ----------\n        record : str\n            record ID\n        field : str\n            field name\n        return_format : (``'json'``), ``'csv'``, ``'xml'``\n            return format for error message\n        event : str\n            If longitudinal project, event to delete file from\n\n        Returns\n        -------\n        response : dict, str\n            response from REDCap after deleting file\n        \"\"\"\n        self._check_file_field(field)\n        # Load up payload\n        pl = self.__basepl(content='file', format=return_format)\n        del pl['format']\n        pl['returnFormat'] = return_format\n        pl['action'] = 'delete'\n        pl['record'] = record\n        pl['field'] = field\n        if event:\n            pl['event'] = event\n        return self._call_api(pl, 'del_file')[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks that the field exists and is a file field", "response": "def _check_file_field(self, field):\n        \"\"\"Check that field exists and is a file field\"\"\"\n        is_field = field in self.field_names\n        is_file = self.__meta_metadata(field, 'field_type') == 'file'\n        if not (is_field and is_file):\n            msg = \"'%s' is not a field or not a 'file' field\" % field\n            raise ValueError(msg)\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexporting the users of the Project", "response": "def export_users(self, format='json'):\n        \"\"\"\n        Export the users of the Project\n\n        Notes\n        -----\n        Each user will have the following keys:\n\n            * ``'firstname'`` : User's first name\n            * ``'lastname'`` : User's last name\n            * ``'email'`` : Email address\n            * ``'username'`` : User's username\n            * ``'expiration'`` : Project access expiration date\n            * ``'data_access_group'`` : data access group ID\n            * ``'data_export'`` : (0=no access, 2=De-Identified, 1=Full Data Set)\n            * ``'forms'`` : a list of dicts with a single key as the form name and\n                value is an integer describing that user's form rights,\n                where: 0=no access, 1=view records/responses and edit\n                records (survey responses are read-only), 2=read only, and\n                3=edit survey responses,\n\n\n        Parameters\n        ----------\n        format : (``'json'``), ``'csv'``, ``'xml'``\n            response return format\n\n        Returns\n        -------\n        users: list, str\n            list of users dicts when ``'format'='json'``,\n            otherwise a string\n        \"\"\"\n        pl = self.__basepl(content='user', format=format)\n        return self._call_api(pl, 'exp_user')[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef export_survey_participant_list(self, instrument, event=None, format='json'):\n        pl = self.__basepl(content='participantList', format=format)\n        pl['instrument'] = instrument\n        if event:\n            pl['event'] = event\n        return self._call_api(pl, 'exp_survey_participant_list')", "response": "This method returns the Survey Participant List"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_new_username(ip, devicetype=None, timeout=_DEFAULT_TIMEOUT):\n    res = Resource(_api_url(ip), timeout)\n    prompt = \"Press the Bridge button, then press Return: \"\n    # Deal with one of the sillier python3 changes\n    if sys.version_info.major == 2:\n        _ = raw_input(prompt)\n    else:\n        _ = input(prompt)\n\n    if devicetype is None:\n        devicetype = \"qhue#{}\".format(getfqdn())\n\n    # raises QhueException if something went wrong\n    response = res(devicetype=devicetype, http_method=\"post\")\n\n    return response[0][\"success\"][\"username\"]", "response": "Interactive helper function to generate a new anonymous username."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _deep_merge_dict(a, b):\n    for k, v in b.items():\n        if k in a and isinstance(a[k], dict) and isinstance(v, dict):\n            _deep_merge_dict(a[k], v)\n        else:\n            a[k] = v", "response": "Additively merge right side dict into left side dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndiscovering and instantiate plugins.", "response": "def load_plugins(config, plugin_kwargs):\n    \"\"\"\n    Discover and instantiate plugins.\n\n    Args:\n        config (dict): loaded configuration for the Gordon service.\n        plugin_kwargs (dict): keyword arguments to give to plugins\n            during instantiation.\n    Returns:\n        Tuple of 3 lists: list of names of plugins, list of\n        instantiated plugin objects, and any errors encountered while\n        loading/instantiating plugins. A tuple of three empty lists is\n        returned if there are no plugins found or activated in gordon\n        config.\n    \"\"\"\n    installed_plugins = _gather_installed_plugins()\n    metrics_plugin = _get_metrics_plugin(config, installed_plugins)\n    if metrics_plugin:\n        plugin_kwargs['metrics'] = metrics_plugin\n\n    active_plugins = _get_activated_plugins(config, installed_plugins)\n    if not active_plugins:\n        return [], [], [], None\n    plugin_namespaces = _get_plugin_config_keys(active_plugins)\n    plugin_configs = _load_plugin_configs(plugin_namespaces, config)\n    plugin_names, plugins, errors = _init_plugins(\n        active_plugins, installed_plugins, plugin_configs, plugin_kwargs)\n    return plugin_names, plugins, errors, plugin_kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating connection to the specified transport.", "response": "def connection_made(self, transport):\n        \"\"\"Create connection, use to send message and close.\n\n        Args:\n            transport (asyncio.DatagramTransport): Transport used for sending.\n        \"\"\"\n        self.transport = transport\n        self.transport.sendto(self.message)\n        self.transport.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform metric to JSON bytestring and send to server.", "response": "async def send(self, metric):\n        \"\"\"Transform metric to JSON bytestring and send to server.\n\n        Args:\n            metric (dict): Complete metric to send as JSON.\n        \"\"\"\n        message = json.dumps(metric).encode('utf-8')\n        await self.loop.create_datagram_endpoint(\n            lambda: UDPClientProtocol(message),\n            remote_addr=(self.ip, self.port))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquery a DNS server multiple times until the record is available.", "response": "async def check_record(self, record, timeout=60):\n        \"\"\"Measures the time for a DNS record to become available.\n\n        Query a provided DNS server multiple times until the reply matches the\n        information in the record or until timeout is reached.\n\n        Args:\n            record (dict): DNS record as a dict with record properties.\n            timeout (int): Time threshold to query the DNS server.\n        \"\"\"\n        start_time = time.time()\n\n        name, rr_data, r_type, ttl = self._extract_record_data(record)\n        r_type_code = async_dns.types.get_code(r_type)\n\n        resolvable_record = False\n        retries = 0\n        sleep_time = 5\n\n        while not resolvable_record and \\\n                timeout > retries * sleep_time:\n\n            retries += 1\n            resolver_res = await self._resolver.query(name, r_type_code)\n            possible_ans = resolver_res.an\n\n            resolvable_record = \\\n                await self._check_resolver_ans(possible_ans, name,\n                                               rr_data, ttl, r_type_code)\n\n            if not resolvable_record:\n                await asyncio.sleep(sleep_time)\n\n        if not resolvable_record:\n            logging.info(\n                f'Sending metric record-checker-failed: {record}.')\n        else:\n            final_time = float(time.time() - start_time)\n            success_msg = (f'This record: {record} took {final_time} to '\n                           'register.')\n            logging.info(success_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if resolver answer is equal to record data.", "response": "async def _check_resolver_ans(\n            self, dns_answer_list, record_name,\n            record_data_list, record_ttl, record_type_code):\n        \"\"\"Check if resolver answer is equal to record data.\n\n        Args:\n            dns_answer_list (list): DNS answer list contains record objects.\n            record_name (str): Record name.\n            record_data_list (list): List of data values for the record.\n            record_ttl (int): Record time-to-live info.\n            record_type_code (int): Record type code.\n\n        Returns:\n            boolean indicating if DNS answer data is equal to record data.\n        \"\"\"\n        type_filtered_list = [\n            ans for ans in dns_answer_list if ans.qtype == record_type_code\n        ]\n\n        # check to see that type_filtered_lst has\n        # the same number of records as record_data_list\n        if len(type_filtered_list) != len(record_data_list):\n            return False\n\n        # check each record data is equal to the given data\n        for rec in type_filtered_list:\n            conditions = [rec.name == record_name,\n                          rec.ttl == record_ttl,\n                          rec.data in record_data_list]\n\n            # if ans record data is not equal\n            # to the given data return False\n            if not all(conditions):\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild an absolute path from * filenames and returns contents of resulting file. Defaults to UTF - 8 encoding.", "response": "def read(*filenames, **kwargs):\n    \"\"\"\n    Build an absolute path from ``*filenames``, and  return contents of\n    resulting file.  Defaults to UTF-8 encoding.\n    \"\"\"\n    encoding = kwargs.get('encoding', 'utf-8')\n    sep = kwargs.get('sep', '\\n')\n    buf = []\n    for fl in filenames:\n        with codecs.open(os.path.join(HERE, fl), 'rb', encoding) as f:\n            buf.append(f.read())\n    return sep.join(buf)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat and output metric.", "response": "def log(self, metric):\n        \"\"\"Format and output metric.\n\n        Args:\n            metric (dict): Complete metric.\n        \"\"\"\n        message = self.LOGFMT.format(**metric)\n        if metric['context']:\n            message += ' context: {context}'.format(context=metric['context'])\n        self._logger.log(self.level, message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeciphering string using Polybius square cipher according to initialised key.", "response": "def decipher(self,string):\n        \"\"\"Decipher string using Polybius square cipher according to initialised key.\n\n        Example::\n\n            plaintext = Polybius('APCZWRLFBDKOTYUQGENHXMIVS',5,'MKSBU').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string. The plaintext will be half the length of the ciphertext.\n        \"\"\"         \n        string = self.remove_punctuation(string)#,filter='[^'+self.chars+']')\n        ret = ''\n        for i in range(0,len(string),2):\n            ret += self.decipher_pair(string[i:i+2])\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeciphering string using ADFGVX according to initialised key information. Punctuation and whitespace are removed from the input.", "response": "def decipher(self,string):\n        \"\"\"Decipher string using ADFGVX cipher according to initialised key information. Punctuation and whitespace\n        are removed from the input.       \n\n        Example::\n\n            plaintext = ADFGVX('ph0qg64mea1yl2nofdxkr3cvs5zw7bj9uti8','HELLO').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The enciphered string.\n        \"\"\"                \n        step2 = ColTrans(self.keyword).decipher(string)\n        step1 = PolybiusSquare(self.key,size=6,chars='ADFGVX').decipher(step2)\n        return step1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ic(ctext):\n    ''' takes ciphertext, calculates index of coincidence.'''\n    counts = ngram_count(ctext,N=1)\n    icval = 0\n    for k in counts.keys():\n        icval += counts[k]*(counts[k]-1)\n    icval /= (len(ctext)*(len(ctext)-1))\n    return icval", "response": "takes ciphertext calculates index of coincidence."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ngram_count(text,N=1,keep_punct=False):\n    ''' if N=1, return a dict containing each letter along with how many times the letter occurred.\n        if N=2, returns a dict containing counts of each bigram (pair of letters)\n        etc.\n        There is an option to remove all spaces and punctuation prior to processing '''\n    if not keep_punct: text = re.sub('[^A-Z]','',text.upper())\n    count = {}\n    for i in range(len(text)-N+1):\n        c = text[i:i+N]\n        if c in count: count[c] += 1\n        else: count[c] = 1.0\n    return count", "response": "Returns a dict containing each letter along with how many times the letter occurred."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ngram_freq(text,N=1,log=False,floor=0.01):\n    ''' returns the n-gram frequencies of all n-grams encountered in text.\n        Option to return log probabilities or standard probabilities.\n        Note that only n-grams occurring in 'text' will have probabilities.\n        For the probability of not-occurring n-grams, use freq['floor'].\n        This is set to floor/len(text) '''\n    freq = ngram_count(text,N)\n    L = 1.0*(len(text)-N+1)\n    for c in freq.keys():\n        if log: freq[c] = math.log10(freq[c]/L)\n        else: freq[c] = freq[c]/L\n    if log: freq['floor'] = math.log10(floor/L)\n    else: freq['floor'] = floor/L   \n    return freq", "response": "returns the n - gram frequencies of all n - grams occurring in text"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore_punctuation(original,modified):\n    ''' If punctuation was accidently removed, use this function to restore it.\n        requires the orignial string with punctuation. '''\n    ret = ''\n    count = 0\n    try:\n        for c in original:\n            if c.isalpha(): \n                ret+=modified[count]\n                count+=1\n            else: ret+=c\n    except IndexError:\n        print('restore_punctuation: strings must have same number of alphabetic chars')\n        raise\n    return ret", "response": "This function is used to restore punctuation from original string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a key word to a key word by appending on other letters of the alphabet.", "response": "def keyword_to_key(word,alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    ''' convert a key word to a key by appending on the other letters of the alphabet.\n    e.g. MONARCHY -> MONARCHYBDEFGIJKLPQSTUVWXZ\n    '''\n    ret = ''\n    word = (word + alphabet).upper()\n    for i in word:\n        if i in ret: continue\n        ret += i\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encipher(self, string):\n        string = self.remove_punctuation(string)  \n        string = re.sub(r'[J]', 'I', string)\n        if len(string) % 2 == 1:\n            string += 'X'\n        ret = ''\n        for c in range(0, len(string), 2):\n            ret += self.encipher_pair(string[c], string[c + 1])\n        return ret", "response": "Encipher string using Playfair cipher according to initialised key. Punctuation and whitespace\n            are removed from the input."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecipher string using Playfair cipher according to initialised key. Punctuation and whitespace are removed from the input.", "response": "def decipher(self, string):\n        \"\"\"Decipher string using Playfair cipher according to initialised key. Punctuation and whitespace\n        are removed from the input. The ciphertext should be an even number of characters. If the input ciphertext is not an even number of characters, an 'X' will be appended.\n\n        Example::\n\n            plaintext = Playfair(key='zgptfoihmuwdrcnykeqaxvsbl').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string.\n        \"\"\"    \n        string = self.remove_punctuation(string)  \n        if len(string) % 2 == 1:\n            string += 'X'\n        ret = ''\n        for c in range(0, len(string), 2):\n            ret += self.decipher_pair(string[c], string[c + 1])\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encipher(self,string):\n        string = self.remove_punctuation(string,filter='[^'+self.key+']')        \n        ctext = \"\"\n        for c in string:\n            ctext += ''.join([str(i) for i in L2IND[c]])\n        return ctext", "response": "Encipher string using Delastelle according to initialised key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeciphers string using Delastelle according to initialised key.", "response": "def decipher(self,string):\n        \"\"\"Decipher string using Delastelle cipher according to initialised key.\n\n        Example::\n\n            plaintext = Delastelle('APCZ WRLFBDKOTYUQGENHXMIVS').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string. The plaintext will be 1/3 the length of the ciphertext.\n        \"\"\"         \n        string = self.remove_punctuation(string,filter='[^'+self.chars+']')\n        ret = ''\n        for i in range(0,len(string),3):\n            ind = tuple([int(string[i+k]) for k in [0,1,2]])\n            ret += IND2L[ind]\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeciphering string using Foursquare cipher according to initialised key. Punctuation and whitespace are removed from the input.", "response": "def decipher(self,string):\n        \"\"\"Decipher string using Foursquare cipher according to initialised key. Punctuation and whitespace\n        are removed from the input. The ciphertext should be an even number of characters. If the input ciphertext is not an even number of characters, an 'X' will be appended.\n\n        Example::\n\n            plaintext = Foursquare(key1='zgptfoihmuwdrcnykeqaxvsbl',key2='mfnbdcrhsaxyogvituewlqzkp').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string.\n        \"\"\"              \n        string = self.remove_punctuation(string)  \n        if len(string)%2 == 1: string = string + 'X'\n        ret = ''\n        for c in range(0,len(string.upper()),2):\n            a,b = self.decipher_pair(string[c],string[c+1])\n            ret += a + b\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encipher(self,string,keep_punct=False):\n        if not keep_punct: string = self.remove_punctuation(string)\n        ret = ''\n        for c in string:\n            if c.isalpha(): ret += self.i2a( self.a2i(c) + 13 )\n            else: ret += c\n        return ret", "response": "r Encipher string using rot13 cipher."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encipher(self,message):\n        message = self.remove_punctuation(message)  \n        effective_ch = [0,0,0,0,0,0,0] # these are the wheels which are effective currently, 1 for yes, 0 no\n                                       # -the zero at the beginning is extra, indicates lug was in pos 0\n        ret = ''\n        # from now we no longer need the wheel starts, we can just increment the actual key\n        for j in range(len(message)):\n            shift = 0 \n            effective_ch[0] = 0;\n            effective_ch[1] = self.wheel_1_settings[self.actual_key[0]]\n            effective_ch[2] = self.wheel_2_settings[self.actual_key[1]]\n            effective_ch[3] = self.wheel_3_settings[self.actual_key[2]]\n            effective_ch[4] = self.wheel_4_settings[self.actual_key[3]]\n            effective_ch[5] = self.wheel_5_settings[self.actual_key[4]]\n            effective_ch[6] = self.wheel_6_settings[self.actual_key[5]]\n             \n            for i in range(0,27): # implements the cylindrical drum with lugs on it\n                if effective_ch[self.lug_positions[i][0]] or effective_ch[self.lug_positions[i][1]]: shift+=1\n            # shift has been found, now actually encrypt letter\n            ret += self.subst(message[j],key='ZYXWVUTSRQPONMLKJIHGFEDCBA',offset=-shift); # encrypt letter\n            self.advance_key();    # advance the key wheels\n        return ret", "response": "Encipher the string using M209 cipher according to initialised key. Punctuation and whitespace are removed from the input."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decipher(self,string):\n        string = string.upper()\n        mapping = dict(zip(self.key,self.table))\n        ptext = \"\"\n        for i in string:\n            ptext += mapping[i]\n        return self.demorse(ptext)", "response": "Decipher a string using FracMorse cipher according to initialised key. Returns the decrypted string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encipher(self,string):\n        string = self.remove_punctuation(string)    \n        ret = ''\n        ind = self.sortind(self.keyword)\n        for i in range(len(self.keyword)):\n            ret += string[ind.index(i)::len(self.keyword)]\n        return ret", "response": "Encipher string using Columnar Transposition cipher according to initialised key. Punctuation and whitespace\n        are removed from the input."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decipher(self,string):\n        '''Decipher string using Columnar Transposition cipher according to initialised key. Punctuation and whitespace\n        are removed from the input.\n\n        Example::\n\n            plaintext = ColTrans('GERMAN').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string.\n        '''           \n        string = self.remove_punctuation(string)        \n        ret = ['_']*len(string)\n        L,M = len(string),len(self.keyword)\n        ind = self.unsortind(self.keyword)\n        upto = 0\n        for i in range(len(self.keyword)):\n            thiscollen = (int)(L/M)\n            if ind[i]< L%M: thiscollen += 1\n            ret[ind[i]::M] = string[upto:upto+thiscollen]\n            upto += thiscollen\n        return ''.join(ret)", "response": "Decipher string using Columnar Transposition cipher according to initialised key. Punctuation and whitespace\n        are removed from the input."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encipher(self,string,keep_punct=False):\n        if not keep_punct: string = self.remove_punctuation(string)\n        return ''.join(self.buildfence(string, self.key))", "response": "Encipher string using Railfence cipher according to initialised key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decipher(self,string,keep_punct=False):\n        if not keep_punct: string = self.remove_punctuation(string)    \n        ind = range(len(string))\n        pos = self.buildfence(ind, self.key)\n        return ''.join(string[pos.index(i)] for i in ind)", "response": "Decipher string using Railfence cipher according to initialised key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decipher(self,string,keep_punct=False):\n        if not keep_punct: string = self.remove_punctuation(string)    \n        ret = ''\n        for c in string:\n            if c.isalpha(): ret += self.i2a(self.inva*(self.a2i(c) - self.b))\n            else: ret += c\n        return ret", "response": "Decipher string using affine cipher according to initialised key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeciphers string using Bifid cipher according to initialised key. Punctuation and whitespace are removed from the input.", "response": "def decipher(self,string):\n        \"\"\"Decipher string using Bifid cipher according to initialised key. Punctuation and whitespace\n        are removed from the input.\n\n        Example::\n\n            plaintext = Bifid('phqgmeaylnofdxkrcvszwbuti',5).decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :returns: The deciphered string.\n        \"\"\"       \n        ret = ''\n        string = string.upper()\n        rowseq,colseq = [],[]\n        # take blocks of length period, reform rowseq,colseq from them\n        for i in range(0,len(string),self.period):\n            tempseq = []\n            for j in range(0,self.period):\n                if i+j >= len(string): continue\n                tempseq.append(int(self.key.index(string[i + j]) / 5))\n                tempseq.append(int(self.key.index(string[i + j]) % 5))\n            rowseq.extend(tempseq[0:int(len(tempseq)/2)])\n            colseq.extend(tempseq[int(len(tempseq)/2):])\n        for i in range(len(rowseq)):\n            ret += self.key[rowseq[i]*5 + colseq[i]]\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeciphering string using Simple Substitution cipher according to initialised key.", "response": "def decipher(self,string,keep_punct=False):\n        \"\"\"Decipher string using Simple Substitution cipher according to initialised key.\n\n        Example::\n\n            plaintext = SimpleSubstitution('AJPCZWRLFBDKOTYUQGENHXMIVS').decipher(ciphertext)     \n\n        :param string: The string to decipher.\n        :param keep_punct: if true, punctuation and spacing are retained. If false, it is all removed. Default is False. \n        :returns: The deciphered string.\n        \"\"\"       \n        # if we have not yet calculated the inverse key, calculate it now\n        if self.invkey == '':\n            for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ': \n                self.invkey += self.i2a(self.key.index(i))\n        if not keep_punct: string = self.remove_punctuation(string)\n        ret = ''      \n        for c in string.upper():\n            if c.isalpha(): ret += self.invkey[self.a2i(c)]\n            else: ret += c\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef matvec(a, b, compression=False):\n    acrs = _vector.vector.to_list(a.tt)\n    bcrs = _vector.vector.to_list(b)\n    ccrs = []\n    d = b.d\n\n    def get_core(i):\n        acr = _np.reshape(\n            acrs[i],\n            (a.tt.r[i],\n             a.n[i],\n             a.m[i],\n             a.tt.r[\n                 i + 1]),\n            order='F')\n        acr = acr.transpose([3, 0, 1, 2])  # a(R_{i+1}, R_i, n_i, m_i)\n        bcr = bcrs[i].transpose([1, 0, 2])  # b(m_i, r_i, r_{i+1})\n        # c(R_{i+1}, R_i, n_i, r_i, r_{i+1})\n        ccr = _np.tensordot(acr, bcr, axes=(3, 0))\n        ccr = ccr.transpose([1, 3, 2, 0, 4]).reshape(\n            (a.tt.r[i] * b.r[i], a.n[i], a.tt.r[i + 1] * b.r[i + 1]), order='F')\n        return ccr\n\n    if compression:  # the compression is laaaaazy and one-directioned\n        # calculate norm of resulting _vector first\n        nrm = _np.array([[1.0]])  # 1 x 1\n        v = _np.array([[1.0]])\n        for i in xrange(d):\n            ccr = get_core(i)\n            # print(str(ccr.shape) + \" -> \"),\n            # minimal loss compression\n            ccr = _np.tensordot(v, ccr, (1, 0))\n            rl, n, rr = ccr.shape\n            if i < d - 1:\n                u, s, v = _np.linalg.svd(\n                    ccr.reshape(\n                        (rl * n, rr), order='F'), full_matrices=False)\n                newr = min(rl * n, rr)\n                ccr = u[:, :newr].reshape((rl, n, newr), order='F')\n                v = _np.dot(_np.diag(s[:newr]), v[:newr, :])\n            # print(ccr.shape)\n            # r x r . r x n x R -> r x n x R\n            nrm = _np.tensordot(nrm, ccr, (0, 0))\n            # r x n x R . r x n x R -> n x R x n x R\n            nrm = _np.tensordot(nrm, _np.conj(ccr), (0, 0))\n            nrm = nrm.diagonal(axis1=0, axis2=2)  # n x R x n x R -> R x R x n\n            nrm = nrm.sum(axis=2)  # R x R x n -> R x R\n        if nrm.size > 1:\n            raise Exception('too many numbers in norm')\n        # print(\"Norm calculated:\", nrm)\n        nrm = _np.sqrt(_np.linalg.norm(nrm))\n        # print(\"Norm predicted:\", nrm)\n        compression = compression * nrm / _np.sqrt(d - 1)\n        v = _np.array([[1.0]])\n\n    for i in xrange(d):\n        ccr = get_core(i)\n        rl, n, rr = ccr.shape\n        if compression:\n            ccr = _np.tensordot(v, ccr, (1, 0))  # c(s_i, n_i, r_i, r_{i+1})\n            if i < d - 1:\n                rl = v.shape[0]\n                u, s, v = _np.linalg.svd(\n                    ccr.reshape(\n                        (rl * n, rr), order='F'), full_matrices=False)\n                ss = _np.cumsum(s[::-1])[::-1]\n                newr = max(min([r for r in range(ss.size) if ss[\n                    r] <= compression] + [min(rl * n, rr)]), 1)\n                # print(\"Rank % 4d replaced by % 4d\" % (rr, newr))\n                ccr = u[:, :newr].reshape((rl, n, newr), order='F')\n                v = _np.dot(_np.diag(s[:newr]), v[:newr, :])\n        ccrs.append(ccr)\n    result = _vector.vector.from_list(ccrs)\n    if compression:\n        # print(result)\n        print(\"Norm actual:\", result.norm(), \" mean rank:\", result.rmean())\n        # print(\"Norm very actual:\", matvec(a,b).norm())\n    return result", "response": "Matrix - vector product in TT format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kron(a, b):\n    if hasattr(a, '__kron__'):\n        return a.__kron__(b)\n    if a is None:\n        return b\n    else:\n        raise ValueError(\n            'Kron is waiting for two TT-vectors or two TT-matrices')", "response": "Kronecker product of two TT - matrices or two TT - vectors"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dot(a, b):\n    if hasattr(a, '__dot__'):\n        return a.__dot__(b)\n    if a is None:\n        return b\n    else:\n        raise ValueError(\n            'Dot is waiting for two TT-vectors or two TT-    matrices')", "response": "Dot product of two TT - vectors or two TT - Vocabularys"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef zkron(ttA, ttB):\n    Al = _matrix.matrix.to_list(ttA)\n    Bl = _matrix.matrix.to_list(ttB)\n    Hl = [_np.kron(B, A) for (A, B) in zip(Al, Bl)]\n    return _matrix.matrix.from_list(Hl)", "response": "Do kronecker product between two matrices ttA and ttB."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo kronecker product between vectors ttA and ttB.", "response": "def zkronv(ttA, ttB):\n    \"\"\"\n    Do kronecker product between vectors ttA and ttB.\n    Look about kronecker at: https://en.wikipedia.org/wiki/Kronecker_product\n    For details about operation refer: https://arxiv.org/abs/1802.02839\n    :param ttA: first TT-vector;\n    :param ttB: second TT-vector;\n    :return: operation result in z-order\n    \"\"\"\n    Al = _vector.vector.to_list(ttA)\n    Bl = _vector.vector.to_list(ttB)\n    Hl = [_np.kron(B, A) for (A, B) in zip(Al, Bl)]\n    return _vector.vector.from_list(Hl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef zmeshgrid(d):\n    lin = xfun(2, d)\n    one = ones(2, d)\n\n    xx = zkronv(lin, one)\n    yy = zkronv(one, lin)\n\n    return xx, yy", "response": "Returns a meshgrid like np. meshgrid but in z - order"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zaffine(c0, c1, c2, d):\n\n    xx, yy = zmeshgrid(d)\n    Hx, Hy = _vector.vector.to_list(xx), _vector.vector.to_list(yy)\n\n    Hs = _cp.deepcopy(Hx)\n    Hs[0][:, :, 0] = c1 * Hx[0][:, :, 0] + c2 * Hy[0][:, :, 0]\n    Hs[-1][1, :, :] = c1 * Hx[-1][1, :, :] + (c0 + c2 * Hy[-1][1, :, :])\n\n    d = len(Hs)\n    for k in range(1, d - 1):\n        Hs[k][1, :, 0] = c1 * Hx[k][1, :, 0] + c2 * Hy[k][1, :, 0]\n\n    return _vector.vector.from_list(Hs)", "response": "Generate linear function c0 + c1 ex + c2 ey in z ordering with d cores in QTT\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef concatenate(*args):\n    tmp = _np.array([[1] + [0] * (len(args) - 1)])\n    result = kron(_vector.vector(tmp), args[0])\n    for i in range(1, len(args)):\n        result += kron(_vector.vector(_np.array([[0] * i +\n                                                 [1] + [0] * (len(args) - i - 1)])), args[i])\n    return result", "response": "Concatenates given TT - vectors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsum TT - vector over specified axes", "response": "def sum(a, axis=-1):\n    \"\"\"Sum TT-vector over specified axes\"\"\"\n    d = a.d\n    crs = _vector.vector.to_list(a.tt if isinstance(a, _matrix.matrix) else a)\n    if axis < 0:\n        axis = range(a.d)\n    elif isinstance(axis, int):\n        axis = [axis]\n    axis = list(axis)[::-1]\n    for ax in axis:\n        crs[ax] = _np.sum(crs[ax], axis=1)\n        rleft, rright = crs[ax].shape\n        if (rleft >= rright or rleft < rright and ax + 1 >= d) and ax > 0:\n            crs[ax - 1] = _np.tensordot(crs[ax - 1], crs[ax], axes=(2, 0))\n        elif ax + 1 < d:\n            crs[ax + 1] = _np.tensordot(crs[ax], crs[ax + 1], axes=(1, 0))\n        else:\n            return _np.sum(crs[ax])\n        crs.pop(ax)\n        d -= 1\n    return _vector.vector.from_list(crs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ones(n, d=None):\n    c = _vector.vector()\n    if d is None:\n        c.n = _np.array(n, dtype=_np.int32)\n        c.d = c.n.size\n    else:\n        c.n = _np.array([n] * d, dtype=_np.int32)\n        c.d = d\n    c.r = _np.ones((c.d + 1,), dtype=_np.int32)\n    c.get_ps()\n    c.core = _np.ones(c.ps[c.d] - 1)\n    return c", "response": "Creates a TT - vector of all ones"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rand(n, d=None, r=2, samplefunc=_np.random.randn):\n    n0 = _np.asanyarray(n, dtype=_np.int32)\n    r0 = _np.asanyarray(r, dtype=_np.int32)\n    if d is None:\n        d = n.size\n    if n0.size is 1:\n        n0 = _np.ones((d,), dtype=_np.int32) * n0\n    if r0.size is 1:\n        r0 = _np.ones((d + 1,), dtype=_np.int32) * r0\n        r0[0] = 1\n        r0[d] = 1\n    c = _vector.vector()\n    c.d = d\n    c.n = n0\n    c.r = r0\n    c.get_ps()\n    c.core = samplefunc(c.ps[d] - 1)\n    return c", "response": "Generate a random d - dimensional TT - vector with ranks r."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eye(n, d=None):\n    c = _matrix.matrix()\n    c.tt = _vector.vector()\n    if d is None:\n        n0 = _np.asanyarray(n, dtype=_np.int32)\n        c.tt.d = n0.size\n    else:\n        n0 = _np.asanyarray([n] * d, dtype=_np.int32)\n        c.tt.d = d\n    c.n = n0.copy()\n    c.m = n0.copy()\n    c.tt.n = (c.n) * (c.m)\n    c.tt.r = _np.ones((c.tt.d + 1,), dtype=_np.int32)\n    c.tt.get_ps()\n    c.tt.alloc_core()\n    for i in xrange(c.tt.d):\n        c.tt.core[\n        c.tt.ps[i] -\n        1:c.tt.ps[\n              i +\n              1] -\n          1] = _np.eye(\n            c.n[i]).flatten()\n    return c", "response": "Creates an identity TT - matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates multilevel Toeplitz TT - matrix with D levels.", "response": "def Toeplitz(x, d=None, D=None, kind='F'):\n    \"\"\" Creates multilevel Toeplitz TT-matrix with ``D`` levels.\n\n        Possible _matrix types:\n\n        * 'F' - full Toeplitz _matrix,             size(x) = 2^{d+1}\n        * 'C' - circulant _matrix,                 size(x) = 2^d\n        * 'L' - lower triangular Toeplitz _matrix, size(x) = 2^d\n        * 'U' - upper triangular Toeplitz _matrix, size(x) = 2^d\n\n        Sample calls:\n\n        >>> # one-level Toeplitz _matrix:\n        >>> T = tt.Toeplitz(x)\n        >>> # one-level circulant _matrix:\n        >>> T = tt.Toeplitz(x, kind='C')\n        >>> # three-level upper-triangular Toeplitz _matrix:\n        >>> T = tt.Toeplitz(x, D=3, kind='U')\n        >>> # two-level mixed-type Toeplitz _matrix:\n        >>> T = tt.Toeplitz(x, kind=['L', 'U'])\n        >>> # two-level mixed-size Toeplitz _matrix:\n        >>> T = tt.Toeplitz(x, [3, 4], kind='C')\n\n    \"\"\"\n\n    # checking for arguments consistency\n    def check_kinds(D, kind):\n        if D % len(kind) == 0:\n            kind.extend(kind * (D // len(kind) - 1))\n        if len(kind) != D:\n            raise ValueError(\n                \"Must give proper amount of _matrix kinds (one or D, for example)\")\n\n    kind = list(kind)\n    if not set(kind).issubset(['F', 'C', 'L', 'U']):\n        raise ValueError(\"Toeplitz _matrix kind must be one of F, C, L, U.\")\n    if d is None:\n        if D is None:\n            D = len(kind)\n        if x.d % D:\n            raise ValueError(\n                \"x.d must be divisible by D when d is not specified!\")\n        if len(kind) == 1:\n            d = _np.array([x.d // D - (1 if kind[0] == 'F' else 0)]\n                          * D, dtype=_np.int32)\n            kind = kind * D\n        else:\n            check_kinds(D, kind)\n            if set(kind).issubset(['F']):\n                d = _np.array([x.d // D - 1] * D, dtype=_np.int32)\n            elif set(kind).issubset(['C', 'L', 'U']):\n                d = _np.array([x.d // D] * D, dtype=_np.int32)\n            else:\n                raise ValueError(\n                    \"Only similar _matrix kinds (only F or only C, L and U) are accepted when d is not specified!\")\n    elif d is not None:\n        d = _np.asarray(d, dtype=_np.int32).flatten()\n        if D is None:\n            D = d.size\n        elif d.size == 1:\n            d = _np.array([d[0]] * D, dtype=_np.int32)\n        if D != d.size:\n            raise ValueError(\"D must be equal to len(d)\")\n        check_kinds(D, kind)\n        if _np.sum(d) + _np.sum([(1 if knd == 'F' else 0)\n                                 for knd in kind]) != x.d:\n            raise ValueError(\n                \"Dimensions inconsistency: x.d != d_1 + d_2 + ... + d_D\")\n\n    # predefined matrices and tensors:\n    I = [[1, 0], [0, 1]]\n    J = [[0, 1], [0, 0]]\n    JT = [[0, 0], [1, 0]]\n    H = [[0, 1], [1, 0]]\n    S = _np.array([[[0], [1]], [[1], [0]]]).transpose()  # 2 x 2 x 1\n    P = _np.zeros((2, 2, 2, 2))\n    P[:, :, 0, 0] = I\n    P[:, :, 1, 0] = H\n    P[:, :, 0, 1] = H\n    P[:, :, 1, 1] = I\n    P = _np.transpose(P)  # 2 x 2! x 2 x 2 x '1'\n    Q = _np.zeros((2, 2, 2, 2))\n    Q[:, :, 0, 0] = I\n    Q[:, :, 1, 0] = JT\n    Q[:, :, 0, 1] = JT\n    Q = _np.transpose(Q)  # 2 x 2! x 2 x 2 x '1'\n    R = _np.zeros((2, 2, 2, 2))\n    R[:, :, 1, 0] = J\n    R[:, :, 0, 1] = J\n    R[:, :, 1, 1] = I\n    R = _np.transpose(R)  # 2 x 2! x 2 x 2 x '1'\n    W = _np.zeros([2] * 5)  # 2 x 2! x 2 x 2 x 2\n    W[0, :, :, 0, 0] = W[1, :, :, 1, 1] = I\n    W[0, :, :, 1, 0] = W[0, :, :, 0, 1] = JT\n    W[1, :, :, 1, 0] = W[1, :, :, 0, 1] = J\n    W = _np.transpose(W)  # 2 x 2! x 2 x 2 x 2\n    V = _np.zeros((2, 2, 2, 2))\n    V[0, :, :, 0] = I\n    V[0, :, :, 1] = JT\n    V[1, :, :, 1] = J\n    V = _np.transpose(V)  # '1' x 2! x 2 x 2 x 2\n\n    crs = []\n    xcrs = _vector.vector.to_list(x)\n    dp = 0  # dimensions passed\n    for j in xrange(D):\n        currd = d[j]\n        xcr = xcrs[dp]\n        cr = _np.tensordot(V, xcr, (0, 1))\n        cr = cr.transpose(3, 0, 1, 2, 4)  # <r_dp| x 2 x 2 x |2> x |r_{dp+1}>\n        cr = cr.reshape((x.r[dp], 2, 2, 2 * x.r[dp + 1]),\n                        order='F')  # <r_dp| x 2 x 2 x |2r_{dp+1}>\n        dp += 1\n        crs.append(cr)\n        for i in xrange(1, currd - 1):\n            xcr = xcrs[dp]\n            # (<2| x 2 x 2 x |2>) x <r_dp| x |r_{dp+1}>\n            cr = _np.tensordot(W, xcr, (1, 1))\n            # <2| x <r_dp| x 2 x 2 x |2> x |r_{dp+1}>\n            cr = cr.transpose([0, 4, 1, 2, 3, 5])\n            # <2r_dp| x 2 x 2 x |2r_{dp+1}>\n            cr = cr.reshape((2 * x.r[dp], 2, 2, 2 * x.r[dp + 1]), order='F')\n            dp += 1\n            crs.append(cr)\n        if kind[j] == 'F':\n            xcr = xcrs[dp]  # r_dp x 2 x r_{dp+1}\n            cr = _np.tensordot(W, xcr, (1, 1)).transpose([0, 4, 1, 2, 3, 5])\n            # <2r_dp| x 2 x 2 x |2r_{dp+1}>\n            cr = cr.reshape((2 * x.r[dp], 2, 2, 2 * x.r[dp + 1]), order='F')\n            dp += 1\n            xcr = xcrs[dp]  # r_dp x 2 x r_{dp+1}\n            # <2| x |1> x <r_dp| x |r_{dp+1}>\n            tmp = _np.tensordot(S, xcr, (1, 1))\n            # tmp = tmp.transpose([0, 2, 1, 3]) # TODO: figure out WHY THE HELL\n            # this spoils everything\n            # <2r_dp| x |r_{dp+1}>\n            tmp = tmp.reshape((2 * x.r[dp], x.r[dp + 1]), order='F')\n            # <2r_{dp-1}| x 2 x 2 x |r_{dp+1}>\n            cr = _np.tensordot(cr, tmp, (3, 0))\n            dp += 1\n            crs.append(cr)\n        else:\n            dotcore = None\n            if kind[j] == 'C':\n                dotcore = P\n            elif kind[j] == 'L':\n                dotcore = Q\n            elif kind[j] == 'U':\n                dotcore = R\n            xcr = xcrs[dp]  # r_dp x 2 x r_{dp+1}\n            # <2| x 2 x 2 x |'1'> x <r_dp| x |r_{dp+1}>\n            cr = _np.tensordot(dotcore, xcr, (1, 1))\n            # <2| x <r_dp| x 2 x 2 x |r_{dp+1}>\n            cr = cr.transpose([0, 3, 1, 2, 4])\n            cr = cr.reshape((2 * x.r[dp], 2, 2, x.r[dp + 1]), order='F')\n            dp += 1\n            crs.append(cr)\n    return _matrix.matrix.from_list(crs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef qlaplace_dd(d):\n    res = _matrix.matrix()\n    d0 = d[::-1]\n    D = len(d0)\n    I = _np.eye(2)\n    J = _np.array([[0, 1], [0, 0]])\n    cr = []\n    if D is 1:\n        for k in xrange(1, d0[0] + 1):\n            if k is 1:\n                cur_core = _np.zeros((1, 2, 2, 3))\n                cur_core[:, :, :, 0] = 2 * I - J - J.T\n                cur_core[:, :, :, 1] = -J\n                cur_core[:, :, :, 2] = -J.T\n            elif k is d0[0]:\n                cur_core = _np.zeros((3, 2, 2, 1))\n                cur_core[0, :, :, 0] = I\n                cur_core[1, :, :, 0] = J.T\n                cur_core[2, :, :, 0] = J\n            else:\n                cur_core = _np.zeros((3, 2, 2, 3))\n                cur_core[0, :, :, 0] = I\n                cur_core[1, :, :, 1] = J\n                cur_core[2, :, :, 2] = J.T\n                cur_core[1, :, :, 0] = J.T\n                cur_core[2, :, :, 0] = J\n            cr.append(cur_core)\n    else:\n        for k in xrange(D):\n            for kappa in xrange(1, d0[k] + 1):\n                if kappa is 1:\n                    if k is 0:\n                        cur_core = _np.zeros((1, 2, 2, 4))\n                        cur_core[:, :, :, 0] = 2 * I - J - J.T\n                        cur_core[:, :, :, 1] = -J\n                        cur_core[:, :, :, 2] = -J.T\n                        cur_core[:, :, :, 3] = I\n                    elif k is D - 1:\n                        cur_core = _np.zeros((2, 2, 2, 3))\n                        cur_core[0, :, :, 0] = 2 * I - J - J.T\n                        cur_core[0, :, :, 1] = -J\n                        cur_core[0, :, :, 2] = -J.T\n                        cur_core[1, :, :, 0] = I\n                    else:\n                        cur_core = _np.zeros((2, 2, 2, 4))\n                        cur_core[0, :, :, 0] = 2 * I - J - J.T\n                        cur_core[0, :, :, 1] = -J\n                        cur_core[0, :, :, 2] = -J.T\n                        cur_core[0, :, :, 3] = I\n                        cur_core[1, :, :, 0] = I\n                elif kappa is d0[k]:\n                    if k is D - 1:\n                        cur_core = _np.zeros((3, 2, 2, 1))\n                        cur_core[0, :, :, 0] = I\n                        cur_core[1, :, :, 0] = J.T\n                        cur_core[2, :, :, 0] = J\n                    else:\n                        cur_core = _np.zeros((4, 2, 2, 2))\n                        cur_core[3, :, :, 0] = I\n                        cur_core[0, :, :, 1] = I\n                        cur_core[1, :, :, 1] = J.T\n                        cur_core[2, :, :, 1] = J\n                else:\n                    if k is D - 1:\n                        cur_core = _np.zeros((3, 2, 2, 3))\n                        cur_core[0, :, :, 0] = I\n                        cur_core[1, :, :, 1] = J\n                        cur_core[2, :, :, 2] = J.T\n                        cur_core[1, :, :, 0] = J.T\n                        cur_core[2, :, :, 0] = J\n                    else:\n                        cur_core = _np.zeros((4, 2, 2, 4))\n                        cur_core[0, :, :, 0] = I\n                        cur_core[1, :, :, 1] = J\n                        cur_core[2, :, :, 2] = J.T\n                        cur_core[1, :, :, 0] = J.T\n                        cur_core[2, :, :, 0] = J\n                        cur_core[3, :, :, 3] = I\n                cr.append(cur_core)\n    return _matrix.matrix.from_list(cr)", "response": "Creates a QTT representation of the Laplace operator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef xfun(n, d=None):\n    if isinstance(n, six.integer_types):\n        n = [n]\n    if d is None:\n        n0 = _np.asanyarray(n, dtype=_np.int32)\n    else:\n        n0 = _np.array(n * d, dtype=_np.int32)\n    d = n0.size\n    if d == 1:\n        return _vector.vector.from_list(\n            [_np.reshape(_np.arange(n0[0]), (1, n0[0], 1))])\n    cr = []\n    cur_core = _np.ones((1, n0[0], 2))\n    cur_core[0, :, 0] = _np.arange(n0[0])\n    cr.append(cur_core)\n    ni = float(n0[0])\n    for i in xrange(1, d - 1):\n        cur_core = _np.zeros((2, n0[i], 2))\n        for j in xrange(n0[i]):\n            cur_core[:, j, :] = _np.eye(2)\n        cur_core[1, :, 0] = ni * _np.arange(n0[i])\n        ni *= n0[i]\n        cr.append(cur_core)\n    cur_core = _np.ones((2, n0[d - 1], 1))\n    cur_core[1, :, 0] = ni * _np.arange(n0[d - 1])\n    cr.append(cur_core)\n    return _vector.vector.from_list(cr)", "response": "Create a QTT - representation of 0 n - > prod"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a QTT - representation of a uniform grid on an interval [ a b )", "response": "def linspace(n, d=None, a=0.0, b=1.0, right=True, left=True):\n    \"\"\" Create a QTT-representation of a uniform grid on an interval [a, b] \"\"\"\n    if isinstance(n, six.integer_types):\n        n = [n]\n    if d is None:\n        n0 = _np.asanyarray(n, dtype=_np.int32)\n    else:\n        n0 = _np.array(n * d, dtype=_np.int32)\n    d = n0.size\n    t = xfun(n0)\n    e = ones(n0)\n    N = _np.prod(n0)  # Size\n    if left and right:\n        h = (b - a) * 1.0 / (N - 1)\n        res = a * e + t * h\n    elif left and not right:\n        h = (b - a) * 1.0 / N\n        res = a * e + t * h\n    elif right and not left:\n        h = (b - a) * 1.0 / N\n        res = a * e + (t + e) * h\n    else:\n        h = (b - a) * 1.0 / (N - 1)\n        res = a * e + (t + e) * h\n    return res.round(1e-13)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates TT - vector for the sin function.", "response": "def sin(d, alpha=1.0, phase=0.0):\n    \"\"\" Create TT-vector for :math:`\\\\sin(\\\\alpha n + \\\\varphi)`.\"\"\"\n    cr = []\n    cur_core = _np.zeros([1, 2, 2], dtype=_np.float)\n    cur_core[0, 0, :] = [_math.cos(phase), _math.sin(phase)]\n    cur_core[0, 1, :] = [_math.cos(alpha + phase), _math.sin(alpha + phase)]\n    cr.append(cur_core)\n    for i in xrange(1, d - 1):\n        cur_core = _np.zeros([2, 2, 2], dtype=_np.float)\n        cur_core[0, 0, :] = [1.0, 0.0]\n        cur_core[1, 0, :] = [0.0, 1.0]\n        cur_core[\n        0,\n        1,\n        :] = [\n            _math.cos(\n                alpha *\n                2 ** i),\n            _math.sin(\n                alpha *\n                2 ** i)]\n        cur_core[1,\n        1,\n        :] = [-_math.sin(alpha * 2 ** i),\n              _math.cos(alpha * 2 ** i)]\n        cr.append(cur_core)\n    cur_core = _np.zeros([2, 2, 1], dtype=_np.float)\n    cur_core[0, :, 0] = [0.0, _math.sin(alpha * 2 ** (d - 1))]\n    cur_core[1, :, 0] = [1.0, _math.cos(alpha * 2 ** (d - 1))]\n    cr.append(cur_core)\n    return _vector.vector.from_list(cr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cos(d, alpha=1.0, phase=0.0):\n    return sin(d, alpha, phase + _math.pi * 0.5)", "response": "Create TT - vector for cos function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating TT - vector for delta - function.", "response": "def delta(n, d=None, center=0):\n    \"\"\" Create TT-vector for delta-function :math:`\\\\delta(x - x_0)`. \"\"\"\n    if isinstance(n, six.integer_types):\n        n = [n]\n    if d is None:\n        n0 = _np.asanyarray(n, dtype=_np.int32)\n    else:\n        n0 = _np.array(n * d, dtype=_np.int32)\n    d = n0.size\n\n    if center < 0:\n        cind = [0] * d\n    else:\n        cind = []\n        for i in xrange(d):\n            cind.append(center % n0[i])\n            center //= n0[i]\n        if center > 0:\n            cind = [0] * d\n    cr = []\n    for i in xrange(d):\n        cur_core = _np.zeros((1, n0[i], 1))\n        cur_core[0, cind[i], 0] = 1\n        cr.append(cur_core)\n    return _vector.vector.from_list(cr)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stepfun(n, d=None, center=1, direction=1):\n    if isinstance(n, six.integer_types):\n        n = [n]\n    if d is None:\n        n0 = _np.asanyarray(n, dtype=_np.int32)\n    else:\n        n0 = _np.array(n * d, dtype=_np.int32)\n    d = n0.size\n    N = _np.prod(n0)\n\n    if center >= N and direction < 0 or center <= 0 and direction > 0:\n        return ones(n0)\n\n    if center <= 0 and direction < 0 or center >= N and direction > 0:\n        raise ValueError(\n            \"Heaviside function with specified center and direction gives zero tensor!\")\n    if direction > 0:\n        center = N - center\n    cind = []\n    for i in xrange(d):\n        cind.append(center % n0[i])\n        center //= n0[i]\n\n    def gen_notx(currcind, currn):\n        return [0.0] * (currn - currcind) + [1.0] * currcind\n\n    def gen_notx_rev(currcind, currn):\n        return [1.0] * currcind + [0.0] * (currn - currcind)\n\n    def gen_x(currcind, currn):\n        result = [0.0] * currn\n        result[currn - currcind - 1] = 1.0\n        return result\n\n    def gen_x_rev(currcind, currn):\n        result = [0.0] * currn\n        result[currcind] = 1.0\n        return result\n\n    if direction > 0:\n        x = gen_x\n        notx = gen_notx\n    else:\n        x = gen_x_rev\n        notx = gen_notx_rev\n\n    crs = []\n    prevrank = 1\n    for i in range(d)[::-1]:\n        break_further = max([0] + cind[:i])\n        nextrank = 2 if break_further else 1\n        one = [1] * n0[i]\n        cr = _np.zeros([nextrank, n0[i], prevrank], dtype=_np.float)\n        tempx = x(cind[i], n0[i])\n        tempnotx = notx(cind[i], n0[i])\n        # high-conditional magic\n        if not break_further:\n            if cind[i]:\n                if prevrank > 1:\n                    cr[0, :, 0] = one\n                    cr[0, :, 1] = tempnotx\n                else:\n                    cr[0, :, 0] = tempnotx\n            else:\n                cr[0, :, 0] = one\n        else:\n            if prevrank > 1:\n                cr[0, :, 0] = one\n                if cind[i]:\n                    cr[0, :, 1] = tempnotx\n                    cr[1, :, 1] = tempx\n                else:\n                    cr[1, :, 1] = tempx\n            else:\n                if cind[i]:\n                    cr[0, :, 0] = tempnotx\n                    cr[1, :, 0] = tempx\n                else:\n                    nextrank = 1\n                    cr = cr[:1, :, :]\n                    cr[0, :, 0] = tempx\n        prevrank = nextrank\n        crs.append(cr)\n    return _vector.vector.from_list(crs[::-1])", "response": "Create TT - vector for Heaviside step function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a list of all the available units in a single tree.", "response": "def unit(n, d=None, j=None, tt_instance=True):\n    ''' Generates e_j _vector in tt.vector format\n    ---------\n    Parameters:\n        n - modes (either integer or array)\n        d - dimensionality (integer)\n        j - position of 1 in full-format e_j (integer)\n        tt_instance - if True, returns tt.vector;\n                      if False, returns tt cores as a list\n    '''\n    if isinstance(n, int):\n        if d is None:\n            d = 1\n        n = n * _np.ones(d, dtype=_np.int32)\n    else:\n        d = len(n)\n    if j is None:\n        j = 0\n    rv = []\n\n    j = _ind2sub(n, j)\n\n    for k in xrange(d):\n        rv.append(_np.zeros((1, n[k], 1)))\n        rv[-1][0, j[k], 0] = 1\n    if tt_instance:\n        rv = _vector.vector.from_list(rv)\n    return rv"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef permute(x, order, eps=None, return_cores=False):\n    '''\n    Permute dimensions (python translation of original matlab code)\n       Y = permute(X, ORDER, EPS) permutes the dimensions of the TT-tensor X\n       according to ORDER, delivering a result at relative accuracy EPS. This\n       function is equivalent to\n          Y = tt_tensor(permute(reshape(full(X), X.n'),ORDER), EPS)\n       but avoids the conversion to the full format.\n\n\n     Simon Etter, Summer 2015\n     Seminar of Applied Mathematics, ETH Zurich\n\n\n     TT-Toolbox 2.2, 2009-2012\n\n    This is TT Toolbox, written by Ivan Oseledets et al. Institute of\n    Numerical Mathematics, Moscow, Russia webpage:\n    http://spring.inm.ras.ru/osel\n\n    For all questions, bugs and suggestions please mail\n    ivan.oseledets@gmail.com\n    ---------------------------\n\n     This code basically performs insertion sort on the TT dimensions:\n      for k = 2:d\n         Bubble the kth dimension to the right (according to ORDER) position in the first 1:k dimensions.\n\n     The current code could be optimised at the following places:\n      - Instead of initially orthogonalising with respect to the first two vertices,\n        orthogonalise directly with respect to the first inversion.\n      - When performing the SVD, check on which side of the current position the\n        next swap will occur and directly establish the appropriate orthogonality\n        (current implementation always assumes we move left).\n     Both changes reduce the number of QRs by at most O(d) and are therefore likely\n     to produce negligible speedup while rendering the code more complicated.\n     '''\n\n    def _reshape(tensor, shape):\n        return _np.reshape(tensor, shape, order='F')\n\n    # Parse input\n    if eps is None:\n        eps = _np.spacing(1)\n    cores = _vector.vector.to_list(x)\n    d = _cp.deepcopy(x.d)\n    n = _cp.deepcopy(x.n)\n    r = _cp.deepcopy(x.r)\n\n    idx = _np.empty(len(order))\n    idx[order] = _np.arange(len(order))\n    eps /= d ** 1.5\n    # ^Numerical evidence suggests that eps = eps/d may be sufficient, however I can only prove correctness\n    #  for this choice of global-to-local conversion factor.\n    assert len(order) > d - 1, 'ORDER must have at least D elements for a D-dimensional tensor'\n\n    # RL-orthogonalise x\n    for kk in xrange(d - 1, 1, -1):  ##########################################\n        new_shape = [r[kk], n[kk] * r[kk + 1]]\n        Q, R = _np.linalg.qr(_reshape(cores[kk], new_shape).T)\n        tr = min(new_shape)\n        cores[kk] = _reshape(Q.T, [tr, n[kk], r[kk + 1]])\n        tmp = _reshape(cores[kk - 1], [r[kk - 1] * n[kk - 1], r[kk]])\n        tmp = _np.dot(tmp, R.T)\n        cores[kk - 1] = _reshape(tmp, [r[kk - 1], n[kk - 1], tr])\n        r[kk] = tr\n    k = 0\n    while (True):\n        # Find next inversion\n        nk = k\n        while (nk < d - 1) and (idx[nk] < idx[nk + 1]):\n            nk += 1\n        if (nk == d - 1):\n            break\n\n        # Move orthogonal centre there\n        for kk in xrange(k, nk - 1):  #############\n            new_shape = [r[kk] * n[kk], r[kk + 1]]\n            Q, R = _np.linalg.qr(_reshape(cores[kk], new_shape))\n            tr = min(new_shape)\n            new_shape = [r[kk], n[kk], tr]\n            cores[kk] = _reshape(Q, new_shape)\n            tmp = _reshape(cores[kk + 1], [r[kk + 1], n[kk + 1] * r[kk + 2]])\n            tmp = _np.dot(R, tmp)\n            cores[kk + 1] = _reshape(tmp, [tr, n[kk + 1], r[kk + 2]])\n            r[kk + 1] = tr\n        k = nk\n\n        # Swap dimensions\n        tmp = _reshape(cores[k], [r[k] * n[k], r[k + 1]])\n        tmp = _np.dot(tmp, _reshape(cores[k + 1], [r[k + 1], n[k + 1] * r[k + 2]]))\n        c = _reshape(tmp, [r[k], n[k], n[k + 1], r[k + 2]])\n        c = _np.transpose(c, [0, 2, 1, 3])\n        tmp = _reshape(c, [r[k] * n[k + 1], n[k] * r[k + 2]])\n        U, S, Vt = _np.linalg.svd(tmp, full_matrices=False)\n        r[k + 1] = max(_my_chop2(S, _np.linalg.norm(S) * eps), 1)\n        lenS = len(S)\n        tmp = U[:, :lenS] * S  # multiplication by diagonal matrix\n        cores[k] = _reshape(tmp[:, :r[k + 1]], [r[k], n[k + 1], r[k + 1]])\n        cores[k + 1] = _reshape(Vt[:r[k + 1], :], [r[k + 1], n[k], r[k + 2]])\n        idx[[k, k + 1]] = idx[[k + 1, k]]\n        n[[k, k + 1]] = n[[k + 1, k]]\n        k = max(k - 1, 0)  ##################\n    # Parse output\n    if return_cores:\n        return cores\n    return _vector.vector.from_list(cores)", "response": "Permute the dimensions of the TT - tensor X according to the given order and return the resulting vector."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the approximate minimum value of the function on a d - dimensional grid.", "response": "def min_func(fun, bounds_min, bounds_max, d=None, rmax=10,\n             n0=64, nswp=10, verb=True, smooth_fun=None):\n    \"\"\"Find (approximate) minimal value of the function on a d-dimensional grid.\"\"\"\n    if d is None:\n        d = len(bounds_min)\n        a = np.asanyarray(bounds_min).copy()\n        b = np.asanyarray(bounds_max).copy()\n    else:\n        a = np.ones(d) * bounds_min\n        b = np.ones(d) * bounds_max\n\n    if smooth_fun is None:\n        smooth_fun = lambda p, lam: (math.pi / 2 - np.arctan(p - lam))\n    #smooth_fun = lambda p, lam: np.exp(-10*(p - lam))\n\n    # We do not need to store the cores, only the interfaces!\n    Rx = [[]] * (d + 1)  # Python list for the interfaces\n    Rx[0] = np.ones((1, 1))\n    Rx[d] = np.ones((1, 1))\n    Jy = [np.empty(0, dtype=np.int)] * (d + 1)\n    ry = rmax * np.ones(d + 1, dtype=np.int)\n    ry[0] = 1\n    ry[d] = 1\n    n = n0 * np.ones(d, dtype=np.int)\n    fun_evals = 0\n\n    grid = [np.reshape(np.linspace(a[i], b[i], n[i]), (n[i], 1))\n            for i in xrange(d)]\n    for i in xrange(d - 1):\n        #cr1 = y[i]\n        ry[i + 1] = min(ry[i + 1], n[i] * ry[i])\n        cr1 = np.random.randn(ry[i], n[i], ry[i + 1])\n        cr1 = reshape(cr1, (ry[i] * n[i], ry[i + 1]))\n        q, r = np.linalg.qr(cr1)\n        ind = maxvol(q)\n        w1 = mkron(np.ones((n[i], 1), dtype=np.int), Jy[i])\n        w2 = mkron(grid[i], np.ones((ry[i], 1), dtype=np.int))\n        Jy[i + 1] = np.hstack((w1, w2))\n        Jy[i + 1] = reshape(Jy[i + 1], (ry[i] * n[i], -1))\n        Jy[i + 1] = Jy[i + 1][ind, :]\n\n        # Jy{i+1} = [kron(ones(n(i),1), Jy{i}), kron((1:n(i))', ones(ry(i),1))];\n        # Jy{i+1} = Jy{i+1}(ind,:);\n    swp = 0\n    dirn = -1\n    i = d - 1\n    lm = float('Inf')\n    while swp < nswp:\n        # Right-to-left sweep\n        # The idea: compute the current core; compute the function of it;\n        # Shift locally or globally? Local shift would be the first try\n        # Compute the current core\n\n        if np.size(Jy[i]) == 0:\n            w1 = np.zeros((ry[i] * n[i] * ry[i + 1], 0), dtype=np.int)\n        else:\n            w1 = mkron(np.ones((n[i] * ry[i + 1], 1), dtype=np.int), Jy[i])\n        w2 = mkron(mkron(np.ones((ry[i + 1], 1), dtype=np.int),\n                         grid[i]), np.ones((ry[i], 1), dtype=np.int))\n        if np.size(Jy[i + 1]) == 0:\n            w3 = np.zeros((ry[i] * n[i] * ry[i + 1], 0), dtype=np.int)\n        else:\n            w3 = mkron(Jy[i + 1], np.ones((ry[i] * n[i], 1), dtype=np.int))\n\n        J = np.hstack((w1, w2, w3))\n        # Just add some random indices to J, which is rnr x d, need to make rn (r + r0) x add,\n        # i.e., just generate random r, random n and random multiindex\n\n        cry = fun(J)\n        fun_evals += cry.size\n        cry = reshape(cry, (ry[i], n[i], ry[i + 1]))\n        min_cur = np.min(cry.flatten(\"F\"))\n        ind_cur = np.argmin(cry.flatten(\"F\"))\n        if lm > min_cur:\n            lm = min_cur\n            x_full = J[ind_cur, :]\n            val = fun(x_full)\n            if verb:\n                print('New record:', val, 'Point:', x_full, 'fevals:', fun_evals)\n        cry = smooth_fun(cry, lm)\n        if (dirn < 0 and i > 0):\n            cry = reshape(cry, (ry[i], n[i] * ry[i + 1]))\n            cry = cry.T\n            #q, r = np.linalg.qr(cry)\n            u, s, v = mysvd(cry, full_matrices=False)\n            ry[i] = min(ry[i], rmax)\n            q = u[:, :ry[i]]\n            ind = rect_maxvol(q)[0]  # maxvol(q)\n            ry[i] = ind.size\n            w1 = mkron(np.ones((ry[i + 1], 1), dtype=np.int), grid[i])\n            if np.size(Jy[i + 1]) == 0:\n                w2 = np.zeros((n[i] * ry[i + 1], 0), dtype=np.int)\n            else:\n                w2 = mkron(Jy[i + 1], np.ones((n[i], 1), dtype=np.int))\n            Jy[i] = np.hstack((w1, w2))\n            Jy[i] = reshape(Jy[i], (n[i] * ry[i + 1], -1))\n            Jy[i] = Jy[i][ind, :]\n\n        if (dirn > 0 and i < d - 1):\n            cry = reshape(cry, (ry[i] * n[i], ry[i + 1]))\n            q, r = np.linalg.qr(cry)\n            #ind = maxvol(q)\n            ind = rect_maxvol(q)[0]\n            ry[i + 1] = ind.size\n            w1 = mkron(np.ones((n[i], 1), dtype=np.int), Jy[i])\n            w2 = mkron(grid[i], np.ones((ry[i], 1), dtype=np.int))\n            Jy[i + 1] = np.hstack((w1, w2))\n            Jy[i + 1] = reshape(Jy[i + 1], (ry[i] * n[i], -1))\n            Jy[i + 1] = Jy[i + 1][ind, :]\n\n        i += dirn\n        if i == d or i == -1:\n            dirn = -dirn\n            i += dirn\n            swp = swp + 1\n    return val, x_full"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the approximate minimum element in a TT - tensor.", "response": "def min_tens(tens, rmax=10, nswp=10, verb=True, smooth_fun=None):\n    \"\"\"Find (approximate) minimal element in a TT-tensor.\"\"\"\n    if smooth_fun is None:\n        smooth_fun = lambda p, lam: (math.pi / 2 - np.arctan(p - lam))\n    d = tens.d\n    Rx = [[]] * (d + 1)  # Python list for the interfaces\n    Rx[0] = np.ones((1, 1))\n    Rx[d] = np.ones((1, 1))\n    Jy = [np.empty(0, dtype=np.int)] * (d + 1)\n    ry = rmax * np.ones(d + 1, dtype=np.int)\n    ry[0] = 1\n    ry[d] = 1\n    n = tens.n\n    elements_seen = 0\n    phi_left = [np.empty(0)] * (d + 1)\n    phi_left[0] = np.array([1])\n    phi_right = [np.empty(0)] * (d + 1)\n    phi_right[d] = np.array([1])\n    cores = tt.tensor.to_list(tens)\n\n    # Fill initial multiindex J randomly.\n    grid = [np.reshape(range(n[i]), (n[i], 1)) for i in xrange(d)]\n    for i in xrange(d - 1):\n        ry[i + 1] = min(ry[i + 1], n[i] * ry[i])\n        ind = sorted(np.random.permutation(ry[i] * n[i])[0:ry[i + 1]])\n        w1 = mkron(np.ones((n[i], 1), dtype=np.int), Jy[i])\n        w2 = mkron(grid[i], np.ones((ry[i], 1), dtype=np.int))\n        Jy[i + 1] = np.hstack((w1, w2))\n        Jy[i + 1] = reshape(Jy[i + 1], (ry[i] * n[i], -1))\n        Jy[i + 1] = Jy[i + 1][ind, :]\n        phi_left[i + 1] = np.tensordot(phi_left[i], cores[i], 1)\n        phi_left[i + 1] = reshape(phi_left[i + 1], (ry[i] * n[i], -1))\n        phi_left[i + 1] = phi_left[i + 1][ind, :]\n    swp = 0\n    dirn = -1\n    i = d - 1\n    lm = float('Inf')\n    while swp < nswp:\n        # Right-to-left sweep\n        # The idea: compute the current core; compute the function of it;\n        # Shift locally or globally? Local shift would be the first try\n        # Compute the current core\n\n        if np.size(Jy[i]) == 0:\n            w1 = np.zeros((ry[i] * n[i] * ry[i + 1], 0), dtype=np.int)\n        else:\n            w1 = mkron(np.ones((n[i] * ry[i + 1], 1), dtype=np.int), Jy[i])\n        w2 = mkron(mkron(np.ones((ry[i + 1], 1), dtype=np.int),\n                         grid[i]), np.ones((ry[i], 1), dtype=np.int))\n        if np.size(Jy[i + 1]) == 0:\n            w3 = np.zeros((ry[i] * n[i] * ry[i + 1], 0), dtype=np.int)\n        else:\n            w3 = mkron(Jy[i + 1], np.ones((ry[i] * n[i], 1), dtype=np.int))\n        J = np.hstack((w1, w2, w3))\n\n        phi_right[i] = np.tensordot(cores[i], phi_right[i + 1], 1)\n        phi_right[i] = reshape(phi_right[i], (-1, n[i] * ry[i + 1]))\n\n        cry = np.tensordot(\n            phi_left[i], np.tensordot(\n                cores[i], phi_right[\n                    i + 1], 1), 1)\n        elements_seen += cry.size\n        cry = reshape(cry, (ry[i], n[i], ry[i + 1]))\n        min_cur = np.min(cry.flatten(\"F\"))\n        ind_cur = np.argmin(cry.flatten(\"F\"))\n        if lm > min_cur:\n            lm = min_cur\n            x_full = J[ind_cur, :]\n            val = tens[x_full]\n            if verb:\n                print('New record:', val, 'Point:', x_full, 'elements seen:', elements_seen)\n        cry = smooth_fun(cry, lm)\n        if dirn < 0 and i > 0:\n            cry = reshape(cry, (ry[i], n[i] * ry[i + 1]))\n            cry = cry.T\n            #q, r = np.linalg.qr(cry)\n            u, s, v = mysvd(cry, full_matrices=False)\n            ry[i] = min(ry[i], rmax)\n            q = u[:, :ry[i]]\n            ind = rect_maxvol(q)[0]  # maxvol(q)\n            ry[i] = ind.size\n            w1 = mkron(np.ones((ry[i + 1], 1), dtype=np.int), grid[i])\n            if np.size(Jy[i + 1]) == 0:\n                w2 = np.zeros((n[i] * ry[i + 1], 0), dtype=np.int)\n            else:\n                w2 = mkron(Jy[i + 1], np.ones((n[i], 1), dtype=np.int))\n            Jy[i] = np.hstack((w1, w2))\n            Jy[i] = reshape(Jy[i], (n[i] * ry[i + 1], -1))\n            Jy[i] = Jy[i][ind, :]\n            phi_right[i] = np.tensordot(cores[i], phi_right[i + 1], 1)\n            phi_right[i] = reshape(phi_right[i], (-1, n[i] * ry[i + 1]))\n            phi_right[i] = phi_right[i][:, ind]\n\n        if dirn > 0 and i < d - 1:\n            cry = reshape(cry, (ry[i] * n[i], ry[i + 1]))\n            q, r = np.linalg.qr(cry)\n            #ind = maxvol(q)\n            ind = rect_maxvol(q)[0]\n            ry[i + 1] = ind.size\n            phi_left[i + 1] = np.tensordot(phi_left[i], cores[i], 1)\n            phi_left[i + 1] = reshape(phi_left[i + 1], (ry[i] * n[i], -1))\n            phi_left[i + 1] = phi_left[i + 1][ind, :]\n            w1 = mkron(np.ones((n[i], 1), dtype=np.int), Jy[i])\n            w2 = mkron(grid[i], np.ones((ry[i], 1), dtype=np.int))\n            Jy[i + 1] = np.hstack((w1, w2))\n            Jy[i + 1] = reshape(Jy[i + 1], (ry[i] * n[i], -1))\n            Jy[i + 1] = Jy[i + 1][ind, :]\n\n        i += dirn\n        if i == d or i == -1:\n            dirn = -dirn\n            i += dirn\n            swp = swp + 1\n    return val, x_full"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the orthogonal matrix Q_{ \\ leq i as defined in [ 1 ].", "response": "def left(X, i):\n    \"\"\"Compute the orthogonal matrix Q_{\\leq i} as defined in [1].\"\"\"\n    if i < 0:\n        return np.ones([1, 1])\n    answ = np.ones([1, 1])\n    cores = tt.tensor.to_list(X)\n    for dim in xrange(i+1):\n        answ = np.tensordot(answ, cores[dim], 1)\n    answ = reshape(answ, (-1, X.r[i+1]))\n    return answ"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef right(X, i):\n    if i > X.d-1:\n        return np.ones([1, 1])\n    answ = np.ones([1, 1])\n    cores = tt.tensor.to_list(X)\n    for dim in xrange(X.d-1, i-1, -1):\n        answ = np.tensordot(cores[dim], answ, 1)\n    answ = reshape(answ, (X.r[i], -1))\n    return answ.T", "response": "Compute the orthogonal matrix Q_{ \\ geq i as defined in [ 1 ]."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the i - th unfolding of a tensor.", "response": "def unfolding(tens, i):\n    \"\"\"Compute the i-th unfolding of a tensor.\"\"\"\n    return reshape(tens.full(), (np.prod(tens.n[0:(i+1)]), -1))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the lhs matrix with the new values from the lhs matrix.", "response": "def _update_lhs(lhs, xCore, zCore, new_lhs):\n    \"\"\" Function to be called from the project()\"\"\"\n    # TODO: Use intermediate variable to use 5 nested loops instead of 6.\n    r_old_x, n, r_x = xCore.shape\n    num_obj, r_old_z, n, r_z = zCore.shape\n    for idx in range(num_obj):\n        for val in range(n):\n            for alpha_old_z in range(r_old_z):\n                for alpha_z in range(r_z):\n                    for alpha_old_x in range(r_old_x):\n                        for alpha_x in range(r_x):\n                            curr_value = lhs[idx, alpha_old_x, alpha_old_z]\n                            curr_value *= xCore[alpha_old_x, val, alpha_x]\n                            curr_value *= zCore[idx, alpha_old_z, val, alpha_z]\n                            new_lhs[idx, alpha_x, alpha_z] += curr_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_rhs(curr_rhs, xCore, zCore, new_rhs):\n    # TODO: Use intermediate variable to use 5 nested loops instead of 6.\n    r_x, n, r_old_x = xCore.shape\n    num_obj, r_z, n, r_old_z = zCore.shape\n    for idx in range(num_obj):\n        for val in range(n):\n            for alpha_old_z in range(r_old_z):\n                for alpha_z in range(r_z):\n                    for alpha_old_x in range(r_old_x):\n                        for alpha_x in range(r_x):\n                            curr_value = curr_rhs[idx, alpha_old_z, alpha_old_x]\n                            curr_value *= xCore[alpha_x, val, alpha_old_x]\n                            curr_value *= zCore[idx, alpha_z, val, alpha_old_z]\n                            new_rhs[idx, alpha_z, alpha_x] += curr_value", "response": "Update the RHS array of the current RHS array with the new values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef project(X, Z, use_jit=False, debug=False):\n    zArr = None\n    if isinstance(Z, tt.vector):\n        zArr = [Z]\n    else:\n        zArr = Z\n\n    # Get rid of redundant ranks (they cause technical difficulties).\n    X = X.round(eps=0)\n\n    numDims, modeSize = X.d, X.n\n    coresX = tt.tensor.to_list(X)\n    coresZ = [None] * len(zArr)\n    for idx in xrange(len(zArr)):\n        assert(modeSize == zArr[idx].n).all()\n        coresZ[idx] = tt.tensor.to_list(zArr[idx])\n\n    if not use_jit and len(zArr) > 10:\n        print('Consider using use_jit=True option to speed up the projection '\n              'process.')\n    if use_jit:\n        for dim in xrange(numDims):\n            r1, n, r2 = coresZ[0][dim].shape\n            for idx in xrange(len(zArr)):\n                if (r1, n, r2) != coresZ[idx][dim].shape:\n                    print('Warning: cannot use the jit version when not all '\n                          'the ranks in the Z array are equal each other. '\n                          'Switching to the non-jit version.')\n                    use_jit = False\n\n    if use_jit:\n        zCoresDim = [None] * numDims\n        for dim in xrange(numDims):\n            r1, n, r2 = coresZ[0][dim].shape\n            zCoresDim[dim] = np.zeros([len(zArr), r1, n, r2])\n            for idx in xrange(len(zArr)):\n                if (r1, n, r2) != coresZ[idx][dim].shape:\n                    print('Warning: cannot use the jit version when not all '\n                          'the ranks in the Z array are equal each other. '\n                          'Switching to the non-jit version.')\n                    use_jit = False\n                zCoresDim[dim][idx, :, :, :] = coresZ[idx][dim]\n        # Initialize the cores of the projection_X(sum z[i]).\n        coresP = []\n        for dim in xrange(numDims):\n            r1 = 2 * X.r[dim]\n            r2 = 2 * X.r[dim+1]\n            if dim == 0:\n                r1 = 1\n            if dim == numDims - 1:\n                r2 = 1\n            coresP.append(np.zeros((r1, modeSize[dim], r2)))\n        # rhs[dim] is a len(zArr) x zArr[idx] x X.rank_dim.rank_dim ndarray.\n        # Right to left orthogonalization of X and preparation of the rhs vectors.\n        for dim in xrange(numDims-1, 0, -1):\n            # Right to left orthogonalization of the X cores.\n            coresX = cores_orthogonalization_step(coresX, dim, left_to_right=False)\n            r1, n, r2 = coresX[dim].shape\n\n            # Fill the right orthogonal part of the projection.\n            for value in xrange(modeSize[dim]):\n                coresP[dim][0:r1, value, 0:r2] = coresX[dim][:, value, :]\n\n        rhs = [None] * (numDims+1)\n        for dim in xrange(numDims):\n            rhs[dim] = np.zeros([len(zArr), zArr[idx].r[dim], coresX[dim].shape[0]])\n        rhs[numDims] = np.ones([len(zArr), 1, 1])\n\n        for dim in xrange(numDims-1, 0, -1):\n            _update_rhs(rhs[dim+1], coresX[dim], zCoresDim[dim], rhs[dim])\n\n        if debug:\n            assert(np.allclose(X.full(), tt.tensor.from_list(coresX).full()))\n\n        # lsh is a len(zArr) x X.rank_dim x zArr[idx].rank_dim ndarray.\n        lhs = np.ones([len(zArr), 1, 1])\n        # Left to right sweep.\n        for dim in xrange(numDims):\n            cc = coresX[dim].copy()\n            r1, n, r2 = cc.shape\n            if dim < numDims-1:\n                # Left to right orthogonalization.\n                cc = reshape(cc, (-1, r2))\n                cc, rr = np.linalg.qr(cc)\n                r2 = cc.shape[1]\n                # Warning: since ranks can change here, do not use X.r!\n                # Use coresX[dim].shape instead.\n                if debug:\n                    # Need to do it before the move non orthogonal part rr to\n                    # the coresX[dim+1].\n                    rightQ = right(tt.tensor.from_list(coresX), dim+1)\n                coresX[dim] = reshape(cc, (r1, n, r2)).copy()\n                coresX[dim+1] = np.tensordot(rr, coresX[dim+1], 1)\n\n                new_lhs = np.zeros([len(zArr), r2, zArr[idx].r[dim+1]])\n                _update_lhs(lhs, coresX[dim], zCoresDim[dim], new_lhs)\n\n                # See the correspondic section in the non-jit version of this\n                # code for a less confusing implementation of\n                # the transformation below.\n                currPCore = np.einsum('ijk,iklm->ijlm', lhs, zCoresDim[dim])\n                currPCore = reshape(currPCore, (len(zArr), r1*n, -1))\n                currPCore -= np.einsum('ij,kjl->kil', cc, new_lhs)\n                currPCore = np.einsum('ijk,ikl', currPCore, rhs[dim+1])\n                currPCore = reshape(currPCore, (r1, modeSize[dim], r2))\n                if dim == 0:\n                    coresP[dim][0:r1, :, 0:r2] += currPCore\n                else:\n                    coresP[dim][r1:, :, 0:r2] += currPCore\n                if debug:\n                    explicit_sum = np.zeros((r1, modeSize[dim], r2))\n                    for idx in xrange(len(zArr)):\n                        leftQm1 = left(tt.tensor.from_list(coresX), dim-1)\n                        leftQ = left(tt.tensor.from_list(coresX), dim)\n\n                        first = np.tensordot(leftQm1.T, unfolding(zArr[idx], dim-1), 1)\n                        second = reshape(first, (-1, np.prod(modeSize[dim+1:])))\n                        if dim < numDims-1:\n                            explicit = second.dot(rightQ)\n                            orth_cc = reshape(coresX[dim], (-1, coresX[dim].shape[2]))\n                            explicit -= orth_cc.dot(leftQ.T.dot(unfolding(zArr[idx], dim)).dot(rightQ))\n                        else:\n                            explicit = second\n                        explicit_sum += reshape(explicit, currPCore.shape)\n                    assert(np.allclose(explicit_sum, currPCore))\n                lhs = new_lhs\n\n                if dim == 0:\n                    coresP[dim][0:r1, :, r2:] = coresX[dim]\n                else:\n                    coresP[dim][r1:, :, r2:] = coresX[dim]\n\n            if dim == numDims-1:\n                coresP[dim][r1:, :, 0:r2] += np.einsum('ijk,iklm->jlm', lhs, zCoresDim[dim])\n\n        if debug:\n            assert(np.allclose(X.full(), tt.tensor.from_list(coresX).full()))\n        return tt.tensor.from_list(coresP)\n    else:\n        # Non-jit version of the code.\n        # Initialize the cores of the projection_X(sum z[i]).\n        coresP = []\n        for dim in xrange(numDims):\n            r1 = 2 * X.r[dim]\n            r2 = 2 * X.r[dim+1]\n            if dim == 0:\n                r1 = 1\n            if dim == numDims - 1:\n                r2 = 1\n            coresP.append(np.zeros((r1, modeSize[dim], r2)))\n        # rhs[idx][dim] is an (Z.rank_dim * X.rank_dim) x 1 vector\n        rhs = [[0] * (numDims+1) for _ in xrange(len(zArr))]\n        for idx in xrange(len(zArr)):\n            rhs[idx][numDims] = np.ones([1, 1])\n        # Right to left sweep to orthogonalize the cores and prepare rhs.\n        for dim in xrange(numDims-1, 0, -1):\n            # Right to left orthogonalization of the X cores.\n            coresX = cores_orthogonalization_step(coresX, dim, left_to_right=False)\n            r1, n, r2 = coresX[dim].shape\n\n            # Fill the right orthogonal part of the projection.\n            coresP[dim][0:r1, :, 0:r2] = coresX[dim]\n            # Compute rhs.\n            for idx in xrange(len(zArr)):\n                coreProd = np.tensordot(coresZ[idx][dim], coresX[dim], axes=(1, 1))\n                coreProd = np.transpose(coreProd, (0, 2, 1, 3))\n                coreProd = reshape(coreProd, (zArr[idx].r[dim]*r1, zArr[idx].r[dim+1]*r2))\n                rhs[idx][dim] = np.dot(coreProd, rhs[idx][dim+1])\n        if debug:\n            assert(np.allclose(X.full(), tt.tensor.from_list(coresX).full()))\n\n        # lsh[idx] is an X.rank_dim x zArr[idx].rank_dim matrix.\n        lhs = [np.ones([1, 1]) for _ in xrange(len(zArr))]\n        # Left to right sweep.\n        for dim in xrange(numDims - 1):\n            if debug:\n                rightQ = right(tt.tensor.from_list(coresX), dim+1)\n            # Left to right orthogonalization of the X cores.\n            coresX = cores_orthogonalization_step(coresX, dim, left_to_right=True)\n            r1, n, r2 = coresX[dim].shape\n            cc = reshape(coresX[dim], (-1, r2))\n\n            for idx in xrange(len(zArr)):\n                currZCore = reshape(coresZ[idx][dim], (zArr[idx].r[dim], -1))\n                currPCore = np.dot(lhs[idx], currZCore)\n\n                # TODO: consider using np.einsum.\n                coreProd = np.tensordot(coresX[dim], coresZ[idx][dim], axes=(1, 1))\n                coreProd = np.transpose(coreProd, (0, 2, 1, 3))\n                coreProd = reshape(coreProd, (r1*zArr[idx].r[dim], r2*zArr[idx].r[dim+1]))\n                lhs[idx] = reshape(lhs[idx], (1, -1))\n                lhs[idx] = np.dot(lhs[idx], coreProd)\n                lhs[idx] = reshape(lhs[idx], (r2, zArr[idx].r[dim+1]))\n\n                currPCore = reshape(currPCore, (-1, zArr[idx].r[dim+1]))\n                currPCore -= np.dot(cc, lhs[idx])\n                rhs[idx][dim+1] = reshape(rhs[idx][dim+1], (zArr[idx].r[dim+1], r2))\n                currPCore = np.dot(currPCore, rhs[idx][dim+1])\n                currPCore = reshape(currPCore, (r1, modeSize[dim], r2))\n                if dim == 0:\n                    coresP[dim][0:r1, :, 0:r2] += currPCore\n                else:\n                    coresP[dim][r1:, :, 0:r2] += currPCore\n\n                if debug:\n                    leftQm1 = left(tt.tensor.from_list(coresX), dim-1)\n                    leftQ = left(tt.tensor.from_list(coresX), dim)\n\n                    first = np.tensordot(leftQm1.T, unfolding(zArr[idx], dim-1), 1)\n                    second = reshape(first, (-1, np.prod(modeSize[dim+1:])))\n                    if dim < numDims-1:\n                        explicit = second.dot(rightQ)\n                        orth_cc = reshape(coresX[dim], (-1, coresX[dim].shape[2]))\n                        explicit -= orth_cc.dot(leftQ.T.dot(unfolding(zArr[idx], dim)).dot(rightQ))\n                    else:\n                        explicit = second\n                    explicit = reshape(explicit, currPCore.shape)\n                    assert(np.allclose(explicit, currPCore))\n\n            if dim == 0:\n                coresP[dim][0:r1, :, r2:] = coresX[dim]\n            else:\n                coresP[dim][r1:, :, r2:] = coresX[dim]\n\n        for idx in xrange(len(zArr)):\n            r1, n, r2 = coresX[numDims-1].shape\n            currZCore = reshape(coresZ[idx][numDims-1], (zArr[idx].r[numDims-1], -1))\n            currPCore = np.dot(lhs[idx], currZCore)\n            currPCore = reshape(currPCore, (r1, n, r2))\n            coresP[numDims-1][r1:, :, 0:r2] += currPCore\n\n        if debug:\n            assert(np.allclose(X.full(), tt.tensor.from_list(coresX).full()))\n        return tt.tensor.from_list(coresP)", "response": "Project a tensor X on the tangent space of tensor Z on the tangent space of tensor X."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef projector_splitting_add(Y, delta, debug=False):\n    # Get rid of redundant ranks (they cause technical difficulties).\n    delta = delta.round(eps=0)\n    numDims = delta.d\n    assert(numDims == Y.d)\n    modeSize = delta.n\n    assert(modeSize == Y.n).all()\n    coresDelta = tt.tensor.to_list(delta)\n    coresY = tt.tensor.to_list(Y)\n    # rhs[dim] is an (delta.rank_dim * Y.rank_dim) x 1 vector\n    rhs = [None] * (numDims+1)\n    rhs[numDims] = np.ones([1, 1])\n    # Right to left sweep to orthogonalize the cores and prepare the rhs.\n    for dim in xrange(numDims-1, 0, -1):\n        # Right to left orthogonalization of the Y cores.\n        coresY = cores_orthogonalization_step(coresY, dim, left_to_right=False)\n        r1, n, r2 = coresY[dim].shape\n\n        # rhs computation.\n        coreProd = np.tensordot(coresDelta[dim], coresY[dim], axes=(1, 1))\n        coreProd = np.transpose(coreProd, (0, 2, 1, 3))\n        coreProd = reshape(coreProd, (delta.r[dim]*r1, delta.r[dim+1]*r2))\n        rhs[dim] = np.dot(coreProd, rhs[dim+1])\n    if debug:\n        assert(np.allclose(Y.full(), tt.tensor.from_list(coresY).full()))\n\n    # lsh is an Y.rank_dim x delta.rank_dim matrix.\n    lhs = np.ones([1, 1])\n    # s is an Y.rank_dim x Y.rank_dim matrix.\n    s = np.ones([1, 1])\n    # Left to right projector splitting sweep.\n    for dim in xrange(numDims):\n        # Y^+ (formula 4.10)\n        cc = coresDelta[dim].copy()\n        r1, n, r2 = coresY[dim].shape\n        cc = np.tensordot(lhs, cc, 1)\n        rhs[dim+1] = reshape(rhs[dim+1], (delta.r[dim+1], r2))\n        cc = reshape(cc, (-1, delta.r[dim+1]))\n        cc = np.dot(cc, rhs[dim+1])\n        if debug:\n            first = np.kron(np.eye(modeSize[dim]), left(tt.tensor.from_list(coresY), dim-1).T)\n            second = np.dot(first, unfolding(delta, dim))\n            explicit = np.dot(second, right(tt.tensor.from_list(coresY), dim+1))\n            assert(np.allclose(explicit, cc))\n        cc += reshape(np.tensordot(s, coresY[dim], 1), (-1, Y.r[dim+1]))\n        if dim < numDims-1:\n            cc, rr = np.linalg.qr(cc)\n            # TODO: do we need to use r1 = cc.shape[1] here????\n        cc = reshape(cc, coresY[dim].shape)\n        coresY[dim] = cc.copy()\n\n        if dim < numDims-1:\n            coreProd = np.tensordot(coresY[dim], coresDelta[dim], axes=(1, 1))\n            coreProd = np.transpose(coreProd, (0, 2, 1, 3))\n            coreProd = reshape(coreProd, (r1*delta.r[dim], r2*delta.r[dim+1]))\n            lhs = reshape(lhs, (1, -1))\n            lhs = np.dot(lhs, coreProd)\n            lhs = reshape(lhs, (r2, delta.r[dim+1]))\n\n        if dim < numDims-1:\n            # Y^- (formula 4.7)\n            s = rr - np.dot(lhs, rhs[dim+1])\n            if debug:\n                first = left(tt.tensor.from_list(coresY), dim).T\n                second = np.dot(first, unfolding(delta, dim))\n                explicit = np.dot(second, right(tt.tensor.from_list(coresY), dim+1))\n                assert(np.allclose(explicit, np.dot(lhs, rhs[dim+1])))\n\n    return tt.tensor.from_list(coresY)", "response": "Compute Y + delta via the projector splitting scheme."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tt_qr(X, left_to_right=True):\n    # Get rid of redundant ranks (they cause technical difficulties).\n    X = X.round(eps=0)\n    numDims = X.d\n    coresX = tt.tensor.to_list(X)\n\n    if left_to_right:\n        # Left to right orthogonalization of the X cores.\n        for dim in xrange(0, numDims-1):\n            coresX = cores_orthogonalization_step(\n                coresX, dim, left_to_right=left_to_right)\n        last_core = coresX[numDims-1]\n        r1, n, r2 = last_core.shape\n        last_core, rr = np.linalg.qr(reshape(last_core, (-1, r2)))\n        coresX[numDims-1] = reshape(last_core, (r1, n, -1))\n    else:\n        # Right to left orthogonalization of X cores\n        for dim in xrange(numDims-1, 0, -1):\n            coresX = cores_orthogonalization_step(\n                coresX, dim, left_to_right=left_to_right)\n        last_core = coresX[0]\n        r1, n, r2 = last_core.shape\n        last_core, rr = np.linalg.qr(\n            np.transpose(reshape(last_core, (r1, -1)))\n        )\n        coresX[0] = reshape(\n            np.transpose(last_core),\n            (-1, n, r2))\n        rr = np.transpose(rr)\n\n    return tt.tensor.from_list(coresX), rr", "response": "This function computes the orthogonalized matrix of a TT tensor X and returns X_orth R - orthogonal tensor and right ( lower triangular matrix of the TT tensor X."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntranslate full - format index into tt. vector one s.", "response": "def ind2sub(siz, idx):\n    '''\n    Translates full-format index into tt.vector one's.\n    ----------\n    Parameters:\n        siz - tt.vector modes\n        idx - full-vector index\n    Note: not vectorized.\n    '''\n    n = len(siz)\n    subs = _np.empty((n))\n    k = _np.cumprod(siz[:-1])\n    k = _np.concatenate((_np.ones(1), k))\n    for i in xrange(n - 1, -1, -1):\n        subs[i] = _np.floor(idx / k[i])\n        idx = idx % k[i]\n    return subs.astype(_np.int32)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ksl(A, y0, tau, verb=1, scheme='symm', space=8, rmax=2000, use_normest=1):\n\n    y0 = y0.round(1e-14)    # This will fix ranks\n                            # to be no more than maximal reasonable.\n                            # Fortran part doesn't  handle excessive ranks\n    ry = y0.r.copy()\n    if scheme is 'symm':\n        tp = 2\n    else:\n        tp = 1\n\n    usenrm = int(use_normest)\n\n    # Check for dtype\n    y = tt.vector()\n    if np.iscomplex(A.tt.core).any() or np.iscomplex(y0.core).any():\n        dyn_tt.dyn_tt.ztt_ksl(\n            y0.d,\n            A.n,\n            A.m,\n            A.tt.r,\n            A.tt.core + 0j,\n            y0.core + 0j,\n            ry,\n            tau,\n            rmax,\n            0,\n            10,\n            verb,\n            tp,\n            space,\n            usenrm\n        )\n        y.core = dyn_tt.dyn_tt.zresult_core.copy()\n    else:\n        A.tt.core = np.real(A.tt.core)\n        y0.core = np.real(y0.core)\n        dyn_tt.dyn_tt.tt_ksl(\n            y0.d,\n            A.n,\n            A.m,\n            A.tt.r,\n            A.tt.core,\n            y0.core,\n            ry,\n            tau,\n            rmax,\n            0,\n            10,\n            verb,\n            tp,\n            space,\n            usenrm\n            )\n        y.core = dyn_tt.dyn_tt.dresult_core.copy()\n    dyn_tt.dyn_tt.deallocate_result()\n    y.d = y0.d\n    y.n = A.n.copy()\n    y.r = ry\n    y.get_ps()\n    return y", "response": "This function performs one step of dynamical tensor - train approximation based on projector splitting integrator\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef amen_solve(A, f, x0, eps, kickrank=4, nswp=20, local_prec='n',\n               local_iters=2, local_restart=40, trunc_norm=1, max_full_size=50, verb=1):\n    \"\"\" Approximate linear system solution in the tensor-train (TT) format\n        using Alternating minimal energy (AMEN approach)\n\n\n    :References: Sergey Dolgov, Dmitry. Savostyanov\n\n                 Paper 1: http://arxiv.org/abs/1301.6068\n                 Paper 2: http://arxiv.org/abs/1304.1222\n\n    :param A: Matrix in the TT-format\n    :type A: matrix\n    :param f: Right-hand side in the TT-format\n    :type f: tensor\n    :param x0: TT-tensor of initial guess.\n    :type x0: tensor\n    :param eps: Accuracy.\n    :type eps: float\n    :param kickrank: compression rank of the residual Z, i.e. enrichment size [4]\n    :param nswp: maximal number of sweeps [50]\n    :param local_prec: local preconditioner: '' (no prec.), 'ljacobi', 'cjacobi', 'rjacobi' ['']\n    :param local_iters: dimension of local gmres [40]\n    :param local_restart: dimension of local gmres [40]\n    :param trunc_norm: truncate in either Frob. ('fro'), or residual norm ('residual') ['residual']\n    :param max_full_size: maximal size of the local matrix for the full solver [50]\n    :param verb: 0 -- no info output, 1 -- print info output\n\n    :Example:\n\n        >>> import tt\n        >>> import tt.amen #Needed, not imported automatically\n        >>> a = tt.qlaplace_dd([8, 8, 8]) #3D-Laplacian\n        >>> rhs = tt.ones(2, 3 * 8) #Right-hand side of all ones\n        >>> x = tt.amen.amen_solve(a, rhs, rhs, 1e-8)\n        amen_solve: swp=1, max_dx= 9.766E-01, max_res= 3.269E+00, max_rank=5\n        amen_solve: swp=2, max_dx= 4.293E-01, max_res= 8.335E+00, max_rank=9\n        amen_solve: swp=3, max_dx= 1.135E-01, max_res= 5.341E+00, max_rank=13\n        amen_solve: swp=4, max_dx= 9.032E-03, max_res= 5.908E-01, max_rank=17\n        amen_solve: swp=5, max_dx= 9.500E-04, max_res= 7.636E-02, max_rank=21\n        amen_solve: swp=6, max_dx= 4.002E-05, max_res= 5.573E-03, max_rank=25\n        amen_solve: swp=7, max_dx= 4.949E-06, max_res= 8.418E-04, max_rank=29\n        amen_solve: swp=8, max_dx= 9.618E-07, max_res= 2.599E-04, max_rank=33\n        amen_solve: swp=9, max_dx= 2.792E-07, max_res= 6.336E-05, max_rank=37\n        amen_solve: swp=10, max_dx= 4.730E-08, max_res= 1.663E-05, max_rank=41\n        amen_solve: swp=11, max_dx= 1.508E-08, max_res= 5.463E-06, max_rank=45\n        amen_solve: swp=12, max_dx= 3.771E-09, max_res= 1.847E-06, max_rank=49\n        amen_solve: swp=13, max_dx= 7.797E-10, max_res= 6.203E-07, max_rank=53\n        amen_solve: swp=14, max_dx= 1.747E-10, max_res= 2.058E-07, max_rank=57\n        amen_solve: swp=15, max_dx= 8.150E-11, max_res= 8.555E-08, max_rank=61\n        amen_solve: swp=16, max_dx= 2.399E-11, max_res= 4.215E-08, max_rank=65\n        amen_solve: swp=17, max_dx= 7.871E-12, max_res= 1.341E-08, max_rank=69\n        amen_solve: swp=18, max_dx= 3.053E-12, max_res= 6.982E-09, max_rank=73\n        >>> print (tt.matvec(a, x) - rhs).norm() / rhs.norm()\n        5.5152374305127345e-09\n    \"\"\"\n    m = A.m.copy()\n    rx0 = x0.r.copy()\n    psx0 = x0.ps.copy()\n    if A.is_complex or f.is_complex:\n        amen_f90.amen_f90.ztt_amen_wrapper(f.d, A.n, m,\n                                           A.tt.r, A.tt.ps, A.tt.core,\n                                           f.r, f.ps, f.core,\n                                           rx0, psx0, x0.core,\n                                           eps, kickrank, nswp, local_iters, local_restart, trunc_norm, max_full_size, verb, local_prec)\n    else:\n        if x0.is_complex:\n            x0 = x0.real()\n            rx0 = x0.r.copy()\n            psx0 = x0.ps.copy()\n        amen_f90.amen_f90.dtt_amen_wrapper(f.d, A.n, m,\n                                           A.tt.r, A.tt.ps, A.tt.core,\n                                           f.r, f.ps, f.core,\n                                           rx0, psx0, x0.core,\n                                           eps, kickrank, nswp, local_iters, local_restart, trunc_norm, max_full_size, verb, local_prec)\n    x = tt.tensor()\n    x.d = f.d\n    x.n = m.copy()\n    x.r = rx0\n    if A.is_complex or f.is_complex:\n        x.core = amen_f90.amen_f90.zcore.copy()\n    else:\n        x.core = amen_f90.amen_f90.core.copy()\n    amen_f90.amen_f90.deallocate_result()\n    x.get_ps()\n    return tt.vector.from_list(tt.tensor.to_list(x))", "response": "Proximate linear system solution in the tensor - train."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef T(self):\n        mycrs = matrix.to_list(self)\n        trans_crs = []\n        for cr in mycrs:\n            trans_crs.append(_np.transpose(cr, [0, 2, 1, 3]))\n        return matrix.from_list(trans_crs)", "response": "Transposed TT - matrix"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn real part of a matrix.", "response": "def real(self):\n        \"\"\"Return real part of a matrix.\"\"\"\n        return matrix(self.tt.real(), n=self.n, m=self.m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef imag(self):\n        return matrix(self.tt.imag(), n=self.n, m=self.m)", "response": "Return imaginary part of a matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef c2r(self):\n        return matrix(a=self.tt.__complex_op('M'), n=_np.concatenate(\n            (self.n, [2])), m=_np.concatenate((self.m, [2])))", "response": "Return real matrix from complex one suitable for solving complex linear system with real solver."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing an approximation to a TT - matrix in with accuracy eps", "response": "def round(self, eps=1e-14, rmax=100000):\n        \"\"\" Computes an approximation to a\n            TT-matrix in with accuracy EPS\n        \"\"\"\n        c = matrix()\n        c.tt = self.tt.round(eps, rmax)\n        c.n = self.n.copy()\n        c.m = self.m.copy()\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a copy of the TT - matrix", "response": "def copy(self):\n        \"\"\" Creates a copy of the TT-matrix \"\"\"\n        c = matrix()\n        c.tt = self.tt.copy()\n        c.n = self.n.copy()\n        c.m = self.m.copy()\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef full(self):\n        N = self.n.prod()\n        M = self.m.prod()\n        a = self.tt.full()\n        d = self.tt.d\n        sz = _np.vstack((self.n, self.m)).flatten('F')\n        a = a.reshape(sz, order='F')\n        # Design a permutation\n        prm = _np.arange(2 * d)\n        prm = prm.reshape((d, 2), order='F')\n        prm = prm.transpose()\n        prm = prm.flatten('F')\n        # Get the inverse permutation\n        iprm = [0] * (2 * d)\n        for i in xrange(2 * d):\n            iprm[prm[i]] = i\n        a = a.transpose(iprm).reshape(N, M, order='F')\n        a = a.reshape(N, M)\n        return a", "response": "Transforms a TT - matrix into a full matrix"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napproximating the matrix-by-vector via the AMEn iteration [y,z]=amen_mv(A, x, tol, varargin) Attempts to approximate the y = A*x with accuracy TOL using the AMEn+ALS iteration. Matrix A has to be given in the TT-format, right-hand side x should be given in the TT-format also. Options are provided in form 'PropertyName1',PropertyValue1,'PropertyName2',PropertyValue2 and so on. The parameters are set to default (in brackets in the following) The list of option names and default values are: o y0 - initial approximation to Ax [rand rank-2] o nswp - maximal number of sweeps [20] o verb - verbosity level, 0-silent, 1-sweep info, 2-block info [1] o kickrank - compression rank of the error, i.e. enrichment size [3] o init_qr - perform QR of the input (save some time in ts, etc) [true] o renorm - Orthog. and truncation methods: direct (svd,qr) or gram (apply svd to the gram matrix, faster for m>>n) [direct] o fkick - Perform solution enrichment during forward sweeps [false] (rather questionable yet; false makes error higher, but \"better structured\": it does not explode in e.g. subsequent matvecs) o z0 - initial approximation to the error Ax-y [rand rank-kickrank] ******** For description of adaptive ALS please see Sergey V. Dolgov, Dmitry V. Savostyanov, Alternating minimal energy methods for linear systems in higher dimensions. Part I: SPD systems, http://arxiv.org/abs/1301.6068, Part II: Faster algorithm and application to nonsymmetric systems, http://arxiv.org/abs/1304.1222 Use {sergey.v.dolgov, dmitry.savostyanov}@gmail.com for feedback ********", "response": "def amen_mv(A, x, tol, y=None, z=None, nswp=20, kickrank=4,\n            kickrank2=0, verb=True, init_qr=True, renorm='direct', fkick=False):\n    '''\n       Approximate the matrix-by-vector via the AMEn iteration\n       [y,z]=amen_mv(A, x, tol, varargin)\n       Attempts to approximate the y = A*x\n       with accuracy TOL using the AMEn+ALS iteration.\n       Matrix A has to be given in the TT-format, right-hand side x should be\n       given in the TT-format also.\n\n       Options are provided in form\n       'PropertyName1',PropertyValue1,'PropertyName2',PropertyValue2 and so\n       on. The parameters are set to default (in brackets in the following)\n       The list of option names and default values are:\n           o y0 - initial approximation to Ax [rand rank-2]\n           o nswp - maximal number of sweeps [20]\n           o verb - verbosity level, 0-silent, 1-sweep info, 2-block info [1]\n           o kickrank - compression rank of the error,\n             i.e. enrichment size [3]\n           o init_qr - perform QR of the input (save some time in ts, etc) [true]\n           o renorm - Orthog. and truncation methods: direct (svd,qr) or gram\n             (apply svd to the gram matrix, faster for m>>n) [direct]\n           o fkick - Perform solution enrichment during forward sweeps [false]\n             (rather questionable yet; false makes error higher, but \"better\n             structured\": it does not explode in e.g. subsequent matvecs)\n           o z0 - initial approximation to the error Ax-y [rand rank-kickrank]\n\n\n    ********\n       For description of adaptive ALS please see\n       Sergey V. Dolgov, Dmitry V. Savostyanov,\n       Alternating minimal energy methods for linear systems in higher dimensions.\n       Part I: SPD systems, http://arxiv.org/abs/1301.6068,\n       Part II: Faster algorithm and application to nonsymmetric systems, http://arxiv.org/abs/1304.1222\n\n       Use {sergey.v.dolgov, dmitry.savostyanov}@gmail.com for feedback\n    ********\n    '''\n\n    if renorm is 'gram':\n        print(\"Not implemented yet. Renorm is switched to 'direct'\")\n        renorm = 'direct'\n\n    if isinstance(x, _tt.vector):\n        d = x.d\n        m = x.n\n        rx = x.r\n        x = _tt.vector.to_list(x)\n        vectype = 1  # tt_tensor\n    elif isinstance(x, list):\n        d = len(x)\n        m = _np.zeros(d)\n        rx = _np.ones(d + 1, dtype=_np.int32)\n        for i in xrange(d):\n            [_, m[i], rx[i + 1]] = x[i].shape\n        vectype = 0  # cell\n    else:\n        raise Exception('x: use tt.tensor or list of cores as numpy.arrays')\n\n    if isinstance(A, _tt.matrix):\n        n = A.n\n        ra = A.tt.r\n        A = _tt.matrix.to_list(A)\n        # prepare A for fast ALS-mv\n        for i in xrange(d):\n            A[i] = _reshape(A[i], (ra[i] * n[i], m[i] * ra[i + 1]))\n        atype = 1  # tt_matrix\n    # Alternative: A is a cell of cell: sparse canonical format\n    elif isinstance(A, list):\n        n = _np.zeros(d)\n        for i in xrange(d):\n            n[i] = A[i][0].shape[0]\n        ra = len(A[0])\n        atype = 0  # cell\n    else:\n        raise Exception('A: use tt.matrix or list of cores as numpy.arrays')\n\n    if y is None:\n        y = _tt.rand(n, d, 2)\n        y = _tt.vector.to_list(y)\n    else:\n        if isinstance(y, _tt.vector):\n            y = _tt.vector.to_list(y)\n\n    ry = _np.ones(d + 1, dtype=_np.int32)\n    for i in range(d):\n        ry[i + 1] = y[i].shape[2]\n\n    if (kickrank + kickrank2 > 0):\n        if z is None:\n            z = _tt.rand(n, d, kickrank + kickrank2)\n            rz = z.r\n            z = _tt.vector.to_list(z)\n        else:\n            if isinstance(z, _tt.vector):\n                z = _tt.vector.to_list(z)\n            rz = _np.ones(d + 1, dtype=_np.int32)\n            for i in range(d):\n                rz[i + 1] = z[i].shape[2]\n\n        phizax = [None] * (d + 1)  # cell(d+1,1);\n        if (atype == 1):\n            phizax[0] = _np.ones((1, 1, 1))  # 1\n            phizax[d] = _np.ones((1, 1, 1))  # 1\n        else:\n            phizax[0] = _np.ones((1, ra))  # 33\n            phizax[d] = _np.ones((1, ra))\n        phizy = [None] * (d + 1)\n        phizy[0] = _np.ones((1))  # , 1))\n        phizy[d] = _np.ones((1))  # , 1))\n\n    phiyax = [None] * (d + 1)\n    if (atype == 1):\n        phiyax[0] = _np.ones((1, 1, 1))  # 1\n        phiyax[d] = _np.ones((1, 1, 1))  # 1\n    else:\n        phiyax[0] = _np.ones((1, ra))  # 3\n        phiyax[d] = _np.ones((1, ra))\n\n    nrms = _np.ones(d)\n\n    # Initial ort\n    for i in range(d - 1):\n        if init_qr:\n            cr = _reshape(y[i], (ry[i] * n[i], ry[i + 1]))\n            if (renorm is 'gram') and (ry[i] * n[i] > 5 * ry[i + 1]):\n                [cr, s, R] = _svdgram(cr)\n            else:\n                [cr, R] = _np.linalg.qr(cr)\n            nrmr = _np.linalg.norm(R)  # , 'fro')\n            if (nrmr > 0):\n                R = R / nrmr\n            cr2 = _reshape(y[i + 1], (ry[i + 1], n[i + 1] * ry[i + 2]))\n            cr2 = _np.dot(R, cr2)\n            ry[i + 1] = cr.shape[1]\n            y[i] = _reshape(cr, (ry[i], n[i], ry[i + 1]))\n            y[i + 1] = _reshape(cr2, (ry[i + 1], n[i + 1], ry[i + 2]))\n\n        [phiyax[i + 1], nrms[i]\n         ] = _compute_next_Phi(phiyax[i], y[i], x[i], 'lr', A[i])\n\n        if (kickrank + kickrank2 > 0):\n            cr = _reshape(z[i], (rz[i] * n[i], rz[i + 1]))\n            if (renorm == 'gram') and (rz[i] * n[i] > 5 * rz[i + 1]):\n                [cr, s, R] = _svdgram(cr)\n            else:\n                [cr, R] = _np.linalg.qr(cr)\n            nrmr = _np.linalg.norm(R)  # , 'fro')\n            if (nrmr > 0):\n                R = R / nrmr\n            cr2 = _reshape(z[i + 1], (rz[i + 1], n[i + 1] * rz[i + 2]))\n            cr2 = _np.dot(R, cr2)\n            rz[i + 1] = cr.shape[1]\n            z[i] = _reshape(cr, (rz[i], n[i], rz[i + 1]))\n            z[i + 1] = _reshape(cr2, (rz[i + 1], n[i + 1], rz[i + 2]))\n            phizax[\n                i +\n                1] = _compute_next_Phi(\n                phizax[i],\n                z[i],\n                x[i],\n                'lr',\n                A[i],\n                nrms[i],\n                return_norm=False)\n            phizy[\n                i +\n                1] = _compute_next_Phi(\n                phizy[i],\n                z[i],\n                y[i],\n                'lr',\n                return_norm=False)\n\n    i = d - 1\n    direct = -1\n    swp = 1\n    max_dx = 0\n\n    while swp <= nswp:\n        # Project the MatVec generating vector\n        crx = _reshape(x[i], (rx[i] * m[i] * rx[i + 1], 1))\n        cry = _bfun3(phiyax[i], A[i], phiyax[i + 1], crx)\n        nrms[i] = _np.linalg.norm(cry)  # , 'fro')\n        # The main goal is to keep y[i] of norm 1\n        if (nrms[i] > 0):\n            cry = cry / nrms[i]\n        else:\n            nrms[i] = 1\n        y[i] = _reshape(y[i], (ry[i] * n[i] * ry[i + 1], 1))\n        dx = _np.linalg.norm(cry - y[i])\n        max_dx = max(max_dx, dx)\n\n        # Truncation and enrichment\n        if ((direct > 0) and (i < d - 1)):  # ?? i<d\n            cry = _reshape(cry, (ry[i] * n[i], ry[i + 1]))\n            if (renorm == 'gram'):\n                [u, s, v] = _svdgram(cry, tol / d**0.5)\n                v = v.T\n                r = u.shape[1]\n            else:\n                [u, s, vt] = _np.linalg.svd(cry, full_matrices=False)\n                #s = diag(s)\n                r = _my_chop2(s, tol * _np.linalg.norm(s) / d**0.5)\n                u = u[:, :r]\n                # ????? s - matrix or vector\n                v = _np.dot(_tconj(vt[:r, :]), _np.diag(s[:r]))\n\n            # Prepare enrichment, if needed\n            if (kickrank + kickrank2 > 0):\n                cry = _np.dot(u, v.T)\n                cry = _reshape(cry, (ry[i] * n[i], ry[i + 1]))\n                # For updating z\n                crz = _bfun3(phizax[i], A[i], phizax[i + 1], crx)\n                crz = _reshape(crz, (rz[i] * n[i], rz[i + 1]))\n                ys = _np.dot(cry, phizy[i + 1])\n                yz = _reshape(ys, (ry[i], n[i] * rz[i + 1]))\n                yz = _np.dot(phizy[i], yz)\n                yz = _reshape(yz, (rz[i] * n[i], rz[i + 1]))\n                crz = crz / nrms[i] - yz\n                nrmz = _np.linalg.norm(crz)  # , 'fro')\n                if (kickrank2 > 0):\n                    [crz, _, _] = _np.linalg.svd(crz, full_matrices=False)\n                    crz = crz[:, : min(crz.shape[1], kickrank)]\n                    crz = _np.hstack(\n                        (crz, _np.random.randn(\n                            rz[i] * n[i], kickrank2)))\n                # For adding into solution\n                if fkick:\n                    crs = _bfun3(phiyax[i], A[i], phizax[i + 1], crx)\n                    crs = _reshape(crs, (ry[i] * n[i], rz[i + 1]))\n                    crs = crs / nrms[i] - ys\n                    u = _np.hstack((u, crs))\n                    if (renorm == 'gram') and (\n                            ry[i] * n[i] > 5 * (ry[i + 1] + rz[i + 1])):\n                        [u, s, R] = _svdgram(u)\n                    else:\n                        [u, R] = _np.linalg.qr(u)\n                    v = _np.hstack((v, _np.zeros((ry[i + 1], rz[i + 1]))))\n                    v = _np.dot(v, R.T)\n                    r = u.shape[1]\n            y[i] = _reshape(u, (ry[i], n[i], r))\n\n            cr2 = _reshape(y[i + 1], (ry[i + 1], n[i + 1] * ry[i + 2]))\n            v = _reshape(v, (ry[i + 1], r))\n            cr2 = _np.dot(v.T, cr2)\n            y[i + 1] = _reshape(cr2, (r, n[i + 1], ry[i + 2]))\n\n            ry[i + 1] = r\n\n            [phiyax[i + 1], nrms[i]\n             ] = _compute_next_Phi(phiyax[i], y[i], x[i], 'lr', A[i])\n\n            if (kickrank + kickrank2 > 0):\n                if (renorm == 'gram') and (rz[i] * n[i] > 5 * rz[i + 1]):\n                    [crz, s, R] = _svdgram(crz)\n                else:\n                    [crz, R] = _np.linalg.qr(crz)\n                rz[i + 1] = crz.shape[1]\n                z[i] = _reshape(crz, (rz[i], n[i], rz[i + 1]))\n                # z[i+1] will be recomputed from scratch in the next step\n\n                phizax[\n                    i +\n                    1] = _compute_next_Phi(\n                    phizax[i],\n                    z[i],\n                    x[i],\n                    'lr',\n                    A[i],\n                    nrms[i],\n                    return_norm=False)\n                phizy[\n                    i +\n                    1] = _compute_next_Phi(\n                    phizy[i],\n                    z[i],\n                    y[i],\n                    'lr',\n                    return_norm=False)\n\n        elif ((direct < 0) and (i > 0)):\n            cry = _reshape(cry, (ry[i], n[i] * ry[i + 1]))\n            if (renorm == 'gram'):\n                [v, s, u] = _svdgram(cry.T, tol / d**0.5)\n                u = u.T\n                r = v.shape[1]\n            else:\n                #[v, s, u] = _np.linalg.svd(cry.T, full_matrices=False)\n                [u, s, vt] = _np.linalg.svd(cry, full_matrices=False)\n                #s = diag(s);\n                r = _my_chop2(s, tol * _np.linalg.norm(s) / d**0.5)\n                v = _tconj(vt[:r, :])\n\n                #v = vt[:r, :]\n                #v = _np.dot(v[:, :r], _np.diag(s[:r]))\n                u = _np.dot(u[:, :r], _np.diag(s[:r]))  # ??????????????????\n\n            # Prepare enrichment, if needed\n            if (kickrank + kickrank2 > 0):\n                cry = _np.dot(u, v.T)  # .T)\n                cry = _reshape(cry, (ry[i], n[i] * ry[i + 1]))\n                # For updating z\n                crz = _bfun3(phizax[i], A[i], phizax[i + 1], crx)\n                crz = _reshape(crz, (rz[i], n[i] * rz[i + 1]))\n                ys = _np.dot(phizy[i], cry)\n                yz = _reshape(ys, (rz[i] * n[i], ry[i + 1]))\n                yz = _np.dot(yz, phizy[i + 1])\n                yz = _reshape(yz, (rz[i], n[i] * rz[i + 1]))\n                crz = crz / nrms[i] - yz\n                nrmz = _np.linalg.norm(crz)  # , 'fro')\n                if (kickrank2 > 0):\n                    [_, _, crz] = _np.linalg.svd(crz, full_matrices=False)\n                    crz = crz[:, : min(crz.shape[1], kickrank)]\n                    crz = _tconj(crz)\n                    crz = _np.vstack(\n                        (crz, _np.random.randn(kickrank2, n[i] * rz[i + 1])))\n                # For adding into solution\n                crs = _bfun3(phizax[i], A[i], phiyax[i + 1], crx)\n                crs = _reshape(crs, (rz[i], n[i] * ry[i + 1]))\n                crs = crs / nrms[i] - ys\n                v = _np.hstack((v, crs.T))  # .T\n                #v = v.T\n                if (renorm == 'gram') and (\n                        n[i] * ry[i + 1] > 5 * (ry[i] + rz[i])):\n                    [v, s, R] = _svdgram(v)\n                else:\n                    [v, R] = _np.linalg.qr(v)\n                u = _np.hstack((u, _np.zeros((ry[i], rz[i]))))\n                u = _np.dot(u, R.T)\n                r = v.shape[1]\n\n            cr2 = _reshape(y[i - 1], (ry[i - 1] * n[i - 1], ry[i]))\n            cr2 = _np.dot(cr2, u)\n            y[i - 1] = _reshape(cr2, (ry[i - 1], n[i - 1], r))\n            y[i] = _reshape(v.T, (r, n[i], ry[i + 1]))\n\n            ry[i] = r\n\n            [phiyax[i], nrms[i]] = _compute_next_Phi(\n                phiyax[i + 1], y[i], x[i], 'rl', A[i])\n\n            if (kickrank + kickrank2 > 0):\n                if (renorm == 'gram') and (n[i] * rz[i + 1] > 5 * rz[i]):\n                    [crz, s, R] = _svdgram(crz.T)\n                else:\n                    [crz, R] = _np.linalg.qr(crz.T)\n                rz[i] = crz.shape[1]\n                z[i] = _reshape(crz.T, (rz[i], n[i], rz[i + 1]))\n                # don't update z[i-1], it will be recomputed from scratch\n\n                phizax[i] = _compute_next_Phi(\n                    phizax[\n                        i + 1],\n                    z[i],\n                    x[i],\n                    'rl',\n                    A[i],\n                    nrms[i],\n                    return_norm=False)\n                phizy[i] = _compute_next_Phi(\n                    phizy[i + 1], z[i], y[i], 'rl', return_norm=False)\n\n        if (verb > 1):\n            print('amen-mv: swp=[%d,%d], dx=%.3e, r=%d, |y|=%.3e, |z|=%.3e' % (swp, i, dx, r, _np.linalg.norm(cry), nrmz))\n\n        # Stopping or reversing\n        if ((direct > 0) and (i == d - 1)) or ((direct < 0) and (i == 0)):\n            if (verb > 0):\n                print('amen-mv: swp=%d{%d}, max_dx=%.3e, max_r=%d' % (swp, (1 - direct) // 2, max_dx, max(ry)))\n            if ((max_dx < tol) or (swp == nswp)) and (direct > 0):\n                break\n            else:\n                # We are at the terminal block\n                y[i] = _reshape(cry, (ry[i], n[i], ry[i + 1]))\n                if (direct > 0):\n                    swp = swp + 1\n            max_dx = 0\n            direct = -direct\n        else:\n            i = i + direct\n    # if (direct>0)\n    y[d - 1] = _reshape(cry, (ry[d - 1], n[d - 1], ry[d]))\n    # else\n    #     y{1} = reshape(cry, ry(1), n(1), ry(2));\n    # end;\n\n    # Distribute norms equally...\n    nrms = _np.exp(sum(_np.log(nrms)) / d)\n    # ... and plug them into y\n    for i in xrange(d):\n        y[i] = _np.dot(y[i], nrms)\n\n    if (vectype == 1):\n        y = _tt.vector.from_list(y)\n        if kickrank == 0:\n            z = None\n        else:\n            z = _tt.vector.from_list(z)\n\n    return y, z"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the next recurrent Phi.", "response": "def _compute_next_Phi(Phi_prev, x, y, direction, A=None,\n                      extnrm=None, return_norm=True):\n    '''\n    Performs the recurrent Phi (or Psi) matrix computation\n    Phi = Phi_prev * (x'Ay).\n    If direction is 'lr', computes Psi\n    if direction is 'rl', computes Phi\n    A can be empty, then only x'y is computed.\n\n        Phi1: rx1, ry1, ra1, or {rx1, ry1}_ra, or rx1, ry1\n        Phi2: ry2, ra2, rx2, or {ry2, rx2}_ra, or ry2, rx2\n    '''\n\n    [rx1, n, rx2] = x.shape\n    [ry1, m, ry2] = y.shape\n\n    if A is not None:\n        if isinstance(A, list):  # ?????????????????????????????????\n            # A is a canonical block\n            ra = len(A)\n        else:\n            # Just full format\n            [ra1, ra2] = A.shape\n            ra1 = ra1 // n\n            ra2 = ra2 // m\n    # ?????????????????????????????????????\n    else:\n        [ra1, ra2] = [1, 1]\n\n    if isinstance(Phi_prev, list):\n        Phi = [None] * ra\n        if return_norm:\n            nrm = 0\n        if (direction == 'lr'):\n            # lr: Phi1\n            x = _reshape(x, (rx1, n * rx2))\n            y = _reshape(y, (ry1 * m, ry2))\n            for i in xrange(ra):\n                Phi[i] = _np.dot(_tconj(x), Phi_prev[i])\n                Phi[i] = _reshape(Phi[i], (n, rx2 * ry1))\n                Phi[i] = Phi[i].T\n                Phi[i] = _np.dot(Phi[i], A[i])\n                Phi[i] = _reshape(Phi[i], (rx2, ry1 * m))\n                Phi[i] = _np.dot(Phi[i], y)\n                if return_norm:\n                    nrm = max(nrm, _np.linalg.norm(Phi[i]))  # , 'fro'))\n        else:\n            # rl: Phi2\n            y = _reshape(y, (ry1, m * ry2))\n            x = _reshape(x, (rx1 * n, rx2))\n            for i in xrange(ra):\n                Phi[i] = _np.dot(Phi_prev[i], x.T)\n                Phi[i] = _reshape(Phi[i], (ry2 * rx1, n))\n                Phi[i] = _np.dot(Phi[i], A[i])\n                Phi[i] = Phi[i].T\n                Phi[i] = _reshape(Phi[i], (m * ry2, rx1))\n                Phi[i] = _np.dot(y, Phi[i])\n                if return_norm:\n                    nrm = max(nrm, _np.linalg.norm(Phi[i]))  # , 'fro'))\n        if return_norm:\n            # Extract the scale to prevent overload\n            if (nrm > 0):\n                for i in xrange(ra):\n                    Phi[i] = Phi[i] / nrm\n            else:\n                nrm = 1\n        elif extnrm is not None:\n            # Override the normalization\n            for i in xrange(ra):\n                Phi[i] = Phi[i] / extnrm\n    else:\n        if (direction == 'lr'):\n            # lr: Phi1\n            x = _reshape(x, (rx1, n * rx2))\n            Phi = _reshape(Phi_prev, (rx1, ry1 * ra1))\n            Phi = _np.dot(_tconj(x), Phi)\n            if A is not None:\n                Phi = _reshape(Phi, (n * rx2 * ry1, ra1))\n                Phi = Phi.T\n                Phi = _reshape(Phi, (ra1 * n, rx2 * ry1))\n                Phi = _np.dot(A.T, Phi)\n                Phi = _reshape(Phi, (m, ra2 * rx2 * ry1))\n            else:\n                Phi = _reshape(Phi, (n, rx2 * ry1))\n            Phi = Phi.T\n            Phi = _reshape(Phi, (ra2 * rx2, ry1 * m))\n            y = _reshape(y, (ry1 * m, ry2))\n            Phi = _np.dot(Phi, y)\n            if A is not None:\n                Phi = _reshape(Phi, (ra2, rx2 * ry2))\n                Phi = Phi.T\n                Phi = _reshape(Phi, (rx2, ry2, ra2))\n            else:\n                Phi = _reshape(Phi, (rx2, ry2))\n        else:\n            # rl: Phi2\n            y = _reshape(y, (ry1 * m, ry2))\n            Phi = _reshape(Phi_prev, (ry2, ra2 * rx2))\n            Phi = _np.dot(y, Phi)\n            if A is not None:\n                Phi = _reshape(Phi, (ry1, m * ra2 * rx2))\n                Phi = Phi.T\n                Phi = _reshape(Phi, (m * ra2, rx2 * ry1))\n                Phi = _np.dot(A, Phi)\n                Phi = _reshape(Phi, (ra1 * n * rx2, ry1))\n                Phi = Phi.T\n            Phi = _reshape(Phi, (ry1 * ra1, n * rx2))\n            x = _reshape(x, (rx1, n * rx2))\n            Phi = _np.dot(Phi, _tconj(x))\n            if A is not None:\n                Phi = _reshape(Phi, (ry1, ra1, rx1))\n            else:\n                Phi = _reshape(Phi, (ry1, rx1))\n\n        if return_norm:\n            # Extract the scale to prevent overload\n            nrm = _np.linalg.norm(Phi)  # , 'fro')\n            if (nrm > 0):\n                Phi = Phi / nrm\n            else:\n                nrm = 1\n        elif extnrm is not None:\n            # Override the normalization by the external one\n            Phi = Phi / extnrm\n\n    if return_norm:\n        return Phi, nrm\n    else:\n        return Phi"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef multifuncrs(X, funs, eps=1E-6,\n                nswp=10,\n                kickrank=5,\n                y0=None,\n                rmax=999999,  # TODO:infinity \\\n                kicktype='amr-two',        \\\n                pcatype='svd',             \\\n                trunctype='fro',           \\\n                d2=1,                      \\\n                do_qr=False,               \\\n                verb=1):\n    \"\"\"Cross approximation of a (vector-)function of several TT-tensors.\n\n    :param X: tuple of TT-tensors\n    :param funs: multivariate function\n    :param eps: accuracy\n    \"\"\"\n\n    dtype = np.float64\n    if len([x for x in X if x.is_complex]) > 0:\n        dtype = np.complex128\n\n    y = y0\n    wasrand = False\n\n    nx = len(X)\n    d = X[0].d\n    n = X[0].n\n    rx = np.transpose(np.array([ttx.r for ttx in X]))\n    #crx = [tt.tensor.to_list(ttx) for x in X]\n    #crx = zip(*crx)\n    crx = np.transpose(np.array([tt.tensor.to_list(ttx)\n                                 for ttx in X], dtype=np.object))\n    crx = np.empty((nx, d), dtype=np.object)\n    i = 0\n    for ttx in X:\n        v = tt.tensor.to_list(ttx)\n        j = 0\n        for w in v:\n            crx[i, j] = w\n            j = j + 1\n        i = i + 1\n    crx = crx.T\n    if y is None:\n        ry = d2 * np.ones((d + 1,), dtype=np.int32)\n        ry[0] = 1\n        y = tt.rand(n, d, ry)\n        wasrand = True\n\n    ry = y.r\n    cry = tt.tensor.to_list(y)\n\n    Ry = np.zeros((d + 1, ), dtype=np.object)\n    Ry[0] = np.array([[1.0]], dtype=dtype)\n    Ry[d] = np.array([[1.0]], dtype=dtype)\n    Rx = np.zeros((d + 1, nx), dtype=np.object)\n    Rx[0, :] = np.ones(nx, dtype=dtype)\n    Rx[d, :] = np.ones(nx, dtype=dtype)\n\n    block_order = [+d, -d]\n\n    # orth\n    for i in range(0, d - 1):\n        cr = cry[i]\n        cr = reshape(cr, (ry[i] * n[i], ry[i + 1]))\n        cr, rv = np.linalg.qr(cr)\n        cr2 = cry[i + 1]\n        cr2 = reshape(cr2, (ry[i + 1], n[i + 1] * ry[i + 2]))\n        cr2 = np.dot(rv, cr2)  # matrix multiplication\n        ry[i + 1] = cr.shape[1]\n        cr = reshape(cr, (ry[i], n[i], ry[i + 1]))\n        cry[i + 1] = reshape(cr2, (ry[i + 1], n[i + 1], ry[i + 2]))\n        cry[i] = cr\n\n        Ry[i + 1] = np.dot(Ry[i], reshape(cr, (ry[i], n[i] * ry[i + 1])))\n        Ry[i + 1] = reshape(Ry[i + 1], (ry[i] * n[i], ry[i + 1]))\n        curind = []\n        if wasrand:\n            # EVERY DAY I'M SHUFFLIN'\n            curind = np.random.permutation(n[i] * ry[i])[:ry[i + 1]]\n        else:\n            curind = maxvol(Ry[i + 1])\n        Ry[i + 1] = Ry[i + 1][curind, :]\n        for j in range(0, nx):\n            try:\n                Rx[i + 1, j] = reshape(crx[i, j],\n                                       (rx[i, j], n[i] * rx[i + 1, j]))\n            except:\n                pass\n            Rx[i + 1, j] = np.dot(Rx[i, j], Rx[i + 1, j])\n            Rx[i + 1, j] = reshape(Rx[i + 1, j], (ry[i] * n[i], rx[i + 1, j]))\n            Rx[i + 1, j] = Rx[i + 1, j][curind, :]\n\n    d2 = ry[d]\n    ry[d] = 1\n    cry[d - 1] = np.transpose(cry[d - 1], [2, 0, 1])  # permute\n\n    last_sweep = False\n    swp = 1\n\n    dy = np.zeros((d, ))\n    max_dy = 0\n\n    cur_order = copy.copy(block_order)\n    order_index = 1\n    i = d - 1\n    # can't use 'dir' identifier in python\n    dirn = int(math.copysign(1, cur_order[order_index]))\n\n    # DMRG sweeps\n    while swp <= nswp or dirn > 0:\n\n        oldy = reshape(cry[i], (d2 * ry[i] * n[i] * ry[i + 1],))\n\n        if not last_sweep:\n            # compute the X superblocks\n            curbl = np.zeros((ry[i] * n[i] * ry[i + 1], nx), dtype=dtype)\n            for j in range(0, nx):\n                cr = reshape(crx[i, j], (rx[i, j], n[i] * rx[i + 1, j]))\n                cr = np.dot(Rx[i, j], cr)\n                cr = reshape(cr, (ry[i] * n[i], rx[i + 1, j]))\n                cr = np.dot(cr, Rx[i + 1, j])\n                curbl[:, j] = cr.flatten('F')\n            # call the function\n            newy = funs(curbl)\n            # multiply with inverted Ry\n            newy = reshape(newy, (ry[i], n[i] * ry[i + 1] * d2))\n            newy = np.linalg.solve(Ry[i], newy)  # y = R \\ y\n            newy = reshape(newy, (ry[i] * n[i] * ry[i + 1], d2))\n            newy = reshape(np.transpose(newy), (d2 * ry[i] * n[i], ry[i + 1]))\n            newy = np.transpose(np.linalg.solve(\n                np.transpose(Ry[i + 1]), np.transpose(newy)))  # y=y/R\n            newy = reshape(newy, (d2 * ry[i] * n[i] * ry[i + 1],))\n        else:\n            newy = oldy\n\n        dy[i] = np.linalg.norm(newy - oldy) / np.linalg.norm(newy)\n        max_dy = max(max_dy, dy[i])\n\n        # truncation\n        if dirn > 0:  # left-to-right\n            newy = reshape(newy, (d2, ry[i] * n[i] * ry[i + 1]))\n            newy = reshape(np.transpose(newy), (ry[i] * n[i], ry[i + 1] * d2))\n        else:\n            newy = reshape(newy, (d2 * ry[i], n[i] * ry[i + 1]))\n\n        r = 0  # defines a variable in global scope\n\n        if kickrank >= 0:\n            u, s, v = np.linalg.svd(newy, full_matrices=False)\n            v = np.conj(np.transpose(v))\n            if trunctype == \"fro\" or last_sweep:\n                r = my_chop2(s, eps / math.sqrt(d) * np.linalg.norm(s))\n            else:\n                # truncate taking into account the (r+1) overhead in the cross\n                # (T.S.: what?)\n                cums = abs(s * np.arange(2, len(s) + 2)) ** 2\n                cums = np.cumsum(cums[::-1])[::-1]\n                cums = cums / cums[0]\n                ff = [i for i in range(len(cums)) if cums[i] < eps ** 2 / d]\n                if len(ff) == 0:\n                    r = len(s)\n                else:\n                    r = np.amin(ff)\n            r = min(r, rmax, len(s))\n        else:\n            if dirn > 0:\n                u, v = np.linalg.qr(newy)\n                v = np.conj(np.transpose(v))\n                r = u.shape[1]\n                s = np.ones((r, ))\n            else:\n                v, u = np.linalg.qr(np.transpose(newy))\n                v = np.conj(v)\n                u = np.transpose(u)\n                r = u.shape[1]\n                s = np.ones((r, ))\n\n        if verb > 1:\n            print('=multifuncrs=   block %d{%d}, dy: %3.3e, r: %d' % (i, dirn, dy[i], r))\n\n        # kicks and interfaces\n        if dirn > 0 and i < d - 1:\n            u = u[:, :r]\n            v = np.dot(v[:, :r], np.diag(s[:r]))\n\n            # kick\n            radd = 0\n            rv = 1\n            if not last_sweep and kickrank > 0:\n                uk = None\n                if kicktype == 'amr-two':\n                    # AMR(two)-like kick.\n\n                    # compute the X superblocks\n                    ind2 = np.unique(np.random.randint(\n                        0, ry[i + 2] * n[i + 1], ry[i + 1]))\n                    #ind2 = np.unique(np.floor(np.random.rand(ry[i + 1]) * (ry[i + 2] * n[i + 1])))\n                    rkick = len(ind2)\n                    curbl = np.zeros((ry[i] * n[i] * rkick, nx), dtype=dtype)\n                    for j in range(nx):\n                        cr1 = reshape(\n                            crx[i, j], (rx[i, j], n[i] * rx[i + 1, j]))\n                        cr1 = np.dot(Rx[i, j], cr1)\n                        cr1 = reshape(cr1, (ry[i] * n[i], rx[i + 1, j]))\n                        cr2 = reshape(\n                            crx[i + 1, j], (rx[i + 1, j] * n[i + 1], rx[i + 2, j]))\n                        cr2 = np.dot(cr2, Rx[i + 2, j])\n                        cr2 = reshape(\n                            cr2, (rx[i + 1, j], n[i + 1] * ry[i + 2]))\n                        cr2 = cr2[:, ind2]\n                        curbl[:, j] = reshape(\n                            np.dot(cr1, cr2), (ry[i] * n[i] * rkick,))\n                    # call the function\n                    uk = funs(curbl)\n                    uk = reshape(uk, (ry[i], n[i] * rkick * d2))\n                    uk = np.linalg.solve(Ry[i], uk)\n                    uk = reshape(uk, (ry[i] * n[i], rkick * d2))\n                    if pcatype == 'svd':\n                        uk, sk, vk = np.linalg.svd(uk, full_matrices=False)\n                        vk = np.conj(np.transpose(vk))\n                        uk = uk[:, :min(kickrank, uk.shape[1])]\n                    else:\n                        # uk = uchol(np.transpose(uk), kickrank + 1) # TODO\n                        uk = uk[:, :max(uk.shape[1] - kickrank + 1, 1):-1]\n                else:\n                    uk = np.random.rand(ry[i] * n[i], kickrank)\n                u, rv = np.linalg.qr(np.concatenate((u, uk), axis=1))\n                radd = uk.shape[1]\n            v = np.concatenate(\n                (v, np.zeros((ry[i + 1] * d2, radd), dtype=dtype)), axis=1)\n            v = np.dot(rv, np.conj(np.transpose(v)))\n            r = u.shape[1]\n\n            cr2 = cry[i + 1]\n            cr2 = reshape(cr2, (ry[i + 1], n[i + 1] * ry[i + 2]))\n            v = reshape(v, (r * ry[i + 1], d2))\n            v = reshape(np.transpose(v), (d2 * r, ry[i + 1]))\n            v = np.dot(v, cr2)\n\n            ry[i + 1] = r\n\n            u = reshape(u, (ry[i], n[i], r))\n            v = reshape(v, (d2, r, n[i + 1], ry[i + 2]))\n\n            cry[i] = u\n            cry[i + 1] = v\n\n            Ry[i + 1] = np.dot(Ry[i], reshape(u, (ry[i], n[i] * ry[i + 1])))\n            Ry[i + 1] = reshape(Ry[i + 1], (ry[i] * n[i], ry[i + 1]))\n            curind = maxvol(Ry[i + 1])\n            Ry[i + 1] = Ry[i + 1][curind, :]\n            for j in range(nx):\n                Rx[i + 1, j] = reshape(crx[i, j],\n                                       (rx[i, j], n[i] * rx[i + 1, j]))\n                Rx[i + 1, j] = np.dot(Rx[i, j], Rx[i + 1, j])\n                Rx[i + 1, j] = reshape(Rx[i + 1, j],\n                                       (ry[i] * n[i], rx[i + 1, j]))\n                Rx[i + 1, j] = Rx[i + 1, j][curind, :]\n        elif dirn < 0 and i > 0:\n            u = np.dot(u[:, :r], np.diag(s[:r]))\n            v = np.conj(v[:, :r])\n\n            radd = 0\n            rv = 1\n            if not last_sweep and kickrank > 0:\n                if kicktype == 'amr-two':\n                    # compute the X superblocks\n                    ind2 = np.unique(np.random.randint(\n                        0, ry[i - 1] * n[i - 1], ry[i]))\n                    rkick = len(ind2)\n                    curbl = np.zeros(\n                        (rkick * n[i] * ry[i + 1], nx), dtype=dtype)\n                    for j in range(nx):\n                        cr1 = reshape(\n                            crx[i, j], (rx[i, j] * n[i], rx[i + 1, j]))\n                        cr1 = np.dot(cr1, Rx[i + 1, j])\n                        cr1 = reshape(cr1, (rx[i, j], n[i] * ry[i + 1]))\n                        cr2 = reshape(\n                            crx[i - 1, j], (rx[i - 1, j], n[i - 1] * rx[i, j]))\n                        cr2 = np.dot(Rx[i - 1, j], cr2)\n                        cr2 = reshape(cr2, (ry[i - 1] * n[i - 1], rx[i, j]))\n                        cr2 = cr2[ind2, :]\n                        curbl[:, j] = reshape(\n                            np.dot(cr2, cr1), (rkick * n[i] * ry[i + 1],))\n                    # calling the function\n                    uk = funs(curbl)\n                    uk = reshape(uk, (rkick * n[i] * ry[i + 1], d2))\n                    uk = reshape(np.transpose(\n                        uk), (d2 * rkick * n[i], ry[i + 1]))\n                    uk = np.transpose(np.linalg.solve(\n                        np.transpose(Ry[i + 1]), np.transpose(uk)))\n                    uk = reshape(uk, (d2 * rkick, n[i] * ry[i + 1]))\n                    if pcatype == 'svd':\n                        vk, sk, uk = np.linalg.svd(uk, full_matrices=False)\n                        uk = np.conj(np.transpose(uk))\n                        # TODO: refactor\n                        uk = uk[:, :min(kickrank, uk.shape[1])]\n                    else:\n                        # uk = uchol(uk, kickrank + 1) # TODO\n                        uk = uk[:, :max(uk.shape[1] - kickrank + 1, 1):-1]\n                else:\n                    uk = np.random.rand(n[i] * ry[i + 1], kickrank)\n                v, rv = np.linalg.qr(np.concatenate((v, uk), axis=1))\n                radd = uk.shape[1]\n            u = np.concatenate(\n                (u, np.zeros((d2 * ry[i], radd), dtype=dtype)), axis=1)\n            u = np.dot(u, np.transpose(rv))\n            r = v.shape[1]\n            cr2 = cry[i - 1]\n            cr2 = reshape(cr2, (ry[i - 1] * n[i - 1], ry[i]))\n            u = reshape(u, (d2, ry[i] * r))\n            u = reshape(np.transpose(u), (ry[i], r * d2))\n            u = np.dot(cr2, u)\n\n            u = reshape(u, (ry[i - 1] * n[i - 1] * r, d2))\n            u = reshape(np.transpose(u), (d2, ry[i - 1], n[i - 1], r))\n            v = reshape(np.transpose(v), (r, n[i], ry[i + 1]))\n\n            ry[i] = r\n            cry[i - 1] = u\n            cry[i] = v\n\n            Ry[i] = np.dot(reshape(v, (ry[i] * n[i], ry[i + 1])), Ry[i + 1])\n            Ry[i] = reshape(Ry[i], (ry[i], n[i] * ry[i + 1]))\n            curind = maxvol(np.transpose(Ry[i]))\n            Ry[i] = Ry[i][:, curind]\n            for j in range(nx):\n                Rx[i, j] = reshape(crx[i, j], (rx[i, j] * n[i], rx[i + 1, j]))\n                Rx[i, j] = np.dot(Rx[i, j], Rx[i + 1, j])\n                Rx[i, j] = reshape(Rx[i, j], (rx[i, j], n[i] * ry[i + 1]))\n                Rx[i, j] = Rx[i, j][:, curind]\n        elif dirn > 0 and i == d - 1:\n            newy = np.dot(np.dot(u[:, :r], np.diag(s[:r])),\n                          np.conj(np.transpose(v[:, :r])))\n            newy = reshape(newy, (ry[i] * n[i] * ry[i + 1], d2))\n            cry[i] = reshape(np.transpose(newy), (d2, ry[i], n[i], ry[i + 1]))\n        elif dirn < 0 and i == 0:\n            newy = np.dot(np.dot(u[:, :r], np.diag(s[:r])),\n                          np.conj(np.transpose(v[:, :r])))\n            newy = reshape(newy, (d2, ry[i], n[i], ry[i + 1]))\n            cry[i] = newy\n\n        i = i + dirn\n        cur_order[order_index] = cur_order[order_index] - dirn\n        if cur_order[order_index] == 0:\n            order_index = order_index + 1\n            if verb > 0:\n                print('=multifuncrs= sweep %d{%d}, max_dy: %3.3e, erank: %g' % (swp, order_index, max_dy,\n                                                                                math.sqrt(np.dot(ry[:d], n * ry[1:]) / np.sum(n))))\n\n            if last_sweep:\n                break\n            if max_dy < eps and dirn < 0:\n                last_sweep = True\n                kickrank = 0\n\n            if order_index >= len(cur_order):\n                cur_order = copy.copy(block_order)\n                order_index = 0\n                if last_sweep:\n                    cur_order = [d - 1]\n\n                max_dy = 0\n                swp = swp + 1\n\n            dirn = int(math.copysign(1, cur_order[order_index]))\n            i = i + dirn\n\n    cry[d - 1] = np.transpose(cry[d - 1][:, :, :, 0], [1, 2, 0])\n    y = tt.tensor.from_list(cry)\n    return y", "response": "Cross approximation of a multivariate function of several TT - tensors."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate TT - vectorr object from a list of TT cores.", "response": "def from_list(a, order='F'):\n        \"\"\"Generate TT-vectorr object from given TT cores.\n\n        :param a: List of TT cores.\n        :type a: list\n        :returns: vector -- TT-vector constructed from the given cores.\n\n        \"\"\"\n        d = len(a)  # Number of cores\n        res = vector()\n        n = _np.zeros(d, dtype=_np.int32)\n        r = _np.zeros(d+1, dtype=_np.int32)\n        cr = _np.array([])\n        for i in xrange(d):\n            cr = _np.concatenate((cr, a[i].flatten(order)))\n            r[i] = a[i].shape[0]\n            r[i+1] = a[i].shape[2]\n            n[i] = a[i].shape[1]\n        res.d = d\n        res.n = n\n        res.r = r\n        res.core = cr\n        res.get_ps()\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef r2c(self):\n        tmp = self.copy()\n        newcore = _np.array(tmp.core, dtype=_np.complex)\n        cr = newcore[tmp.ps[-2] - 1:tmp.ps[-1] - 1]\n        cr = cr.reshape((tmp.r[-2], tmp.n[-1], tmp.r[-1]), order='F')\n        cr[:, 1, :] *= 1j\n        newcore[tmp.ps[-2] - 1:tmp.ps[-1] - 1] = cr.flatten('F')\n        tmp.core = newcore\n        return sum(tmp, axis=tmp.d - 1)", "response": "Get complex vector. from real one made by tensor. c2r. r2c."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning full array of in - memory entries.", "response": "def full(self, asvector=False):\n        \"\"\"Returns full array (uncompressed).\n\n        .. warning::\n           TT compression allows to keep in memory tensors much larger than ones PC can handle in\n           raw format. Therefore this function is quite unsafe; use it at your own risk.\n\n       :returns: numpy.ndarray -- full tensor.\n\n       \"\"\"\n        # Generate correct size vector\n        sz = self.n.copy()\n        if self.r[0] > 1:\n            sz = _np.concatenate(([self.r[0]], sz))\n        if self.r[self.d] > 1:\n            sz = _np.concatenate(([self.r[self.d]], sz))\n        if (_np.iscomplex(self.core).any()):\n            a = _tt_f90.tt_f90.ztt_to_full(\n                self.n, self.r, self.ps, self.core, _np.prod(sz))\n        else:\n            a = _tt_f90.tt_f90.dtt_to_full(\n                self.n, self.r, self.ps, _np.real(\n                    self.core), _np.prod(sz))\n        a = a.reshape(sz, order='F')\n        if asvector:\n            a=a.flatten(order='F')\n        return a"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying TT rounding procedure to the TT - vector and returns rounded tensor.", "response": "def round(self, eps=1e-14, rmax=1000000):\n        \"\"\"Applies TT rounding procedure to the TT-vector and **returns rounded tensor**.\n\n        :param eps: Rounding accuracy.\n        :type eps: float\n        :param rmax: Maximal rank\n        :type rmax: int\n        :returns: tensor -- rounded TT-vector.\n\n        Usage example:\n\n        >>> a = tt.ones(2, 10)\n        >>> b = a + a\n        >>> print b.r\n        array([1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1], dtype=int32)\n        >>> b = b.round(1E-14)\n        >>> print b.r\n        array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32)\n\n        \"\"\"\n        c = vector()\n        c.n = _np.copy(self.n)\n        c.d = self.d\n        c.r = _np.copy(self.r)\n        c.ps = _np.copy(self.ps)\n        if (_np.iscomplex(self.core).any()):\n            _tt_f90.tt_f90.ztt_compr2(c.n, c.r, c.ps, self.core, eps, rmax)\n            c.core = _tt_f90.tt_f90.zcore.copy()\n        else:\n            _tt_f90.tt_f90.dtt_compr2(c.n, c.r, c.ps, self.core, eps, rmax)\n            c.core = _tt_f90.tt_f90.core.copy()\n        _tt_f90.tt_f90.tt_dealloc()\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rmean(self):\n        if not _np.all(self.n):\n            return 0\n        # Solving quadratic equation ar^2 + br + c = 0;\n        a = _np.sum(self.n[1:-1])\n        b = self.n[0] + self.n[-1]\n        c = - _np.sum(self.n * self.r[1:] * self.r[:-1])\n        D = b ** 2 - 4 * a * c\n        r = 0.5 * (-b + _np.sqrt(D)) / a\n        return r", "response": "Calculates the mean rank of a TT - vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef qtt_fft1(self,tol,inverse=False, bitReverse=True): \n    \n        d = self.d \n        r = self.r.copy()\n        y = self.to_list(self)   \n        \n        if inverse:\n            twiddle =-1+1.22e-16j # exp(pi*1j)\n        else:\n            twiddle =-1-1.22e-16j # exp(-pi*1j)\n        \n        for i in range(d-1, 0, -1):\n            \n            r1= y[i].shape[0]   # head r\n            r2= y[i].shape[2]   # tail r\n            crd2 = _np.zeros((r1, 2, r2), order='F',  dtype=complex) \n            # last block +-\n            crd2[:,0,:]= (y[i][:,0,:] + y[i][:,1,:])/_np.sqrt(2)\n            crd2[:,1,:]= (y[i][:,0,:] - y[i][:,1,:])/_np.sqrt(2)           \n            # last block twiddles\n            y[i]= _np.zeros((r1*2, 2, r2),order='F',dtype=complex) \n            y[i][0:r1,    0, 0:r2]= crd2[:,0,:]\n            y[i][r1:r1*2, 1, 0:r2]= crd2[:,1,:]\n            #1..i-1 block twiddles and qr\n            rv=1; \n            \n            for j in range(0, i):\n            \n                cr=y[j]\n                r1= cr.shape[0]   # head r\n                r2= cr.shape[2]   # tail r\n                if j==0:\n                    r[j]=r1\n                    r[j+1] = r2*2\n                    y[j] = _np.zeros((r[j], 2, r[j+1]),order='F',dtype=complex)\n                    y[j][0:r1, :, 0:r2] = cr \n                    y[j][0:r1, 0, r2 :r[j+1]] = cr[:,0,:] \n                    y[j][0:r1, 1, r2 :r[j+1]] = twiddle**(1.0/(2**(i-j)))*cr[:,1,:]\n                else:\n                    r[j]=r1*2\n                    r[j+1] = r2*2\n                    y[j] = _np.zeros((r[j], 2, r[j+1]),order='F',dtype=complex)\n                    y[j][0:r1, :, 0:r2] = cr \n                    y[j][r1:r[j], 0, r2 :r[j+1]] = cr[:,0,:] \n                    y[j][r1:r[j], 1, r2 :r[j+1]] = twiddle**(1.0/(2**(i-j)))*cr[:,1,:]\n                        \n                    \n                y[j] = _np.reshape(y[j],( r[j], 2*r[j+1]),order='F')\n                y[j] = _np.dot(rv,y[j])\n                r[j] = y[j].shape[0]\n                y[j] = _np.reshape(y[j],( 2*r[j],  r[j+1]),order='F')\n                \n                y[j], rv = _np.linalg.qr(y[j])\n                y[j] = _np.reshape(y[j], (r[j], 2, rv.shape[0]),order='F')\n            \n            y[i] = _np.reshape(y[i], (r[i], 2*r[i+1]),order='F')  \n            y[i] = _np.dot(rv,y[i])\n            r[i] = rv.shape[0]\n            # backward svd\n            for j in range(i, 0,-1):\n                u,s,v = _np.linalg.svd(y[j], full_matrices=False)\n                rnew = my_chop2(s, _np.linalg.norm(s)*tol/_np.sqrt(i))\n                u=_np.dot(u[:, 0:rnew], _np.diag(s[0:rnew]))\n                v= v[0:rnew, :] \n                y[j] = _np.reshape(v, (rnew, 2, r[j+1]),order='F' )\n                y[j-1] = _np.reshape(y[j-1], (r[j-1]*2,r[j] ),order='F' )\n                y[j-1] = _np.dot(y[j-1], u)\n                r[j] = rnew\n                y[j-1] = _np.reshape(y[j-1], (r[j-1],r[j]*2 ),order='F' )\n                \n            y[0] = _np.reshape(y[0], (r[0],2, r[1]), order='F' )\n        \n        # FFT on the first block\n        y[0]=_np.transpose(y[0],(1,0,2))\n        y[0]=_np.reshape(y[0],(2, r[0]*r[1]),order='F')\n        y[0]= _np.dot( _np.array([[1,1],[1,-1]]), y[0])/_np.sqrt(2)\n        y[0]=_np.reshape(y[0],(2, r[0], r[1]),order='F')\n        y[0]=_np.transpose(y[0],(1,0,2))\n        \n        if bitReverse:\n            # Reverse the train\n            y2=[None]*d\n            for i in range(d):\n                y2[d-i-1]= _np.transpose(y[i],(2,1,0))\n            \n            y=self.from_list(y2)\n        else: # for multi-dimensional qtt_fft\n            y=self.from_list(y)\n        return y", "response": "Compute 1D discrete Fourier transform in the QTT format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napproximates computation of minimal eigenvalues in tensor train format", "response": "def eigb(A, y0, eps, rmax=150, nswp=20, max_full_size=1000, verb=1):\n    \"\"\" Approximate computation of minimal eigenvalues in tensor train format\n    This function uses alternating least-squares algorithm for the computation of several\n    minimal eigenvalues. If you want maximal eigenvalues, just send -A to the function.\n\n    :Reference:\n\n\n        S. V. Dolgov, B. N. Khoromskij, I. V. Oseledets, and D. V. Savostyanov.\n        Computation of extreme eigenvalues in higher dimensions using block tensor train format. Computer Phys. Comm.,\n        185(4):1207-1216, 2014. http://dx.doi.org/10.1016/j.cpc.2013.12.017\n\n\n    :param A: Matrix in the TT-format\n    :type A: matrix\n    :param y0: Initial guess in the block TT-format, r(d+1) is the number of eigenvalues sought\n    :type y0: tensor\n    :param eps: Accuracy required\n    :type eps: float\n    :param rmax: Maximal rank\n    :type rmax: int\n    :param kickrank: Addition rank, the larger the more robus the method,\n    :type kickrank: int\n    :rtype: A tuple (ev, tensor), where ev is a list of eigenvalues, tensor is an approximation to eigenvectors.\n\n    :Example:\n\n\n        >>> import tt\n        >>> import tt.eigb\n        >>> d = 8; f = 3\n        >>> r = [8] * (d * f + 1); r[d * f] = 8; r[0] = 1\n        >>> x = tt.rand(n, d * f, r)\n        >>> a = tt.qlaplace_dd([8, 8, 8])\n        >>> sol, ev = tt.eigb.eigb(a, x, 1e-6, verb=0)\n        Solving a block eigenvalue problem\n        Looking for 8 eigenvalues with accuracy 1E-06\n        swp: 1 er = 35.93 rmax:19\n        swp: 2 er = 4.51015E-04 rmax:18\n        swp: 3 er = 1.87584E-12 rmax:17\n        Total number of matvecs: 0\n        >>> print ev\n        [ 0.00044828  0.00089654  0.00089654  0.00089654  0.0013448   0.0013448\n                  0.0013448   0.00164356]\n\n\n\n    \"\"\"\n    ry = y0.r.copy()\n    lam = tt_eigb.tt_block_eig.tt_eigb(y0.d, A.n, A.m, A.tt.r, A.tt.core, y0.core, ry, eps,\n                                       rmax, ry[y0.d], 0, nswp, max_full_size, verb)\n    y = tensor()\n    y.d = y0.d\n    y.n = A.n.copy()\n    y.r = ry\n    y.core = tt_eigb.tt_block_eig.result_core.copy()\n    tt_eigb.tt_block_eig.deallocate_result()\n    y.get_ps()\n    return y, lam"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef GMRES(A, u_0, b, eps=1e-6, maxit=100, m=20, _iteration=0, callback=None, verbose=0):\n    maxitexceeded = False\n    converged = False\n\n    if verbose:\n        print('GMRES(m=%d, _iteration=%d, maxit=%d)' % (m, _iteration, maxit))\n    v = np.ones((m + 1), dtype=object) * np.nan\n    R = np.ones((m, m)) * np.nan\n    g = np.zeros(m)\n    s = np.ones(m) * np.nan\n    c = np.ones(m) * np.nan\n    v[0] = b - A(u_0, eps=eps)\n    v[0] = v[0].round(eps)\n    resnorm = v[0].norm()\n    curr_beta = resnorm\n    bnorm = b.norm()\n    wlen = resnorm\n    q = m\n    for j in range(m):\n        _iteration += 1\n\n        delta = eps / (curr_beta / resnorm)\n\n        if verbose:\n            print(\"it = %d delta = \" % _iteration, delta)\n\n        v[j] *= 1.0 / wlen\n        v[j + 1] = A(v[j], eps=delta)\n        for i in range(j + 1):\n            R[i, j] = tt.dot(v[j + 1], v[i])\n            v[j + 1] = v[j + 1] - R[i, j] * v[i]\n        v[j + 1] = v[j + 1].round(delta)\n\n        wlen = v[j + 1].norm()\n        for i in range(j):\n            r1 = R[i, j]\n            r2 = R[i + 1, j]\n            R[i, j] = c[i] * r1 - s[i] * r2\n            R[i + 1, j] = c[i] * r2 + s[i] * r1\n        denom = np.hypot(wlen, R[j, j])\n        s[j] = wlen / denom\n        c[j] = -R[j, j] / denom\n        R[j, j] = -denom\n\n        g[j] = c[j] * curr_beta\n        curr_beta *= s[j]\n\n        if verbose:\n            print(\"it = {}, ||r|| = {}\".format(_iteration, curr_beta / bnorm))\n\n        converged = (curr_beta / bnorm) < eps or (curr_beta / resnorm) < eps\n        maxitexceeded = _iteration >= maxit\n        if converged or maxitexceeded:\n            q = j + 1\n            break\n\n    y = la.solve_triangular(R[:q, :q], g[:q], check_finite=False)\n    for idx in range(q):\n        u_0 += v[idx] * y[idx]\n\n    u_0 = u_0.round(eps)\n\n    if callback is not None:\n        callback(u_0)\n\n    if converged or maxitexceeded:\n        return u_0, resnorm / bnorm\n    return GMRES(A, u_0, b, eps, maxit, m, _iteration, callback=callback, verbose=verbose)", "response": "Flexible TT GMRES algorithm for non - linear system"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the row of the Kronecker product between left and right - orthogonal cores.", "response": "def getRow(leftU, rightV, jVec):\n    '''\n    Compute X_{\\geq \\mu}^T \\otimes X_{leq \\mu}\n    X_{\\geq \\mu} = V_{\\mu+1}(j_{\\mu}) \\ldots V_{d} (j_{d}) [left interface matrix]\n    X_{\\leq \\mu} = U_{1} (j_{1}) \\ldots U_{\\mu-1}(j_{\\mu-1}) [right interface matrix]\n    \n    Parameters:\n        :list of numpy.arrays: leftU\n            left-orthogonal cores from 1 to \\mu-1\n        :list of numpy.arrays: rightV\n            right-orthogonal cores from \\mu+1 to d\n        :list, tuple, np.array: jVec\n            indices for each dimension n[k]\n    Returns:\n        :numpy.array: result\n            Kronecker product between left and right interface\n            matrices. Left matrix is transposed.\n    '''\n    jLeft = None\n    jRight = None\n    if len(leftU) > 0:\n        jLeft = jVec[:len(leftU)]\n    if len(rightV) > 0:\n        jRight = jVec[-len(rightV):]\n    \n    multU = np.ones([1,1])\n    for k in xrange(len(leftU)):\n        multU = np.dot(multU, leftU[k][:, jLeft[k], :])\n    multV= np.ones([1,1])\n    for k in xrange(len(rightV)-1, -1, -1):\n        multV = np.dot(rightV[k][:, jRight[k], :], multV)\n    \n    result = np.kron(multV.T, multU)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes functional J for a given x and a dictionary of functional values.", "response": "def computeFunctional(x, cooP):\n    '''\n    Compute value of functional J(X) = ||PX - PA||^2_F,\n    where P is projector into index subspace of known elements,\n          X is our approximation,\n          A is original tensor.\n          \n    Parameters:\n        :tt.vector: x\n            current approximation [X]\n        :dict: cooP\n            dictionary with two records\n                - 'indices': numpy.array of P x d shape,\n                contains index subspace of P known elements;\n                each string is an index of one element.\n                - 'values': numpy array of size P,\n                contains P known values.\n    \n    Returns:\n        :float: result\n            value of functional\n    '''\n    indices = cooP['indices']\n    values = cooP['values']\n    \n    [P, d] = indices.shape\n    assert P == len(values)\n    \n    result = 0\n    for p in xrange(P):\n        index = tuple(indices[p, :])\n        result += (x[index] - values[p])**2\n    result *= 0.5\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ttSparseALS(cooP, shape, x0=None, ttRank=1, tol=1e-5, maxnsweeps=20, verbose=True, alpha=1e-2):\n    '''\n    TT completion via Alternating Least Squares algorithm.\n    \n    Parameters:\n        :dict: cooP\n            dictionary with two records\n                - 'indices': numpy.array of P x d shape,\n                contains index subspace of P known elements;\n                each string is an index of one element.\n                - 'values': numpy array of size P,\n                contains P known values.   \n        :list, numpy.array: shape\n            full-format shape of tensor to be completed [dimensions]\n        :tt.vector: x0 = None\n            initial approximation of completed tensor\n            If it is specified, parameters 'shape' and 'ttRank' will be ignored\n        :int, numpy.array: ttRank = 1\n            assumed rank of completed tensor\n        :float: tol = 1e-5\n            tolerance for functional value\n        :int: maxnsweeps = 20\n            maximal number of sweeps [sequential optimization of all d cores\n            in right or left direction]\n        :boolean: verbose = True\n            switcher of messages from function\n        :float: alpha: = 1e-2\n            regularizer of least squares problem for each slice of current TT core.\n            [rcond parameter for np.linalg.lstsq]\n            \n    Returns:\n        :tt.vector: xNew\n            completed TT vector\n        :list: fit\n            list of functional values at each sweep\n    '''\n    indices = cooP['indices']\n    values = cooP['values']\n    \n    [P, d] = indices.shape\n    assert P == len(values)\n    \n    timeVal = time.clock()\n    if x0 is None:\n        x = tt.rand(shape, r = ttRank)\n        x = x.round(0.)\n        x = (1./x.norm())*x\n    else:\n        x = copy.deepcopy(x0)\n    assert d == x.d\n    # TODO: also check if cooP indices are aligned with shape\n    normP = np.linalg.norm(values)\n    values /= normP\n    fitList = []\n    sweepTimeList = []\n    initTime = time.clock() - timeVal\n    \n    timeVal = time.clock()\n    coreList = tt.vector.to_list(x)\n    #coreList = orthLRFull(coreList, mu = d, splitResult = False)\n    # orthTime = time.clock() - timeVal\n    \n    if verbose:\n        print(\"Initialization time: %.3f seconds (proc.time)\" % (initTime))\n        # print \"Orthogonalizing time: %.3f seconds (proc.time)\" % (orthTime)\n    \n    for sweep in xrange(maxnsweeps):\n        sweepStart = time.clock()\n        # list left + right\n        [kStart, kEnd, kStep] = [0, d, 1]\n        # select direction of sweep\n        '''\n        if sweep % 2 == 0: # left to rigth\n            [kStart, kEnd, kStep] = [0, d, 1]\n        else: # right to left\n            [kStart, kEnd, kStep] = [d-1, -1, -1]\n        '''\n        # fix k-th core to update\n        for k in xrange(kStart, kEnd, kStep):\n            [r1, n, r2] = coreList[k].shape\n            core = np.zeros([r1, n, r2])\n            leftU = []\n            rightV = []\n            if k > 0:\n                leftU = coreList[:k]\n            if k < d-1:\n                rightV = coreList[k+1:] \n            for i in xrange(n):\n                thetaI = np.where(indices[:, k] == i)[0]\n                if len(thetaI) > 0:\n                    A = np.zeros([len(thetaI), r1*r2])\n                    for j in xrange(len(thetaI)):\n                        tmp = getRow(leftU, rightV, indices[thetaI[j], :])\n                        A[j:j+1, :] += tmp   # .flatten(order = 'F')\n                    vecCoreSlice, _, _, _ = np.linalg.lstsq(A, values[thetaI])#, rcond = alpha)\n                    # 0.5*np.linalg.norm(np.dot(A, vecCoreSlice) - values[thetaI])**2.\n                    core[:, i, :] += reshape(vecCoreSlice, [r1, r2]) ####\n            '''\n            if k < (d-1):\n                core = reshape(core, [r1*n, r2])\n                Q, R = np.linalg.qr(core)\n                rnew = Q.shape[1]\n                core = reshape(Q, [r1, n, rnew])\n                coreList[k+1] = np.einsum('ijk,li->ljk', coreList[k+1], R)\n            '''\n            coreList[k] = core.copy()\n            '''\n            else:\n                if (k > 0):\n                    core = reshape(core, [r1, n*r2])\n                    Q, R = np.linalg.qr(core.T)\n                    rnew = Q.shape[1]\n                    core = reshape(Q.T, [rnew, n, r2])\n                    coreList[k-1] = np.einsum('ijk,lk->ijl', coreList[k-1], R)\n            '''\n            \n        xNew = tt.vector.from_list(coreList)\n        fit = computeFunctional(xNew, cooP)\n        fitList.append(fit)\n        if fit < tol:\n            break\n        if sweep > 0:\n            if abs(fit - fitList[-2]) < tol:\n                break\n        sweepTimeList.append(time.clock() - sweepStart)\n        if verbose:\n            print(\"sweep %d/%d\\t fit value: %.5e\\t time: %.3f seconds (proc.time)\" % (sweep+1, maxnsweeps, fit, sweepTimeList[-1]))\n    if verbose:\n        print(\"Total sweep time: %.3f seconds (proc.time)\\t Total time: %.3f seconds (proc.time)\" % (sum(sweepTimeList), sum(sweepTimeList) + initTime))# + orthTime)\n    info = {'fit': fitList, 'initTime': initTime,  'sweepTime': sweepTimeList} # 'orthTime': orthTime,\n    xNew *= normP\n    values *= normP\n    \n    return xNew, info", "response": "This function is used to generate a new TT vector for a set of functional values in a set of states."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating icon image and hover text", "response": "def update(self, icon=None, hover_text=None):\r\n        \"\"\" update icon image and/or hover text \"\"\"\r\n        if icon:\r\n            self._icon = icon\r\n            self._load_icon()\r\n        if hover_text:\r\n            self._hover_text = hover_text\r\n        self._refresh_icon()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding text items for system locale.", "response": "def encode_for_locale(s):\r\n    \"\"\"\r\n    Encode text items for system locale. If encoding fails, fall back to ASCII.\r\n    \"\"\"\r\n    try:\r\n        return s.encode(LOCALE_ENCODING, 'ignore')\r\n    except (AttributeError, UnicodeDecodeError):\r\n        return s.decode('ascii', 'ignore').encode(LOCALE_ENCODING)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fib(n):\n    v = n.value\n    return v if v < 2 else fib2(PythonInt(v-1)) + fib(PythonInt(v-2))", "response": "Terrible Fibonacci number generator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun Fibonacci generator r times.", "response": "def run_fib_with_clear(r):\n    \"\"\" Run Fibonacci generator r times. \"\"\"\n    for i in range(r):\n        if randint(RAND_MIN, RAND_MAX) == RAND_MIN:\n            fib.cache_clear()\n            fib2.cache_clear()\n        res = fib(PythonInt(FIB))\n        if RESULT != res:\n            raise ValueError(\"Expected %d, Got %d\" % (RESULT, res))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_fib_with_stats(r):\n    for i in range(r):\n        res = fib(PythonInt(FIB))\n        if RESULT != res:\n            raise ValueError(\"Expected %d, Got %d\" % (RESULT, res))", "response": "Run Fibonacci generator r times."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the datetime information out of a string.", "response": "def parse(self, input_str, reference_date=\"\"):\n        \"\"\"Parses datetime information out of string input.\n\n        It invokes the SUTimeWrapper.annotate() function in Java.\n\n        Args:\n            input_str: The input as string that has to be parsed.\n            reference_date: Optional reference data for SUTime.\n\n        Returns:\n            A list of dicts with the result from the SUTimeWrapper.annotate()\n                call.\n        \"\"\"\n        if not jpype.isThreadAttachedToJVM():\n            jpype.attachThreadToJVM()\n        if reference_date:\n            return json.loads(self._sutime.annotate(input_str, reference_date))\n        return json.loads(self._sutime.annotate(input_str))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats a user s message for safe processing.", "response": "def format_message(self, msg, botreply=False):\n        \"\"\"Format a user's message for safe processing.\n\n        This runs substitutions on the message and strips out any remaining\n        symbols (depending on UTF-8 mode).\n\n        :param str msg: The user's message.\n        :param bool botreply: Whether this formatting is being done for the\n            bot's last reply (e.g. in a ``%Previous`` command).\n\n        :return str: The formatted message.\n        \"\"\"\n\n        # Make sure the string is Unicode for Python 2.\n        if sys.version_info[0] < 3 and isinstance(msg, str):\n            msg = msg.decode()\n\n        # Lowercase it.\n        msg = msg.lower()\n\n        # Run substitutions on it.\n        msg = self.substitute(msg, \"sub\")\n\n        # In UTF-8 mode, only strip metacharacters and HTML brackets\n        # (to protect from obvious XSS attacks).\n        if self.utf8:\n            msg = re.sub(RE.utf8_meta, '', msg)\n            msg = re.sub(self.master.unicode_punctuation, '', msg)\n\n            # For the bot's reply, also strip common punctuation.\n            if botreply:\n                msg = re.sub(RE.utf8_punct, '', msg)\n        else:\n            # For everything else, strip all non-alphanumerics.\n            msg = utils.strip_nasties(msg)\n            msg = msg.strip() # Strip leading and trailing white space\n            msg = RE.ws.sub(\" \",msg) # Replace the multiple whitespaces by single whitespace\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npreparing a regular expression for the reply of a user.", "response": "def reply_regexp(self, user, regexp):\n        \"\"\"Prepares a trigger for the regular expression engine.\n\n        :param str user: The user ID invoking a reply.\n        :param str regexp: The original trigger text to be turned into a regexp.\n\n        :return regexp: The final regexp object.\"\"\"\n\n        if regexp in self.master._regexc[\"trigger\"]:\n            # Already compiled this one!\n            return self.master._regexc[\"trigger\"][regexp]\n\n        # If the trigger is simply '*' then the * there needs to become (.*?)\n        # to match the blank string too.\n        regexp = re.sub(RE.zero_star, r'<zerowidthstar>', regexp)\n\n        # Filter in arrays.\n        arrays = re.findall(RE.array, regexp)\n        for array in arrays:\n            rep = ''\n            if array in self.master._array:\n                rep = r'(?:' + '|'.join(self.expand_array(array)) + ')'\n            regexp = re.sub(r'\\@' + re.escape(array) + r'\\b', rep, regexp)\n\n        # Simple replacements.\n        regexp = regexp.replace('*', '(.+?)')   # Convert * into (.+?)\n        regexp = regexp.replace('#', '(\\d+?)')  # Convert # into (\\d+?)\n        regexp = regexp.replace('_', '(\\w+?)')  # Convert _ into (\\w+?)\n        regexp = re.sub(RE.weight, '', regexp)  # Remove {weight} tags, allow spaces before the bracket\n        regexp = regexp.replace('<zerowidthstar>', r'(.*?)')\n\n        # Optionals.\n        optionals = re.findall(RE.optionals, regexp)\n        for match in optionals:\n            parts = match.split(\"|\")\n            new = []\n            for p in parts:\n                p = r'(?:\\\\s|\\\\b)+{}(?:\\\\s|\\\\b)+'.format(p.strip())\n                new.append(p)\n\n            # If this optional had a star or anything in it, make it\n            # non-matching.\n            pipes = '|'.join(new)\n            pipes = pipes.replace(r'(.+?)', r'(?:.+?)')\n            pipes = pipes.replace(r'(\\d+?)', r'(?:\\d+?)')\n            pipes = pipes.replace(r'([A-Za-z]+?)', r'(?:[A-Za-z]+?)')\n\n            regexp = re.sub(r'\\s*\\[' + re.escape(match) + '\\]\\s*',\n                '(?:' + pipes + r'|(?:\\\\s|\\\\b))', regexp)\n\n        # _ wildcards can't match numbers!\n        regexp = re.sub(RE.literal_w, r'[^\\\\s\\\\d]', regexp)\n\n        # Filter in bot variables.\n        bvars = re.findall(RE.bot_tag, regexp)\n        for var in bvars:\n            rep = ''\n            if var in self.master._var:\n                rep = self.format_message(self.master._var[var])\n            regexp = regexp.replace('<bot {var}>'.format(var=var), rep)\n\n        # Filter in user variables.\n        uvars = re.findall(RE.get_tag, regexp)\n        for var in uvars:\n            rep = ''\n            value = self.master.get_uservar(user, var)\n            if value not in [None, \"undefined\"]:\n                rep = utils.strip_nasties(value)\n            regexp = regexp.replace('<get {var}>'.format(var=var), rep)\n\n        # Filter in <input> and <reply> tags. This is a slow process, so only\n        # do it if we have to!\n        if '<input' in regexp or '<reply' in regexp:\n            history = self.master.get_uservar(user, \"__history__\")\n            for type in ['input', 'reply']:\n                tags = re.findall(r'<' + type + r'([0-9])>', regexp)\n                for index in tags:\n                    rep = self.format_message(history[type][int(index) - 1])\n                    regexp = regexp.replace('<{type}{index}>'.format(type=type, index=index), rep)\n                regexp = regexp.replace('<{type}>'.format(type=type),\n                                        self.format_message(history[type][0]))\n                # TODO: the Perl version doesn't do just <input>/<reply> in trigs!\n\n        if self.utf8:\n            return re.compile(r'^' + regexp.lower() + r'$', re.UNICODE)\n        else:\n            return re.compile(r'^' + regexp.lower() + r'$')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_expand_array(self, array_name, depth=0):\n        if depth > self.master._depth:\n            raise Exception(\"deep recursion detected\")\n        if not array_name in self.master._array:\n            raise Exception(\"array '%s' not defined\" % (array_name))\n        ret = list(self.master._array[array_name])\n        for array in self.master._array[array_name]:\n            if array.startswith('@'):\n                ret.remove(array)\n                expanded = self.do_expand_array(array[1:], depth+1)\n                ret.extend(expanded)\n\n        return set(ret)", "response": "Do recurrent expansion of an array."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expand_array(self, array_name):\n        ret = self.master._array[array_name] if array_name in self.master._array else []\n        try:\n            ret = self.do_expand_array(array_name)\n        except Exception as e:\n            self.warn(\"Error expanding array '%s': %s\" % (array_name, str(e)))\n        return ret", "response": "Expand variables and return a list of keywords."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_tags(self, user, msg, reply, st=[], bst=[], depth=0, ignore_object_errors=True):\n        stars = ['']\n        stars.extend(st)\n        botstars = ['']\n        botstars.extend(bst)\n        if len(stars) == 1:\n            stars.append(\"undefined\")\n        if len(botstars) == 1:\n            botstars.append(\"undefined\")\n\n        matcher = re.findall(RE.reply_array, reply)\n        for match in matcher:\n            name = match\n            if name in self.master._array:\n                result = \"{random}\" + \"|\".join(self.master._array[name]) + \"{/random}\"\n            else:\n                result = \"\\x00@\" + name + \"\\x00\"\n            reply = reply.replace(\"(@\"+name+\")\", result)\n        reply = re.sub(RE.ph_array, r'(@\\1)', reply)\n\n        # Tag shortcuts.\n        reply = reply.replace('<person>', '{person}<star>{/person}')\n        reply = reply.replace('<@>', '{@<star>}')\n        reply = reply.replace('<formal>', '{formal}<star>{/formal}')\n        reply = reply.replace('<sentence>', '{sentence}<star>{/sentence}')\n        reply = reply.replace('<uppercase>', '{uppercase}<star>{/uppercase}')\n        reply = reply.replace('<lowercase>', '{lowercase}<star>{/lowercase}')\n\n        # Weight and <star> tags.\n        reply = re.sub(RE.weight, '', reply)  # Leftover {weight}s\n        if len(stars) > 0:\n            reply = reply.replace('<star>', text_type(stars[1]))\n            reStars = re.findall(RE.star_tags, reply)\n            for match in reStars:\n                if int(match) < len(stars):\n                    reply = reply.replace('<star{match}>'.format(match=match), text_type(stars[int(match)]))\n        if len(botstars) > 0:\n            reply = reply.replace('<botstar>', botstars[1])\n            reStars = re.findall(RE.botstars, reply)\n            for match in reStars:\n                if int(match) < len(botstars):\n                    reply = reply.replace('<botstar{match}>'.format(match=match), text_type(botstars[int(match)]))\n\n        # <input> and <reply>\n        history = self.master.get_uservar(user, \"__history__\")\n        if type(history) is not dict:\n            history = self.default_history()\n        reply = reply.replace('<input>', history['input'][0])\n        reply = reply.replace('<reply>', history['reply'][0])\n        reInput = re.findall(RE.input_tags, reply)\n        for match in reInput:\n            reply = reply.replace('<input{match}>'.format(match=match),\n                                  history['input'][int(match) - 1])\n        reReply = re.findall(RE.reply_tags, reply)\n        for match in reReply:\n            reply = reply.replace('<reply{match}>'.format(match=match),\n                                  history['reply'][int(match) - 1])\n\n        # <id> and escape codes.\n        reply = reply.replace('<id>', user)\n        reply = reply.replace('\\\\s', ' ')\n        reply = reply.replace('\\\\n', \"\\n\")\n        reply = reply.replace('\\\\#', '#')\n\n        # Random bits.\n        reRandom = re.findall(RE.random_tags, reply)\n        for match in reRandom:\n            output = ''\n            if '|' in match:\n                output = utils.random_choice(match.split('|'))\n            else:\n                output = utils.random_choice(match.split(' '))\n            reply = reply.replace('{{random}}{match}{{/random}}'.format(match=match), output, 1) # Replace 1st match\n\n        # Person Substitutions and String Formatting.\n        for item in ['person', 'formal', 'sentence', 'uppercase',  'lowercase']:\n            matcher = re.findall(r'\\{' + item + r'\\}(.+?)\\{/' + item + r'\\}', reply)\n            for match in matcher:\n                output = None\n                if item == 'person':\n                    # Person substitutions.\n                    output = self.substitute(match, \"person\")\n                else:\n                    output = utils.string_format(match, item)\n                reply = reply.replace('{{{item}}}{match}{{/{item}}}'.format(item=item, match=match), output)\n\n        # Handle all variable-related tags with an iterative regex approach,\n        # to allow for nesting of tags in arbitrary ways (think <set a=<get b>>)\n        # Dummy out the <call> tags first, because we don't handle them right\n        # here.\n        reply = reply.replace(\"<call>\", \"{__call__}\")\n        reply = reply.replace(\"</call>\", \"{/__call__}\")\n        while True:\n            # This regex will match a <tag> which contains no other tag inside\n            # it, i.e. in the case of <set a=<get b>> it will match <get b> but\n            # not the <set> tag, on the first pass. The second pass will get the\n            # <set> tag, and so on.\n            match = re.search(RE.tag_search, reply)\n            if not match: break  # No remaining tags!\n\n            match = match.group(1)\n            parts  = match.split(\" \", 1)\n            tag    = parts[0].lower()\n            data   = parts[1] if len(parts) > 1 else \"\"\n            insert = \"\"  # Result of the tag evaluation\n\n            # Handle the tags.\n            if tag == \"bot\" or tag == \"env\":\n                # <bot> and <env> tags are similar.\n                target = self.master._var if tag == \"bot\" else self.master._global\n                if \"=\" in data:\n                    # Setting a bot/env variable.\n                    parts = data.split(\"=\")\n                    self.say(\"Set \" + tag + \" variable \" + text_type(parts[0]) + \"=\" + text_type(parts[1]))\n                    target[parts[0]] = parts[1]\n                else:\n                    # Getting a bot/env variable.\n                    insert = target.get(data, \"undefined\")\n            elif tag == \"set\":\n                # <set> user vars.\n                parts = data.split(\"=\")\n                self.say(\"Set uservar \" + text_type(parts[0]) + \"=\" + text_type(parts[1]))\n                self.master.set_uservar(user, parts[0], parts[1])\n            elif tag in [\"add\", \"sub\", \"mult\", \"div\"]:\n                # Math operator tags.\n                parts = data.split(\"=\")\n                var   = parts[0]\n                value = parts[1]\n                curv  = self.master.get_uservar(user, var)\n\n                # Sanity check the value.\n                try:\n                    value = int(value)\n                    if curv in [None, \"undefined\"]:\n                        # Initialize it.\n                        curv = 0\n                except:\n                    insert = \"[ERR: Math can't '{}' non-numeric value '{}']\".format(tag, value)\n\n                # Attempt the operation.\n                try:\n                    orig = int(curv)\n                    new  = 0\n                    if tag == \"add\":\n                        new = orig + value\n                    elif tag == \"sub\":\n                        new = orig - value\n                    elif tag == \"mult\":\n                        new = orig * value\n                    elif tag == \"div\":\n                        new = orig // value\n                    self.master.set_uservar(user, var, new)\n                except:\n                    insert = \"[ERR: Math couldn't '{}' to value '{}']\".format(tag, curv)\n            elif tag == \"get\":\n                insert = self.master.get_uservar(user, data)\n            else:\n                # Unrecognized tag.\n                insert = \"\\x00{}\\x01\".format(match)\n\n            reply = reply.replace(\"<{}>\".format(match), text_type(insert))\n\n        # Restore unrecognized tags.\n        reply = reply.replace(\"\\x00\", \"<\").replace(\"\\x01\", \">\")\n\n        # Streaming code. DEPRECATED!\n        if '{!' in reply:\n            self._warn(\"Use of the {!...} tag is deprecated and not supported here.\")\n\n        # Topic setter.\n        reTopic = re.findall(RE.topic_tag, reply)\n        for match in reTopic:\n            self.say(\"Setting user's topic to \" + match)\n            self.master.set_uservar(user, \"topic\", match)\n            reply = reply.replace('{{topic={match}}}'.format(match=match), '')\n\n        # Inline redirecter.\n        reRedir = re.findall(RE.redir_tag, reply)\n        for match in reRedir:\n            self.say(\"Redirect to \" + match)\n            at = match.strip()\n            subreply = self._getreply(user, at, step=(depth + 1))\n            reply = reply.replace('{{@{match}}}'.format(match=match), subreply)\n\n        # Object caller.\n        reply = reply.replace(\"{__call__}\", \"<call>\")\n        reply = reply.replace(\"{/__call__}\", \"</call>\")\n        reCall = re.findall(r'<call>(.+?)</call>', reply)\n        for match in reCall:\n            parts  = re.split(RE.ws, match)\n            output = ''\n            obj    = parts[0]\n            args   = []\n            if len(parts) > 1:\n                args = parts[1:]\n\n            # Do we know this object?\n            if obj in self.master._objlangs:\n                # We do, but do we have a handler for that language?\n                lang = self.master._objlangs[obj]\n                if lang in self.master._handlers:\n                    # We do.\n                    try:\n                        output = self.master._handlers[lang].call(self.master, obj, user, args)\n                    except python.PythonObjectError as e:\n                        self.warn(str(e))\n                        if not ignore_object_errors:\n                            raise ObjectError(str(e))\n                        output = RS_ERR_OBJECT\n                else:\n                    if not ignore_object_errors:\n                        raise ObjectError(RS_ERR_OBJECT_HANDLER)\n                    output = RS_ERR_OBJECT_HANDLER\n            else:\n                if not ignore_object_errors:\n                    raise ObjectError(RS_ERR_OBJECT_MISSING)\n                output = RS_ERR_OBJECT_MISSING\n\n            reply = reply.replace('<call>{match}</call>'.format(match=match), output)\n\n        return reply", "response": "Process tags in a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a kind of substitution on a message.", "response": "def substitute(self, msg, kind):\n        \"\"\"Run a kind of substitution on a message.\n\n        :param str msg: The message to run substitutions against.\n        :param str kind: The kind of substitution to run,\n            one of ``subs`` or ``person``.\n        \"\"\"\n\n        # Safety checking.\n        if 'lists' not in self.master._sorted:\n            raise RepliesNotSortedError(\"You must call sort_replies() once you are done loading RiveScript documents\")\n        if kind not in self.master._sorted[\"lists\"]:\n            raise RepliesNotSortedError(\"You must call sort_replies() once you are done loading RiveScript documents\")\n\n        # Get the substitution map.\n        subs = None\n        if kind == 'sub':\n            subs = self.master._sub\n        else:\n            subs = self.master._person\n\n        # Make placeholders each time we substitute something.\n        ph = []\n        i  = 0\n\n        for pattern in self.master._sorted[\"lists\"][kind]:\n            result = subs[pattern]\n\n            # Make a placeholder.\n            ph.append(result)\n            placeholder = \"\\x00%d\\x00\" % i\n            i += 1\n\n            cache = self.master._regexc[kind][pattern]\n            msg = re.sub(cache[\"sub1\"], placeholder, msg)\n            msg = re.sub(cache[\"sub2\"], placeholder + r'\\1', msg)\n            msg = re.sub(cache[\"sub3\"], r'\\1' + placeholder + r'\\2', msg)\n            msg = re.sub(cache[\"sub4\"], r'\\1' + placeholder, msg)\n\n        placeholders = re.findall(RE.placeholder, msg)\n        for match in placeholders:\n            i = int(match)\n            result = ph[i]\n            msg = msg.replace('\\x00' + match + '\\x00', result)\n\n        # Strip & return.\n        return msg.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a Python object from a list of code lines.", "response": "def load(self, name, code):\n        \"\"\"Prepare a Python code object given by the RiveScript interpreter.\n\n        :param str name: The name of the Python object macro.\n        :param []str code: The Python source code for the object macro.\n        \"\"\"\n        # We need to make a dynamic Python method.\n        source = \"def RSOBJ(rs, args):\\n\"\n        for line in code:\n            source = source + \"\\t\" + line + \"\\n\"\n\n        source += \"self._objects[name] = RSOBJ\\n\"\n\n        try:\n            exec(source)\n            # self._objects[name] = RSOBJ\n        except Exception as e:\n            print(\"Failed to load code from object\", name)\n            print(\"The error given was: \", e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef call(self, rs, name, user, fields):\n        # Call the dynamic method.\n        if name not in self._objects:\n            return '[ERR: Object Not Found]'\n        func = self._objects[name]\n        reply = ''\n        try:\n            reply = func(rs, fields)\n            if reply is None:\n                reply = ''\n        except Exception as e:\n            raise PythonObjectError(\"Error executing Python object: \" + str(e))\n        return text_type(reply)", "response": "Invoke a previously loaded object macro."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_topic_triggers(rs, topic, thats, depth=0, inheritance=0, inherited=False):\n\n    # Break if we're in too deep.\n    if depth > rs._depth:\n        rs._warn(\"Deep recursion while scanning topic inheritance\")\n\n    # Keep in mind here that there is a difference between 'includes' and\n    # 'inherits' -- topics that inherit other topics are able to OVERRIDE\n    # triggers that appear in the inherited topic. This means that if the top\n    # topic has a trigger of simply '*', then NO triggers are capable of\n    # matching in ANY inherited topic, because even though * has the lowest\n    # priority, it has an automatic priority over all inherited topics.\n    #\n    # The getTopicTriggers method takes this into account. All topics that\n    # inherit other topics will have their triggers prefixed with a fictional\n    # {inherits} tag, which would start at {inherits=0} and increment if this\n    # topic has other inheriting topics. So we can use this tag to make sure\n    # topics that inherit things will have their triggers always be on top of\n    # the stack, from inherits=0 to inherits=n.\n\n    # Important info about the depth vs inheritance params to this function:\n    # depth increments by 1 each time this function recursively calls itrs.\n    # inheritance increments by 1 only when this topic inherits another\n    # topic.\n    #\n    # This way, '> topic alpha includes beta inherits gamma' will have this\n    # effect:\n    #  alpha and beta's triggers are combined together into one matching\n    #  pool, and then those triggers have higher matching priority than\n    #  gamma's.\n    #\n    # The inherited option is True if this is a recursive call, from a topic\n    # that inherits other topics. This forces the {inherits} tag to be added\n    # to the triggers. This only applies when the top topic 'includes'\n    # another topic.\n    rs._say(\"\\tCollecting trigger list for topic \" + topic + \"(depth=\"\n        + str(depth) + \"; inheritance=\" + str(inheritance) + \"; \"\n        + \"inherited=\" + str(inherited) + \")\")\n\n    # topic:   the name of the topic\n    # depth:   starts at 0 and ++'s with each recursion\n\n    # Topic doesn't exist?\n    if not topic in rs._topics:\n        rs._warn(\"Inherited or included topic {} doesn't exist or has no triggers\".format(\n            topic\n        ))\n        return []\n\n    # Collect an array of triggers to return.\n    triggers = []\n\n    # Get those that exist in this topic directly.\n    inThisTopic = []\n    if not thats:\n        # The non-that structure is {topic}->[array of triggers]\n        if topic in rs._topics:\n            for trigger in rs._topics[topic]:\n                inThisTopic.append([ trigger[\"trigger\"], trigger ])\n    else:\n        # The 'that' structure is: {topic}->{cur trig}->{prev trig}->{trig info}\n        if topic in rs._thats.keys():\n            for curtrig in rs._thats[topic].keys():\n                for previous, pointer in rs._thats[topic][curtrig].items():\n                    inThisTopic.append([ pointer[\"trigger\"], pointer ])\n\n    # Does this topic include others?\n    if topic in rs._includes:\n        # Check every included topic.\n        for includes in rs._includes[topic]:\n            rs._say(\"\\t\\tTopic \" + topic + \" includes \" + includes)\n            triggers.extend(get_topic_triggers(rs, includes, thats, (depth + 1), inheritance, True))\n\n    # Does this topic inherit others?\n    if topic in rs._lineage:\n        # Check every inherited topic.\n        for inherits in rs._lineage[topic]:\n            rs._say(\"\\t\\tTopic \" + topic + \" inherits \" + inherits)\n            triggers.extend(get_topic_triggers(rs, inherits, thats, (depth + 1), (inheritance + 1), False))\n\n    # Collect the triggers for *this* topic. If this topic inherits any\n    # other topics, it means that this topic's triggers have higher\n    # priority than those in any inherited topics. Enforce this with an\n    # {inherits} tag.\n    if topic in rs._lineage or inherited:\n        for trigger in inThisTopic:\n            rs._say(\"\\t\\tPrefixing trigger with {inherits=\" + str(inheritance) + \"}\" + trigger[0])\n            triggers.append([\"{inherits=\" + str(inheritance) + \"}\" + trigger[0], trigger[1]])\n    else:\n        triggers.extend(inThisTopic)\n\n    return triggers", "response": "Recursively scans a topic and returns a list of all triggers that are allowed to be added to the top of the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_topic_tree(rs, topic, depth=0):\n\n    # Break if we're in too deep.\n    if depth > rs._depth:\n        rs._warn(\"Deep recursion while scanning topic trees!\")\n        return []\n\n    # Collect an array of all topics.\n    topics = [topic]\n\n    # Does this topic include others?\n    if topic in rs._includes:\n        # Try each of these.\n        for includes in sorted(rs._includes[topic]):\n            topics.extend(get_topic_tree(rs, includes, depth + 1))\n\n    # Does this topic inherit others?\n    if topic in rs._lineage:\n        # Try each of these.\n        for inherits in sorted(rs._lineage[topic]):\n            topics.extend(get_topic_tree(rs, inherits, depth + 1))\n\n    return topics", "response": "Given one topic get the list of all included and inherited topics."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef word_count(trigger, all=False):\n    words = []\n    if all:\n        words = re.split(RE.ws, trigger)\n    else:\n        words = re.split(RE.wilds_and_optionals, trigger)\n\n    wc = 0  # Word count\n    for word in words:\n        if len(word) > 0:\n            wc += 1\n\n    return wc", "response": "Count the number of words that are not wildcards or options in a trigger."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef string_format(msg, method):\n    if method == \"uppercase\":\n        return msg.upper()\n    elif method == \"lowercase\":\n        return msg.lower()\n    elif method == \"sentence\":\n        return msg.capitalize()\n    elif method == \"formal\":\n        return string.capwords(msg)", "response": "Format a string (upper, lower, formal, sentence).\n\n    :param str msg: The user's message.\n    :param str method: One of ``uppercase``, ``lowercase``,\n        ``sentence`` or ``formal``.\n\n    :return str: The reformatted string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npreparing a Perl code object given by the RS interpreter.", "response": "def load(self, name, code):\n        \"\"\"Prepare a Perl code object given by the RS interpreter.\"\"\"\n\n        source = \"\\n\".join(code)\n        self._objects[name] = source"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreceive an inbound SMS and send a reply from RiveScript.", "response": "def hello_rivescript():\n    \"\"\"Receive an inbound SMS and send a reply from RiveScript.\"\"\"\n\n    from_number = request.values.get(\"From\", \"unknown\")\n    message     = request.values.get(\"Body\")\n    reply       = \"(Internal error)\"\n\n    # Get a reply from RiveScript.\n    if message:\n        reply = bot.reply(from_number, message)\n\n    # Send the response.\n    resp = twilio.twiml.Response()\n    resp.message(reply)\n    return str(resp)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a reply from RiveScript.", "response": "def reply():\n    \"\"\"Fetch a reply from RiveScript.\n\n    Parameters (JSON):\n    * username\n    * message\n    * vars\n    \"\"\"\n    params = request.json\n    if not params:\n        return jsonify({\n            \"status\": \"error\",\n            \"error\": \"Request must be of the application/json type!\",\n        })\n\n    username = params.get(\"username\")\n    message  = params.get(\"message\")\n    uservars = params.get(\"vars\", dict())\n\n    # Make sure the required params are present.\n    if username is None or message is None:\n        return jsonify({\n            \"status\": \"error\",\n            \"error\": \"username and message are required keys\",\n        })\n\n    # Copy and user vars from the post into RiveScript.\n    if type(uservars) is dict:\n        for key, value in uservars.items():\n            bot.set_uservar(username, key, value)\n\n    # Get a reply from the bot.\n    reply = bot.reply(username, message)\n\n    # Get all the user's vars back out of the bot to include in the response.\n    uservars = bot.get_uservars(username)\n\n    # Send the response.\n    return jsonify({\n        \"status\": \"ok\",\n        \"reply\": reply,\n        \"vars\": uservars,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an example curl command.", "response": "def index(path=None):\n    \"\"\"On all other routes, just return an example `curl` command.\"\"\"\n    payload = {\n        \"username\": \"soandso\",\n        \"message\": \"Hello bot\",\n        \"vars\": {\n            \"name\": \"Soandso\",\n        }\n    }\n    return Response(r\"\"\"Usage: curl -i \\\n    -H \"Content-Type: application/json\" \\\n    -X POST -d '{}' \\\n    http://localhost:5000/reply\"\"\".format(json.dumps(payload)),\n    mimetype=\"text/plain\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntranslates a username into a key for Redis.", "response": "def _key(self, username, frozen=False):\n        \"\"\"Translate a username into a key for Redis.\"\"\"\n        if frozen:\n            return self.frozen + username\n        return self.prefix + username"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_user(self, username):\n        data = self.client.get(self._key(username))\n        if data is None:\n            return None\n        return json.loads(data.decode())", "response": "Custom helper method to retrieve a user s data from Redis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sort_trigger_set(triggers, exclude_previous=True, say=None):\n    if say is None:\n        say = lambda x: x\n\n    # KEEP IN MIND: the `triggers` array is composed of array elements of the form\n    # [\"trigger text\", pointer to trigger data]\n    # So this code will use e.g. `trig[0]` when referring to the trigger text.\n\n    # Create a list of trigger objects map.\n    trigger_object_list = []\n    for index, trig in enumerate(triggers):\n\n        if exclude_previous and trig[1][\"previous\"]:\n            continue\n\n        pattern = trig[0]  # Extract only the text of the trigger, with possible tag of inherit\n\n        # See if it has a weight tag\n        match, weight = re.search(RE.weight, trig[0]), 0\n        if match:  # Value of math is not None if there is a match.\n            weight = int(match.group(1))  # Get the weight from the tag ``{weight}``\n\n        # See if it has an inherits tag.\n        match = re.search(RE.inherit, pattern)\n        if match:\n            inherit = int(match.group(1))  # Get inherit value from the tag ``{inherit}``\n            say(\"\\t\\t\\tTrigger belongs to a topic which inherits other topics: level=\" + str(inherit))\n            triggers[index][0] = pattern = re.sub(RE.inherit, \"\", pattern)  # Remove the inherit tag if any\n        else:\n            inherit = sys.maxsize  # If not found any inherit, set it to the maximum value, to place it last in the sort\n\n        trigger_object_list.append(TriggerObj(pattern, index, weight, inherit))\n\n    # Priority order of sorting criteria:\n    # weight, inherit, is_empty, star, pound, under, option, wordcount, len, alphabet\n    sorted_list = sorted(trigger_object_list,\n                         key=attrgetter('weight', 'inherit', 'is_empty', 'star', 'pound',\n                                        'under', 'option', 'wordcount', 'len', 'alphabet'))\n    return [triggers[item.index] for item in sorted_list]", "response": "Sort a group of triggers in optimal sorting order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort_list(items):\n\n    # Track by number of words.\n    track = {}\n\n    def by_length(word1, word2):\n        return len(word2) - len(word1)\n\n    # Loop through each item.\n    for item in items:\n        # Count the words.\n        cword = utils.word_count(item, all=True)\n        if cword not in track:\n            track[cword] = []\n        track[cword].append(item)\n\n    # Sort them.\n    output = []\n    for count in sorted(track.keys(), reverse=True):\n        sort = sorted(track[count], key=len, reverse=True)\n        output.extend(sort)\n\n    return output", "response": "Sort a simple list by number of words and length."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_directory(self, directory, ext=None):\n        self._say(\"Loading from directory: \" + directory)\n\n        if ext is None:\n            # Use the default extensions - .rive is preferable.\n            ext = ['.rive', '.rs']\n        elif type(ext) == str:\n            # Backwards compatibility for ext being a string value.\n            ext = [ext]\n\n        if not os.path.isdir(directory):\n            self._warn(\"Error: \" + directory + \" is not a directory.\")\n            return\n\n        for root, subdirs, files in os.walk(directory):\n            for file in files:\n                for extension in ext:\n                    if file.lower().endswith(extension):\n                        # Load this file.\n                        self.load_file(os.path.join(root, file))\n                        break", "response": "Load RiveScript documents from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_file(self, filename):\n        self._say(\"Loading file: \" + filename)\n\n        fh    = codecs.open(filename, 'r', 'utf-8')\n        lines = fh.readlines()\n        fh.close()\n\n        self._say(\"Parsing \" + str(len(lines)) + \" lines of code from \" + filename)\n        self._parse(filename, lines)", "response": "Load and parse a RiveScript file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stream(self, code):\n        self._say(\"Streaming code.\")\n        if type(code) in [str, text_type]:\n            code = code.split(\"\\n\")\n        self._parse(\"stream()\", code)", "response": "Stream in RiveScript source code dynamically."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse(self, fname, code):\n\n        # Get the \"abstract syntax tree\"\n        ast = self._parser.parse(fname, code)\n\n        # Get all of the \"begin\" type variables: global, var, sub, person, ...\n        for kind, data in ast[\"begin\"].items():\n            internal = getattr(self, \"_\" + kind)  # The internal name for this attribute\n            for name, value in data.items():\n                if value == \"<undef>\":\n                    del internal[name]\n                else:\n                    internal[name] = value\n\n                # Precompile substitutions.\n                if kind in [\"sub\", \"person\"]:\n                    self._precompile_substitution(kind, name)\n\n        # Let the scripts set the debug mode and other special globals.\n        if self._global.get(\"debug\"):\n            self._debug = str(self._global[\"debug\"]).lower() == \"true\"\n        if self._global.get(\"depth\"):\n            self._depth = int(self._global[\"depth\"])\n\n        # Consume all the parsed triggers.\n        for topic, data in ast[\"topics\"].items():\n            # Keep a map of the topics that are included/inherited under this topic.\n            if not topic in self._includes:\n                self._includes[topic] = {}\n            if not topic in self._lineage:\n                self._lineage[topic] = {}\n            self._includes[topic].update(data[\"includes\"])\n            self._lineage[topic].update(data[\"inherits\"])\n\n            # Consume the triggers.\n            if not topic in self._topics:\n                self._topics[topic] = []\n            for trigger in data[\"triggers\"]:\n                self._topics[topic].append(trigger)\n\n                # Precompile the regexp for this trigger.\n                self._precompile_regexp(trigger[\"trigger\"])\n\n                # Does this trigger have a %Previous? If so, make a pointer to\n                # this exact trigger in _thats.\n                if trigger[\"previous\"] is not None:\n                    if not topic in self._thats:\n                        self._thats[topic] = {}\n                    if not trigger[\"trigger\"] in self._thats[topic]:\n                        self._thats[topic][trigger[\"trigger\"]] = {}\n                    self._thats[topic][trigger[\"trigger\"]][trigger[\"previous\"]] = trigger\n\n        # Load all the parsed objects.\n        for obj in ast[\"objects\"]:\n            # Have a handler for it?\n            if obj[\"language\"] in self._handlers:\n                self._objlangs[obj[\"name\"]] = obj[\"language\"]\n                self._handlers[obj[\"language\"]].load(obj[\"name\"], obj[\"code\"])", "response": "Parse the RiveScript source code into memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps the in - memory RiveScript brain as a JSON - serializable Python data structure.", "response": "def deparse(self):\n        \"\"\"Dump the in-memory RiveScript brain as a Python data structure.\n\n        This would be useful, for example, to develop a user interface for\n        editing RiveScript replies without having to edit the RiveScript\n        source code directly.\n\n        :return dict: JSON-serializable Python data structure containing the\n            contents of all RiveScript replies currently loaded in memory.\n        \"\"\"\n\n        # Data to return.\n        result = {\n            \"begin\": {\n                \"global\":   {},\n                \"var\":      {},\n                \"sub\":      {},\n                \"person\":   {},\n                \"array\":    {},\n                \"triggers\": [],\n            },\n            \"topics\":  {},\n        }\n\n        # Populate the config fields.\n        if self._debug:\n            result[\"begin\"][\"global\"][\"debug\"] = self._debug\n        if self._depth != 50:\n            result[\"begin\"][\"global\"][\"depth\"] = 50\n\n        # Definitions\n        result[\"begin\"][\"var\"]    = self._var.copy()\n        result[\"begin\"][\"sub\"]    = self._sub.copy()\n        result[\"begin\"][\"person\"] = self._person.copy()\n        result[\"begin\"][\"array\"]  = self._array.copy()\n        result[\"begin\"][\"global\"].update(self._global.copy())\n\n        # Topic Triggers.\n        for topic in self._topics:\n            dest = None  # Where to place the topic info\n\n            if topic == \"__begin__\":\n                # Begin block.\n                dest = result[\"begin\"]\n            else:\n                # Normal topic.\n                if topic not in result[\"topics\"]:\n                    result[\"topics\"][topic] = {\n                        \"triggers\": [],\n                        \"includes\": {},\n                        \"inherits\": {},\n                    }\n                dest = result[\"topics\"][topic]\n\n            # Copy the triggers.\n            for trig in self._topics[topic]:\n                dest[\"triggers\"].append(copy.deepcopy(trig))\n\n            # Inherits/Includes.\n            for label, mapping in {\"inherits\": self._lineage, \"includes\": self._includes}.items():\n                if topic in mapping and len(mapping[topic]):\n                    dest[label] = mapping[topic].copy()\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, fh, deparsed=None):\n\n        # Passed a string instead of a file handle?\n        if type(fh) is str:\n            fh = codecs.open(fh, \"w\", \"utf-8\")\n\n        # Deparse the loaded data.\n        if deparsed is None:\n            deparsed = self.deparse()\n\n        # Start at the beginning.\n        fh.write(\"// Written by rivescript.deparse()\\n\")\n        fh.write(\"! version = 2.0\\n\\n\")\n\n        # Variables of all sorts!\n        for kind in [\"global\", \"var\", \"sub\", \"person\", \"array\"]:\n            if len(deparsed[\"begin\"][kind].keys()) == 0:\n                continue\n\n            for var in sorted(deparsed[\"begin\"][kind].keys()):\n                # Array types need to be separated by either spaces or pipes.\n                data = deparsed[\"begin\"][kind][var]\n                if type(data) not in [str, text_type]:\n                    needs_pipes = False\n                    for test in data:\n                        if \" \" in test:\n                            needs_pipes = True\n                            break\n\n                    # Word-wrap the result, target width is 78 chars minus the\n                    # kind, var, and spaces and equals sign.\n                    # TODO: not implemented yet.\n                    # width = 78 - len(kind) - len(var) - 4\n\n                    if needs_pipes:\n                        data = self._write_wrapped(\"|\".join(data), sep=\"|\")\n                    else:\n                        data = \" \".join(data)\n\n                fh.write(\"! {kind} {var} = {data}\\n\".format(\n                    kind=kind,\n                    var=var,\n                    data=data,\n                ))\n            fh.write(\"\\n\")\n\n        # Begin block.\n        if len(deparsed[\"begin\"][\"triggers\"]):\n            fh.write(\"> begin\\n\\n\")\n            self._write_triggers(fh, deparsed[\"begin\"][\"triggers\"], indent=\"\\t\")\n            fh.write(\"< begin\\n\\n\")\n\n        # The topics. Random first!\n        topics = [\"random\"]\n        topics.extend(sorted(deparsed[\"topics\"].keys()))\n        done_random = False\n        for topic in topics:\n            if topic not in deparsed[\"topics\"]: continue\n            if topic == \"random\" and done_random: continue\n            if topic == \"random\": done_random = True\n\n            tagged = False  # Used > topic tag\n\n            data = deparsed[\"topics\"][topic]\n\n            if topic != \"random\" or len(data[\"includes\"]) or len(data[\"inherits\"]):\n                tagged = True\n                fh.write(\"> topic \" + topic)\n\n                if data[\"inherits\"]:\n                    fh.write(\" inherits \" + \" \".join(sorted(data[\"inherits\"].keys())))\n                if data[\"includes\"]:\n                    fh.write(\" includes \" + \" \".join(sorted(data[\"includes\"].keys())))\n\n                fh.write(\"\\n\\n\")\n\n            indent = \"\\t\" if tagged else \"\"\n            self._write_triggers(fh, data[\"triggers\"], indent=indent)\n\n            if tagged:\n                fh.write(\"< topic\\n\\n\")\n\n        return True", "response": "Writes the currently parsed RiveScript data into a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _write_triggers(self, fh, triggers, indent=\"\"):\n\n        for trig in triggers:\n            fh.write(indent + \"+ \" + self._write_wrapped(trig[\"trigger\"], indent=indent) + \"\\n\")\n            d = trig\n\n            if d.get(\"previous\"):\n                fh.write(indent + \"% \" + self._write_wrapped(d[\"previous\"], indent=indent) + \"\\n\")\n\n            for cond in d[\"condition\"]:\n                fh.write(indent + \"* \" + self._write_wrapped(cond, indent=indent) + \"\\n\")\n\n            if d.get(\"redirect\"):\n                fh.write(indent + \"@ \" + self._write_wrapped(d[\"redirect\"], indent=indent) + \"\\n\")\n\n            for reply in d[\"reply\"]:\n                fh.write(indent + \"- \" + self._write_wrapped(reply, indent=indent) + \"\\n\")\n\n            fh.write(\"\\n\")", "response": "Writes a list of triggers to a file handle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_wrapped(self, line, sep=\" \", indent=\"\", width=78):\n\n        words = line.split(sep)\n        lines = []\n        line  = \"\"\n        buf   = []\n\n        while len(words):\n            buf.append(words.pop(0))\n            line = sep.join(buf)\n            if len(line) > width:\n                # Need to word wrap!\n                words.insert(0, buf.pop())  # Undo\n                lines.append(sep.join(buf))\n                buf = []\n                line = \"\"\n\n        # Straggler?\n        if line:\n            lines.append(line)\n\n        # Returned output\n        result = lines.pop(0)\n        if len(lines):\n            eol = \"\"\n            if sep == \" \":\n                eol = \"\\s\"\n            for item in lines:\n                result += eol + \"\\n\" + indent + \"^ \" + item\n\n        return result", "response": "Word - wrap a line of text for being written to a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort_replies(self, thats=False):\n        # (Re)initialize the sort cache.\n        self._sorted[\"topics\"] = {}\n        self._sorted[\"thats\"]  = {}\n        self._say(\"Sorting triggers...\")\n\n        # Loop through all the topics.\n        for topic in self._topics.keys():\n            self._say(\"Analyzing topic \" + topic)\n\n            # Collect a list of all the triggers we're going to worry about.\n            # If this topic inherits another topic, we need to recursively add\n            # those to the list as well.\n            alltrig = inherit_utils.get_topic_triggers(self, topic, False)\n\n            # Sort them.\n            self._sorted[\"topics\"][topic] = sorting.sort_trigger_set(alltrig, True, self._say)\n\n            # Get all of the %Previous triggers for this topic.\n            that_triggers = inherit_utils.get_topic_triggers(self, topic, True)\n\n            # And sort them, too.\n            self._sorted[\"thats\"][topic] = sorting.sort_trigger_set(that_triggers, False, self._say)\n\n        # And sort the substitution lists.\n        if not \"lists\" in self._sorted:\n            self._sorted[\"lists\"] = {}\n        self._sorted[\"lists\"][\"sub\"] = sorting.sort_list(self._sub.keys())\n        self._sorted[\"lists\"][\"person\"] = sorting.sort_list(self._person.keys())", "response": "Sort the loaded triggers in memory and the associated topic and person triggers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndefine a custom language handler for RiveScript objects.", "response": "def set_handler(self, language, obj):\n        \"\"\"Define a custom language handler for RiveScript objects.\n\n        Pass in a ``None`` value for the object to delete an existing handler (for\n        example, to prevent Python code from being able to be run by default).\n\n        Look in the ``eg`` folder of the rivescript-python distribution for\n        an example script that sets up a JavaScript language handler.\n\n        :param str language: The lowercased name of the programming language.\n            Examples: python, javascript, perl\n        :param class obj: An instance of an implementation class object.\n            It should provide the following interface::\n\n                class MyObjectHandler:\n                    def __init__(self):\n                        pass\n                    def load(self, name, code):\n                        # name = the name of the object from the RiveScript code\n                        # code = the source code of the object\n                    def call(self, rs, name, fields):\n                        # rs     = the current RiveScript interpreter object\n                        # name   = the name of the object being called\n                        # fields = array of arguments passed to the object\n                        return reply\n        \"\"\"\n\n        # Allow them to delete a handler too.\n        if obj is None:\n            if language in self._handlers:\n                del self._handlers[language]\n        else:\n            self._handlers[language] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_subroutine(self, name, code):\n\n        # Do we have a Python handler?\n        if 'python' in self._handlers:\n            self._handlers['python']._objects[name] = code\n            self._objlangs[name] = 'python'\n        else:\n            self._warn(\"Can't set_subroutine: no Python object handler!\")", "response": "Define a Python object from your program."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a global variable.", "response": "def set_global(self, name, value):\n        \"\"\"Set a global variable.\n\n        Equivalent to ``! global`` in RiveScript code.\n\n        :param str name: The name of the variable to set.\n        :param str value: The value of the variable.\n            Set this to ``None`` to delete the variable.\n        \"\"\"\n        if value is None:\n            # Unset the variable.\n            if name in self._global:\n                del self._global[name]\n        self._global[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a bot variable.", "response": "def set_variable(self, name, value):\n        \"\"\"Set a bot variable.\n\n        Equivalent to ``! var`` in RiveScript code.\n\n        :param str name: The name of the variable to set.\n        :param str value: The value of the variable.\n            Set this to ``None`` to delete the variable.\n        \"\"\"\n        if value is None:\n            # Unset the variable.\n            if name in self._var:\n                del self._var[name]\n        self._var[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a substitution. Equivalent to ``! sub`` in RiveScript code. :param str what: The original text to replace. :param str rep: The text to replace it with. Set this to ``None`` to delete the substitution.", "response": "def set_substitution(self, what, rep):\n        \"\"\"Set a substitution.\n\n        Equivalent to ``! sub`` in RiveScript code.\n\n        :param str what: The original text to replace.\n        :param str rep: The text to replace it with.\n            Set this to ``None`` to delete the substitution.\n        \"\"\"\n        if rep is None:\n            # Unset the variable.\n            if what in self._subs:\n                del self._subs[what]\n        self._subs[what] = rep"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_person(self, what, rep):\n        if rep is None:\n            # Unset the variable.\n            if what in self._person:\n                del self._person[what]\n        self._person[what] = rep", "response": "Set a person substitution."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting a variable for a user.", "response": "def set_uservar(self, user, name, value):\n        \"\"\"Set a variable for a user.\n\n        This is like the ``<set>`` tag in RiveScript code.\n\n        :param str user: The user ID to set a variable for.\n        :param str name: The name of the variable to set.\n        :param str value: The value to set there.\n        \"\"\"\n        self._session.set(user, {name: value})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset many variables for a user or many users.", "response": "def set_uservars(self, user, data=None):\n        \"\"\"Set many variables for a user, or set many variables for many users.\n\n        This function can be called in two ways::\n\n            # Set a dict of variables for a single user.\n            rs.set_uservars(username, vars)\n\n            # Set a nested dict of variables for many users.\n            rs.set_uservars(many_vars)\n\n        In the first syntax, ``vars`` is a simple dict of key/value string\n        pairs. In the second syntax, ``many_vars`` is a structure like this::\n\n            {\n                \"username1\": {\n                    \"key\": \"value\",\n                },\n                \"username2\": {\n                    \"key\": \"value\",\n                },\n            }\n\n        This way you can export *all* user variables via ``get_uservars()``\n        and then re-import them all at once, instead of setting them once per\n        user.\n\n        :param optional str user: The user ID to set many variables for.\n            Skip this parameter to set many variables for many users instead.\n        :param dict data: The dictionary of key/value pairs for user variables,\n            or else a dict of dicts mapping usernames to key/value pairs.\n\n        This may raise a ``TypeError`` exception if you pass it invalid data\n        types. Note that only the standard ``dict`` type is accepted, but not\n        variants like ``OrderedDict``, so if you have a dict-like type you\n        should cast it to ``dict`` first.\n        \"\"\"\n\n        # Check the parameters to see how we're being used.\n        if type(user) is dict and data is None:\n            # Setting many variables for many users.\n            for uid, uservars in user.items():\n                if type(uservars) is not dict:\n                    raise TypeError(\n                        \"In set_uservars(many_vars) syntax, the many_vars dict \"\n                        \"must be in the format of `many_vars['username'] = \"\n                        \"dict(key=value)`, but the contents of many_vars['{}']\"\n                        \" is not a dict.\".format(uid)\n                    )\n\n                self._session.set(uid, uservars)\n\n        elif type(user) in [text_type, str] and type(data) is dict:\n            # Setting variables for a single user.\n            self._session.set(user, data)\n\n        else:\n            raise TypeError(\n                \"set_uservars() may only be called with types ({str}, dict) or \"\n                \"(dict<{str}, dict>) but you called it with types ({a}, {b})\"\n                .format(\n                    str=\"unicode\" if sys.version_info[0] < 3 else \"str\",\n                    a=type(user),\n                    b=type(data),\n                ),\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a user variable about a user.", "response": "def get_uservar(self, user, name):\n        \"\"\"Get a variable about a user.\n\n        :param str user: The user ID to look up a variable for.\n        :param str name: The name of the variable to get.\n\n        :return: The user variable, or ``None`` or ``\"undefined\"``:\n\n            * If the user has no data at all, this returns ``None``.\n            * If the user doesn't have this variable set, this returns the\n              string ``\"undefined\"``.\n            * Otherwise this returns the string value of the variable.\n        \"\"\"\n        if name == '__lastmatch__':  # Treat var `__lastmatch__` since it can't receive \"undefined\" value\n            return self.last_match(user)\n        else:\n            return self._session.get(user, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all the user variables about a user.", "response": "def get_uservars(self, user=None):\n        \"\"\"Get all variables about a user (or all users).\n\n        :param optional str user: The user ID to retrieve all variables for.\n            If not passed, this function will return all data for all users.\n\n        :return dict: All the user variables.\n\n            * If a ``user`` was passed, this is a ``dict`` of key/value pairs\n              of that user's variables. If the user doesn't exist in memory,\n              this returns ``None``.\n            * Otherwise, this returns a ``dict`` of key/value pairs that map\n              user IDs to their variables (a ``dict`` of ``dict``).\n        \"\"\"\n\n        if user is None:\n            # All the users!\n            return self._session.get_all()\n        else:\n            # Just this one!\n            return self._session.get_any(user)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_uservars(self, user=None):\n\n        if user is None:\n            # All the users!\n            self._session.reset_all()\n        else:\n            # Just this one.\n            self._session.reset(user)", "response": "Delete all variables about a user or all users."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trigger_info(self, trigger=None, dump=False):\n        if dump:\n            return self._syntax\n\n        response = None\n\n        # Search the syntax tree for the trigger.\n        for category in self._syntax:\n            for topic in self._syntax[category]:\n                if trigger in self._syntax[category][topic]:\n                    # We got a match!\n                    if response is None:\n                        response = list()\n                    fname, lineno = self._syntax[category][topic][trigger]['trigger']\n                    response.append(dict(\n                        category=category,\n                        topic=topic,\n                        trigger=trigger,\n                        filename=fname,\n                        line=lineno,\n                    ))\n\n        return response", "response": "Get information about a specific trigger."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef current_user(self):\n        if self._brain._current_user is None:\n            # They're doing it wrong.\n            self._warn(\"current_user() is meant to be used from within a Python object macro!\")\n        return self._brain._current_user", "response": "Retrieve the user ID of the current user talking to your bot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a reply from the RiveScript brain.", "response": "def reply(self, user, msg, errors_as_replies=True):\n        \"\"\"Fetch a reply from the RiveScript brain.\n\n        Arguments:\n            user (str): A unique user ID for the person requesting a reply.\n                This could be e.g. a screen name or nickname. It's used internally\n                to store user variables (including topic and history), so if your\n                bot has multiple users each one should have a unique ID.\n            msg (str): The user's message. This is allowed to contain\n                punctuation and such, but any extraneous data such as HTML tags\n                should be removed in advance.\n            errors_as_replies (bool): When errors are encountered (such as a\n                deep recursion error, no reply matched, etc.) this will make the\n                reply be a text representation of the error message. If you set\n                this to ``False``, errors will instead raise an exception, such as\n                a ``DeepRecursionError`` or ``NoReplyError``. By default, no\n                exceptions are raised and errors are set in the reply instead.\n\n        Returns:\n            str: The reply output.\n        \"\"\"\n        return self._brain.reply(user, msg, errors_as_replies)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _precompile_substitution(self, kind, pattern):\n        if pattern not in self._regexc[kind]:\n            qm = re.escape(pattern)\n            self._regexc[kind][pattern] = {\n                \"qm\": qm,\n                \"sub1\": re.compile(r'^' + qm + r'$'),\n                \"sub2\": re.compile(r'^' + qm + r'(\\W+)'),\n                \"sub3\": re.compile(r'(\\W+)' + qm + r'(\\W+)'),\n                \"sub4\": re.compile(r'(\\W+)' + qm + r'$'),\n            }", "response": "Pre - compile the regexp for a substitution pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dump(self):\n        pp = pprint.PrettyPrinter(indent=4)\n\n        print(\"=== Variables ===\")\n        print(\"-- Globals --\")\n        pp.pprint(self._global)\n        print(\"-- Bot vars --\")\n        pp.pprint(self._var)\n        print(\"-- Substitutions --\")\n        pp.pprint(self._sub)\n        print(\"-- Person Substitutions --\")\n        pp.pprint(self._person)\n        print(\"-- Arrays --\")\n        pp.pprint(self._array)\n\n        print(\"=== Topic Structure ===\")\n        pp.pprint(self._topics)\n        print(\"=== %Previous Structure ===\")\n        pp.pprint(self._thats)\n\n        print(\"=== Includes ===\")\n        pp.pprint(self._includes)\n\n        print(\"=== Inherits ===\")\n        pp.pprint(self._lineage)\n\n        print(\"=== Sort Buffer ===\")\n        pp.pprint(self._sorted)\n\n        print(\"=== Syntax Tree ===\")\n        pp.pprint(self._syntax)", "response": "For debugging dump the entire data structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread and parse a RiveScript document and return a data structure that represents all of the useful contents of the RiveScript document.", "response": "def parse(self, filename, code):\n        \"\"\"Read and parse a RiveScript document.\n\n        Returns a data structure that represents all of the useful contents of\n        the document, in this format::\n\n            {\n                \"begin\": { # \"begin\" data\n                    \"global\": {}, # map of !global vars\n                    \"var\": {},    # bot !var's\n                    \"sub\": {},    # !sub substitutions\n                    \"person\": {}, # !person substitutions\n                    \"array\": {},  # !array lists\n                },\n                \"topics\": { # main reply data\n                    \"random\": { # (topic name)\n                        \"includes\": {}, # map of included topics (values=1)\n                        \"inherits\": {}, # map of inherited topics\n                        \"triggers\": [   # array of triggers\n                            {\n                                \"trigger\": \"hello bot\",\n                                \"reply\": [], # array of replies\n                                \"condition\": [], # array of conditions\n                                \"redirect\": None, # redirect command\n                                \"previous\": None, # 'previous' reply\n                            },\n                            # ...\n                        ]\n                    }\n                }\n                \"objects\": [ # parsed object macros\n                    {\n                        \"name\": \"\",     # object name\n                        \"language\": \"\", # programming language\n                        \"code\": [],     # array of lines of code\n                    }\n                ]\n            }\n\n        Args:\n            filename (str): The name of the file that the code came from, for\n                syntax error reporting purposes.\n            code (str[]): The source code to parse.\n\n        Returns:\n            dict: The aforementioned data structure.\n        \"\"\"\n\n        # Eventual returned structure (\"abstract syntax tree\" but not really)\n        ast = {\n            \"begin\": {\n                \"global\": {},\n                \"var\": {},\n                \"sub\": {},\n                \"person\": {},\n                \"array\": {},\n            },\n            \"topics\": {},\n            \"objects\": [],\n        }\n\n        # Track temporary variables.\n        topic   = 'random'  # Default topic=random\n        lineno  = 0         # Line numbers for syntax tracking\n        comment = False     # In a multi-line comment\n        inobj   = False     # In an object\n        objname = ''        # The name of the object we're in\n        objlang = ''        # The programming language of the object\n        objbuf  = []        # Object contents buffer\n        curtrig = None      # Pointer to the current trigger in ast.topics\n        isThat  = None      # Is a %Previous trigger\n\n        # Local (file scoped) parser options.\n        local_options = dict(\n            concat=\"none\",  # Concat mode for ^Continue command\n        )\n\n        # Read each line.\n        for lp, line in enumerate(code):\n            lineno += 1\n\n            self.say(\"Line: \" + line + \" (topic: \" + topic + \") incomment: \" + str(inobj))\n            if len(line.strip()) == 0:  # Skip blank lines\n                continue\n\n            # In an object?\n            if inobj:\n                if re.match(RE.objend, line):\n                    # End the object.\n                    if len(objname):\n                        ast[\"objects\"].append({\n                            \"name\": objname,\n                            \"language\": objlang,\n                            \"code\": objbuf,\n                        })\n                    objname = ''\n                    objlang = ''\n                    objbuf  = []\n                    inobj   = False\n                else:\n                    objbuf.append(line)\n                continue\n\n            line = line.strip()  # Trim excess space. We do it down here so we\n                                 # don't mess up python objects!\n            line = RE.ws.sub(\" \", line)  # Replace the multiple whitespaces by single whitespace\n\n            # Look for comments.\n            if line[:2] == '//':  # A single-line comment.\n                continue\n            elif line[0] == '#':\n                self.warn(\"Using the # symbol for comments is deprecated\", filename, lineno)\n            elif line[:2] == '/*':  # Start of a multi-line comment.\n                if '*/' not in line:  # Cancel if the end is here too.\n                    comment = True\n                continue\n            elif '*/' in line:\n                comment = False\n                continue\n            if comment:\n                continue\n\n            # Separate the command from the data.\n            if len(line) < 2:\n                self.warn(\"Weird single-character line '\" + line + \"' found.\", filename, lineno)\n                continue\n            cmd = line[0]\n            line = line[1:].strip()\n\n            # Ignore inline comments if there's a space before the // symbols.\n            if \" //\" in line:\n                line = line.split(\" //\")[0].strip()\n\n            # Run a syntax check on this line.\n            syntax_error = self.check_syntax(cmd, line)\n            if syntax_error:\n                # There was a syntax error! Are we enforcing strict mode?\n                syntax_error = \"Syntax error in \" + filename + \" line \" + str(lineno) + \": \" \\\n                    + syntax_error + \" (near: \" + cmd + \" \" + line + \")\"\n                if self.strict:\n                    raise Exception(syntax_error)\n                else:\n                    self.warn(syntax_error)\n                    return  # Don't try to continue\n\n            # Reset the %Previous state if this is a new +Trigger.\n            if cmd == '+':\n                isThat = None\n\n            # Do a lookahead for ^Continue and %Previous commands.\n            for i in range(lp + 1, len(code)):\n                lookahead = code[i].strip()\n                if len(lookahead) < 2:\n                    continue\n                lookCmd = lookahead[0]\n                lookahead = lookahead[1:].strip()\n                lookahead = re.sub(RE.space, ' ', lookahead)  # Replace the `\\s` in the message\n\n                # Only continue if the lookahead line has any data.\n                if len(lookahead) != 0:\n                    # The lookahead command has to be either a % or a ^.\n                    if lookCmd != '^' and lookCmd != '%':\n                        break\n\n                    # If the current command is a +, see if the following is\n                    # a %.\n                    if cmd == '+':\n                        if lookCmd == '%':\n                            isThat = lookahead\n                            break\n                        else:\n                            isThat = None\n\n                    # If the current command is a ! and the next command(s) are\n                    # ^, we'll tack each extension on as a line break (which is\n                    # useful information for arrays).\n                    if cmd == '!':\n                        if lookCmd == '^':\n                            line += \"<crlf>\" + lookahead\n                        continue\n\n                    # If the current command is not a ^ and the line after is\n                    # not a %, but the line after IS a ^, then tack it on to the\n                    # end of the current line.\n                    if cmd != '^' and lookCmd != '%':\n                        if lookCmd == '^':\n                            line += self.concat_modes.get(\n                                local_options[\"concat\"], \"\"\n                            ) + lookahead\n                        else:\n                            break\n\n            self.say(\"Command: \" + cmd + \"; line: \" + line)\n\n            # Handle the types of RiveScript commands.\n            if cmd == '!':\n                # ! DEFINE\n                halves = re.split(RE.equals, line, 2)\n                left = re.split(RE.ws, halves[0].strip(), 2)\n                value, type, var = '', '', ''\n                if len(halves) == 2:\n                    value = halves[1].strip()\n                if len(left) >= 1:\n                    type = left[0].strip()\n                    if len(left) >= 2:\n                        var = ' '.join(left[1:]).strip()\n\n                # Remove 'fake' line breaks unless this is an array.\n                if type != 'array':\n                    value = re.sub(RE.crlf, '', value)\n\n                # Handle version numbers.\n                if type == 'version':\n                    # Verify we support it.\n                    try:\n                        if float(value) > rs_version:\n                            self.warn(\"Unsupported RiveScript version. We only support \" + rs_version, filename, lineno)\n                            return\n                    except:\n                        self.warn(\"Error parsing RiveScript version number: not a number\", filename, lineno)\n                    continue\n\n                # All other types of defines require a variable and value name.\n                if len(var) == 0:\n                    self.warn(\"Undefined variable name\", filename, lineno)\n                    continue\n                elif len(value) == 0:\n                    self.warn(\"Undefined variable value\", filename, lineno)\n                    continue\n\n                # Handle the rest of the types.\n                if type == 'local':\n                    # Local file-scoped parser options.\n                    self.say(\"\\tSet parser option \" + var + \" = \" + value)\n                    local_options[var] = value\n                elif type == 'global':\n                    # 'Global' variables\n                    self.say(\"\\tSet global \" + var + \" = \" + value)\n\n                    if value == '<undef>':\n                        try:\n                            del(ast[\"begin\"][\"global\"][var])\n                        except:\n                            self.warn(\"Failed to delete missing global variable\", filename, lineno)\n                    else:\n                        ast[\"begin\"][\"global\"][var] = value\n\n                    # Handle flipping debug and depth vars.\n                    if var == 'debug':\n                        if value.lower() == 'true':\n                            value = True\n                        else:\n                            value = False\n                    elif var == 'depth':\n                        try:\n                            value = int(value)\n                        except:\n                            self.warn(\"Failed to set 'depth' because the value isn't a number!\", filename, lineno)\n                    elif var == 'strict':\n                        if value.lower() == 'true':\n                            value = True\n                        else:\n                            value = False\n                elif type == 'var':\n                    # Bot variables\n                    self.say(\"\\tSet bot variable \" + var + \" = \" + value)\n\n                    if value == '<undef>':\n                        try:\n                            del(ast[\"begin\"][\"var\"][var])\n                        except:\n                            self.warn(\"Failed to delete missing bot variable\", filename, lineno)\n                    else:\n                        ast[\"begin\"][\"var\"][var] = value\n                elif type == 'array':\n                    # Arrays\n                    self.say(\"\\tArray \" + var + \" = \" + value)\n\n                    if value == '<undef>':\n                        try:\n                            del(ast[\"begin\"][\"array\"][var])\n                        except:\n                            self.warn(\"Failed to delete missing array\", filename, lineno)\n                        continue\n\n                    # Did this have multiple parts?\n                    parts = value.split(\"<crlf>\")\n\n                    # Process each line of array data.\n                    fields = []\n                    for val in parts:\n                        if '|' in val:\n                            fields.extend(val.split('|'))\n                        else:\n                            fields.extend(re.split(RE.ws, val))\n\n                    # Convert any remaining '\\s' escape codes into spaces.\n                    for f in fields:\n                        f = f.replace('\\s', ' ')\n\n                    ast[\"begin\"][\"array\"][var] = fields\n                elif type == 'sub':\n                    # Substitutions\n                    self.say(\"\\tSubstitution \" + var + \" => \" + value)\n\n                    if value == '<undef>':\n                        try:\n                            del(ast[\"begin\"][\"sub\"][var])\n                        except:\n                            self.warn(\"Failed to delete missing substitution\", filename, lineno)\n                    else:\n                        ast[\"begin\"][\"sub\"][var] = value\n                elif type == 'person':\n                    # Person Substitutions\n                    self.say(\"\\tPerson Substitution \" + var + \" => \" + value)\n\n                    if value == '<undef>':\n                        try:\n                            del(ast[\"begin\"][\"person\"][var])\n                        except:\n                            self.warn(\"Failed to delete missing person substitution\", filename, lineno)\n                    else:\n                        ast[\"begin\"][\"person\"][var] = value\n                else:\n                    self.warn(\"Unknown definition type '\" + type + \"'\", filename, lineno)\n            elif cmd == '>':\n                # > LABEL\n                temp = re.split(RE.ws, line)\n                type   = temp[0]\n                name   = ''\n                fields = []\n                if len(temp) >= 2:\n                    name = temp[1]\n                if len(temp) >= 3:\n                    fields = temp[2:]\n\n                # Handle the label types.\n                if type == 'begin':\n                    # The BEGIN block.\n                    self.say(\"\\tFound the BEGIN block.\")\n                    type = 'topic'\n                    name = '__begin__'\n                if type == 'topic':\n                    # Starting a new topic.\n                    self.say(\"\\tSet topic to \" + name)\n                    curtrig = None\n                    topic  = name\n\n                    # Initialize the topic tree.\n                    self._init_topic(ast[\"topics\"], topic)\n\n                    # Does this topic include or inherit another one?\n                    mode = ''  # or 'inherits' or 'includes'\n                    if len(fields) >= 2:\n                        for field in fields:\n                            if field == 'includes':\n                                mode = 'includes'\n                            elif field == 'inherits':\n                                mode = 'inherits'\n                            elif mode != '':\n                                # This topic is either inherited or included.\n                                if mode == 'includes':\n                                    ast[\"topics\"][name][\"includes\"][field] = 1\n                                else:\n                                    ast[\"topics\"][name][\"inherits\"][field] = 1\n                elif type == 'object':\n                    # If a field was provided, it should be the programming\n                    # language.\n                    lang = None\n                    if len(fields) > 0:\n                        lang = fields[0].lower()\n\n                    # Only try to parse a language we support.\n                    curtrig = None\n                    if lang is None:\n                        self.warn(\"Trying to parse unknown programming language\", filename, lineno)\n                        lang = 'python'  # Assume it's Python.\n\n                    # We have a handler, so start loading the code.\n                    objname = name\n                    objlang = lang\n                    objbuf  = []\n                    inobj   = True\n                else:\n                    self.warn(\"Unknown label type '\" + type + \"'\", filename, lineno)\n            elif cmd == '<':\n                # < LABEL\n                type = line\n\n                if type == 'begin' or type == 'topic':\n                    self.say(\"\\tEnd topic label.\")\n                    topic = 'random'\n                elif type == 'object':\n                    self.say(\"\\tEnd object label.\")\n                    inobj = False\n            elif cmd == '+':\n                # + TRIGGER\n                self.say(\"\\tTrigger pattern: \" + line)\n\n                # Initialize the topic tree.\n                self._init_topic(ast[\"topics\"], topic)\n                curtrig = {\n                    \"trigger\": line,\n                    \"reply\": [],\n                    \"condition\": [],\n                    \"redirect\": None,\n                    \"previous\": isThat,\n                }\n                ast[\"topics\"][topic][\"triggers\"].append(curtrig)\n            elif cmd == '-':\n                # - REPLY\n                if curtrig is None:\n                    self.warn(\"Response found before trigger\", filename, lineno)\n                    continue\n\n                self.say(\"\\tResponse: \" + line)\n                curtrig[\"reply\"].append(line.strip())\n            elif cmd == '%':\n                # % PREVIOUS\n                pass  # This was handled above.\n            elif cmd == '^':\n                # ^ CONTINUE\n                pass  # This was handled above.\n            elif cmd == '@':\n                # @ REDIRECT\n                if curtrig is None:\n                    self.warn(\"Redirect found before trigger\", filename, lineno)\n                    continue\n\n                self.say(\"\\tRedirect: \" + line)\n                curtrig[\"redirect\"] = line.strip()\n            elif cmd == '*':\n                # * CONDITION\n                if curtrig is None:\n                    self.warn(\"Condition found before trigger\", filename, lineno)\n                    continue\n\n                self.say(\"\\tAdding condition: \" + line)\n                curtrig[\"condition\"].append(line.strip())\n            else:\n                self.warn(\"Unrecognized command \\\"\" + cmd + \"\\\"\", filename, lineno)\n                continue\n\n        return ast"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the syntax of a line of RiveScript code.", "response": "def check_syntax(self, cmd, line):\n        \"\"\"Syntax check a line of RiveScript code.\n\n        Args:\n            str cmd: The command symbol for the line of code, such as one\n                of ``+``, ``-``, ``*``, ``>``, etc.\n            str line: The remainder of the line of code, such as the text of\n                a trigger or reply.\n\n        Return:\n            str: A string syntax error message or ``None`` if no errors.\n        \"\"\"\n\n        # Run syntax checks based on the type of command.\n        if cmd == '!':\n            # ! Definition\n            #   - Must be formatted like this:\n            #     ! type name = value\n            #     OR\n            #     ! type = value\n            match = re.match(RE.def_syntax, line)\n            if not match:\n                return \"Invalid format for !Definition line: must be '! type name = value' OR '! type = value'\"\n        elif cmd == '>':\n            # > Label\n            #   - The \"begin\" label must have only one argument (\"begin\")\n            #   - \"topic\" labels must be lowercased but can inherit other topics (a-z0-9_\\s)\n            #   - \"object\" labels must follow the same rules as \"topic\", but don't need to be lowercase\n            parts = re.split(\" \", line, 2)\n            if parts[0] == \"begin\" and len(parts) > 1:\n                return \"The 'begin' label takes no additional arguments, should be verbatim '> begin'\"\n            elif parts[0] == \"topic\":\n                search = re.search(RE.name_syntax, line)\n                if search:\n                    return \"Topics should be lowercased and contain only numbers and letters\"\n            elif parts[0] == \"object\":\n                search = re.search(RE.obj_syntax, line) # Upper case is allowed\n                if search:\n                    return \"Objects can only contain numbers and letters\"\n        elif cmd == '+' or cmd == '%' or cmd == '@':\n            # + Trigger, % Previous, @ Redirect\n            #   This one is strict. The triggers are to be run through the regexp engine,\n            #   therefore it should be acceptable for the regexp engine.\n            #   - Entirely lowercase\n            #   - No symbols except: ( | ) [ ] * _ # @ { } < > =\n            #   - All brackets should be matched\n            #   - No empty option with pipe such as ||, [|, |], (|, |) and whitespace between\n            parens = 0  # Open parenthesis\n            square = 0  # Open square brackets\n            curly  = 0  # Open curly brackets\n            angle  = 0  # Open angled brackets\n\n            # Count brackets.\n            for char in line:\n                if char == '(':\n                    parens += 1\n                elif char == ')':\n                    parens -= 1\n                elif char == '[':\n                    square += 1\n                elif char == ']':\n                    square -= 1\n                elif char == '{':\n                    curly += 1\n                elif char == '}':\n                    curly -= 1\n                elif char == '<':\n                    angle += 1\n                elif char == '>':\n                    angle -= 1\n                elif char == '|':\n                    if parens == 0 and square == 0:   # Pipe outside the alternative and option\n                        return \"Pipe | must be within parenthesis brackets or square brackets\"\n\n                if (angle != 0) and (char in {\"(\", \")\", \"[\", \"]\", \"{\", \"}\"}):\n                    return \"Angle bracket must be closed before closing or opening other type of brackets\"\n\n                total = parens + square + curly   # At each character, not more than 1 bracket opens, except <>\n                for special_char_count in [parens, square, curly, angle, total]:\n                    if special_char_count not in (0, 1):\n                        return \"Unbalanced brackets\"\n\n            # Any mismatches?\n            if parens != 0:\n                return \"Unmatched parenthesis brackets\"\n            elif square != 0:\n                return \"Unmatched square brackets\"\n            elif curly != 0:\n                return \"Unmatched curly brackets\"\n            elif angle != 0:\n                return \"Unmatched angle brackets\"\n\n            # Check for empty pipe\n            search = re.search(RE.empty_pipe, line)\n            if search:\n                return \"Piped arrays can't include blank entries\"\n\n            # In UTF-8 mode, most symbols are allowed.\n            if self.utf8:\n                search = re.search(RE.utf8_trig, line)\n                if search:\n                    return \"Triggers can't contain uppercase letters, backslashes or dots in UTF-8 mode.\"\n            else:\n                search = re.search(RE.trig_syntax, line)\n                if search:\n                    return \"Triggers may only contain lowercase letters, numbers, and these symbols: ( | ) [ ] * _ # @ { } < > =\"\n        elif cmd == '-' or cmd == '^' or cmd == '/':\n            # - Trigger, ^ Continue, / Comment\n            # These commands take verbatim arguments, so their syntax is loose.\n            pass\n        elif cmd == '*':\n            # * Condition\n            #   Syntax for a conditional is as follows:\n            #   * value symbol value => response\n            match = re.match(RE.cond_syntax, line)\n            if not match:\n                return \"Invalid format for !Condition: should be like '* value symbol value => response'\"\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump_to_response(request, app_label=None, exclude=None,\n                     filename_prefix=None):\n    \"\"\"Utility function that dumps the given app/model to an HttpResponse.\n    \"\"\"\n    app_label = app_label or []\n    exclude = exclude\n    try:\n        filename = '%s.%s' % (datetime.now().isoformat(),\n                              settings.SMUGGLER_FORMAT)\n        if filename_prefix:\n            filename = '%s_%s' % (filename_prefix, filename)\n        if not isinstance(app_label, list):\n            app_label = [app_label]\n        response = serialize_to_response(app_label, exclude)\n        response['Content-Disposition'] = 'attachment; filename=%s' % filename\n        return response\n    except CommandError as e:\n        messages.error(\n            request,\n            _('An exception occurred while dumping data: %s') % force_text(e))\n    return HttpResponseRedirect(request.build_absolute_uri().split('dump')[0])", "response": "Utility function that dumps the given app and model to an HttpResponse."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump_data(request):\n    # Try to grab app_label data\n    app_label = request.GET.get('app_label', [])\n    if app_label:\n        app_label = app_label.split(',')\n    return dump_to_response(request, app_label=app_label,\n                            exclude=settings.SMUGGLER_EXCLUDE_LIST)", "response": "Exports data from whole project."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexport data from a model.", "response": "def dump_model_data(request, app_label, model_label):\n    \"\"\"Exports data from a model.\n    \"\"\"\n    return dump_to_response(request, '%s.%s' % (app_label, model_label),\n                            [], '-'.join((app_label, model_label)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding the items in the topological order of the items in the input dictionary.", "response": "def toposort(data):\n    \"\"\"Dependencies are expressed as a dictionary whose keys are items\nand whose values are a set of dependent items. Output is a list of\nsets in topological order. The first set consists of items with no\ndependences, each subsequent set consists of items that depend upon\nitems in the preceeding sets.\n\"\"\"\n\n    # Special case empty input.\n    if len(data) == 0:\n        return\n\n    # Copy the input so as to leave it unmodified.\n    data = data.copy()\n\n    # Ignore self dependencies.\n    for k, v in data.items():\n        v.discard(k)\n    # Find all items that don't depend on anything.\n    extra_items_in_deps = functools.reduce(\n        set.union, data.values()\n    ) - set(data.keys())\n\n    # Add empty dependences where needed.\n    data.update(dict((item, set()) for item in extra_items_in_deps))\n    while True:\n        ordered = set(item for item, dep in data.items() if len(dep) == 0)\n        if not ordered:\n            break\n        yield ordered\n        data = dict(\n            (item, (dep - ordered))\n            for item, dep in data.items()\n            if item not in ordered\n        )\n    if len(data) != 0:\n        raise ValueError(\n            'Cyclic dependencies exist among these items: {}'\n            .format(', '.join(repr(x) for x in data.items()))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reorder_dag(sequence,\n                depends_getter=lambda x: x.depends_on,\n                name_getter=lambda x: x.app_name,\n                impatience_max=100):\n    \"\"\"\n    DAG = Directed Acyclic Graph\n    If we have something like:\n        C depends on B\n        B depends on A\n        A doesn't depend on any\n\n    Given the order of [C, B, A] expect it to return [A, B, C]\n\n    parameters:\n\n        :sequence: some sort of iterable list\n\n        :depends_getter: a callable that extracts the depends on sub-list\n\n        :name_getter: a callable that extracts the name\n\n        :impatience_max: a max count that is reached before we end up in\n                         an infinite loop.\n    \"\"\"\n\n    jobs = collections.defaultdict(list)\n    map_ = {}\n    _count_roots = 0\n    for each in sequence:\n        name = name_getter(each)\n        depends_on = depends_getter(each)\n        if depends_on is None:\n            depends_on = []\n        elif isinstance(depends_on, tuple):\n            depends_on = list(depends_on)\n        elif not isinstance(depends_on, list):\n            depends_on = [depends_on]\n        if not depends_on:\n            _count_roots += 1\n        jobs[name] += depends_on\n        map_[name] = each\n\n    if not _count_roots:\n        raise CircularDAGError(\"No job is at the root\")\n\n    try:\n        jobs = dict(zip(jobs.keys(), map(set, jobs.values())))\n        ordered_jobs = list(toposort_flatten(jobs))\n    except ValueError, e:\n        raise CircularDAGError(e)\n\n    return [map_[x] for x in ordered_jobs if x in map_]", "response": "This function will reorder the list of items in the DAG."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a frequency string into a number of seconds that a certain frequency string represents.", "response": "def convert_frequency(frequency):\n    \"\"\"return the number of seconds that a certain frequency string represents.\n    For example: `1d` means 1 day which means 60 * 60 * 24 seconds.\n    The recognized formats are:\n        10d  : 10 days\n        3m   : 3 minutes\n        12h  : 12 hours\n    \"\"\"\n    number = int(re.findall('\\d+', frequency)[0])\n    unit = re.findall('[^\\d]+', frequency)[0]\n    if unit == 'h':\n        number *= 60 * 60\n    elif unit == 'm':\n        number *= 60\n    elif unit == 'd':\n        number *= 60 * 60 * 24\n    elif unit:\n        raise FrequencyDefinitionError(unit)\n    return number"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a nicely formatted string of the time between d and now.", "response": "def timesince(d, now):\n    \"\"\"\n    Taken from django.utils.timesince and modified to simpler requirements.\n\n    Takes two datetime objects and returns the time between d and now\n    as a nicely formatted string, e.g. \"10 minutes\". If d occurs after now,\n    then \"0 minutes\" is returned.\n\n    Units used are years, months, weeks, days, hours, and minutes.\n    Seconds and microseconds are ignored. Up to two adjacent units will be\n    displayed. For example, \"2 weeks, 3 days\" and \"1 year, 3 months\" are\n    possible outputs, but \"2 weeks, 3 hours\" and \"1 year, 5 days\" are not.\n\n    Adapted from\n    http://web.archive.org/web/20060617175230/\\\n    http://blog.natbat.co.uk/archive/2003/Jun/14/time_since\n    \"\"\"\n    def pluralize(a, b):\n        def inner(n):\n            if n == 1:\n                return a % n\n            return b % n\n        return inner\n\n    def ugettext(s):\n        return s\n\n    chunks = (\n        (60 * 60 * 24 * 365, pluralize('%d year', '%d years')),\n        (60 * 60 * 24 * 30, pluralize('%d month', '%d months')),\n        (60 * 60 * 24 * 7, pluralize('%d week', '%d weeks')),\n        (60 * 60 * 24, pluralize('%d day', '%d days')),\n        (60 * 60, pluralize('%d hour', '%d hours')),\n        (60, pluralize('%d minute', '%d minutes')),\n        (0, pluralize('%d second', '%d seconds'))\n    )\n    # Convert datetime.date to datetime.datetime for comparison.\n    if not isinstance(d, datetime.datetime):\n        d = datetime.datetime(d.year, d.month, d.day)\n    if now and not isinstance(now, datetime.datetime):\n        now = datetime.datetime(now.year, now.month, now.day)\n\n    delta = now - d\n    # ignore microseconds\n    since = delta.days * 24 * 60 * 60 + delta.seconds\n    if since <= 0:\n        # d is in the future compared to now, stop processing.\n        # We'll use the last chunk (highest granularity)\n        _, name = chunks[-1]\n        return name(0)\n    for i, (seconds, name) in enumerate(chunks):\n        if seconds > 0:\n            count = since // seconds\n            if count != 0:\n                break\n        else:\n            count = since\n\n    result = name(count)\n    if i + 1 < len(chunks):\n        # Now get the second item\n        seconds2, name2 = chunks[i + 1]\n        if seconds2 > 0:\n            count2 = (since - (seconds * count)) // seconds2\n        else:\n            count2 = since - (seconds * count)\n        if count2 != 0:\n            result += ugettext(', ') + name2(count2)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a named connection.", "response": "def connection(self, name=None):\n        \"\"\"return a named connection.\n\n        This function will return a named connection by either finding one\n        in its pool by the name or creating a new one.  If no name is given,\n        it will use the name of the current executing thread as the name of\n        the connection.\n\n        parameters:\n            name - a name as a string\n        \"\"\"\n        if not name:\n            name = self._get_default_connection_name()\n        if name in self.pool:\n            return self.pool[name]\n        self.pool[name] = psycopg2.connect(self.dsn)\n        return self.pool[name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close_connection(self, connection, force=False):\n        if force:\n            try:\n                connection.close()\n            except self.operational_exceptions:\n                self.config.logger.error('ConnectionFactory - failed closing')\n            for name, conn in self.pool.iteritems():\n                if conn is connection:\n                    break\n            del self.pool[name]\n        else:\n            pass", "response": "overriding the baseclass function this routine will decline to\n        close a connection at the end of a transaction context. This routine will close all open connections."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise the KeyboardInterrupt which will cause the app to effectively shutdown closing all the structures and resources and restart the app if restart is set to True", "response": "def respond_to_SIGHUP(signal_number, frame, logger=None):\n    \"\"\"raise the KeyboardInterrupt which will cause the app to effectively\n    shutdown, closing all it resources.  Then, because it sets 'restart' to\n    True, the app will reread all the configuration information, rebuild all\n    of its structures and resources and start running again\"\"\"\n    global restart\n    restart = True\n    if logger:\n        logger.info('detected SIGHUP')\n    raise KeyboardInterrupt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a series of integers used for the length of the sleep between retries. It produces after exhausting the list, it repeats the last value from the list forever. This generator will never raise the StopIteration exception.", "response": "def backoff_generator(self):\n        \"\"\"Generate a series of integers used for the length of the sleep\n        between retries.  It produces after exhausting the list, it repeats\n        the last value from the list forever.  This generator will never raise\n        the StopIteration exception.\"\"\"\n        for x in self.config.backoff_delays:\n            yield x\n        while True:\n            yield self.config.backoff_delays[-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef responsive_sleep(self, seconds, wait_reason=''):\n        for x in xrange(int(seconds)):\n            if (self.config.wait_log_interval and\n                    not x % self.config.wait_log_interval):\n                self.config.logger.debug(\n                    '%s: %dsec of %dsec' % (wait_reason, x, seconds)\n                )\n            self.quit_check()\n            time.sleep(1.0)", "response": "Sleep for the specified number of seconds logging every\n        wait_log_interval seconds with progress info."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_backfill_cron_app(cls):\n    #----------------------------------------------------------------------\n    def main(self, function=None):\n        return super(cls, self).main(\n            function=function,\n            once=False,\n        )\n    cls.main = main\n    cls._is_backfill_app = True\n    return cls", "response": "a class decorator for Crontabber Apps that allows the base class to be a backfill CronApp."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef with_single_transaction(resource_name):\n    transaction_executor_attr_name = \"%s_transaction_executor\" % resource_name\n\n    def class_decorator(cls):\n        def _run_proxy(self, *args, **kwargs):\n            getattr(self, transaction_executor_attr_name)(\n                self.run,\n                *args,\n                **kwargs\n            )\n        cls._run_proxy = _run_proxy\n        return cls\n    return class_decorator", "response": "a class decorator for Crontabber Apps that returns a class that will be used in a single transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_time(value):\n    try:\n        h, m = value.split(':')\n        h = int(h)\n        m = int(m)\n        if h >= 24 or h < 0:\n            raise ValueError\n        if m >= 60 or m < 0:\n            raise ValueError\n    except ValueError:\n        raise TimeDefinitionError(\"Invalid definition of time %r\" % value)", "response": "check that it s a value like 03 : 45 or 1 : 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef keys(self):\n        keys = []\n        for app_name, __ in self.items():\n            keys.append(app_name)\n        return keys", "response": "return a list of all app_names"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all the app_names and their values as tuples", "response": "def items(self):\n        \"\"\"return all the app_names and their values as tuples\"\"\"\n        sql = \"\"\"\n            SELECT\n                app_name,\n                next_run,\n                first_run,\n                last_run,\n                last_success,\n                depends_on,\n                error_count,\n                last_error\n            FROM crontabber\"\"\"\n        columns = (\n            'app_name',\n            'next_run', 'first_run', 'last_run', 'last_success',\n            'depends_on', 'error_count', 'last_error'\n        )\n        items = []\n        for record in self.transaction_executor(execute_query_fetchall, sql):\n            row = dict(zip(columns, record))\n            items.append((row.pop('app_name'), row))\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef values(self):\n        values = []\n        for __, data in self.items():\n            values.append(data)\n        return values", "response": "return a list of all state values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop(self, key, default=_marker):\n        try:\n            popped = self[key]\n            del self[key]\n            return popped\n        except KeyError:\n            if default == _marker:\n                raise\n            return default", "response": "remove the item by key returning the item with the specified key or default if no item is specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nagios(self, stream=sys.stdout):\n        warnings = []\n        criticals = []\n        for class_name, job_class in self.config.crontabber.jobs.class_list:\n            if job_class.app_name in self.job_state_database:\n                info = self.job_state_database.get(job_class.app_name)\n                if not info.get('error_count', 0):\n                    continue\n                error_count = info['error_count']\n                # trouble!\n                serialized = (\n                    '%s (%s) | %s | %s' %\n                    (job_class.app_name,\n                     class_name,\n                     info['last_error']['type'],\n                     info['last_error']['value'])\n                )\n                if (\n                    error_count == 1 and\n                    hasattr(job_class, \"_is_backfill_app\")\n                ):\n                    # just a warning for now\n                    warnings.append(serialized)\n                else:\n                    # anything worse than that is critical\n                    criticals.append(serialized)\n\n        if criticals:\n            stream.write('CRITICAL - ')\n            stream.write('; '.join(criticals))\n            stream.write('\\n')\n            return 2\n        elif warnings:\n            stream.write('WARNING - ')\n            stream.write('; '.join(warnings))\n            stream.write('\\n')\n            return 1\n        stream.write('OK - All systems nominal')\n        stream.write('\\n')\n        return 0", "response": "Print out the nagios of the current state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the job from the state.", "response": "def reset_job(self, description):\n        \"\"\"remove the job from the state.\n        if means that next time we run, this job will start over from scratch.\n        \"\"\"\n        class_list = self.config.crontabber.jobs.class_list\n        class_list = self._reorder_class_list(class_list)\n        for class_name, job_class in class_list:\n            if (\n                job_class.app_name == description or\n                description == job_class.__module__ + '.' + job_class.__name__\n            ):\n                if job_class.app_name in self.job_state_database:\n                    self.config.logger.info('App reset')\n                    self.job_state_database.pop(job_class.app_name)\n                else:\n                    self.config.logger.warning('App already reset')\n                return\n        raise JobNotFoundError(description)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef time_to_run(self, class_, time_):\n        app_name = class_.app_name\n        try:\n            info = self.job_state_database[app_name]\n        except KeyError:\n            if time_:\n                h, m = [int(x) for x in time_.split(':')]\n                # only run if this hour and minute is < now\n                now = utc_now()\n                if now.hour > h:\n                    return True\n                elif now.hour == h and now.minute >= m:\n                    return True\n                return False\n            else:\n                # no past information, run now\n                return True\n        next_run = info['next_run']\n\n        if not next_run:\n            # It has never run before.\n            # If it has an active ongoing status it means two\n            # independent threads tried to start it. The second one\n            # (by a tiny time margin) will have a job_class whose\n            # `ongoing` value has already been set.\n            # If that's the case, let it through because it will\n            # commence and break due to RowLevelLockError in the\n            # state's __setitem__ method.\n            return bool(info['ongoing'])\n\n        if next_run < utc_now():\n            return True\n        return False", "response": "return true if the job is time to run the job."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompare the list of configured jobs with the jobs in the state database", "response": "def audit_ghosts(self):\n        \"\"\"compare the list of configured jobs with the jobs in the state\"\"\"\n        print_header = True\n        for app_name in self._get_ghosts():\n            if print_header:\n                print_header = False\n                print (\n                    \"Found the following in the state database but not \"\n                    \"available as a configured job:\"\n                )\n            print \"\\t%s\" % (app_name,)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef export_js(\n            self,\n            js_module_name=JS_MODULE_NAME,\n            js_template=JS_ES6_IMPORT_EXPORT_TEMPLATE,\n            js_indent=JS_INDENTATION):\n        '''Export the grammar to a JavaScript file which can be\n        used with the js-lrparsing module.\n\n        Two templates are available:\n            Grammar.JS_WINDOW_TEMPLATE\n            Grammar.JS_ES6_IMPORT_EXPORT_TEMPLATE (default)\n        '''\n\n        language = []\n        refs = []\n        classes = {'Grammar'}\n        indent = 0\n        cname = self.__class__.__name__ if 'import ' in js_template else None\n\n        for name in self._order:\n            elem = getattr(self, name, None)\n            if not isinstance(elem, Element):\n                continue\n            if not hasattr(elem, '_export_js'):\n                continue\n            language.append('{indent}{var} {name} = {value};'.format(\n                indent=js_indent,\n                name=name,\n                var='static' if cname else 'var',\n                value=elem._export_js(js_indent, indent, classes, cname)))\n\n        for name, ref in self._refs.items():\n            refs.append(\n                    '{pre}{name}.set({value});'\n                    .format(\n                        pre='{}.'.format(cname) if cname else js_indent,\n                        name=name,\n                        value=ref._element._export_js(\n                            js_indent,\n                            -1 if cname else indent,\n                            classes,\n                            cname)))\n\n        if 'Rule' in classes:\n            classes.remove('Rule')\n\n        return js_template.format(\n            name=self.__class__.__name__,\n            indent=js_indent,\n            js_module=js_module_name,\n            datetime=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),\n            language='\\n'.join(language),\n            refs='\\n{}'.format('\\n'.join(refs)),\n            arguments=',\\n'.join(map(lambda s:\n                                     js_indent * 3 + s, classes)),\n            re_keywords=self.RE_KEYWORDS.pattern.replace('\\\\', '\\\\\\\\'),\n            classes=', '.join(classes),\n            constructors=',\\n'.join(\n                map(lambda s: js_indent + s,\n                    ['.'.join([\n                        'window',\n                        js_module_name, n]) for n in classes])))", "response": "Exports the grammar to a JavaScript file which can be used with the js - lrparsing module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports the grammar to a python file which can be used with the pyleri module. This can be used to auto - create a grammar and an export of the final result is required.", "response": "def export_py(\n            self,\n            py_module_name=PY_MODULE_NAME,\n            py_template=PY_TEMPLATE,\n            py_indent=PY_INDENTATION):\n        '''Export the grammar to a python file which can be\n        used with the pyleri module. This can be useful when python code\n        if used to auto-create a grammar and an export of the final result is\n        required.'''\n\n        language = []\n        classes = {'Grammar'}\n        indent = 0\n\n        for name in self._order:\n            elem = getattr(self, name, None)\n            if not isinstance(elem, Element):\n                continue\n            if not hasattr(elem, '_export_py'):\n                continue\n            language.append('{indent}{name} = {value}'.format(\n                indent=py_indent,\n                name=name,\n                value=elem._export_py(py_indent, indent, classes)))\n\n        for name, ref in self._refs.items():\n            language.append(\n                '{indent}{name} = {value}'\n                .format(\n                    indent=py_indent,\n                    name=name,\n                    value=ref._element._export_py(\n                        py_indent,\n                        indent,\n                        classes)))\n\n        return py_template.format(\n            name=self.__class__.__name__,\n            indent=py_indent,\n            py_module=py_module_name,\n            datetime=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),\n            language='\\n'.join(language),\n            re_keywords=self.RE_KEYWORDS.pattern.replace('\\\\', '\\\\\\\\'),\n            imports='\\n'.join(\n                map(lambda s: s, [\n                    ' '.join(['from', py_module_name, 'import', n])\n                    for n in classes if n != 'Rule'])))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexport the grammar to a c file which can be used with the libcleri module.", "response": "def export_c(self, target=C_TARGET, c_indent=C_INDENTATION, headerf=None):\n        '''Export the grammar to a c (source and header) file which can be\n        used with the libcleri module.'''\n        language = []\n        indent = 0\n        enums = set()\n        for name in self._order:\n            elem = getattr(self, name, None)\n            if not isinstance(elem, Element):\n                continue\n            if not hasattr(elem, '_export_c'):\n                continue\n            language.append(\n                '{indent}cleri_t * {name} = {value};'.format(\n                    indent=c_indent,\n                    name=name,\n                    value=elem._export_c(c_indent, indent, enums)))\n\n        for name, ref in self._refs.items():\n            language.append(\n                '{indent}cleri_ref_set({name}, {value});'\n                .format(\n                    indent=c_indent,\n                    name=name,\n                    value=ref._element._export_c(\n                        c_indent,\n                        indent,\n                        enums,\n                        ref)))\n\n        pattern = self.RE_KEYWORDS.pattern.replace('\\\\', '\\\\\\\\')\n        if not pattern.startswith('^'):\n            pattern = '^' + pattern\n\n        enums = ',\\n'.join([\n            '{}{}'.format(c_indent, gid)\n            for gid in sorted(enums)]) + ','\n\n        header_file = '\"{}.h\"'.format(target) if headerf is None else headerf\n\n        fun = target.strip('/').replace('/', '_')\n\n        return (self.__class__.C_TEMPLATE_C.format(\n                    name=self.__class__.__name__,\n                    target=target,\n                    header_file=header_file,\n                    fun=fun,\n                    indent=c_indent,\n                    datetime=time.strftime(\n                        '%Y-%m-%d %H:%M:%S',\n                        time.localtime()),\n                    language='\\n'.join(language),\n                    re_keywords=pattern),\n                self.__class__.C_TEMPLATE_H.format(\n                    name=self.__class__.__name__,\n                    target=target,\n                    fun=fun,\n                    guard=target.upper().replace('/', '_').replace('\\\\', '_'),\n                    datetime=time.strftime(\n                        '%Y-%m-%d %H:%M:%S',\n                        time.localtime()),\n                    language='\\n'.join(language),\n                    enums=enums))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef export_go(\n            self,\n            go_template=GO_TEMPLATE,\n            go_indent=GO_INDENTATION,\n            go_package=GO_PACKAGE):\n        '''Export the grammar to a Go file which can be\n        used with the goleri module.'''\n\n        language = []\n        enums = set()\n        indent = 0\n        pattern = self.RE_KEYWORDS.pattern.replace('`', '` + \"`\" + `')\n        if not pattern.startswith('^'):\n            pattern = '^' + pattern\n\n        for name in self._order:\n            elem = getattr(self, name, None)\n            if not isinstance(elem, Element):\n                continue\n            if not hasattr(elem, '_export_go'):\n                continue\n            language.append('{indent}{name} := {value}'.format(\n                indent=go_indent,\n                name=camel_case(name),\n                value=elem._export_go(go_indent, indent, enums)))\n\n        for name, ref in self._refs.items():\n            language.append(\n                    '{indent}{name}.Set({value})'\n                    .format(\n                        indent=go_indent,\n                        name=camel_case(name),\n                        value=ref._element._export_go(\n                            go_indent,\n                            indent,\n                            enums)))\n\n        enums = ' = iota\\n'.join([\n            '{}{}'.format(go_indent, gid)\n            for gid in sorted(enums)]) + ' = iota'\n\n        return go_template.format(\n            name=self.__class__.__name__,\n            indent=go_indent,\n            package=go_package,\n            datetime=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),\n            language='\\n'.join(language),\n            re_keywords=pattern,\n            enums=enums)", "response": "Export the grammar to a Go file which can be\n            used with the goleri module."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexports the grammar to a Java file which can be used with the jleri module.", "response": "def export_java(\n            self,\n            java_template=JAVA_TEMPLATE,\n            java_indent=JAVA_INDENTATION,\n            java_package=JAVA_PACKAGE,\n            is_public=True):\n        '''Export the grammar to a Java file which can be\n        used with the jleri module.'''\n\n        language = []\n        enums = set()\n        classes = {'jleri.Grammar', 'jleri.Element'}\n\n        refs = []\n        indent = 0\n        pattern = self.RE_KEYWORDS.pattern.replace('\\\\', '\\\\\\\\')\n        if not pattern.startswith('^'):\n            pattern = '^' + pattern\n\n        for name in self._order:\n            elem = getattr(self, name, None)\n            if not isinstance(elem, Element):\n                continue\n            if not hasattr(elem, '_export_java'):\n                continue\n            language.append(\n                '{indent}private static final Element {name} = {value};'\n                .format(\n                    indent=java_indent,\n                    name=name.upper(),\n                    value=elem._export_java(\n                        java_indent, indent, enums, classes)))\n\n        enum_str = ',\\n'.join([\n            '{indent}{indent}{gid}'.format(\n                indent=java_indent,\n                gid=gid)\n            for gid in sorted(enums)])\n\n        for name, ref in self._refs.items():\n            refs.append(\n                    '{indent}{indent}((Ref) {name}).set({value});'\n                    .format(\n                        indent=java_indent,\n                        name=name.upper(),\n                        value=ref._element._export_java(\n                            java_indent,\n                            -2,\n                            enums,\n                            classes)))\n        return java_template.format(\n            name=self.__class__.__name__,\n            imports='\\n'.join(\n                map(lambda s: s, [\n                    'import {};'.format(c)\n                    for c in sorted(classes) if c != 'Rule'])),\n            indent=java_indent,\n            package='' if java_package is None\n                    else 'package {};\\n'.format(java_package),\n            datetime=time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),\n            language='\\n'.join(language),\n            re_keywords=pattern,\n            refs='' if not refs else '{}\\n'.format('\\n'.join(refs)),\n            enums=enum_str,\n            public='public ' if is_public else '')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, string):\n        '''Parse some string to the Grammar.\n\n        Returns a nodeResult with the following attributes:\n         - is_valid: True when the string is successfully parsed\n                     by the Grammar.\n         - pos: position in the string where parsing ended.\n                (this is the end of the string when is_valid is True)\n         - expecting: a list containing possible elements at position\n                      'pos' in the string.\n         - tree: the parse_tree containing a structured\n                 result for the given string.\n        '''\n        self._string = string\n        self._expecting = Expecting()\n        self._cached_kw_match.clear()\n        self._len_string = len(string)\n        self._pos = None\n        tree = Node(self._element, string, 0, self._len_string)\n        node_res = Result(*self._walk(\n            self._element,\n            0,\n            tree.children,\n            self._element,\n            True))\n\n        # get rest if anything\n        rest = self._string[node_res.pos:].lstrip()\n\n        # set is_valid to False if we have 'rest' left.\n        if node_res.is_valid and rest:\n            node_res.is_valid = False\n\n        # add end_of_statement to expecting if this is possible\n        if not self._expecting.required and rest:\n            self._expecting.set_mode_required(node_res.pos, True)\n            self._expecting.update(end_of_statement, node_res.pos)\n\n        node_res.expecting = self._expecting.get_expecting()\n\n        # add expecting and correct pos to node_res if node_res is not valid\n        if not node_res.is_valid:\n            node_res.pos = self._expecting.pos\n\n        node_res.tree = tree\n\n        return node_res", "response": "Parse some string to the Grammar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef figure_buffer(figs):\n    '''Extract raw image buffer from matplotlib figure shaped as 1xHxWx3.'''\n    assert len(figs) > 0, 'No figure buffers given. Forgot to return from draw call?'\n    buffers = []\n    w, h = figs[0].canvas.get_width_height()\n    for f in figs:\n        wf, hf = f.canvas.get_width_height()\n        assert wf == w and hf == h, 'All canvas objects need to have same size'\n        buffers.append(np.fromstring(f.canvas.tostring_rgb(), dtype=np.uint8).reshape(h, w, 3))\n\n    return np.stack(buffers)", "response": "Extract raw image buffer from matplotlib figure shaped as 1xHxWx3."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef figure_tensor(func, **tf_pyfunc_kwargs):\n    '''Decorate matplotlib drawing routines.\n\n    This dectorator is meant to decorate functions that return matplotlib\n    figures. The decorated function has to have the following signature\n\n        def decorated(*args, **kwargs) -> figure or iterable of figures\n    \n    where `*args` can be any positional argument and `**kwargs` are any\n    keyword arguments. The decorated function returns a tensor of shape \n    `[NumFigures, Height, Width, 3]` of type `tf.uint8`. \n    \n    The drawing code is invoked during running of TensorFlow sessions, \n    at a time when all positional tensor arguments have been evaluated \n    by the session. The decorated function is then passed the tensor values. \n    All non tensor arguments remain unchanged.\n    '''\n\n    name = tf_pyfunc_kwargs.pop('name', func.__name__)\n\n    @wraps(func)\n    def wrapper(*func_args, **func_kwargs):\n        tf_args = PositionalTensorArgs(func_args)\n        \n        def pyfnc_callee(*tensor_values, **unused):\n            try:\n                figs = as_list(func(*tf_args.mix_args(tensor_values), **func_kwargs))\n                for f in figs:\n                    f.canvas.draw()\n                return figure_buffer(figs)\n            except Exception:\n                print('-'*5 + 'tfmpl catched exception' + '-'*5)\n                print(traceback.format_exc())                \n                print('-'*20)\n                raise\n\n        return tf.py_func(pyfnc_callee, tf_args.tensor_args, tf.uint8, name=name, **tf_pyfunc_kwargs)\n    return wrapper", "response": "Decorate drawing routines. This dectorator is meant to decorate functions that return matplotlib figure objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecorates matplotlib drawing routines that return a tensor of shape 2x2 array of size 3.", "response": "def blittable_figure_tensor(func, init_func, **tf_pyfunc_kwargs):\n    '''Decorate matplotlib drawing routines with blitting support.\n\n    This dectorator is meant to decorate functions that return matplotlib\n    figures. The decorated function has to have the following signature\n\n        def decorated(*args, **kwargs) -> iterable of artists\n    \n    where `*args` can be any positional argument and `**kwargs` are any\n    keyword arguments. The decorated function returns a tensor of shape \n    `[NumFigures, Height, Width, 3]` of type `tf.uint8`. \n\n    Besides the actual drawing function, `blittable_figure_tensor` requires\n    a `init_func` argument with the following signature\n\n        def init(*args, **kwargs) -> iterable of figures, iterable of artists\n    \n    The init function is meant to create and initialize figures, as well as to\n    perform drawing that is meant to be done only once. Any set of artits to be\n    updated in later drawing calls should also be allocated in init. The \n    initialize function must have the same positional and keyword arguments\n    as the decorated function. It is called once before the decorated function\n    is called.\n    \n    The drawing code / init function is invoked during running of TensorFlow \n    sessions, at a time when all positional tensor arguments have been \n    evaluated by the session. The decorated / init function is then passed the \n    tensor values. All non tensor arguments remain unchanged.\n    '''\n    name = tf_pyfunc_kwargs.pop('name', func.__name__)\n    assert callable(init_func), 'Init function not callable'\n\n    @wraps(func)\n    def wrapper(*func_args, **func_kwargs):\n        figs = None\n        bgs = None\n\n        tf_args = PositionalTensorArgs(func_args)\n\n        def pyfnc_callee(*tensor_values, **unused):\n            \n            try:\n                nonlocal figs, bgs\n                pos_args = tf_args.mix_args(tensor_values)\n                \n                if figs is None:\n                    figs, artists = init_func(*pos_args, **func_kwargs)\n                    figs = as_list(figs)\n                    artists = as_list(artists)\n                    for f in figs:\n                        f.canvas.draw()\n                    for a in artists:\n                        a.set_animated(True)\n                    bgs = [f.canvas.copy_from_bbox(f.bbox) for f in figs]                \n\n                artists = as_list(func(*pos_args, **func_kwargs))\n\n                for f, bg in zip(figs, bgs):\n                    f.canvas.restore_region(bg)                \n                for a in artists:\n                    a.axes.draw_artist(a)\n                for f in figs:\n                    f.canvas.blit(f.bbox)\n\n                return figure_buffer(figs)\n            except Exception:\n                print('-'*5 + 'tfmpl catched exception' + '-'*5)\n                print(traceback.format_exc())                \n                print('-'*20)\n                raise\n\n        return tf.py_func(pyfnc_callee, tf_args.tensor_args, tf.uint8, name=name, **tf_pyfunc_kwargs)\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef draw_confusion_matrix(matrix):\n    '''Draw confusion matrix for MNIST.'''\n    fig = tfmpl.create_figure(figsize=(7,7))\n    ax = fig.add_subplot(111)\n    ax.set_title('Confusion matrix for MNIST classification')\n    \n    tfmpl.plots.confusion_matrix.draw(\n        ax, matrix,\n        axis_labels=['Digit ' + str(x) for x in range(10)],\n        normalize=True\n    )\n\n    return fig", "response": "Draw confusion matrix for MNIST classification."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_labels_and_predictions(labels, predictions, num_classes):\n    '''Compute a confusion matrix from labels and predictions.\n    \n    A drop-in replacement for tf.confusion_matrix that works on CPU data\n    and not tensors.\n\n    Params\n    ------\n    labels : array-like \n        1-D array of real labels for classification\n    predicitions: array-like\n        1-D array of predicted label classes\n    num_classes: scalar\n        Total number of classes\n\n    Returns\n    -------\n    matrix : NxN array\n        Array of shape [num_classes, num_classes] containing the confusion values.\n    ''' \n    assert len(labels) == len(predictions)   \n    cm = np.zeros((num_classes, num_classes), dtype=np.int32)\n    for i in range(len(labels)):\n        cm[labels[i], predictions[i]] += 1\n    return cm", "response": "Compute a confusion matrix from labels and predictions."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots a confusion matrix.", "response": "def draw(ax, cm, axis_labels=None, normalize=False):\n    '''Plot a confusion matrix.\n\n    Inspired by\n    https://stackoverflow.com/questions/41617463/tensorflow-confusion-matrix-in-tensorboard\n\n    Params\n    ------\n    ax : axis\n        Axis to plot on\n    cm : NxN array\n        Confusion matrix\n    \n    Kwargs\n    ------\n    axis_labels : array-like\n        Array of size N containing axis labels\n    normalize : bool\n        Whether to plot counts or ratios.\n    '''\n    \n    cm = np.asarray(cm)\n    num_classes = cm.shape[0]\n\n    if normalize:\n        with np.errstate(invalid='ignore', divide='ignore'):\n            cm = cm / cm.sum(1, keepdims=True)\n        cm = np.nan_to_num(cm, copy=True)\n\n    po = np.get_printoptions()\n    np.set_printoptions(precision=2)\n    \n    ax.imshow(cm, cmap='Oranges')\n\n    ticks = np.arange(num_classes)\n    \n    ax.set_xlabel('Predicted')\n    ax.set_xticks(ticks)\n    ax.xaxis.set_label_position('bottom')\n    ax.xaxis.tick_bottom()\n\n    ax.set_ylabel('Actual')\n    ax.set_yticks(ticks)\n    ax.yaxis.set_label_position('left')\n    ax.yaxis.tick_left()\n\n    if axis_labels is not None:\n        ticklabels = [re.sub(r'([a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))', r'\\1 ', x) for x in axis_labels]\n        ticklabels = ['\\n'.join(wrap(l, 20)) for l in ticklabels]\n        ax.set_xticklabels(ticklabels, rotation=-90,  ha='center')\n        ax.set_yticklabels(ticklabels, va ='center')\n\n    for i, j in product(range(num_classes), range(num_classes)):\n        if cm[i,j] == 0:\n            txt = '.'\n        elif normalize:            \n            txt = '{:.2f}'.format(cm[i,j])\n        else:\n            txt = '{}'.format(cm[i,j])\n        ax.text(j, i, txt, horizontalalignment=\"center\", verticalalignment='center', color= \"black\", fontsize=7)\n\n    np.set_printoptions(**po)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_figure(*fig_args, **fig_kwargs):\n    '''Create a single figure.\n\n    Args and Kwargs are passed to `matplotlib.figure.Figure`.\n    \n    This routine is provided in order to avoid usage of pyplot which\n    is stateful and not thread safe. As drawing routines in tf-matplotlib\n    are called from py-funcs in their respective thread, avoid usage\n    of pyplot where possible.\n    '''\n\n    fig = Figure(*fig_args, **fig_kwargs)\n    # Attach canvas\n    FigureCanvas(fig)\n    return fig", "response": "Create a single figure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_figures(n, *fig_args, **fig_kwargs):\n    '''Create multiple figures.\n\n    Args and Kwargs are passed to `matplotlib.figure.Figure`.\n    \n    This routine is provided in order to avoid usage of pyplot which\n    is stateful and not thread safe. As drawing routines in tf-matplotlib\n    are called from py-funcs in their respective thread, avoid usage\n    of pyplot where possible.\n    '''\n    return [create_figure(*fig_args, **fig_kwargs) for _ in range(n)]", "response": "Create multiple figures.\n\n    Args and Kwargs are passed to `matplotlib.figure.Figure`.\n    \n    This routine is provided in order to avoid usage of pyplot which\n    is stateful and not thread safe. As drawing routines in tf-matplotlib\n    are called from py-funcs in their respective thread, avoid usage\n    of pyplot where possible."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vararg_decorator(f):\n    '''Decorator to handle variable argument decorators.'''\n\n    @wraps(f)\n    def decorator(*args, **kwargs):\n        if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n            return f(args[0])\n        else:\n            return lambda realf: f(realf, *args, **kwargs)\n\n    return decorator", "response": "Decorator to handle variable argument decorators."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nensure x is of list type.", "response": "def as_list(x):\n    '''Ensure `x` is of list type.'''\n    \n    if x is None:\n        x = []\n    elif not isinstance(x, Sequence):\n        x = [x]\n    return list(x)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all(self, page=1, per_page=10, order_by=\"latest\"):\n        return self._all(\"/photos\", page=page, per_page=per_page, order_by=order_by)", "response": "Get a single page from the list of all photos."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a single page of the curated photos.", "response": "def curated(self, page=1, per_page=10, order_by=\"latest\"):\n        \"\"\"\n        Get a single page from the list of the curated photos (front-page\u2019s photos).\n\n        :param page [integer]: Page number to retrieve. (Optional; default: 1)\n        :param per_page [integer]: Number of items per page. (Optional; default: 10)\n        :param order_by [string]: How to sort the photos. Optional.\n        (Valid values: latest, oldest, popular; default: latest)\n        :return: [Array]: A single page of the curated Photo list.\n        \"\"\"\n        return self._all(\"/photos/curated\", page=page, per_page=per_page, order_by=order_by)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single photo from the Unsplash API.", "response": "def get(self, photo_id, width=None, height=None, rect=None):\n        \"\"\"\n        Retrieve a single photo.\n\n        Note: Supplying the optional w or h parameters will result\n        in the custom photo URL being added to the 'urls' object:\n\n        :param photo_id [string]: The photo\u2019s ID. Required.\n        :param width [integer]: Image width in pixels.\n        :param height [integer]: Image height in pixels.\n        :param rect [string]: 4 comma-separated integers representing x, y, width, height of the cropped rectangle.\n        :return: [Photo]: The Unsplash Photo.\n        \"\"\"\n        url = \"/photos/%s\" % photo_id\n        params = {\n            \"w\": width,\n            \"h\": height,\n            \"rect\": rect\n        }\n        result = self._get(url, params=params)\n        return PhotoModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(self, query, category=None, orientation=None, page=1, per_page=10):\n        if orientation and orientation not in self.orientation_values:\n            raise Exception()\n        params = {\n            \"query\": query,\n            \"category\": category,\n            \"orientation\": orientation,\n            \"page\": page,\n            \"per_page\": per_page\n        }\n        url = \"/photos/search\"\n        result = self._get(url, params=params)\n        return PhotoModel.parse_list(result)", "response": "Search for photos from a photo search."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves a random photo from the Unsplash API.", "response": "def random(self, count=1, **kwargs):\n        \"\"\"\n        Retrieve a single random photo, given optional filters.\n\n        Note: If supplying multiple category ID\u2019s,\n        the resulting photos will be those that\n        match all of the given categories, not ones that match any category.\n\n        Note: You can\u2019t use the collections and query parameters in the same request\n\n        Note: When supplying a count parameter\n        - and only then - the response will be an array of photos,\n        even if the value of count is 1.\n\n        All parameters are optional, and can be combined to narrow\n        the pool of photos from which a random one will be chosen.\n\n        :param count [integer]: The number of photos to return. (Default: 1; max: 30)\n        :param category: Category ID(\u2018s) to filter selection. If multiple, comma-separated. (deprecated)\n        :param collections: Public collection ID(\u2018s) to filter selection. If multiple, comma-separated\n        :param featured: Limit selection to featured photos.\n        :param username: \tLimit selection to a single user.\n        :param query: Limit selection to photos matching a search term.\n        :param w: Image width in pixels.\n        :param h: Image height in pixels.\n        :param orientation: Filter search results by photo orientation.\n        Valid values are landscape, portrait, and squarish.\n        :return: [Array] or [Photo]: A single page of the curated Photo list or The Unsplash Photo. .\n        :raise UnsplashError: If the given orientation is not in the default orientation values.\n        \"\"\"\n        kwargs.update({\"count\": count})\n        orientation = kwargs.get(\"orientation\", None)\n        if orientation and orientation not in self.orientation_values:\n            raise Exception()\n        url = \"/photos/random\"\n        result = self._get(url, params=kwargs)\n        return PhotoModel.parse_list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a single photo s stats.", "response": "def stats(self, photo_id):\n        \"\"\"\n        Retrieve a single photo\u2019s stats.\n\n        :param photo_id [string]: The photo\u2019s ID. Required.\n        :return: [Stat]: The Unsplash Stat.\n        \"\"\"\n        url = \"/photos/%s/stats\" % photo_id\n        result = self._get(url)\n        return StatModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef like(self, photo_id):\n        url = \"/photos/%s/like\" % photo_id\n        result = self._post(url)\n        return PhotoModel.parse(result)", "response": "Like a photo on behalf of the logged - in user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a user\u2019s like of a photo. Note: This action is idempotent; sending the DELETE request to a single photo multiple times has no additional effect. :param photo_id [string]: The photo\u2019s ID. Required. :return: [Photo]: The Unsplash Photo.", "response": "def unlike(self, photo_id):\n        \"\"\"\n        Remove a user\u2019s like of a photo.\n\n        Note: This action is idempotent; sending the DELETE request\n        to a single photo multiple times has no additional effect.\n\n        :param photo_id [string]: The photo\u2019s ID. Required.\n        :return: [Photo]: The Unsplash Photo.\n        \"\"\"\n        url = \"/photos/%s/like\" % photo_id\n        result = self._delete(url)\n        return PhotoModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef photos(self, query, page=1, per_page=10):\n        url = \"/search/photos\"\n        data = self._search(url, query, page=page, per_page=per_page)\n        data[\"results\"] = PhotoModel.parse_list(data.get(\"results\"))\n        return data", "response": "Get a single page of photo results for a query."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a single page of collection results for a query.", "response": "def collections(self, query, page=1, per_page=10):\n        \"\"\"\n        Get a single page of collection results for a query.\n\n        :param query [string]: Search terms.\n        :param page [integer]: Page number to retrieve. (Optional; default: 1)\n        :param per_page [integer]: Number of items per page. (Optional; default: 10)\n        :return: [dict]: {u'total': 0, u'total_pages': 0, u'results': [Collection]}\n        \"\"\"\n        url = \"/search/collections\"\n        data = self._search(url, query, page=page, per_page=per_page)\n        data[\"results\"] = CollectionModel.parse_list(data.get(\"results\"))\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef users(self, query, page=1, per_page=10):\n        url = \"/search/users\"\n        data = self._search(url, query, page=page, per_page=per_page)\n        data[\"results\"] = UserModel.parse_list(data.get(\"results\"))\n        return data", "response": "Get a single page of user results for a query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a single page from the list of all collections.", "response": "def all(self, page=1, per_page=10):\n        \"\"\"\n        Get a single page from the list of all collections.\n\n        :param page [integer]: Page number to retrieve. (Optional; default: 1)\n        :param per_page [integer]: Number of items per page. (Optional; default: 10)\n        :return: [Array]: A single page of the Collection list.\n        \"\"\"\n        url = \"/collections\"\n        result = self._all(url, page=page, per_page=per_page)\n        return CollectionModel.parse_list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, collection_id):\n        url = \"/collections/%s\" % collection_id\n        result = self._get(url)\n        return CollectionModel.parse(result)", "response": "Retrieve a single collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_curated(self, collection_id):\n        url = \"/collections/curated/%s\" % collection_id\n        result = self._get(url)\n        return CollectionModel.parse(result)", "response": "Retrieve a single curated collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a collection s photos.", "response": "def photos(self, collection_id, page=1, per_page=10):\n        \"\"\"\n        Retrieve a collection\u2019s photos.\n\n        :param collection_id [string]: The collection\u2019s ID. Required.\n        :param page [integer]: Page number to retrieve. (Optional; default: 1)\n        :param per_page [integer]: Number of items per page. (Optional; default: 10)\n        :return: [Array]: A single page of the Photo list.\n        \"\"\"\n        url = \"/collections/%s/photos\" % collection_id\n        result = self._all(url, page=page, per_page=per_page)\n        return PhotoModel.parse_list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a list of collections related to this one.", "response": "def related(self, collection_id):\n        \"\"\"\n        Retrieve a list of collections related to this one.\n\n        :param collection_id [string]: The collection\u2019s ID. Required.\n        :return: [Array]: A single page of the Collection list.\n        \"\"\"\n        url = \"/collections/%s/related\" % collection_id\n        result = self._get(url)\n        return CollectionModel.parse_list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new Unsplash Collection.", "response": "def create(self, title, description=None, private=False):\n        \"\"\"\n        Create a new collection.\n        This requires the 'write_collections' scope.\n\n        :param title [string]: The title of the collection. (Required.)\n        :param description [string]: The collection\u2019s description. (Optional.)\n        :param private [boolean]: Whether to make this collection private. (Optional; default false).\n        :return: [Collection]: The Unsplash Collection.\n        \"\"\"\n        url = \"/collections\"\n        data = {\n            \"title\": title,\n            \"description\": description,\n            \"private\": private\n        }\n        result = self._post(url, data=data)\n        return CollectionModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, collection_id, title=None, description=None, private=False):\n        url = \"/collections/%s\" % collection_id\n        data = {\n            \"title\": title,\n            \"description\": description,\n            \"private\": private\n        }\n        result = self._put(url, data=data)\n        return CollectionModel.parse(result)", "response": "Update an existing Unsplash Collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_photo(self, collection_id, photo_id):\n        url = \"/collections/%s/add\" % collection_id\n        data = {\n            \"collection_id\": collection_id,\n            \"photo_id\": photo_id\n        }\n        result = self._post(url, data=data) or {}\n        return CollectionModel.parse(result.get(\"collection\")), PhotoModel.parse(result.get(\"photo\"))", "response": "Adds a photo to one of the logged - in user s unsplash collections."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_photo(self, collection_id, photo_id):\n        url = \"/collections/%s/remove\" % collection_id\n        data = {\n            \"collection_id\": collection_id,\n            \"photo_id\": photo_id\n        }\n        result = self._delete(url, data=data) or {}\n        return CollectionModel.parse(result.get(\"collection\")), PhotoModel.parse(result.get(\"photo\"))", "response": "Removes a photo from one of the logged - in users s unsplash collections."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef total(self):\n        url = \"/stats/total\"\n        result = self._get(url)\n        return StatModel.parse(result)", "response": "Get a list of counts for all of the Unsplash s stats"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the overall Unsplash stats for the past 30 days.", "response": "def month(self):\n        \"\"\"\n        Get the overall Unsplash stats for the past 30 days.\n\n        :return [Stat]: The Unsplash Stat.\n        \"\"\"\n        url = \"/stats/month\"\n        result = self._get(url)\n        return StatModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the access token for the user.", "response": "def get_access_token(self, code):\n        \"\"\"\n        Getting access token\n        :param code [string]: The authorization code supplied to the callback by Unsplash.\n        :return [string]: access token\n        \"\"\"\n        self.token = self.oauth.fetch_token(\n            token_url=self.access_token_url,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scope=self.scope,\n            code=code\n        )\n        return self.token.get(\"access_token\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef refresh_token(self):\n        self.token = self.oauth.refresh_token(self.access_token_url, refresh_token=self.get_refresh_token())\n        self.access_token = self.token.get(\"access_token\")", "response": "Refresh the current expired access token"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a list of JSON objects into a result set of model instances.", "response": "def parse_list(cls, data):\n        \"\"\"Parse a list of JSON objects into a result set of model instances.\"\"\"\n        results = ResultSet()\n        data = data or []\n        for obj in data:\n            if obj:\n                results.append(cls.parse(obj))\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_auth_header(self):\n        if self.api.is_authenticated:\n            return {\"Authorization\": \"Bearer %s\" % self.api.access_token}\n        return {\"Authorization\": \"Client-ID %s\" % self.api.client_id}", "response": "Returns the authorization header according to the authentication procedure"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the currently - logged in user.", "response": "def me(self):\n        \"\"\"\n        Get the currently-logged in user.\n\n        Note: To access a user\u2019s private data,\n        the user is required to authorize the 'read_user' scope.\n        Without it, this request will return a '403 Forbidden' response.\n\n        Note: Without a Bearer token (i.e. using a Client-ID token)\n        this request will return a '401 Unauthorized' response.\n\n        :return: [User]: The Unsplash User.\n        \"\"\"\n        url = \"/me\"\n        result = self._get(url)\n        return UserModel.parse(result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, **kwargs):\n        url = \"/me\"\n        result = self._put(url, data=kwargs)\n        return UserModel.parse(result)", "response": "Update the currently - logged in user s local cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, username, width=None, height=None):\n        url = \"/users/{username}\".format(username=username)\n        params = {\n            \"w\": width,\n            \"h\": height\n        }\n        result = self._get(url, params=params)\n        return UserModel.parse(result)", "response": "Retrieve public details on a given user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef portfolio(self, username):\n        url = \"/users/{username}/portfolio\".format(username=username)\n        result = self._get(url)\n        return LinkModel.parse(result)", "response": "Retrieve a single user s portfolio link."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of photos uploaded by a user.", "response": "def photos(self, username, page=1, per_page=10, order_by=\"latest\"):\n        \"\"\"\n        Get a list of photos uploaded by a user.\n\n        :param username [string]: The user\u2019s username. Required.\n        :param page [integer]: Page number to retrieve. (Optional; default: 1)\n        :param per_page [integer]: Number of items per page. (Optional; default: 10)\n        :param order_by [string]: How to sort the photos. Optional.\n        (Valid values: latest, oldest, popular; default: latest)\n        :return: [Array]: A single page of the Photo list.\n        \"\"\"\n        url = \"/users/{username}/photos\".format(username=username)\n        result = self._photos(url, username, page=page, per_page=per_page, order_by=order_by)\n        return PhotoModel.parse_list(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collections(self, username, page=1, per_page=10):\n        url = \"/users/{username}/collections\".format(username=username)\n        params = {\n            \"page\": page,\n            \"per_page\": per_page\n        }\n        result = self._get(url, params=params)\n        return CollectionModel.parse_list(result)", "response": "Get a list of collections created by the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a partition of the string based on width", "response": "def wrap(self, width):\n        \"\"\"Returns a partition of the string based on `width`\"\"\"\n        res = []\n        prev_state = set()\n        part = []\n        cwidth = 0\n        for char, _width, state in zip(self._string, self._width, self._state):\n            if cwidth + _width > width:\n                if prev_state:\n                    part.append(self.ANSI_RESET)\n                res.append(\"\".join(part))\n                prev_state = set()\n                part = []\n                cwidth = 0\n            cwidth += _width\n            if prev_state == state:\n                pass\n            elif prev_state <= state:\n                part.extend(state - prev_state)\n            else:\n                part.append(self.ANSI_RESET)\n                part.extend(state)\n            prev_state = state\n            part.append(char)\n        if prev_state:\n            part.append(self.ANSI_RESET)\n        if part:\n            res.append(\"\".join(part))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef max_table_width(self):\n        offset = ((self._column_count - 1)\n                  * termwidth(self.column_separator_char))\n        offset += termwidth(self.left_border_char)\n        offset += termwidth(self.right_border_char)\n        self._max_table_width = max(self._max_table_width,\n                                    offset + self._column_count)\n        return self._max_table_width", "response": "get or set the maximum width of the table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _initialize_table(self, column_count):\n        header = [''] * column_count\n        alignment = [self.default_alignment] * column_count\n        width = [0] * column_count\n        padding = [self.default_padding] * column_count\n\n        self._column_count = column_count\n        self._column_headers = HeaderData(self, header)\n        self._column_alignments = AlignmentMetaData(self, alignment)\n        self._column_widths = PositiveIntegerMetaData(self, width)\n        self._left_padding_widths = PositiveIntegerMetaData(self, padding)\n        self._right_padding_widths = PositiveIntegerMetaData(self, padding)", "response": "Initializes the internal table data structures."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the style of the table from a predefined set of styles.", "response": "def set_style(self, style):\n        \"\"\"Set the style of the table from a predefined set of styles.\n\n        Parameters\n        ----------\n        style: Style\n\n            It can be one of the following:\n\n            * beautifulTable.STYLE_DEFAULT\n            * beautifultable.STYLE_NONE\n            * beautifulTable.STYLE_DOTTED\n            * beautifulTable.STYLE_MYSQL\n            * beautifulTable.STYLE_SEPARATED\n            * beautifulTable.STYLE_COMPACT\n            * beautifulTable.STYLE_MARKDOWN\n            * beautifulTable.STYLE_RESTRUCTURED_TEXT\n            * beautifultable.STYLE_BOX\n            * beautifultable.STYLE_BOX_DOUBLED\n            * beautifultable.STYLE_BOX_ROUNDED\n            * beautifultable.STYLE_GRID\n        \"\"\"\n        if not isinstance(style, enums.Style):\n            allowed = (\"{}.{}\".format(type(self).__name__, i.name)\n                       for i in enums.Style)\n            error_msg = (\"allowed values for style are: \"\n                         + ', '.join(allowed))\n            raise ValueError(error_msg)\n        style_template = style.value\n        self.left_border_char = style_template.left_border_char\n        self.right_border_char = style_template.right_border_char\n        self.top_border_char = style_template.top_border_char\n        self.bottom_border_char = style_template.bottom_border_char\n        self.header_separator_char = style_template.header_separator_char\n        self.column_separator_char = style_template.column_separator_char\n        self.row_separator_char = style_template.row_separator_char\n        self.intersect_top_left = style_template.intersect_top_left\n        self.intersect_top_mid = style_template.intersect_top_mid\n        self.intersect_top_right = style_template.intersect_top_right\n        self.intersect_header_left = style_template.intersect_header_left\n        self.intersect_header_mid = style_template.intersect_header_mid\n        self.intersect_header_right = style_template.intersect_header_right\n        self.intersect_row_left = style_template.intersect_row_left\n        self.intersect_row_mid = style_template.intersect_row_mid\n        self.intersect_row_right = style_template.intersect_row_right\n        self.intersect_bottom_left = style_template.intersect_bottom_left\n        self.intersect_bottom_mid = style_template.intersect_bottom_mid\n        self.intersect_bottom_right = style_template.intersect_bottom_right"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating width of column automatically based on data.", "response": "def _calculate_column_widths(self):\n        \"\"\"Calculate width of column automatically based on data.\"\"\"\n        table_width = self.get_table_width()\n        lpw, rpw = self._left_padding_widths, self._right_padding_widths\n        pad_widths = [(lpw[i] + rpw[i]) for i in range(self._column_count)]\n        max_widths = [0 for index in range(self._column_count)]\n        offset = table_width - sum(self._column_widths) + sum(pad_widths)\n        self._max_table_width = max(self._max_table_width,\n                                    offset + self._column_count)\n\n        for index, column in enumerate(zip(*self._table)):\n            max_length = 0\n            for i in column:\n                for j in to_unicode(i).split('\\n'):\n                    output_str = get_output_str(j, self.detect_numerics,\n                                                self.numeric_precision,\n                                                self.sign_mode.value)\n                    max_length = max(max_length, termwidth(output_str))\n            for i in to_unicode(self._column_headers[index]).split('\\n'):\n                output_str = get_output_str(i, self.detect_numerics,\n                                            self.numeric_precision,\n                                            self.sign_mode.value)\n                max_length = max(max_length, termwidth(output_str))\n            max_widths[index] += max_length\n\n        sum_ = sum(max_widths)\n        desired_sum = self._max_table_width - offset\n\n        # Set flag for columns who are within their fair share\n        temp_sum = 0\n        flag = [0] * len(max_widths)\n        for i, width in enumerate(max_widths):\n            if width <= int(desired_sum / self._column_count):\n                temp_sum += width\n                flag[i] = 1\n            else:\n                # Allocate atleast 1 character width to the column\n                temp_sum += 1\n\n        avail_space = desired_sum - temp_sum\n        actual_space = sum_ - temp_sum\n        shrinked_columns = {}\n\n        # Columns which exceed their fair share should be shrinked based on\n        # how much space is left for the table\n        for i, width in enumerate(max_widths):\n            self.column_widths[i] = width\n            if not flag[i]:\n                new_width = 1 + int((width-1) * avail_space / actual_space)\n                if new_width < width:\n                    self.column_widths[i] = new_width\n                    shrinked_columns[new_width] = i\n\n        # Divide any remaining space among shrinked columns\n        if shrinked_columns:\n            extra = (self._max_table_width\n                     - offset\n                     - sum(self.column_widths))\n            actual_space = sum(shrinked_columns)\n\n            if extra > 0:\n                for i, width in enumerate(sorted(shrinked_columns)):\n                    index = shrinked_columns[width]\n                    extra_width = int(width * extra / actual_space)\n                    self.column_widths[i] += extra_width\n                    if i == (len(shrinked_columns) - 1):\n                        extra = (self._max_table_width\n                                 - offset\n                                 - sum(self.column_widths))\n                        self.column_widths[index] += extra\n\n        for i in range(self.column_count):\n            self.column_widths[i] += pad_widths[i]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort(self, key, reverse=False):\n        if isinstance(key, int):\n            index = key\n        elif isinstance(key, basestring):\n            index = self.get_column_index(key)\n        else:\n            raise TypeError(\"'key' must either be 'int' or 'str'\")\n        self._table.sort(key=operator.itemgetter(index), reverse=reverse)", "response": "Stable sort of the table with respect to a column."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the index of a column from it s header.", "response": "def get_column_index(self, header):\n        \"\"\"Get index of a column from it's header.\n\n        Parameters\n        ----------\n        header: str\n            header of the column.\n\n        Raises\n        ------\n        ValueError:\n            If no column could be found corresponding to `header`.\n        \"\"\"\n        try:\n            index = self._column_headers.index(header)\n            return index\n        except ValueError:\n            raise_suppressed(KeyError((\"'{}' is not a header for any \"\n                                       \"column\").format(header)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_column(self, key):\n        if isinstance(key, int):\n            index = key\n        elif isinstance(key, basestring):\n            index = self.get_column_index(key)\n        else:\n            raise TypeError((\"key must be an int or str, \"\n                             \"not {}\").format(type(key).__name__))\n        return iter(map(operator.itemgetter(index), self._table))", "response": "Return an iterator to a column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving and return a column from the table.", "response": "def pop_column(self, index=-1):\n        \"\"\"Remove and return row at index (default last).\n\n        Parameters\n        ----------\n        index : int, str\n            index of the column, or the header of the column.\n            If index is specified, then normal list rules apply.\n\n        Raises\n        ------\n        TypeError:\n            If index is not an instance of `int`, or `str`.\n\n        IndexError:\n            If Table is empty.\n        \"\"\"\n        if isinstance(index, int):\n            pass\n        elif isinstance(index, basestring):\n            index = self.get_column_index(index)\n        else:\n            raise TypeError((\"column index must be an integer or a string, \"\n                             \"not {}\").format(type(index).__name__))\n        if self._column_count == 0:\n            raise IndexError(\"pop from empty table\")\n        if self._column_count == 1:\n            # This is the last column. So we should clear the table to avoid\n            # empty rows\n            self.clear(clear_metadata=True)\n        else:\n            # Not the last column. safe to pop from row\n            self._column_count -= 1\n            self._column_alignments._pop(index)\n            self._column_widths._pop(index)\n            self._left_padding_widths._pop(index)\n            self._right_padding_widths._pop(index)\n            self._column_headers._pop(index)\n            for row in self._table:\n                row._pop(index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert_row(self, index, row):\n        row = self._validate_row(row)\n        row_obj = RowData(self, row)\n        self._table.insert(index, row_obj)", "response": "Insert a row before index in the table."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates a column named header in the table.", "response": "def update_row(self, key, value):\n        \"\"\"Update a column named `header` in the table.\n\n        If length of column is smaller than number of rows, lets say\n        `k`, only the first `k` values in the column is updated.\n\n        Parameters\n        ----------\n        key : int or slice\n            index of the row, or a slice object.\n\n        value : iterable\n            If an index is specified, `value` should be an iterable\n            of appropriate length. Instead if a slice object is\n            passed as key, value should be an iterable of rows.\n\n        Raises\n        ------\n        IndexError:\n            If index specified is out of range.\n\n        TypeError:\n            If `value` is of incorrect type.\n\n        ValueError:\n            If length of row does not matches number of columns.\n        \"\"\"\n        if isinstance(key, int):\n            row = self._validate_row(value, init_table_if_required=False)\n            row_obj = RowData(self, row)\n            self._table[key] = row_obj\n        elif isinstance(key, slice):\n            row_obj_list = []\n            for row in value:\n                row_ = self._validate_row(row, init_table_if_required=True)\n                row_obj_list.append(RowData(self, row_))\n            self._table[key] = row_obj_list\n        else:\n            raise TypeError(\"key must be an integer or a slice object\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_column(self, header, column):\n        index = self.get_column_index(header)\n        if not isinstance(header, basestring):\n            raise TypeError(\"header must be of type str\")\n        for row, new_item in zip(self._table, column):\n            row[index] = new_item", "response": "Update a column in the table with the given header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting a column before index in the table.", "response": "def insert_column(self, index, header, column):\n        \"\"\"Insert a column before `index` in the table.\n\n        If length of column is bigger than number of rows, lets say\n        `k`, only the first `k` values of `column` is considered.\n        If column is shorter than 'k', ValueError is raised.\n\n        Note that Table remains in consistent state even if column\n        is too short. Any changes made by this method is rolled back\n        before raising the exception.\n\n        Parameters\n        ----------\n        index : int\n            List index rules apply.\n\n        header : str\n            Title of the column.\n\n        column : iterable\n            Any iterable of appropriate length.\n\n        Raises\n        ------\n        TypeError:\n            If `header` is not of type `str`.\n\n        ValueError:\n            If length of `column` is shorter than number of rows.\n        \"\"\"\n        if self._column_count == 0:\n            self.column_headers = HeaderData(self, [header])\n            self._table = [RowData(self, [i]) for i in column]\n        else:\n            if not isinstance(header, basestring):\n                raise TypeError(\"header must be of type str\")\n            column_length = 0\n            for i, (row, new_item) in enumerate(zip(self._table, column)):\n                row._insert(index, new_item)\n                column_length = i\n            if column_length == len(self._table) - 1:\n                self._column_count += 1\n                self._column_headers._insert(index, header)\n                self._column_alignments._insert(index, self.default_alignment)\n                self._column_widths._insert(index, 0)\n                self._left_padding_widths._insert(index, self.default_padding)\n                self._right_padding_widths._insert(index, self.default_padding)\n            else:\n                # Roll back changes so that table remains in consistent state\n                for j in range(column_length, -1, -1):\n                    self._table[j]._pop(index)\n                raise ValueError((\"length of 'column' should be atleast {}, \"\n                                  \"got {}\").format(len(self._table),\n                                                   column_length + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nappends a column to the end of the table.", "response": "def append_column(self, header, column):\n        \"\"\"Append a column to end of the table.\n\n        Parameters\n        ----------\n        header : str\n            Title of the column\n\n        column : iterable\n            Any iterable of appropriate length.\n        \"\"\"\n        self.insert_column(self._column_count, header, column)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_horizontal_line(self, char, intersect_left,\n                             intersect_mid, intersect_right):\n        \"\"\"Get a horizontal line for the table.\n\n        Internal method used to actually get all horizontal lines in the table.\n        Column width should be set prior to calling this method. This method\n        detects intersection and handles it according to the values of\n        `intersect_*_*` attributes.\n\n        Parameters\n        ----------\n        char : str\n            Character used to draw the line.\n\n        Returns\n        -------\n        str\n            String which will be printed as the Top border of the table.\n        \"\"\"\n        width = self.get_table_width()\n\n        try:\n            line = list(char * (int(width/termwidth(char)) + 1))[:width]\n        except ZeroDivisionError:\n            line = [' '] * width\n\n        if len(line) == 0:\n            return ''\n\n        # Only if Special Intersection is enabled and horizontal line is\n        # visible\n        if not char.isspace():\n            # If left border is enabled and it is visible\n            visible_junc = not intersect_left.isspace()\n            if termwidth(self.left_border_char) > 0:\n                if not (self.left_border_char.isspace() and visible_junc):\n                    length = min(termwidth(self.left_border_char),\n                                 termwidth(intersect_left))\n                    for i in range(length):\n                        line[i] = intersect_left[i]\n            visible_junc = not intersect_right.isspace()\n            # If right border is enabled and it is visible\n            if termwidth(self.right_border_char) > 0:\n                if not (self.right_border_char.isspace() and visible_junc):\n                    length = min(termwidth(self.right_border_char),\n                                 termwidth(intersect_right))\n                    for i in range(length):\n                        line[-i-1] = intersect_right[-i-1]\n            visible_junc = not intersect_mid.isspace()\n            # If column separator is enabled and it is visible\n            if termwidth(self.column_separator_char):\n                if not (self.column_separator_char.isspace() and visible_junc):\n                    index = termwidth(self.left_border_char)\n                    for i in range(self._column_count-1):\n                        index += (self._column_widths[i])\n                        length = min(termwidth(self.column_separator_char),\n                                     termwidth(intersect_mid))\n                        for i in range(length):\n                            line[index+i] = intersect_mid[i]\n                        index += termwidth(self.column_separator_char)\n\n        return ''.join(line)", "response": "Returns a string that will be printed as the horizontal line of the table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_table_width(self):\n        if self.column_count == 0:\n            return 0\n        width = sum(self._column_widths)\n        width += ((self._column_count - 1)\n                  * termwidth(self.column_separator_char))\n        width += termwidth(self.left_border_char)\n        width += termwidth(self.right_border_char)\n        return width", "response": "Returns the width of the table as number of characters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_string(self, recalculate_width=True):\n        # Empty table. returning empty string.\n        if len(self._table) == 0:\n            return ''\n\n        if self.serialno and self.column_count > 0:\n            self.insert_column(0, self.serialno_header,\n                               range(1, len(self) + 1))\n\n        # Should widths of column be recalculated\n        if recalculate_width or sum(self._column_widths) == 0:\n            self._calculate_column_widths()\n\n        string_ = []\n\n        # Drawing the top border\n        if self.top_border_char:\n            string_.append(\n                self._get_top_border())\n\n        # Print headers if not empty or only spaces\n        if ''.join(self._column_headers).strip():\n            headers = to_unicode(self._column_headers)\n            string_.append(headers)\n\n            if self.header_separator_char:\n                string_.append(\n                    self._get_header_separator())\n\n        # Printing rows\n        first_row_encountered = False\n        for row in self._table:\n            if first_row_encountered and self.row_separator_char:\n                string_.append(\n                    self._get_row_separator())\n            first_row_encountered = True\n            content = to_unicode(row)\n            string_.append(content)\n\n        # Drawing the bottom border\n        if self.bottom_border_char:\n            string_.append(\n                self._get_bottom_border())\n\n        if self.serialno and self.column_count > 0:\n            self.pop_column(0)\n\n        return '\\n'.join(string_)", "response": "Get the table as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_output_str(item, detect_numerics, precision, sign_value):\n    if detect_numerics:\n        item = _convert_to_numeric(item)\n    if isinstance(item, float):\n        item = round(item, precision)\n    try:\n        item = '{:{sign}}'.format(item, sign=sign_value)\n    except (ValueError, TypeError):\n        pass\n    return to_unicode(item)", "response": "Returns the final string which should be displayed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_row_within_width(self, row):\n        table = self._table\n        lpw, rpw = table.left_padding_widths, table.right_padding_widths\n        wep = table.width_exceed_policy\n\n        list_of_rows = []\n\n        if (wep is WidthExceedPolicy.WEP_STRIP or\n                wep is WidthExceedPolicy.WEP_ELLIPSIS):\n\n            # Let's strip the row\n            delimiter = '' if wep is WidthExceedPolicy.WEP_STRIP else '...'\n            row_item_list = []\n            for index, row_item in enumerate(row):\n                left_pad = table._column_pad * lpw[index]\n                right_pad = table._column_pad * rpw[index]\n                clmp_str = (left_pad\n                            + self._clamp_string(row_item, index, delimiter)\n                            + right_pad)\n                row_item_list.append(clmp_str)\n            list_of_rows.append(row_item_list)\n        elif wep is WidthExceedPolicy.WEP_WRAP:\n\n            # Let's wrap the row\n            string_partition = []\n\n            for index, row_item in enumerate(row):\n                width = table.column_widths[index] - lpw[index] - rpw[index]\n                string_partition.append(textwrap(row_item, width))\n\n            for row_items in zip_longest(*string_partition, fillvalue=''):\n                row_item_list = []\n                for index, row_item in enumerate(row_items):\n                    left_pad = table._column_pad * lpw[index]\n                    right_pad = table._column_pad * rpw[index]\n                    row_item_list.append(left_pad + row_item + right_pad)\n                list_of_rows.append(row_item_list)\n\n        if len(list_of_rows) == 0:\n            return [[''] * table.column_count]\n        else:\n            return list_of_rows", "response": "Process a row so that it is clamped by column_width."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclamps the string to fit in the column referred by column_index.", "response": "def _clamp_string(self, row_item, column_index, delimiter=''):\n        \"\"\"Clamp `row_item` to fit in column referred by column_index.\n\n        This method considers padding and appends the delimiter if `row_item`\n        needs to be truncated.\n\n        Parameters\n        ----------\n        row_item: str\n            String which should be clamped.\n\n        column_index: int\n            Index of the column `row_item` belongs to.\n\n        delimiter: str\n            String which is to be appended to the clamped string.\n\n        Returns\n        -------\n        str\n            The modified string which fits in it's column.\n        \"\"\"\n        width = (self._table.column_widths[column_index]\n                 - self._table.left_padding_widths[column_index]\n                 - self._table.right_padding_widths[column_index])\n\n        if termwidth(row_item) <= width:\n            return row_item\n        else:\n            if width - len(delimiter) >= 0:\n                clamped_string = (textwrap(row_item, width-len(delimiter))[0]\n                                  + delimiter)\n            else:\n                clamped_string = delimiter[:width]\n            return clamped_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending text message to target user.", "response": "def send_im(self, target, message, mentions=None, parse=None, update_msg_id=None, wrap_length=5000):\n        \"\"\"\n        Send text message.\n\n        :param target: Target user UIN or chat ID.\n        :param message: Message text.\n        :param mentions: Iterable with UINs to mention in message.\n        :param parse: Iterable with several values from :class:`icq.constant.MessageParseType` specifying which message\n            items should be parsed by target client (making preview, snippets, etc.). Specify empty iterable to avoid\n            parsing message at target client. By default all types are included.\n        :param update_msg_id: Message ID to update.\n        :param wrap_length: Maximum length of symbols in one message. Text exceeding this length will be sent in several\n            messages.\n\n        :return: Tuple of HTTP responses.\n        \"\"\"\n        try:\n            responses = set()\n            for text in wrap(string=str(message), length=wrap_length):\n                response = self.http_session.post(\n                    url=\"{}/im/sendIM\".format(self.api_base_url),\n                    data={\n                        \"r\": uuid.uuid4(),\n                        \"aimsid\": self.token,\n                        \"t\": target,\n                        \"message\": text,\n                        \"mentions\": (\n                            mentions if isinstance(mentions, six.string_types) or not hasattr(mentions, \"__iter__\")\n                            else \",\".join(mentions)\n                        ),\n                        \"parse\": json.dumps([p.value for p in parse]) if parse is not None else None,\n                        \"updateMsgId\": update_msg_id\n                    },\n                    timeout=self.timeout_s\n                )\n\n                try:\n                    self.__sent_im_cache[response.json()[\"response\"][\"data\"][\"msgId\"]] = text\n                except (LookupError, TypeError):\n                    self.log.exception(\"Error while getting 'msgId'!\")\n\n                responses.add(response)\n            return tuple(responses)\n        except ReadTimeout:\n            self.log.exception(\"Timeout while sending request!\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef random_choice(sequence):\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "response": "Same as random. choice but supports set type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render_markdown(text, context=None):\n    if context is None or not isinstance(context, dict):\n        context = {}\n    markdown_html = _transform_markdown_into_html(text)\n    sanitised_markdown_html = _sanitise_markdown_html(markdown_html)\n    return mark_safe(sanitised_markdown_html)", "response": "Render markdown into HTML."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndeprecate call to render_markdown.", "response": "def render(text, context=None):\n    \"\"\"\n    Depreceated call to render_markdown().\n    \"\"\"\n    warning = (\n        \"wagtailmarkdown.utils.render() is deprecated. Use \"\n        \"wagtailmarkdown.utils.render_markdown() instead.\"\n    )\n    warnings.warn(warning, WagtailMarkdownDeprecationWarning, stacklevel=2)\n    return render_markdown(text, context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a table block and build a table.", "response": "def run(self, parent, blocks):\r\n        \"\"\" Parse a table block and build table. \"\"\"\r\n        block = blocks.pop(0).split('\\n')\r\n        header = block[0].strip()\r\n        seperator = block[1].strip()\r\n        rows = block[2:]\r\n        # Get format type (bordered by pipes or not)\r\n        border = False\r\n        if header.startswith('|'):\r\n            border = True\r\n        # Get alignment of columns\r\n        align = []\r\n        for c in self._split_row(seperator, border):\r\n            if c.startswith(':') and c.endswith(':'):\r\n                align.append('center')\r\n            elif c.startswith(':'):\r\n                align.append('left')\r\n            elif c.endswith(':'):\r\n                align.append('right')\r\n            else:\r\n                align.append(None)\r\n        # Build table\r\n        table = etree.SubElement(parent, 'table')\r\n        table.set('class', 'wftable')\r\n        thead = etree.SubElement(table, 'thead')\r\n        self._build_row(header, thead, align, border)\r\n        tbody = etree.SubElement(table, 'tbody')\r\n        for row in rows:\r\n            self._build_row(row.strip(), tbody, align, border)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a row of text build table cells.", "response": "def _build_row(self, row, parent, align, border):\r\n        \"\"\" Given a row of text, build table cells. \"\"\"\r\n        tr = etree.SubElement(parent, 'tr')\r\n        tag = 'td'\r\n        if parent.tag == 'thead':\r\n            tag = 'th'\r\n        cells = self._split_row(row, border)\r\n        # We use align here rather than cells to ensure every row\r\n        # contains the same number of columns.\r\n        for i, a in enumerate(align):\r\n            c = etree.SubElement(tr, tag)\r\n            try:\r\n                c.text = cells[i].strip()\r\n            except IndexError:\r\n                c.text = \"\"\r\n            if a:\r\n                c.set('align', a)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _split_row(self, row, border):\r\n        if border:\r\n            if row.startswith('|'):\r\n                row = row[1:]\r\n            if row.endswith('|'):\r\n                row = row[:-1]\r\n        return row.split('|')", "response": "split a row of text into list of cells."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extendMarkdown(self, md, md_globals):\r\n        md.parser.blockprocessors.add('table',\r\n                                      TableProcessor(md.parser),\r\n                                      '<hashheader')", "response": "Add an instance of TableProcessor to BlockParser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all the static files directories found by STATICFILES_FINDERS", "response": "def get_all_static():\n    \"\"\"\n    Get all the static files directories found by ``STATICFILES_FINDERS``\n\n    :return: set of paths (top-level folders only)\n    \"\"\"\n    static_dirs = set()\n\n    for finder in settings.STATICFILES_FINDERS:\n        finder = finders.get_finder(finder)\n\n        if hasattr(finder, 'storages'):\n            for storage in finder.storages.values():\n                static_dirs.add(storage.location)\n\n        if hasattr(finder, 'storage'):\n            static_dirs.add(finder.storage.location)\n\n    return static_dirs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noutputting the content of the current command to a temporary file.", "response": "def input(self, **kwargs):\n        \"\"\"\n        Specify temporary input file extension.\n\n        Browserify requires explicit file extension (\".js\" or \".json\" by default).\n        https://github.com/substack/node-browserify/issues/1469\n        \"\"\"\n        if self.infile is None and \"{infile}\" in self.command:\n            if self.filename is None:\n                self.infile = NamedTemporaryFile(mode='wb', suffix=self.infile_ext)\n                self.infile.write(self.content.encode(self.default_encoding))\n                self.infile.flush()\n                self.options += (\n                    ('infile', self.infile.name),\n                )\n        return super(BaseCompiler, self).input(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef graph_hash(obj):\n    '''this hashes all types to a hash without colissions. python's hashing algorithms are not cross type compatable but hashing tuples with the type as the first element seems to do the trick'''\n    obj_type = type(obj)\n    try:\n        # this works for hashables\n        return hash((obj_type, obj))\n    except:\n        # this works for object containers since graphdb\n        # wants to identify different containers\n        # instead of the sum of their current internals\n        return hash((obj_type, id(obj)))", "response": "this hashes all types to a hash without colissions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_item(self, item):\n        ''' use this function to store a python object in the database '''\n        assert not isinstance(item, RamGraphDBNode)\n        item_hash = graph_hash(item)\n        if item_hash not in self.nodes:\n            self.nodes[item_hash] = RamGraphDBNode(item)\n        return self.nodes[item_hash]", "response": "store a python object in the database"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef store_relation(self, src, name, dst):\n        ''' use this to store a relation between two objects '''\n        self.__require_string__(name)\n        #print('storing relation', src, name, dst)\n        # make sure both items are stored\n        self.store_item(src).link(name, self.store_item(dst))", "response": "use this to store a relation between two objects"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a relation from a source or a target", "response": "def delete_relation(self, src, relation, target):\n        ''' can be both used as (src, relation, dest) for a single relation or\n            (src, relation) to delete all relations of that type from the src '''\n        self.__require_string__(relation)\n        if src in self and target in self:\n            self._get_item_node(src).unlink(relation, self._get_item_node(target))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_item(self, item):\n        ''' removes an item from the db '''\n        for relation, dst in self.relations_of(item, True):\n            self.delete_relation(item, relation, dst)\n            #print(item, relation, dst)\n        for src, relation in self.relations_to(item, True):\n            self.delete_relation(src, relation, item)\n            #print(src, relation, item)\n        h = self._item_hash(item)\n        if item in self:\n            #print('deleting item:', item)\n            self.nodes[h].clear()\n            del self.nodes[h]", "response": "removes an item from the db"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all relations the originate from target", "response": "def relations_of(self, target, include_object=False):\n        ''' list all relations the originate from target '''\n        relations = (target if isinstance(target, RamGraphDBNode) else self._get_item_node(target)).outgoing\n        if include_object:\n            for k in relations:\n                for v in relations[k]:\n                    if hasattr(v, 'obj'): # filter dead links\n                        yield k, v.obj\n        else:\n            yield from relations"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef relations_to(self, target, include_object=False):\n        ''' list all relations pointing at an object '''\n        relations = self._get_item_node(target).incoming\n        if include_object:\n            for k in relations:\n                for v in relations[k]:\n                    if hasattr(v, 'obj'): # filter dead links\n                        yield v.obj, k\n        else:\n            yield from relations", "response": "list all relations pointing at an object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_objects(self):\n        ''' display the entire of objects with their (id, value, node) '''\n        for key in self.nodes:\n            node = self.nodes[key]\n            value = node.obj\n            print(key, '-', repr(value), '-', node)", "response": "display the entire of objects with their id value node"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_relations(self):\n        ''' list every relation in the database as (src, relation, dst) '''\n        for node in self.iter_nodes():\n            for relation, target in self.relations_of(node.obj, True):\n                yield node.obj, relation, target", "response": "list every relation in the database as ( src relation dst )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying every relation in the database as ( src relation dst", "response": "def show_relations(self):\n        ''' display every relation in the database as (src, relation, dst) '''\n        for src_node in self.iter_nodes():\n            for relation in src_node.outgoing:\n                for dst_node in src_node.outgoing[relation]:\n                    print(repr(src_node.obj), '-', relation, '-', repr(dst_node.obj))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing this to filter VLists simply provide a filter function and what relation to apply it to", "response": "def where(self, relation, filter_fn):\n        ''' use this to filter VLists, simply provide a filter function and what relation to apply it to '''\n        assert type(relation).__name__ in {'str','unicode'}, 'where needs the first arg to be a string'\n        assert callable(filter_fn), 'filter_fn needs to be callable'\n        return VList(i for i in self if relation in i._relations() and any(filter_fn(_()) for _ in i[relation]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _where(self, filter_fn):\n        ''' use this to filter VLists, simply provide a filter function to filter the current found objects '''\n        assert callable(filter_fn), 'filter_fn needs to be callable'\n        return VList(i for i in self if filter_fn(i()))", "response": "use this to filter VLists simply provide a filter function that returns True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _where(self, **kwargs):\n        '''use this to filter VLists with kv pairs'''\n        out = self\n        for k,v in kwargs.items():\n            out = out.where(k, lambda i:i==v)\n        return out", "response": "use this to filter VLists with kv pairs"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a file at the given path and sets the permissions to read only read or write", "response": "def _create_file(path=''):\n        ''' creates a file at the given path and sets the permissions to user only read/write '''\n        from os.path import isfile\n        if not isfile(path): # only do the following if the file doesn't exist yet\n            from os import chmod\n            from stat import S_IRUSR, S_IWUSR\n\n            open(path, \"a\").close()  # create the file\n            attempt(lambda: chmod(path, (S_IRUSR | S_IWUSR)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_item(self, item):\n        ''' use this function to store a python object in the database '''\n        #print('storing item', item)\n        item_id = self._id_of(item)\n        #print('item_id', item_id)\n        if item_id is None:\n            #print('storing item', item)\n            blob = self.serialize(item)\n            with self._write_lock:\n                self._execute(\n                    'INSERT into objects (code) values (?);',\n                    (blob,)\n                )\n                self.autocommit()", "response": "store a python object in the database"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_item(self, item):\n        ''' removes an item from the db '''\n        for relation in self.relations_of(item):\n            self.delete_relation(item, relation)\n        for origin, relation in self.relations_to(item, True):\n            self.delete_relation(origin, relation, item)\n        with self._write_lock:\n            self._execute('''\n                DELETE from objects where code=?\n            ''', (self.serialize(item),))\n            self.autocommit()", "response": "Removes an item from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_relation(self, src, name, dst):\n        ''' use this to store a relation between two objects '''\n        self.__require_string__(name)\n        #print('storing relation', src, name, dst)\n        # make sure both items are stored\n        self.store_item(src)\n        self.store_item(dst)\n        with self._write_lock:\n            #print(locals())\n            # run the insertion\n            self._execute(\n                'insert into relations select ob1.id, ?, ob2.id from objects as ob1, objects as ob2 where ob1.code=? and ob2.code=?;',\n                (name, self.serialize(src), self.serialize(dst))\n            )\n            self.autocommit()", "response": "store a relation between two objects"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _delete_single_relation(self, src, relation, dst):\n        ''' deletes a single relation between objects '''\n        self.__require_string__(relation)\n        src_id = self._id_of(src)\n        dst_id = self._id_of(dst)\n        with self._write_lock:\n            self._execute('''\n                DELETE from relations where src=? and name=? and dst=?\n            ''', (src_id, relation, dst_id))\n            self.autocommit()", "response": "Deletes a single relation between objects src and dst."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_relation(self, src, relation, *targets):\n        ''' can be both used as (src, relation, dest) for a single relation or\n            (src, relation) to delete all relations of that type from the src '''\n        self.__require_string__(relation)\n        if len(targets):\n            for i in targets:\n                self._delete_single_relation(src, relation, i)\n        else:\n            # delete all connections of that relation from src\n            for i in list(self.find(src, relation)):\n                self._delete_single_relation(src, relation, i)", "response": "delete a single relation from a source"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn back all elements the target has a relation to", "response": "def find(self, target, relation):\n        ''' returns back all elements the target has a relation to '''\n        query = 'select ob1.code from objects as ob1, objects as ob2, relations where relations.dst=ob1.id and relations.name=? and relations.src=ob2.id and ob2.code=?' # src is id not source :/\n        for i in self._execute(query, (relation, self.serialize(target))):\n            yield self.deserialize(i[0])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all relations the originate from target", "response": "def relations_of(self, target, include_object=False):\n        ''' list all relations the originate from target '''\n        if include_object:\n            _ = self._execute('''\n                select relations.name, ob2.code from relations, objects as ob1, objects as ob2 where relations.src=ob1.id and ob2.id=relations.dst and ob1.code=?\n            ''', (self.serialize(target),))\n            for i in _:\n                yield i[0], self.deserialize(i[1])\n        else:\n\n            _ = self._execute('''\n                select distinct relations.name from relations, objects where relations.src=objects.id and objects.code=?\n            ''', (self.serialize(target),))\n            for i in _:\n                yield i[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef relations_to(self, target, include_object=False):\n        ''' list all relations pointing at an object '''\n        if include_object:\n            _ = self._execute('''\n                select name, (select code from objects where id=src) from relations where dst=?\n            ''', (self._id_of(target),))\n            for i in _:\n                yield self.deserialize(i[1]), i[0]\n        else:\n            _ = self._execute('''\n                select distinct name from relations where dst=?\n            ''', (self._id_of(target),))\n            for i in _:\n                yield i[0]", "response": "list all relations pointing at an object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates tuples containing relation object_that_applies", "response": "def connections_of(self, target):\n        ''' generate tuples containing (relation, object_that_applies) '''\n        return gen.chain( ((r,i) for i in self.find(target,r)) for r in self.relations_of(target) )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist the entire of objects with their id serialized_form actual_value", "response": "def list_objects(self):\n        ''' list the entire of objects with their (id, serialized_form, actual_value) '''\n        for i in self._execute('select * from objects'):\n            _id, code = i\n            yield _id, code, self.deserialize(code)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists every relation in the database as ( src name dst )", "response": "def list_relations(self):\n        ''' list every relation in the database as (src, relation, dst) '''\n        _ = self._execute('select * from relations').fetchall()\n        for i in _:\n            #print(i)\n            src, name, dst = i\n            src = self.deserialize(\n                next(self._execute('select code from objects where id=?',(src,)))[0]\n            )\n            dst = self.deserialize(\n                next(self._execute('select code from objects where id=?',(dst,)))[0]\n            )\n            yield src, name, dst"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating changes between tables and foreign keys.", "response": "def calc_changes(db, ignore_tables=None):\n  migrator = None # expose eventually?\n  if migrator is None:\n    migrator = auto_detect_migrator(db)\n\n  existing_tables = [unicode(t) for t in db.get_tables()]\n  existing_indexes = {table:get_indexes_by_table(db, table) for table in existing_tables}\n  existing_columns_by_table = get_columns_by_table(db)\n  foreign_keys_by_table = get_foreign_keys_by_table(db)\n\n  table_names_to_models = {_table_name(cls): cls for cls in all_models.keys()}\n\n  to_run = []\n\n  table_adds, add_fks, table_deletes, table_renames = calc_table_changes(existing_tables, ignore_tables=ignore_tables)\n  table_renamed_from = {v: k for k, v in table_renames.items()}\n  for tbl in table_adds:\n    to_run += create_table(table_names_to_models[tbl])\n  for field in add_fks:\n    if hasattr(field, '__pwdbev__not_deferred') and field.__pwdbev__not_deferred:\n      field.deferred = False\n    to_run += create_foreign_key(field)\n  for k, v in table_renames.items():\n    to_run += rename_table(migrator, k, v)\n\n\n  rename_cols_by_table = {}\n  deleted_cols_by_table = {}\n  for etn, ecols in existing_columns_by_table.items():\n    if etn in table_deletes: continue\n    ntn = table_renames.get(etn, etn)\n    model = table_names_to_models.get(ntn)\n    if not model: continue\n    defined_fields = model._meta.sorted_fields\n    defined_column_name_to_field = {unicode(_column_name(f)):f for f in defined_fields}\n    existing_fks_by_column = {fk.column:fk for fk in foreign_keys_by_table[etn]}\n    adds, deletes, renames, alter_statements = calc_column_changes(db, migrator, etn, ntn, ecols, defined_fields, existing_fks_by_column)\n    for column_name in adds:\n      field = defined_column_name_to_field[column_name]\n      to_run += alter_add_column(db, migrator, ntn, column_name, field)\n      if not field.null:\n        # alter_add_column strips null constraints\n        # add them back after setting any defaults\n        if field.default is not None:\n          to_run += set_default(db, migrator, ntn, column_name, field)\n        else:\n          to_run.append(('-- adding a not null column without a default will fail if the table is not empty',[]))\n        to_run += add_not_null(db, migrator, ntn, column_name, field)\n\n    for column_name in deletes:\n      fk = existing_fks_by_column.get(column_name)\n      if fk:\n        to_run += drop_foreign_key(db, migrator, ntn, fk.name)\n      to_run += drop_column(db, migrator, ntn, column_name)\n    for ocn, ncn in renames.items():\n      field = defined_column_name_to_field[ncn]\n      to_run += rename_column(db, migrator, ntn, ocn, ncn, field)\n    to_run += alter_statements\n    rename_cols_by_table[ntn] = renames\n    deleted_cols_by_table[ntn] = deletes\n\n  for ntn, model in table_names_to_models.items():\n    etn = table_renamed_from.get(ntn, ntn)\n    deletes = deleted_cols_by_table.get(ntn,set())\n    existing_indexes_for_table = [i for i in existing_indexes.get(etn, []) if not any([(c in deletes) for c in i.columns])]\n    to_run += calc_index_changes(db, migrator, existing_indexes_for_table, model, rename_cols_by_table.get(ntn, {}))\n\n  '''\n  to_run += calc_perms_changes($schema_tables, noop) unless $check_perms_for.empty?\n  '''\n  for tbl in table_deletes:\n    to_run += drop_table(migrator, tbl)\n  return to_run"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_keep_alive(self, sock, after_idle_sec=5, interval_sec=60,\n                       max_fails=5):\n        \"\"\"\n        This function instructs the TCP socket to send a heart beat every n\n        seconds to detect dead connections. It's the TCP equivalent of the\n        IRC ping-pong protocol and allows for better cleanup / detection\n        of dead TCP connections.\n\n        It activates after 1 second (after_idle_sec) of idleness, then sends\n        a keepalive ping once every 3 seconds(interval_sec), and closes the\n        connection after 5 failed ping (max_fails), or 15 seconds\n        \"\"\"\n\n        # OSX\n        if platform.system() == \"Darwin\":\n            # scraped from /usr/include, not exported by python's socket module\n            TCP_KEEPALIVE = 0x10\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n            sock.setsockopt(socket.IPPROTO_TCP, TCP_KEEPALIVE, interval_sec)\n\n        if platform.system() == \"Windows\":\n            sock.ioctl(socket.SIO_KEEPALIVE_VALS, (1, 10000, 3000))\n\n        if platform.system() == \"Linux\":\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE,\n                            after_idle_sec)\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL,\n                            interval_sec)\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, max_fails)", "response": "Sets the given socket to keep alive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the buffer and return a list of the reply entries.", "response": "def parse_buf(self, encoding=\"unicode\"):\n        \"\"\"\n        Since TCP is a stream-orientated protocol, responses aren't guaranteed\n        to be complete when they arrive. The buffer stores all the data and\n        this function splits the data into replies based on the new line\n        delimiter.\n        \"\"\"\n        buf_len = len(self.buf)\n        replies = []\n        reply = b\"\"\n        chop = 0\n        skip = 0\n        i = 0\n        buf_len = len(self.buf)\n        for i in range(0, buf_len):\n            ch = self.buf[i:i + 1]\n            if skip:\n                skip -= 1\n                i += 1\n                continue\n\n            nxt = i + 1\n            if nxt < buf_len:\n                if ch == b\"\\r\" and self.buf[nxt:nxt + 1] == b\"\\n\":\n\n                    # Append new reply.\n                    if reply != b\"\":\n                        if encoding == \"unicode\":\n                            replies.append(encode_str(reply, encoding))\n                        else:\n                            replies.append(reply)\n                        reply = b\"\"\n\n                    # Truncate the whole buf if chop is out of bounds.\n                    chop = nxt + 1\n                    skip = 1\n                    i += 1\n                    continue\n\n            reply += ch\n            i += 1\n\n        # Truncate buf.\n        if chop:\n            self.buf = self.buf[chop:]\n\n        return replies"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_node(self, node_ip, node_port=None, same_nodes=1):\r\n        self.debug_print(\"Validating: \" + node_ip)\r\n\r\n        # Is this a valid IP?\r\n        if not is_ip_valid(node_ip) or node_ip == \"0.0.0.0\":\r\n            self.debug_print(\"Invalid node ip in validate node\")\r\n            return 0\r\n\r\n        # Is this a valid port?\r\n        if node_port != 0 and node_port is not None:\r\n            if not is_valid_port(node_port):\r\n                self.debug_print(\"Invalid node port in validate port\")\r\n                return 0\r\n\r\n        \"\"\"\r\n        Don't accept connections from self to passive server\r\n        or connections to already connected nodes.\r\n        \"\"\"\r\n        if not self.enable_duplicate_ip_cons:\r\n            # Don't connect to ourself.\r\n            if (node_ip == \"127.0.0.1\" or\r\n                    node_ip == get_lan_ip(self.interface) or\r\n                    node_ip == self.wan_ip):\r\n                self.debug_print(\"Cannot connect to ourself.\")\r\n                return 0\r\n\r\n            # No, really: don't connect to ourself.\r\n            if node_ip == self.passive_bind and node_port == self.passive_port:\r\n                self.debug_print(\"Error connecting to same listen server.\")\r\n                return 0\r\n\r\n            # Don't connect to same nodes.\r\n            if same_nodes:\r\n                for node in self.outbound + self.inbound:\r\n                    try:\r\n                        addr, port = node[\"con\"].s.getpeername()\r\n                        if node_ip == addr:\r\n                            self.debug_print(\"Already connected to this node.\")\r\n                            return 0\r\n                    except Exception as e:\r\n                        print(e)\r\n                        return 0\r\n\r\n        return 1", "response": "Don't accept connections from self to passive server\r\n        or connections to already connected nodes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bootstrap(self):\r\n        # Disable bootstrap.\r\n        if not self.enable_bootstrap:\r\n            return None\r\n\r\n        # Avoid raping the rendezvous server.\r\n        t = time.time()\r\n        if self.last_bootstrap is not None:\r\n            if t - self.last_bootstrap <= rendezvous_interval:\r\n                self.debug_print(\"Bootstrapped recently\")\r\n                return None\r\n        self.last_bootstrap = t\r\n        self.debug_print(\"Searching for nodes to connect to.\")\r\n\r\n        try:\r\n            connection_slots = self.max_outbound - (len(self.outbound))\r\n            if connection_slots > 0:\r\n                # Connect to rendezvous server.\r\n                rendezvous_con = self.rendezvous.server_connect()\r\n\r\n                # Retrieve random nodes to bootstrap with.\r\n                rendezvous_con.send_line(\"BOOTSTRAP \" +\r\n                                         str(self.max_outbound * 2))\r\n                choices = rendezvous_con.recv_line(timeout=2)\r\n                if choices == \"NODES EMPTY\":\r\n                    rendezvous_con.close()\r\n                    self.debug_print(\"Node list is empty.\")\r\n                    return self\r\n                else:\r\n                    self.debug_print(\"Found node list.\")\r\n\r\n                # Parse node list.\r\n                choices = re.findall(\"(?:(p|s)[:]([0-9]+[.][0-9]+[.][0-9]+[.][0-9]+)[:]([0-9]+))+\\s?\", choices)\r\n                rendezvous_con.s.close()\r\n\r\n                # Attempt to make active simultaneous connections.\r\n                passive_nodes = []\r\n                for node in choices:\r\n                    # Out of connection slots.\r\n                    if not connection_slots:\r\n                        break\r\n\r\n                    # Add to list of passive nodes.\r\n                    node_type, node_ip, node_port = node\r\n                    self.debug_print(str(node))\r\n                    if node_type == \"p\":\r\n                        passive_nodes.append(node)\r\n\r\n                # Use passive to make up the remaining cons.\r\n                i = 0\r\n                while i < len(passive_nodes) and connection_slots > 0:\r\n                    node_type, node_ip, node_port = passive_nodes[i]\r\n                    con = self.add_node(node_ip, node_port, \"passive\")\r\n                    if con is not None:\r\n                        connection_slots -= 1\r\n                        self.debug_print(\"Con successful.\")\r\n                    else:\r\n                        self.debug_print(\"Con failed.\")\r\n\r\n                    i += 1\r\n\r\n        except Exception as e:\r\n            self.debug_print(\"Unknown error in bootstrap()\")\r\n            error = parse_exception(e)\r\n            log_exception(self.error_log_path, error)\r\n\r\n        return self", "response": "Returns a new instance of the most recent bootstrapped version of the nodes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining the type of node based on the node type and the node s information.", "response": "def determine_node(self):\r\n        \"\"\"\r\n        Determines the type of node based on a combination of forwarding\r\n        reachability and NAT type.\r\n        \"\"\"\r\n\r\n        # Manually set node_type as simultaneous.\r\n        if self.node_type == \"simultaneous\":\r\n            if self.nat_type != \"unknown\":\r\n                return \"simultaneous\"\r\n\r\n        # Get IP of binding interface.\r\n        unspecific_bind = [\"0.0.0.0\", \"127.0.0.1\", \"localhost\"]\r\n        if self.passive_bind in unspecific_bind:\r\n            lan_ip = get_lan_ip(self.interface)\r\n        else:\r\n            lan_ip = self.passive_bind\r\n\r\n        # Passive node checks.\r\n        if lan_ip is not None \\\r\n                and self.passive_port is not None and self.enable_forwarding:\r\n            self.debug_print(\"Checking if port is forwarded.\")\r\n\r\n            # Check port isn't already forwarded.\r\n            if is_port_forwarded(lan_ip, self.passive_port, \"TCP\",\r\n                                 self.forwarding_servers):\r\n                msg = \"Port already forwarded. Skipping NAT traversal.\"\r\n                self.debug_print(msg)\r\n\r\n                self.forwarding_type = \"forwarded\"\r\n                return \"passive\"\r\n            else:\r\n                self.debug_print(\"Port is not already forwarded.\")\r\n\r\n            # Most routers.\r\n            try:\r\n                self.debug_print(\"Trying UPnP\")\r\n\r\n                UPnP(self.interface).forward_port(\"TCP\", self.passive_port,\r\n                                                  lan_ip)\r\n\r\n                if is_port_forwarded(lan_ip, self.passive_port, \"TCP\",\r\n                                     self.forwarding_servers):\r\n                    self.forwarding_type = \"UPnP\"\r\n                    self.debug_print(\"Forwarded port with UPnP.\")\r\n                else:\r\n                    self.debug_print(\"UPnP failed to forward port.\")\r\n\r\n            except Exception as e:\r\n                # Log exception.\r\n                error = parse_exception(e)\r\n                log_exception(self.error_log_path, error)\r\n                self.debug_print(\"UPnP failed to forward port.\")\r\n\r\n                # Apple devices.\r\n                try:\r\n                    self.debug_print(\"Trying NATPMP.\")\r\n                    NatPMP(self.interface).forward_port(\"TCP\",\r\n                                                        self.passive_port,\r\n                                                        lan_ip)\r\n                    if is_port_forwarded(lan_ip, self.passive_port, \"TCP\",\r\n                                         self.forwarding_servers):\r\n                        self.forwarding_type = \"NATPMP\"\r\n                        self.debug_print(\"Port forwarded with NATPMP.\")\r\n                    else:\r\n                        self.debug_print(\"Failed to forward port with NATPMP.\")\r\n                        self.debug_print(\"Falling back on TCP hole punching or\"\r\n                                         \" proxying.\")\r\n                except Exception as e:\r\n                    # Log exception\r\n                    error = parse_exception(e)\r\n                    log_exception(self.error_log_path, error)\r\n                    self.debug_print(\"Failed to forward port with NATPMP.\")\r\n\r\n            # Check it worked.\r\n            if self.forwarding_type != \"manual\":\r\n                return \"passive\"\r\n\r\n        # Fail-safe node types.\r\n        if self.nat_type != \"unknown\":\r\n            return \"simultaneous\"\r\n        else:\r\n            return \"active\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self):\r\n\r\n        self.debug_print(\"Starting networking.\")\r\n        self.debug_print(\"Make sure to iterate over replies if you need\"\r\n                         \" connection alive management!\")\r\n\r\n        # Register a cnt + c handler\r\n        signal.signal(signal.SIGINT, self.stop)\r\n\r\n        # Save WAN IP.\r\n        self.debug_print(\"WAN IP = \" + str(self.wan_ip))\r\n\r\n        # Check rendezvous server is up.\r\n        try:\r\n            rendezvous_con = self.rendezvous.server_connect()\r\n            rendezvous_con.close()\r\n        except:\r\n            raise Exception(\"Unable to connect to rendezvous server.\")\r\n\r\n        # Started no matter what\r\n        # since LAN connections are always possible.\r\n        self.start_passive_server()\r\n\r\n        # Determine NAT type.\r\n        if self.nat_type == \"unknown\":\r\n            self.debug_print(\"Determining NAT type.\")\r\n            nat_type = self.rendezvous.determine_nat()\r\n            if nat_type is not None and nat_type != \"unknown\":\r\n                self.nat_type = nat_type\r\n                self.rendezvous.nat_type = nat_type\r\n                self.debug_print(\"NAT type = \" + nat_type)\r\n            else:\r\n                self.debug_print(\"Unable to determine NAT type.\")\r\n\r\n        # Check NAT type if node is simultaneous\r\n        # is manually specified.\r\n        if self.node_type == \"simultaneous\":\r\n            if self.nat_type not in self.rendezvous.predictable_nats:\r\n                self.debug_print(\"Manual setting of simultanous specified but\"\r\n                                 \" ignored since NAT does not support it.\")\r\n                self.node_type = \"active\"\r\n        else:\r\n            # Determine node type.\r\n            self.debug_print(\"Determining node type.\")\r\n\r\n            # No checks for manually specifying passive\r\n            # (there probably should be.)\r\n            if self.node_type == \"unknown\":\r\n                self.node_type = self.determine_node()\r\n\r\n        # Prevent P2P nodes from running as simultaneous.\r\n        if self.net_type == \"p2p\":\r\n            \"\"\"\r\n            TCP hole punching is reserved specifically for direct networks\r\n            (a net object reserved for receiving direct connections\r\n            -- p2p is for connecting to the main network. The reason for this\r\n            is you can't do multiple TCP hole punches at the same time so\r\n            reserved for direct network where it's most needed.\r\n            \"\"\"\r\n            if self.node_type == \"simultaneous\":\r\n                self.debug_print(\"Simultaneous is not allowed for P2P\")\r\n                self.node_type = \"active\"\r\n                self.disable_simultaneous()\r\n\r\n        self.debug_print(\"Node type = \" + self.node_type)\r\n\r\n        # Close stray cons from determine_node() tests.\r\n        self.close_cons()\r\n\r\n        # Set net started status.\r\n        self.is_net_started = 1\r\n\r\n        # Initialise our UNL details.\r\n        self.unl = UNL(\r\n            net=self,\r\n            dht_node=self.dht_node,\r\n            wan_ip=self.wan_ip\r\n        )\r\n\r\n        # Nestled calls.\r\n        return self", "response": "This function determines node and NAT type, saves connectivity details,\r\n        and starts any needed servers to be a part of the network. This is\r\n        usually the first function called after initialising the Net class."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops the networking process.", "response": "def stop(self, signum=None, frame=None):\r\n        self.debug_print(\"Stopping networking.\")\r\n\r\n        if self.passive is not None:\r\n            try:\r\n                self.passive.shutdown(1)\r\n            except:\r\n                pass\r\n            self.passive.close()\r\n            self.passive = None\r\n\r\n        if self.last_advertise is not None:\r\n            self.rendezvous.leave_fight()\r\n\r\n        \"\"\"\r\n        Just let the threads timeout by themselves.\r\n        Otherwise mutex deadlocks could occur.\r\n        for unl_thread in self.unl.unl_threads:\r\n            unl_thread.exit()\r\n        \"\"\"\r\n\r\n        for con in self:\r\n            con.close()\r\n\r\n        if signum is not None:\r\n            raise Exception(\"Process was interrupted.\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_remote_port(self):\r\n        msg = \"REMOTE TCP %s\" % (str(self.transport.getPeer().port))\r\n        self.send_line(msg)", "response": "Sends the remote port mapped for the connection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving old TCP hole punching candidates for a certain node.", "response": "def cleanup_candidates(self, node_ip):\r\n        \"\"\"\r\n        Removes old TCP hole punching candidates for a\r\n        designated node if a certain amount of time has passed\r\n        since they last connected.\r\n        \"\"\"\r\n        if node_ip in self.factory.candidates:\r\n            old_candidates = []\r\n            for candidate in self.factory.candidates[node_ip]:\r\n                elapsed = int(time.time() - candidate[\"time\"])\r\n                if elapsed > self.challege_timeout:\r\n                    old_candidates.append(candidate)\r\n\r\n            for candidate in old_candidates:\r\n                self.factory.candidates[node_ip].remove(candidate)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse to progate new candidates to passive simultaneous nodes.", "response": "def propogate_candidates(self, node_ip):\r\n        \"\"\"\r\n        Used to progate new candidates to passive simultaneous\r\n        nodes.\r\n        \"\"\"\r\n\r\n        if node_ip in self.factory.candidates:\r\n            old_candidates = []\r\n            for candidate in self.factory.candidates[node_ip]:\r\n                # Not connected.\r\n                if not candidate[\"con\"].connected:\r\n                    continue\r\n\r\n                # Already sent -- updated when they accept this challenge.\r\n                if candidate[\"propogated\"]:\r\n                    continue\r\n\r\n                # Notify node of challege from client.\r\n                msg = \"CHALLENGE %s %s %s\" % (\r\n                    candidate[\"ip_addr\"],\r\n                    \" \".join(map(str, candidate[\"predictions\"])),\r\n                    candidate[\"proto\"])\r\n\r\n                self.factory.nodes[\"simultaneous\"][node_ip][\"con\"].\\\r\n                    send_line(msg)\r\n                old_candidates.append(candidate)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling when the connection to the remote node has been lost.", "response": "def connectionLost(self, reason):\r\n        \"\"\"\r\n        Mostly handles clean-up of node + candidate structures.\r\n        Avoids memory exhaustion for a large number of connections.\r\n        \"\"\"\r\n        try:\r\n            self.connected = False\r\n            if debug:\r\n                print(self.log_entry(\"CLOSED =\", \"none\"))\r\n\r\n            # Every five minutes: cleanup\r\n            t = time.time()\r\n            if time.time() - self.factory.last_cleanup >= self.cleanup:\r\n                self.factory.last_cleanup = t\r\n\r\n                # Delete old passive nodes.\r\n                old_node_ips = []\r\n                for node_ip in list(self.factory.nodes[\"passive\"]):\r\n                    passive_node = self.factory.nodes[\"passive\"][node_ip]\r\n                    # Gives enough time for passive nodes to receive clients.\r\n                    if t - passive_node[\"time\"] >= self.node_lifetime:\r\n                        old_node_ips.append(node_ip)\r\n                for node_ip in old_node_ips:\r\n                    del self.factory.nodes[\"passive\"][node_ip]\r\n\r\n                # Delete old simultaneous nodes.\r\n                old_node_ips = []\r\n                for node_ip in list(self.factory.nodes[\"simultaneous\"]):\r\n                    simultaneous_node =\\\r\n                        self.factory.nodes[\"simultaneous\"][node_ip]\r\n                    # Gives enough time for passive nodes to receive clients.\r\n                    if t - simultaneous_node[\"time\"] >= self.node_lifetime:\r\n                        old_node_ips.append(node_ip)\r\n                for node_ip in old_node_ips:\r\n                    del self.factory.nodes[\"simultaneous\"][node_ip]\r\n\r\n                # Delete old candidates and candidate structs.\r\n                old_node_ips = []\r\n                for node_ip in list(self.factory.candidates):\r\n                    # Record old candidates.\r\n                    old_candidates = []\r\n                    for candidate in self.factory.candidates[node_ip]:\r\n                        # Hole punching is ms time sensitive.\r\n                        # Candidates older than this is safe to assume\r\n                        # they're not needed.\r\n                        if node_ip not in self.factory.nodes[\"simultaneous\"] \\\r\n                                and t - candidate[\"time\"] >= self.challenge_timeout * 5:\r\n                            old_candidates.append(candidate)\r\n\r\n                    # Remove old candidates.\r\n                    for candidate in old_candidates:\r\n                        self.factory.candidates[node_ip].remove(candidate)\r\n\r\n                    # Record old node IPs.\r\n                    if not len(self.factory.candidates[node_ip]) and \\\r\n                            node_ip not in self.factory.nodes[\"simultaneous\"]:\r\n                        old_node_ips.append(node_ip)\r\n\r\n                # Remove old node IPs.\r\n                for node_ip in old_node_ips:\r\n                    del self.factory.candidates[node_ip]\r\n        except Exception as e:\r\n            error = parse_exception(e)\r\n            log_exception(error_log_path, error)\r\n            print(self.log_entry(\"ERROR =\", error))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch(self, server):\r\n        t = None\r\n        socket_default_timeout = socket.getdefaulttimeout()\r\n        opener = urllib.build_opener()\r\n        opener.addheaders = [('User-agent',\r\n                              \"Mozilla/5.0 (X11; Linux x86_64; rv:24.0)\"\r\n                              \" Gecko/20100101 Firefox/24.0\")]\r\n\r\n        try:\r\n            # Close url resource if fetching not finished within timeout.\r\n            t = Timer(self.timeout, self.handle_timeout, [self.url])\r\n            t.start()\r\n\r\n            # Open URL.\r\n            if version_info[0:2] == (2, 5):\r\n                # Support for Python 2.5.* using socket hack\r\n                # (Changes global socket timeout.)\r\n                socket.setdefaulttimeout(self.timeout)\r\n                self.url = opener.open(server)\r\n            else:\r\n                self.url = opener.open(server, timeout=self.timeout)\r\n    \r\n            # Read response.\r\n            content = self.url.read()\r\n\r\n            # Didn't want to import chardet. Prefered to stick to stdlib\r\n            if PY3K:\r\n                try:\r\n                    content = content.decode('UTF-8')\r\n                except UnicodeDecodeError:\r\n                    content = content.decode('ISO-8859-1')\r\n\r\n            p = '(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.('\r\n            p += '25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|['\r\n            p += '01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'\r\n            m = re.search(\r\n                p,\r\n                content)\r\n            myip = m.group(0)\r\n            if len(myip) > 0:\r\n                return myip\r\n            else:\r\n                return ''\r\n        except Exception as e:\r\n            print(e)\r\n            return ''\r\n        finally:\r\n            if self.url is not None:\r\n                self.url.close()\r\n                self.url = None\r\n            if t is not None:\r\n                t.cancel()\r\n\r\n            # Reset default socket timeout.\r\n            if socket.getdefaulttimeout() != socket_default_timeout:\r\n                socket.setdefaulttimeout(socket_default_timeout)", "response": "This function gets your IP from a specific server and returns the IP and the HTTP status code."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_handler(self, their_unl, events, force_master, hairpin, nonce):\r\n        # Figure out who should make the connection.\r\n        our_unl = self.value.encode(\"ascii\")\r\n        their_unl = their_unl.encode(\"ascii\")\r\n        master = self.is_master(their_unl)\r\n\r\n        \"\"\"\r\n        Master defines who connects if either side can. It's used to\r\n        eliminate having multiple connections with the same host.\r\n        \"\"\"\r\n        if force_master:\r\n            master = 1\r\n\r\n        # Deconstruct binary UNLs into dicts.\r\n        our_unl = self.deconstruct(our_unl)\r\n        their_unl = self.deconstruct(their_unl)\r\n\r\n        if our_unl is None:\r\n            raise Exception(\"Unable to deconstruct our UNL.\")\r\n\r\n        if their_unl is None:\r\n            raise Exception(\"Unable to deconstruct their UNL.\")\r\n\r\n        # This means the nodes are behind the same router.\r\n        if our_unl[\"wan_ip\"] == their_unl[\"wan_ip\"]:\r\n            # Connect to LAN IP.\r\n            our_unl[\"wan_ip\"] = our_unl[\"lan_ip\"]\r\n            their_unl[\"wan_ip\"] = their_unl[\"lan_ip\"]\r\n\r\n            # Already behind NAT so no forwarding needed.\r\n            if hairpin:\r\n                our_unl[\"node_type\"] = \"passive\"\r\n                their_unl[\"node_type\"] = \"passive\"\r\n\r\n        # Generate con ID.\r\n        if nonce != \"0\" * 64:\r\n            # Convert nonce to bytes.\r\n            if sys.version_info >= (3, 0, 0):\r\n                if type(nonce) == str:\r\n                    nonce.encode(\"ascii\")\r\n            else:\r\n                if type(nonce) == unicode:\r\n                    nonce = str(nonce)\r\n\r\n            # Check nonce length.\r\n            assert(len(nonce) == 64)\r\n\r\n            # Create con ID.\r\n            con_id = self.net.generate_con_id(\r\n                nonce,\r\n                our_unl[\"wan_ip\"],\r\n                their_unl[\"wan_ip\"]\r\n            )\r\n        else:\r\n            con_id = None\r\n\r\n        # Acquire mutex.\r\n        self.mutex.acquire()\r\n\r\n        # Wait for other UNLs to finish.\r\n        end_time = time.time()\r\n        end_time += len(self.pending_unls) * 60\r\n        self.debug_print(\"Waiting for other unls to finish\")\r\n        while their_unl in self.pending_unls and time.time() < end_time:\r\n            # This is an undifferentiated duplicate.\r\n            if events is None:\r\n                self.mutex.release()\r\n                return\r\n\r\n            time.sleep(1)\r\n\r\n        self.debug_print(\"Other unl finished\")\r\n\r\n        is_exception = 0\r\n        try:\r\n            # Wait for any other hole punches to finish.\r\n            if (their_unl[\"node_type\"] == \"simultaneous\" and\r\n                    our_unl[\"node_type\"] != \"passive\"):\r\n                self.pending_sim_open.append(their_unl[\"value\"])\r\n                end_time = time.time()\r\n                end_time += len(self.pending_unls) * 60\r\n                self.debug_print(\"wait for other hole punches to finish\")\r\n                while len(self.pending_sim_open) and time.time() < end_time:\r\n                    if self.pending_sim_open[0] == their_unl[\"value\"]:\r\n                        break\r\n\r\n                    time.sleep(1)\r\n\r\n                self.debug_print(\"other hole punches finished\")\r\n\r\n            # Set pending UNL.\r\n            self.pending_unls.append(their_unl)\r\n\r\n            # Release mutex.\r\n            self.mutex.release()\r\n\r\n            # Get connection.\r\n            con = self.get_connection(\r\n                our_unl,\r\n                their_unl,\r\n                master,\r\n                nonce,\r\n                force_master,\r\n                con_id\r\n            )\r\n        except Exception as e:\r\n            is_exception = 1\r\n            print(e)\r\n            print(\"EXCEPTION IN UNL.GET_CONNECTION\")\r\n            log_exception(\"error.log\", parse_exception(e))\r\n        finally:\r\n            # Release mutex.\r\n            if self.mutex.locked() and is_exception:\r\n                self.mutex.release()\r\n\r\n            # Undo pending connect state.\r\n            if their_unl in self.pending_unls:\r\n                self.pending_unls.remove(their_unl)\r\n\r\n            # Undo pending sim open.\r\n            if len(self.pending_sim_open):\r\n                if self.pending_sim_open[0] == their_unl[\"value\"]:\r\n                    self.pending_sim_open = self.pending_sim_open[1:]\r\n\r\n        # Only execute events if this function was called manually.\r\n        if events is not None:\r\n            # Success.\r\n            if con is not None:\r\n                if \"success\" in events:\r\n                    events[\"success\"](con)\r\n\r\n            # Failure.\r\n            if con is None:\r\n                if \"failure\" in events:\r\n                    events[\"failure\"](con)", "response": "Create a new connection to the given node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to the master and the events.", "response": "def connect(self, their_unl, events, force_master=1, hairpin=1,\r\n                nonce=\"0\" * 64):\r\n        \"\"\"\r\n        A new thread is spawned because many of the connection techniques\r\n        rely on sleep to determine connection outcome or to synchronise hole\r\n        punching techniques. If the sleep is in its own thread it won't\r\n        block main execution.\r\n        \"\"\"\r\n        parms = (their_unl, events, force_master, hairpin, nonce)\r\n        t = Thread(target=self.connect_handler, args=parms)\r\n        t.start()\r\n        self.unl_threads.append(t)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_clock_skew(self):\n        n = self.statx_n(self.data_points)\n\n        \"\"\"\n        Required to be able to compute the standard\n        deviation.\n        \"\"\"\n        if n < 1:\n            return Decimal(\"0\")\n\n        avg = self.statx_avg(self.data_points)\n        sdev = self.statx_sdev(self.data_points)\n\n        \"\"\"\n        Incrementally remove aberration points.\n        \"\"\"\n        for k in range(0, self.clean_steps):\n            \"\"\"\n            Remove aberration points: keep only\n            the sigma range around the average.\n            \"\"\"\n            min_val = avg - sdev\n            max_val = avg + sdev\n\n            cleaned_data_points = []\n            for i in range(0, n):\n                v = self.data_points[i]\n                if v < min_val or v > max_val:\n                    continue\n                cleaned_data_points.append(v)\n\n            self.data_points = cleaned_data_points[:]\n\n            \"\"\"\n            Recompute the new average using the\n            \"sound\" points we kept.\n            \"\"\"\n            n = self.statx_n(self.data_points)\n\n            \"\"\"\n            Not enough data to compute standard\n            deviation.\n            \"\"\"\n            if n < 2:\n                break\n\n            avg = self.statx_avg(self.data_points)\n            sdev = self.statx_sdev(self.data_points)\n\n            if sdev <= self.max_sdev or n < self.min_data:\n                break\n\n        \"\"\"\n        If standard deviation is too large still, we\n        cannot update our clock. Collect more points.\n\n        If we don't have a minimum amount of data,\n        don't attempt the update yet, continue collecting.\n        \"\"\"\n        if sdev > self.max_sdev or n < self.min_data:\n            return Decimal(\"0\")\n\n        return avg", "response": "Calculates the average and standard deviation of the current data points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attend_fight(self, mappings, node_ip, predictions, ntp):\r\n\r\n        # Bind listen server socket.\r\n        mappings = self.add_listen_sock(mappings)\r\n        log.debug(mappings)\r\n\r\n        # Walk to fight.\r\n        self.simultaneous_cons = []\r\n        predictions = predictions.split(\" \")\r\n        self.simultaneous_fight(mappings, node_ip, predictions, ntp)\r\n\r\n        # Return hole made in opponent.\r\n        if len(self.simultaneous_cons):\r\n            \"\"\"\r\n            There may be a problem here. I noticed that when these lines\r\n            were removed during testing that connections tended to\r\n            succeed more. There may be a lack of synchronization between\r\n            the timing for connections to succeed so that a close on\r\n            one side of the fight ends up ruining valid connections on\r\n            this side. Will need to test more.\r\n\r\n            Notes: the UNL synchronization code could actually fix\r\n            this (potential) problem as a cool unintended side-effect.\r\n            \"\"\"\r\n\r\n            # Close unneeded holes.\r\n            \"\"\"\r\n            for i in range(1, len(self.simultaneous_cons)):\r\n                try:\r\n                    print(\"Closing unneeded hole\")\r\n                    #self.simultaneous_cons[i].s.close()\r\n                except:\r\n                    pass\r\n            \"\"\"\r\n\r\n            try:\r\n                # Return open hole.\r\n                return self.simultaneous_cons[0]\r\n            except:\r\n                # Try accept a connection.\r\n                log.debug(\"No holes found\")\r\n                for mapping in mappings:\r\n                    # Check if there's a new con.\r\n                    s = mapping[\"listen\"]\r\n                    r, w, e = select.select(\r\n                        [s],\r\n                        [],\r\n                        [],\r\n                        0\r\n                    )\r\n\r\n                    # Find socket.\r\n                    for found_sock in r:\r\n                        # Not us.\r\n                        if found_sock != s:\r\n                            continue\r\n\r\n                        # Accept a new con from the listen queue.\r\n                        log.debug(\"Accept logic works!\")\r\n                        client, address = s.accept()\r\n                        con = Sock(blocking=0)\r\n                        con.set_sock(client)\r\n                        return con\r\n\r\n        return None", "response": "This function is used to make a new fight connection. It creates a listen socket and walks to the fight and returns the new connection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sequential_connect(self):\r\n\r\n        # Connect to rendezvous server.\r\n        try:\r\n            mappings = sequential_bind(self.mapping_no + 1, self.interface)\r\n            con = self.server_connect(mappings[0][\"sock\"])\r\n        except Exception as e:\r\n            log.debug(e)\r\n            log.debug(\"this err\")\r\n            return None\r\n\r\n        # First mapping is used to talk to server.\r\n        mappings.remove(mappings[0])\r\n\r\n        # Receive port mapping.\r\n        msg = \"SOURCE TCP %s\" % (str(mappings[0][\"source\"]))\r\n        con.send_line(msg)\r\n        reply = con.recv_line(timeout=2)\r\n        remote_port = self.parse_remote_port(reply)\r\n        if not remote_port:\r\n            return None\r\n\r\n        # Generate port predictions.\r\n        predictions = \"\"\r\n        if self.nat_type != \"random\":\r\n            mappings = self.predict_mappings(mappings)\r\n            for mapping in mappings:\r\n                predictions += str(mapping[\"remote\"]) + \" \"\r\n            predictions = predictions.rstrip()\r\n        else:\r\n            predictions = \"1337\"\r\n\r\n        return [con, mappings, predictions]", "response": "Returns a connection to the Rendezvous Server and returns a tuple of the connection mappings and predictions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef simultaneous_listen(self):\r\n\r\n        # Close socket.\r\n        if self.server_con is not None:\r\n            self.server_con.s.close()\r\n            self.server_con = None\r\n\r\n        # Reset predictions + mappings.\r\n        self.mappings = None\r\n        self.predictions = None\r\n\r\n        # Connect to rendezvous server.\r\n        parts = self.sequential_connect()\r\n        if parts is None:\r\n            return 0\r\n        con, mappings, predictions = parts\r\n        con.blocking = 0\r\n        con.timeout = 0\r\n        con.s.settimeout(0)\r\n        self.server_con = con\r\n        self.mappings = mappings\r\n        self.predictions = predictions\r\n\r\n        # Register simultaneous node with server.\r\n        msg = \"SIMULTANEOUS READY 0 0\"\r\n        ret = self.server_con.send_line(msg)\r\n        if not ret:\r\n            return 0\r\n        return 1", "response": "This function is called by passive simultaneous nodes who\r\n        wish to establish themself as such. It sets up a connection to the Rendezvous Server to monitor for new hole punching requests."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of mappings that are compatible with the current NAT type.", "response": "def predict_mappings(self, mappings):\r\n        \"\"\"\r\n        This function is used to predict the remote ports that a NAT\r\n        will map a local connection to. It requires the NAT type to\r\n        be determined before use. Current support for preserving and\r\n        delta type mapping behaviour.\r\n        \"\"\"\r\n        if self.nat_type not in self.predictable_nats:\r\n            msg = \"Can't predict mappings for non-predictable NAT type.\"\r\n            raise Exception(msg)\r\n\r\n        for mapping in mappings:\r\n            mapping[\"bound\"] = mapping[\"sock\"].getsockname()[1]\r\n\r\n            if self.nat_type == \"preserving\":\r\n                mapping[\"remote\"] = mapping[\"source\"]\r\n\r\n            if self.nat_type == \"delta\":\r\n                max_port = 65535\r\n                mapping[\"remote\"] = int(mapping[\"source\"]) + self.delta\r\n\r\n                # Overflow or underflow = wrap port around.\r\n                if mapping[\"remote\"] > max_port:\r\n                    mapping[\"remote\"] -= max_port\r\n                if mapping[\"remote\"] < 0:\r\n                    mapping[\"remote\"] = max_port - -mapping[\"remote\"]\r\n\r\n                # Unknown error.\r\n                if mapping[\"remote\"] < 1 or mapping[\"remote\"] > max_port:\r\n                    mapping[\"remote\"] = 1\r\n                mapping[\"remote\"] = str(mapping[\"remote\"])\r\n\r\n        return mappings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattempting to open a hole by TCP hole punching. This function is called by the simultaneous fight function and its the code that handles doing the actual hole punching / connecting.", "response": "def throw_punch(self, args, tries=1):\r\n        \"\"\"\r\n        Attempt to open a hole by TCP hole punching. This\r\n        function is called by the simultaneous fight function\r\n        and its the code that handles doing the actual hole\r\n        punching / connecting.\r\n        \"\"\"\r\n\r\n        # Parse arguments.\r\n        if len(args) != 3:\r\n            return 0\r\n        sock, node_ip, remote_port = args\r\n        if sock is None or node_ip is None or remote_port is None:\r\n            return 0\r\n\r\n        # Generous timeout.\r\n        con = Sock(blocking=1, interface=self.interface)\r\n        con.set_sock(sock)\r\n        local = 0\r\n        if is_ip_private(node_ip):\r\n            \"\"\"\r\n            When simulating nodes on the same computer a delay needs to be set\r\n            for the loop back interface to simulate the delays that occur over\r\n            a WAN link. This requirement may also be needed for nodes on a LAN.\r\n\r\n            sudo tc qdisc replace dev lo root handle 1:0 netem delay 0.5sec\r\n\r\n            Speculation: The simulation problem may be to do with CPU cores.\r\n            If the program is run on the same core then the connects will always\r\n            be out of sync. If that's the case -- tries will need to be set to\r\n            ~1000 which was what it was before. Perhaps a delay could be\r\n            simulated by sleeping for random periods if its a local connection?\r\n            That could help punch through at least once and then just set the\r\n            tries to >= 1000.\r\n            \"\"\"\r\n            tries = 20  # 20\r\n            local = 1\r\n\r\n        source_port = sock.getsockname()[1]\r\n        error = 0\r\n        log.debug(\"Throwing punch\")\r\n        for i in range(0, tries):\r\n            # Attempt to connect.\r\n            try:\r\n                con.connect(node_ip, remote_port)\r\n                log.debug(\"Sim open success!\")\r\n\r\n                # FATALITY.\r\n\r\n                # Atomic operation so mutex not required.\r\n                # Record hole made.\r\n                con.set_blocking(blocking=0, timeout=5)\r\n                self.simultaneous_cons.append(con)\r\n                return 1\r\n            except Exception as e:\r\n                # Punch was blocked, opponent is strong.\r\n                e = str(parse_exception(e))\r\n                log.debug(e)\r\n                error = 1\r\n                continue\r\n\r\n        if error:\r\n            sock.close()\r\n\r\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_remote_port(self, reply):\r\n\r\n        remote_port = re.findall(\"^REMOTE (TCP|UDP) ([0-9]+)$\", reply)\r\n        if not len(remote_port):\r\n            remote_port = 0\r\n        else:\r\n            remote_port = int(remote_port[0][1])\r\n            if remote_port < 1 or remote_port > 65535:\r\n                remote_port = 0\r\n        return remote_port", "response": "Parses a remote port from a Rendezvous Server s response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef determine_nat(self, return_instantly=1):\r\n        # Already set.\r\n        if self.nat_type != \"unknown\":\r\n            return self.nat_type\r\n        nat_type = \"random\"\r\n\r\n        # Check collision ration.\r\n        if self.port_collisions * 5 > self.nat_tests:\r\n            msg = \"Port collision number is too high compared to nat tests.\"\r\n            msg += \" Collisions must be in ratio 1 : 5 to avoid ambiguity\"\r\n            msg += \" in test results.\"\r\n            raise Exception(msg)\r\n\r\n        # Load mappings for reuse test.\r\n        \"\"\"\r\n        Notes: This reuse test needs to ideally be performed against\r\n        bootstrapping nodes on at least two different addresses and\r\n        ports to each other because there are NAT types which\r\n        allocate new mappings based on changes to these variables.\r\n        \"\"\"\r\n        def custom_server_con(port=None, servers=None):\r\n            # Get connection to rendezvous server with random\r\n            # source port specified\r\n            servers = servers or self.rendezvous_servers\r\n            con = None\r\n            while con is None:\r\n                try:\r\n                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n                    port = port or get_unused_port(None)\r\n                    sock.bind(('', port))\r\n                    source_port = sock.getsockname()[1]\r\n                    index = random.randrange(0, len(servers))\r\n                    log.debug(\"Trying index: \" + str(index))\r\n                    con = self.server_connect(sock, index, servers)\r\n                except:\r\n                    time.sleep(1)\r\n                    sock.close()\r\n\r\n            # Record which server we're connected to.\r\n            server = list(con.s.getpeername())[:]\r\n            server = {\r\n                \"addr\": server[0],\r\n                \"port\": server[1]\r\n            }\r\n\r\n            # Get the port mappings and instruct remote host to disconnect\r\n            # This gives them the timewait state (we also connect to another\r\n            # server anyway so as to avoid using the exact same con tuple.)\r\n            con.send_line(\"SOURCE TCP \" + str(source_port))\r\n            remote_port = con.recv_line(timeout=2)\r\n            remote_port = self.parse_remote_port(remote_port)\r\n            con.send_line(\"QUIT\")\r\n\r\n            return source_port, remote_port, server\r\n\r\n        log.debug(\"Starting initial mappings for preserving + reuse tests\")\r\n        mappings = []\r\n        for i in range(0, self.nat_tests):\r\n            src, remote, server = custom_server_con()\r\n            mappings.append({\r\n                \"source\": src,\r\n                \"remote\": int(remote),\r\n                \"server\": server\r\n            })\r\n        log.debug(mappings)\r\n        log.debug(len(mappings))\r\n        log.debug(self.nat_tests)\r\n        log.debug(\"Finished mappings\")\r\n\r\n        # Preserving test.\r\n        preserving = 0\r\n        for mapping in mappings:\r\n            if mapping[\"source\"] == mapping[\"remote\"]:\r\n                preserving += 1\r\n        if preserving >= (self.nat_tests - self.port_collisions):\r\n            nat_type = \"preserving\"\r\n            if return_instantly:\r\n                return nat_type\r\n\r\n        \"\"\"\r\n        # Test reuse.\r\n        log.debug(\"Testing reuse\")\r\n        reuse = 0\r\n        for mapping in mappings:\r\n            addr = (\"www.example.com\", 80)\r\n            servers = self.rendezvous_servers[:]\r\n            servers.remove(mapping[\"server\"])\r\n            log.debug(\"servers = \" + str(servers))\r\n            src, remote, junk = custom_server_con(mapping[\"source\"], servers)\r\n            if remote == mapping[\"remote\"]:\r\n                reuse += 1\r\n\r\n\r\n        # Check reuse results.\r\n        if reuse >= (self.nat_tests - self.port_collisions):\r\n            nat_type = \"reuse\"\r\n            if return_instantly:\r\n                return nat_type\r\n\r\n            # Load mappings for delta tests.\r\n            mappings = sequential_bind(self.nat_tests, self.interface)\r\n            for i in range(0, self.nat_tests):\r\n                con = self.server_connect(mappings[i][\"sock\"])\r\n                con.send_line(\"SOURCE TCP \" + str(mappings[i][\"source\"]))\r\n                remote_port = self.parse_remote_port(con.recv_line(timeout=2))\r\n                mappings[i][\"remote\"] = int(remote_port)\r\n                con.s.close()\r\n        \"\"\"\r\n\r\n        # Delta test.\r\n        delta_ret = self.delta_test(mappings)\r\n        if delta_ret[\"nat_type\"] != \"random\":\r\n            # Save delta value.\r\n            self.delta = delta_ret[\"delta\"]\r\n            nat_type = \"delta\"\r\n            if return_instantly:\r\n                return nat_type\r\n\r\n        return nat_type", "response": "Returns the next available NAT type and time - to - live mapping for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_unused_port(port=None):\n    if port is None or port < 1024 or port > 65535:\n        port = random.randint(1024, 65535)\n    assert(1024 <= port <= 65535)\n    while True:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            s.bind(('', port))  # Try to open port\n        except socket.error as e:\n            if e.errno in (98, 10048):  # 98, 10048 means address already bound\n                return get_unused_port(None)\n            raise e\n        s.close()\n        return port", "response": "Checks if port is already in use."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_lan_ip(interface=\"default\"):\n    if sys.version_info < (3, 0, 0):\n        if type(interface) == str:\n            interface = unicode(interface)\n    else:\n        if type(interface) == bytes:\n            interface = interface.decode(\"utf-8\")\n\n    # Get ID of interface that handles WAN stuff.\n    default_gateway = get_default_gateway(interface)\n    gateways = netifaces.gateways()\n    wan_id = None\n    if netifaces.AF_INET in gateways:\n        gw_list = gateways[netifaces.AF_INET]\n        for gw_info in gw_list:\n            if gw_info[0] == default_gateway:\n                wan_id = gw_info[1]\n                break\n\n    # Find LAN IP of interface for WAN stuff.\n    interfaces = netifaces.interfaces()\n    if wan_id in interfaces:\n        families = netifaces.ifaddresses(wan_id)\n        if netifaces.AF_INET in families:\n            if_info_list = families[netifaces.AF_INET]\n            for if_info in if_info_list:\n                if \"addr\" in if_info:\n                    return if_info[\"addr\"]\n\n    \"\"\"\n    Execution may reach here if the host is using\n    virtual interfaces on Linux and there are no gateways\n    which suggests the host is a VPS or server. In this\n    case\n    \"\"\"\n    if platform.system() == \"Linux\":\n        if ip is not None:\n            return ip.routes[\"8.8.8.8\"][\"prefsrc\"]\n\n    return None", "response": "Get the LAN IP of a given interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the n most recent IP in the n most recent ones.", "response": "def get_wan_ip(n=0):\n    \"\"\"\n    That IP module sucks. Occasionally it returns an IP address behind\n    cloudflare which probably happens when cloudflare tries to proxy your web\n    request because it thinks you're trying to DoS. It's better if we just run\n    our own infrastructure.\n    \"\"\"\n\n    if n == 2:\n        try:\n            ip = myip()\n            ip = extract_ip(ip)\n            if is_ip_valid(ip):\n                return ip\n        except Exception as e:\n            print(str(e))\n            return None\n\n    # Fail-safe: use centralized server for IP lookup.\n    from pyp2p.net import forwarding_servers\n    for forwarding_server in forwarding_servers:\n        url = \"http://\" + forwarding_server[\"addr\"] + \":\"\n        url += str(forwarding_server[\"port\"])\n        url += forwarding_server[\"url\"]\n        url += \"?action=get_wan_ip\"\n        try:\n            r = urlopen(url, timeout=5)\n            response = r.read().decode(\"utf-8\")\n            response = extract_ip(response)\n            if is_ip_valid(response):\n                return response\n        except Exception as e:\n            print(str(e))\n            continue\n\n    time.sleep(1)\n    return get_wan_ip(n + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_gateway_addr():\r\n    try:\r\n        import netifaces\r\n        return netifaces.gateways()[\"default\"][netifaces.AF_INET][0]\r\n    except ImportError:\r\n        shell_command = 'netstat -rn'\r\n        if os.name == \"posix\":\r\n            pattern = \\\r\n                re.compile('(?:default|0\\.0\\.0\\.0|::/0)\\s+([\\w\\.:]+)\\s+.*UG')\r\n        elif os.name == \"nt\":\r\n            if platform.version().startswith(\"6.1\"):\r\n                pattern = re.compile(\".*?0.0.0.0[ ]+0.0.0.0[ ]+(.*?)[ ]+?.*?\\n\")\r\n            else:\r\n                pattern = re.compile(\".*?Default Gateway:[ ]+(.*?)\\n\")\r\n        system_out = os.popen(shell_command, 'r').read()\r\n        if not system_out:\r\n            raise NATPMPNetworkError(NATPMP_GATEWAY_CANNOT_FIND,\r\n                                     error_str(NATPMP_GATEWAY_CANNOT_FIND))\r\n        match = pattern.search(system_out)\r\n        if not match:\r\n            raise NATPMPNetworkError(NATPMP_GATEWAY_CANNOT_FIND,\r\n                                     error_str(NATPMP_GATEWAY_CANNOT_FIND))\r\n        addr = match.groups()[0].strip()\r\n        return addr", "response": "Try to get the gateway address from the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a gateway address string and returns a non - blocking UDP socket to communicate with its NAT - PMP implementation on its NAT - PMP port.", "response": "def get_gateway_socket(gateway):\r\n    \"\"\"Takes a gateway address string and returns a non-blocking UDP\r\n       socket to communicate with its NAT-PMP implementation on\r\n       NATPMP_PORT.\r\n       \r\n       e.g. addr = get_gateway_socket('10.0.1.1')\r\n    \"\"\"\r\n    if not gateway:\r\n        raise NATPMPNetworkError(NATPMP_GATEWAY_NO_VALID_GATEWAY,\r\n                                 error_str(NATPMP_GATEWAY_NO_VALID_GATEWAY))\r\n    response_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n    response_socket.setblocking(0)\r\n    response_socket.connect((gateway, NATPMP_PORT))\r\n    return response_socket"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_public_address(gateway_ip=None, retry=9):\r\n    if gateway_ip is None:\r\n        gateway_ip = get_gateway_addr()\r\n    addr_request = PublicAddressRequest()\r\n    addr_response = send_request_with_retry(gateway_ip, addr_request,\r\n                                            response_data_class=\r\n                                            PublicAddressResponse,\r\n                                            retry=retry, response_size=12)\r\n    if addr_response.result != 0:\r\n        # sys.stderr.write(\"NAT-PMP error %d: %s\\n\" %\r\n        #                  (addr_response.result,\r\n        #                   error_str(addr_response.result)))\r\n        # sys.stderr.flush()\r\n        raise NATPMPResultError(addr_response.result,\r\n                                error_str(addr_response.result), addr_response)\r\n    addr = addr_response.ip\r\n    return addr", "response": "A high - level function that returns the public interface IP of the current host by querying the NAT - PMP compatible gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map_tcp_port(public_port, private_port, lifetime=3600, gateway_ip=None,\r\n                 retry=9, use_exception=True):\r\n    \"\"\"A high-level wrapper to map_port() that requests a mapping\r\n       for a public TCP port on the NAT to a private TCP port on this host.\r\n       Returns the complete response on success.\r\n       \r\n            public_port - the public port of the mapping requested\r\n            private_port - the private port of the mapping requested\r\n            lifetime - the duration of the mapping in seconds.\r\n                       Defaults to 3600, per specification.\r\n            gateway_ip - the IP to the NAT-PMP compatible gateway.\r\n                        Defaults to using auto-detection function\r\n                        get_gateway_addr()\r\n            retry - the number of times to retry the request if unsuccessful.\r\n                    Defaults to 9 as per specification.\r\n            use_exception - throw an exception if an error result is\r\n                           received from the gateway.  Defaults to True.\r\n    \"\"\"\r\n    return map_port(NATPMP_PROTOCOL_TCP, public_port, private_port, lifetime,\r\n                    gateway_ip=gateway_ip, retry=retry,\r\n                    use_exception=use_exception)", "response": "A high - level wrapper to create a new TCP port mapping."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map_udp_port(public_port, private_port, lifetime=3600, gateway_ip=None,\r\n                 retry=9, use_exception=True):\r\n    \"\"\"A high-level wrapper to map_port() that requests a mapping for\r\n       a public UDP port on the NAT to a private UDP port on this host.\r\n       Returns the complete response on success.\r\n       \r\n            public_port - the public port of the mapping requested\r\n            private_port - the private port of the mapping requested\r\n            lifetime - the duration of the mapping in seconds.\r\n                       Defaults to 3600, per specification.\r\n            gateway_ip - the IP to the NAT-PMP compatible gateway.\r\n                         Defaults to using auto-detection function\r\n                         get_gateway_addr()\r\n            retry - the number of times to retry the request if unsuccessful.\r\n                    Defaults to 9 as per specification.\r\n            use_exception - throw an exception if an error result is\r\n                            received from the gateway.  Defaults to True.\r\n    \"\"\"\r\n    return map_port(NATPMP_PROTOCOL_UDP, public_port, private_port, lifetime,\r\n                    gateway_ip=gateway_ip, retry=retry,\r\n                    use_exception=use_exception)", "response": "A high - level wrapper to map_port that returns a response for a mapping for a specific public UDP port on the NAT - PMP compatible gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef map_port(protocol, public_port, private_port, lifetime=3600,\r\n             gateway_ip=None, retry=9, use_exception=True):\r\n    \"\"\"A function to map public_port to private_port of protocol.\r\n       Returns the complete response on success.\r\n       \r\n            protocol - NATPMP_PROTOCOL_UDP or NATPMP_PROTOCOL_TCP\r\n            public_port - the public port of the mapping requested\r\n            private_port - the private port of the mapping requested\r\n            lifetime - the duration of the mapping in seconds.\r\n                       Defaults to 3600, per specification.\r\n            gateway_ip - the IP to the NAT-PMP compatible gateway.\r\n                         Defaults to using auto-detection function\r\n                         get_gateway_addr()\r\n            retry - the number of times to retry the request if unsuccessful.\r\n                    Defaults to 9 as per specification.\r\n            use_exception - throw an exception if an error result\r\n                            is received from the gateway.  Defaults to True.\r\n    \"\"\"\r\n    if protocol not in [NATPMP_PROTOCOL_UDP, NATPMP_PROTOCOL_TCP]:\r\n        raise ValueError(\"Must be either NATPMP_PROTOCOL_UDP or \"\r\n                         \"NATPMP_PROTOCOL_TCP\")\r\n    if gateway_ip is None:\r\n        gateway_ip = get_gateway_addr()\r\n    response = None\r\n    port_mapping_request = PortMapRequest(protocol, private_port,\r\n                                          public_port, lifetime)\r\n    port_mapping_response = \\\r\n        send_request_with_retry(gateway_ip, port_mapping_request,\r\n                                response_data_class=PortMapResponse,\r\n                                retry=retry)\r\n    if port_mapping_response.result != 0 and use_exception:\r\n        raise NATPMPResultError(port_mapping_response.result,\r\n                                error_str(port_mapping_response.result),\r\n                                port_mapping_response)\r\n    return port_mapping_response", "response": "A function to map a port of a protocol to a private port."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nforwards a port from one gateway to another.", "response": "def forward_port(self, proto, src_port, dest_ip, dest_port=None):\n        \"\"\"\n        Creates a new mapping for the default gateway to forward ports.\n        Source port is from the perspective of the original client.\n        For example, if a client tries to connect to us on port 80,\n        the source port is port 80. The destination port isn't\n        necessarily 80, however. We might wish to run our web server\n        on a different port so we can have the router forward requests\n        for port 80 to another port (what I call the destination port.)\n\n        If the destination port isn't specified, it defaults to the\n        source port. Proto is either TCP or UDP. Function returns None\n        on success, otherwise it raises an exception.\n        \"\"\"\n\n        proto = proto.upper()\n        valid_protos = [\"TCP\", \"UDP\"]\n        if proto not in valid_protos:\n            raise Exception(\"Invalid protocol for forwarding.\")\n\n        valid_ports = range(1, 65535)\n        if src_port not in valid_ports:\n            raise Exception(\"Invalid port for forwarding.\")\n\n        # Source port is forwarded to same destination port number.\n        if dest_port is None:\n            dest_port = src_port\n\n        # Use UPnP binary for forwarding on Windows.\n        if platform.system() == \"Windows\":\n            cmd = \"upnpc-static.exe -a %s %s %s %s\" % (get_lan_ip(),\n                                                       str(src_port),\n                                                       str(dest_port),\n                                                       proto)\n            out, err = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,\n                                        stderr=subprocess.PIPE).communicate()\n            if \"is not recognized\" in err:\n                raise Exception(\"Missing upnpc-static.exe\")\n            \n            return\n\n        # Find gateway address.\n        gateway_addr = self.find_gateway()\n        if gateway_addr is None:\n            raise Exception(\"Unable to find UPnP compatible gateway.\")\n\n        # Get control URL.\n        rhost = re.findall('([^/]+)', gateway_addr)\n        res = urlopen(gateway_addr, timeout=self.timeout).read().decode(\"utf-8\")\n        res = res.replace('\\r', '')\n        res = res.replace('\\n', '')\n        res = res.replace('\\t', '')\n        pres = res.split('<serviceId>urn:upnp-org:serviceId:WANIPConn1'\n                         '</serviceId>')\n        p2res = pres[1].split('</controlURL>')\n        p3res = p2res[0].split('<controlURL>')\n        ctrl = p3res[1]\n        rip = res.split('<presentationURL>')\n        rip1 = rip[1].split('</presentationURL>')\n        router_ip = rip1[0]\n\n        port_map_desc = \"PyP2P\"\n        msg = \\\n            '<?xml version=\"1.0\"?><s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"><s:Body><u:AddPortMapping xmlns:u=\"urn:schemas-upnp-org:service:WANIPConnection:1\"><NewRemoteHost></NewRemoteHost><NewExternalPort>' \\\n            + str(src_port) \\\n            + '</NewExternalPort><NewProtocol>' + str(proto) + '</NewProtocol><NewInternalPort>' \\\n            + str(dest_port) + '</NewInternalPort><NewInternalClient>' + str(dest_ip) \\\n            + '</NewInternalClient><NewEnabled>1</NewEnabled><NewPortMappingDescription>' + str(port_map_desc) + '</NewPortMappingDescription><NewLeaseDuration>0</NewLeaseDuration></u:AddPortMapping></s:Body></s:Envelope>'\n\n        # Attempt to add new port map.\n        x = 'http://' + rhost[1] + '/' + ctrl\n        if sys.version_info >= (3, 0, 0):\n            msg = bytes(msg, \"utf-8\")\n\n        req = Request('http://' + rhost[1] + '/' + ctrl, msg)\n        req.add_header('SOAPAction',\n                       '\"urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping\"'\n                       )\n        req.add_header('Content-type', 'application/xml')\n        res = urlopen(req, timeout=self.timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef next(self, *args):\n        self.initialize()\n        self.future = asyncio.Future(loop=self.loop)\n        self.handle = self.loop.call_at(self.get_next(), self.call_func, *args)\n        return self.future", "response": "Yield the next available entry in the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing croniter and related times", "response": "def initialize(self):\n        \"\"\"Initialize croniter and related times\"\"\"\n        if self.croniter is None:\n            self.time = time.time()\n            self.datetime = datetime.now(self.tz)\n            self.loop_time = self.loop.time()\n            self.croniter = croniter(self.spec, start_time=self.datetime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns next iteration time related to loop time", "response": "def get_next(self):\n        \"\"\"Return next iteration time related to loop time\"\"\"\n        return self.loop_time + (self.croniter.get_next(float) - self.time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call_next(self):\n        if self.handle is not None:\n            self.handle.cancel()\n        next_time = self.get_next()\n        self.handle = self.loop.call_at(next_time, self.call_next)\n        self.call_func()", "response": "Set next hop in the loop. Call task"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls the function in the event loop.", "response": "def call_func(self, *args, **kwargs):\n        \"\"\"Called. Take care of exceptions using gather\"\"\"\n        asyncio.gather(\n            self.cron(*args, **kwargs),\n            loop=self.loop, return_exceptions=True\n            ).add_done_callback(self.set_result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_result(self, result):\n        result = result.result()[0]\n        if self.future is not None:\n            if isinstance(result, Exception):\n                self.future.set_exception(result)\n            else:\n                self.future.set_result(result)\n            self.future = None\n        elif isinstance(result, Exception):\n            raise result", "response": "Set future s result if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timeparse(sval):\n    match = re.match(r'\\s*' + TIMEFORMAT + r'\\s*$', sval, re.I)\n    if not match or not match.group(0).strip():\n        return\n\n    mdict = match.groupdict()\n    return sum(\n        MULTIPLIERS[k] * cast(v) for (k, v) in mdict.items() if v is not None)", "response": "Parse a time expression returning it as a number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd():\n    '''Handler for command line invocation'''\n\n    # Try to handle any reasonable thing thrown at this.\n    # Consume '-f' and '-o' as input/output, allow '-' for stdin/stdout\n    # and treat any subsequent arguments as a space separated string to\n    # be titlecased (so it still works if people forget quotes)\n    parser = argparse.ArgumentParser()\n    in_group = parser.add_mutually_exclusive_group()\n    in_group.add_argument('string', nargs='*', default=[],\n            help='String to titlecase')\n    in_group.add_argument('-f', '--input-file',\n            help='File to read from to titlecase')\n    parser.add_argument('-o', '--output-file',\n            help='File to write titlecased output to)')\n\n    args = parser.parse_args()\n\n    if args.input_file is not None:\n        if args.input_file == '-':\n            ifile = sys.stdin\n        else:\n            ifile = open(args.input_file)\n    else:\n        ifile = sys.stdin\n\n    if args.output_file is not None:\n        if args.output_file == '-':\n            ofile = sys.stdout\n        else:\n            ofile = open(args.output_file, 'w')\n    else:\n        ofile = sys.stdout\n\n    if len(args.string) > 0:\n        in_string = ' '.join(args.string)\n    else:\n        with ifile:\n            in_string = ifile.read()\n\n    with ofile:\n        ofile.write(titlecase(in_string))", "response": "Handler for command line invocation"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_options(cls, parser: OptionManager) -> None:\n        parser.add_option(\n            '--eradicate-aggressive',\n            default=False,\n            help=(\n                'Enables aggressive mode for eradicate; '\n                'this may result in false positives'\n            ),\n            action='store_true',\n            type=None,\n        )", "response": "Add options to the given option parser instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self) -> Generator[Tuple[int, int, str, type], None, None]:\n        if self.filename != STDIN:\n            buffer = StringIO()\n            options = _Options(aggressive=self.options.eradicate_aggressive)\n            fix_file(self.filename, options, buffer)\n            traceback = buffer.getvalue()\n\n            if traceback:\n                yield 1, 0, self._error(traceback), type(self)", "response": "Runs the checker.\n\n        ``fix_file()`` only mutates the buffer object.\n        It is the only way to find out if some error happened."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding unique values yielded by g removing any duplicates.", "response": "def unique(g):\n    \"\"\"\n    Yield values yielded by ``g``, removing any duplicates.\n\n    Example\n    -------\n    >>> list(unique(iter([1, 3, 1, 2, 3])))\n    [1, 3, 2]\n    \"\"\"\n    yielded = set()\n    for value in g:\n        if value not in yielded:\n            yield value\n            yielded.add(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef static_get_type_attr(t, name):\n    for type_ in t.mro():\n        try:\n            return vars(type_)[name]\n        except KeyError:\n            pass\n    raise AttributeError(name)", "response": "Get a type attribute statically circumventing the descriptor protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat an error message for conflicting default implementations.", "response": "def _conflicting_defaults(typename, conflicts):\n    \"\"\"Format an error message for conflicting default implementations.\n\n    Parameters\n    ----------\n    typename : str\n        Name of the type for which we're producing an error.\n    conflicts : dict[str -> list[Interface]]\n        Map from strings to interfaces providing a default with that name.\n\n    Returns\n    -------\n    message : str\n        User-facing error message.\n    \"\"\"\n    message = \"\\nclass {C} received conflicting default implementations:\".format(\n        C=typename,\n    )\n    for attrname, interfaces in conflicts.items():\n        message += dedent(\n            \"\"\"\n\n            The following interfaces provided default implementations for {attr!r}:\n            {interfaces}\"\"\"\n        ).format(\n            attr=attrname,\n            interfaces=bulleted_list(sorted(map(getname, interfaces))),\n        )\n    return InvalidImplementation(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify(self, type_):\n        raw_missing, mistyped, mismatched = self._diff_signatures(type_)\n\n        # See if we have defaults for missing methods.\n        missing = []\n        defaults_to_use = {}\n        for name in raw_missing:\n            try:\n                defaults_to_use[name] = self._defaults[name].implementation\n            except KeyError:\n                missing.append(name)\n\n        if not any((missing, mistyped, mismatched)):\n            return defaults_to_use\n\n        raise self._invalid_implementation(type_, missing, mistyped, mismatched)", "response": "Verify that a type implements this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _invalid_implementation(self, t, missing, mistyped, mismatched):\n        assert missing or mistyped or mismatched, \"Implementation wasn't invalid.\"\n\n        message = \"\\nclass {C} failed to implement interface {I}:\".format(\n            C=getname(t),\n            I=getname(self),\n        )\n        if missing:\n            message += dedent(\n                \"\"\"\n\n                The following methods of {I} were not implemented:\n                {missing_methods}\"\"\"\n            ).format(\n                I=getname(self),\n                missing_methods=self._format_missing_methods(missing)\n            )\n\n        if mistyped:\n            message += dedent(\n                \"\"\"\n\n                The following methods of {I} were implemented with incorrect types:\n                {mismatched_types}\"\"\"\n            ).format(\n                I=getname(self),\n                mismatched_types=self._format_mismatched_types(mistyped),\n            )\n\n        if mismatched:\n            message += dedent(\n                \"\"\"\n\n                The following methods of {I} were implemented with invalid signatures:\n                {mismatched_methods}\"\"\"\n            ).format(\n                I=getname(self),\n                mismatched_methods=self._format_mismatched_methods(mismatched),\n            )\n        return InvalidImplementation(message)", "response": "Make a TypeError explaining why t doesn t implement our interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an interface from an existing class.", "response": "def from_class(cls, existing_class, subset=None, name=None):\n        \"\"\"Create an interface from an existing class.\n\n        Parameters\n        ----------\n        existing_class : type\n            The type from which to extract an interface.\n        subset : list[str], optional\n            List of methods that should be included in the interface.\n            Default is to use all attributes not defined in an empty class.\n        name : str, optional\n            Name of the generated interface.\n            Default is ``existing_class.__name__ + 'Interface'``.\n\n        Returns\n        -------\n        interface : type\n            A new interface class with stubs generated from ``existing_class``.\n        \"\"\"\n        if name is None:\n            name = existing_class.__name__ + 'Interface'\n\n        if subset is None:\n            subset = set(dir(existing_class)) - TRIVIAL_CLASS_ATTRIBUTES\n\n        return InterfaceMeta(\n            name,\n            (Interface,),\n            {name: static_get_type_attr(existing_class, name) for name in subset},\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compatible(impl_sig, iface_sig):\n    return all([\n        positionals_compatible(\n            takewhile(is_positional, impl_sig.parameters.values()),\n            takewhile(is_positional, iface_sig.parameters.values()),\n        ),\n        keywords_compatible(\n            valfilter(complement(is_positional), impl_sig.parameters),\n            valfilter(complement(is_positional), iface_sig.parameters),\n        ),\n    ])", "response": "Check whether impl_sig is compatible with iface_sig."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef aggregate_group_loop(*args, **kwargs):\n    func = kwargs['func']\n    del kwargs['func']\n    return aggregate_np(*args, func=lambda x: func(x), **kwargs)", "response": "wraps func in lambda which prevents aggregate_numpy from recognising and optimising it. Instead it groups and loops."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step_count(group_idx):\n    cmp_pos = 0\n    steps = 1\n    if len(group_idx) < 1:\n        return 0\n    for i in range(len(group_idx)):\n        if group_idx[cmp_pos] != group_idx[i]:\n            cmp_pos = i\n            steps += 1\n    return steps", "response": "Return the amount of index changes within group_idx."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step_indices(group_idx):\n    ilen = step_count(group_idx) + 1\n    indices = np.empty(ilen, np.int64)\n    indices[0] = 0\n    indices[-1] = group_idx.size\n    cmp_pos = 0\n    ri = 1\n    for i in range(len(group_idx)):\n        if group_idx[cmp_pos] != group_idx[i]:\n            cmp_pos = i\n            indices[ri] = i\n            ri += 1\n    return indices", "response": "Return the edges of areas within group_idx which are filled with the same value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef callable(cls, nans=False, reverse=False, scalar=False):\n        _valgetter = cls._valgetter_scalar if scalar else cls._valgetter\n        valgetter = nb.njit(_valgetter)\n        outersetter = nb.njit(cls._outersetter)\n\n        _cls_inner = nb.njit(cls._inner)\n        if nans:\n            def _inner(ri, val, ret, counter, mean):\n                if not np.isnan(val):\n                    _cls_inner(ri, val, ret, counter, mean)\n            inner = nb.njit(_inner)\n        else:\n            inner = _cls_inner\n\n        def _loop(group_idx, a, ret, counter, mean, outer, fill_value, ddof):\n            # fill_value and ddof need to be present for being exchangeable with loop_2pass\n            size = len(ret)\n            rng = range(len(group_idx) - 1, -1 , -1) if reverse else range(len(group_idx))\n            for i in rng:\n                ri = group_idx[i]\n                if ri < 0:\n                    raise ValueError(\"negative indices not supported\")\n                if ri >= size:\n                    raise ValueError(\"one or more indices in group_idx are too large\")\n                val = valgetter(a, i)\n                inner(ri, val, ret, counter, mean)\n                outersetter(outer, i, ret[ri])\n        return nb.njit(_loop, nogil=True)", "response": "Compile a jitted function for the class."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompile a jitted function and loop over the sorted data.", "response": "def callable(self, nans=False):\n        \"\"\"Compile a jitted function and loop it over the sorted data.\"\"\"\n        jitfunc = nb.njit(self.func, nogil=True)\n\n        def _loop(sortidx, group_idx, a, ret):\n            size = len(ret)\n            group_idx_srt = group_idx[sortidx]\n            a_srt = a[sortidx]\n\n            indices = step_indices(group_idx_srt)\n            for i in range(len(indices) - 1):\n                start_idx, stop_idx =  indices[i], indices[i + 1]\n                ri = group_idx_srt[start_idx]\n                if ri < 0:\n                    raise ValueError(\"negative indices not supported\")\n                if ri >= size:\n                    raise ValueError(\"one or more indices in group_idx are too large\")\n                ret[ri] = jitfunc(a_srt[start_idx:stop_idx])\n        return nb.njit(_loop, nogil=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_aliasing(*extra):\n    alias = dict((k, k) for k in funcs_common)\n    alias.update(_alias_str)\n    alias.update((fn, fn) for fn in _alias_builtin.values())\n    alias.update(_alias_builtin)\n    for d in extra:\n        alias.update(d)\n    alias.update((k, k) for k in set(alias.values()))\n    # Treat nan-functions as firstclass member and add them directly\n    for key in set(alias.values()):\n        if key not in funcs_no_separate_nan:\n            key = 'nan' + key\n            alias[key] = key\n    return alias", "response": "Returns the dict mapping strings and functions to the list of available functions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the key of a found implementation or the func itself", "response": "def get_func(func, aliasing, implementations):\n    \"\"\" Return the key of a found implementation or the func itself \"\"\"\n    try:\n        func_str = aliasing[func]\n    except KeyError:\n        if callable(func):\n            return func\n    else:\n        if func_str in implementations:\n            return func_str\n        if func_str.startswith('nan') and \\\n                func_str[3:] in funcs_no_separate_nan:\n            raise ValueError(\"%s does not have a nan-version\".format(func_str[3:]))\n        else:\n            raise NotImplementedError(\"No such function available\")\n    raise ValueError(\"func %s is neither a valid function string nor a \"\n                     \"callable object\".format(func))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef minimum_dtype(x, dtype=np.bool_):\n\n    def check_type(x, dtype):\n        try:\n            converted = dtype.type(x)\n        except (ValueError, OverflowError):\n            return False\n        # False if some overflow has happened\n        return converted == x or np.isnan(x)\n\n    def type_loop(x, dtype, dtype_dict, default=None):\n        while True:\n            try:\n                dtype = np.dtype(dtype_dict[dtype.name])\n                if check_type(x, dtype):\n                    return np.dtype(dtype)\n            except KeyError:\n                if default is not None:\n                    return np.dtype(default)\n                raise ValueError(\"Can not determine dtype of %r\" % x)\n\n    dtype = np.dtype(dtype)\n    if check_type(x, dtype):\n        return dtype\n\n    if np.issubdtype(dtype, np.inexact):\n        return type_loop(x, dtype, _next_float_dtype)\n    else:\n        return type_loop(x, dtype, _next_int_dtype, default=np.float32)", "response": "returns the most basic dtype which represents x properly which is the same value range as the specified dtype."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform basic input validation on the group_idx and a.", "response": "def input_validation(group_idx, a, size=None, order='C', axis=None,\n                     ravel_group_idx=True, check_bounds=True):\n    \"\"\" Do some fairly extensive checking of group_idx and a, trying to\n    give the user as much help as possible with what is wrong. Also,\n    convert ndim-indexing to 1d indexing.\n    \"\"\"\n    if not isinstance(a, (int, float, complex)):\n        a = np.asanyarray(a)\n    group_idx = np.asanyarray(group_idx)\n\n    if not np.issubdtype(group_idx.dtype, np.integer):\n        raise TypeError(\"group_idx must be of integer type\")\n\n    # This check works for multidimensional indexing as well\n    if check_bounds and np.any(group_idx < 0):\n        raise ValueError(\"negative indices not supported\")\n\n    ndim_idx = np.ndim(group_idx)\n    ndim_a = np.ndim(a)\n\n    # Deal with the axis arg: if present, then turn 1d indexing into\n    # multi-dimensional indexing along the specified axis.\n    if axis is None:\n        if ndim_a > 1:\n            raise ValueError(\"a must be scalar or 1 dimensional, use .ravel to\"\n                             \" flatten. Alternatively specify axis.\")\n    elif axis >= ndim_a or axis < -ndim_a:\n        raise ValueError(\"axis arg too large for np.ndim(a)\")\n    else:\n        axis = axis if axis >= 0 else ndim_a + axis  # negative indexing\n        if ndim_idx > 1:\n            # TODO: we could support a sequence of axis values for multiple\n            # dimensions of group_idx.\n            raise NotImplementedError(\"only 1d indexing currently\"\n                                      \"supported with axis arg.\")\n        elif a.shape[axis] != len(group_idx):\n            raise ValueError(\"a.shape[axis] doesn't match length of group_idx.\")\n        elif size is not None and not np.isscalar(size):\n            raise NotImplementedError(\"when using axis arg, size must be\"\n                                      \"None or scalar.\")\n        else:\n            # Create the broadcast-ready multidimensional indexing.\n            # Note the user could do this themselves, so this is\n            # very much just a convenience.\n            size_in = np.max(group_idx) + 1 if size is None else size\n            group_idx_in = group_idx\n            group_idx = []\n            size = []\n            for ii, s in enumerate(a.shape):\n                ii_idx = group_idx_in if ii == axis else np.arange(s)\n                ii_shape = [1] * ndim_a\n                ii_shape[ii] = s\n                group_idx.append(ii_idx.reshape(ii_shape))\n                size.append(size_in if ii == axis else s)\n            # Use the indexing, and return. It's a bit simpler than\n            # using trying to keep all the logic below happy\n            group_idx = np.ravel_multi_index(group_idx, size, order=order,\n                                             mode='raise')\n            flat_size = np.prod(size)\n            ndim_idx = ndim_a\n            return group_idx.ravel(), a.ravel(), flat_size, ndim_idx, size\n\n    if ndim_idx == 1:\n        if size is None:\n            size = np.max(group_idx) + 1\n        else:\n            if not np.isscalar(size):\n                raise ValueError(\"output size must be scalar or None\")\n            if check_bounds and np.any(group_idx > size - 1):\n                raise ValueError(\"one or more indices are too large for \"\n                                 \"size %d\" % size)\n        flat_size = size\n    else:\n        if size is None:\n            size = np.max(group_idx, axis=1) + 1\n        elif np.isscalar(size):\n            raise ValueError(\"output size must be of length %d\"\n                             % len(group_idx))\n        elif len(size) != len(group_idx):\n            raise ValueError(\"%d sizes given, but %d output dimensions \"\n                             \"specified in index\" % (len(size),\n                                                     len(group_idx)))\n        if ravel_group_idx:\n            group_idx = np.ravel_multi_index(group_idx, size, order=order,\n                                             mode='raise')\n        flat_size = np.prod(size)\n\n    if not (np.ndim(a) == 0 or len(a) == group_idx.size):\n        raise ValueError(\"group_idx and a must be of the same length, or a\"\n                         \" can be scalar\")\n\n    return group_idx, a, flat_size, ndim_idx, size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multi_arange(n):\n    if n.ndim != 1:\n        raise ValueError(\"n is supposed to be 1d array.\")\n\n    n_mask = n.astype(bool)\n    n_cumsum = np.cumsum(n)\n    ret = np.ones(n_cumsum[-1] + 1, dtype=int)\n    ret[n_cumsum[n_mask]] -= n[n_mask]\n    ret[0] -= 1\n    return np.cumsum(ret)[:-1]", "response": "This function returns a 1d array that contains the range of n."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef label_contiguous_1d(X):\n\n    if X.ndim != 1:\n        raise ValueError(\"this is for 1d masks only.\")\n\n    is_start = np.empty(len(X), dtype=bool)\n    is_start[0] = X[0]  # True if X[0] is True or non-zero\n\n    if X.dtype.kind == 'b':\n        is_start[1:] = ~X[:-1] & X[1:]\n        M = X\n    else:\n        M = X.astype(bool)\n        is_start[1:] = X[:-1] != X[1:]\n        is_start[~M] = False\n\n    L = np.cumsum(is_start)\n    L[~M] = 0\n    return L", "response": "This function labels contiguous 1 - dimensional arrays X with a label."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrelabel unique groups in a node.", "response": "def relabel_groups_unique(group_idx):\n    \"\"\"\n    See also ``relabel_groups_masked``.\n    \n    keep_group:  [0 3 3 3 0 2 5 2 0 1 1 0 3 5 5]\n    ret:         [0 3 3 3 0 2 4 2 0 1 1 0 3 4 4]\n    \n    Description of above: unique groups in input was ``1,2,3,5``, i.e.\n    ``4`` was missing, so group 5 was relabled to be ``4``.\n    Relabeling maintains order, just \"compressing\" the higher numbers\n    to fill gaps.\n    \"\"\"\n\n    keep_group = np.zeros(np.max(group_idx) + 1, dtype=bool)\n    keep_group[0] = True\n    keep_group[group_idx] = True\n    return relabel_groups_masked(group_idx, keep_group)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrelabel groups in a group_idx array to be filled with gaps.", "response": "def relabel_groups_masked(group_idx, keep_group):\n    \"\"\"\n    group_idx: [0 3 3 3 0 2 5 2 0 1 1 0 3 5 5]\n   \n                 0 1 2 3 4 5\n    keep_group: [0 1 0 1 1 1]\n    \n    ret:       [0 2 2 2 0 0 4 0 0 1 1 0 2 4 4]\n    \n    Description of above in words: remove group 2, and relabel group 3,4, and 5\n    to be 2, 3 and 4 respecitvely, in order to fill the gap.  Note that group 4 was never used\n    in the input group_idx, but the user supplied mask said to keep group 4, so group\n    5 is only moved up by one place to fill the gap created by removing group 2.\n    \n    That is, the mask describes which groups to remove,\n    the remaining groups are relabled to remove the gaps created by the falsy\n    elements in ``keep_group``.  Note that ``keep_group[0]`` has no particular meaning because it refers\n    to the zero group which cannot be \"removed\".\n\n    ``keep_group`` should be bool and ``group_idx`` int.\n    Values in ``group_idx`` can be any order, and \n    \"\"\"\n\n    keep_group = keep_group.astype(bool, copy=not keep_group[0])\n    if not keep_group[0]:  # ensuring keep_group[0] is True makes life easier\n        keep_group[0] = True\n\n    relabel = np.zeros(keep_group.size, dtype=group_idx.dtype)\n    relabel[keep_group] = np.arange(np.count_nonzero(keep_group))\n    return relabel[group_idx]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _array(group_idx, a, size, fill_value, dtype=None):\n    if fill_value is not None and not (np.isscalar(fill_value) or\n                                       len(fill_value) == 0):\n        raise ValueError(\"fill_value must be None, a scalar or an empty \"\n                         \"sequence\")\n    order_group_idx = np.argsort(group_idx, kind='mergesort')\n    counts = np.bincount(group_idx, minlength=size)\n    ret = np.split(a[order_group_idx], np.cumsum(counts)[:-1])\n    ret = np.asanyarray(ret)\n    if fill_value is None or np.isscalar(fill_value):\n        _fill_untouched(group_idx, ret, fill_value)\n    return ret", "response": "groups a into separate arrays keeping the order intact."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _generic_callable(group_idx, a, size, fill_value, dtype=None,\n                      func=lambda g: g, **kwargs):\n    \"\"\"groups a by inds, and then applies foo to each group in turn, placing\n    the results in an array.\"\"\"\n    groups = _array(group_idx, a, size, ())\n    ret = np.full(size, fill_value, dtype=dtype or np.float64)\n\n    for i, grp in enumerate(groups):\n        if np.ndim(grp) == 1 and len(grp) > 0:\n            ret[i] = func(grp)\n    return ret", "response": "generic function for group_idx and apply func to each group in turn placing\n    the results in an array."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _fill_untouched(idx, ret, fill_value):\n    untouched = np.ones_like(ret, dtype=bool)\n    untouched[idx] = False\n    ret[untouched] = fill_value", "response": "fill_value is the value to fill_value in the elements of ret not indexed by idx."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aggregate_grouploop(*args, **kwargs):\n    extrafuncs = {'allnan': allnan, 'anynan': anynan,\n                  'first': itemgetter(0), 'last': itemgetter(-1),\n                  'nanfirst': nanfirst, 'nanlast': nanlast}\n    func = kwargs.pop('func')\n    func = extrafuncs.get(func, func)\n    if isinstance(func, str):\n        raise NotImplementedError(\"Grouploop needs to be called with a function\")\n    return aggregate_numpy.aggregate(*args, func=lambda x: func(x), **kwargs)", "response": "wraps func in lambda which prevents aggregate_numpy from recognising and optimising it. Instead it groups and loops."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef c_func(funcname, reverse=False, nans=False, scalar=False):\n    varnames = ['group_idx', 'a', 'ret', 'counter']\n    codebase = c_base_reverse if reverse else c_base\n    iteration = c_iter_scalar[funcname] if scalar else c_iter[funcname]\n    if scalar:\n        varnames.remove('a')\n    return codebase % dict(init=c_init(varnames), iter=iteration,\n                           finish=c_finish.get(funcname, ''),\n                           ri_redir=(c_ri_redir if nans else c_ri))", "response": "Fill c_funcs with constructed code from the templates"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the indices of the edges of areas within group_idx which are filled with the same value", "response": "def step_indices(group_idx):\n    \"\"\" Get the edges of areas within group_idx, which are filled \n        with the same value\n    \"\"\"\n    ilen = step_count(group_idx) + 1\n    indices = np.empty(ilen, int)\n    indices[0] = 0\n    indices[-1] = group_idx.size\n    inline(c_step_indices, ['group_idx', 'indices'], define_macros=c_macros, extra_compile_args=c_args)\n    return indices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a random projection matrix for the given size", "response": "def __create_proj_mat(self, size):\n        \"\"\"Create a random projection matrix\n\n        [1] D. Achlioptas. Database-friendly random projections: Johnson-Lindenstrauss with binary coins.\n        [2] P. Li, et al. Very sparse random projections.\n\n        http://scikit-learn.org/stable/modules/random_projection.html#sparse-random-projection\n        \"\"\"\n\n        # [1]\n        # return np.random.choice([-np.sqrt(3), 0, np.sqrt(3)], size=size, p=[1 / 6, 2 / 3, 1 / 6])\n\n        # [2]\n        s = 1 / self.density\n        return np.random.choice([-np.sqrt(s / self.k), 0, np.sqrt(s / self.k)],\n                                size=size,\n                                p=[1 / (2 * s), 1 - 1 / s, 1 / (2 * s)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_movies(data_home, size):\n    all_genres = ['Action',\n                  'Adventure',\n                  'Animation',\n                  \"Children's\",\n                  'Comedy',\n                  'Crime',\n                  'Documentary',\n                  'Drama',\n                  'Fantasy',\n                  'Film-Noir',\n                  'Horror',\n                  'Musical',\n                  'Mystery',\n                  'Romance',\n                  'Sci-Fi',\n                  'Thriller',\n                  'War',\n                  'Western']\n    n_genre = len(all_genres)\n\n    movies = {}\n\n    if size == '100k':\n        with open(os.path.join(data_home, 'u.item'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: l.rstrip().split('|'), f.readlines()))\n\n        for line in lines:\n            movie_vec = np.zeros(n_genre)\n            for i, flg_chr in enumerate(line[-n_genre:]):\n                if flg_chr == '1':\n                    movie_vec[i] = 1.\n            movie_id = int(line[0])\n            movies[movie_id] = movie_vec\n    elif size == '1m':\n        with open(os.path.join(data_home, 'movies.dat'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: l.rstrip().split('::'), f.readlines()))\n\n        for item_id_str, title, genres in lines:\n            movie_vec = np.zeros(n_genre)\n            for genre in genres.split('|'):\n                i = all_genres.index(genre)\n                movie_vec[i] = 1.\n            item_id = int(item_id_str)\n            movies[item_id] = movie_vec\n\n    return movies", "response": "Load movie genres as a context."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload user demographics as contexts.", "response": "def load_users(data_home, size):\n    \"\"\"Load user demographics as contexts.User ID -> {sex (M/F), age (7 groupd), occupation(0-20; 21)}\n    Returns:\n        dict of user vectors: user_id -> numpy array (1+1+21,); (sex_flg + age_group + n_occupation, )\n    \"\"\"\n    ages = [1, 18, 25, 35, 45, 50, 56, 999]\n\n    users = {}\n\n    if size == '100k':\n        all_occupations = ['administrator',\n                           'artist',\n                           'doctor',\n                           'educator',\n                           'engineer',\n                           'entertainment',\n                           'executive',\n                           'healthcare',\n                           'homemaker',\n                           'lawyer',\n                           'librarian',\n                           'marketing',\n                           'none',\n                           'other',\n                           'programmer',\n                           'retired',\n                           'salesman',\n                           'scientist',\n                           'student',\n                           'technician',\n                           'writer']\n\n        with open(os.path.join(data_home, 'u.user'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: l.rstrip().split('|'), f.readlines()))\n\n        for user_id_str, age_str, sex_str, occupation_str, zip_code in lines:\n                user_vec = np.zeros(1 + 1 + 21)  # 1 categorical, 1 value, 21 categorical\n                user_vec[0] = 0 if sex_str == 'M' else 1  # sex\n\n                # age (ML1M is \"age group\", but 100k has actual \"age\")\n                age = int(age_str)\n                for i in range(7):\n                    if age >= ages[i] and age < ages[i + 1]:\n                        user_vec[1] = i\n                        break\n\n                user_vec[2 + all_occupations.index(occupation_str)] = 1  # occupation (1-of-21)\n                users[int(user_id_str)] = user_vec\n    elif size == '1m':\n        with open(os.path.join(data_home, 'users.dat'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: l.rstrip().split('::'), f.readlines()))\n\n        for user_id_str, sex_str, age_str, occupation_str, zip_code in lines:\n                user_vec = np.zeros(1 + 1 + 21)  # 1 categorical, 1 value, 21 categorical\n                user_vec[0] = 0 if sex_str == 'M' else 1  # sex\n                user_vec[1] = ages.index(int(age_str))  # age group (1, 18, ...)\n                user_vec[2 + int(occupation_str)] = 1  # occupation (1-of-21)\n                users[int(user_id_str)] = user_vec\n\n    return users"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_ratings(data_home, size):\n\n    if size == '100k':\n        with open(os.path.join(data_home, 'u.data'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: list(map(int, l.rstrip().split('\\t'))), f.readlines()))\n    elif size == '1m':\n        with open(os.path.join(data_home, 'ratings.dat'), encoding='ISO-8859-1') as f:\n            lines = list(map(lambda l: list(map(int, l.rstrip().split('::'))), f.readlines()))\n\n    ratings = []\n\n    for l in lines:\n        # Since we consider positive-only feedback setting, ratings < 5 will be excluded.\n        if l[2] == 5:\n            ratings.append(l)\n\n    ratings = np.asarray(ratings)\n\n    # sorted by timestamp\n    return ratings[np.argsort(ratings[:, 3])]", "response": "Load all samples in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute difference between given 2 dates in month / day.", "response": "def delta(d1, d2, opt='d'):\n    \"\"\"Compute difference between given 2 dates in month/day.\n    \"\"\"\n    delta = 0\n\n    if opt == 'm':\n        while True:\n            mdays = monthrange(d1.year, d1.month)[1]\n            d1 += timedelta(days=mdays)\n            if d1 <= d2:\n                delta += 1\n            else:\n                break\n    else:\n        delta = (d2 - d1).days\n\n    return delta"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef feature_hash(feature, dim, seed=123):\n    vec = np.zeros(dim)\n    i = mmh3.hash(feature, seed) % dim\n    vec[i] = 1\n    return vec", "response": "Feature hashing.\n\n    Args:\n        feature (str): Target feature represented as string.\n        dim (int): Number of dimensions for a hash value.\n        seed (float): Seed of a MurmurHash3 hash function.\n\n    Returns:\n        numpy 1d array: one-hot-encoded feature vector for `s`."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count_true_positive(truth, recommend):\n    tp = 0\n    for r in recommend:\n        if r in truth:\n            tp += 1\n    return tp", "response": "Counts the number of true positives from given set of samples."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the recall of the current node in the tree.", "response": "def recall(truth, recommend, k=None):\n    \"\"\"Recall@k.\n\n    Args:\n        truth (numpy 1d array): Set of truth samples.\n        recommend (numpy 1d array): Ordered set of recommended samples.\n        k (int): Top-k items in `recommend` will be recommended.\n\n    Returns:\n        float: Recall@k.\n\n    \"\"\"\n    if len(truth) == 0:\n        if len(recommend) == 0:\n            return 1.\n        return 0.\n\n    if k is None:\n        k = len(recommend)\n    return count_true_positive(truth, recommend[:k]) / float(truth.size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef precision(truth, recommend, k=None):\n    if len(recommend) == 0:\n        if len(truth) == 0:\n            return 1.\n        return 0.\n\n    if k is None:\n        k = len(recommend)\n    return count_true_positive(truth, recommend[:k]) / float(k)", "response": "Returns the precision of the truth and recommendations."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef average_precision(truth, recommend):\n    if len(truth) == 0:\n        if len(recommend) == 0:\n            return 1.\n        return 0.\n\n    tp = accum = 0.\n    for n in range(recommend.size):\n        if recommend[n] in truth:\n            tp += 1.\n            accum += (tp / (n + 1.))\n    return accum / truth.size", "response": "Average Precision of a set of truth and recommendations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the AUC of the given set of truth and recommendations.", "response": "def auc(truth, recommend):\n    \"\"\"Area under the ROC curve (AUC).\n\n    Args:\n        truth (numpy 1d array): Set of truth samples.\n        recommend (numpy 1d array): Ordered set of recommended samples.\n\n    Returns:\n        float: AUC.\n\n    \"\"\"\n    tp = correct = 0.\n    for r in recommend:\n        if r in truth:\n            # keep track number of true positives placed before\n            tp += 1.\n        else:\n            correct += tp\n    # number of all possible tp-fp pairs\n    pairs = tp * (recommend.size - tp)\n\n    # if there is no TP (or no FP), it's meaningless for this metric (i.e., AUC=0.5)\n    if pairs == 0:\n        return 0.5\n\n    return correct / pairs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the reciprocal rank of the set of truth and recommend.", "response": "def reciprocal_rank(truth, recommend):\n    \"\"\"Reciprocal Rank (RR).\n\n    Args:\n        truth (numpy 1d array): Set of truth samples.\n        recommend (numpy 1d array): Ordered set of recommended samples.\n\n    Returns:\n        float: RR.\n\n    \"\"\"\n    for n in range(recommend.size):\n        if recommend[n] in truth:\n            return 1. / (n + 1)\n    return 0."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmeans Percentile Rank of a set of truth and recommendations.", "response": "def mpr(truth, recommend):\n    \"\"\"Mean Percentile Rank (MPR).\n\n    Args:\n        truth (numpy 1d array): Set of truth samples.\n        recommend (numpy 1d array): Ordered set of recommended samples.\n\n    Returns:\n        float: MPR.\n\n    \"\"\"\n    if len(recommend) == 0 and len(truth) == 0:\n        return 0.  # best\n    elif len(truth) == 0 or len(truth) == 0:\n        return 100.  # worst\n\n    accum = 0.\n    n_recommend = recommend.size\n    for t in truth:\n        r = np.where(recommend == t)[0][0] / float(n_recommend)\n        accum += r\n    return accum * 100. / truth.size"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ndcg(truth, recommend, k=None):\n    if k is None:\n        k = len(recommend)\n\n    def idcg(n_possible_truth):\n        res = 0.\n        for n in range(n_possible_truth):\n            res += 1. / np.log2(n + 2)\n        return res\n\n    dcg = 0.\n    for n, r in enumerate(recommend[:k]):\n        if r not in truth:\n            continue\n        dcg += 1. / np.log2(n + 2)\n\n    res_idcg = idcg(np.min([truth.size, k]))\n    if res_idcg == 0.:\n        return 0.\n    return dcg / res_idcg", "response": "Returns the NDCG of the given set of truth and recommendations."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes a recommender by resetting stored users and items.", "response": "def initialize(self, *args):\n        \"\"\"Initialize a recommender by resetting stored users and items.\n        \"\"\"\n        # number of observed users\n        self.n_user = 0\n\n        # store user data\n        self.users = {}\n\n        # number of observed items\n        self.n_item = 0\n\n        # store item data\n        self.items = {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a user into the dictionary.", "response": "def register_user(self, user):\n        \"\"\"For new users, append their information into the dictionaries.\n\n        Args:\n            user (User): User.\n\n        \"\"\"\n        self.users[user.index] = {'known_items': set()}\n        self.n_user += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scores2recos(self, scores, candidates, rev=False):\n        sorted_indices = np.argsort(scores)\n\n        if rev:\n            sorted_indices = sorted_indices[::-1]\n\n        return candidates[sorted_indices], scores[sorted_indices]", "response": "Return a list of items for a user u_index based on scores."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntrain a model using the first 30% positive events to avoid cold - start.", "response": "def fit(self, train_events, test_events, n_epoch=1):\n        \"\"\"Train a model using the first 30% positive events to avoid cold-start.\n\n        Evaluation of this batch training is done by using the next 20% positive events.\n        After the batch SGD training, the models are incrementally updated by using the 20% test events.\n\n        Args:\n            train_events (list of Event): Positive training events (0-30%).\n            test_events (list of Event): Test events (30-50%).\n            n_epoch (int): Number of epochs for the batch training.\n\n        \"\"\"\n        # make initial status for batch training\n        for e in train_events:\n            self.__validate(e)\n            self.rec.users[e.user.index]['known_items'].add(e.item.index)\n            self.item_buffer.append(e.item.index)\n\n        # for batch evaluation, temporarily save new users info\n        for e in test_events:\n            self.__validate(e)\n            self.item_buffer.append(e.item.index)\n\n        self.__batch_update(train_events, test_events, n_epoch)\n\n        # batch test events are considered as a new observations;\n        # the model is incrementally updated based on them before the incremental evaluation step\n        for e in test_events:\n            self.rec.users[e.user.index]['known_items'].add(e.item.index)\n            self.rec.update(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates recommend and update procedure and compute incremental recall.", "response": "def evaluate(self, test_events):\n        \"\"\"Iterate recommend/update procedure and compute incremental recall.\n\n        Args:\n            test_events (list of Event): Positive test events.\n\n        Returns:\n            list of tuples: (rank, recommend time, update time)\n\n        \"\"\"\n        for i, e in enumerate(test_events):\n            self.__validate(e)\n\n            # target items (all or unobserved depending on a detaset)\n            unobserved = set(self.item_buffer)\n            if not self.repeat:\n                unobserved -= self.rec.users[e.user.index]['known_items']\n\n            # item i interacted by user u must be in the recommendation candidate\n            # even if it is a new item\n            unobserved.add(e.item.index)\n\n            candidates = np.asarray(list(unobserved))\n\n            # make top-{at} recommendation for the 1001 items\n            start = time.clock()\n            recos, scores = self.__recommend(e, candidates)\n            recommend_time = (time.clock() - start)\n\n            rank = np.where(recos == e.item.index)[0][0]\n\n            # Step 2: update the model with the observed event\n            self.rec.users[e.user.index]['known_items'].add(e.item.index)\n            start = time.clock()\n            self.rec.update(e)\n            update_time = (time.clock() - start)\n\n            self.item_buffer.append(e.item.index)\n\n            # (top-1 score, where the correct item is ranked, rec time, update time)\n            yield scores[0], rank, recommend_time, update_time"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbatch update called by the fitting method.", "response": "def __batch_update(self, train_events, test_events, n_epoch):\n        \"\"\"Batch update called by the fitting method.\n\n        Args:\n            train_events (list of Event): Positive training events.\n            test_events (list of Event): Test events.\n            n_epoch (int): Number of epochs for the batch training.\n\n        \"\"\"\n        for epoch in range(n_epoch):\n            # SGD requires us to shuffle events in each iteration\n            # * if n_epoch == 1\n            #   => shuffle is not required because it is a deterministic training (i.e. matrix sketching)\n            if n_epoch != 1:\n                np.random.shuffle(train_events)\n\n            # train\n            for e in train_events:\n                self.rec.update(e, batch_train=True)\n\n            # test\n            MPR = self.__batch_evaluate(test_events)\n            if self.debug:\n                logger.debug('epoch %2d: MPR = %f' % (epoch + 1, MPR))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating the current model by using the given test events.", "response": "def __batch_evaluate(self, test_events):\n        \"\"\"Evaluate the current model by using the given test events.\n\n        Args:\n            test_events (list of Event): Current model is evaluated by these events.\n\n        Returns:\n            float: Mean Percentile Rank for the test set.\n\n        \"\"\"\n        percentiles = np.zeros(len(test_events))\n\n        all_items = set(self.item_buffer)\n        for i, e in enumerate(test_events):\n\n            # check if the data allows users to interact the same items repeatedly\n            unobserved = all_items\n            if not self.repeat:\n                # make recommendation for all unobserved items\n                unobserved -= self.rec.users[e.user.index]['known_items']\n                # true item itself must be in the recommendation candidates\n                unobserved.add(e.item.index)\n\n            candidates = np.asarray(list(unobserved))\n            recos, scores = self.__recommend(e, candidates)\n\n            pos = np.where(recos == e.item.index)[0][0]\n            percentiles[i] = pos / (len(recos) - 1) * 100\n\n        return np.mean(percentiles)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscale X values to new width", "response": "def _scale_x_values(self, values, max_width):\n        '''Scale X values to new width'''\n\n        if type(values) == dict:\n            values = self._scale_x_values_timestamps(values=values, max_width=max_width)\n\n        adjusted_values = list(values)\n        if len(adjusted_values) > max_width:\n\n            def get_position(current_pos):\n                return len(adjusted_values) * current_pos // max_width\n\n            adjusted_values = [statistics.mean(adjusted_values[get_position(i):get_position(i + 1)]) for i in range(max_width)]\n\n        return adjusted_values"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _scale_x_values_timestamps(self, values, max_width):\n        '''Scale X values to new width based on timestamps'''\n        first_timestamp = float(values[0][0])\n        last_timestamp = float(values[-1][0])\n        step_size = (last_timestamp - first_timestamp) / max_width\n\n        values_by_column = [[] for i in range(max_width)]\n        for timestamp, value in values:\n            if value is None:\n                continue\n            timestamp = float(timestamp)\n            column = (timestamp - first_timestamp) // step_size\n            column = int(min(column, max_width - 1))  # Don't go beyond the last column\n            values_by_column[column].append(value)\n\n        adjusted_values = [statistics.mean(values) if values else 0 for values in values_by_column]  # Average each column, 0 if no values\n\n        return adjusted_values", "response": "Scale X values based on timestamps"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _scale_y_values(self, values, new_min, new_max, scale_old_from_zero=True):\n        '''\n        Take values and transmute them into a new range\n        '''\n        # Scale Y values - Create a scaled list of values to use for the visual graph\n        scaled_values = []\n        y_min_value = min(values)\n        if scale_old_from_zero:\n            y_min_value = 0\n        y_max_value = max(values)\n        new_min = 0\n        OldRange = (y_max_value - y_min_value) or 1  # Prevents division by zero if all values are the same\n        NewRange = (new_max - new_min)  # max_height is new_max\n        for old_value in values:\n            new_value = (((old_value - y_min_value) * NewRange) / OldRange) + new_min\n            scaled_values.append(new_value)\n        return scaled_values", "response": "Scale the Y values of the entries in the list of entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a representation of an ascii graph using two lists of values.", "response": "def _get_ascii_field(self, values):\n        '''Create a representation of an ascii graph using two lists in this format: field[x][y] = \"char\"'''\n\n        empty_space = ' '\n\n        # This formats as field[x][y]\n        field = [[empty_space for y in range(max(values) + 1)] for x in range(len(values))]\n\n        # Draw graph into field\n        for x in range(len(values)):\n            y = values[x]\n            y_prev = values[x - 1] if x - 1 in range(len(values)) else y\n            y_next = values[x + 1] if x + 1 in range(len(values)) else y\n            # Fill empty space\n            if abs(y_prev - y) > 1:\n                # Fill space between y and y_prev\n                step = 1 if y_prev - y > 0 else -1\n\n                # We don't want the first item to be inclusive, so we use step instead of y+1 since step can be negative\n                for h in range(y + step, y_prev, step):\n                    if field[x][h] is empty_space:\n                        field[x][h] = '|'\n\n            # Assign the character to be placed into the graph\n            char = self._assign_ascii_character(y_prev, y, y_next)\n\n            field[x][y] = char\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassigns the character to be placed into the graph", "response": "def _assign_ascii_character(self, y_prev, y, y_next):  # noqa for complexity\n            '''Assign the character to be placed into the graph'''\n            char = '?'\n            if y_next > y and y_prev > y:\n                char = '-'\n            elif y_next < y and y_prev < y:\n                char = '-'\n            elif y_prev < y and y == y_next:\n                char = '-'\n            elif y_prev == y and y_next < y:\n                char = '-'\n            elif y_next > y:\n                char = '/'\n            elif y_next < y:\n                char = '\\\\'\n            elif y_prev < y:\n                char = '/'\n            elif y_prev > y:\n                char = '\\\\'\n            elif y_next == y:\n                char = '-'\n            elif y == y_prev:\n                char = '-'\n            return char"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _draw_ascii_graph(self, field):\n        '''Draw graph from field double nested list, format field[x][y] = char'''\n        row_strings = []\n        for y in range(len(field[0])):\n            row = ''\n            for x in range(len(field)):\n                row += field[x][y]\n            row_strings.insert(0, row)\n        graph_string = '\\n'.join(row_strings)\n        return graph_string", "response": "Draw graph from field double nested list format field [ x ] = char"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef asciigraph(self, values=None, max_height=None, max_width=None, label=False):\n        '''\n        Accepts a list of y values and returns an ascii graph\n        Optionally values can also be a dictionary with a key of timestamp, and a value of value. InGraphs returns data in this format for example.\n        '''\n        result = ''\n        border_fill_char = '*'\n        start_ctime = None\n        end_ctime = None\n\n        if not max_width:\n            max_width = 180\n\n        # If this is a dict of timestamp -> value, sort the data, store the start/end time, and convert values to a list of values\n        if isinstance(values, dict):\n            time_series_sorted = sorted(list(values.items()), key=lambda x: x[0])  # Sort timestamp/value dict by the timestamps\n\n            start_timestamp = time_series_sorted[0][0]\n            end_timestamp = time_series_sorted[-1][0]\n\n            start_ctime = datetime.fromtimestamp(float(start_timestamp)).ctime()\n            end_ctime = datetime.fromtimestamp(float(end_timestamp)).ctime()\n            values = self._scale_x_values_timestamps(values=time_series_sorted, max_width=max_width)\n        values = [value for value in values if value is not None]\n\n        if not max_height:\n            max_height = min(20, max(values))\n\n        stdev = statistics.stdev(values)\n        mean = statistics.mean(values)\n\n        # Do value adjustments\n        adjusted_values = list(values)\n        adjusted_values = self._scale_x_values(values=values, max_width=max_width)\n        upper_value = max(adjusted_values)  # Getting upper/lower after scaling x values so we don't label a spike we can't see\n        lower_value = min(adjusted_values)\n        adjusted_values = self._scale_y_values(values=adjusted_values, new_min=0, new_max=max_height, scale_old_from_zero=False)\n        adjusted_values = self._round_floats_to_ints(values=adjusted_values)\n\n        # Obtain Ascii Graph String\n        field = self._get_ascii_field(adjusted_values)\n        graph_string = self._draw_ascii_graph(field=field)\n\n        # Label the graph\n        if label:\n            top_label = 'Upper value: {upper_value:.2f} '.format(upper_value=upper_value).ljust(max_width, border_fill_char)\n            result += top_label + '\\n'\n        result += '{graph_string}\\n'.format(graph_string=graph_string)\n        if label:\n            lower = f'Lower value: {lower_value:.2f} '\n            stats = f' Mean: {mean:.2f} *** Std Dev: {stdev:.2f} ******'\n            fill_length = max_width - len(lower) - len(stats)\n            stat_label = f'{lower}{\"*\" * fill_length}{stats}\\n'\n            result += stat_label\n\n            if start_ctime and end_ctime:\n                fill_length = max_width - len(start_ctime) - len(end_ctime)\n                result += f'{start_ctime}{\" \" * fill_length}{end_ctime}\\n'\n\n        return result", "response": "This function returns an ascii graph of the ingraph data for the given list of y values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreplacing variables in the given expression using the given substitution.", "response": "def substitute(expression: Union[Expression, Pattern], substitution: Substitution) -> Replacement:\n    \"\"\"Replaces variables in the given *expression* using the given *substitution*.\n\n    >>> print(substitute(f(x_), {'x': a}))\n    f(a)\n\n    If nothing was substituted, the original expression is returned:\n\n    >>> expression = f(x_)\n    >>> result = substitute(expression, {'y': a})\n    >>> print(result)\n    f(x_)\n    >>> expression is result\n    True\n\n    Note that this function returns a list of expressions iff the expression is a variable and its substitution\n    is a list of expressions. In other cases were a substitution is a list of expressions, the expressions will\n    be integrated as operands in the surrounding operation:\n\n    >>> print(substitute(f(x_, c), {'x': [a, b]}))\n    f(a, b, c)\n\n    If you substitute with a `Multiset` of values, they will be sorted:\n\n    >>> replacement = Multiset([b, a, b])\n    >>> print(substitute(f(x_, c), {'x': replacement}))\n    f(a, b, b, c)\n\n    Parameters:\n        expression:\n            An expression in which variables are substituted.\n        substitution:\n            A substitution dictionary. The key is the name of the variable,\n            the value either an expression or a list of expression to use as a replacement for\n            the variable.\n\n    Returns:\n        The expression resulting from applying the substitution.\n    \"\"\"\n    if isinstance(expression, Pattern):\n        expression = expression.expression\n    return _substitute(expression, substitution)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace(expression: Expression, position: Sequence[int], replacement: Replacement) -> Replacement:\n    if len(position) == 0:\n        return replacement\n    if not isinstance(expression, Operation):\n        raise IndexError(\"Invalid position {!r} for expression {!s}\".format(position, expression))\n    if position[0] >= op_len(expression):\n        raise IndexError(\"Position {!r} out of range for expression {!s}\".format(position, expression))\n    pos = position[0]\n    operands = list(op_iter(expression))\n    subexpr = replace(operands[pos], position[1:], replacement)\n    if isinstance(subexpr, Sequence):\n        new_operands = tuple(operands[:pos]) + tuple(subexpr) + tuple(operands[pos + 1:])\n        return create_operation_expression(expression, new_operands)\n    operands[pos] = subexpr\n    return create_operation_expression(expression, operands)", "response": "r Replaces the subexpression of expression at the given position with the given replacement."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace_many(expression: Expression, replacements: Sequence[Tuple[Sequence[int], Replacement]]) -> Replacement:\n    if len(replacements) == 0:\n        return expression\n    replacements = sorted(replacements)\n    if len(replacements[0][0]) == 0:\n        if len(replacements) > 1:\n            raise IndexError(\n                \"Cannot replace child positions for expression {}, got {!r}\".format(expression, replacements[1:])\n            )\n        return replacements[0][1]\n    if len(replacements) == 1:\n        return replace(expression, replacements[0][0], replacements[0][1])\n    if not isinstance(expression, Operation):\n        raise IndexError(\"Invalid replacements {!r} for expression {!s}\".format(replacements, expression))\n    operands = list(op_iter(expression))\n    new_operands = []\n    last_index = 0\n    for index, group in itertools.groupby(replacements, lambda r: r[0][0]):\n        new_operands.extend(operands[last_index:index])\n        replacements = [(pos[1:], r) for pos, r in group]\n        if len(replacements) == 1:\n            replacement = replace(operands[index], replacements[0][0], replacements[0][1])\n        else:\n            replacement = replace_many(operands[index], replacements)\n        if isinstance(replacement, (list, tuple, Multiset)):\n            new_operands.extend(replacement)\n        else:\n            new_operands.append(replacement)\n        last_index = index + 1\n    new_operands.extend(operands[last_index:len(operands)])\n    return create_operation_expression(expression, new_operands)", "response": "r Replaces the subexpressions of expression at the given positions with the given replacements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace all occurrences of the patterns in the given expression with the given set of replacement rules.", "response": "def replace_all(expression: Expression, rules: Iterable[ReplacementRule], max_count: int=math.inf) \\\n        -> Union[Expression, Sequence[Expression]]:\n    \"\"\"Replace all occurrences of the patterns according to the replacement rules.\n\n    A replacement rule consists of a *pattern*, that is matched against any subexpression\n    of the expression. If a match is found, the *replacement* callback of the rule is called with\n    the variables from the match substitution. Whatever the callback returns is used as a replacement for the\n    matched subexpression. This can either be a single expression or a sequence of expressions, which is then\n    integrated into the surrounding operation in place of the subexpression.\n\n    Note that the pattern can therefore not be a single sequence variable/wildcard, because only single expressions\n    will be matched.\n\n    Args:\n        expression:\n            The expression to which the replacement rules are applied.\n        rules:\n            A collection of replacement rules that are applied to the expression.\n        max_count:\n            If given, at most *max_count* applications of the rules are performed. Otherwise, the rules\n            are applied until there is no more match. If the set of replacement rules is not confluent,\n            the replacement might not terminate without a *max_count* set.\n\n    Returns:\n        The resulting expression after the application of the replacement rules. This can also be a sequence of\n        expressions, if the root expression is replaced with a sequence of expressions by a rule.\n    \"\"\"\n    rules = [ReplacementRule(pattern, replacement) for pattern, replacement in rules]\n    expression = expression\n    replaced = True\n    replace_count = 0\n    while replaced and replace_count < max_count:\n        replaced = False\n        for subexpr, pos in preorder_iter_with_position(expression):\n            for pattern, replacement in rules:\n                try:\n                    subst = next(match(subexpr, pattern))\n                    result = replacement(**subst)\n                    expression = replace(expression, pos, result)\n                    replaced = True\n                    break\n                except StopIteration:\n                    pass\n            if replaced:\n                break\n        replace_count += 1\n\n    return expression"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace_all_post_order(expression: Expression, rules: Iterable[ReplacementRule]) \\\n        -> Union[Expression, Sequence[Expression]]:\n    \"\"\"Replace all occurrences of the patterns according to the replacement rules.\n\n    A replacement rule consists of a *pattern*, that is matched against any subexpression\n    of the expression. If a match is found, the *replacement* callback of the rule is called with\n    the variables from the match substitution. Whatever the callback returns is used as a replacement for the\n    matched subexpression. This can either be a single expression or a sequence of expressions, which is then\n    integrated into the surrounding operation in place of the subexpression.\n\n    Note that the pattern can therefore not be a single sequence variable/wildcard, because only single expressions\n    will be matched.\n\n    Args:\n        expression:\n            The expression to which the replacement rules are applied.\n        rules:\n            A collection of replacement rules that are applied to the expression.\n        max_count:\n            If given, at most *max_count* applications of the rules are performed. Otherwise, the rules\n            are applied until there is no more match. If the set of replacement rules is not confluent,\n            the replacement might not terminate without a *max_count* set.\n\n    Returns:\n        The resulting expression after the application of the replacement rules. This can also be a sequence of\n        expressions, if the root expression is replaced with a sequence of expressions by a rule.\n    \"\"\"\n    return _replace_all_post_order(expression, rules)[0]", "response": "Replaces all occurrences of the patterns according to the replacement rules."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether the given subject matches given pattern.", "response": "def is_match(subject: Expression, pattern: Expression) -> bool:\n    \"\"\"\n    Check whether the given *subject* matches given *pattern*.\n\n    Args:\n        subject:\n            The subject.\n        pattern:\n            The pattern.\n\n    Returns:\n        True iff the subject matches the pattern.\n    \"\"\"\n    return any(True for _ in match(subject, pattern))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_graph(self) -> Graph:  # pragma: no cover\n        if Graph is None:\n            raise ImportError('The graphviz package is required to draw the graph.')\n        graph = Graph()\n        nodes_left = {}  # type: Dict[TLeft, str]\n        nodes_right = {}  # type: Dict[TRight, str]\n        node_id = 0\n        for (left, right), value in self._edges.items():\n            if left not in nodes_left:\n                name = 'node{:d}'.format(node_id)\n                nodes_left[left] = name\n                graph.node(name, label=str(left))\n                node_id += 1\n            if right not in nodes_right:\n                name = 'node{:d}'.format(node_id)\n                nodes_right[right] = name\n                graph.node(name, label=str(right))\n                node_id += 1\n            edge_label = value is not True and str(value) or ''\n            graph.edge(nodes_left[left], nodes_right[right], edge_label)\n        return graph", "response": "Returns a graphviz. Graph representation of this bipartite graph."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_matching(self) -> Dict[TLeft, TRight]:\n        # The directed graph is represented as a dictionary of edges\n        # The key is the tail of all edges which are represented by the value\n        # The value is a set of heads for the all edges originating from the tail (key)\n        # In addition, the graph stores which part of the bipartite graph a node originated from\n        # to avoid problems when a value exists in both halfs.\n        # Only one direction of the undirected edge is needed for the HopcroftKarp class\n        directed_graph = {}  # type: Dict[Tuple[int, TLeft], Set[Tuple[int, TRight]]]\n\n        for (left, right) in self._edges:\n            tail = (LEFT, left)\n            head = (RIGHT, right)\n            if tail not in directed_graph:\n                directed_graph[tail] = {head}\n            else:\n                directed_graph[tail].add(head)\n\n        matching = HopcroftKarp(directed_graph).maximum_matching()\n\n        # Filter out the partitions (LEFT and RIGHT) and only return the matching edges\n        # that go from LEFT to RIGHT\n        return dict((tail[1], head[1]) for tail, head in matching.items() if tail[0] == LEFT)", "response": "Finds a matching in the bipartite graph."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef without_nodes(self, edge: Edge) -> 'BipartiteGraph[TLeft, TRight, TEdgeValue]':\n        return BipartiteGraph(((n1, n2), v) for (n1, n2), v in self._edges.items() if n1 != edge[0] and n2 != edge[1])", "response": "Returns a copy of this bipartite graph with the given edge and its adjacent nodes removed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef without_edge(self, edge: Edge) -> 'BipartiteGraph[TLeft, TRight, TEdgeValue]':\n        return BipartiteGraph((e2, v) for e2, v in self._edges.items() if edge != e2)", "response": "Returns a copy of this bipartite graph with the given edge removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new subgraph where only the nodes from the given sets are included.", "response": "def limited_to(self, left: Set[TLeft], right: Set[TRight]) -> 'BipartiteGraph[TLeft, TRight, TEdgeValue]':\n        \"\"\"Returns the induced subgraph where only the nodes from the given sets are included.\"\"\"\n        return BipartiteGraph(((n1, n2), v) for (n1, n2), v in self._edges.items() if n1 in left and n2 in right)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a graphviz. Digraph representation of this directed match graph.", "response": "def as_graph(self) -> Digraph:  # pragma: no cover\n        \"\"\"Returns a :class:`graphviz.Digraph` representation of this directed match graph.\"\"\"\n        if Digraph is None:\n            raise ImportError('The graphviz package is required to draw the graph.')\n        graph = Digraph()\n\n        subgraphs = [Digraph(graph_attr={'rank': 'same'}), Digraph(graph_attr={'rank': 'same'})]\n        nodes = [{}, {}]  # type: List[Dict[Union[TLeft, TRight], str]]\n        edges = []  # type: List [Tuple[str, str]]\n        node_id = 0\n        for (tail_part, tail), head_set in self.items():\n            if tail not in nodes[tail_part]:\n                name = 'node{:d}'.format(node_id)\n                nodes[tail_part][tail] = name\n                subgraphs[tail_part].node(name, label=str(tail))\n                node_id += 1\n            for head_part, head in head_set:\n                if head not in nodes[head_part]:\n                    name = 'node{:d}'.format(node_id)\n                    nodes[head_part][head] = name\n                    subgraphs[head_part].node(name, label=str(head))\n                    node_id += 1\n                edges.append((nodes[tail_part][tail], nodes[head_part][head]))\n        graph.subgraph(subgraphs[0])\n        graph.subgraph(subgraphs[1])\n        for tail_node, head_node in edges:\n            graph.edge(tail_node, head_node)\n        return graph"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_constant(expression):\n    if isinstance(expression, Wildcard):\n        return False\n    if isinstance(expression, Expression):\n        return expression.is_constant\n    if isinstance(expression, Operation):\n        return all(is_constant(o) for o in op_iter(expression))\n    return True", "response": "Check if the given expression is constant i. e. it does not contain Wildcards."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the given expression is syntactic.", "response": "def is_syntactic(expression):\n    \"\"\"\n    Check if the given expression is syntactic, i.e. it does not contain sequence wildcards or\n    associative/commutative operations.\n    \"\"\"\n    if isinstance(expression, Wildcard):\n        return expression.fixed_size\n    if isinstance(expression, Expression):\n        return expression.is_syntactic\n    if isinstance(expression, (AssociativeOperation, CommutativeOperation)):\n        return False\n    if isinstance(expression, Operation):\n        return all(is_syntactic(o) for o in op_iter(expression))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_head(expression):\n    if isinstance(expression, Wildcard):\n        if isinstance(expression, SymbolWildcard):\n            return expression.symbol_type\n        return None\n    return type(expression)", "response": "Returns the given expression s head."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match_head(subject, pattern):\n    if isinstance(pattern, Pattern):\n        pattern = pattern.expression\n    pattern_head = get_head(pattern)\n    if pattern_head is None:\n        return True\n    if issubclass(pattern_head, OneIdentityOperation):\n        return True\n    subject_head = get_head(subject)\n    assert subject_head is not None\n    return issubclass(subject_head, pattern_head)", "response": "Checks if the head of subject matches the pattern s head."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate over the expression in preorder.", "response": "def preorder_iter(expression):\n    \"\"\"Iterate over the expression in preorder.\"\"\"\n    yield expression\n    if isinstance(expression, Operation):\n        for operand in op_iter(expression):\n            yield from preorder_iter(operand)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over the expression in preorder. Also yields the position of each subexpression.", "response": "def preorder_iter_with_position(expression):\n    \"\"\"Iterate over the expression in preorder.\n\n    Also yields the position of each subexpression.\n    \"\"\"\n    yield expression, ()\n    if isinstance(expression, Operation):\n        for i, operand in enumerate(op_iter(expression)):\n            for child, pos in preorder_iter_with_position(operand):\n                yield child, (i, ) + pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_anonymous(expression):\n    if hasattr(expression, 'variable_name') and expression.variable_name:\n        return False\n    if isinstance(expression, Operation):\n        return all(is_anonymous(o) for o in op_iter(expression))\n    return True", "response": "Returns True iff the expression contains any variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True iff the expression contains any of the variables from the given set.", "response": "def contains_variables_from_set(expression, variables):\n    \"\"\"Returns True iff the expression contains any of the variables from the given set.\"\"\"\n    if hasattr(expression, 'variable_name') and expression.variable_name in variables:\n        return True\n    if isinstance(expression, Operation):\n        return any(contains_variables_from_set(o, variables) for o in op_iter(expression))\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the set of variable names in the given expression.", "response": "def get_variables(expression, variables=None):\n    \"\"\"Returns the set of variable names in the given expression.\"\"\"\n    if variables is None:\n        variables = set()\n    if hasattr(expression, 'variable_name') and expression.variable_name is not None:\n        variables.add(expression.variable_name)\n    if isinstance(expression, Operation):\n        for operand in op_iter(expression):\n            get_variables(operand, variables)\n    return variables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new expression with renamed variables.", "response": "def rename_variables(expression: Expression, renaming: Dict[str, str]) -> Expression:\n    \"\"\"Rename the variables in the expression according to the given dictionary.\n\n    Args:\n        expression:\n            The expression in which the variables are renamed.\n        renaming:\n            The renaming dictionary. Maps old variable names to new ones.\n            Variable names not occuring in the dictionary are left unchanged.\n\n    Returns:\n        The expression with renamed variables.\n    \"\"\"\n    if isinstance(expression, Operation):\n        if hasattr(expression, 'variable_name'):\n            variable_name = renaming.get(expression.variable_name, expression.variable_name)\n            return create_operation_expression(\n                expression, [rename_variables(o, renaming) for o in op_iter(expression)], variable_name=variable_name\n            )\n        operands = [rename_variables(o, renaming) for o in op_iter(expression)]\n        return create_operation_expression(expression, operands)\n    elif isinstance(expression, Expression):\n        expression = expression.__copy__()\n        expression.variable_name = renaming.get(expression.variable_name, expression.variable_name)\n    return expression"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator over the integer vectors that are not larger than or equal to max_vector.", "response": "def fixed_integer_vector_iter(max_vector: Tuple[int, ...], vector_sum: int) -> Iterator[Tuple[int, ...]]:\n    \"\"\"\n    Return an iterator over the integer vectors which\n\n    - are componentwise less than or equal to *max_vector*, and\n    - are non-negative, and where\n    - the sum of their components is exactly *vector_sum*.\n\n    The iterator yields the vectors in lexicographical order.\n\n    Examples:\n\n        List all vectors that are between ``(0, 0)`` and ``(2, 2)`` componentwise, where the sum of components is 2:\n\n        >>> vectors = list(fixed_integer_vector_iter([2, 2], 2))\n        >>> vectors\n        [(0, 2), (1, 1), (2, 0)]\n        >>> list(map(sum, vectors))\n        [2, 2, 2]\n\n    Args:\n        max_vector:\n            Maximum vector for the iteration. Every yielded result will be less than or equal to this componentwise.\n        vector_sum:\n            Every iterated vector will have a component sum equal to this value.\n\n    Yields:\n        All non-negative vectors that have the given sum and are not larger than the given maximum.\n\n    Raises:\n        ValueError:\n            If *vector_sum* is negative.\n    \"\"\"\n    if vector_sum < 0:\n        raise ValueError(\"Vector sum must not be negative\")\n    if len(max_vector) == 0:\n        if vector_sum == 0:\n            yield tuple()\n        return\n    total = sum(max_vector)\n    if vector_sum <= total:\n        start = max(max_vector[0] + vector_sum - total, 0)\n        end = min(max_vector[0], vector_sum)\n        for j in range(start, end + 1):\n            for vec in fixed_integer_vector_iter(max_vector[1:], vector_sum - j):\n                yield (j, ) + vec"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding all weak compositions of integer n into num_parts parts.", "response": "def weak_composition_iter(n: int, num_parts: int) -> Iterator[Tuple[int, ...]]:\n    \"\"\"Yield all weak compositions of integer *n* into *num_parts* parts.\n\n    Each composition is yielded as a tuple. The generated partitions are order-dependant and not unique when\n    ignoring the order of the components. The partitions are yielded in lexicographical order.\n\n    Example:\n\n        >>> compositions = list(weak_composition_iter(5, 2))\n        >>> compositions\n        [(0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)]\n\n        We can easily verify that all compositions are indeed valid:\n\n        >>> list(map(sum, compositions))\n        [5, 5, 5, 5, 5, 5]\n\n    The algorithm was adapted from an answer to this `Stackoverflow question`_.\n\n    Args:\n        n:\n            The integer to partition.\n        num_parts:\n            The number of parts for the combination.\n\n    Yields:\n        All non-negative tuples that have the given sum and size.\n\n    Raises:\n        ValueError:\n            If *n* or *num_parts* are negative.\n\n    .. _Stackoverflow question: http://stackoverflow.com/questions/40538923/40540014#40540014\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Total must not be negative\")\n    if num_parts < 0:\n        raise ValueError(\"Number of num_parts must not be negative\")\n    if num_parts == 0:\n        if n == 0:\n            yield tuple()\n        return\n    m = n + num_parts - 1\n    last = (m, )\n    first = (-1, )\n    for t in itertools.combinations(range(m), num_parts - 1):\n        yield tuple(v - u - 1 for u, v in zip(first + t, t + last))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding all possible variable substitutions for given values and variables.", "response": "def commutative_sequence_variable_partition_iter(values: Multiset, variables: List[VariableWithCount]\n                                                ) -> Iterator[Dict[str, Multiset]]:\n    \"\"\"Yield all possible variable substitutions for given values and variables.\n\n    .. note::\n\n        The results are not yielded in any particular order because the algorithm uses dictionaries. Dictionaries until\n        Python 3.6 do not keep track of the insertion order.\n\n    Example:\n\n        For a subject like ``fc(a, a, a, b, b, c)`` and a pattern like ``f(x__, y___, y___)`` one can define the\n        following input parameters for the partitioning:\n\n        >>> x = VariableWithCount(name='x', count=1, minimum=1, default=None)\n        >>> y = VariableWithCount(name='y', count=2, minimum=0, default=None)\n        >>> values = Multiset('aaabbc')\n\n        Then the solutions are found (and sorted to get a unique output):\n\n        >>> substitutions = commutative_sequence_variable_partition_iter(values, [x, y])\n        >>> as_strings = list(str(Substitution(substitution)) for substitution in substitutions)\n        >>> for substitution in sorted(as_strings):\n        ...     print(substitution)\n        {x \u21a6 {a, a, a, b, b, c}, y \u21a6 {}}\n        {x \u21a6 {a, a, a, c}, y \u21a6 {b}}\n        {x \u21a6 {a, b, b, c}, y \u21a6 {a}}\n        {x \u21a6 {a, c}, y \u21a6 {a, b}}\n\n    Args:\n        values:\n            The multiset of values which are partitioned and distributed among the variables.\n        variables:\n            A list of the variables to distribute the values among. Each variable has a name, a count of how many times\n            it occurs and a minimum number of values it needs.\n\n    Yields:\n        Each possible substitutions that is a valid partitioning of the values among the variables.\n    \"\"\"\n    if len(variables) == 1:\n        yield from _commutative_single_variable_partiton_iter(values, variables[0])\n        return\n\n    generators = []\n    for value, count in values.items():\n        generators.append(_make_variable_generator_factory(value, count, variables))\n\n    initial = dict((var.name, Multiset()) for var in variables)  # type: Dict[str, 'Multiset[T]']\n    for subst in generator_chain(initial, *generators):\n        valid = True\n        for var in variables:\n            if var.default is not None and len(subst[var.name]) == 0:\n                subst[var.name] = var.default\n            elif len(subst[var.name]) < var.minimum:\n                valid = False\n                break\n        if valid:\n            if None in subst:\n                del subst[None]\n            yield subst"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_short_lambda_source(lambda_func: LambdaType) -> Optional[str]:\n    try:\n        all_source_lines, lnum = inspect.findsource(lambda_func)\n        source_lines, _ = inspect.getsourcelines(lambda_func)\n    except (IOError, TypeError):\n        return None\n    all_source_lines = [l.rstrip('\\r\\n') for l in all_source_lines]\n    block_end = lnum + len(source_lines)\n    source_ast = None\n    for i in range(lnum, -1, -1):\n        try:\n            block = all_source_lines[i:block_end]\n            if block[0].startswith(' ') or block[0].startswith('\\t'):\n                block.insert(0, 'with 0:')\n            source_ast = ast.parse(os.linesep.join(block))\n        except (SyntaxError, tokenize.TokenError):\n            pass\n        else:\n            break\n    nv = LambdaNodeVisitor(block)\n    nv.visit(source_ast)\n    lambda_code = lambda_func.__code__\n    for candidate_code, lambda_text in nv.lambdas:\n        candidate_code = candidate_code.co_consts[0]\n        # We don't check for direct equivalence since the flags can be different\n        if (candidate_code.co_code == lambda_code.co_code and\n            candidate_code.co_consts == lambda_code.co_consts and\n            candidate_code.co_names == lambda_code.co_names and\n            candidate_code.co_varnames == lambda_code.co_varnames and\n            candidate_code.co_cellvars == lambda_code.co_cellvars and\n            candidate_code.co_freevars == lambda_code.co_freevars):\n            return lambda_text[lambda_text.index(':')+1:].strip()\n\n    return None", "response": "Return the source of a short lambda function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extended_euclid(a: int, b: int) -> Tuple[int, int, int]:\n    if b == 0:\n        return (1, 0, a)\n\n    x0, y0, d = extended_euclid(b, a % b)\n    x, y = y0, x0 - (a // b) * y0\n\n    return (x, y, d)", "response": "Extended Euclidean algorithm that computes the B\u00e9zout coefficients and GCD of a and b."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generator_chain(initial_data: T, *factories: Callable[[T], Iterator[T]]) -> Iterator[T]:\n    generator_count = len(factories)\n    if generator_count == 0:\n        yield initial_data\n        return\n    generators = [None] * generator_count  # type: List[Optional[Iterator[T]]]\n    next_data = initial_data\n    generator_index = 0\n    while True:\n        try:\n            while generator_index < generator_count:\n                if generators[generator_index] is None:\n                    generators[generator_index] = factories[generator_index](next_data)\n                next_data = next(generators[generator_index])\n                generator_index += 1\n            yield next_data\n            generator_index -= 1\n        except StopIteration:\n            generators[generator_index] = None\n            generator_index -= 1\n            if generator_index < 0:\n                break", "response": "A generator that yields data from one of the given generators."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntry to add a variable with its replacement to the substitution.", "response": "def try_add_variable(self, variable_name: str, replacement: VariableReplacement) -> None:\n        \"\"\"Try to add the variable with its replacement to the substitution.\n\n        This considers an existing replacement and will only succeed if the new replacement\n        can be merged with the old replacement. Merging can occur if either the two replacements\n        are equivalent. Replacements can also be merged if the old replacement for the variable_name was\n        unordered (i.e. a :class:`~.Multiset`) and the new one is an equivalent ordered version of it:\n\n        >>> subst = Substitution({'x': Multiset(['a', 'b'])})\n        >>> subst.try_add_variable('x', ('a', 'b'))\n        >>> print(subst)\n        {x \u21a6 (a, b)}\n\n        Args:\n            variable:\n                The name of the variable to add.\n            replacement:\n                The replacement for the variable.\n\n        Raises:\n            ValueError:\n                if the variable cannot be merged because it conflicts with the existing\n                substitution for the variable_name.\n        \"\"\"\n        if variable_name not in self:\n            self[variable_name] = replacement.copy() if isinstance(replacement, Multiset) else replacement\n        else:\n            existing_value = self[variable_name]\n\n            if isinstance(existing_value, tuple):\n                if isinstance(replacement, Multiset):\n                    if Multiset(existing_value) != replacement:\n                        raise ValueError\n                elif replacement != existing_value:\n                    raise ValueError\n            elif isinstance(existing_value, Multiset):\n                if not isinstance(replacement, (tuple, list, Multiset)):\n                    raise ValueError\n                compare_value = Multiset(replacement)\n                if existing_value == compare_value:\n                    if not isinstance(replacement, Multiset):\n                        self[variable_name] = replacement\n                else:\n                    raise ValueError\n            elif replacement != existing_value:\n                raise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new substitution with the given variable added.", "response": "def union_with_variable(self, variable: str, replacement: VariableReplacement) -> 'Substitution':\n        \"\"\"Try to create a new substitution with the given variable added.\n\n        See :meth:`try_add_variable` for a version of this method that modifies the substitution\n        in place.\n\n        Args:\n            variable_name:\n                The name of the variable to add.\n            replacement:\n                The substitution for the variable.\n\n        Returns:\n            The new substitution with the variable_name added or merged.\n\n        Raises:\n            ValueError:\n                if the variable cannot be merged because it conflicts with the existing\n                substitution for the variable.\n        \"\"\"\n        new_subst = Substitution(self)\n        new_subst.try_add_variable(variable, replacement)\n        return new_subst"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts the variable substitution for the given pattern and subject. This assumes that subject and pattern already match when being considered as linear. Also, they both must be :term:`syntactic`, as sequence variables cannot be handled here. All that this method does is checking whether all the substitutions for the variables can be unified. So, in case it returns ``False``, the substitution is invalid for the match. ..warning:: This method mutates the substitution and will even do so in case the extraction fails. Create a copy before using this method if you need to preserve the original substitution. Example: With an empty initial substitution and a linear pattern, the extraction will always succeed: >>> subst = Substitution() >>> subst.extract_substitution(f(a, b), f(x_, y_)) True >>> print(subst) {x \u21a6 a, y \u21a6 b} Clashing values for existing variables will fail: >>> subst.extract_substitution(b, x_) False For non-linear patterns, the extraction can also fail with an empty substitution: >>> subst = Substitution() >>> subst.extract_substitution(f(a, b), f(x_, x_)) False >>> print(subst) {x \u21a6 a} Note that the initial substitution got mutated even though the extraction failed! Args: subject: A :term:`syntactic` subject that matches the pattern. pattern: A :term:`syntactic` pattern that matches the subject. Returns: ``True`` iff the substitution could be extracted successfully.", "response": "def extract_substitution(self, subject: 'expressions.Expression', pattern: 'expressions.Expression') -> bool:\n        \"\"\"Extract the variable substitution for the given pattern and subject.\n\n        This assumes that subject and pattern already match when being considered as linear.\n        Also, they both must be :term:`syntactic`, as sequence variables cannot be handled here.\n        All that this method does is checking whether all the substitutions for the variables can be unified.\n        So, in case it returns ``False``, the substitution is invalid for the match.\n\n        ..warning::\n\n            This method mutates the substitution and will even do so in case the extraction fails.\n\n            Create a copy before using this method if you need to preserve the original substitution.\n\n        Example:\n\n            With an empty initial substitution and a linear pattern, the extraction will always succeed:\n\n            >>> subst = Substitution()\n            >>> subst.extract_substitution(f(a, b), f(x_, y_))\n            True\n            >>> print(subst)\n            {x \u21a6 a, y \u21a6 b}\n\n            Clashing values for existing variables will fail:\n\n            >>> subst.extract_substitution(b, x_)\n            False\n\n            For non-linear patterns, the extraction can also fail with an empty substitution:\n\n            >>> subst = Substitution()\n            >>> subst.extract_substitution(f(a, b), f(x_, x_))\n            False\n            >>> print(subst)\n            {x \u21a6 a}\n\n            Note that the initial substitution got mutated even though the extraction failed!\n\n        Args:\n            subject:\n                A :term:`syntactic` subject that matches the pattern.\n            pattern:\n                A :term:`syntactic` pattern that matches the subject.\n\n        Returns:\n            ``True`` iff the substitution could be extracted successfully.\n        \"\"\"\n        if getattr(pattern, 'variable_name', False):\n            try:\n                self.try_add_variable(pattern.variable_name, subject)\n            except ValueError:\n                return False\n            return True\n        elif isinstance(pattern, expressions.Operation):\n            assert isinstance(subject, type(pattern))\n            assert op_len(subject) == op_len(pattern)\n            op_expression = cast(expressions.Operation, subject)\n            for subj, patt in zip(op_iter(op_expression), op_iter(pattern)):\n                if not self.extract_substitution(subj, patt):\n                    return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new substitution that is the union of this and the others.", "response": "def union(self, *others: 'Substitution') -> 'Substitution':\n        \"\"\"Try to merge the substitutions.\n\n        If a variable occurs in multiple substitutions, try to merge the replacements.\n        See :meth:`union_with_variable` to see how replacements are merged.\n\n        Does not modify any of the original substitutions.\n\n        Example:\n\n        >>> subst1 = Substitution({'x': Multiset(['a', 'b']), 'z': a})\n        >>> subst2 = Substitution({'x': ('a', 'b'), 'y': ('c', )})\n        >>> print(subst1.union(subst2))\n        {x \u21a6 (a, b), y \u21a6 (c), z \u21a6 a}\n\n        Args:\n            others:\n                The other substitutions to merge with this one.\n\n        Returns:\n            The new substitution with the other substitutions merged.\n\n        Raises:\n            ValueError:\n                if a variable occurs in multiple substitutions but cannot be merged because the\n                substitutions conflict.\n        \"\"\"\n        new_subst = Substitution(self)\n        for other in others:\n            for variable_name, replacement in other.items():\n                new_subst.try_add_variable(variable_name, replacement)\n        return new_subst"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rename(self, renaming: Dict[str, str]) -> 'Substitution':\n        return Substitution((renaming.get(name, name), value) for name, value in self.items())", "response": "Returns a copy of the substitution with renamed variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_operation(term: Any) -> bool:\n    return isinstance(term, type) and issubclass(term, Operation)", "response": "Return True iff the given term is a subclass of Operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_symbol_wildcard(term: Any) -> bool:\n    return isinstance(term, type) and issubclass(term, Symbol)", "response": "Return True iff the given term is a subclass of Symbol."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_symbol_wildcard_label(state: '_State', symbol: Symbol) -> Type[Symbol]:\n    return next((t for t in state.keys() if is_symbol_wildcard(t) and isinstance(symbol, t)), None)", "response": "Return the transition target for the given symbol type from the given state or None if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _term_str(term: TermAtom) -> str:  # pragma: no cover\n    if is_operation(term):\n        return term.name + '('\n    elif is_symbol_wildcard(term):\n        return '*{!s}'.format(term.__name__)\n    elif isinstance(term, Wildcard):\n        return '*{!s}{!s}'.format(term.min_count, (not term.fixed_size) and '+' or '')\n    elif term == Wildcard:\n        return '*'\n    else:\n        return str(term)", "response": "Return a string representation of a term atom."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_syntactic(self):\n        for term in self._terms:\n            if isinstance(term, Wildcard) and not term.fixed_size:\n                return False\n            if is_operation(term) and issubclass(term, (AssociativeOperation, CommutativeOperation)):\n                return False\n        return True", "response": "True iff the flatterm is syntactic."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merged(cls, *flatterms: 'FlatTerm') -> 'FlatTerm':\n        return cls(cls._combined_wildcards_iter(sum(flatterms, cls.empty())))", "response": "Concatenate the given flatterms into a single flatterm."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flatterm_iter(cls, expression: Expression) -> Iterator[TermAtom]:\n        if isinstance(expression, Operation):\n            yield type(expression)\n            for operand in op_iter(expression):\n                yield from cls._flatterm_iter(operand)\n            yield OPERATION_END\n        elif isinstance(expression, SymbolWildcard):\n            yield expression.symbol_type\n        elif isinstance(expression, (Symbol, Wildcard)):\n            yield expression\n        else:\n            assert False, \"Unreachable unless a new unsupported expression type is added.\"", "response": "Generator that yields the atoms of the expressions in prefix notation with operation end markers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _combined_wildcards_iter(flatterm: Iterator[TermAtom]) -> Iterator[TermAtom]:\n        last_wildcard = None  # type: Optional[Wildcard]\n        for term in flatterm:\n            if isinstance(term, Wildcard) and not isinstance(term, SymbolWildcard):\n                if last_wildcard is not None:\n                    new_min_count = last_wildcard.min_count + term.min_count\n                    new_fixed_size = last_wildcard.fixed_size and term.fixed_size\n                    last_wildcard = Wildcard(new_min_count, new_fixed_size)\n                else:\n                    last_wildcard = Wildcard(term.min_count, term.fixed_size)\n            else:\n                if last_wildcard is not None:\n                    yield last_wildcard\n                    last_wildcard = None\n                yield term\n        if last_wildcard is not None:\n            yield last_wildcard", "response": "Combine consecutive wildcards in a flatterm into a single one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef labels(self) -> Set[TransitionLabel]:\n        labels = set()  # type: Set[TransitionLabel]\n        if self.state1 is not None and self.fixed != 1:\n            labels.update(self.state1.keys())\n        if self.state2 is not None and self.fixed != 2:\n            labels.update(self.state2.keys())\n        if self.fixed != 0:\n            if self.fixed == 1 and self.state2 is None:\n                labels.add(OPERATION_END)\n            elif self.fixed == 2 and self.state1 is None:\n                labels.add(OPERATION_END)\n            labels.add(Wildcard)\n        return labels", "response": "Return the set of transition labels to examine for this queue state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a pattern to the discrimination net.", "response": "def add(self, pattern: Union[Pattern, FlatTerm], final_label: T=None) -> int:\n        \"\"\"Add a pattern to the discrimination net.\n\n        Args:\n            pattern:\n                The pattern which is added to the DiscriminationNet. If an expression is given, it will be converted to\n                a `FlatTerm` for internal processing. You can also pass a `FlatTerm` directly.\n            final_label:\n                A label that is returned if the pattern matches when using :meth:`match`. This will default to the\n                pattern itself.\n\n        Returns:\n            The index of the newly added pattern. This is used internally to later to get the pattern and its final\n            label once a match is found.\n        \"\"\"\n        index = len(self._patterns)\n        self._patterns.append((pattern, final_label))\n        flatterm = FlatTerm(pattern.expression) if not isinstance(pattern, FlatTerm) else pattern\n        if flatterm.is_syntactic or len(flatterm) == 1:\n            net = self._generate_syntactic_net(flatterm, index)\n        else:\n            net = self._generate_net(flatterm, index)\n\n        if self._root:\n            self._root = self._product_net(self._root, net)\n        else:\n            self._root = net\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a DFA state for the given flatterm.", "response": "def _generate_net(cls, flatterm: FlatTerm, final_label: T) -> _State[T]:\n        \"\"\"Generates a DFA matching the given pattern.\"\"\"\n        # Capture the last sequence wildcard for every level of operation nesting on a stack\n        # Used to add backtracking edges in case the \"match\" fails later\n        last_wildcards = [None]\n        # Generate a fail state for every level of nesting to backtrack to a sequence wildcard in a parent Expression\n        # in case no match can be found\n        fail_states = [None]\n        operand_counts = [0]\n        root = state = _State()\n        states = {root.id: root}\n\n        for term in flatterm:\n            if operand_counts[-1] >= 0:\n                operand_counts[-1] += 1\n\n            # For wildcards, generate a chain of #min_count Wildcard edges\n            # If the wildcard is unbounded (fixed_size = False),\n            # add a wildcard self loop at the end\n            if isinstance(term, Wildcard):\n                # Generate a chain of #min_count Wildcard edges\n                for _ in range(term.min_count):\n                    state = cls._create_child_state(state, Wildcard)\n                    states[state.id] = state\n                # If it is a sequence wildcard, add a self loop\n                if not term.fixed_size:\n                    state[Wildcard] = state\n                    last_wildcards[-1] = state\n                    operand_counts[-1] = -1\n            else:\n                state = cls._create_child_state(state, term)\n                states[state.id] = state\n                if is_operation(term):\n                    fail_state = None\n                    if last_wildcards[-1] or fail_states[-1]:\n                        last_fail_state = (\n                            fail_states[-1]\n                            if not isinstance(fail_states[-1], list) else fail_states[-1][operand_counts[-1]]\n                        )\n                        if term.arity.fixed_size:\n                            fail_state = _State()\n                            states[fail_state.id] = fail_state\n                            new_fail_states = [fail_state]\n                            for _ in range(term.arity.min_count):\n                                new_fail_state = _State()\n                                states[new_fail_state.id] = new_fail_state\n                                fail_state[Wildcard] = new_fail_state\n                                fail_state = new_fail_state\n                                new_fail_states.append(new_fail_state)\n                            fail_state[OPERATION_END] = last_wildcards[-1] or last_fail_state\n                            fail_state = new_fail_states\n                        else:\n                            fail_state = _State()\n                            states[fail_state.id] = fail_state\n                            fail_state[OPERATION_END] = last_wildcards[-1] or last_fail_state\n                            fail_state[Wildcard] = fail_state\n                    fail_states.append(fail_state)\n                    last_wildcards.append(None)\n                    operand_counts.append(0)\n                elif term == OPERATION_END:\n                    fail_states.pop()\n                    last_wildcards.pop()\n                    operand_counts.pop()\n\n            if last_wildcards[-1] != state:\n                if last_wildcards[-1]:\n                    state[EPSILON] = last_wildcards[-1]\n                elif fail_states[-1]:\n                    last_fail_state = (\n                        fail_states[-1]\n                        if not isinstance(fail_states[-1], list) else fail_states[-1][operand_counts[-1]]\n                    )\n                    state[EPSILON] = last_fail_state\n\n        state.payload = [final_label]\n\n        return cls._convert_nfa_to_dfa(root, states)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match(self, subject: Union[Expression, FlatTerm]) -> Iterator[Tuple[T, Substitution]]:\n        for index in self._match(subject):\n            pattern, label = self._patterns[index]\n            subst = Substitution()\n            if subst.extract_substitution(subject, pattern.expression):\n                for constraint in pattern.constraints:\n                    if not constraint(subst):\n                        break\n                else:\n                    yield label, subst", "response": "Match the given subject against all patterns in the net."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the given subject matches any pattern in the net.", "response": "def is_match(self, subject: Union[Expression, FlatTerm]) -> bool:\n        \"\"\"Check if the given subject matches any pattern in the net.\n\n        Args:\n            subject:\n                The subject that is matched. Must be constant.\n\n        Returns:\n            True, if any pattern matches the subject.\n        \"\"\"\n        try:\n            next(self.match(subject))\n        except StopIteration:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering the discrimination net as graphviz digraph.", "response": "def as_graph(self) -> Digraph:  # pragma: no cover\n        \"\"\"Renders the discrimination net as graphviz digraph.\"\"\"\n        if Digraph is None:\n            raise ImportError('The graphviz package is required to draw the graph.')\n        dot = Digraph()\n\n        nodes = set()\n        queue = [self._root]\n        while queue:\n            state = queue.pop(0)\n            if not state.payload:\n                dot.node('n{!s}'.format(state.id), '', {'shape': ('circle' if state else 'doublecircle')})\n            else:\n                dot.node('n{!s}'.format(state.id), '\\n'.join(map(str, state.payload)), {'shape': 'box'})\n\n            for next_state in state.values():\n                if next_state.id not in nodes:\n                    queue.append(next_state)\n                    nodes.add(state.id)\n\n        nodes = set()\n        queue = [self._root]\n        while queue:\n            state = queue.pop(0)\n            if state.id in nodes:\n                continue\n            nodes.add(state.id)\n\n            for (label, other) in state.items():\n                dot.edge('n{!s}'.format(state.id), 'n{!s}'.format(other.id), _term_str(label))\n                if other.id not in nodes:\n                    queue.append(other)\n\n        return dot"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, pattern: Pattern) -> int:\n        inner = pattern.expression\n        if self.operation is None:\n            if not isinstance(inner, Operation) or isinstance(inner, CommutativeOperation):\n                raise TypeError(\"Pattern must be a non-commutative operation.\")\n            self.operation = type(inner)\n        elif not isinstance(inner, self.operation):\n            raise TypeError(\n                \"All patterns must be the same operation, expected {} but got {}\".format(self.operation, type(inner))\n            )\n\n        if op_len(inner) < 3:\n            raise ValueError(\"Pattern has not enough operands.\")\n\n        operands = list(op_iter(inner))\n\n        first_name = self._check_wildcard_and_get_name(operands[0])\n        last_name = self._check_wildcard_and_get_name(operands[-1])\n\n        index = len(self._patterns)\n        self._patterns.append((pattern, first_name, last_name))\n\n        flatterm = FlatTerm.merged(*(FlatTerm(o) for o in operands[1:-1]))\n        self._net.add(flatterm, index)\n\n        return index", "response": "Adds a pattern that will be recognized by the matcher."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a pattern can be matched with a sequence matcher.", "response": "def can_match(cls, pattern: Pattern) -> bool:\n        \"\"\"Check if a pattern can be matched with a sequence matcher.\n\n        Args:\n            pattern:\n                The pattern to check.\n\n        Returns:\n            True, iff the pattern can be matched with a sequence matcher.\n        \"\"\"\n        if not isinstance(pattern.expression, Operation) or isinstance(pattern.expression, CommutativeOperation):\n            return False\n\n        if op_len(pattern.expression) < 3:\n            return False\n\n        first, *_, last = op_iter(pattern.expression)\n\n        try:\n            cls._check_wildcard_and_get_name(first)\n            cls._check_wildcard_and_get_name(last)\n        except ValueError:\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match(self, subject: Expression) -> Iterator[Tuple[Pattern, Substitution]]:\n        if not isinstance(subject, self.operation):\n            return\n\n        subjects = list(op_iter(subject))\n        flatterms = [FlatTerm(o) for o in subjects]\n\n        for i in range(len(flatterms)):\n            flatterm = FlatTerm.merged(*flatterms[i:])\n\n            for index in self._net._match(flatterm, collect=True):\n                match_index = self._net._patterns[index][1]\n                pattern, first_name, last_name = self._patterns[match_index]\n                operand_count = op_len(pattern.expression) - 2\n                expr_operands = subjects[i:i + operand_count]\n                patt_operands = list(op_iter(pattern.expression))[1:-1]\n\n                substitution = Substitution()\n                if not all(itertools.starmap(substitution.extract_substitution, zip(expr_operands, patt_operands))):\n                    continue\n\n                try:\n                    if first_name is not None:\n                        substitution.try_add_variable(first_name, tuple(subjects[:i]))\n                    if last_name is not None:\n                        substitution.try_add_variable(last_name, tuple(subjects[i + operand_count:]))\n                except ValueError:\n                    continue\n\n                for constraint in pattern.constraints:\n                    if not constraint(substitution):\n                        break\n                else:\n                    yield pattern, substitution", "response": "Match the given subject against all patterns in the sequence matcher."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(subject: Expression, pattern: Pattern) -> Iterator[Substitution]:\n    if not is_constant(subject):\n        raise ValueError(\"The subject for matching must be constant.\")\n    global_constraints = [c for c in pattern.constraints if not c.variables]\n    local_constraints = set(c for c in pattern.constraints if c.variables)\n    for subst in _match([subject], pattern.expression, Substitution(), local_constraints):\n        for constraint in global_constraints:\n            if not constraint(subst):\n                break\n        else:\n            yield subst", "response": "r Returns an iterator over the possible match substitutions for the given subject and pattern."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_anywhere(subject: Expression, pattern: Pattern) -> Iterator[Tuple[Substitution, Tuple[int, ...]]]:\n    if not is_constant(subject):\n        raise ValueError(\"The subject for matching must be constant.\")\n    for child, pos in preorder_iter_with_position(subject):\n        if match_head(child, pattern):\n            for subst in match(child, pattern):\n                yield subst, pos", "response": "Tries to match the given pattern to the any subexpression of the given subject."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a list of subjects and an operation that is partitoning for the variable part of the operands. Given a partitoning for the variable part of the operands. Given a partitoning for the optional parts each pattern gets assigned.", "response": "def _build_full_partition(\n        optional_parts, sequence_var_partition: Sequence[int], subjects: Sequence[Expression], operation: Operation\n) -> List[Sequence[Expression]]:\n    \"\"\"Distribute subject operands among pattern operands.\n\n    Given a partitoning for the variable part of the operands (i.e. a list of how many extra operands each sequence\n    variable gets assigned).\n    \"\"\"\n    i = 0\n    var_index = 0\n    opt_index = 0\n    result = []\n    for operand in op_iter(operation):\n        wrap_associative = False\n        if isinstance(operand, Wildcard):\n            count = operand.min_count if operand.optional is None else 0\n            if not operand.fixed_size or isinstance(operation, AssociativeOperation):\n                count += sequence_var_partition[var_index]\n                var_index += 1\n                wrap_associative = operand.fixed_size and operand.min_count\n            elif operand.optional is not None:\n                count = optional_parts[opt_index]\n                opt_index += 1\n        else:\n            count = 1\n\n        operand_expressions = list(op_iter(subjects))[i:i + count]\n        i += count\n\n        if wrap_associative and len(operand_expressions) > wrap_associative:\n            fixed = wrap_associative - 1\n            operand_expressions = tuple(operand_expressions[:fixed]) + (\n                create_operation_expression(operation, operand_expressions[fixed:]),\n            )\n\n        result.append(operand_expressions)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef grouped(self):\n        for _ in self._match(self.matcher.root):\n            yield list(self._internal_iter())", "response": "Yields the matches grouped by their final state in the automaton."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new pattern to the matcher.", "response": "def add(self, pattern: Pattern, label=None) -> None:\n        \"\"\"Add a new pattern to the matcher.\n\n        The optional label defaults to the pattern itself and is yielded during matching. The same pattern can be\n        added with different labels which means that every match for the pattern will result in every associated label\n        being yielded with that match individually.\n\n        Equivalent patterns with the same label are not added again. However, patterns that are structurally equivalent,\n        but have different constraints or different variable names are distinguished by the matcher.\n\n        Args:\n            pattern:\n                The pattern to add.\n            label:\n                An optional label for the pattern. Defaults to the pattern itself.\n        \"\"\"\n        if label is None:\n            label = pattern\n        for i, (p, l, _) in enumerate(self.patterns):\n            if pattern == p and label == l:\n                return i\n        # TODO: Avoid renaming in the pattern, use variable indices instead\n        renaming = self._collect_variable_renaming(pattern.expression) if self.rename else {}\n        self._internal_add(pattern, label, renaming)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new pattern to the matcher.", "response": "def _internal_add(self, pattern: Pattern, label, renaming) -> int:\n        \"\"\"Add a new pattern to the matcher.\n\n        Equivalent patterns are not added again. However, patterns that are structurally equivalent,\n        but have different constraints or different variable names are distinguished by the matcher.\n\n        Args:\n            pattern: The pattern to add.\n\n        Returns:\n            The internal id for the pattern. This is mainly used by the :class:`CommutativeMatcher`.\n        \"\"\"\n        pattern_index = len(self.patterns)\n        renamed_constraints = [c.with_renamed_vars(renaming) for c in pattern.local_constraints]\n        constraint_indices = [self._add_constraint(c, pattern_index) for c in renamed_constraints]\n        self.patterns.append((pattern, label, constraint_indices))\n        self.pattern_vars.append(renaming)\n        pattern = rename_variables(pattern.expression, renaming)\n        state = self.root\n        patterns_stack = [deque([pattern])]\n\n        self._process_pattern_stack(state, patterns_stack, renamed_constraints, pattern_index)\n\n        return pattern_index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef match(self, subject: Expression) -> Iterator[Tuple[Expression, Substitution]]:\n        return _MatchIter(self, subject)", "response": "Match the subject against all the patterns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _collect_variable_renaming(\n            cls, expression: Expression, position: List[int]=None, variables: Dict[str, str]=None\n    ) -> Dict[str, str]:\n        \"\"\"Return renaming for the variables in the expression.\n\n        The variable names are generated according to the position of the variable in the expression. The goal is to\n        rename variables in structurally identical patterns so that the automaton contains less redundant states.\n        \"\"\"\n        if position is None:\n            position = [0]\n        if variables is None:\n            variables = {}\n        if getattr(expression, 'variable_name', False):\n            if expression.variable_name not in variables:\n                variables[expression.variable_name] = cls._get_name_for_position(position, variables.values())\n        position[-1] += 1\n        if isinstance(expression, Operation):\n            if isinstance(expression, CommutativeOperation):\n                for operand in op_iter(expression):\n                    position.append(0)\n                    cls._collect_variable_renaming(operand, position, variables)\n                    position.pop()\n            else:\n                for operand in op_iter(expression):\n                    cls._collect_variable_renaming(operand, position, variables)\n\n        return variables", "response": "Return renaming for the variables in the expression."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new rule to the replacer.", "response": "def add(self, rule: 'functions.ReplacementRule') -> None:\n        \"\"\"Add a new rule to the replacer.\n\n        Args:\n            rule:\n                The rule to add.\n        \"\"\"\n        self.matcher.add(rule.pattern, rule.replacement)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace(self, expression: Expression, max_count: int=math.inf) -> Union[Expression, Sequence[Expression]]:\n        replaced = True\n        replace_count = 0\n        while replaced and replace_count < max_count:\n            replaced = False\n            for subexpr, pos in preorder_iter_with_position(expression):\n                try:\n                    replacement, subst = next(iter(self.matcher.match(subexpr)))\n                    result = replacement(**subst)\n                    expression = functions.replace(expression, pos, result)\n                    replaced = True\n                    break\n                except StopIteration:\n                    pass\n            replace_count += 1\n        return expression", "response": "Replaces all occurrences of the patterns according to the replacement rules."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_post_order(self, expression: Expression) -> Union[Expression, Sequence[Expression]]:\n        return self._replace_post_order(expression)[0]", "response": "Replaces all occurrences of the patterns according to the replacement rules."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bipartite_as_graph(self) -> Graph:  # pragma: no cover\n        if Graph is None:\n            raise ImportError('The graphviz package is required to draw the graph.')\n        graph = Graph()\n        nodes_left = {}  # type: Dict[TLeft, str]\n        nodes_right = {}  # type: Dict[TRight, str]\n        node_id = 0\n        for (left, right), value in self.bipartite._edges.items():\n            if left not in nodes_left:\n                name = 'node{:d}'.format(node_id)\n                nodes_left[left] = name\n                label = str(self.subjects_by_id[left])\n                graph.node(name, label=label)\n                node_id += 1\n            if right not in nodes_right:\n                name = 'node{:d}'.format(node_id)\n                nodes_right[right] = name\n                label = str(self.automaton.patterns[right][0])\n                graph.node(name, label=label)\n                node_id += 1\n            edge_label = value is not True and str(value) or ''\n            graph.edge(nodes_left[left], nodes_right[right], edge_label)\n        return graph", "response": "Returns a graphviz. Graph representation of this bipartite."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a graphviz. Graph representation of this bipartite.", "response": "def concrete_bipartite_as_graph(self, subjects, patterns) -> Graph:  # pragma: no cover\n        \"\"\"Returns a :class:`graphviz.Graph` representation of this bipartite graph.\"\"\"\n        if Graph is None:\n            raise ImportError('The graphviz package is required to draw the graph.')\n        bipartite = self._build_bipartite(subjects, patterns)\n        graph = Graph()\n        nodes_left = {}  # type: Dict[TLeft, str]\n        nodes_right = {}  # type: Dict[TRight, str]\n        node_id = 0\n        for (left, right), value in bipartite._edges.items():\n            if left not in nodes_left:\n                subject_id, i = left\n                name = 'node{:d}'.format(node_id)\n                nodes_left[left] = name\n                label = '{}, {}'.format(i, self.subjects_by_id[subject_id])\n                graph.node(name, label=label)\n                node_id += 1\n            if right not in nodes_right:\n                pattern, i = right\n                name = 'node{:d}'.format(node_id)\n                nodes_right[right] = name\n                label = '{}, {}'.format(i, self.automaton.patterns[pattern][0])\n                graph.node(name, label=label)\n                node_id += 1\n            edge_label = value is not True and str(value) or ''\n            graph.edge(nodes_left[left], nodes_right[right], edge_label)\n        return graph"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collect_variables(self, variables: MultisetOfVariables) -> None:\n        if self.variable_name is not None:\n            variables.add(self.variable_name)", "response": "Recursively adds all variables occuring in the expression to the given multiset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _simplify(cls, operands: List[Expression]) -> bool:\n\n        if cls.associative:\n            new_operands = []  # type: List[Expression]\n            for operand in operands:\n                if isinstance(operand, cls):\n                    new_operands.extend(operand.operands)  # type: ignore\n                else:\n                    new_operands.append(operand)\n            operands.clear()\n            operands.extend(new_operands)\n\n        if cls.one_identity and len(operands) == 1:\n            expr = operands[0]\n            if not isinstance(expr, Wildcard) or (expr.min_count == 1 and expr.fixed_size):\n                return True\n\n        if cls.commutative:\n            operands.sort()\n\n        return False", "response": "Flatten the operands of associative or commutative operations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new(\n            name: str,\n            arity: Arity,\n            class_name: str=None,\n            *,\n            associative: bool=False,\n            commutative: bool=False,\n            one_identity: bool=False,\n            infix: bool=False\n    ) -> Type['Operation']:\n        \"\"\"Utility method to create a new operation type.\n\n        Example:\n\n        >>> Times = Operation.new('*', Arity.polyadic, 'Times', associative=True, commutative=True, one_identity=True)\n        >>> Times\n        Times['*', Arity(min_count=2, fixed_size=False), associative, commutative, one_identity]\n        >>> str(Times(Symbol('a'), Symbol('b')))\n        '*(a, b)'\n\n        Args:\n            name:\n                Name or symbol for the operator. Will be used as name for the new class if\n                `class_name` is not specified.\n            arity:\n                The arity of the operator as explained in the documentation of `Operation`.\n            class_name:\n                Name for the new operation class to be used instead of name. This argument\n                is required if `name` is not a valid python identifier.\n\n        Keyword Args:\n            associative:\n                See :attr:`~Operation.associative`.\n            commutative:\n                See :attr:`~Operation.commutative`.\n            one_identity:\n                See :attr:`~Operation.one_identity`.\n            infix:\n                See :attr:`~Operation.infix`.\n\n        Raises:\n            ValueError: if the class name of the operation is not a valid class identifier.\n        \"\"\"\n        class_name = class_name or name\n        if not class_name.isidentifier() or keyword.iskeyword(class_name):\n            raise ValueError(\"Invalid identifier for new operator class.\")\n\n        return type(\n            class_name, (Operation, ), {\n                'name': name,\n                'arity': arity,\n                'associative': associative,\n                'commutative': commutative,\n                'one_identity': one_identity,\n                'infix': infix\n            }\n        )", "response": "Utility method to create a new operation type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a Wildcard that matches a single argument with a default value.", "response": "def optional(name, default) -> 'Wildcard':\n        \"\"\"Create a `Wildcard` that matches a single argument with a default value.\n\n        If the wildcard does not match, the substitution will contain the\n        default value instead.\n\n        Args:\n            name:\n                The name for the wildcard.\n            default:\n                The default value of the wildcard.\n\n        Returns:\n            A n optional wildcard.\n        \"\"\"\n        return Wildcard(min_count=1, fixed_size=True, variable_name=name, optional=default)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef symbol(name: str=None, symbol_type: Type[Symbol]=Symbol) -> 'SymbolWildcard':\n        if isinstance(name, type) and issubclass(name, Symbol) and symbol_type is Symbol:\n            return SymbolWildcard(name)\n        return SymbolWildcard(symbol_type, variable_name=name)", "response": "Create a SymbolWildcard that matches a single Symbol argument."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_response(resp):\n        if resp.status_code in [200, 201, 202]:\n            return resp.json()\n        elif resp.status_code == 204:\n            return None\n        elif resp.status_code == 400:\n            raise error.BadRequestError(resp.text)\n        elif resp.status_code == 401:\n            raise error.UnauthorizedError(resp.text)\n        elif resp.status_code == 403:\n            raise error.ForbiddenError(resp.text)\n        elif resp.status_code == 404:\n            raise error.NotFoundError(resp.text)\n        elif resp.status_code == 429:\n            raise error.TooManyRequestsError(resp.text)\n        elif resp.status_code == 503:\n            raise error.ServiceUnavailableError(resp.text)\n        else:\n            raise error.OptimizelyError(resp.text)", "response": "Method to parse the response from the Optimizely API and return the result as JSON."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert python data structures to R equivalents", "response": "def _to_r(o, as_data=False, level=0):\n    \"\"\"Helper function to convert python data structures to R equivalents\n\n    TODO: a single model for transforming to r to handle\n    * function args\n    * lists as function args\n    \"\"\"\n    if o is None:\n        return \"NA\"\n    if isinstance(o, basestring):\n        return o\n    if hasattr(o, \"r\"):\n        # bridge to @property r on GGStatement(s)\n        return o.r\n    elif isinstance(o, bool):\n        return \"TRUE\" if o else \"FALSE\"\n    elif isinstance(o, (list, tuple)):\n        inner = \",\".join([_to_r(x, True, level+1) for x in o])\n        return \"c({})\".format(inner) if as_data else inner\n    elif isinstance(o, dict):\n        inner = \",\".join([\"{}={}\".format(k, _to_r(v, True, level+1))\n                         for k, v in sorted(o.iteritems(), key=lambda x: x[0])])\n        return \"list({})\".format(inner) if as_data else inner\n    return str(o)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data_sql(db, sql):\n    if not db:\n        if sql:\n            print \"ERR: -db option must be set if using -sql\"\n        return \"\"\n\n    cmd = \"\"\"\n    library(RPostgreSQL)\n    drv = dbDriver('PostgreSQL')\n    con = dbConnect(drv, dbname='%(db_name)s')\n    q = \"%(query)s\"\n    data = dbGetQuery(con, q)\n    \"\"\"\n\n    return GGData(cmd % {\n        'db_name': db,\n        'query': sql\n    })", "response": "Load file using RPostgreSQL"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ggsave(name, plot, data=None, *args, **kwargs):\n    # constants\n    kwdefaults = {\n        'width': 10,\n        'height': 8,\n        'scale': 1\n    }\n    keys_to_rm = [\"prefix\", \"quiet\", \"postfix\", 'libs']\n    varname = 'p'\n\n    # process arguments\n    prefix = kwargs.get('prefix', '')\n    postfix = kwargs.get('postfix', '')\n    libs = kwargs.get('libs', [])\n    libs = '\\n'.join([\"library(%s)\" % lib for lib in libs])\n    quiet = kwargs.get(\"quiet\", False)\n    kwargs = {k: v for k, v in kwargs.iteritems()\n              if v is not None and k not in keys_to_rm}\n    kwdefaults.update(kwargs)\n    kwargs = kwdefaults\n\n    # figure out how to load data in the R environment\n    if data is None: data = plot.data\n\n    if data is None:\n        # Don't load anything, the data source is already present in R\n        data_src = ''\n    elif isinstance(data, basestring) and 'RPostgreSQL' in data:\n        # Hack to allow through data_sql results\n        data_src = data\n    elif isinstance(data, GGData):\n        data_src = str(data)\n    else:\n        # format the python data object\n        data_src = str(data_py(data))\n\n    prog = \"%(header)s\\n%(libs)s\\n%(prefix)s\\n%(data)s\\n%(postfix)s\\n%(varname)s = %(prog)s\" % {\n        'header': \"library(ggplot2)\",\n        'libs': libs,\n        'data': data_src,\n        'prefix': prefix,\n        'postfix': postfix,\n        'varname': varname,\n        'prog': plot.r\n    }\n\n    if name:\n        stmt = GGStatement(\"ggsave\", esc(name), varname, *args, **kwargs)\n        prog = \"%s\\n%s\" % (prog, stmt.r)\n\n    if not quiet:\n        print prog\n        print\n\n    if name:\n        execute_r(prog, quiet)\n    return prog", "response": "Save a GGStatements object to a new name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering pygg in an IPython notebook and return a ggplot2 image.", "response": "def gg_ipython(plot, data, width=IPYTHON_IMAGE_SIZE, height=None,\n               *args, **kwargs):\n    \"\"\"Render pygg in an IPython notebook\n\n    Allows one to say things like:\n\n    import pygg\n    p = pygg.ggplot('diamonds', pygg.aes(x='carat', y='price', color='clarity'))\n    p += pygg.geom_point(alpha=0.5, size = 2)\n    p += pygg.scale_x_log10(limits=[1, 2])\n    pygg.gg_ipython(p, data=None, quiet=True)\n\n    directly in an IPython notebook and see the resulting ggplot2 image\n    displayed inline.  This function is print a warning if the IPython library\n    cannot be imported.  The ggplot2 image is rendered as a PNG and not\n    as a vectorized graphics object right now.\n\n    Note that by default gg_ipython sets the output height and width to\n    IPYTHON_IMAGE_SIZE pixels as this is a reasonable default size for a\n    browser-based notebook.  Height is by default None, indicating that height\n    should be set to the same value as width.  It is possible to adjust\n    the aspect ratio of the output by providing non-None values for both\n    width and height\n\n    \"\"\"\n    try:\n        import IPython.display\n        tmp_image_filename = tempfile.NamedTemporaryFile(suffix='.jpg').name\n        # Quiet by default\n        kwargs['quiet'] = kwargs.get('quiet', True)\n\n        if width is None:\n            raise ValueError(\"Width cannot be None\")\n        height = height or width\n        w_in, h_in = size_r_img_inches(width, height)\n        ggsave(name=tmp_image_filename, plot=plot, data=data,\n               dpi=600, width=w_in, height=h_in, units=esc('in'),\n               *args, **kwargs)\n        return IPython.display.Image(filename=tmp_image_filename,\n                                     width=width, height=height)\n    except ImportError:\n        print \"Could't load IPython library; integration is disabled\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the width and height for an R image for display in IPython", "response": "def size_r_img_inches(width, height):\n    \"\"\"Compute the width and height for an R image for display in IPython\n\n    Neight width nor height can be null but should be integer pixel values > 0.\n\n    Returns a tuple of (width, height) that should be used by ggsave in R to\n    produce an appropriately sized jpeg/png/pdf image with the right aspect\n    ratio.  The returned values are in inches.\n\n    \"\"\"\n    # both width and height are given\n    aspect_ratio = height / (1.0 * width)\n    return R_IMAGE_SIZE, round(aspect_ratio * R_IMAGE_SIZE, 2)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_r(prog, quiet):\n    FNULL = open(os.devnull, 'w') if quiet else None\n    try:\n        input_proc = subprocess.Popen([\"echo\", prog], stdout=subprocess.PIPE)\n        status = subprocess.call(\"R --no-save --quiet\",\n                                 stdin=input_proc.stdout,\n                                 stdout=FNULL,\n                                 stderr=subprocess.STDOUT,\n                                 shell=True) # warning, this is a security problem\n        if status != 0:\n            raise ValueError(\"ggplot2 bridge failed for program: {}.\"\n                             \" Check for an error\".format(prog))\n    finally:\n        if FNULL is not None:\n            FNULL.close()", "response": "Execute the R code prog an R subprocess and return a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef axis_labels(xtitle, \n                ytitle, \n                xsuffix=\"continuous\", \n                ysuffix=\"continuous\",\n                xkwargs={},\n                ykwargs={}):\n  \"\"\"\n  Helper function to create reasonable axis labels\n\n  @param xtitle String for the title of the X axis.  Automatically escaped\n  @param ytitle String for the title of the Y axis.  Automatically escaped\n  @param xsuffix Suffix string appended to \"scales_x_\" to define the type of x axis\n                 Default: \"continuous\"\n  @param ysuffix Suffix string appended to \"scales_y_\" to define the type of y axis\n                 Default: \"continuous\"\n  @param xkwargs keyword arguments to pass to scales_x_* function\n  @param xkwargs keyword arguments to pass to scales_x_* function\n  @return GGStatements\n\n  For example:\n    \n      p = ggplot(...)\n      p += axis_labels(\"Dataset Size (MB)\", \n                       \"Latency (sec)\", \n                       \"log10\",  \n                       xkwargs=dict(breaks=[0, 10, 100, 5000]))\n\n  \"\"\"\n\n  exec \"xfunc = scale_x_%s\" % xsuffix\n  exec \"yfunc = scale_y_%s\" % ysuffix\n  return (\n    xfunc(name=esc(xtitle), **xkwargs) + \n    yfunc(name=esc(ytitle), **ykwargs)\n  )", "response": "Returns GGStatements for the basic axis labels."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_master_binding():\n  ggplot = make_ggplot2_binding(\"ggplot\")\n  def _ggplot(data, *args, **kwargs):\n    data_var = data\n    if not isinstance(data, basestring):\n      data_var = \"data\"\n    else:\n      data = None\n    stmt = ggplot(data_var, *args, **kwargs)\n    stmt.data = data\n    return stmt\n  return _ggplot", "response": "wrap around ggplot call to handle passed in data objects\n \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert this GGStatement into its R equivalent expression", "response": "def r(self):\n        \"\"\"Convert this GGStatement into its R equivalent expression\"\"\"\n        r_args = [_to_r(self.args), _to_r(self.kwargs)]\n        # remove empty strings from the call args\n        r_args = \",\".join([x for x in r_args if x != \"\"])\n        return \"{}({})\".format(self.name, r_args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode(precision, with_z):\n    logger = logging.getLogger('geobuf')\n    stdin = click.get_text_stream('stdin')\n    sink = click.get_binary_stream('stdout')\n    try:\n        data = json.load(stdin)\n        pbf = geobuf.encode(\n            data,\n            precision if precision >= 0 else 6,\n            3 if with_z else 2)\n        sink.write(pbf)\n        sys.exit(0)\n    except Exception:\n        logger.exception(\"Failed. Exception caught\")\n        sys.exit(1)", "response": "Given GeoJSON on stdin writes a geobuf file to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decode():\n    logger = logging.getLogger('geobuf')\n    stdin = click.get_binary_stream('stdin')\n    sink = click.get_text_stream('stdout')\n    try:\n        pbf = stdin.read()\n        data = geobuf.decode(pbf)\n        json.dump(data, sink)\n        sys.exit(0)\n    except Exception:\n        logger.exception(\"Failed. Exception caught\")\n        sys.exit(1)", "response": "Given a Geobuf byte string on stdin write a GeoJSON feature\n    collection to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding an integer into a string preserving order.", "response": "def encode_int(code, bits_per_char=6):\n    \"\"\"Encode int into a string preserving order\n\n    It is using 2, 4 or 6 bits per coding character (default 6).\n\n    Parameters:\n        code: int           Positive integer.\n        bits_per_char: int  The number of bits per coding character.\n\n    Returns:\n        str: the encoded integer\n    \"\"\"\n    if code < 0:\n        raise ValueError('Only positive ints are allowed!')\n\n    if bits_per_char == 6:\n        return _encode_int64(code)\n    if bits_per_char == 4:\n        return _encode_int16(code)\n    if bits_per_char == 2:\n        return _encode_int4(code)\n\n    raise ValueError('`bits_per_char` must be in {6, 4, 2}')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode string into int assuming encoding with encode_int", "response": "def decode_int(tag, bits_per_char=6):\n    \"\"\"Decode string into int assuming encoding with `encode_int()`\n\n    It is using 2, 4 or 6 bits per coding character (default 6).\n\n    Parameters:\n        tag: str           Encoded integer.\n        bits_per_char: int  The number of bits per coding character.\n\n    Returns:\n        int: the decoded string\n    \"\"\"\n    if bits_per_char == 6:\n        return _decode_int64(tag)\n    if bits_per_char == 4:\n        return _decode_int16(tag)\n    if bits_per_char == 2:\n        return _decode_int4(tag)\n\n    raise ValueError('`bits_per_char` must be in {6, 4, 2}')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a lng lat position as a geohash using a hilbert curve.", "response": "def encode(lng, lat, precision=10, bits_per_char=6):\n    \"\"\"Encode a lng/lat position as a geohash using a hilbert curve\n\n    This function encodes a lng/lat coordinate to a geohash of length `precision`\n    on a corresponding a hilbert curve. Each character encodes `bits_per_char` bits\n    per character (allowed are 2, 4 and 6 bits [default 6]). Hence, the geohash encodes\n    the lng/lat coordinate using `precision` * `bits_per_char` bits. The number of\n    bits devided by 2 give the level of the used hilbert curve, e.g. precision=10, bits_per_char=6\n    (default values) use 60 bit and a level 30 hilbert curve to map the globe.\n\n    Parameters:\n        lng: float          Longitude; between -180.0 and 180.0; WGS 84\n        lat: float          Latitude; between -90.0 and 90.0; WGS 84\n        precision: int      The number of characters in a geohash\n        bits_per_char: int  The number of bits per coding character\n\n    Returns:\n        str: geohash for lng/lat of length `precision`\n    \"\"\"\n    assert _LNG_INTERVAL[0] <= lng <= _LNG_INTERVAL[1]\n    assert _LAT_INTERVAL[0] <= lat <= _LAT_INTERVAL[1]\n    assert precision > 0\n    assert bits_per_char in (2, 4, 6)\n\n    bits = precision * bits_per_char\n    level = bits >> 1\n    dim = 1 << level\n\n    x, y = _coord2int(lng, lat, dim)\n\n    if CYTHON_AVAILABLE and bits <= MAX_BITS:\n        code = xy2hash_cython(x, y, dim)\n    else:\n        code = _xy2hash(x, y, dim)\n\n    return encode_int(code, bits_per_char).rjust(precision, '0')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecodes a geohash on a hilbert curve as a lng lat position.", "response": "def decode(code, bits_per_char=6):\n    \"\"\"Decode a geohash on a hilbert curve as a lng/lat position\n\n    Decodes the geohash `code` as a lng/lat position. It assumes, that\n    the length of `code` corresponds to the precision! And that each character\n    in `code` encodes `bits_per_char` bits. Do not mix geohashes with different\n    `bits_per_char`!\n\n    Parameters:\n        code: str           The geohash to decode.\n        bits_per_char: int  The number of bits per coding character\n\n    Returns:\n        Tuple[float, float]:  (lng, lat) coordinate for the geohash.\n    \"\"\"\n    assert bits_per_char in (2, 4, 6)\n\n    if len(code) == 0:\n        return 0., 0.\n\n    lng, lat, _lng_err, _lat_err = decode_exactly(code, bits_per_char)\n    return lng, lat"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_exactly(code, bits_per_char=6):\n    assert bits_per_char in (2, 4, 6)\n\n    if len(code) == 0:\n        return 0., 0., _LNG_INTERVAL[1], _LAT_INTERVAL[1]\n\n    bits = len(code) * bits_per_char\n    level = bits >> 1\n    dim = 1 << level\n\n    code_int = decode_int(code, bits_per_char)\n    if CYTHON_AVAILABLE and bits <= MAX_BITS:\n        x, y = hash2xy_cython(code_int, dim)\n    else:\n        x, y = _hash2xy(code_int, dim)\n\n    lng, lat = _int2coord(x, y, dim)\n    lng_err, lat_err = _lvl_error(level)  # level of hilbert curve is bits / 2\n\n    return lng + lng_err, lat + lat_err, lng_err, lat_err", "response": "Decodes a geohash on a hilbert curve as a lng lat - error position with error - marginss."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _coord2int(lng, lat, dim):\n    assert dim >= 1\n\n    lat_y = (lat + _LAT_INTERVAL[1]) / 180.0 * dim   # [0 ... dim)\n    lng_x = (lng + _LNG_INTERVAL[1]) / 360.0 * dim  # [0 ... dim)\n\n    return min(dim - 1, int(floor(lng_x))), min(dim - 1, int(floor(lat_y)))", "response": "Convert lon lat values into a dim x dim - grid coordinate system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert x y values in dim x dim - grid coordinate system into lng lat values.", "response": "def _int2coord(x, y, dim):\n    \"\"\"Convert x, y values in dim x dim-grid coordinate system into lng, lat values.\n\n    Parameters:\n        x: int        x value of point [0, dim); corresponds to longitude\n        y: int        y value of point [0, dim); corresponds to latitude\n        dim: int      Number of coding points each x, y value can take.\n                      Corresponds to 2^level of the hilbert curve.\n\n    Returns:\n        Tuple[float, float]: (lng, lat)\n            lng    longitude value of coordinate [-180.0, 180.0]; corresponds to X axis\n            lat    latitude value of coordinate [-90.0, 90.0]; corresponds to Y axis\n    \"\"\"\n    assert dim >= 1\n    assert x < dim\n    assert y < dim\n\n    lng = x / dim * 360 - 180\n    lat = y / dim * 180 - 90\n\n    return lng, lat"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert x y value to hashcode.", "response": "def _xy2hash(x, y, dim):\n    \"\"\"Convert (x, y) to hashcode.\n\n    Based on the implementation here:\n        https://en.wikipedia.org/w/index.php?title=Hilbert_curve&oldid=797332503\n\n    Pure python implementation.\n\n    Parameters:\n        x: int        x value of point [0, dim) in dim x dim coord system\n        y: int        y value of point [0, dim) in dim x dim coord system\n        dim: int      Number of coding points each x, y value can take.\n                      Corresponds to 2^level of the hilbert curve.\n\n    Returns:\n        int: hashcode  \u2208 [0, dim**2)\n    \"\"\"\n    d = 0\n    lvl = dim >> 1\n    while (lvl > 0):\n        rx = int((x & lvl) > 0)\n        ry = int((y & lvl) > 0)\n        d += lvl * lvl * ((3 * rx) ^ ry)\n        x, y = _rotate(lvl, x, y, rx, ry)\n        lvl >>= 1\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _hash2xy(hashcode, dim):\n    assert(hashcode <= dim * dim - 1)\n    x = y = 0\n    lvl = 1\n    while (lvl < dim):\n        rx = 1 & (hashcode >> 1)\n        ry = 1 & (hashcode ^ rx)\n        x, y = _rotate(lvl, x, y, rx, ry)\n        x += lvl * rx\n        y += lvl * ry\n        hashcode >>= 2\n        lvl <<= 1\n    return x, y", "response": "Convert a hashcode to x y."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrotate and flip a quadrant appropriately", "response": "def _rotate(n, x, y, rx, ry):\n    \"\"\"Rotate and flip a quadrant appropriately\n\n    Based on the implementation here:\n        https://en.wikipedia.org/w/index.php?title=Hilbert_curve&oldid=797332503\n\n    \"\"\"\n    if ry == 0:\n        if rx == 1:\n            x = n - 1 - x\n            y = n - 1 - y\n        return y, x\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the neighbours of a geohash.", "response": "def neighbours(code, bits_per_char=6):\n    \"\"\"Get the neighbouring geohashes for `code`.\n\n    Look for the north, north-east, east, south-east, south, south-west, west,\n    north-west neighbours. If you are at the east/west edge of the grid\n    (lng \u2208 (-180, 180)), then it wraps around the globe and gets the corresponding\n    neighbor.\n\n    Parameters:\n        code: str           The geohash at the center.\n        bits_per_char: int  The number of bits per coding character.\n\n    Returns:\n        dict: geohashes in the neighborhood of `code`. Possible keys are 'north',\n            'north-east', 'east', 'south-east', 'south', 'south-west',\n            'west', 'north-west'. If the input code covers the north pole, then\n            keys 'north', 'north-east', and 'north-west' are not present, and if\n            the input code covers the south pole then keys 'south', 'south-west',\n            and 'south-east' are not present.\n    \"\"\"\n    lng, lat, lng_err, lat_err = decode_exactly(code, bits_per_char)\n    precision = len(code)\n\n    north = lat + 2 * lat_err\n\n    south = lat - 2 * lat_err\n\n    east = lng + 2 * lng_err\n    if east > 180:\n        east -= 360\n\n    west = lng - 2 * lng_err\n    if west < -180:\n        west += 360\n\n    neighbours_dict = {\n        'east': encode(east, lat,   precision, bits_per_char),  # noqa: E241\n        'west': encode(west, lat,   precision, bits_per_char),  # noqa: E241\n    }\n\n    if north <= 90:  # input cell not already at the north pole\n        neighbours_dict.update({\n            'north':      encode(lng,  north, precision, bits_per_char),  # noqa: E241\n            'north-east': encode(east, north, precision, bits_per_char),  # noqa: E241\n            'north-west': encode(west, north, precision, bits_per_char),  # noqa: E241\n        })\n\n    if south >= -90:  # input cell not already at the south pole\n        neighbours_dict.update({\n            'south':      encode(lng,  south, precision, bits_per_char),  # noqa: E241\n            'south-east': encode(east, south, precision, bits_per_char),  # noqa: E241\n            'south-west': encode(west, south, precision, bits_per_char),  # noqa: E241\n        })\n\n    return neighbours_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a geojson rectangle from code", "response": "def rectangle(code, bits_per_char=6):\n    \"\"\"Builds a (geojson) rectangle from `code`\n\n    The center of the rectangle decodes as the lng/lat for code and\n    the rectangle corresponds to the error-margin, i.e. every lng/lat\n    point within this rectangle will be encoded as `code`, given `precision == len(code)`.\n\n    Parameters:\n        code: str           The geohash for which the rectangle should be build.\n        bits_per_char: int  The number of bits per coding character.\n\n    Returns:\n        dict: geojson `Feature` containing the rectangle as a `Polygon`.\n    \"\"\"\n    lng, lat, lng_err, lat_err = decode_exactly(code, bits_per_char)\n\n    return {\n        'type': 'Feature',\n        'properties': {\n            'code': code,\n            'lng': lng,\n            'lat': lat,\n            'lng_err': lng_err,\n            'lat_err': lat_err,\n            'bits_per_char': bits_per_char,\n        },\n        'bbox': (\n            lng - lng_err,  # bottom left\n            lat - lat_err,\n            lng + lng_err,  # top right\n            lat + lat_err,\n        ),\n        'geometry': {\n            'type': 'Polygon',\n            'coordinates': [[\n                (lng - lng_err, lat - lat_err),\n                (lng + lng_err, lat - lat_err),\n                (lng + lng_err, lat + lat_err),\n                (lng - lng_err, lat + lat_err),\n                (lng - lng_err, lat - lat_err),\n            ]],\n        },\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hilbert_curve(precision, bits_per_char=6):\n    bits = precision * bits_per_char\n\n    coords = []\n    for i in range(1 << bits):\n        code = encode_int(i, bits_per_char).rjust(precision, '0')\n        coords += [decode(code, bits_per_char)]\n\n    return {\n        'type': 'Feature',\n        'properties': {},\n        'geometry': {\n            'type': 'LineString',\n            'coordinates': coords,\n        },\n    }", "response": "Builds the geojson LineString of the used hilbert curve."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isSignatureValid(expected, received):\n    if expected:\n        if not received or expected != received:\n            return False\n    else:\n        if received:\n            return False\n    return True", "response": "Verifies that the received signature matches the expected value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef notifyOnDisconnect(self, callback):\n        if self._disconnectCBs is None:\n            self._disconnectCBs = []\n        self._disconnectCBs.append(callback)", "response": "Registers a callback that will be called when the DBus connection to the remote object is lost."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connectionLost(self, reason):\n        if self._disconnectCBs:\n            for cb in self._disconnectCBs:\n                cb(self, reason)", "response": "Called by the DBusObjectHandler when the connection is lost."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninforming the DBus daemon of the process s interest in the specified signal and registers the callback function to be called when the signal arrives.", "response": "def notifyOnSignal(self, signalName, callback, interface=None):\n        \"\"\"\n        Informs the DBus daemon of the process's interest in the specified\n        signal and registers the callback function to be called when the\n        signal arrives. Multiple callbacks may be registered.\n\n        @type signalName: C{string}\n        @param signalName: Name of the signal to register the callback for\n\n        @type callback: Callable object\n        @param callback: Callback to be called on signal arrival. The callback\n            will be passed signals arguments as positional function arguments.\n\n        @type interface: C{string}\n        @param interface: Optional DBus interface emitting the signal. This is\n            only needed if more than one interface shares a signal with the\n            same name\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: a Deferred to an integer rule_id that may be passed to\n            cancelSignalNotification to prevent the delivery of future signals\n            to the callback\n        \"\"\"\n        iface = None\n        signal = None\n\n        for i in self.interfaces:\n            if interface and not i.name == interface:\n                continue\n\n            if signalName in i.signals:\n                signal = i.signals[signalName]\n                iface = i\n                break\n\n        def callback_caller(sig_msg):\n            if isSignatureValid(signal.sig, sig_msg.signature):\n                if sig_msg.body:\n                    callback(*sig_msg.body)\n                else:\n                    callback()\n\n        if iface is None:\n            raise AttributeError(\n                'Requested signal \"%s\" is not a member of any of the '\n                'supported interfaces' % (signalName,),\n            )\n\n        d = self.objHandler.conn.addMatch(\n            callback_caller,\n            mtype='signal',\n            path=self.objectPath,\n            member=signalName,\n            interface=iface.name,\n        )\n\n        def on_ok(rule_id):\n\n            if self._signalRules is None:\n                self._signalRules = set()\n\n            self._signalRules.add(rule_id)\n\n            return rule_id\n\n        d.addCallback(on_ok)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncancel a callback previously registered with notifyOnSignal", "response": "def cancelSignalNotification(self, rule_id):\n        \"\"\"\n        Cancels a callback previously registered with notifyOnSignal\n        \"\"\"\n        if self._signalRules and rule_id in self._signalRules:\n            self.objHandler.conn.delMatch(rule_id)\n            self._signalRules.remove(rule_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling the remote method and returns a Deferred instance to the result of the call.", "response": "def callRemote(self, methodName, *args, **kwargs):\n        \"\"\"\n        Calls the remote method and returns a Deferred instance to the result.\n        DBus does not support passing keyword arguments over the wire. The\n        keyword arguments accepted by this method alter the behavior of the\n        remote call as described in the kwargs prameter description.\n\n        @type methodName: C{string}\n        @param methodName: Name of the method to call\n\n        @param args: Positional arguments to be passed to the remote method\n\n        @param kwargs: Three keyword parameters may be passed to alter the\n            behavior of the remote method call. If \\\"expectReply=False\\\" is\n            supplied, the returned Deferred will be immediately called back\n            with the value None. If \\\"autoStart=False\\\" is supplied the DBus\n            daemon will not attempt to auto-start a service to fulfill the call\n            if the service is not yet running (defaults to True). If\n            \\\"timeout=VALUE\\\" is supplied, the returned Deferred will be\n            errbacked with a L{error.TimeOut} instance if the remote call does\n            not return before the timeout elapses. If \\\"interface\\\" is\n            specified, the remote call use the method of the named interface.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: a Deferred to the result of the remote call\n        \"\"\"\n        expectReply = kwargs.get('expectReply', True)\n        autoStart = kwargs.get('autoStart', True)\n        timeout = kwargs.get('timeout', None)\n        interface = kwargs.get('interface', None)\n\n        m = None\n\n        for i in self.interfaces:\n            if interface and not interface == i.name:\n                continue\n            m = i.methods.get(methodName, None)\n            if m:\n                break\n\n        if m is None:\n            raise AttributeError(\n                'Requested method \"%s\" is not a member of any of the '\n                'supported interfaces' % (methodName,),\n            )\n\n        if len(args) != m.nargs:\n            raise TypeError(\n                '%s.%s takes %d arguments (%d given)' %\n                (i.name, methodName, m.nargs, len(args)),\n            )\n\n        return self.objHandler.conn.callRemote(\n            self.objectPath, methodName,\n            interface=i.name,\n            destination=self.busName,\n            signature=m.sigIn,\n            body=args,\n            expectReply=expectReply,\n            autoStart=autoStart,\n            timeout=timeout,\n            returnSignature=m.sigOut,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls by the DBus Connection object when the connection is lost.", "response": "def connectionLost(self, reason):\n        \"\"\"\n        Called by the DBus Connection object when the connection is lost.\n\n        @type reason: L{twistd.python.failure.Failure}\n        @param reason: The value passed to the associated connection's\n                       connectionLost method.\n        \"\"\"\n        for wref in self._weakProxies.valuerefs():\n            p = wref()\n            if p is not None:\n                p.connectionLost(reason)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake the specified object available over DBus", "response": "def exportObject(self, dbusObject):\n        \"\"\"\n        Makes the specified object available over DBus\n\n        @type dbusObject: an object implementing the L{IDBusObject} interface\n        @param dbusObject: The object to export over DBus\n        \"\"\"\n        o = IDBusObject(dbusObject)\n        self.exports[o.getObjectPath()] = o\n        o.setObjectHandler(self)\n\n        i = {}\n        for iface in o.getInterfaces():\n            i[iface.name] = o.getAllProperties(iface.name)\n\n        msig = message.SignalMessage(\n            o.getObjectPath(),\n            'InterfacesAdded',\n            'org.freedesktop.DBus.ObjectManager',\n            signature='sa{sa{sv}}',\n            body=[o.getObjectPath(), i],\n        )\n\n        self.conn.sendMessage(msig)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Python dictionary containing the reply content for the managed objects for the specified object path.", "response": "def getManagedObjects(self, objectPath):\n        \"\"\"\n        Returns a Python dictionary containing the reply content for\n        org.freedesktop.DBus.ObjectManager.GetManagedObjects\n        \"\"\"\n        d = {}\n\n        for p in sorted(self.exports.keys()):\n            if not p.startswith(objectPath) or p == objectPath:\n                continue\n            o = self.exports[p]\n            i = {}\n            d[p] = i\n            for iface in o.getInterfaces():\n                i[iface.name] = o.getAllProperties(iface.name)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends an error message to the local peer.", "response": "def _send_err(self, msg, errName, errMsg):\n        \"\"\"\n        Helper method for sending error messages\n        \"\"\"\n        r = message.ErrorMessage(\n            errName,\n            msg.serial,\n            body=[errMsg],\n            signature='s',\n            destination=msg.sender,\n        )\n\n        self.conn.sendMessage(r)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handleMethodCallMessage(self, msg):\n        if (\n            msg.interface == 'org.freedesktop.DBus.Peer'\n            and msg.member == 'Ping'\n        ):\n            r = message.MethodReturnMessage(\n                msg.serial,\n                destination=msg.sender,\n            )\n\n            self.conn.sendMessage(r)\n            return\n\n        if (\n                msg.interface == 'org.freedesktop.DBus.Introspectable'\n                and msg.member == 'Introspect'\n        ):\n            xml = introspection.generateIntrospectionXML(\n                msg.path,\n                self.exports,\n            )\n\n            if xml is not None:\n                r = message.MethodReturnMessage(\n                    msg.serial,\n                    body=[xml],\n                    destination=msg.sender,\n                    signature='s',\n                )\n\n                self.conn.sendMessage(r)\n\n                return\n\n        # Try to get object from complete object path\n        o = self.exports.get(msg.path, None)\n        if o is None:\n            self._send_err(\n                msg,\n                'org.freedesktop.DBus.Error.UnknownObject',\n                '%s is not an object provided by this process.' % (msg.path),\n            )\n            return\n\n        if (\n                msg.interface == 'org.freedesktop.DBus.ObjectManager'\n                and msg.member == 'GetManagedObjects'\n        ):\n            i_and_p = self.getManagedObjects(o.getObjectPath())\n\n            r = message.MethodReturnMessage(\n                msg.serial,\n                body=[i_and_p],\n                destination=msg.sender,\n                signature='a{oa{sa{sv}}}',\n            )\n\n            self.conn.sendMessage(r)\n\n            return\n\n        i = None\n\n        for x in o.getInterfaces():\n            if msg.interface:\n                if x.name == msg.interface:\n                    i = x\n                    break\n            else:\n                if msg.member in x.methods:\n                    i = x\n                    break\n\n        m = None\n        if i:\n            m = i.methods.get(msg.member, None)\n\n        if m is None:\n            self._send_err(\n                msg,\n                'org.freedesktop.DBus.Error.UnknownMethod',\n                (\n                    'Method \"%s\" with signature \"%s\" on interface \"%s\" '\n                    'doesn\\'t exist'\n                ) % (\n                    msg.member, msg.signature or '',\n                    msg.interface or '(null)',\n                ),\n            )\n\n            return\n\n        msig = msg.signature if msg.signature is not None else ''\n        esig = m.sigIn if m.sigIn is not None else ''\n\n        if esig != msig:\n            self._send_err(\n                msg,\n                'org.freedesktop.DBus.Error.InvalidArgs',\n                'Call to %s has wrong args (%s, expected %s)' %\n                (msg.member, msg.signature or '', m.sigIn or '')\n            )\n            return\n\n        d = defer.maybeDeferred(\n            o.executeMethod,\n            i,\n            msg.member,\n            msg.body,\n            msg.sender,\n        )\n\n        if msg.expectReply:\n            def send_reply(return_values):\n                if isinstance(return_values, (list, tuple)):\n                    if m.nret == 1:\n                        return_values = [return_values]\n                else:\n                    return_values = [return_values]\n\n                r = message.MethodReturnMessage(\n                    msg.serial,\n                    body=return_values,\n                    destination=msg.sender,\n                    signature=m.sigOut,\n                )\n                self.conn.sendMessage(r)\n\n            def send_error(err):\n                e = err.value\n                errMsg = err.getErrorMessage()\n                name = None\n\n                if hasattr(e, 'dbusErrorName'):\n                    name = e.dbusErrorName\n\n                if name is None:\n                    name = 'org.txdbus.PythonException.' + e.__class__.__name__\n\n                try:\n                    marshal.validateErrorName(name)\n                except error.MarshallingError:\n                    errMsg = ('!!(Invalid error name \"%s\")!! ' % name) + errMsg\n                    name = 'org.txdbus.InvalidErrorName'\n\n                r = message.ErrorMessage(name, msg.serial,\n                                         body=[errMsg],\n                                         signature='s',\n                                         destination=msg.sender)\n                self.conn.sendMessage(r)\n\n            d.addCallback(send_reply)\n            d.addErrback(send_error)", "response": "Handles the DBus MethodCall messages on behalf of the DBus Connection and dispatches them to the appropriate exported object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getRemoteObject(self, busName, objectPath, interfaces=None,\n                        replaceKnownInterfaces=False):\n        \"\"\"\n        Creates a L{RemoteDBusObject} instance to represent the\n        specified DBus object.  If explicit interfaces are not\n        supplied, DBus object introspection will be used to obtain\n        them automatically.\n\n        @type busName: C{string}\n        @param busName: Name of the bus exporting the desired object\n\n        @type objectPath: C{string}\n        @param objectPath: DBus path of the desired object\n\n        @type interfaces: None, C{string} or L{interface.DBusInterface} or a\n                          list of C{string}/L{interface.DBusInterface}\n        @param interfaces: May be None, a single value, or a list of string\n                           interface names and/or instances of\n                           L{interface.DBusInterface}. If None or any of the\n                           specified interface names are unknown, full\n                           introspection will be attempted.  If interfaces\n                           consists of solely of L{interface.DBusInterface}\n                           instances and/or known interfacep names, no\n                           introspection will be preformed.\n\n        @type replaceKnownInterfaces: C{bool}\n        @param replaceKnownInterfaces: If True (defaults to False), any\n                                       interfaces discovered during the\n                                       introspection process will override any\n                                       previous, cached values.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: A Deferred to the L{RemoteDBusObject} instance\n        \"\"\"\n\n        weak_id = (busName, objectPath, interfaces)\n\n        need_introspection = False\n        required_interfaces = set()\n\n        if interfaces is not None:\n\n            ifl = []\n\n            if not isinstance(interfaces, list):\n                interfaces = [interfaces]\n\n            for i in interfaces:\n                if isinstance(i, interface.DBusInterface):\n                    ifl.append(i)\n                    required_interfaces.add(i.name)\n                else:\n                    required_interfaces.add(i)\n                    if i in interface.DBusInterface.knownInterfaces:\n                        ifl.append(interface.DBusInterface.knownInterfaces[i])\n                    else:\n                        need_introspection = True\n\n            if not need_introspection:\n                return defer.succeed(\n                    RemoteDBusObject(self, busName, objectPath, ifl)\n                )\n\n        d = self.conn.introspectRemoteObject(\n            busName,\n            objectPath,\n            replaceKnownInterfaces,\n        )\n\n        def ok(ifaces):\n            missing = required_interfaces - {q.name for q in ifaces}\n\n            if missing:\n                raise error.IntrospectionFailed(\n                    'Introspection failed to find interfaces: '\n                    + ','.join(missing)\n                )\n\n            prox = RemoteDBusObject(self, busName, objectPath, ifaces)\n\n            self._weakProxies[weak_id] = prox\n\n            return prox\n\n        d.addCallback(ok)\n\n        return d", "response": "Creates a Deferred to obtain the remote object for the specified object path and interfaces."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a L{Method m to the interface", "response": "def addMethod(self, m):\n        \"\"\"\n        Adds a L{Method} to the interface\n        \"\"\"\n        if m.nargs == -1:\n            m.nargs = len([a for a in marshal.genCompleteTypes(m.sigIn)])\n            m.nret = len([a for a in marshal.genCompleteTypes(m.sigOut)])\n        self.methods[m.name] = m\n        self._xml = None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addSignal(self, s):\n        if s.nargs == -1:\n            s.nargs = len([a for a in marshal.genCompleteTypes(s.sig)])\n        self.signals[s.name] = s\n        self._xml = None", "response": "Adds a L{Signal s to the interface\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(reactor, busAddress='session'):\n    from txdbus import endpoints\n\n    f = DBusClientFactory()\n\n    d = f.getConnection()\n\n    eplist = endpoints.getDBusEndpoints(reactor, busAddress)\n\n    eplist.reverse()\n\n    def try_next_ep(err):\n        if eplist:\n            eplist.pop().connect(f).addErrback(try_next_ep)\n        else:\n            d.errback(\n                ConnectError(\n                    string=(\n                        'Failed to connect to any bus address. Last error: '\n                        + err.getErrorMessage()\n                    )\n                )\n            )\n\n    if eplist:\n        try_next_ep(None)\n    else:\n        d.errback(\n            ConnectError(\n                string=(\n                    'Failed to connect to any bus address. No valid bus '\n                    'addresses found'\n                )\n            )\n        )\n\n    return d", "response": "Connect to the specified bus and returns a Deferred to the fully - connected\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling by DBus when the connection has been established.", "response": "def connectionAuthenticated(self):\n        \"\"\"\n        Called by L{protocol.BasicDBusProtocol} when the DBus authentication\n        has completed successfully.\n        \"\"\"\n        self.router = router.MessageRouter()\n        self.match_rules = {}\n        self.objHandler = objects.DBusObjectHandler(self)\n        # serial_number => (deferred, delayed_timeout_cb | None):\n        self._pendingCalls = {}\n        self._dcCallbacks = []\n\n        d = self.callRemote(\n            '/Hello',\n            'Hello',\n            interface='org.freedesktop.DBus',\n            destination='org.freedesktop.DBus',\n        )\n\n        d.addCallbacks(\n            self._cbGotHello,\n            lambda err: self.factory._failed(err),\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall when the transport loses a connection to the bus.", "response": "def connectionLost(self, reason):\n        \"\"\"\n        Called when the transport loses connection to the bus\n        \"\"\"\n        if self.busName is None:\n            return\n\n        for cb in self._dcCallbacks:\n            cb(self, reason)\n\n        for d, timeout in self._pendingCalls.values():\n            if timeout:\n                timeout.cancel()\n            d.errback(reason)\n        self._pendingCalls = {}\n\n        self.objHandler.connectionLost(reason)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getRemoteObject(self, busName, objectPath, interfaces=None,\n                        replaceKnownInterfaces=False):\n        \"\"\"\n        Creates a L{objects.RemoteDBusObject} instance to represent the\n        specified DBus object.  If explicit interfaces are not supplied, DBus\n        object introspection will be used to obtain them automatically.\n\n        @param interfaces: May be None, a single value, or a list of string\n                           interface names and/or instances of\n                           L{interface.DBusInterface}. If None or any of the\n                           specified interface names are unknown, full\n                           introspection will be attempted.  If interfaces\n                           consists of solely of L{interface.DBusInterface}\n                           instances and/or known interface names, no\n                           introspection will be preformed.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: A deferred to a L{objects.RemoteDBusObject} instance\n            representing the remote object\n        \"\"\"\n        return self.objHandler.getRemoteObject(\n            busName,\n            objectPath,\n            interfaces,\n            replaceKnownInterfaces,\n        )", "response": "Returns a Deferred that resolves when the remote object is created."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a message matching rule previously registered with addMatch", "response": "def delMatch(self, rule_id):\n        \"\"\"\n        Removes a message matching rule previously registered with addMatch\n        \"\"\"\n        rule = self.match_rules[rule_id]\n\n        d = self.callRemote(\n            '/org/freedesktop/DBus',\n            'RemoveMatch',\n            interface='org.freedesktop.DBus',\n            destination='org.freedesktop.DBus',\n            body=[rule],\n            signature='s',\n        )\n\n        def ok(_):\n            del self.match_rules[rule_id]\n            self.router.delMatch(rule_id)\n\n        d.addCallback(ok)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addMatch(self, callback, mtype=None, sender=None, interface=None,\n                 member=None, path=None, path_namespace=None, destination=None,\n                 arg=None, arg_path=None, arg0namespace=None):\n        \"\"\"\n        Creates a message matching rule, associates it with the specified\n        callback function, and sends the match rule to the DBus daemon.\n        The arguments to this function are exactly follow the DBus\n        specification.  Refer to the \\\"Message Bus Message Routing\\\" section of\n        the DBus specification for details.\n\n        @rtype: C{int}\n        @returns: a L{Deferred} to an integer id that may be used to unregister\n            the match rule\n        \"\"\"\n\n        l = []\n\n        def add(k, v):\n            if v is not None:\n                l.append(\"%s='%s'\" % (k, v))\n\n        add('type', mtype)\n        add('sender', sender)\n        add('interface', interface)\n        add('member', member)\n        add('path', path)\n        add('path_namespace', path_namespace)\n        add('destination', destination)\n\n        if arg:\n            for idx, v in arg:\n                add('arg%d' % (idx,), v)\n\n        if arg_path:\n            for idx, v in arg_path:\n                add('arg%dpath' % (idx,), v)\n\n        add('arg0namespace', arg0namespace)\n\n        rule = ','.join(l)\n\n        d = self.callRemote(\n            '/org/freedesktop/DBus',\n            'AddMatch',\n            interface='org.freedesktop.DBus',\n            destination='org.freedesktop.DBus',\n            body=[rule],\n            signature='s',\n        )\n\n        def ok(_):\n            rule_id = self.router.addMatch(\n                callback,\n                mtype,\n                sender,\n                interface,\n                member,\n                path,\n                path_namespace,\n                destination,\n                arg,\n                arg_path,\n                arg0namespace,\n            )\n            self.match_rules[rule_id] = rule\n            return rule_id\n\n        d.addCallbacks(ok)\n\n        return d", "response": "Adds a new match rule to the specified DBus object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getNameOwner(self, busName):\n        d = self.callRemote(\n            '/org/freedesktop/DBus',\n            'GetNameOwner',\n            interface='org.freedesktop.DBus',\n            signature='s',\n            body=[busName],\n            destination='org.freedesktop.DBus',\n        )\n        return d", "response": "Returns a Deferred to the unique connection name owning the bus name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef requestBusName(self, newName,\n                       allowReplacement=False,\n                       replaceExisting=False,\n                       doNotQueue=True,\n                       errbackUnlessAcquired=True):\n        \"\"\"\n        Calls org.freedesktop.DBus.RequestName to request that the specified\n        bus name be associated with the connection.\n\n        @type newName: C{string}\n        @param newName: Bus name to acquire\n\n        @type allowReplacement: C{bool}\n        @param allowReplacement: If True (defaults to False) and another\n            application later requests this same name, the new requester will\n            be given the name and this connection will lose ownership.\n\n        @type replaceExisting: C{bool}\n        @param replaceExisting: If True (defaults to False) and another\n            application owns the name but specified allowReplacement at the\n            time of the name acquisition, this connection will assume ownership\n            of the bus name.\n\n        @type doNotQueue: C{bool}\n        @param doNotQueue: If True (defaults to True) the name request will\n            fail if the name is currently in use. If False, the request will\n            cause this connection to be queued for ownership of the requested\n            name\n\n        @type errbackUnlessAcquired: C{bool}\n        @param errbackUnlessAcquired: If True (defaults to True) an\n            L{twisted.python.failure.Failure} will be returned if the name is\n            not acquired.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: a Deferred to\n        \"\"\"\n        flags = 0\n        if allowReplacement:\n            flags |= 0x1\n        if replaceExisting:\n            flags |= 0x2\n        if doNotQueue:\n            flags |= 0x4\n\n        d = self.callRemote(\n            '/org/freedesktop/DBus',\n            'RequestName',\n            interface='org.freedesktop.DBus',\n            signature='su',\n            body=[newName, flags],\n            destination='org.freedesktop.DBus',\n        )\n\n        def on_result(r):\n            if errbackUnlessAcquired and not (\n                    r == NAME_ACQUIRED or r == NAME_ALREADY_OWNER):\n                raise error.FailedToAcquireName(newName, r)\n            return r\n\n        d.addCallback(on_result)\n\n        return d", "response": "Requests that the specified name be associated with the specified connection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef introspectRemoteObject(self, busName, objectPath,\n                               replaceKnownInterfaces=False):\n        \"\"\"\n        Calls org.freedesktop.DBus.Introspectable.Introspect\n\n        @type busName: C{string}\n        @param busName: Name of the bus containing the object\n\n        @type objectPath: C{string}\n        @param objectPath: Object Path to introspect\n\n        @type replaceKnownInterfaces: C{bool}\n        @param replaceKnownInterfaces: If True (defaults to False), the content\n            of the introspected XML will override any pre-existing definitions\n            of the contained interfaces.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: a Deferred to a list of L{interface.DBusInterface} instances\n            created from the content of the introspected XML description of the\n            object's interface.\n        \"\"\"\n        d = self.callRemote(\n            objectPath,\n            'Introspect',\n            interface='org.freedesktop.DBus.Introspectable',\n            destination=busName,\n        )\n\n        def ok(xml_str):\n            return introspection.getInterfacesFromXML(\n                xml_str,\n                replaceKnownInterfaces\n            )\n\n        def err(e):\n            raise error.IntrospectionFailed(\n                'Introspection Failed: ' + e.getErrorMessage()\n            )\n\n        d.addCallbacks(ok, err)\n\n        return d", "response": "Introspects the content of the object at the specified path and returns a Deferred to list of DBusInterface instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cbCvtReply(self, msg, returnSignature):\n        if msg is None:\n            return None\n\n        if returnSignature != _NO_CHECK_RETURN:\n            if not returnSignature:\n                if msg.signature:\n                    raise error.RemoteError(\n                        'Unexpected return value signature')\n            else:\n                if not msg.signature or msg.signature != returnSignature:\n                    msg = 'Expected \"%s\". Received \"%s\"' % (\n                        str(returnSignature), str(msg.signature))\n                    raise error.RemoteError(\n                        'Unexpected return value signature: %s' %\n                        (msg,))\n\n        if msg.body is None or len(msg.body) == 0:\n            return None\n\n        # if not (\n        #     isinstance(msg.body[0], six.string_types) and\n        #     msg.body[0].startswith('<!D')\n        # ):\n        #     print('RET SIG', msg.signature, 'BODY:', msg.body)\n        if len(msg.body) == 1 and not msg.signature[0] == '(':\n            return msg.body[0]\n        else:\n            return msg.body", "response": "Convert a remote method call reply message into an appropriate callback\n        value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall a method on a remote DBus object and returns a deferred to the result. @type objectPath: C{string} @param objectPath: Path of the remote object @type methodName: C{string} @param methodName: Name of the method to call @type interface: None or C{string} @param interface: If specified, this specifies the interface containing the desired method @type destination: None or C{string} @param destination: If specified, this specifies the bus name containing the remote object @type signature: None or C{string} @param signature: If specified, this specifies the DBus signature of the body of the DBus MethodCall message. This string must be a valid Signature string as defined by the DBus specification. If arguments are supplied to the method call, this parameter must be provided. @type body: C{list} @param body: A C{list} of Python objects to encode. The list content must match the content of the signature parameter @type expectReply: C{bool} @param expectReply: If True (defaults to True) the returned deferred will be called back with the eventual result of the remote call. If False, the deferred will be immediately called back with None. @type autoStart: C{bool} @param autoStart: If True (defaults to True) DBus will attempt to automatically start a service to handle the method call if a service matching the target object is registered but not yet started. @type timeout: None or C{float} @param timeout: If specified and the remote call does not return a value before the timeout expires, the returned Deferred will be errbacked with a L{error.TimeOut} instance. @type returnSignature: C{string} @param returnSignature: If specified, the return values will be validated against the signature string. If the returned values do not mactch, the returned Deferred witl be errbacked with a L{error.RemoteError} instance. @rtype: L{twisted.internet.defer.Deferred} @returns: a Deferred to the result. If expectReply is False, the deferred will be immediately called back with None.", "response": "def callRemote(self, objectPath, methodName,\n                   interface=None,\n                   destination=None,\n                   signature=None,\n                   body=None,\n                   expectReply=True,\n                   autoStart=True,\n                   timeout=None,\n                   returnSignature=_NO_CHECK_RETURN):\n        \"\"\"\n        Calls a method on a remote DBus object and returns a deferred to the\n        result.\n\n        @type objectPath: C{string}\n        @param objectPath: Path of the remote object\n\n        @type methodName: C{string}\n        @param methodName: Name of the method to call\n\n        @type interface: None or C{string}\n        @param interface: If specified, this specifies the interface containing\n            the desired method\n\n        @type destination: None or C{string}\n        @param destination: If specified, this specifies the bus name\n        containing the remote object\n\n        @type signature: None or C{string}\n        @param signature: If specified, this specifies the DBus signature of\n            the body of the DBus MethodCall message. This string must be a\n            valid Signature string as defined by the DBus specification. If\n            arguments are supplied to the method call, this parameter must be\n            provided.\n\n        @type body: C{list}\n        @param body: A C{list} of Python objects to encode. The list content\n            must match the content of the signature parameter\n\n        @type expectReply: C{bool}\n        @param expectReply: If True (defaults to True) the returned deferred\n            will be called back with the eventual result of the remote call. If\n            False, the deferred will be immediately called back with None.\n\n        @type autoStart: C{bool}\n        @param autoStart: If True (defaults to True) DBus will attempt to\n            automatically start a service to handle the method call if a\n            service matching the target object is registered but not yet\n            started.\n\n        @type timeout: None or C{float}\n        @param timeout: If specified and the remote call does not return a\n            value before the timeout expires, the returned Deferred will be\n            errbacked with a L{error.TimeOut} instance.\n\n        @type returnSignature: C{string}\n        @param returnSignature: If specified, the return values will be\n            validated against the signature string. If the returned values do\n            not mactch, the returned Deferred witl be errbacked with a\n            L{error.RemoteError} instance.\n\n        @rtype: L{twisted.internet.defer.Deferred}\n        @returns: a Deferred to the result. If expectReply is False, the\n             deferred will be immediately called back with None.\n        \"\"\"\n\n        try:\n            mcall = message.MethodCallMessage(\n                objectPath,\n                methodName,\n                interface=interface,\n                destination=destination,\n                signature=signature,\n                body=body,\n                expectReply=expectReply,\n                autoStart=autoStart,\n                oobFDs=self._toBeSentFDs,\n            )\n\n            d = self.callRemoteMessage(mcall, timeout)\n\n            d.addCallback(self._cbCvtReply, returnSignature)\n\n            return d\n        except Exception:\n            return defer.fail()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when a remote method invocation timeout occurs.", "response": "def _onMethodTimeout(self, serial, d):\n        \"\"\"\n        Called when a remote method invocation timeout occurs\n        \"\"\"\n        del self._pendingCalls[serial]\n        d.errback(error.TimeOut('Method call timed out'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef callRemoteMessage(self, mcall, timeout=None):\n        assert isinstance(mcall, message.MethodCallMessage)\n\n        if mcall.expectReply:\n            d = defer.Deferred()\n\n            if timeout:\n                timeout = reactor.callLater(\n                    timeout, self._onMethodTimeout, mcall.serial, d)\n\n            self._pendingCalls[mcall.serial] = (d, timeout)\n\n            self.sendMessage(mcall)\n\n            return d\n        else:\n            self.sendMessage(mcall)\n\n            return defer.succeed(None)", "response": "Sends a remote method call to the remote method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when a method return message is received.", "response": "def methodReturnReceived(self, mret):\n        \"\"\"\n        Called when a method return message is received\n        \"\"\"\n        d, timeout = self._pendingCalls.get(mret.reply_serial, (None, None))\n        if timeout:\n            timeout.cancel()\n        if d:\n            del self._pendingCalls[mret.reply_serial]\n            d.callback(mret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef errorReceived(self, merr):\n        d, timeout = self._pendingCalls.get(merr.reply_serial, (None, None))\n        if timeout:\n            timeout.cancel()\n        if d:\n            del self._pendingCalls[merr.reply_serial]\n            e = error.RemoteError(merr.error_name)\n            e.message = ''\n            e.values = []\n            if merr.body:\n                if isinstance(merr.body[0], six.string_types):\n                    e.message = merr.body[0]\n                e.values = merr.body\n            d.errback(e)", "response": "Called when an error is received from the broker."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of endpoints from the DBUS_SESSION_BUS_ADDRESS environment variable.", "response": "def getDBusEnvEndpoints(reactor, client=True):\n    \"\"\"\n    Creates endpoints from the DBUS_SESSION_BUS_ADDRESS environment variable\n\n    @rtype: C{list} of L{twisted.internet.interfaces.IStreamServerEndpoint}\n    @returns: A list of endpoint instances\n    \"\"\"\n    env = os.environ.get('DBUS_SESSION_BUS_ADDRESS', None)\n    if env is None:\n        raise Exception('DBus Session environment variable not set')\n\n    return getDBusEndpoints(reactor, env, client)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of DBus endpoints for the given bus address.", "response": "def getDBusEndpoints(reactor, busAddress, client=True):\n    \"\"\"\n    Creates DBus endpoints.\n\n    @param busAddress: 'session', 'system', or a valid bus address as defined\n        by the DBus specification. If 'session' (the default) or 'system' is\n        supplied, the contents of the DBUS_SESSION_BUS_ADDRESS or\n        DBUS_SYSTEM_BUS_ADDRESS environment variables will be used for the bus\n        address, respectively. If DBUS_SYSTEM_BUS_ADDRESS is not set, the\n        well-known address unix:path=/var/run/dbus/system_bus_socket will be\n        used.\n    @type busAddress: C{string}\n\n    @rtype: C{list} of L{twisted.internet.interfaces.IStreamServerEndpoint}\n    @returns: A list of endpoint instances\n    \"\"\"\n\n    if busAddress == 'session':\n        addrString = os.environ.get('DBUS_SESSION_BUS_ADDRESS', None)\n        if addrString is None:\n            raise Exception('DBus Session environment variable not set')\n\n    elif busAddress == 'system':\n        addrString = os.environ.get(\n            'DBUS_SYSTEM_BUS_ADDRESS',\n            'unix:path=/var/run/dbus/system_bus_socket',\n        )\n\n    else:\n        addrString = busAddress\n\n    # XXX Add documentation about extra key=value parameters in address string\n    #    such as nonce-tcp vs tcp which use same endpoint class\n    epl = []\n\n    for ep_addr in addrString.split(';'):\n        d = {}\n        kind = None\n        ep = None\n\n        for c in ep_addr.split(','):\n            if c.startswith('unix:'):\n                kind = 'unix'\n                c = c[5:]\n            elif c.startswith('tcp:'):\n                kind = 'tcp'\n                c = c[4:]\n            elif c.startswith('nonce-tcp:'):\n                kind = 'tcp'\n                c = c[10:]\n                d['nonce-tcp'] = True\n            elif c.startswith('launchd:'):\n                kind = 'launchd'\n                c = c[7:]\n\n            if '=' in c:\n                k, v = c.split('=')\n                d[k] = v\n\n        if kind == 'unix':\n            if 'path' in d:\n                path = d['path']\n            elif 'tmpdir' in d:\n                path = d['tmpdir'] + '/dbus-' + str(os.getpid())\n            elif 'abstract' in d:\n                path = '\\0' + d['abstract']\n\n            if client:\n                ep = UNIXClientEndpoint(reactor, path=path)\n            else:\n                ep = UNIXServerEndpoint(reactor, address=path)\n\n        elif kind == 'tcp':\n            if client:\n                ep = TCP4ClientEndpoint(reactor, d['host'], int(d['port']))\n            else:\n                ep = TCP4ServerEndpoint(reactor, int(\n                    d['port']), interface=d['host'])\n\n        if ep:\n            ep.dbus_args = d\n            epl.append(ep)\n\n    return epl"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating that the provided object path conforms to the DBus standard.", "response": "def validateObjectPath(p):\n    \"\"\"\n    Ensures that the provided object path conforms to the DBus standard.\n    Throws a L{error.MarshallingError} if non-conformant\n\n    @type p: C{string}\n    @param p: A DBus object path\n    \"\"\"\n    if not p.startswith('/'):\n        raise MarshallingError('Object paths must begin with a \"/\"')\n    if len(p) > 1 and p[-1] == '/':\n        raise MarshallingError('Object paths may not end with \"/\"')\n    if '//' in p:\n        raise MarshallingError('\"//\" is not allowed in object paths\"')\n    if invalid_obj_path_re.search(p):\n        raise MarshallingError('Invalid characters contained in object path')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate that the supplied name is a valid DBus Interface name.", "response": "def validateInterfaceName(n):\n    \"\"\"\n    Verifies that the supplied name is a valid DBus Interface name. Throws\n    an L{error.MarshallingError} if the format is invalid\n\n    @type n: C{string}\n    @param n: A DBus interface name\n    \"\"\"\n    try:\n        if '.' not in n:\n            raise Exception('At least two components required')\n        if '..' in n:\n            raise Exception('\"..\" not allowed in interface names')\n        if len(n) > 255:\n            raise Exception('Name exceeds maximum length of 255')\n        if n[0] == '.':\n            raise Exception('Names may not begin with a \".\"')\n        if n[0].isdigit():\n            raise Exception('Names may not begin with a digit')\n        if if_re.search(n):\n            raise Exception(\n                'Names contains a character outside the set [A-Za-z0-9_.]')\n        if dot_digit_re.search(n):\n            raise Exception(\n                'No components of an interface name may begin with a digit')\n    except Exception as e:\n        raise MarshallingError('Invalid interface name \"%s\": %s' % (n, str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate that the supplied name is a valid DBus Bus name.", "response": "def validateBusName(n):\n    \"\"\"\n    Verifies that the supplied name is a valid DBus Bus name. Throws\n    an L{error.MarshallingError} if the format is invalid\n\n    @type n: C{string}\n    @param n: A DBus bus name\n    \"\"\"\n    try:\n        if '.' not in n:\n            raise Exception('At least two components required')\n        if '..' in n:\n            raise Exception('\"..\" not allowed in bus names')\n        if len(n) > 255:\n            raise Exception('Name exceeds maximum length of 255')\n        if n[0] == '.':\n            raise Exception('Names may not begin with a \".\"')\n        if n[0].isdigit():\n            raise Exception('Names may not begin with a digit')\n        if bus_re.search(n):\n            raise Exception(\n                'Names contains a character outside the set [A-Za-z0-9_.\\\\-:]')\n        if not n[0] == ':' and dot_digit_re.search(n):\n            raise Exception(\n                'No coponents of an interface name may begin with a digit')\n    except Exception as e:\n        raise MarshallingError('Invalid bus name \"%s\": %s' % (n, str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validateMemberName(n):\n    try:\n        if len(n) < 1:\n            raise Exception('Name must be at least one byte in length')\n        if len(n) > 255:\n            raise Exception('Name exceeds maximum length of 255')\n        if n[0].isdigit():\n            raise Exception('Names may not begin with a digit')\n        if mbr_re.search(n):\n            raise Exception(\n                'Names contains a character outside the set [A-Za-z0-9_]')\n    except Exception as e:\n        raise MarshallingError('Invalid member name \"%s\": %s' % (n, str(e)))", "response": "Validates that the supplied name is a valid DBus member name. Throws an exception if the name is invalid."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dbus_lenFD(self, fd):\n        f = os.fdopen(fd, 'rb')\n        result = len(f.read())\n        f.close()\n        return result", "response": "Returns the byte count after reading till EOF."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread byte_count bytes from fd and returns them.", "response": "def dbus_readBytesFD(self, fd, byte_count):\n        \"\"\"\n        Reads byte_count bytes from fd and returns them.\n        \"\"\"\n        f = os.fdopen(fd, 'rb')\n        result = f.read(byte_count)\n        f.close()\n        return bytearray(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread byte_count from fd1 and fd2. Returns concatenation of byte_count.", "response": "def dbus_readBytesTwoFDs(self, fd1, fd2, byte_count):\n        \"\"\"\n        Reads byte_count from fd1 and fd2. Returns concatenation.\n        \"\"\"\n        result = bytearray()\n        for fd in (fd1, fd2):\n            f = os.fdopen(fd, 'rb')\n            result.extend(f.read(byte_count))\n            f.close()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generateIntrospectionXML(objectPath, exportedObjects):\n    l = [_dtd_decl]\n    l.append('<node name=\"%s\">' % (objectPath,))\n\n    obj = exportedObjects.get(objectPath, None)\n    if obj is not None:\n        for i in obj.getInterfaces():\n            l.append(i.introspectionXml)\n        l.append(_intro)\n\n    # make sure objectPath ends with '/' to only get partial matches based on\n    # the full path, not a part of a subpath\n    if not objectPath.endswith('/'):\n        objectPath += '/'\n    matches = []\n    for path in exportedObjects.keys():\n        if path.startswith(objectPath):\n            path = path[len(objectPath):].partition('/')[0]\n            if path not in matches:\n                matches.append(path)\n\n    if obj is None and not matches:\n        return None\n\n    for m in matches:\n        l.append('<node name=\"%s\"/>' % m)\n\n    l.append('</node>')\n    return '\\n'.join(l)", "response": "Generates the introspection XML for an object path or partial object path."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the supplied Introspection XML string and returns a list of L { interface. DBusInerface } instances representing the XML interface that is defined within the XML string.", "response": "def getInterfacesFromXML(xmlStr, replaceKnownInterfaces=False):\n    \"\"\"\n    Parses the supplied Introspection XML string and returns a list of\n    L{interface.DBusInerface} instances representing the XML interface\n    definitions.\n\n    @type replaceKnownInterfaces: C{bool}\n    @param replaceKnownInterfaces: If true, pre-existing interface definitions\n                                   will be replaced by the contents of the\n                                   interfaces defined within the XML string\n\n    @rtype: C{list} of L{interface.DBusInerface}\n    \"\"\"\n    handler = IntrospectionHandler(replaceKnownInterfaces)\n\n    xmlStr = xmlStr.strip()\n    if xmlStr.startswith('<!DOCTYPE'):\n        xmlStr = xmlStr[xmlStr.find('>') + 1:]\n\n    # xml.sax.parseString( xmlStr, handler )\n    p = xml.sax.make_parser()\n    p.setFeature(xml.sax.handler.feature_validation, False)\n    p.setFeature(xml.sax.handler.feature_external_ges, False)\n    p.setContentHandler(handler)\n    p.parse(cStringIO(xmlStr))\n\n    return handler.interfaces"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when a client connects to the bus. This method assigns the unique name of the client to the bus and adds the client to the list of clients that are connected to the bus.", "response": "def clientConnected(self, proto):\n        \"\"\"\n        Called when a client connects to the bus. This method assigns the\n        new connection a unique bus name.\n        \"\"\"\n        proto.uniqueName = ':1.%d' % (self.next_id,)\n        self.next_id += 1\n        self.clients[proto.uniqueName] = proto"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clientDisconnected(self, proto):\n        for rule_id in proto.matchRules:\n            self.router.delMatch(rule_id)\n\n        for busName in proto.busNames.keys():\n            self.dbus_ReleaseName(busName, proto.uniqueName)\n\n        if proto.uniqueName:\n            del self.clients[proto.uniqueName]", "response": "Called when a client disconnects from the bus"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sendMessage(self, msg):\n        if msg._messageType in (1, 2):\n            assert msg.destination, 'Failed to specify a message destination'\n\n        if msg.destination is not None:\n            if msg.destination[0] == ':':\n                p = self.clients.get(msg.destination, None)\n            else:\n                p = self.busNames.get(msg.destination, None)\n                if p:\n                    p = p[0]\n\n            # print 'SND: ', msg._messageType, ' to ',  p.uniqueName, 'serial',\n            # msg.serial,\n\n            if p:\n                p.sendMessage(msg)\n            else:\n                log.msg(\n                    'Invalid bus name in msg.destination: '\n                    + msg.destination\n                )\n        else:\n            self.router.routeMessage(msg)", "response": "Sends the supplied message to the correct destination."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendSignal(self, p, member, signature=None, body=None,\n                   path='/org/freedesktop/DBus',\n                   interface='org.freedesktop.DBus'):\n        \"\"\"\n        Sends a signal to a specific connection\n\n        @type p: L{BusProtocol}\n        @param p: L{BusProtocol} instance to send a signal to\n\n        @type member: C{string}\n        @param member: Name of the signal to send\n\n        @type path: C{string}\n        @param path: Path of the object emitting the signal. Defaults to\n                     'org/freedesktop/DBus'\n\n        @type interface: C{string}\n        @param interface: If specified, this specifies the interface containing\n            the desired method. Defaults to 'org.freedesktop.DBus'\n\n        @type body: None or C{list}\n        @param body: If supplied, this is a list of signal arguments. The\n            contents of the list must match the signature.\n\n        @type signature: None or C{string}\n        @param signature: If specified, this specifies the DBus signature of\n            the body of the DBus Signal message. This string must be a valid\n            Signature string as defined by the DBus specification. If the body\n            argumnent is supplied, this parameter must be provided.\n        \"\"\"\n        if not isinstance(body, (list, tuple)):\n            body = [body]\n\n        s = message.SignalMessage(path, member, interface,\n                                  p.uniqueName, signature, body)\n        p.sendMessage(s)", "response": "Sends a signal to a specific connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef broadcastSignal(self, member, signature=None, body=None,\n                        path='/org/freedesktop/DBus',\n                        interface='org.freedesktop.DBus'):\n        \"\"\"\n        Sends a signal to all connections with registered interest\n\n        @type member: C{string}\n        @param member: Name of the signal to send\n\n        @type path: C{string}\n        @param path: Path of the object emitting the signal. Defaults to\n                     'org/freedesktop/DBus'\n\n        @type interface: C{string}\n        @param interface: If specified, this specifies the interface containing\n            the desired method. Defaults to 'org.freedesktop.DBus'\n\n        @type body: None or C{list}\n        @param body: If supplied, this is a list of signal arguments. The\n            contents of the list must match the signature.\n\n        @type signature: None or C{string}\n        @param signature: If specified, this specifies the DBus signature of\n            the body of the DBus Signal message. This string must be a valid\n            Signature string as defined by the DBus specification. If the body\n            argumnent is supplied , this parameter must be provided.\n        \"\"\"\n        if not isinstance(body, (list, tuple)):\n            body = [body]\n\n        s = message.SignalMessage(path, member, interface,\n                                  None, signature, body)\n        self.router.routeMessage(s)", "response": "Sends a signal to all connections with the same name and interface."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a raw binary message and returns a new object.", "response": "def parseMessage(rawMessage, oobFDs):\n    \"\"\"\n    Parses the raw binary message and returns a L{DBusMessage} subclass.\n    Unmarshalling DBUS 'h' (UNIX_FD) gets the FDs from the oobFDs list.\n\n    @type rawMessage: C{str}\n    @param rawMessage: Raw binary message to parse\n\n    @rtype: L{DBusMessage} subclass\n    @returns: The L{DBusMessage} subclass corresponding to the contained\n              message\n    \"\"\"\n\n    lendian = rawMessage[0] == b'l'[0]\n\n    nheader, hval = marshal.unmarshal(\n        _headerFormat,\n        rawMessage,\n        0,\n        lendian,\n        oobFDs,\n    )\n\n    messageType = hval[1]\n\n    if messageType not in _mtype:\n        raise error.MarshallingError(\n            'Unknown Message Type: ' + str(messageType)\n        )\n\n    m = object.__new__(_mtype[messageType])\n\n    m.rawHeader = rawMessage[:nheader]\n\n    npad = nheader % 8 and (8 - nheader % 8) or 0\n\n    m.rawPadding = rawMessage[nheader: nheader + npad]\n\n    m.rawBody = rawMessage[nheader + npad:]\n\n    m.serial = hval[5]\n\n    for code, v in hval[6]:\n        try:\n            setattr(m, _hcode[code], v)\n        except KeyError:\n            pass\n\n    if m.signature:\n        nbytes, m.body = marshal.unmarshal(\n            m.signature,\n            m.rawBody,\n            lendian=lendian,\n            oobFDs=oobFDs,\n        )\n\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _marshal(self, newSerial=True, oobFDs=None):\n        flags = 0\n\n        if not self.expectReply:\n            flags |= 0x1\n\n        if not self.autoStart:\n            flags |= 0x2\n\n        # may be overriden below, depending on oobFDs\n        _headerAttrs = self._headerAttrs\n\n        # marshal body before headers to know if the 'unix_fd' header is needed\n        if self.signature:\n            binBody = b''.join(\n                marshal.marshal(\n                    self.signature,\n                    self.body,\n                    oobFDs=oobFDs\n                )[1]\n            )\n            if oobFDs:\n                # copy class based _headerAttrs to add a unix_fds header this\n                # time\n                _headerAttrs = list(self._headerAttrs)\n                _headerAttrs.append(('unix_fds', 9, False))\n                self.unix_fds = len(oobFDs)\n        else:\n            binBody = b''\n\n        self.headers = []\n\n        for attr_name, code, _ in _headerAttrs:\n            hval = getattr(self, attr_name, None)\n\n            if hval is not None:\n                if attr_name == 'path':\n                    hval = marshal.ObjectPath(hval)\n                elif attr_name == 'signature':\n                    hval = marshal.Signature(hval)\n                elif attr_name == 'unix_fds':\n                    hval = marshal.UInt32(hval)\n\n                self.headers.append([code, hval])\n\n        self.bodyLength = len(binBody)\n\n        if newSerial:\n            self.serial = DBusMessage._nextSerial\n\n            DBusMessage._nextSerial += 1\n\n        binHeader = b''.join(marshal.marshal(\n            _headerFormat,\n            [\n                self.endian,\n                self._messageType,\n                flags,\n                self._protocolVersion,\n                self.bodyLength,\n                self.serial,\n                self.headers\n            ],\n            lendian=self.endian == ord('l')\n        )[1])\n\n        headerPadding = marshal.pad['header'](len(binHeader))\n\n        self.rawHeader = binHeader\n        self.rawPadding = headerPadding\n        self.rawBody = binBody\n\n        self.rawMessage = b''.join([binHeader, headerPadding, binBody])\n\n        if len(self.rawMessage) > self._maxMsgLen:\n            raise error.MarshallingError(\n                'Marshalled message exceeds maximum message size of %d' %\n                (self._maxMsgLen,),\n            )", "response": "Marshal the message into binary format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencrypting the given plaintext value", "response": "def encrypt(self, plaintext):\n        \"\"\"Encrypt the given plaintext value\"\"\"\n        if not isinstance(plaintext, int):\n            raise ValueError('Plaintext must be an integer value')\n        if not self.in_range.contains(plaintext):\n            raise OutOfRangeError('Plaintext is not within the input range')\n        return self.encrypt_recursive(plaintext, self.in_range, self.out_range)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decrypt(self, ciphertext):\n        if not isinstance(ciphertext, int):\n            raise ValueError('Ciphertext must be an integer value')\n        if not self.out_range.contains(ciphertext):\n            raise OutOfRangeError('Ciphertext is not within the output range')\n        return self.decrypt_recursive(ciphertext, self.in_range, self.out_range)", "response": "Decrypt the given ciphertext value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tape_gen(self, data):\n\n        # FIXME\n        data = str(data).encode()\n\n        # Derive a key from data\n        hmac_obj = hmac.HMAC(self.key, digestmod=hashlib.sha256)\n        hmac_obj.update(data)\n        assert hmac_obj.digest_size == 32\n        digest = hmac_obj.digest()\n\n        # Use AES in the CTR mode to generate a pseudo-random bit string\n        aes_algo = algorithms.AES(digest)\n        aes_cipher = Cipher(aes_algo, mode=CTR(b'\\x00' * 16), backend=default_backend())\n        encryptor = aes_cipher.encryptor()\n\n        while True:\n            encrypted_bytes = encryptor.update(b'\\x00' * 16)\n            # Convert the data to a list of bits\n            bits = util.str_to_bitstring(encrypted_bytes)\n            for bit in bits:\n                yield bit", "response": "Generate a bit string from the given data string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a random key for ope cipher.", "response": "def generate_key(block_size=32):\n        \"\"\"Generate random key for ope cipher.\n\n        Parameters\n        ----------\n        block_size : int, optional\n            Length of random bytes.\n\n        Returns\n        -------\n        random_key : str\n            A random key for encryption.\n\n        Notes:\n        ------\n        Implementation follows https://github.com/pyca/cryptography\n        \"\"\"\n        random_seq = os.urandom(block_size)\n        random_key = base64.b64encode(random_seq)\n        return random_key"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef byte_to_bitstring(byte):\n    assert 0 <= byte <= 0xff\n    bits = [int(x) for x in list(bin(byte + 0x100)[3:])]\n    return bits", "response": "Convert one byte to a list of bits"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef str_to_bitstring(data):\n    assert isinstance(data, bytes), \"Data must be an instance of bytes\"\n    byte_list = data_to_byte_list(data)\n    bit_list = [bit for data_byte in byte_list for bit in byte_to_bitstring(data_byte)]\n    return bit_list", "response": "Convert a string to a list of bits"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sample_hgd(in_range, out_range, nsample, seed_coins):\n    in_size = in_range.size()\n    out_size = out_range.size()\n    assert in_size > 0 and out_size > 0\n    assert in_size <= out_size\n    assert out_range.contains(nsample)\n\n    # 1-based index of nsample in out_range\n    nsample_index = nsample - out_range.start + 1\n    if in_size == out_size:\n        # Input and output domains have equal size\n        return in_range.start + nsample_index - 1\n\n    in_sample_num = HGD.rhyper(nsample_index, in_size, out_size - in_size, seed_coins)\n    if in_sample_num == 0:\n        return in_range.start\n    else:\n        in_sample = in_range.start + in_sample_num - 1\n        assert in_range.contains(in_sample)\n        return in_sample", "response": "Get a sample from the hypergeometric distribution using the provided bit list as a source of randomness"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample_uniform(in_range, seed_coins):\n    if isinstance(seed_coins, list):\n        seed_coins.append(None)\n        seed_coins = iter(seed_coins)\n    cur_range = in_range.copy()\n    assert cur_range.size() != 0\n    while cur_range.size() > 1:\n        mid = (cur_range.start + cur_range.end) // 2\n        bit = next(seed_coins)\n        if bit == 0:\n            cur_range.end = mid\n        elif bit == 1:\n            cur_range.start = mid + 1\n        elif bit is None:\n            raise NotEnoughCoinsError()\n        else:\n            raise InvalidCoinError()\n    assert cur_range.size() == 1\n    return cur_range.start", "response": "Uniformly select a number from the range using the bit list as a source of randomness"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting a HTTP download returning a HTTPDownloader object", "response": "def __downloadPage(factory, *args, **kwargs):\n    \"\"\"Start a HTTP download, returning a HTTPDownloader object\"\"\"\n\n    # The Twisted API is weird:\n    # 1) web.client.downloadPage() doesn't give us the HTTP headers\n    # 2) there is no method that simply accepts a URL and gives you back\n    #    a HTTPDownloader object\n\n    #TODO: convert getPage() usage to something similar, too\n\n    downloader = factory(*args, **kwargs)\n    if downloader.scheme == 'https':\n        from twisted.internet import ssl\n        contextFactory = ssl.ClientContextFactory()\n        reactor.connectSSL(downloader.host, downloader.port,\n                           downloader, contextFactory)\n    else:\n        reactor.connectTCP(downloader.host, downloader.port,\n                           downloader)\n    return downloader"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nencodes the multipart request.", "response": "def __encodeMultipart(self, fields, files):\n        \"\"\"\n        fields is a sequence of (name, value) elements for regular form fields.\n        files is a sequence of (name, filename, value) elements for data to be uploaded as files\n        Return (content_type, body) ready for httplib.HTTP instance\n        \"\"\"\n        boundary = mimetools.choose_boundary()\n        crlf = '\\r\\n'\n\n        l = []\n        for k, v in fields:\n            l.append('--' + boundary)\n            l.append('Content-Disposition: form-data; name=\"%s\"' % k)\n            l.append('')\n            l.append(v)\n        for (k, f, v) in files:\n            l.append('--' + boundary)\n            l.append('Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (k, f))\n            l.append('Content-Type: %s' % self.__getContentType(f))\n            l.append('')\n            l.append(v)\n        l.append('--' + boundary + '--')\n        l.append('')\n        body = crlf.join(l)\n\n        return boundary, body"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a deferred for a HTTP client after handling incoming headers", "response": "def __clientDefer(self, c):\n        \"\"\"Return a deferred for a HTTP client, after handling incoming headers\"\"\"\n        def handle_headers(r):\n            self.gotHeaders(c.response_headers)\n            return r\n\n        return c.deferred.addBoth(handle_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __doDownloadPage(self, *args, **kwargs):\n        logger.debug(\"download page: %r, %r\", args, kwargs)\n\n        return self.__clientDefer(downloadPage(*args, **kwargs))", "response": "Works like client. downloadPage but handles incoming headers\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nverifying a user s credentials.", "response": "def verify_credentials(self, delegate=None):\n        \"Verify a user's credentials.\"\n        parser = txml.Users(delegate)\n        return self.__downloadPage('/account/verify_credentials.xml', parser)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, status, source=None, params={}):\n        \"Update your status.  Returns the ID of the new post.\"\n        params = params.copy()\n        params['status'] = status\n        if source:\n            params['source'] = source\n        return self.__parsed_post(self.__post('/statuses/update.xml', params),\n            txml.parseUpdateResponse)", "response": "Update your status. Returns the ID of the new post."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget updates from friends. Calls the delgate once for each status object received.", "response": "def friends(self, delegate, params={}, extra_args=None):\n        \"\"\"Get updates from friends.\n\n        Calls the delgate once for each status object received.\"\"\"\n        return self.__get('/statuses/friends_timeline.xml', delegate, params,\n            txml.Statuses, extra_args=extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets updates from friends. MimeType Calls the delgate once for each status object received.", "response": "def home_timeline(self, delegate, params={}, extra_args=None):\n        \"\"\"Get updates from friends.\n\n        Calls the delgate once for each status object received.\"\"\"\n        return self.__get('/statuses/home_timeline.xml', delegate, params,\n            txml.Statuses, extra_args=extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the most recent updates for a user.", "response": "def user_timeline(self, delegate, user=None, params={}, extra_args=None):\n        \"\"\"Get the most recent updates for a user.\n\n        If no user is specified, the statuses for the authenticating user are\n        returned.\n\n        See search for example of how results are returned.\"\"\"\n        if user:\n            params['id'] = user\n        return self.__get('/statuses/user_timeline.xml', delegate, params,\n                          txml.Statuses, extra_args=extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef public_timeline(self, delegate, params={}, extra_args=None):\n        \"Get the most recent public timeline.\"\n\n        return self.__get('/statuses/public_timeline.atom', delegate, params,\n                          extra_args=extra_args)", "response": "Get the most recent public timeline."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the direct messages for the authenticating user.", "response": "def direct_messages(self, delegate, params={}, extra_args=None):\n        \"\"\"Get direct messages for the authenticating user.\n\n        Search results are returned one message at a time a DirectMessage\n        objects\"\"\"\n        return self.__get('/direct_messages.xml', delegate, params,\n                          txml.Direct, extra_args=extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_direct_message(self, text, user=None, delegate=None, screen_name=None, user_id=None, params={}):\n        params = params.copy()\n        if user is not None:\n            params['user'] = user\n        if user_id is not None:\n            params['user_id'] = user_id\n        if screen_name is not None:\n            params['screen_name'] = screen_name\n        params['text'] = text\n        parser = txml.Direct(delegate)\n        return self.__postPage('/direct_messages/new.xml', parser, params)", "response": "Send a direct message to the user."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the most recent replies for the authenticating user.", "response": "def replies(self, delegate, params={}, extra_args=None):\n        \"\"\"Get the most recent replies for the authenticating user.\n\n        See search for example of how results are returned.\"\"\"\n        return self.__get('/statuses/replies.atom', delegate, params,\n                          extra_args=extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef follow_user(self, user, delegate):\n        parser = txml.Users(delegate)\n        return self.__postPage('/friendships/create/%s.xml' % (user), parser)", "response": "Follow the given user. Returns the user info back to the given delegate."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unfollow_user(self, user, delegate):\n        parser = txml.Users(delegate)\n        return self.__postPage('/friendships/destroy/%s.xml' % (user), parser)", "response": "Unfollows the given user. Returns the user info back to the given delegate."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the list of friends for a user. Calls the delegate with each user object found.", "response": "def list_friends(self, delegate, user=None, params={}, extra_args=None, page_delegate=None):\n        \"\"\"Get the list of friends for a user.\n\n        Calls the delegate with each user object found.\"\"\"\n        if user:\n            url = '/statuses/friends/' + user + '.xml'\n        else:\n            url = '/statuses/friends.xml'\n\n        return self.__get_maybe_paging(url, delegate, params, txml.PagedUserList, extra_args, page_delegate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the info for a specific user. Returns a delegate that will receive the user in a callback.", "response": "def show_user(self, user):\n        \"\"\"Get the info for a specific user.\n\n        Returns a delegate that will receive the user in a callback.\"\"\"\n\n        url = '/users/show/%s.xml' % (user)\n        d = defer.Deferred()\n\n        self.__downloadPage(url, txml.Users(lambda u: d.callback(u))) \\\n            .addErrback(lambda e: d.errback(e))\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search(self, query, delegate, args=None, extra_args=None):\n        if args is None:\n            args = {}\n        args['q'] = query\n        return self.__doDownloadPage(self.search_url + '?' + self._urlencode(args),\n            txml.Feed(delegate, extra_args), agent=self.agent)", "response": "Perform a search query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef startService(self):\n        service.Service.startService(self)\n        self._toState('idle')\n\n        try:\n            self.connect()\n        except NoConsumerError:\n            pass", "response": "Start the service.\n\n        This causes a transition to the C{'idle'} state, and then calls\n        L{connect} to attempt an initial conection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to the current state of the current Tweets.", "response": "def connect(self, forceReconnect=False):\n        \"\"\"\n        Check current conditions and initiate connection if possible.\n\n        This is called to check preconditions for starting a new connection,\n        and initating the connection itself.\n\n        If the service is not running, this will do nothing.\n\n        @param forceReconnect: Drop an existing connection to reconnnect.\n        @type forceReconnect: C{False}\n\n        @raises L{ConnectError}: When a connection (attempt) is already in\n            progress, unless C{forceReconnect} is set.\n\n        @raises L{NoConsumerError}: When there is no consumer for incoming\n        tweets. No further connection attempts will be made, unless L{connect}\n        is called again.\n        \"\"\"\n        if self._state == 'stopped':\n            raise Error(\"This service is not running. Not connecting.\")\n        if self._state == 'connected':\n            if forceReconnect:\n                self._toState('disconnecting')\n                return True\n            else:\n                raise ConnectError(\"Already connected.\")\n        elif self._state == 'aborting':\n            raise ConnectError(\"Aborting connection in progress.\")\n        elif self._state == 'disconnecting':\n            raise ConnectError(\"Disconnect in progress.\")\n        elif self._state == 'connecting':\n            if forceReconnect:\n                self._toState('aborting')\n                return True\n            else:\n                raise ConnectError(\"Connect in progress.\")\n\n        if self.delegate is None:\n            if self._state != 'idle':\n                self._toState('idle')\n            raise NoConsumerError()\n\n        if self._state == 'waiting':\n            if self._reconnectDelayedCall.called:\n                self._reconnectDelayedCall = None\n                pass\n            else:\n                self._reconnectDelayedCall.reset(0)\n                return True\n\n        self._toState('connecting')\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when the connection has been established. This method is called when an HTTP 200 response has been received, with the protocol that decodes the individual Twitter stream elements. That protocol will call the consumer for all Twitter entries received. The protocol, stored in L{protocol}, has a deferred that fires when the connection is closed, causing a transition to the C{'disconnected'} state. @param protocol: The Twitter stream protocol. @type protocol: L{TwitterStream}", "response": "def makeConnection(self, protocol):\n        \"\"\"\n        Called when the connection has been established.\n\n        This method is called when an HTTP 200 response has been received,\n        with the protocol that decodes the individual Twitter stream elements.\n        That protocol will call the consumer for all Twitter entries received.\n\n        The protocol, stored in L{protocol}, has a deferred that fires when\n        the connection is closed, causing a transition to the\n        C{'disconnected'} state.\n\n        @param protocol: The Twitter stream protocol.\n        @type protocol: L{TwitterStream}\n        \"\"\"\n        self._errorState = None\n\n        def cb(result):\n            self.protocol = None\n            if self._state == 'stopped':\n                # Don't transition to any other state. We are stopped.\n                pass\n            else:\n                if isinstance(result, failure.Failure):\n                    reason = result\n                else:\n                    reason = None\n                self._toState('disconnected', reason)\n\n        self.protocol = protocol\n        d = protocol.deferred\n        d.addBoth(cb)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nattempts to reconnect. If the current back-off delay is 0, L{connect} is called. Otherwise, it will cause a transition to the C{'waiting'} state, ultimately causing a call to L{connect} when the delay expires.", "response": "def _reconnect(self, errorState):\n        \"\"\"\n        Attempt to reconnect.\n\n        If the current back-off delay is 0, L{connect} is called. Otherwise,\n        it will cause a transition to the C{'waiting'} state, ultimately\n        causing a call to L{connect} when the delay expires.\n        \"\"\"\n        def connect():\n            if self.noisy:\n                log.msg(\"Reconnecting now.\")\n            self.connect()\n\n        backOff = self.backOffs[errorState]\n\n        if self._errorState != errorState or self._delay is None:\n            self._errorState = errorState\n            self._delay = backOff['initial']\n        else:\n            self._delay = min(backOff['max'], self._delay * backOff['factor'])\n\n        if self._delay == 0:\n            connect()\n        else:\n            self._reconnectDelayedCall = self.reactor.callLater(self._delay,\n                                                                connect)\n            self._toState('waiting')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _toState(self, state, *args, **kwargs):\n        try:\n            method = getattr(self, '_state_%s' % state)\n        except AttributeError:\n            raise ValueError(\"No such state %r\" % state)\n\n        log.msg(\"%s: to state %r\" % (self.__class__.__name__, state))\n        self._state = state\n        method(*args, **kwargs)", "response": "Transition to the next state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstating of an error.", "response": "def _state_error(self, reason):\n        \"\"\"\n        The connection attempt resulted in an error.\n\n        Attempt a reconnect with a back-off algorithm.\n        \"\"\"\n        log.err(reason)\n\n        def matchException(failure):\n            for errorState, backOff in self.backOffs.iteritems():\n                if 'errorTypes' not in backOff:\n                    continue\n                if failure.check(*backOff['errorTypes']):\n                    return errorState\n\n            return 'other'\n\n        errorState = matchException(reason)\n        self._reconnect(errorState)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when a line is received.", "response": "def lineReceived(self, line):\n        \"\"\"\n        Called when a line is received.\n\n        We expect a length in bytes or an empty line for keep-alive. If\n        we got a length, switch to raw mode to receive that amount of bytes.\n        \"\"\"\n        if line and line.isdigit():\n            self._expectedLength = int(line)\n            self._rawBuffer = []\n            self._rawBufferLength = 0\n            self.setRawMode()\n        else:\n            self.keepAliveReceived()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rawDataReceived(self, data):\n        self._rawBuffer.append(data)\n        self._rawBufferLength += len(data)\n\n        if self._rawBufferLength >= self._expectedLength:\n            receivedData = ''.join(self._rawBuffer)\n            expectedData = receivedData[:self._expectedLength]\n            extraData = receivedData[self._expectedLength:]\n\n            self._rawBuffer = None\n            self._rawBufferLength = None\n            self._expectedLength = None\n\n            self.datagramReceived(expectedData)\n            self.setLineMode(extraData)", "response": "Called when raw data is received."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfills this objects attributes from a dictionary for known properties.", "response": "def fromDict(cls, data):\n        \"\"\"\n        Fill this objects attributes from a dict for known properties.\n        \"\"\"\n        obj = cls()\n        obj.raw = data\n        for name, value in data.iteritems():\n            if cls.SIMPLE_PROPS and name in cls.SIMPLE_PROPS:\n                setattr(obj, name, value)\n            elif cls.COMPLEX_PROPS and name in cls.COMPLEX_PROPS:\n                value = cls.COMPLEX_PROPS[name].fromDict(value)\n                setattr(obj, name, value)\n            elif cls.LIST_PROPS and name in cls.LIST_PROPS:\n                value = [cls.LIST_PROPS[name].fromDict(item)\n                         for item in value]\n                setattr(obj, name, value)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode the JSON - encoded datagram and call the callback.", "response": "def datagramReceived(self, data):\n        \"\"\"\n        Decode the JSON-encoded datagram and call the callback.\n        \"\"\"\n        try:\n            obj = json.loads(data)\n        except ValueError, e:\n            log.err(e, 'Invalid JSON in stream: %r' % data)\n            return\n\n        if u'text' in obj:\n            obj = Status.fromDict(obj)\n        else:\n            log.msg('Unsupported object %r' % obj)\n            return\n\n        self.callback(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls when the connection is lost.", "response": "def connectionLost(self, reason):\n        \"\"\"\n        Called when the body is complete or the connection was lost.\n\n        @note: As the body length is usually not known at the beginning of the\n        response we expect a L{PotentialDataLoss} when Twitter closes the\n        stream, instead of L{ResponseDone}. Other exceptions are treated\n        as error conditions.\n        \"\"\"\n        self.setTimeout(None)\n        if reason.check(ResponseDone, PotentialDataLoss):\n            self.deferred.callback(None)\n        else:\n            self.deferred.errback(reason)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef simpleListFactory(list_type):\n    def create(delegate, extra_args=None):\n        \"\"\"Create a Parser object for the specific tag type, on the fly\"\"\"\n        return listParser(list_type, delegate, extra_args)\n    return create", "response": "Used for simple parsers that support only one type of object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a delegate for a sub - sub - item according to a list of names", "response": "def setSubDelegates(self, namelist, before=None, after=None):\n        \"\"\"Set a delegate for a sub-sub-item, according to a list of names\"\"\"\n        if len(namelist) > 1:\n            def set_sub(i):\n                i.setSubDelegates(namelist[1:], before, after)\n            self.setBeforeDelegate(namelist[0], set_sub)\n        elif len(namelist) == 1:\n            self.setDelegate(namelist[0], before, after)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsplit a path into sentinel list_path and path", "response": "def _split_path(path):\n    \"\"\"split a path return by the api\n\n    return\n        - the sentinel:\n        - the rest of the path as a list.\n        - the original path stripped of / for normalisation.\n    \"\"\"\n    path = path.strip('/')\n    list_path = path.split('/')\n    sentinel = list_path.pop(0)\n    return sentinel, list_path, path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeactivating the contents manager class", "response": "def deactivate(profile='default'):\n    \"\"\"should be a matter of just unsetting the above keys\n    \"\"\"\n    with jconfig(profile) as config:\n        deact = True;\n        if not getattr(config.NotebookApp.contents_manager_class, 'startswith',lambda x:False)('jupyterdrive'):\n            deact=False\n        if 'gdrive' not in getattr(config.NotebookApp.tornado_settings,'get', lambda _,__:'')('contents_js_source',''):\n            deact=False\n        if deact:\n            del config['NotebookApp']['tornado_settings']['contents_js_source']\n            del config['NotebookApp']['contents_manager_class']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sequence_type(seq):\n    '''Validates a coral.sequence data type.\n\n    :param sequence_in: input DNA sequence.\n    :type sequence_in: any\n    :returns: The material - 'dna', 'rna', or 'peptide'.\n    :rtype: str\n    :raises: ValueError\n\n    '''\n    if isinstance(seq, coral.DNA):\n        material = 'dna'\n    elif isinstance(seq, coral.RNA):\n        material = 'rna'\n    elif isinstance(seq, coral.Peptide):\n        material = 'peptide'\n    else:\n        raise ValueError('Input was not a recognized coral.sequence object.')\n    return material", "response": "Validates a coral. sequence data type. Returns the material - dna rna or peptide."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsimulates a PCR. :param template: DNA template from which to PCR. :type template: coral.DNA :param primer1: First PCR primer. :type primer1: coral.Primer :param primer2: First PCR primer. :type primer2: coral.Primer :param min_tm: Minimum melting temperature (Tm) at which primers must bind to the template. :type min_tm: float :param min_primer_len: Minimum amount of template homology required at the 3' end of each primer. :type min_primer_len: int :returns: A dsDNA Amplicon. :rtype: coral.DNA :raises: PrimingError if a primer binds more than once on the template, primers bind in overlapping sequence of the template, there are no forward primer binding sites or reverse priming sites, or if the PCR would work only on a circular version of the template (if template is linear).", "response": "def pcr(template, primer1, primer2, min_tm=50.0, min_primer_len=14):\n    '''Simulate a PCR.\n\n    :param template: DNA template from which to PCR.\n    :type template: coral.DNA\n    :param primer1: First PCR primer.\n    :type primer1: coral.Primer\n    :param primer2: First PCR primer.\n    :type primer2: coral.Primer\n    :param min_tm: Minimum melting temperature (Tm) at which primers must bind\n                   to the template.\n    :type min_tm: float\n    :param min_primer_len: Minimum amount of template homology required at the\n                           3' end of each primer.\n    :type min_primer_len: int\n    :returns: A dsDNA Amplicon.\n    :rtype: coral.DNA\n    :raises: PrimingError if a primer binds more than once on the template,\n             primers bind in overlapping sequence of the template, there are no\n             forward primer binding sites or reverse priming sites, or if the\n             PCR would work only on a circular version of the template (if\n             template is linear).\n\n    '''\n    # Find match in top or bottom strands for each primer\n    p1_matches = coral.analysis.anneal(template, primer1, min_tm=min_tm,\n                                       min_len=min_primer_len)\n    p2_matches = coral.analysis.anneal(template, primer2, min_tm=min_tm,\n                                       min_len=min_primer_len)\n    p1_binding_locations = [m[0] for strand in p1_matches for m in strand]\n    p2_binding_locations = [m[0] for strand in p2_matches for m in strand]\n\n    # Ensure unique top and bottom matches\n    if len(p1_binding_locations) > 1:\n        primer_msg = 'Multiple primer 1 binding locations: {}'\n        raise PrimingError(primer_msg.format(p1_binding_locations))\n\n    if len(p2_binding_locations) > 1:\n        primer_msg = 'Multiple primer 2 binding locations: {}'\n        raise PrimingError(primer_msg.format(p2_binding_locations))\n\n    if not p1_binding_locations and not p2_binding_locations:\n        raise PrimingError('Neither primer binds the template')\n\n    if not p1_binding_locations:\n        raise PrimingError('Primer 1 does not bind the template')\n\n    if not p2_binding_locations:\n        raise PrimingError('Primer 2 does not bind the template')\n\n    # Check that primers bind on opposite strands of the template\n    tops = p1_matches[0] + p2_matches[0]\n    bottoms = p1_matches[1] + p2_matches[1]\n    if not tops:\n        raise PrimingError('No primers bind the template\\'s top strand.')\n    if not bottoms:\n        raise PrimingError('No primers bind the template\\'s bottom strand.')\n\n    # Figure out which primer matches the top strand\n    if p1_matches[0]:\n        # primer1 is top\n        fwd = primer1\n        rev = primer2\n    else:\n        # primer2 matches top strand\n        fwd = primer2\n        rev = primer1\n\n    # Now we can simulate the PCR. If primer locations are overlapping, we\n    # throw an error. If the primers won't amplify a product (e.g. a linear\n    # template with primers facing away from one another), throw a different\n    # error. Otherwise, amplify the product, including any overhangs.\n\n    # 3' locations, annealing region length\n    fwd_3, fwd_len = tops[0]\n    rev_3, rev_len = bottoms[0]\n\n    # 5' locations\n    fwd_5 = fwd_3 - fwd_len\n    rev_5 = rev_3 - rev_len\n\n    # location on the top strand where the 'reverse' primer ends (its 3' end)\n    rev_3_top = len(template) - rev_3\n    rev_5_top = len(template) - rev_5\n    # TODO: Use % operator?\n    if rev_5_top > len(template):\n        rev_5_top = rev_5_top - len(template)\n\n    # overhangs\n    fwd_overhang = fwd.primer()[:-fwd_len]\n    rev_overhang = rev.primer()[:-rev_len]\n\n    # TODO: what about searching substrings over circulate templates?\n    # Cases:\n    # 1)  Primers point towards one another - overlapping is fine\n    #       -> isolate region between 5' annealing regions and tack on the\n    #          rest of the overhang.\n    # 2)  Primers point away from one another, template is linear\n    #       -> error\n    # 3)  Primers point away from one another, template is circular\n    #       a) Primers don't overlap\n    #           -> rotate to 'top' primer start, extract sequence\n    #       b) Primers overlap\n    #           -> Extract whole sequence as linear fragment, tack on rest of\n    #              'bottom' primer. May disrupt features.\n    if template.circular:\n        # Circular template - primers always point towards one another\n        if rev_3_top > fwd_3:\n            # Inter-primer region doesn't go over the origin (index 0)\n            # However, the 'anneal' region may extend over it.\n            # FIXME: handle case where 'anneal' region extends over origin\n            # FIXME: simplify - just generate 'before' and 'after', then\n            # combine with preamplicon later\n            if rev_3_top + rev_len > len(template):\n                # Reverse primer extends over the origin\n                if fwd_5 - fwd_len < 0:\n                    # Forward primer extends over the origin\n                    preamplicon = template.linearize()\n                    # Add extra anneal regions\n                    before = template[fwd_5:]\n                    after = template[:rev_5_top]\n                    preamplicon = before + preamplicon + after\n                else:\n                    # Only the reverse primer extends over the origin\n                    preamplicon = template[fwd_5:]\n                    after = template[:rev_5_top]\n                    preamplicon = preamplicon + after\n            elif fwd_5 - fwd_len < 0:\n                # Only the forward primer extends over the origin\n                before = template[fwd_5:]\n                preamplicon = before + template[:rev_5_top]\n            else:\n                # Extract like normal\n                preamplicon = template[fwd_5:len(template) - rev_5]\n        else:\n            # Inter-primer region goes over the origin (index 0)\n            preamplicon_len = len(template) - fwd_5 + rev_5_top\n            preamplicon = template.rotate(-fwd_5)[:preamplicon_len]\n    else:\n        # Linear template\n        if rev_3_top < fwd_5 or fwd_3 > rev_5_top:\n            # Primers point away from one another.\n            raise PrimingError('Primers point away from one another.')\n        else:\n            # Primers point towards each other.\n            preamplicon = template[fwd_5:len(template) - rev_5]\n\n    # Add overhangs\n    amplicon = (fwd_overhang.to_ds() +\n                preamplicon +\n                rev_overhang.to_ds().reverse_complement())\n\n    return amplicon"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a DNA template and a restriction endonuclease reaction return a list of digested DNA fragments.", "response": "def digest(dna, restriction_enzyme):\n    '''Restriction endonuclease reaction.\n\n    :param dna: DNA template to digest.\n    :type dna: coral.DNA\n    :param restriction_site: Restriction site to use.\n    :type restriction_site: RestrictionSite\n    :returns: list of digested DNA fragments.\n    :rtype: coral.DNA list\n\n    '''\n    pattern = restriction_enzyme.recognition_site\n    located = dna.locate(pattern)\n    if not located[0] and not located[1]:\n        return [dna]\n    # Bottom strand indices are relative to the bottom strand 5' end.\n    # Convert to same type as top strand\n    pattern_len = len(pattern)\n    r_indices = [len(dna) - index - pattern_len for index in\n                 located[1]]\n    # If sequence is palindrome, remove redundant results\n    if pattern.is_palindrome():\n        r_indices = [index for index in r_indices if index not in\n                     located[0]]\n    # Flatten cut site indices\n    cut_sites = sorted(located[0] + r_indices)\n    # Go through each cut site starting at highest one\n    # Cut remaining template once, generating remaining + new\n    current = [dna]\n    for cut_site in cut_sites[::-1]:\n        new = _cut(current, cut_site, restriction_enzyme)\n        current.append(new[1])\n        current.append(new[0])\n    current.reverse()\n    # Combine first and last back together if digest was circular\n    if dna.circular:\n        current[0] = current.pop() + current[0]\n    return current"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _cut(dna, index, restriction_enzyme):\n    '''Cuts template once at the specified index.\n\n    :param dna: DNA to cut\n    :type dna: coral.DNA\n    :param index: index at which to cut\n    :type index: int\n    :param restriction_enzyme: Enzyme with which to cut\n    :type restriction_enzyme: coral.RestrictionSite\n    :returns: 2-element list of digested sequence, including any overhangs.\n    :rtype: list\n\n    '''\n    # TODO: handle case where cut site is outside of recognition sequence,\n    # for both circular and linear cases where site is at index 0\n    # Find absolute indices at which to cut\n    cut_site = restriction_enzyme.cut_site\n    top_cut = index + cut_site[0]\n    bottom_cut = index + cut_site[1]\n\n    # Isolate left and ride sequences\n    to_cut = dna.pop()\n    max_cut = max(top_cut, bottom_cut)\n    min_cut = min(top_cut, bottom_cut)\n    left = to_cut[:max_cut]\n    right = to_cut[min_cut:]\n\n    # If applicable, leave overhangs\n    diff = top_cut - bottom_cut\n    if not diff:\n        # Blunt-end cutter, no adjustment necessary\n        pass\n    elif diff > 0:\n        # 3' overhangs\n        left = coral.reaction.five_resect(left.flip(), diff).flip()\n        right = coral.reaction.five_resect(right, diff)\n    else:\n        # 5' overhangs\n        left = coral.reaction.three_resect(left, abs(diff))\n        right = coral.reaction.three_resect(right.flip(), abs(diff)).flip()\n\n    return [left, right]", "response": "Cuts template once at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ipynb_to_rst(directory, filename):\n    print(filename)\n    os.chdir(directory)\n    subprocess.Popen([\"ipython\", \"nbconvert\", \"--to\", \"rst\",\n                      filename],\n                     stdout=subprocess.PIPE,\n                     stderr=subprocess.PIPE,\n                     cwd=directory)", "response": "Converts a given file in a directory to an rst in the same directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_ipynbs(directory):\n    # The ipython_examples dir has to be in the same dir as this script\n    for root, subfolders, files in os.walk(os.path.abspath(directory)):\n        for f in files:\n            if \".ipynb_checkpoints\" not in root:\n                if f.endswith(\"ipynb\"):\n                    ipynb_to_rst(root, f)", "response": "Recursively converts all ipynb files in a directory into rst files in\n    the same directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _context_walk(dna, window_size, context_len, step):\n    '''Generate context-dependent 'non-boundedness' scores for a DNA sequence.\n\n    :param dna: Sequence to score.\n    :type dna: coral.DNA\n    :param window_size: Window size in base pairs.\n    :type window_size: int\n    :param context_len: The number of bases of context to use when analyzing\n                        each window.\n    :type context_len: int\n    :param step: The number of base pairs to move for each new window.\n    :type step: int\n\n    '''\n    # Generate window indices\n    window_start_ceiling = len(dna) - context_len - window_size\n    window_starts = range(context_len - 1, window_start_ceiling, step)\n    window_ends = [start + window_size for start in window_starts]\n\n    # Generate left and right in-context subsequences\n    l_starts = [step * i for i in range(len(window_starts))]\n    l_seqs = [dna[start:end] for start, end in zip(l_starts, window_ends)]\n    r_ends = [x + window_size + context_len for x in window_starts]\n    r_seqs = [dna[start:end].reverse_complement() for start, end in\n              zip(window_starts, r_ends)]\n\n    # Combine and calculate nupack pair probabilities\n    seqs = l_seqs + r_seqs\n    pairs_run = coral.analysis.nupack_multi(seqs, 'dna', 'pairs', {'index': 0})\n    # Focus on pair probabilities that matter - those in the window\n    pairs = [run[-window_size:] for run in pairs_run]\n    # Score by average pair probability\n    lr_scores = [sum(pair) / len(pair) for pair in pairs]\n\n    # Split into left-right contexts again and sum for each window\n    l_scores = lr_scores[0:len(seqs) / 2]\n    r_scores = lr_scores[len(seqs) / 2:]\n    scores = [(l + r) / 2 for l, r in zip(l_scores, r_scores)]\n\n    # Summarize and return window indices and score\n    summary = zip(window_starts, window_ends, scores)\n\n    return summary", "response": "Generate a context - dependent non - boundedness score for a DNA sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwalk through the sequence of interest in windows of window_size evaluate free pair probabilities.", "response": "def windows(self, window_size=60, context_len=90, step=10):\n        '''Walk through the sequence of interest in windows of window_size,\n        evaluate free (unbound) pair probabilities.\n\n        :param window_size: Window size in base pairs.\n        :type window_size: int\n        :param context_len: The number of bases of context to use when\n                            analyzing each window.\n        :type context_len: int\n        :param step: The number of base pairs to move for each new window.\n        :type step: int\n\n        '''\n        self.walked = _context_walk(self.template, window_size, context_len,\n                                    step)\n        self.core_starts, self.core_ends, self.scores = zip(*self.walked)\n        return self.walked"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot(self):\n        '''Plot the results of the run method.'''\n        try:\n            from matplotlib import pylab\n        except ImportError:\n            raise ImportError('Optional dependency matplotlib not installed.')\n\n        if self.walked:\n            fig = pylab.figure()\n            ax1 = fig.add_subplot(111)\n            ax1.plot(self.core_starts, self.scores, 'bo-')\n            pylab.xlabel('Core sequence start position (base pairs).')\n            pylab.ylabel('Score - Probability of being unbound.')\n            pylab.show()\n        else:\n            raise Exception('Run calculate() first so there\\'s data to plot!')", "response": "Plot the results of the run method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsimulate a primer binding event. Will find the maximum subset of basepairs in the primer that binds to the template and extend them until the maximum basepair is found.", "response": "def anneal(template, primer, min_tm=50.0, min_len=10):\n    '''Simulates a primer binding event. Will find the maximum subset\n    of bases in the primer that binds to the template, including overhang\n    sequences. **Note**: Primer binding locations indicate the 3' end of the\n    primer, not the begining of the annealing sequence.\n\n    :param template: DNA template for which to bind a primer.\n    :type template: coral.DNA\n    :param primer: Primer to bind to template.\n    :type primer: coral.Primer\n    :param min_tm: The cutoff melting temperature for primer binding - a binder\n                   with a lower Tm will be rejected.\n    :type min_tm: float\n    :param min_len: The cutoff for bases required for binding - a binder with\n                    fewer bases will be rejected.\n    :type min_len: int\n    :returns: A length 2 list (top and bottom strands) of matches. Each\n              match is itself a 2-tuple indicating (1) the location on the\n              template of the 3' end of the primer binding site and (2) the\n              length of the match (number of bases), e.g. [[(25, 15)],[]] would\n              indicate a single top-strand match at template position 25 with\n              15 bases of 3' primer homology.\n    :rtype: list\n    :raises: PrimerLengthError if primer length is too small.\n             AnnealError if inputs are of the wrong type.\n\n    '''\n    # TODO: add possibility for primer basepair mismatch\n    if len(primer) < min_len:\n        msg = 'Primer length is shorter than min_len argument.'\n        raise PrimerLengthError(msg)\n    if len(template) < min_len:\n        msg = 'Template is shorter than the min_len argument.'\n        raise AnnealError(msg)\n\n    # Strategy: locate all min-length matches, then extend them until they\n    # no longer match. This provides an advantage over the previous strategy of\n    # updating a dictionary with indices from coral.DNA.locate() as keys, as\n    # the latter's indices may actually move for a given primer as it passes\n    # over the origin\n    def update_match_linear(base, location_length, anneal_seq):\n        '''Increase the location and length of binding site, if applicable.'''\n        # TODO: this is very inefficient - should stop updating once the first\n        # mismatch occurs.\n        location, length = location_length\n\n        if location == 0:\n            return location_length\n\n        location_next = location - 1\n        length_next = length + 1\n        seq = base[location_next:location_next + length_next]\n\n        if seq == anneal_seq:\n            return (location_next, length_next)\n        else:\n            return location_length\n\n    def update_match_circular(base, location_length, anneal_seq):\n        '''Increase the location and length of binding site, if applicable.'''\n        # TODO: this is very inefficient - should stop updating once the first\n        # mismatch occurs.\n        base_len = len(base)\n        location, length = location_length\n        if location == 0:\n            location_next = base_len - 1\n        else:\n            location_next = location - 1\n        length_next = length + 1\n\n        if (location_next + length_next) > base_len:\n            upstream = base[location_next:]\n            downstream = base[:length_next - (base_len - location_next)]\n            seq = upstream + downstream\n        else:\n            # No need to 'rotate' sequence\n            seq = base[location_next:location_next + length_next]\n\n        if seq == anneal_seq:\n            return (location_next, length_next)\n        else:\n            return location_length\n\n    if template.circular:\n        update_fun = update_match_circular\n    else:\n        update_fun = update_match_linear\n\n    # Maximum annealing length to test (can't exceed template length)\n    max_len = min(len(template), len(primer))\n\n    primer_dna = primer.to_ds()\n    anneal_len = min_len\n    anneal_seq = primer_dna[-anneal_len:]\n    binding_data = []\n    for k, strand_locs in enumerate(template.locate(anneal_seq)):\n        matches = zip(strand_locs, [min_len] * len(strand_locs))\n        for i in range(anneal_len + 1, max_len + 1):\n            anneal_seq = primer_dna[-i:]\n            for j, match in enumerate(matches):\n                if k == 0:\n                    matches[j] = update_fun(template.top, match, anneal_seq)\n                else:\n                    matches[j] = update_fun(template.bottom, match,\n                                            anneal_seq)\n        binding_data.append(matches)\n\n    # Now, filter out all the matches that are too short\n    for i in reversed(range(len(primer_dna) + 1)):\n        min_len = i + 1\n        tm = primer_dna[-min_len:].tm()\n        if tm < min_tm:\n            break\n\n    for strand in binding_data:\n        for i in reversed(range(len(strand))):\n            if strand[i][1] < min_len:\n                strand.pop(i)\n\n    # Finally, adjust the position to be the 3' end\n    for strand in binding_data:\n        for i, match in enumerate(strand):\n            length = match[1]\n            loc_new = match[0] + length\n            if loc_new > len(template):\n                # Circularly permute\n                loc_new = loc_new - len(template)\n            strand[i] = [loc_new, length]\n\n    # Overwriting dictionary keys ensures uniqueness\n    # fwd_matches = {}\n    # rev_matches = {}\n    # for i in range(len(primer) - min_len + 1)[::-1]:\n    #     primer_dna = primer.overhang + primer.anneal\n    #     annealing = primer_dna[i:]\n    #     anneal_temp = annealing.tm()\n    #     anneal_len = len(annealing)\n    #     if anneal_temp > min_tm:\n    #         p_matches = template.locate(annealing)\n    #         for match in p_matches[0]:\n    #             fwd_matches[match + anneal_len] = anneal_len\n    #         for match in p_matches[1]:\n    #             rev_matches[match + anneal_len] = anneal_len\n\n    # # Convert dictionaries to lists\n    # fwds = [[key, val] for key, val in fwd_matches.iteritems()]\n    # revs = [[key, val] for key, val in rev_matches.iteritems()]\n\n    return binding_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndesigns a primer to a nearest - neighbor Tm setpoint.", "response": "def primer(dna, tm=65, min_len=10, tm_undershoot=1, tm_overshoot=3,\n           end_gc=False, tm_parameters='cloning', overhang=None,\n           structure=False):\n    '''Design primer to a nearest-neighbor Tm setpoint.\n\n    :param dna: Sequence for which to design a primer.\n    :type dna: coral.DNA\n    :param tm: Ideal primer Tm in degrees C.\n    :type tm: float\n    :param min_len: Minimum primer length.\n    :type min_len: int\n    :param tm_undershoot: Allowed Tm undershoot.\n    :type tm_undershoot: float\n    :param tm_overshoot: Allowed Tm overshoot.\n    :type tm_overshoot: float\n    :param end_gc: Obey the 'end on G or C' rule.\n    :type end_gc: bool\n    :param tm_parameters: Melting temp calculator method to use.\n    :type tm_parameters: string\n    :param overhang: Append the primer to this overhang sequence.\n    :type overhang: str\n    :param structure: Evaluate primer for structure, with warning for high\n                      structure.\n    :type structure: bool\n    :returns: A primer.\n    :rtype: coral.Primer\n    :raises: ValueError if the input sequence is lower than the Tm settings\n             allow.\n             ValueError if a primer ending with G or C can't be found given\n             the Tm settings.\n\n    '''\n    # Check Tm of input sequence to see if it's already too low\n    seq_tm = coral.analysis.tm(dna, parameters=tm_parameters)\n    if seq_tm < (tm - tm_undershoot):\n        msg = 'Input sequence Tm is lower than primer Tm setting'\n        raise ValueError(msg)\n    # Focus on first 90 bases - shouldn't need more than 90bp to anneal\n    dna = dna[0:90]\n\n    # Generate primers from min_len to 'tm' + tm_overshoot\n    # TODO: this is a good place for optimization. Only calculate as many\n    # primers as are needed. Use binary search.\n    primers_tms = []\n    last_tm = 0\n    bases = min_len\n    while last_tm <= tm + tm_overshoot and bases != len(dna):\n        next_primer = dna[0:bases]\n        last_tm = coral.analysis.tm(next_primer, parameters=tm_parameters)\n        primers_tms.append((next_primer, last_tm))\n        bases += 1\n\n    # Trim primer list based on tm_undershoot and end_gc\n    primers_tms = [(primer, melt) for primer, melt in primers_tms if\n                   melt >= tm - tm_undershoot]\n    if end_gc:\n        primers_tms = [pair for pair in primers_tms if\n                       pair[0][-1] == coral.DNA('C') or\n                       pair[0][-1] == coral.DNA('G')]\n    if not primers_tms:\n        raise ValueError('No primers could be generated using these settings')\n\n    # Find the primer closest to the set Tm, make it single stranded\n    tm_diffs = [abs(melt - tm) for primer, melt in primers_tms]\n    best_index = tm_diffs.index(min(tm_diffs))\n    best_primer, best_tm = primers_tms[best_index]\n    best_primer = best_primer.top\n\n    # Apply overhang\n    if overhang:\n        overhang = overhang.top\n\n    output_primer = coral.Primer(best_primer, best_tm, overhang=overhang)\n\n    def _structure(primer):\n        '''Check annealing sequence for structure.\n\n        :param primer: Primer for which to evaluate structure\n        :type primer: sequence.Primer\n\n        '''\n        # Check whole primer for high-probability structure, focus in on\n        # annealing sequence, report average\n        nupack = coral.analysis.Nupack(primer.primer())\n        pairs = nupack.pairs(0)\n        anneal_len = len(primer.anneal)\n        pairs_mean = sum(pairs[-anneal_len:]) / anneal_len\n        if pairs_mean < 0.5:\n            warnings.warn('High probability structure', Warning)\n        return pairs_mean\n    if structure:\n        _structure(output_primer)\n    return output_primer"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndesign primers for PCR amplifying any arbitrary sequence.", "response": "def primers(dna, tm=65, min_len=10, tm_undershoot=1, tm_overshoot=3,\n            end_gc=False, tm_parameters='cloning', overhangs=None,\n            structure=False):\n    '''Design primers for PCR amplifying any arbitrary sequence.\n\n    :param dna: Input sequence.\n    :type dna: coral.DNA\n    :param tm: Ideal primer Tm in degrees C.\n    :type tm: float\n    :param min_len: Minimum primer length.\n    :type min_len: int\n    :param tm_undershoot: Allowed Tm undershoot.\n    :type tm_undershoot: float\n    :param tm_overshoot: Allowed Tm overshoot.\n    :type tm_overshoot: float\n    :param end_gc: Obey the 'end on G or C' rule.\n    :type end_gc: bool\n    :param tm_parameters: Melting temp calculator method to use.\n    :type tm_parameters: string\n    :param overhangs: 2-tuple of overhang sequences.\n    :type overhangs: tuple\n    :param structure: Evaluate each primer for structure, with warning for high\n                      structure.\n    :type structure: bool\n    :returns: A list primers (the output of primer).\n    :rtype: list\n\n    '''\n    if not overhangs:\n        overhangs = [None, None]\n    templates = [dna, dna.reverse_complement()]\n    primer_list = []\n    for template, overhang in zip(templates, overhangs):\n        primer_i = primer(template, tm=tm, min_len=min_len,\n                          tm_undershoot=tm_undershoot,\n                          tm_overshoot=tm_overshoot, end_gc=end_gc,\n                          tm_parameters=tm_parameters,\n                          overhang=overhang, structure=structure)\n        primer_list.append(primer_i)\n    return primer_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list of DNA sequences assemble into a single construct.", "response": "def assemble_oligos(dna_list, reference=None):\n    '''Given a list of DNA sequences, assemble into a single construct.\n    :param dna_list: List of DNA sequences - they must be single-stranded.\n    :type dna_list: coral.DNA list\n    :param reference: Expected sequence - once assembly completed, this will\n    be used to reorient the DNA (assembly could potentially occur from either\n    side of a linear DNA construct if oligos are in a random order). If this\n    fails, an AssemblyError is raised.\n    :type reference: coral.DNA\n    :raises: AssemblyError if it can't assemble for any reason.\n    :returns: A single assembled DNA sequence\n    :rtype: coral.DNA\n\n    '''\n    # FIXME: this protocol currently only supports 5' ends on the assembly\n    # Find all matches for every oligo. If more than 2 per side, error.\n    # Self-oligo is included in case the 3' end is self-complementary.\n    # 1) Find all unique 3' binders (and non-binders).\n    match_3 = [bind_unique(seq, dna_list, right=True) for i, seq in\n               enumerate(dna_list)]\n    # 2) Find all unique 5' binders (and non-binders).\n    match_5 = [bind_unique(seq, dna_list, right=False) for i, seq in\n               enumerate(dna_list)]\n    # Assemble into 2-tuple\n    zipped = zip(match_5, match_3)\n\n    # 3) If none found, error out with 'oligo n has no binders'\n    for i, oligo_match in enumerate(zipped):\n        if not any(oligo_match):\n            error = 'Oligo {} has no binding partners.'.format(i + 1)\n            raise AssemblyError(error)\n    # 4) There should be exactly 2 oligos that bind at 3' end but\n    # not 5'.\n    ends = []\n    for i, (five, three) in enumerate(zipped):\n        if five is None and three is not None:\n            ends.append(i)\n    # 5) If more than 2, error with 'too many ends'.\n    if len(ends) > 2:\n        raise AssemblyError('Too many (>2) end oligos found.')\n    # 6) If more than 2, error with 'not enough ends'.\n    if len(ends) < 2:\n        raise AssemblyError('Not enough (<2) end oligos found.')\n    # NOTE:If 1-4 are satisfied, unique linear assembly has been found (proof?)\n    # 8) Start with first end and build iteratively\n    last_index = ends[0]\n    assembly = dna_list[last_index]\n    flip = True\n    # This would be slightly less complicated if the sequences were tied to\n    # their match info in a tuple\n    # Append next region n - 1 times\n    for i in range(len(dna_list) - 1):\n        if flip:\n            # Next oligo needs to be flipped before concatenation\n            # Grab 3' match from last oligo's info\n            current_index, matchlen = zipped[last_index][1]\n            # Get new oligo sequence, make double-stranded for concatenation\n            next_oligo = dna_list[current_index].to_ds()\n            # Reverse complement for concatenation\n            next_oligo = next_oligo.reverse_complement()\n            # Don't reverse complement the next one\n            flip = False\n        else:\n            # Grab 5' match from last oligo's info\n            current_index, matchlen = zipped[last_index][0]\n            # Get new oligo sequence, make double-stranded for concatenation\n            next_oligo = dna_list[current_index].to_ds()\n            # Reverse complement the next one\n            flip = True\n        # Trim overlap from new sequence\n        next_oligo = next_oligo[(matchlen - 1):]\n        # Concatenate and update last oligo's information\n        assembly += next_oligo\n        last_index = current_index\n    if reference:\n        if assembly == reference or assembly == reference.reverse_complement():\n            return assembly\n        else:\n            raise AssemblyError('Assembly did not match reference')\n    else:\n        return assembly"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbinds a sequence to a sequence that uniquely matches the reverse - complement of the associated 5 or 3 region of one sequence in a list of query sequences.", "response": "def bind_unique(reference, query_list, min_overlap=12, right=True):\n    '''(5' or 3' region on reference sequence that uniquely matches the reverse\n    complement of the associated (5' or 3') region of one sequence in a list of\n    query sequences.\n\n    :param reference: Reference sequence.\n    :type reference: coral.DNA\n    :param query_list: List of query sequences.\n    :type query_list: coral.DNA list\n    :param min_overlap: Minimum overlap for a match (in bp).\n    :type min_overlap: int\n    :param right: Check right side of sequence (3'). False results in 5' check.\n    :type right: bool\n    :returns: Tuple of the indices of any matches and the size of the match in\n              bp.\n    :rtype: tuple of ints\n    :raises: AssemblyError if more than one match is found.\n\n    '''\n    size = min_overlap\n    found = []\n    # Reverse complementing here provides massive speedup?\n    rev_query = [seq.reverse_complement() for seq in query_list]\n    while not found and not size > len(reference):\n        for i, seq in enumerate(rev_query):\n            if right:\n                # FIXME: these getitems are the slowest part of assembly\n                # Easiest speedup?\n                if reference.endswith(seq[:size]):\n                    found.append(i)\n            else:\n                if reference.startswith(seq[-size:]):\n                    found.append(i)\n        size += 1\n    if len(found) > 1:\n        raise AssemblyError('Ambiguous oligo binding')\n    if not found:\n        return None\n    else:\n        return found[0], size"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nonmatches(self):\n        '''Report mismatches, indels, and coverage.'''\n        # For every result, keep a dictionary of mismatches, insertions, and\n        # deletions\n        report = []\n        for result in self.aligned_results:\n            report.append(self._analyze_single(self.aligned_reference, result))\n\n        return report", "response": "Report mismatches indels deletions and coverage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a summary plot of the alignment and highlight nonmatches.", "response": "def plot(self):\n        '''Make a summary plot of the alignment and highlight nonmatches.'''\n        import matplotlib.pyplot as plt\n        import matplotlib.patches as patches\n\n        # Constants to use throughout drawing\n        n = len(self.results)\n        nbases = len(self.aligned_reference)\n        barheight = 0.4\n\n        # Vary height of figure based on number of results\n        figheight = 3 + 3 * (n - 1)\n        fig = plt.figure(figsize=(9, figheight))\n        ax1 = fig.add_subplot(111)\n\n        # Plot bars to represent coverage area\n        # Reference sequence\n        ax1.add_patch(patches.Rectangle((0, 0), nbases, barheight,\n                                        facecolor='black'))\n        # Results\n        for i, report in enumerate(self.nonmatches()):\n            j = i + 1\n            start, stop = report['coverage']\n            patch = patches.Rectangle((start, j), stop - start, barheight,\n                                      facecolor='darkgray')\n            ax1.add_patch(patch)\n\n            # Draw a vertical line for each type of result\n            plt.vlines(report['mismatches'], j, j + barheight,\n                       colors='b')\n            plt.vlines(report['insertions'], j, j + barheight,\n                       colors='r')\n\n            # Terminal trailing deletions shouldn't be added\n            deletions = []\n            crange = range(*report['coverage'])\n            deletions = [idx for idx in report['deletions'] if idx in crange]\n            plt.vlines(deletions, j, j + barheight,\n                       colors='g')\n\n        ax1.set_xlim((0, nbases))\n        ax1.set_ylim((-0.3, n + 1))\n        ax1.set_yticks([i + barheight / 2 for i in range(n + 1)])\n        ax1.set_yticklabels(['Reference'] + self.names)\n\n        # Add legend\n        mismatch_patch = patches.Patch(color='blue', label='Mismatch')\n        insertion_patch = patches.Patch(color='red', label='Insertion')\n        deletion_patch = patches.Patch(color='green', label='Deletion')\n        plt.legend(handles=[mismatch_patch, insertion_patch, deletion_patch],\n                   loc=1, ncol=3, mode='expand', borderaxespad=0.)\n\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreport mistmatches and indels for a single aligned reference and result.", "response": "def _analyze_single(self, reference, result):\n        '''Report mistmatches and indels for a single (aligned) reference and\n        result.'''\n        # TODO: Recalculate coverage based on reference (e.g. sequencing result\n        # longer than template\n        reference_str = str(reference)\n        result_str = str(result)\n        report = {'mismatches': [], 'insertions': [], 'deletions': []}\n        for i, (ref, res) in enumerate(zip(reference_str, result_str)):\n            if ref != res:\n                # It's a mismatch or indel\n                if ref == '-':\n                    report['insertions'].append(i)\n                if res == '-':\n                    report['deletions'].append(i)\n                else:\n                    report['mismatches'].append(i)\n\n        start = len(result_str) - len(result_str.lstrip('-'))\n        stop = len(result_str) - len(result_str.rstrip('-'))\n        report['coverage'] = [start, stop]\n\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving terminal Ns from sequencing results.", "response": "def _remove_n(self):\n        '''Remove terminal Ns from sequencing results.'''\n        for i, result in enumerate(self.results):\n            largest = max(str(result).split('N'), key=len)\n            start = result.locate(largest)[0][0]\n            stop = start + len(largest)\n            if start != stop:\n                self.results[i] = self.results[i][start:stop]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef random_dna(n):\n    '''Generate a random DNA sequence.\n\n    :param n: Output sequence length.\n    :type n: int\n    :returns: Random DNA sequence of length n.\n    :rtype: coral.DNA\n\n    '''\n    return coral.DNA(''.join([random.choice('ATGC') for i in range(n)]))", "response": "Generate a random DNA sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate randomized codons given a peptide sequence.", "response": "def random_codons(peptide, frequency_cutoff=0.0, weighted=False, table=None):\n    '''Generate randomized codons given a peptide sequence.\n\n    :param peptide: Peptide sequence for which to generate randomized\n                    codons.\n    :type peptide: coral.Peptide\n    :param frequency_cutoff: Relative codon usage cutoff - codons that\n                             are rarer will not be used. Frequency is\n                             relative to average over all codons for a\n                             given amino acid.\n    :param frequency_cutoff: Codon frequency table to use.\n    :param weighted: Use codon table\n    :type weighted: bool\n    :param table: Codon frequency table to use. Table should be organized\n                  by amino acid, then be a dict of codon: frequency.\n                  Only relevant if weighted=True or frequency_cutoff > 0.\n                  Tables available:\n\n                  constants.molecular_bio.CODON_FREQ_BY_AA['sc'] (default)\n    :type table: dict\n    :returns: Randomized sequence of codons (DNA) that code for the input\n              peptide.\n    :rtype: coral.DNA\n    :raises: ValueError if frequency_cutoff is set so high that there are no\n             codons available for an amino acid in the input peptide.\n\n    '''\n    if table is None:\n        table = CODON_FREQ_BY_AA['sc']\n    # Process codon table using frequency_cutoff\n    new_table = _cutoff(table, frequency_cutoff)\n    # Select codons randomly or using weighted distribution\n    rna = ''\n    for amino_acid in str(peptide):\n        codons = new_table[amino_acid.upper()]\n        if not codons:\n            raise ValueError('No {} codons at freq cutoff'.format(amino_acid))\n        if weighted:\n            cumsum = []\n            running_sum = 0\n            for codon, frequency in codons.iteritems():\n                running_sum += frequency\n                cumsum.append(running_sum)\n            random_num = random.uniform(0, max(cumsum))\n            for codon, value in zip(codons, cumsum):\n                if value > random_num:\n                    selection = codon\n                    break\n        else:\n            selection = random.choice(codons.keys())\n        rna += selection\n    return coral.RNA(rna)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a new codon frequency table given a mean cutoff.", "response": "def _cutoff(table, frequency_cutoff):\n    '''Generate new codon frequency table given a mean cutoff.\n\n    :param table: codon frequency table of form {amino acid: codon: frequency}\n    :type table: dict\n    :param frequency_cutoff: value between 0 and 1.0 for mean frequency cutoff\n    :type frequency_cutoff: float\n    :returns: A codon frequency table with some codons removed.\n    :rtype: dict\n\n    '''\n    new_table = {}\n    # IDEA: cutoff should be relative to most-frequent codon, not average?\n    for amino_acid, codons in table.iteritems():\n        average_cutoff = frequency_cutoff * sum(codons.values()) / len(codons)\n        new_table[amino_acid] = {}\n        for codon, frequency in codons.iteritems():\n            if frequency > average_cutoff:\n                new_table[amino_acid][codon] = frequency\n    return new_table"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nacquires a genome from Entrez and return it as a sequence.", "response": "def fetch_genome(genome_id):\n    '''Acquire a genome from Entrez\n\n    '''\n    # TODO: Can strandedness by found in fetched genome attributes?\n    # TODO: skip read/write step?\n    # Using a dummy email for now - does this violate NCBI guidelines?\n    email = 'loremipsum@gmail.com'\n    Entrez.email = email\n\n    print 'Downloading Genome...'\n    handle = Entrez.efetch(db='nucleotide', id=str(genome_id), rettype='gb',\n                           retmode='text')\n    print 'Genome Downloaded...'\n    tmpfile = os.path.join(mkdtemp(), 'tmp.gb')\n    with open(tmpfile, 'w') as f:\n        f.write(handle.read())\n    genome = coral.seqio.read_dna(tmpfile)\n\n    return genome"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cofold(self, strand1, strand2, temp=37.0, dangles=2, nolp=False,\n               nogu=False, noclosinggu=False, constraints=None,\n               canonicalbponly=False, partition=-1, pfscale=None, gquad=False):\n        '''Run the RNAcofold command and retrieve the result in a dictionary.\n\n        :param strand1: Strand 1 for running RNAcofold.\n        :type strand1: coral.DNA or coral.RNA\n        :param strand1: Strand 2 for running RNAcofold.\n        :type strand2: coral.DNA or coral.RNA\n        :param temp: Temperature at which to run the calculations.\n        :type temp: float\n        :param dangles: How to treat dangling end energies. Set to 0 to ignore\n                        dangling ends. Set to 1 to limit unpaired bases to\n                        at most one dangling end (default for MFE calc). Set to\n                        2 (the default) to remove the limit in 1. Set to 3 to\n                        allow coaxial stacking of adjacent helices in\n                        .multi-loops\n        :type dangles: int\n        :param nolp: Produce structures without lonely pairs (isolated single\n                     base pairs).\n        :type nolp: bool\n        :param nogu: Do not allow GU pairs.\n        :type nogu: bool\n        :param noclosinggu: Do not allow GU pairs at the end of helices.\n        :type noclosinggu: bool\n        :param constraints: Any structural constraints to use. Format is\n                            defined at\n                            http://www.tbi.univie.ac.at/RNA/RNAfold.1.html\n        :type constraints: str\n        :param canonicalbponly: Remove non-canonical base pairs from the\n                                structure constraint (if applicable).\n        :type canonicalbponly: bool\n        :param partition: Calculates the partition function for the sequence.\n        :type partition: int\n        :param pfscale: Scaling factor for the partition function.\n        :type pfScale: float\n        :param gquad: Incorporate G-Quadruplex formation into the structure\n                      prediction.\n        :type gquad: bool\n\n        :returns: Dictionary of calculated values, defaulting to values of MFE\n                  ('mfe': float) and dotbracket structure ('dotbracket': str).\n                  More keys are added depending on keyword arguments.\n        :rtype: dict\n\n        '''\n        cmd_args = []\n        cmd_kwargs = {'--temp=': str(temp)}\n        cmd_kwargs['--dangles='] = dangles\n        if nolp:\n            cmd_args.append('--noLP')\n        if nogu:\n            cmd_args.append('--noGU')\n        if noclosinggu:\n            cmd_args.append('--noClosingGU')\n        if constraints is not None:\n            cmd_args.append('--constraint')\n            if canonicalbponly:\n                cmd_args.append('--canonicalBPonly')\n        if partition:\n            cmd_args.append('--partfunc')\n        if pfscale is not None:\n            cmd_kwargs['pfScale'] = float(pfscale)\n        if gquad:\n            cmd_args.append('--gquad')\n\n        inputs = ['>strands\\n{}&{}'.format(str(strand1), str(strand2))]\n        if constraints is not None:\n            inputs.append(constraints)\n\n        rnafold_output = self._run('RNAcofold', inputs, cmd_args, cmd_kwargs)\n\n        # Process the output\n        output = {}\n        lines = rnafold_output.splitlines()\n        # Line 1 is the name of the sequence input, line 2 is the sequence\n        lines.pop(0)\n        lines.pop(0)\n        # Line 3 is the dotbracket + mfe for strand1\n        line3 = lines.pop(0)\n        output['dotbracket'] = self._lparse(line3, '^(.*) \\(')\n        output['mfe'] = float(self._lparse(line3, ' \\((.*)\\)$'))\n        # Optional outputs\n        if partition:\n            # Line 4 is 'a coarse representation of the pair probabilities' and\n            # the ensemble free energy\n            line4 = lines.pop(0)\n            output['coarse'] = self._lparse(line4, '^(.*) \\[')\n            output['ensemble'] = float(self._lparse(line4, ' \\[(.*)\\]$'))\n            # Line 5 is the centroid structure, its free energy, and distance\n            # to the ensemble\n            line5 = lines.pop(0)\n            'ensemble (.*),'\n            output['frequency'] = float(self._lparse(line5, 'ensemble (.*),'))\n            output['deltaG'] = float(self._lparse(line5, 'binding=(.*)$'))\n            # Parse the postscript file (the only place the probability matrix\n            # is)\n            with open(os.path.join(self._tempdir, 'strands_dp.ps')) as f:\n                pattern = 'start of base pair probability data\\n(.*)\\nshowpage'\n                dotplot_file = f.read()\n                dotplot_data = re.search(pattern, dotplot_file,\n                                         flags=re.DOTALL).group(1).split('\\n')\n                # Dimension of the dotplot - compares seq1, seq2 to self and\n                # to each other (concatenation of seq1 and seq2 = axis)\n                dim = len(strand1) + len(strand2)\n                ensemble_probs = np.zeros((dim, dim))\n                optimal_probs = np.zeros((dim, dim))\n\n                for point in dotplot_data:\n                    point_split = point.split(' ')\n                    # Use zero indexing\n                    i = int(point_split[0]) - 1\n                    j = int(point_split[1]) - 1\n                    sqprob = float(point_split[2])\n                    probtype = point_split[3]\n                    if probtype == 'ubox':\n                        ensemble_probs[i][j] = sqprob**2\n                    else:\n                        optimal_probs[i][j] = sqprob**2\n                output['ensemble_matrix'] = ensemble_probs\n                output['optimal_matrix'] = optimal_probs\n\n        return output", "response": "Run the RNAcofold command and retrieve the result in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the RNAfold command and retrieve the result in a dictionary.", "response": "def fold(self, strand, temp=37.0, dangles=2, nolp=False, nogu=False,\n             noclosinggu=False, constraints=None, canonicalbponly=False,\n             partition=False, pfscale=None, imfeelinglucky=False, gquad=False):\n        '''Run the RNAfold command and retrieve the result in a dictionary.\n\n        :param strand: The DNA or RNA sequence on which to run RNAfold.\n        :type strand: coral.DNA or coral.RNA\n        :param temp: Temperature at which to run the calculations.\n        :type temp: float\n        :param dangles: How to treat dangling end energies. Set to 0 to ignore\n                        dangling ends. Set to 1 to limit unpaired bases to\n                        at most one dangling end (default for MFE calc). Set to\n                        2 (the default) to remove the limit in 1. Set to 3 to\n                        allow coaxial stacking of adjacent helices in\n                        .multi-loops\n        :type dangles: int\n        :param nolp: Produce structures without lonely pairs (isolated single\n                     base pairs).\n        :type nolp: bool\n        :param nogu: Do not allow GU pairs.\n        :type nogu: bool\n        :param noclosinggu: Do not allow GU pairs at the end of helices.\n        :type noclosinggu: bool\n        :param constraints: Any structural constraints to use. Format is\n                            defined at\n                            http://www.tbi.univie.ac.at/RNA/RNAfold.1.html\n        :type constraints: str\n        :param canonicalbponly: Remove non-canonical base pairs from the\n                                structure constraint (if applicable).\n        :type canonicalbponly: bool\n        :param partition: Generates the partition function, generating a coarse\n                          grain structure ('coarse') in the format described at\n                          http://www.itc.univie.ac.at/~ivo/RNA/RNAlib/PF-Fold.h\n                          tml, the ensemble free energy ('ensemble'), the\n                          centroid structure ('centroid'), the free energy of\n                          the centroid structure ('centroid_fe'), and its\n                          distance from the ensemble ('centroid_d').\n        :type partition: int\n        :param pfscale: Scaling factor for the partition function.\n        :type pfScale: float\n        :param imfeelinglucky: Returns the one secondary structure from the\n                               Boltzmann equilibrium according to its\n                               probability in the ensemble.\n        :type imfeelinglucky: bool\n        :param gquad: Incorporate G-Quadruplex formation into the structure\n                      prediction.\n        :type gquad: bool\n\n        :returns: Dictionary of calculated values, defaulting to values of MFE\n                  ('mfe': float) and dotbracket structure ('dotbracket': str).\n                  More keys are added depending on keyword arguments.\n        :rtype: dict\n\n        '''\n        cmd_args = []\n        cmd_kwargs = {'--temp=': str(temp)}\n        cmd_kwargs['--dangles='] = dangles\n        if nolp:\n            cmd_args.append('--noLP')\n        if nogu:\n            cmd_args.append('--noGU')\n        if noclosinggu:\n            cmd_args.append('--noClosingGU')\n        if constraints is not None:\n            cmd_args.append('--constraint')\n            if canonicalbponly:\n                cmd_args.append('--canonicalBPonly')\n        if partition:\n            cmd_args.append('--partfunc')\n        if pfscale is not None:\n            cmd_kwargs['pfScale'] = float(pfscale)\n        if gquad:\n            cmd_args.append('--gquad')\n\n        inputs = [str(strand)]\n        if constraints is not None:\n            inputs.append(constraints)\n\n        if strand.circular:\n            cmd_args.append('--circ')\n        rnafold_output = self._run('RNAfold', inputs, cmd_args, cmd_kwargs)\n\n        # Process the output\n        output = {}\n        lines = rnafold_output.splitlines()\n        # Line 1 is the sequence as RNA\n        lines.pop(0)\n        # Line 2 is the dotbracket + mfe\n        line2 = lines.pop(0)\n        output['dotbracket'] = self._lparse(line2, '^(.*) \\(')\n        output['mfe'] = float(self._lparse(line2, ' \\((.*)\\)$'))\n        # Optional outputs\n        if partition:\n            # Line 3 is 'a coarse representation of the pair probabilities' and\n            # the ensemble free energy\n            line3 = lines.pop(0)\n            output['coarse'] = self._lparse(line3, '^(.*) \\[')\n            output['ensemble'] = float(self._lparse(line3, ' \\[(.*)\\]$'))\n            # Line 4 is the centroid structure, its free energy, and distance\n            # to the ensemble\n            line4 = lines.pop(0)\n            output['centroid'] = self._lparse(line4, '^(.*) \\{')\n            output['centroid_fe'] = float(self._lparse(line4, '^.*{(.*) d'))\n            output['centroid_d'] = float(self._lparse(line4, 'd=(.*)}$'))\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates expected fraction of primer dimers.", "response": "def dimers(primer1, primer2, concentrations=[5e-7, 3e-11]):\n    '''Calculate expected fraction of primer dimers.\n\n    :param primer1: Forward primer.\n    :type primer1: coral.DNA\n    :param primer2: Reverse primer.\n    :type primer2: coral.DNA\n    :param template: DNA template.\n    :type template: coral.DNA\n    :param concentrations: list of concentrations for primers and the\n                           template. Defaults are those for PCR with 1kb\n                           template.\n    :type concentrations: list\n    :returns: Fraction of dimers versus the total amount of primer added.\n    :rtype: float\n\n    '''\n    # It is not reasonable (yet) to use a long template for doing these\n    # computations directly, as NUPACK does an exhaustive calculation and\n    # would take too long without a cluster.\n    # Instead, this function compares primer-primer binding to\n    # primer-complement binding\n\n    # Simulate binding of template vs. primers\n    nupack = coral.analysis.NUPACK([primer1.primer(), primer2.primer(),\n                                    primer1.primer().reverse_complement(),\n                                    primer2.primer().reverse_complement()])\n    # Include reverse complement concentration\n    primer_concs = [concentrations[0]] * 2\n    template_concs = [concentrations[1]] * 2\n    concs = primer_concs + template_concs\n    nupack_concs = nupack.concentrations(2, conc=concs)\n    dimer_conc = nupack_concs['concentrations'][5]\n    #primer1_template = nupack_concs['concentrations'][6]\n    #primer2_template = nupack_concs['concentrations'][10]\n    return dimer_conc / concs[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_dna(path):\n    '''Read DNA from file. Uses BioPython and coerces to coral format.\n\n    :param path: Full path to input file.\n    :type path: str\n    :returns: DNA sequence.\n    :rtype: coral.DNA\n\n    '''\n    filename, ext = os.path.splitext(os.path.split(path)[-1])\n\n    genbank_exts = ['.gb', '.ape']\n    fasta_exts = ['.fasta', '.fa', '.fsa', '.seq']\n    abi_exts = ['.abi', '.ab1']\n\n    if any([ext == extension for extension in genbank_exts]):\n        file_format = 'genbank'\n    elif any([ext == extension for extension in fasta_exts]):\n        file_format = 'fasta'\n    elif any([ext == extension for extension in abi_exts]):\n        file_format = 'abi'\n    else:\n        raise ValueError('File format not recognized.')\n\n    seq = SeqIO.read(path, file_format)\n    dna = coral.DNA(str(seq.seq))\n    if seq.name == '.':\n        dna.name = filename\n    else:\n        dna.name = seq.name\n\n    # Features\n    for feature in seq.features:\n        try:\n            dna.features.append(_seqfeature_to_coral(feature))\n        except FeatureNameError:\n            pass\n    dna.features = sorted(dna.features, key=lambda feature: feature.start)\n    # Used to use data_file_division, but it's inconsistent (not always the\n    # molecule type)\n    dna.circular = False\n    with open(path) as f:\n        first_line = f.read().split()\n        for word in first_line:\n            if word == 'circular':\n                dna.circular = True\n\n    return dna", "response": "Reads a DNA file and returns it as a sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_sequencing(directory):\n    '''Read .seq and .abi/.ab1 results files from a dir.\n\n    :param directory: Path to directory containing sequencing files.\n    :type directory: str\n    :returns: A list of DNA sequences.\n    :rtype: coral.DNA list\n\n    '''\n    dirfiles = os.listdir(directory)\n    seq_exts = ['.seq', '.abi', '.ab1']\n    # Exclude files that aren't sequencing results\n    seq_paths = [x for x in dirfiles if os.path.splitext(x)[1] in seq_exts]\n    paths = [os.path.join(directory, x) for x in seq_paths]\n    sequences = [read_dna(x) for x in paths]\n\n    return sequences", "response": "Reads. seq and. ab1 results files from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a DNA sequence to a file.", "response": "def write_dna(dna, path):\n    '''Write DNA to a file (genbank or fasta).\n\n    :param dna: DNA sequence to write to file\n    :type dna: coral.DNA\n    :param path: file path to write. Has to be genbank or fasta file.\n    :type path: str\n\n    '''\n    # Check if path filetype is valid, remember for later\n    ext = os.path.splitext(path)[1]\n    if ext == '.gb' or ext == '.ape':\n        filetype = 'genbank'\n    elif ext == '.fa' or ext == '.fasta':\n        filetype = 'fasta'\n    else:\n        raise ValueError('Only genbank or fasta files are supported.')\n\n    # Convert features to Biopython form\n    # Information lost on conversion:\n    #     specificity of feature type\n    #     strandedness\n    #     topology\n    features = []\n    for feature in dna.features:\n        features.append(_coral_to_seqfeature(feature))\n    # Biopython doesn't like 'None' here\n    # FIXME: this is a legacy feature - remove?\n    bio_id = dna.id if hasattr(dna, 'id') else ''\n    # Maximum length of name is 16\n    seq = SeqRecord(Seq(str(dna), alphabet=ambiguous_dna), id=bio_id,\n                    name=dna.name[0:16].replace(' ', '_'), features=features,\n                    description=dna.name)\n    if dna.circular:\n        seq.annotations['data_file_division'] = 'circular'\n    else:\n        seq.annotations['data_file_division'] = 'linear'\n\n    if filetype == 'genbank':\n        SeqIO.write(seq, path, 'genbank')\n    elif filetype == 'fasta':\n        SeqIO.write(seq, path, 'fasta')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a list of primers out to a csv file.", "response": "def write_primers(primer_list, path, names=None, notes=None):\n    '''Write a list of primers out to a csv file. The first three columns are\n    compatible with the current IDT order form (name, sequence, notes). By\n    default there are no notes, which is an optional parameter.\n\n    :param primer_list: A list of primers.\n    :type primer_list: coral.Primer list\n    :param path: A path to the csv you want to write.\n    :type path: str\n    :param names: A list of strings to name each oligo. Must be the same length\n                  as the primer_list.\n    :type names: str list\n    :param notes: A list of strings to provide a note for each oligo. Must be\n                  the same length as the primer_list.\n    :type notes: str list\n\n    '''\n    # Check for notes and names having the right length, apply them to primers\n    if names is not None:\n        if len(names) != len(primer_list):\n            names_msg = 'Mismatch in number of notes and primers.'\n            raise PrimerAnnotationError(names_msg)\n        for i, name in enumerate(names):\n            primer_list[i].name = name\n    if notes is not None:\n        if len(notes) != len(primer_list):\n            notes_msg = 'Mismatch in number of notes and primers.'\n            raise PrimerAnnotationError(notes_msg)\n        for i, note in enumerate(notes):\n            primer_list[i].note = note\n\n    # Write to csv\n    with open(path, 'w') as csv_file:\n        writer = csv.writer(csv_file)\n        writer.writerow(['name', 'sequence', 'notes'])\n        for primer in primer_list:\n            string_rep = str(primer.overhang).lower() + str(primer.anneal)\n            writer.writerow([primer.name, string_rep, primer.note])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntranslate genbank feature types into usable ones.", "response": "def _process_feature_type(feature_type, bio_to_coral=True):\n    '''Translate genbank feature types into usable ones (currently identical).\n    The feature table is derived from the official genbank spec (gbrel.txt)\n    available at http://www.insdc.org/documents/feature-table\n\n    :param feature_type: feature to convert\n    :type feature_type: str\n    :param bio_to_coral: from coral to Biopython (True) or the other direction\n                   (False)\n    :param bio_to_coral: bool\n    :returns: coral version of genbank feature_type, or vice-versa.\n    :rtype: str\n\n    '''\n\n    err_msg = 'Unrecognized feature type: {}'.format(feature_type)\n    if bio_to_coral:\n        try:\n            name = coral.constants.genbank.TO_CORAL[feature_type]\n        except KeyError:\n            raise ValueError(err_msg)\n    else:\n        try:\n            name = coral.constants.genbank.TO_BIO[feature_type]\n        except KeyError:\n            raise ValueError(err_msg)\n    return name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a Biopython SeqFeature to a coral. Feature.", "response": "def _seqfeature_to_coral(feature):\n    '''Convert a Biopython SeqFeature to a coral.Feature.\n\n    :param feature: Biopython SeqFeature\n    :type feature: Bio.SeqFeature\n\n    '''\n    # Some genomic sequences don't have a label attribute\n    # TODO: handle genomic cases differently than others. Some features lack\n    # a label but should still be incorporated somehow.\n    qualifiers = feature.qualifiers\n    if 'label' in qualifiers:\n        feature_name = qualifiers['label'][0]\n    elif 'locus_tag' in qualifiers:\n        feature_name = qualifiers['locus_tag'][0]\n    else:\n        raise FeatureNameError('Unrecognized feature name')\n    # Features with gaps are special, require looking at subfeatures\n    # Assumption: subfeatures are never more than one level deep\n    if feature.location_operator == 'join':\n        # Feature has gaps. Have to figure out start/stop from subfeatures,\n        # calculate gap indices. A nested feature model may be required\n        # eventually.\n        # Reorder the sub_feature list by start location\n        # Assumption: none of the subfeatures overlap so the last entry in\n        # the reordered list also has the final stop point of the feature.\n        # FIXME: Getting a deprecation warning about using sub_features\n        # instead of feature.location being a CompoundFeatureLocation\n        reordered = sorted(feature.location.parts,\n                           key=lambda location: location.start)\n        starts = [int(location.start) for location in reordered]\n        stops = [int(location.end) for location in reordered]\n        feature_start = starts.pop(0)\n        feature_stop = stops.pop(-1)\n        starts = [start - feature_start for start in starts]\n        stops = [stop - feature_start for stop in stops]\n        feature_gaps = list(zip(stops, starts))\n    else:\n        # Feature doesn't have gaps. Ignore subfeatures.\n        feature_start = int(feature.location.start)\n        feature_stop = int(feature.location.end)\n        feature_gaps = []\n    feature_type = _process_feature_type(feature.type)\n    if feature.location.strand == -1:\n        feature_strand = 1\n    else:\n        feature_strand = 0\n    if 'gene' in qualifiers:\n        gene = qualifiers['gene']\n    else:\n        gene = []\n    if 'locus_tag' in qualifiers:\n        locus_tag = qualifiers['locus_tag']\n    else:\n        locus_tag = []\n    coral_feature = coral.Feature(feature_name, feature_start,\n                                  feature_stop, feature_type,\n                                  gene=gene, locus_tag=locus_tag,\n                                  qualifiers=qualifiers,\n                                  strand=feature_strand,\n                                  gaps=feature_gaps)\n    return coral_feature"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _coral_to_seqfeature(feature):\n    '''Convert a coral.Feature to a Biopython SeqFeature.\n\n    :param feature: coral Feature.\n    :type feature: coral.Feature\n\n    '''\n    bio_strand = 1 if feature.strand == 1 else -1\n    ftype = _process_feature_type(feature.feature_type, bio_to_coral=False)\n    sublocations = []\n    if feature.gaps:\n        # There are gaps. Have to define location_operator and  add subfeatures\n        location_operator = 'join'\n        # Feature location means nothing for 'join' sequences?\n        # TODO: verify\n        location = FeatureLocation(ExactPosition(0), ExactPosition(1),\n                                   strand=bio_strand)\n        # Reconstruct start/stop indices for each subfeature\n        stops, starts = zip(*feature.gaps)\n        starts = [feature.start] + [start + feature.start for start in starts]\n        stops = [stop + feature.start for stop in stops] + [feature.stop]\n        # Build subfeatures\n        for start, stop in zip(starts, stops):\n            sublocation = FeatureLocation(ExactPosition(start),\n                                          ExactPosition(stop),\n                                          strand=bio_strand)\n            sublocations.append(sublocation)\n        location = CompoundLocation(sublocations, operator='join')\n    else:\n        # No gaps, feature is simple\n        location_operator = ''\n        location = FeatureLocation(ExactPosition(feature.start),\n                                   ExactPosition(feature.stop),\n                                   strand=bio_strand)\n    qualifiers = feature.qualifiers\n    qualifiers['label'] = [feature.name]\n    seqfeature = SeqFeature(location, type=ftype,\n                            qualifiers=qualifiers,\n                            location_operator=location_operator)\n    return seqfeature", "response": "Convert a coral. Feature to a Biopython SeqFeature."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_ord_matrix(matrix, alphabet):\n    '''Given the SubstitutionMatrix input, generate an equivalent matrix that\n    is indexed by the ASCII number of each residue (e.g. A -> 65).'''\n    ords = [ord(c) for c in alphabet]\n    ord_matrix = np.zeros((max(ords) + 1, max(ords) + 1), dtype=np.integer)\n    for i, row_ord in enumerate(ords):\n        for j, col_ord in enumerate(ords):\n            ord_matrix[row_ord, col_ord] = matrix[i, j]\n\n    return ord_matrix", "response": "Given the SubstitutionMatrix input generate an equivalent matrix that contains the ASCII number of each residue."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the alignment of two sequences.", "response": "def aligner(seqj, seqi, method='global', gap_open=-7, gap_extend=-7,\n            gap_double=-7, matrix=submat.DNA_SIMPLE.matrix,\n            alphabet=submat.DNA_SIMPLE.alphabet):\n    '''Calculates the alignment of two sequences. The global method uses\n    a global Needleman-Wunsh algorithm, local does a a local\n    Smith-Waterman alignment, global_cfe does a global alignment with\n    cost-free ends and glocal does an alignment which is global only with\n    respect to the shorter sequence, also known as a semi-global\n    alignment. Returns the aligned (sub)sequences as character arrays.\n\n    Gotoh, O. (1982). J. Mol. Biol. 162, 705-708.\n    Needleman, S. & Wunsch, C. (1970). J. Mol. Biol. 48(3), 443-53.\n    Smith, T.F. & Waterman M.S. (1981). J. Mol. Biol. 147, 195-197.\n\n    :param seqj: First sequence.\n    :type seqj: str\n    :param seqi: Second sequence.\n    :type seqi: str\n    :param method: Type of alignment: 'global', 'global_cfe', 'local', or\n                   'glocal'.\n    :type method: str\n    :param gap_open: The cost of opening a gap (negative number).\n    :type gap_open: float\n    :param gap_extend: The cost of extending an open gap (negative number).\n    :type gap_extend: float\n    :param gap_double: The gap-opening cost if a gap is already open in the\n                       other sequence (negative number).\n    :type gap_double: float\n    :param matrix: A score matrix dictionary name. Examples can be found in\n                   the substitution_matrices module.\n    :type matrix: str\n    :param alphabet: The characters corresponding to matrix rows/columns.\n    :type alphabet: str\n\n    '''\n    amatrix = as_ord_matrix(matrix, alphabet)\n    NONE, LEFT, UP, DIAG = range(4)  # NONE is 0\n    max_j = len(seqj)\n    max_i = len(seqi)\n\n    if max_j > max_i:\n        flip = 1\n        seqi, seqj = seqj, seqi\n        max_i, max_j = max_j, max_i\n    else:\n        flip = 0\n\n    F = np.zeros((max_i + 1, max_j + 1), dtype=np.float32)\n    I = np.ndarray((max_i + 1, max_j + 1), dtype=np.float32)\n    I.fill(-np.inf)\n    J = np.ndarray((max_i + 1, max_j + 1), dtype=np.float32)\n    J.fill(-np.inf)\n    pointer = np.zeros((max_i + 1, max_j + 1), dtype=np.uint)  # NONE\n\n    if method == 'global':\n        pointer[0, 1:] = LEFT\n        pointer[1:, 0] = UP\n        F[0, 1:] = gap_open + gap_extend * np.arange(0, max_j,\n                                                     dtype=np.float32)\n        F[1:, 0] = gap_open + gap_extend * np.arange(0, max_i,\n                                                     dtype=np.float32)\n    elif method == 'global_cfe':\n        pointer[0, 1:] = LEFT\n        pointer[1:, 0] = UP\n    elif method == 'glocal':\n        pointer[0, 1:] = LEFT\n        F[0, 1:] = gap_open + gap_extend * np.arange(0, max_j,\n                                                     dtype=np.float32)\n\n    seqi_ord = [ord(base) for base in seqi]\n    seqj_ord = [ord(base) for base in seqj]\n    for i in range(1, max_i + 1):\n        ci = seqi_ord[i - 1]\n        for j in range(1, max_j + 1):\n            cj = seqj_ord[j - 1]\n            # I\n            I[i, j] = max(F[i, j - 1] + gap_open,\n                          I[i, j - 1] + gap_extend,\n                          J[i, j - 1] + gap_double)\n            # J\n            J[i, j] = max(F[i - 1, j] + gap_open,\n                          J[i - 1, j] + gap_extend,\n                          I[i - 1, j] + gap_double)\n            # F\n            diag_score = F[i - 1, j - 1] + amatrix[ci, cj]\n            left_score = I[i, j]\n            up_score = J[i, j]\n            max_score = max(diag_score, up_score, left_score)\n\n            F[i, j] = max(0, max_score) if method == 'local' else max_score\n\n            if method == 'local':\n                if F[i, j] == 0:\n                    pass  # point[i,j] = NONE\n                elif max_score == diag_score:\n                    pointer[i, j] = DIAG\n                elif max_score == up_score:\n                    pointer[i, j] = UP\n                elif max_score == left_score:\n                    pointer[i, j] = LEFT\n            elif method == 'glocal':\n                # In a semi-global alignment we want to consume as much as\n                # possible of the longer sequence.\n                if max_score == up_score:\n                    pointer[i, j] = UP\n                elif max_score == diag_score:\n                    pointer[i, j] = DIAG\n                elif max_score == left_score:\n                    pointer[i, j] = LEFT\n            else:\n                # global\n                if max_score == up_score:\n                    pointer[i, j] = UP\n                elif max_score == left_score:\n                    pointer[i, j] = LEFT\n                else:\n                    pointer[i, j] = DIAG\n\n    align_j = []\n    align_i = []\n    if method == 'local':\n        # max anywhere\n        i, j = max_index(F)\n    elif method == 'glocal':\n        # max in last col\n        i, j = (F[:, -1].argmax(), max_j)\n    elif method == 'global_cfe':\n        # from i,j to max(max(last row), max(last col)) for free\n        row_max, col_idx = F[-1].max(), F[-1].argmax()\n        col_max, row_idx = F[:, -1].max(), F[:, -1].argmax()\n        if row_max > col_max:\n            pointer[-1, col_idx + 1:] = LEFT\n        else:\n            pointer[row_idx + 1:, -1] = UP\n\n    p = pointer[i, j]\n    while p != NONE:\n        if p == DIAG:\n            i -= 1\n            j -= 1\n            align_j.append(seqj[j])\n            align_i.append(seqi[i])\n        elif p == LEFT:\n            j -= 1\n            align_j.append(seqj[j])\n            align_i.append('-')\n        elif p == UP:\n            i -= 1\n            align_j.append('-')\n            align_i.append(seqi[i])\n        else:\n            raise Exception('wtf!')\n        p = pointer[i, j]\n    align_i = ''.join(align_i[::-1])\n    align_j = ''.join(align_j[::-1])\n    # np.array(align_i.reverse())\n    return ((align_i, align_j) if flip else (align_j, align_i))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef score_alignment(a, b, gap_open, gap_extend, matrix):\n    '''Calculate the alignment score from two aligned sequences.\n\n    :param a: The first aligned sequence.\n    :type a: str\n    :param b: The second aligned sequence.\n    :type b: str\n    :param gap_open: The cost of opening a gap (negative number).\n    :type gap_open: int\n    :param gap_extend: The cost of extending an open gap (negative number).\n    :type gap_extend: int.\n    :param matrix: A score matrix dictionary name. Examples can be found in\n                   the substitution_matrices module.\n\n    '''\n    al = a\n    bl = b\n    l = len(al)\n    score = 0\n    assert len(bl) == l, 'Alignment lengths must be the same'\n    mat = as_ord_matrix(matrix)\n\n    gap_started = 0\n\n    for i in range(l):\n        if al[i] == '-' or bl[i] == '-':\n            score += gap_extend if gap_started else gap_open\n            gap_started = 1\n        else:\n            score += mat[ord(al[i]), ord(bl[i])]\n            gap_started = 0\n    return score", "response": "Calculate the alignment score from two aligned sequences."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_docs(directory):\n    os.chdir(directory)\n    process = subprocess.Popen([\"make\", \"html\"], cwd=directory)\n    process.communicate()", "response": "Builds sphinx docs from a given directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndesigns Gibson primers given two DNA sequences.", "response": "def gibson_primers(dna1, dna2, overlap='mixed', maxlen=80, overlap_tm=65.0,\n                   insert=None, primer_kwargs=None):\n    '''Design Gibson primers given two DNA sequences (connect left to right)\n\n    :param dna1: First piece of DNA for which to design primers. Once Gibsoned,\n                 would be connected at its right side to dna2.\n    :type dna1: coral.DNA\n    :param dna2: First piece of DNA for which to design primers. Once Gibsoned,\n                 would be connected at its right side to dna2.\n    :type dna2: coral.DNA\n    :param overlap: Specifies location of overlap. 'left' puts it on the 'dna1'\n                    side (i.e. the primer to amplify dna2). 'right' puts it on\n                    the dna2 side, and 'mixed' does a ~50:50 split\n    :type overlap: str\n    :param maxlen: Maximum length of each primer.\n    :type maxlen: int\n    :param overlap_tm: Minimum Tm of overlap\n    :type overlap_tm: float\n    :param insert: A DNA insert to add with primers and use as assembly\n                   homology. This overrides the 'split' argument.\n    :type insert: coral.DNA\n    :param primer_kwargs: keyword arguments to pass to design_primer()\n    :type primer_kwargs: dict\n    :returns: Reverse, then forward primer for bridging the two sequences.\n              Note that the forward primer binds dna2, reverse dna1.\n    :rtype: A sequence.Primer tuple\n    :raises: ValueError if split parameter is an invalid string.\n\n    '''\n    if primer_kwargs is None:\n        primer_kwargs = {}\n\n    # Annealing sequences\n    # DNA 2 primer is a forward primer\n    fwd_anneal = coral.design.primer(dna2, **primer_kwargs)\n    # DNA 1 primer is a reverse primer\n    rev_anneal = coral.design.primer(dna1.flip(), **primer_kwargs)\n    # Overhangs\n    if insert is None:\n        # No insert, so follow split argument\n        if overlap == 'left':\n            # If splitting left, put overhang on forward primer\n            overlap_revcomp = coral.design.primer(dna1.flip(), tm=overlap_tm,\n                                                  tm_undershoot=0)\n            fwd_overhang = overlap_revcomp.primer().reverse_complement()\n            rev_overhang = None\n        elif overlap == 'right':\n            # If splitting right, put overhang on reverse primer\n            overlap = coral.design.primer(dna2, tm=overlap_tm, tm_undershoot=0)\n            fwd_overhang = None\n            rev_overhang = overlap.primer().reverse_complement()\n        elif overlap == 'mixed':\n            # If mixed, grow size of both until overlap Tm is reached\n            overlap_l = dna1[0:0]  # Empty sequence.DNA\n            overlap_r = dna2[0]  # First base\n            overlap_melt = overlap_r.tm()\n            while overlap_melt < overlap_tm:\n                rlen = len(overlap_r)\n                llen = len(overlap_l)\n                if rlen > llen:\n                    # Increase left side of overlap\n                    overlap_l = dna1[-(rlen + 1):]\n                else:\n                    # Increase right side of overlap\n                    overlap_r = dna2[:(llen + 1)]\n                overlap = overlap_l + overlap_r\n                overlap_melt = overlap.tm()\n            fwd_overhang = overlap_l\n            rev_overhang = overlap_r.reverse_complement()\n        else:\n            raise ValueError('split argument must be left, right, or mixed')\n        # Generate primers using anneal, overhang, and tm data\n        fwd = coral.Primer(fwd_anneal.primer(), tm=fwd_anneal.tm,\n                           overhang=fwd_overhang)\n        rev = coral.Primer(rev_anneal.primer(), tm=rev_anneal.tm,\n                           overhang=rev_overhang)\n    else:\n        # There's an insert to use as the overhang\n        overlap = insert\n        fwd_overhang = insert.primer()\n        rev_overhang = insert.reverse_complement().primer()\n        # Generate primers using anneal, overhang, and tm data\n        fwd = coral.Primer(fwd_anneal.primer(), tm=fwd_anneal.tm,\n                           overhang=fwd_overhang)\n        rev = coral.Primer(rev_anneal.primer(), tm=rev_anneal.tm,\n                           overhang=rev_overhang)\n        left_trim = 0\n        # If either primer is too long, try trimming the overhang\n        while len(fwd) > maxlen:\n            # Generate new overlap\n            overlap = insert[left_trim:]\n            # Tm must be above overlap_tm\n            if coral.analysis.tm(overlap) < overlap_tm:\n                raise TmError('Right primer is too long with this Tm setting.')\n            # Regenerate forward overhang\n            fwd_overhang = overlap.primer()\n            # Regenerate primer with new overhang\n            fwd = coral.Primer(fwd_anneal.primer(), tm=fwd_anneal.tm,\n                               overhang=fwd_overhang)\n            # Increase 'trimming' index\n            left_trim += 1\n        right_trim = 0\n        while len(rev) > maxlen:\n            # Generate new overlap\n            overlap = insert[:len(insert) - right_trim]\n            # Tm must be above overlap_tm\n            if coral.analysis.tm(overlap) < overlap_tm:\n                raise TmError('Left primer is too long with this Tm setting.')\n            # Regenerate reverse overhang\n            rev_overhang = overlap.reverse_complement().to_ss()\n            rev = coral.Primer(rev_anneal.to_ss(), tm=rev_anneal.tm,\n                               overhang=rev_overhang)\n            # Increase 'trimming' index\n            right_trim += 1\n    # Check primer lengths\n    if any([len(primer) > maxlen for primer in (fwd, rev)]):\n        raise LengthError('At least one of the primers is longer than maxlen.')\n\n    return rev, fwd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndesign Gibson primers given a set of DNA sequences.", "response": "def gibson(seq_list, circular=True, overlaps='mixed', overlap_tm=65,\n           maxlen=80, terminal_primers=True, primer_kwargs=None):\n    '''Design Gibson primers given a set of sequences\n\n    :param seq_list: List of DNA sequences to stitch together\n    :type seq_list: list containing coral.DNA\n    :param circular: If true, designs primers for making a circular construct.\n                     If false, designs primers for a linear construct.\n    :type circular: bool\n    :param splits: Specifies locations of overlap. Must be either a single\n                   entry of the same type as the 'split' parameter in\n                   gibson_primers or a list of those types of the appropriate\n                   length (for circular construct, len(seq_list), for\n                   linear construct, len(seq_list) - 1)\n    :type splits: str or list of str\n    :param overlap_tm: Minimum Tm of overlap\n    :type overlap_tm: float\n    :param maxlen: Maximum length of each primer.\n    :type maxlen: int\n    :param terminal_primers: If the output is not circular, will design\n                             non-Gibson primers for amplifying the first and\n                             last fragments sans homology. If False, there will\n                             be one less set of primers returned.\n    :type terminal_primers: bool\n    :param primer_kwargs: keyword arguments to pass to design.primer\n    :type primer_kwargs: dict\n    :returns: Forward and reverse primers for amplifying every fragment.\n    :rtype: a list of sequence.Primer tuples\n    :raises: ValueError if split parameter is an invalid string or wrong size.\n\n    '''\n\n    # Input checking\n    if circular:\n        n_overlaps = len(seq_list)\n    else:\n        n_overlaps = len(seq_list) - 1\n\n    if type(overlaps) is str:\n        overlaps = [overlaps] * n_overlaps\n    else:\n        if len(overlaps) != n_overlaps:\n            raise ValueError('Incorrect number of \\'overlaps\\' entries.')\n        else:\n            for overlap in overlaps:\n                if overlap not in ['left', 'right', 'mixed']:\n                    raise ValueError('Invalid \\'overlaps\\' setting.')\n\n    if primer_kwargs is None:\n        primer_kwargs = {}\n\n    # If here, inputs were good\n    # Design primers for linear constructs:\n    primers_list = []\n    for i, (left, right) in enumerate(zip(seq_list[:-1], seq_list[1:])):\n        primers_list.append(gibson_primers(left, right, overlaps[i],\n                                           overlap_tm=overlap_tm,\n                                           primer_kwargs=primer_kwargs))\n    if circular:\n        primers_list.append(gibson_primers(seq_list[-1], seq_list[0],\n                                           overlaps[-1],\n                                           overlap_tm=overlap_tm,\n                                           primer_kwargs=primer_kwargs))\n    else:\n        if terminal_primers:\n            primer_f = coral.design.primer(seq_list[0], **primer_kwargs)\n            primer_r = coral.design.primer(seq_list[-1].reverse_complement(),\n                                           **primer_kwargs)\n            primers_list.append((primer_r, primer_f))\n\n    # Primers are now in order of 'reverse for seq1, forward for seq2' config\n    # Should be in 'forward and reverse primers for seq1, then seq2', etc\n    # Just need to rotate one to the right\n    flat = [y for x in primers_list for y in x]\n    flat = [flat[-1]] + flat[:-1]\n    grouped_primers = [(flat[2 * i], flat[2 * i + 1]) for i in\n                       range(len(flat) / 2)]\n\n    return grouped_primers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _decompose(string, n):\n    '''Given string and multiplier n, find m**2 decomposition.\n\n    :param string: input string\n    :type string: str\n    :param n: multiplier\n    :type n: int\n    :returns: generator that produces m**2 * string if m**2 is a factor of n\n    :rtype: generator of 0 or 1\n\n    '''\n    binary = [int(x) for x in bin(n)[2:]]\n    new_string = string\n    counter = 1\n    while counter <= len(binary):\n        if binary[-counter]:\n            yield new_string\n        new_string += new_string\n        counter += 1", "response": "Given a string and multiplier n find m**2 decomposition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reverse_complement(sequence, material):\n    '''Reverse complement a sequence.\n\n    :param sequence: Sequence to reverse complement\n    :type sequence: str\n    :param material: dna, rna, or peptide.\n    :type material: str\n    '''\n    code = dict(COMPLEMENTS[material])\n    reverse_sequence = sequence[::-1]\n    return ''.join([code[str(base)] for base in reverse_sequence])", "response": "Reverse complement a sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_alphabet(seq, material):\n    '''Verify that a given string is valid DNA, RNA, or peptide characters.\n\n    :param seq: DNA, RNA, or peptide sequence.\n    :type seq: str\n    :param material: Input material - 'dna', 'rna', or 'pepide'.\n    :type sequence: str\n    :returns: Whether the `seq` is a valid string of `material`.\n    :rtype: bool\n    :raises: ValueError if `material` isn't \\'dna\\', \\'rna\\', or \\'peptide\\'.\n             ValueError if `seq` contains invalid characters for its\n             material type.\n\n    '''\n    errs = {'dna': 'DNA', 'rna': 'RNA', 'peptide': 'peptide'}\n    if material == 'dna' or material == 'rna' or material == 'peptide':\n        alphabet = ALPHABETS[material]\n        err_msg = errs[material]\n    else:\n        msg = 'Input material must be \\'dna\\', \\'rna\\', or \\'peptide\\'.'\n        raise ValueError(msg)\n    # This is a bottleneck when modifying sequence - hence the run_checks\n    # optional parameter in sequence objects..\n    # First attempt with cython was slower. Could also try pypy.\n    if re.search('[^' + alphabet + ']', seq):\n        raise ValueError('Encountered a non-%s character' % err_msg)", "response": "Verify that a given string is a valid DNA RNA or peptide character sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_seq(seq, material):\n    '''Validate and process sequence inputs.\n\n    :param seq: input sequence\n    :type seq: str\n    :param material: DNA, RNA, or peptide\n    :type: str\n    :returns: Uppercase version of `seq` with the alphabet checked by\n              check_alphabet().\n    :rtype: str\n\n    '''\n    check_alphabet(seq, material)\n    seq = seq.upper()\n    return seq", "response": "Validate and process sequence inputs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting whether a sequence is a palindrome.", "response": "def palindrome(seq):\n    '''Test whether a sequence is palindrome.\n\n    :param seq: Sequence to analyze (DNA or RNA).\n    :type seq: coral.DNA or coral.RNA\n    :returns: Whether a sequence is a palindrome.\n    :rtype: bool\n\n    '''\n    seq_len = len(seq)\n    if seq_len % 2 == 0:\n        # Sequence has even number of bases, can test non-overlapping seqs\n        wing = seq_len / 2\n        l_wing = seq[0: wing]\n        r_wing = seq[wing:]\n        if l_wing == r_wing.reverse_complement():\n            return True\n        else:\n            return False\n    else:\n        # Sequence has odd number of bases and cannot be a palindrome\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self):\n        '''Create a copy of the current instance.\n\n        :returns: A safely editable copy of the current sequence.\n\n        '''\n        # Significant performance improvements by skipping alphabet check\n        return type(self)(self.seq, self.material, run_checks=False)", "response": "Create a safely editable copy of the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef locate(self, pattern):\n        '''Find sequences matching a pattern.\n\n        :param pattern: Sequence for which to find matches.\n        :type pattern: str\n        :returns: Indices of pattern matches.\n        :rtype: list of ints\n\n        '''\n        if len(pattern) > len(self):\n            raise ValueError('Search pattern longer than searchable ' +\n                             'sequence.')\n        seq = self.seq\n\n        pattern = str(pattern).upper()\n        re_pattern = '(?=' + pattern + ')'\n        matches = [index.start() % len(self) for index in\n                   re.finditer(re_pattern, seq)]\n\n        return matches", "response": "Find sequences matching a pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self):\n        '''Return a copy of the Feature.\n\n        :returns: A safely editable copy of the current feature.\n        :rtype: coral.Feature\n\n        '''\n        return type(self)(self.name, self.start, self.stop, self.feature_type,\n                          gene=self.gene, locus_tag=self.locus_tag,\n                          qualifiers=self.qualifiers, strand=self.strand)", "response": "Return a safely editable copy of the current feature."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits Nupack commands over processors.", "response": "def nupack_multi(seqs, material, cmd, arguments, report=True):\n    '''Split Nupack commands over processors.\n\n    :param inputs: List of sequences, same format as for coral.analysis.Nupack.\n    :type inpus: list\n    :param material: Input material: 'dna' or 'rna'.\n    :type material: str\n    :param cmd: Command: 'mfe', 'pairs', 'complexes', or 'concentrations'.\n    :type cmd: str\n    :param arguments: Arguments for the command.\n    :type arguments: str\n    :returns: A list of the same return value you would get from `cmd`.\n    :rtype: list\n\n    '''\n    nupack_pool = multiprocessing.Pool()\n    try:\n        args = [{'seq': seq,\n                 'cmd': cmd,\n                 'material': material,\n                 'arguments': arguments} for seq in seqs]\n        nupack_iterator = nupack_pool.imap(run_nupack, args)\n        total = len(seqs)\n        msg = ' calculations complete.'\n        passed = 4\n        while report:\n            completed = nupack_iterator._index\n            if (completed == total):\n                break\n            else:\n                if passed >= 4:\n                    print '({0}/{1}) '.format(completed, total) + msg\n                    passed = 0\n                passed += 1\n                time.sleep(1)\n        multi_output = [x for x in nupack_iterator]\n        nupack_pool.close()\n        nupack_pool.join()\n    except KeyboardInterrupt:\n        nupack_pool.terminate()\n        nupack_pool.close()\n        raise KeyboardInterrupt\n\n    return multi_output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun picklable Nupack command.", "response": "def run_nupack(kwargs):\n    '''Run picklable Nupack command.\n\n    :param kwargs: keyword arguments to pass to Nupack as well as 'cmd'.\n    :returns: Variable - whatever `cmd` returns.\n\n    '''\n    run = NUPACK(kwargs['seq'])\n    output = getattr(run, kwargs['cmd'])(**kwargs['arguments'])\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pfunc_multi(self, strands, permutation=None, temp=37.0, pseudo=False,\n                    material=None, dangles='some', sodium=1.0, magnesium=0.0):\n        '''Compute the partition function for an ordered complex of strands.\n        Runs the \\'pfunc\\' command.\n\n        :param strands: List of strands to use as inputs to pfunc -multi.\n        :type strands: list\n        :param permutation: The circular permutation of strands to test in\n                            complex. e.g. to test in the order that was input\n                            for 4 strands, the permutation would be [1,2,3,4].\n                            If set to None, defaults to the order of the\n                            input strands.\n        :type permutation: list\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: A 2-tuple of the free energy of the ordered complex\n                  (float) and the partition function (float).\n        :rtype: tuple\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strands, material, multi=True)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=True)\n        # Set up the input file and run the command\n        if permutation is None:\n            permutation = range(1, len(strands) + 1)\n        lines = self._multi_lines(strands, permutation)\n        stdout = self._run('pfunc', cmd_args, lines).split('\\n')\n\n        return (float(stdout[-3]), float(stdout[-2]))", "response": "Compute the partition function for an ordered complex of strands."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the pair probabilities for an ordered complex of strands.", "response": "def pairs(self, strand, cutoff=0.001, temp=37.0, pseudo=False,\n              material=None, dangles='some', sodium=1.0, magnesium=0.0):\n        '''Compute the pair probabilities for an ordered complex of strands.\n        Runs the \\'pairs\\' command.\n\n        :param strand: Strand on which to run pairs. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strand: list\n        :param cutoff: Only probabilities above this cutoff appear in the\n                       output.\n        :type cutoff: float\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: The probability matrix, where the (i, j)th entry\n                  is the probability that base i is bound to base j. The matrix\n                  is augmented (it's N+1 by N+1, where N is the number of bases\n                  in the sequence) with an (N+1)th column containing the\n                  probability that each base is unpaired.\n        :rtype: numpy.array\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strand, material)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=False)\n\n        # Set up the input file and run the command. Note: no STDOUT\n        lines = [str(strand)]\n        self._run('pairs', cmd_args, lines)\n\n        # Read the output from file\n        ppairs = self._read_tempfile('pairs.ppairs')\n        data = re.search('\\n\\n\\d*\\n(.*)', ppairs, flags=re.DOTALL).group(1)\n        N = len(strand)\n        data_lines = [line.split('\\t') for line in data.split('\\n') if line]\n        prob_matrix = self._pairs_to_np(data_lines, N)\n\n        return prob_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the pair probabilities for a set of strands in a single base.", "response": "def pairs_multi(self, strands, cutoff=0.001, permutation=None, temp=37.0,\n                    pseudo=False, material=None, dangles='some', sodium=1.0,\n                    magnesium=0.0):\n        '''Compute the pair probabilities for an ordered complex of strands.\n        Runs the \\'pairs\\' command.\n\n        :param strands: List of strands to use as inputs to pairs -multi.\n        :type strands: list\n        :param permutation: The circular permutation of strands to test in\n                            complex. e.g. to test in the order that was input\n                            for 4 strands, the permutation would be [1,2,3,4].\n                            If set to None, defaults to the order of the\n                            input strands.\n        :type permutation: list\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :param cutoff: Only probabilities above this cutoff appear in the\n                       output.\n        :type cutoff: float\n        :returns: Two probability matrices: The probability matrix as in the\n                  pairs method (but with a dimension equal to the sum of the\n                  lengths of the sequences in the permutation), and a similar\n                  probability matrix where multiple strands of the same species\n                  are considered to be indistinguishable.\n        :rtype: list\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strands, material, multi=True)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=True)\n\n        # Set up the input file and run the command. Note: no STDOUT\n        if permutation is None:\n            permutation = range(1, len(strands) + 1)\n        lines = self._multi_lines(strands, permutation)\n        self._run('pairs', cmd_args, lines)\n\n        # Read the output from file\n        N = sum([len(s) for s in strands])\n        matrices = []\n        for mat_type in ['ppairs', 'epairs']:\n            data = self._read_tempfile('pairs.' + mat_type)\n            probs = re.search('\\n\\n\\d*\\n(.*)', data, flags=re.DOTALL).group(1)\n            lines = probs.split('\\n')\n            # Remove the last line (empty)\n            lines.pop()\n            pairlist = [line.split('\\t') for line in lines]\n            prob_matrix = self._pairs_to_np(pairlist, N)\n            matrices.append(prob_matrix)\n\n        return matrices"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mfe(self, strand, degenerate=False, temp=37.0, pseudo=False,\n            material=None, dangles='some', sodium=1.0, magnesium=0.0):\n        '''Compute the MFE for an ordered complex of strands. Runs the \\'mfe\\'\n        command.\n\n        :param strand: Strand on which to run mfe. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strand: coral.DNA or coral.RNA\n        :param degenerate: Setting to True will result in returning a list of\n                           dictionaries associated with structures having the\n                           same, minimal MFE value.\n        :type degenerate: bool\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: A dictionary with keys for 'mfe' (a float), 'dotparens'\n                  (dot-parens notation of the MFE structure), and 'pairlist'\n                  (a pair list notation of the MFE structure). Note that the\n                  pair list will be an empty list if the MFE is unstructured.\n        :rtype: dict\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strand, material)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=False)\n        if degenerate:\n            cmd_args.append('-degenerate')\n\n        # Set up the input file and run the command. Note: no STDOUT\n        lines = [str(strand)]\n        self._run('mfe', cmd_args, lines)\n\n        # Read the output from file\n        structures = self._process_mfe(self._read_tempfile('mfe.mfe'))\n\n        if degenerate:\n            return structures\n        else:\n            return structures[0]", "response": "Compute the MFE for an ordered complex of strands."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mfe_multi(self, strands, permutation=None, degenerate=False, temp=37.0,\n                  pseudo=False, material=None, dangles='some', sodium=1.0,\n                  magnesium=0.0):\n        '''Compute the MFE for an ordered complex of strands. Runs the \\'mfe\\'\n        command.\n\n        :param strands: Strands on which to run mfe. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strands: list\n        :param permutation: The circular permutation of strands to test in\n                            complex. e.g. to test in the order that was input\n                            for 4 strands, the permutation would be [1,2,3,4].\n                            If set to None, defaults to the order of the\n                            input strands.\n        :type permutation: list\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :param degenerate: Setting to True will result in returning a list of\n                           dictionaries associated with structures having the\n                           same, minimal MFE value.\n        :type degenerate: bool\n        :returns: A dictionary with keys for 'mfe' (a float), 'dotparens'\n                  (dot-parens notation of the MFE structure), and 'pairlist'\n                  (a pair list notation of the MFE structure). Note that the\n                  pair list will be an empty list if the MFE is unstructured.\n        :rtype: dict\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strands, material, multi=True)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=True)\n        if degenerate:\n            cmd_args.append('-degenerate')\n\n        # Set up the input file and run the command. Note: no STDOUT\n        if permutation is None:\n            permutation = range(1, len(strands) + 1)\n        lines = self._multi_lines(strands, permutation)\n        self._run('mfe', cmd_args, lines)\n\n        # Read the output from file\n        structures = self._process_mfe(self._read_tempfile('mfe.mfe'))\n\n        if degenerate:\n            return structures\n        else:\n            return structures[0]", "response": "Compute the MFE for an ordered complex of strands."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef subopt(self, strand, gap, temp=37.0, pseudo=False, material=None,\n               dangles='some', sodium=1.0, magnesium=0.0):\n        '''Compute the suboptimal structures within a defined energy gap of the\n        MFE. Runs the \\'subopt\\' command.\n\n        :param strand: Strand on which to run subopt. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strand: coral.DNA or coral.RNA\n        :param gap: Energy gap within to restrict results, e.g. 0.1.\n        :type gap: float\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: A list of dictionaries of the type returned by .mfe().\n        :rtype: list\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strand, material)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=False)\n\n        # Set up the input file and run the command. Note: no STDOUT\n        lines = [str(strand), str(gap)]\n        self._run('subopt', cmd_args, lines)\n\n        # Read the output from file\n        structures = self._process_mfe(self._read_tempfile('subopt.subopt'))\n\n        return structures", "response": "Compute the suboptimal structures within a defined energy gap of the MFE."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenumerate the total number of secondary structures over the the ensemble \u03a9 ( \u03c0.", "response": "def count(self, strand, pseudo=False):\n        '''Enumerates the total number of secondary structures over the\n        structural ensemble \u03a9(\u03c0). Runs the \\'count\\' command.\n\n        :param strand: Strand on which to run count. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strand: list\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :returns: The count of the number of structures in the structural\n                  ensemble.\n        :rtype: int\n\n        '''\n        # Set up command flags\n        if pseudo:\n            cmd_args = ['-pseudo']\n        else:\n            cmd_args = []\n\n        # Set up the input file and run the command\n        stdout = self._run('count', cmd_args, [str(strand)]).split('\\n')\n\n        # Return the count\n        return int(float(stdout[-2]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nenumerate the total number of secondary structures over the structureural ensemble \u03a9 ( \u03c0 ) with an ordered permutation of strands.", "response": "def count_multi(self, strands, permutation=None, pseudo=False):\n        '''Enumerates the total number of secondary structures over the\n        structural ensemble \u03a9(\u03c0) with an ordered permutation of strands. Runs\n        the \\'count\\' command.\n\n        :param strands: List of strands to use as inputs to count -multi.\n        :type strands: list\n        :param permutation: The circular permutation of strands to test in\n                            complex. e.g. to test in the order that was input\n                            for 4 strands, the permutation would be [1,2,3,4].\n                            If set to None, defaults to the order of the\n                            input strands.\n        :type permutation: list\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :returns: Dictionary with the following key:value pairs: 'energy':\n                  free energy, 'pfunc': partition function.\n        :rtype: dict\n\n        '''\n        # Set up command flags\n        cmd_args = ['-multi']\n        if pseudo:\n            cmd_args.append('-pseudo')\n\n        # Set up the input file and run the command\n        if permutation is None:\n            permutation = range(1, len(strands) + 1)\n        lines = self._multi_lines(strands, permutation)\n        stdout = self._run('count', cmd_args, lines).split('\\n')\n\n        return int(float(stdout[-2]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef energy(self, strand, dotparens, temp=37.0, pseudo=False, material=None,\n               dangles='some', sodium=1.0, magnesium=0.0):\n        '''Calculate the free energy of a given sequence structure. Runs the\n        \\'energy\\' command.\n\n        :param strand: Strand on which to run energy. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strand: coral.DNA or coral.RNA\n        :param dotparens: The structure in dotparens notation.\n        :type dotparens: str\n        :param temp: Temperature setting for the computation. Negative values\n                     are not allowed.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: The free energy of the sequence with the specified secondary\n                  structure.\n        :rtype: float\n\n        '''\n        # Set the material (will be used to set command material flag)\n        material = self._set_material(strand, material)\n\n        # Set up command flags\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=False)\n\n        # Set up the input file and run the command. Note: no STDOUT\n        lines = [str(strand), dotparens]\n        stdout = self._run('energy', cmd_args, lines).split('\\n')\n\n        # Return the energy\n        return float(stdout[-2])", "response": "Calculate the free energy of a given secondary sequence structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef complexes(self, strands, max_size, ordered=False, pairs=False,\n                  mfe=False, cutoff=0.001, degenerate=False, temp=37.0,\n                  pseudo=False, material=None, dangles='some', sodium=1.0,\n                  magnesium=0.0):\n        '''\n        :param strands: Strands on which to run energy. Strands must be either\n                       coral.DNA or coral.RNA).\n        :type strands: list of coral.DNA or coral.RNA\n        :param max_size: Maximum complex size to consider (maximum number of\n                         strand species in complex).\n        :type max_size: int\n        :param ordered: Consider distinct ordered complexes - all distinct\n                        circular permutations of each complex.\n        :type ordered: bool\n        :param pairs: Calculate base-pairing observables as with .pairs().\n        :type pairs: bool\n        :param cutoff: A setting when pairs is set to True - only probabilities\n                       above this threshold will be returned.\n        :type cutoff: float\n        :param degenerate: Applies only when \\'mfe\\' is set to True. If\n                           set to True, the 'mfe' value associated with each\n                           complex will be a list of degenerate MFEs (as in\n                           the case of .mfe()).\n        :type degenerate: bool\n        :param temp: Temperature.\n        :type temp: float\n        :param pseudo: Enable pseudoknots.\n        :type pseudo: bool\n        :param material: The material setting to use in the computation. If set\n                         to None (the default), the material type is inferred\n                         from the strands. Other settings available: 'dna' for\n                         DNA parameters, 'rna' for RNA (1995) parameters, and\n                         'rna1999' for the RNA 1999 parameters.\n        :type material: str\n        :param dangles: How to treat dangles in the computation. From the\n                        user guide: For \\'none\\': Dangle energies are ignored.\n                        For \\'some\\': \\'A dangle energy is incorporated for\n                        each unpaired base flanking a duplex\\'. For 'all': all\n                        dangle energy is considered.\n        :type dangles: str\n        :param sodium: Sodium concentration in solution (molar), only applies\n                       to DNA.\n        :type sodium: float\n        :param magnesium: Magnesium concentration in solution (molar), only\n                          applies to DNA>\n        :type magnesium: float\n        :returns: A list of dictionaries containing at least 'energy',\n                  'complex', and 'strands' keys. If 'ordered' is True, the\n                  different possible ordered permutations of complexes are\n                  considered. In addition, with 'ordered' set to True, an\n                  additional 'order' key describing the exact order of strands\n                  and a 'permutation' index (integer) are added. If 'pairs' is\n                  True, there is an additional 'epairs' key containing the\n                  base-pairing expectation values. If 'mfe' is selected, 'mfe,\n                  'dotparens', and 'pairlist' keys in the same as .mfe(). In\n                  addition, 'mfe' sets the -ordered flag, so the same keys as\n                  when 'ordered' is set to True are added.\n        :rtype: float\n\n        '''\n        # TODO: Consider returning a pandas dataframe in this (and other)\n        # situations to make sorting/selection between results easier.\n        material = self._set_material(strands, material, multi=True)\n        cmd_args = self._prep_cmd_args(temp, dangles, material, pseudo, sodium,\n                                       magnesium, multi=False)\n        cmd_args.append('-quiet')\n        if mfe:\n            cmd_args.append('-mfe')\n            ordered = True\n            if degenerate:\n                cmd_args.append('-degenerate')\n        if ordered:\n            cmd_args.append('-ordered')\n        if pairs:\n            cmd_args.append('-pairs')\n            cmd_args.append('-cutoff')\n            cmd_args.append(cutoff)\n\n        dim = sum([len(s) for s in strands])\n        nstrands = len(strands)\n        # Set up the input file and run the command\n        lines = self._multi_lines(strands, [max_size])\n        self._run('complexes', cmd_args, lines)\n\n        # Read the output from file(s)\n        if ordered:\n            ocx_lines = self._read_tempfile('complexes.ocx').split('\\n')\n            # Process each lines\n            output = []\n            for line in ocx_lines:\n                if line and not line.startswith('%'):\n                    data = line.split('\\t')\n                    energy = float(data[-1])\n                    complexes = [int(d) for d in data[2:2 + nstrands]]\n                    permutation = int(data[1])\n                    output.append({'energy': energy, 'complex': complexes,\n                                   'permutation': permutation})\n\n            key_lines = self._read_tempfile('complexes.ocx-key').split('\\n')\n\n            data_lines = [l for l in key_lines if not l.startswith('%')]\n            data_lines.pop()\n            for i, line in enumerate(data_lines):\n                data = line.split('\\t')\n                keys = [int(d) for d in data[2:-1]]\n                output[i]['order'] = keys\n\n            if pairs:\n                epairs_data = self._read_tempfile('complexes.ocx-epairs')\n                pairslist = self._process_epairs(epairs_data)\n                for i, pairs in enumerate(pairslist):\n                    output[i]['epairs'] = self._pairs_to_np(pairs, dim)\n                # TODO: add ocx-ppairs as well\n\n            if mfe:\n                mfe_data = self._read_tempfile('complexes.ocx-mfe')\n                if degenerate:\n                    return NotImplementedError('Not implemented for complexes')\n                else:\n                    mfe_output = self._process_mfe(mfe_data, complexes=True)\n                    for i, mfedat in enumerate(mfe_output):\n                        output[i]['mfe'] = mfedat['mfe']\n                        output[i]['dotparens'] = mfedat['dotparens']\n                        output[i]['pairlist'] = mfedat['pairlist']\n        else:\n            cx_lines = self._read_tempfile('complexes.cx').split('\\n')\n            # Remove empty last line\n            cx_lines.pop()\n            output = []\n            for line in cx_lines:\n                if not line.startswith('%'):\n                    data = line.split('\\t')\n                    energy = float(data[-1])\n                    complexes = [int(d) for d in data[1:1 + len(strands)]]\n                    output.append({'energy': energy, 'complex': complexes})\n\n            if pairs:\n                # Process epairs\n                epairs_data = self._read_tempfile('complexes.cx-epairs')\n                pairslist = self._process_epairs(epairs_data)\n                for i, pairs in enumerate(pairslist):\n                    proba_mat = self._pairs_to_np(pairs, dim)\n                    output[i]['epairs'] = proba_mat\n\n        # Add strands (for downstream concentrations)\n        for cx in output:\n            cx['strands'] = [s.copy() for s in strands]\n\n        return output", "response": "Return a list of complexes for the base - pairing model."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef concentrations(self, complexes, concs, ordered=False, pairs=False,\n                       cutoff=0.001, temp=37.0):\n        '''\n        :param complexes: A list of the type returned by the complexes()\n                          method.\n        :type complexes: list\n        :param concs: The concentration(s) of each strand species in the\n                      initial complex. If they are all the same, a single\n                      float can be used here.\n        :type concs: list of floats or float\n        :param ordered: Consider distinct ordered complexes - all distinct\n                        circular permutations of each complex.\n        :type ordered: bool\n        :param pairs: Calculate base-pairing observables as with .pairs().\n        :type pairs: bool\n        :param cutoff: A setting when pairs is set to True - only probabilities\n                       above this threshold will be returned.\n        :type cutoff: float\n        :param temp: Temperature in C.\n        :type temp: float\n        :returns: A list of dictionaries containing (at least) a\n                  'concentrations' key. If 'pairs' is True, an 'fpairs' key\n                  is added.\n        :rtype: list\n\n        '''\n        # Check inputs\n        nstrands = len(complexes[0]['strands'])\n        try:\n            if len(concs) != nstrands:\n                raise ValueError('concs argument not same length as strands.')\n        except TypeError:\n            concs = [concs for i in range(len(complexes['strands']))]\n\n        # Set up command-line arguments\n        cmd_args = ['-quiet']\n        if ordered:\n            cmd_args.append('-ordered')\n\n        # Write .con file\n        with open(os.path.join(self._tempdir, 'concentrations.con')) as f:\n            f.writelines(concs)\n\n        # Write .cx or .ocx file\n        header = ['%t Number of strands: {}'.format(nstrands),\n                  '%\\tid\\tsequence']\n        for i, strand in enumerate(complexes['strands']):\n            header.append('%\\t{}\\t{}'.format(i + 1, strand))\n        header.append('%\\tT = {}'.format(temp))\n        body = []\n        for i, cx in enumerate(complexes):\n            permutation = '\\t'.join(complexes['complex'])\n            line = '{}\\t{}\\t{}'.format(i + 1, permutation, complexes['energy'])\n            body.append(line)\n\n        if ordered:\n            cxfile = os.path.join(self._tempdir, 'concentrations.ocx')\n        else:\n            cxfile = os.path.join(self._tempdir, 'concentrations.cx')\n\n        with open(cxfile) as f:\n            f.writelines(header + body)\n\n        # Run 'concentrations'\n        self._run('concentrations', cmd_args, None)\n\n        # Parse the .eq (concentrations) file\n        eq_lines = self._read_tempfile('concentrations.eq').split('\\n')\n        tsv_lines = [l for l in eq_lines if not l.startswith('%')]\n        output = []\n        for i, line in enumerate(tsv_lines):\n            # It's a TSV\n            data = line.split('\\t')\n            # Column 0 is an index\n            # Columns 1-nstrands is the complex\n            cx = [int(c) for c in data[1:nstrands]]\n            # Column nstrands + 1 is the complex energy\n            # Column nstrands + 2 is the equilibrium concentration\n            eq = float(data[nstrands + 2])\n            output[i] = {'complex': cx, 'concentration': eq}\n\n        if pairs:\n            # Read the .fpairs file\n            pairs = self._read_tempfile('concentrations.fpairs')\n            pairs_tsv = [l for l in pairs.split('\\n') if not l.startswith('%')]\n            # Remove first line (n complexes)\n            dim = int(pairs_tsv.pop(0))\n            pprob = [[int(p[0]), int(p[1]), float(p[2])] for p in pairs_tsv]\n            # Convert to augmented numpy matrix\n            fpairs_mat = self.pairs_to_np(pprob, dim)\n            for i, out in enumerate(output):\n                output[i]['fpairs'] = fpairs_mat\n\n        return output", "response": "This method returns a list of dictionaries containing the concentrations of each complex."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the distributions NUPACK command.", "response": "def distributions(self, complexes, counts, volume, maxstates=1e7,\n                      ordered=False, temp=37.0):\n        '''Runs the \\'distributions\\' NUPACK command. Note: this is intended\n        for a relatively small number of species (on the order of ~20\n        total strands for complex size ~14).\n\n        :param complexes: A list of the type returned by the complexes()\n                          method.\n        :type complexes: list\n        :param counts: A list of the exact number of molecules of each initial\n                       species (the strands in the complexes command).\n        :type counts: list of ints\n        :param volume: The volume, in liters, of the container.\n        :type volume: float\n        :param maxstates: Maximum number of states to be enumerated, needed\n                          as allowing too many states can lead to a segfault.\n                          In NUPACK, this is referred to as lambda.\n        :type maxstates: float\n        :param ordered: Consider distinct ordered complexes - all distinct\n                        circular permutations of each complex.\n        :type ordered: bool\n        :param temp: Temperature in C.\n        :type temp: float\n        :returns: A list of dictionaries containing (at least) a 'complexes'\n                  key for the unique complex, an 'ev' key for the expected\n                  value of the complex population and a 'probcols' list\n                  indicating the probability that a given complex has\n                  population 0, 1, ... max(pop) at equilibrium.\n        :rtype: list\n        :raises: LambdaError if maxstates is exceeded.\n\n        '''\n        # Check inputs\n        nstrands = len(complexes[0]['strands'])\n        if len(counts) != nstrands:\n            raise ValueError('counts argument not same length as strands.')\n\n        # Set up command-line arguments\n        cmd_args = []\n        if ordered:\n            cmd_args.append('-ordered')\n\n        # Write .count file\n        countpath = os.path.join(self._tempdir, 'distributions.count')\n        with open(countpath, 'w') as f:\n            f.writelines([str(c) for c in counts] + [str(volume)])\n\n        # Write .cx or .ocx file\n        header = ['%t Number of strands: {}'.format(nstrands),\n                  '%\\tid\\tsequence']\n        for i, strand in enumerate(complexes['strands']):\n            header.append('%\\t{}\\t{}'.format(i + 1, strand))\n        header.append('%\\tT = {}'.format(temp))\n        body = []\n        for i, cx in enumerate(complexes):\n            permutation = '\\t'.join(complexes['complex'])\n            line = '{}\\t{}\\t{}'.format(i + 1, permutation, complexes['energy'])\n            body.append(line)\n\n        if ordered:\n            cxfile = os.path.join(self._tempdir, 'distributions.ocx')\n        else:\n            cxfile = os.path.join(self._tempdir, 'distributions.cx')\n\n        with open(cxfile) as f:\n            f.writelines(header + body)\n\n        # Run 'distributions'\n        stdout = self._run('distributions', cmd_args, None)\n\n        # Parse STDOUT\n        stdout_lines = stdout.split('\\n')\n        if stdout_lines[0].startswith('Exceeded maximum number'):\n            raise LambdaError('Exceeded maxstates combinations.')\n\n        # pop_search = re.search('There are (*) pop', stdout_lines[0]).group(1)\n        # populations = int(pop_search)\n        # kT_search = re.search('of the box: (*) kT', stdout_lines[1]).group(1)\n        # kT = float(kT_search)\n\n        # Parse .dist file (comments header + TSV)\n        dist_lines = self._read_tempfile('distributions.dist').split('\\n')\n        tsv_lines = [l for l in dist_lines if not l.startswith('%')]\n        tsv_lines.pop()\n        output = []\n        for i, line in enumerate(tsv_lines):\n            data = line.split('\\t')\n            # Column 0 is an index\n            # Columns 1-nstrands are complexes\n            cx = [int(d) for d in data[1:nstrands]]\n            # Column nstrands + 1 is expected value of complex\n            ev = float(data[nstrands + 1])\n            # Columns nstrands + 2 and on are probability columns\n            probcols = [float(d) for d in data[nstrands + 2:]]\n            output[i]['complex'] = cx\n            output[i]['ev'] = ev\n            output[i]['probcols'] = probcols\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npreparing lines to write to file for command input.", "response": "def _multi_lines(self, strands, permutation):\n        '''Prepares lines to write to file for pfunc command input.\n\n        :param strand: Strand input (cr.DNA or cr.RNA).\n        :type strand: cr.DNA or cr.DNA\n        :param permutation: Permutation (e.g. [1, 2, 3, 4]) of the type used\n                            by pfunc_multi.\n        :type permutation: list\n        '''\n        lines = []\n        # Write the total number of distinct strands\n        lines.append(str(len(strands)))\n        # Write the distinct strands\n        lines += [str(strand) for strand in strands]\n        # Write the permutation\n        lines.append(' '.join(str(p) for p in permutation))\n\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_tempfile(self, filename):\n        '''Read in and return file that's in the tempdir.\n\n        :param filename: Name of the file to read.\n        :type filename: str\n\n        '''\n        with open(os.path.join(self._tempdir, filename)) as f:\n            return f.read()", "response": "Read in and return file that s in the tempdir."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a set of pair probability lines construct a numpy array.", "response": "def _pairs_to_np(self, pairlist, dim):\n        '''Given a set of pair probability lines, construct a numpy array.\n\n        :param pairlist: a list of pair probability triples\n        :type pairlist: list\n        :returns: An upper triangular matrix of pair probabilities augmented\n                  with one extra column that represents the unpaired\n                  probabilities.\n        :rtype: numpy.array\n\n        '''\n        mat = np.zeros((dim, dim + 1))\n        for line in pairlist:\n            i = int(line[0]) - 1\n            j = int(line[1]) - 1\n            prob = float(line[2])\n            mat[i, j] = prob\n        return mat"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _flip_feature(self, feature, parent_len):\n    '''Adjust a feature's location when flipping DNA.\n\n    :param feature: The feature to flip.\n    :type feature: coral.Feature\n    :param parent_len: The length of the sequence to which the feature belongs.\n    :type parent_len: int\n\n    '''\n    copy = feature.copy()\n    # Put on the other strand\n    if copy.strand == 0:\n        copy.strand = 1\n    else:\n        copy.strand = 0\n    # Adjust locations - guarantee that start is always less than end\n    copy.start = parent_len - copy.start\n    copy.stop = parent_len - copy.stop\n    copy.start, copy.stop = copy.stop, copy.start\n    return copy", "response": "Flip a feature s location when flipping DNA."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ape(self, ape_path=None):\n        '''Open in ApE if `ApE` is in your command line path.'''\n        # TODO: simplify - make ApE look in PATH only\n        cmd = 'ApE'\n        if ape_path is None:\n            # Check for ApE in PATH\n            ape_executables = []\n            for path in os.environ['PATH'].split(os.pathsep):\n                exepath = os.path.join(path, cmd)\n                ape_executables.append(os.access(exepath, os.X_OK))\n            if not any(ape_executables):\n                raise Exception('Ape not in PATH. Use ape_path kwarg.')\n        else:\n            cmd = ape_path\n        # Check whether ApE exists in PATH\n        tmp = tempfile.mkdtemp()\n        if self.name is not None and self.name:\n            filename = os.path.join(tmp, '{}.ape'.format(self.name))\n        else:\n            filename = os.path.join(tmp, 'tmp.ape')\n        coral.seqio.write_dna(self, filename)\n        process = subprocess.Popen([cmd, filename])\n        # Block until window is closed\n        try:\n            process.wait()\n            shutil.rmtree(tmp)\n        except KeyboardInterrupt:\n            shutil.rmtree(tmp)", "response": "Open in ApE if ApE is in your command line path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a safely - editable copy of the current instance.", "response": "def copy(self):\n        '''Create a copy of the current instance.\n\n        :returns: A safely-editable copy of the current sequence.\n        :rtype: coral.DNA\n\n        '''\n        # Significant performance improvements by skipping alphabet check\n        features_copy = [feature.copy() for feature in self.features]\n        copy = type(self)(self.top.seq, circular=self.circular,\n                          features=features_copy, name=self.name,\n                          bottom=self.bottom.seq, run_checks=False)\n        return copy"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef circularize(self):\n        '''Circularize linear DNA.\n\n        :returns: A circularized version of the current sequence.\n        :rtype: coral.DNA\n\n        '''\n        if self.top[-1].seq == '-' and self.bottom[0].seq == '-':\n            raise ValueError('Cannot circularize - termini disconnected.')\n        if self.bottom[-1].seq == '-' and self.top[0].seq == '-':\n            raise ValueError('Cannot circularize - termini disconnected.')\n\n        copy = self.copy()\n        copy.circular = True\n        copy.top.circular = True\n        copy.bottom.circular = True\n        return copy", "response": "Circularize linear DNA.\n\n        :returns: A circularized version of the current sequence.\n        :rtype: coral.DNA"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisplaying a visualization of the sequence in an IPython notebook.", "response": "def display(self):\n        '''Display a visualization of the sequence in an IPython notebook.'''\n        try:\n            from IPython.display import HTML\n            import uuid\n        except ImportError:\n            raise IPythonDisplayImportError\n\n        sequence_json = self.json()\n\n        d3cdn = '//d3js.org/d3.v3.min.js'\n        div_id = 'sequence_{}'.format(uuid.uuid1())\n\n        cur_dir = os.path.abspath(os.path.dirname(__file__))\n        d3_plasmid_path = os.path.join(cur_dir, 'd3-plasmid.js')\n        with open(d3_plasmid_path) as f:\n            d3_plasmid_js = f.read()\n\n        html = '<div id={div_id}></div>'.format(div_id=div_id)\n        js_databind = '''\n        <script>\n        require([\\'{d3_cdn}\\'], function(lib) {{\n            window.data = {data};'''.format(div_id=div_id, d3_cdn=d3cdn,\n                                            data=sequence_json)\n\n        js_viz = '''\n            d3sequence(window.data, \\'{div_id}\\')\n        }});\n        </script>\n        '''.format(div_id=div_id)\n\n        return HTML(html + js_databind + d3_plasmid_js + js_viz)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef excise(self, feature):\n        '''Removes feature from circular plasmid and linearizes. Automatically\n        reorients at the base just after the feature. This operation is\n        complementary to the .extract() method.\n\n        :param feature_name: The feature to remove.\n        :type feature_name: coral.Feature\n\n        '''\n        rotated = self.rotate_to_feature(feature)\n        excised = rotated[feature.stop - feature.start:]\n\n        return excised", "response": "Removes feature from circular plasmid and linearizes. Automatically\n        reorients at the base just after the feature."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extract(self, feature, remove_subfeatures=False):\n        '''Extract a feature from the sequence. This operation is complementary\n        to the .excise() method.\n\n        :param feature: Feature object.\n        :type feature: coral.sequence.Feature\n        :param remove_subfeatures: Remove all features in the extracted\n                                   sequence aside from the input feature.\n        :type remove_subfeatures: bool\n        :returns: A subsequence from start to stop of the feature.\n\n        '''\n        extracted = self[feature.start:feature.stop]\n        # Turn gaps into Ns or Xs\n        for gap in feature.gaps:\n            for i in range(*gap):\n                extracted[i] = self._any_char\n        if remove_subfeatures:\n            # Keep only the feature specified\n            extracted.features = [feature]\n        # Update feature locations\n        # copy them\n        for feature in extracted.features:\n            feature.move(-feature.start)\n        return extracted", "response": "Extract a feature from the sequence. This method is complementary to the. excise method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nflipping the top and bottom strands of the DNA.", "response": "def flip(self):\n        '''Flip the DNA - swap the top and bottom strands.\n\n        :returns: Flipped DNA (bottom strand is now top strand, etc.).\n        :rtype: coral.DNA\n\n        '''\n        copy = self.copy()\n        copy.top, copy.bottom = copy.bottom, copy.top\n        copy.features = [_flip_feature(f, len(self)) for f in copy.features]\n        return copy"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef locate(self, pattern):\n        '''Find sequences matching a pattern. For a circular sequence, the\n        search extends over the origin.\n\n        :param pattern: str or NucleicAcidSequence for which to find matches.\n        :type pattern: str or coral.DNA\n        :returns: A list of top and bottom strand indices of matches.\n        :rtype: list of lists of indices (ints)\n        :raises: ValueError if the pattern is longer than either the input\n                 sequence (for linear DNA) or twice as long as the input\n                 sequence (for circular DNA).\n\n        '''\n        top_matches = self.top.locate(pattern)\n        bottom_matches = self.bottom.locate(pattern)\n\n        return [top_matches, bottom_matches]", "response": "Find sequences matching a pattern. For a linear sequence the\n        search extends over the origin. For a circular sequence the\n        search extends over the origin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrotate the current sequence by n bases.", "response": "def rotate(self, n):\n        '''Rotate Sequence by n bases.\n\n        :param n: Number of bases to rotate.\n        :type n: int\n        :returns: The current sequence reoriented at `index`.\n        :rtype: coral.DNA\n        :raises: ValueError if applied to linear sequence or `index` is\n                 negative.\n\n        '''\n        if not self.circular and n != 0:\n            raise ValueError('Cannot rotate linear DNA')\n        else:\n            copy = self.copy()\n            copy.top = self.top.rotate(n)\n            copy.bottom = self.bottom.rotate(-n)\n            copy.features = []\n            for feature in self.features:\n                feature_copy = feature.copy()\n                feature_copy.move(n)\n                # Adjust the start/stop if we move over the origin\n                feature_copy.start = feature_copy.start % len(self)\n                feature_copy.stop = feature_copy.stop % len(self)\n                copy.features.append(feature_copy)\n\n            return copy.circularize()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreverses complement the current sequence.", "response": "def reverse_complement(self):\n        '''Reverse complement the DNA.\n\n        :returns: A reverse-complemented instance of the current sequence.\n        :rtype: coral.DNA\n\n        '''\n        copy = self.copy()\n        # Note: if sequence is double-stranded, swapping strand is basically\n        # (but not entirely) the same thing - gaps affect accuracy.\n        copy.top = self.top.reverse_complement()\n        copy.bottom = self.bottom.reverse_complement()\n\n        # Remove all features - the reverse complement isn't flip!\n        copy.features = []\n\n        return copy"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select_features(self, term, by='name', fuzzy=False):\n        '''Select features from the features list based on feature name,\n           gene, or locus tag.\n           :param term: Search term.\n           :type term: str\n           :param by: Feature attribute to search by. Options are 'name',\n           'gene', and 'locus_tag'.\n           :type by: str\n           :param fuzzy: If True, search becomes case-insensitive and will also\n           find substrings - e.g. if fuzzy search is enabled, a search for\n           'gfp' would return a hit for a feature named 'GFP_seq'.\n           :type fuzzy: bool\n           :returns: A list of features matched by the search.\n           :rtype: list\n\n        '''\n        features = []\n        if fuzzy:\n            fuzzy_term = term.lower()\n            for feature in self.features:\n                if fuzzy_term in feature.__getattribute__(by).lower():\n                    features.append(feature)\n        else:\n            for feature in self.features:\n                if feature.__getattribute__(by) == term:\n                    features.append(feature)\n\n        return features", "response": "Select features from the features list based on a search term."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new feature from the current object.", "response": "def to_feature(self, name=None, feature_type='misc_feature'):\n        '''Create a feature from the current object.\n\n        :param name: Name for the new feature. Must be specified if the DNA\n                     instance has no .name attribute.\n        :type name: str\n        :param feature_type: The type of feature (genbank standard).\n        :type feature_type: str\n\n        '''\n        if name is None:\n            if not self.name:\n                raise ValueError('name attribute missing from DNA instance'\n                                 ' and arguments')\n            name = self.name\n        return Feature(name, start=0, stop=len(self),\n                       feature_type=feature_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreport whether the enzyme cuts outside its recognition site.", "response": "def cuts_outside(self):\n        '''Report whether the enzyme cuts outside its recognition site.\n        Cutting at the very end of the site returns True.\n\n        :returns: Whether the enzyme will cut outside its recognition site.\n        :rtype: bool\n\n        '''\n        for index in self.cut_site:\n            if index < 0 or index > len(self.recognition_site) + 1:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self):\n        '''Generate a Primer copy.\n\n        :returns: A safely-editable copy of the current primer.\n        :rtype: coral.DNA\n\n        '''\n        return type(self)(self.anneal, self.tm, overhang=self.overhang,\n                          name=self.name, note=self.note)", "response": "Generate a safely - editable copy of the current primer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates nearest - neighbor melting temperature in \u00b0C.", "response": "def tm(seq, dna_conc=50, salt_conc=50, parameters='cloning'):\n    '''Calculate nearest-neighbor melting temperature (Tm).\n\n    :param seq: Sequence for which to calculate the tm.\n    :type seq: coral.DNA\n    :param dna_conc: DNA concentration in nM.\n    :type dna_conc: float\n    :param salt_conc: Salt concentration in mM.\n    :type salt_conc: float\n    :param parameters: Nearest-neighbor parameter set. Available options:\n                       'breslauer': Breslauer86 parameters\n                       'sugimoto': Sugimoto96 parameters\n                       'santalucia96': SantaLucia96 parameters\n                       'santalucia98': SantaLucia98 parameters\n                       'cloning': breslauer without corrections\n                       'cloning_sl98': santalucia98 fit to 'cloning'\n    :type parameters: str\n    :returns: Melting temperature (Tm) in \u00b0C.\n    :rtype: float\n    :raises: ValueError if parameter argument is invalid.\n\n    '''\n    if parameters == 'breslauer':\n        params = tm_params.BRESLAUER\n    elif parameters == 'sugimoto':\n        params = tm_params.SUGIMOTO\n    elif parameters == 'santalucia96':\n        params = tm_params.SANTALUCIA96\n    elif parameters == 'santalucia98' or parameters == 'cloning_sl98':\n        params = tm_params.SANTALUCIA98\n    elif parameters == 'cloning':\n        params = tm_params.CLONING\n    else:\n        raise ValueError('Unsupported parameter set.')\n\n    # Thermodynamic parameters\n    pars = {'delta_h': params['delta_h'], 'delta_s': params['delta_s']}\n    pars_error = {'delta_h': params['delta_h_err'],\n                  'delta_s': params['delta_s_err']}\n\n    # Error corrections - done first for use of reverse_complement parameters\n    if parameters == 'breslauer':\n        deltas = breslauer_corrections(seq, pars_error)\n    elif parameters == 'sugimoto':\n        deltas = breslauer_corrections(seq, pars_error)\n    elif parameters == 'santalucia96':\n        deltas = breslauer_corrections(seq, pars_error)\n    elif parameters == 'santalucia98' or parameters == 'cloning_sl98':\n        deltas = santalucia98_corrections(seq, pars_error)\n    elif parameters == 'cloning':\n        deltas = breslauer_corrections(seq, pars_error)\n        deltas[0] += 3.4\n        deltas[1] += 12.4\n\n    # Sum up the nearest-neighbor enthalpy and entropy\n    seq = str(seq).upper()\n\n    # TODO: catch more cases when alphabets expand\n    if 'N' in seq:\n        raise ValueError('Can\\'t calculate Tm of an N base.')\n    new_delt = _pair_deltas(seq, pars)\n    deltas[0] += new_delt[0]\n    deltas[1] += new_delt[1]\n\n    # Unit corrections\n    salt_conc /= 1e3\n    dna_conc /= 1e9\n    deltas[0] *= 1e3\n\n    # Universal gas constant (R)\n    R = 1.9872\n\n    # Supposedly this is what dnamate does, but the output doesn't match theirs\n#    melt = (-deltas[0] / (-deltas[1] + R * log(dna_conc / 4.0))) +\n#                          16.6 * log(salt_conc) - 273.15\n#    return melt\n    # Overall equation is supposedly:\n    # sum{dH}/(sum{dS} + R ln(dna_conc/b)) - 273.15\n    # with salt corrections for the whole term (or for santalucia98,\n    # salt corrections added to the dS term.\n    # So far, implementing this as described does not give results that match\n    # any calculator but Biopython's\n\n    if parameters == 'breslauer' or parameters == 'cloning':\n        numerator = -deltas[0]\n        # Modified dna_conc denominator\n        denominator = (-deltas[1]) + R * log(dna_conc / 16.0)\n        # Modified Schildkraut-Lifson equation adjustment\n        salt_adjustment = 16.6 * log(salt_conc) / log(10.0)\n        melt = numerator / denominator + salt_adjustment - 273.15\n    elif parameters == 'santalucia98' or 'cloning_sl98':\n        # TODO: dna_conc should be divided by 2.0 when dna_conc >> template\n        # (like PCR)\n        numerator = -deltas[0]\n        # SantaLucia 98 salt correction\n        salt_adjustment = 0.368 * (len(seq) - 1) * log(salt_conc)\n        denominator = -deltas[1] + salt_adjustment + R * log(dna_conc / 4.0)\n        melt = -deltas[0] / denominator - 273.15\n    elif parameters == 'santalucia96':\n        # TODO: find a way to test whether the code below matches another\n        # algorithm. It appears to be correct, but need to test it.\n        numerator = -deltas[0]\n        denominator = -deltas[1] + R * log(dna_conc / 4.0)\n        # SantaLucia 96 salt correction\n        salt_adjustment = 12.5 * log10(salt_conc)\n        melt = numerator / denominator + salt_adjustment - 273.15\n    elif parameters == 'sugimoto':\n        # TODO: the stuff below is untested and probably wrong\n        numerator = -deltas[0]\n        denominator = -deltas[1] + R * log(dna_conc / 4.0)\n        # Sugimoto parameters were fit holding salt concentration constant\n        # Salt correction can be chosen / ignored? Remove sugimoto set since\n        # it's so similar to santalucia98?\n        salt_correction = 16.6 * log10(salt_conc)\n        melt = numerator / denominator + salt_correction - 273.15\n\n    if parameters == 'cloning_sl98':\n        # Corrections to make santalucia98 method approximate cloning method.\n        # May be even better for cloning with Phusion than 'cloning' method\n        melt *= 1.27329212575\n        melt += -2.55585450119\n\n    return melt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pair_deltas(seq, pars):\n    '''Add up nearest-neighbor parameters for a given sequence.\n\n    :param seq: DNA sequence for which to sum nearest neighbors\n    :type seq: str\n    :param pars: parameter set to use\n    :type pars: dict\n    :returns: nearest-neighbor delta_H and delta_S sums.\n    :rtype: tuple of floats\n\n    '''\n    delta0 = 0\n    delta1 = 0\n    for i in range(len(seq) - 1):\n        curchar = seq[i:i + 2]\n        delta0 += pars['delta_h'][curchar]\n        delta1 += pars['delta_s'][curchar]\n    return delta0, delta1", "response": "Add up nearest - neighbor parameters for a given DNA sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsum corrections for Breslauer 84 method.", "response": "def breslauer_corrections(seq, pars_error):\n    '''Sum corrections for Breslauer '84 method.\n\n    :param seq: sequence for which to calculate corrections.\n    :type seq: str\n    :param pars_error: dictionary of error corrections\n    :type pars_error: dict\n    :returns: Corrected delta_H and delta_S parameters\n    :rtype: list of floats\n\n    '''\n    deltas_corr = [0, 0]\n    contains_gc = 'G' in str(seq) or 'C' in str(seq)\n    only_at = str(seq).count('A') + str(seq).count('T') == len(seq)\n    symmetric = seq == seq.reverse_complement()\n    terminal_t = str(seq)[0] == 'T' + str(seq)[-1] == 'T'\n\n    for i, delta in enumerate(['delta_h', 'delta_s']):\n        if contains_gc:\n            deltas_corr[i] += pars_error[delta]['anyGC']\n        if only_at:\n            deltas_corr[i] += pars_error[delta]['onlyAT']\n        if symmetric:\n            deltas_corr[i] += pars_error[delta]['symmetry']\n        if terminal_t and delta == 'delta_h':\n            deltas_corr[i] += pars_error[delta]['terminalT'] * terminal_t\n    return deltas_corr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsumming corrections for Santa Lucia 9 method.", "response": "def santalucia98_corrections(seq, pars_error):\n    '''Sum corrections for SantaLucia '98 method (unified parameters).\n\n    :param seq: sequence for which to calculate corrections.\n    :type seq: str\n    :param pars_error: dictionary of error corrections\n    :type pars_error: dict\n    :returns: Corrected delta_H and delta_S parameters\n    :rtype: list of floats\n\n    '''\n    deltas_corr = [0, 0]\n    first = str(seq)[0]\n    last = str(seq)[-1]\n\n    start_gc = first == 'G' or first == 'C'\n    start_at = first == 'A' or first == 'T'\n    end_gc = last == 'G' or last == 'C'\n    end_at = last == 'A' or last == 'T'\n    init_gc = start_gc + end_gc\n    init_at = start_at + end_at\n\n    symmetric = seq == seq.reverse_complement()\n\n    for i, delta in enumerate(['delta_h', 'delta_s']):\n        deltas_corr[i] += init_gc * pars_error[delta]['initGC']\n        deltas_corr[i] += init_at * pars_error[delta]['initAT']\n        if symmetric:\n            deltas_corr[i] += pars_error[delta]['symmetry']\n    return deltas_corr"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef repeats(seq, size):\n    '''Count times that a sequence of a certain size is repeated.\n\n    :param seq: Input sequence.\n    :type seq: coral.DNA or coral.RNA\n    :param size: Size of the repeat to count.\n    :type size: int\n    :returns: Occurrences of repeats and how many\n    :rtype: tuple of the matched sequence and how many times it occurs\n\n    '''\n    seq = str(seq)\n    n_mers = [seq[i:i + size] for i in range(len(seq) - size + 1)]\n    counted = Counter(n_mers)\n    # No one cares about patterns that appear once, so exclude them\n    found_repeats = [(key, value) for key, value in counted.iteritems() if\n                     value > 1]\n    return found_repeats", "response": "Count times that a sequence of a certain size is repeated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsimulating a Gibson reaction.", "response": "def gibson(seq_list, linear=False, homology=10, tm=63.0):\n    '''Simulate a Gibson reaction.\n\n    :param seq_list: list of DNA sequences to Gibson\n    :type seq_list: list of coral.DNA\n    :param linear: Attempt to produce linear, rather than circular,\n                   fragment from input fragments.\n    :type linear: bool\n    :param homology_min: minimum bp of homology allowed\n    :type homology_min: int\n    :param tm: Minimum tm of overlaps\n    :type tm: float\n    :returns: coral.reaction.Gibson instance.\n    :raises: ValueError if any input sequences are circular DNA.\n\n    '''\n    # FIXME: Preserve features in overlap\n    # TODO: set a max length?\n    # TODO: add 'expected' keyword argument somewhere to automate\n    # validation\n\n    # Remove any redundant (identical) sequences\n    seq_list = list(set(seq_list))\n    for seq in seq_list:\n        if seq.circular:\n            raise ValueError('Input sequences must be linear.')\n\n    # Copy input list\n    working_list = [s.copy() for s in seq_list]\n\n    # Attempt to fuse fragments together until only one is left\n    while len(working_list) > 1:\n        working_list = _find_fuse_next(working_list, homology, tm)\n    if not linear:\n        # Fuse the final fragment to itself\n        working_list = _fuse_last(working_list, homology, tm)\n\n    # Clear features\n    working_list[0].features = []\n    return _annotate_features(working_list[0], seq_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _find_fuse_next(working_list, homology, tm):\n    '''Find the next sequence to fuse, and fuse it (or raise exception).\n\n    :param homology: length of terminal homology in bp\n    :type homology: int\n    :raises: AmbiguousGibsonError if there is more than one way for the\n             fragment ends to combine.\n             GibsonOverlapError if no homology match can be found.\n\n    '''\n    # 1. Take the first sequence and find all matches\n    # Get graphs:\n    #   a) pattern watson : targets watson\n    #   b) pattern watson : targets crick\n    #   c) pattern crick: targets watson\n    #   d) pattern crick: targets crick\n    pattern = working_list[0]\n    targets = working_list[1:]\n\n    # Output graph nodes of terminal binders:\n    #   (destination, size, strand1, strand2)\n    def graph_strands(strand1, strand2):\n        graph = []\n        for i, target in enumerate(targets):\n            matchlen = homology_report(pattern, target, strand1, strand2,\n                                       cutoff=homology, min_tm=tm)\n            if matchlen:\n                graph.append((i, matchlen, strand1, strand2))\n        return graph\n\n    graph_ww = graph_strands('w', 'w')\n    graph_wc = graph_strands('w', 'c')\n    graph_cw = graph_strands('c', 'w')\n    graph_cc = graph_strands('c', 'c')\n    graphs_w = graph_ww + graph_wc\n    graphs_c = graph_cw + graph_cc\n    graphs = graphs_w + graphs_c\n\n    # 2. See if there's more than one result on a strand.\n    # If so, throw an exception.\n    if len(graphs_w) > 1 or len(graphs_c) > 1:\n        raise AmbiguousGibsonError('multiple compatible ends.')\n    if len(graphs_w) == len(graphs_c) == 0:\n        raise GibsonOverlapError('Failed to find compatible Gibson ends.')\n\n    # 3. There must be one result. Where is it?\n    # If there's one result on each strand, go with the one that matches the\n    # pattern watson strand (will occur first - index 0)\n    match = graphs[0]\n\n    # 4. Combine pieces together\n    # 4a. Orient pattern sequence\n    if match[2] == 'c':\n        left_side = pattern.reverse_complement()\n    else:\n        left_side = pattern\n    # 4b. Orient target sequence\n    if match[3] == 'w':\n        right_side = working_list.pop(match[0] + 1).reverse_complement()\n    else:\n        right_side = working_list.pop(match[0] + 1)\n\n    working_list[0] = left_side + right_side[match[1]:]\n    return working_list", "response": "Find the next sequence to fuse and fuse it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfuses the last termini in a list of working_list.", "response": "def _fuse_last(working_list, homology, tm):\n    '''With one sequence left, attempt to fuse it to itself.\n\n    :param homology: length of terminal homology in bp.\n    :type homology: int\n    :raises: AmbiguousGibsonError if either of the termini are palindromic\n             (would bind self-self).\n             ValueError if the ends are not compatible.\n\n    '''\n    # 1. Construct graph on self-self\n    #    (destination, size, strand1, strand2)\n    pattern = working_list[0]\n\n    def graph_strands(strand1, strand2):\n        matchlen = homology_report(pattern, pattern, strand1, strand2,\n                                   cutoff=homology, min_tm=tm, top_two=True)\n        if matchlen:\n            # Ignore full-sequence matches\n            # HACK: modified homology_report to accept top_two. It should\n            # really just ignore full-length matches\n            for length in matchlen:\n                if length != len(pattern):\n                    return (0, length, strand1, strand2)\n        else:\n            return []\n\n    # cw is redundant with wc\n    graph_ww = graph_strands('w', 'w')\n    graph_wc = graph_strands('w', 'c')\n    graph_cc = graph_strands('c', 'c')\n    if graph_ww + graph_cc:\n        raise AmbiguousGibsonError('Self-self binding during circularization.')\n    if not graph_wc:\n        raise ValueError('Failed to find compatible ends for circularization.')\n\n    working_list[0] = working_list[0][:-graph_wc[1]].circularize()\n\n    return working_list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef homology_report(seq1, seq2, strand1, strand2, cutoff=0, min_tm=63.0,\n                    top_two=False, max_size=500):\n    '''Given two sequences (seq1 and seq2), report the size of all perfect\n    matches between the 3' end of the top strand of seq1 and the 3' end of\n    either strand of seq2. In short, in a Gibson reaction, what would bind the\n    desired part of seq1, given a seq2?\n\n    :param seq1: Sequence for which to test 3\\' binding of a single strand to\n                 seq2.\n    :type seq1: coral.DNA\n    :param seq2: Sequence for which to test 3\\' binding of each strand to seq1.\n    :type seq1: coral.DNA\n    :param strand1: w (watson) or c (crick) - which strand of seq1 is being\n                        tested.\n    :type strand1ed: str\n    :param strand2: w (watson) or c (crick) - which strand of seq2 is being\n                        tested.\n    :type strand2ed: str\n    :param cutoff: size cutoff for the report - if a match is lower, it's\n                   ignored\n    :type cutoff: int\n    :param min_tm: Minimum tm value cutoff - matches below are ignored.\n    :type min_tm: float\n    :param top_two: Return the best two matches\n    :type top_two: bool\n    :param max_size: Maximum overlap size (increases speed)\n    :type max_size: int\n    :returns: List of left and right identities.\n    :rtype: list of ints\n\n    '''\n    # Ensure that strand 1 is Watson and strand 2 is Crick\n    if strand1 == 'c':\n        seq1 = seq1.reverse_complement()\n    if strand2 == 'w':\n        seq2 = seq2.reverse_complement()\n    # Generate all same-length 5' ends of seq1 and 3' ends of seq2 within\n    # maximum homology length\n    # TODO: If strings aren't used here, gen_chunks takes forever. Suggests a\n    # need to optimize coral.DNA subsetting\n    seq1_str = str(seq1)\n    seq2_str = str(seq2)\n\n    def gen_chunks(s1, s2):\n        chunks1 = [seq1_str[-(i + 1):] for i in range(min(len(seq1_str),\n                                                          max_size))]\n        chunks2 = [seq2_str[:(i + 1)] for i in range(min(len(seq2_str),\n                                                         max_size))]\n        return chunks1, chunks2\n\n    seq1_chunks, seq2_chunks = gen_chunks(seq1_str, seq2_str)\n\n    # Check for exact matches from terminal end to terminal end\n    target_matches = []\n    for i, (s1, s2) in enumerate(zip(seq1_chunks, seq2_chunks)):\n        s1len = len(s1)\n        # Inefficient! (reverse complementing a bunch of times)\n        # Don't calculate tm once base tm has been reached.\n        # TODO: Go through logic here again and make sure the order of checking\n        # makes sense\n        if s1 == s2:\n            logger.debug('Found Match: {}'.format(str(s1)))\n            if s1len >= cutoff:\n                tm = coral.analysis.tm(seq1[-(i + 1):])\n                logger.debug('Match tm: {} C'.format(tm))\n                if tm >= min_tm:\n                    target_matches.append(s1len)\n                elif tm >= min_tm - 4:\n                    msg = 'One overlap had a Tm of {} C.'.format(tm)\n                    warnings.warn(msg)\n                    target_matches.append(s1len)\n\n    target_matches.sort()\n    if not top_two:\n        return 0 if not target_matches else target_matches[0]\n    else:\n        return 0 if not target_matches else target_matches[0:2]", "response": "Report the size of all perfect\n    matches between the 3 end of the top strand of seq1 and seq2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a sequence from Yeast genome. org.", "response": "def fetch_yeast_locus_sequence(locus_name, flanking_size=0):\n    '''Acquire a sequence from SGD http://www.yeastgenome.org.\n\n    :param locus_name: Common name or systematic name for the locus (e.g. ACT1\n                       or YFL039C).\n    :type locus_name: str\n    :param flanking_size: The length of flanking DNA (on each side) to return\n    :type flanking_size: int\n\n    '''\n    from intermine.webservice import Service\n\n    service = Service('http://yeastmine.yeastgenome.org/yeastmine/service')\n\n    # Get a new query on the class (table) you will be querying:\n    query = service.new_query('Gene')\n\n    if flanking_size > 0:\n\n        # The view specifies the output columns\n        # secondaryIdentifier: the systematic name (e.g. YFL039C)\n        # symbol: short name (e.g. ACT1)\n        # length: sequence length\n        # flankingRegions.direction: Upstream or downstream (or both) of locus\n        # flankingRegions.sequence.length: length of the flanking regions\n        # flankingRegions.sequence.residues: sequence of the flanking regions\n        query.add_view('secondaryIdentifier', 'symbol', 'length',\n                       'flankingRegions.direction',\n                       'flankingRegions.sequence.length',\n                       'flankingRegions.sequence.residues')\n\n        # You can edit the constraint values below\n        query.add_constraint('flankingRegions.direction', '=', 'both',\n                             code='A')\n        query.add_constraint('Gene', 'LOOKUP', locus_name, 'S. cerevisiae',\n                             code='B')\n        query.add_constraint('flankingRegions.distance', '=',\n                             '{:.1f}kb'.format(flanking_size / 1000.),\n                             code='C')\n        # Uncomment and edit the code below to specify your own custom logic:\n        query.set_logic('A and B and C')\n\n        # TODO: What to do when there's more than one result?\n        first_result = query.rows().next()\n        # FIXME: Use logger module instead\n        # print first_result['secondaryIdentifier']\n        # print first_result['symbol'], row['length']\n        # print first_result['flankingRegions.direction']\n        # print first_result['flankingRegions.sequence.length']\n        # print first_result['flankingRegions.sequence.residues']\n\n        seq = coral.DNA(first_result['flankingRegions.sequence.residues'])\n        # TODO: add more metadata\n\n    elif flanking_size == 0:\n        # The view specifies the output columns\n        query.add_view('primaryIdentifier', 'secondaryIdentifier', 'symbol',\n                       'name', 'sgdAlias', 'organism.shortName',\n                       'sequence.length', 'sequence.residues', 'description',\n                       'qualifier')\n\n        query.add_constraint('status', 'IS NULL', code='D')\n        query.add_constraint('status', '=', 'Active', code='C')\n        query.add_constraint('qualifier', 'IS NULL', code='B')\n        query.add_constraint('qualifier', '!=', 'Dubious', code='A')\n        query.add_constraint('Gene', 'LOOKUP', locus_name, 'S. cerevisiae',\n                             code='E')\n\n        # Your custom constraint logic is specified with the code below:\n        query.set_logic('(A or B) and (C or D) and E')\n\n        first_result = query.rows().next()\n        seq = coral.DNA(first_result['sequence.residues'])\n    else:\n        print 'Problem with the flanking region size....'\n        seq = coral.DNA('')\n\n    return seq"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_yeast_sequence(chromosome, start, end, reverse_complement=False):\n    '''Acquire a sequence from SGD http://www.yeastgenome.org\n    :param chromosome: Yeast chromosome.\n    :type chromosome: int\n    :param start: A biostart.\n    :type start: int\n    :param end: A bioend.\n    :type end: int\n    :param reverse_complement: Get the reverse complement.\n    :type revervse_complement: bool\n    :returns: A DNA sequence.\n    :rtype: coral.DNA\n\n    '''\n    import requests\n\n    if start != end:\n        if reverse_complement:\n            rev_option = '-REV'\n        else:\n            rev_option = ''\n        param_url = '&chr=' + str(chromosome) + '&beg=' + str(start) + \\\n                    '&end=' + str(end) + '&rev=' + rev_option\n        url = 'http://www.yeastgenome.org/cgi-bin/getSeq?map=a2map' + \\\n            param_url\n\n        res = requests.get(url)\n        # ok... sadely, I contacted SGD and they haven;t implemented this so\n        # I have to parse their yeastgenome page, but\n        # it is easy between the raw sequence is between <pre> tags!\n\n        # warning that's for the first < so we need +5!\n        begin_index = res.text.index('<pre>')\n\n        end_index = res.text.index('</pre>')\n        sequence = res.text[begin_index + 5:end_index]\n        sequence = sequence.replace('\\n', '').replace('\\r', '')\n    else:\n        sequence = ''\n\n    return coral.DNA(sequence)", "response": "Acquire a sequence from Yeast genome."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nacquiring the location of a gene from Yeast genome. org.", "response": "def get_yeast_gene_location(gene_name):\n    '''Acquire the location of a gene from SGD http://www.yeastgenome.org\n    :param gene_name: Name of the gene.\n    :type gene_name: string\n    :returns location: [int: chromosome, int:biostart, int:bioend, int:strand]\n    :rtype location: list\n\n    '''\n    from intermine.webservice import Service\n    service = Service('http://yeastmine.yeastgenome.org/yeastmine/service')\n\n    # Get a new query on the class (table) you will be querying:\n    query = service.new_query('Gene')\n\n    # The view specifies the output columns\n    query.add_view('primaryIdentifier', 'secondaryIdentifier', 'symbol',\n                   'name', 'organism.shortName',\n                   'chromosome.primaryIdentifier',\n                   'chromosomeLocation.start', 'chromosomeLocation.end',\n                   'chromosomeLocation.strand')\n\n    # Uncomment and edit the line below (the default) to select a custom sort\n    # order:\n    # query.add_sort_order('Gene.primaryIdentifier', 'ASC')\n\n    # You can edit the constraint values below\n    query.add_constraint('organism.shortName', '=', 'S. cerevisiae',\n                         code='B')\n    query.add_constraint('Gene', 'LOOKUP', gene_name, code='A')\n\n    # Uncomment and edit the code below to specify your own custom logic:\n    # query.set_logic('A and B')\n    chromosomes = {'chrI': 1,\n                   'chrII': 2,\n                   'chrIII': 3,\n                   'chrIV': 4,\n                   'chrV': 5,\n                   'chrVI': 6,\n                   'chrVII': 7,\n                   'chrVIII': 8,\n                   'chrIX': 9,\n                   'chrX': 10,\n                   'chrXI': 11,\n                   'chrXII': 12,\n                   'chrXIII': 13,\n                   'chrXIV': 14,\n                   'chrXV': 15,\n                   'chrXVI': 16}\n    first_result = query.rows().next()\n\n    return [chromosomes[first_result['chromosome.primaryIdentifier']],\n            first_result['chromosomeLocation.start'],\n            first_result['chromosomeLocation.end'],\n            int(first_result['chromosomeLocation.strand'])]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve systematic yeast gene id from the common name.", "response": "def get_gene_id(gene_name):\n    '''Retrieve systematic yeast gene name from the common name.\n\n    :param gene_name: Common name for yeast gene (e.g. ADE2).\n    :type gene_name: str\n    :returns: Systematic name for yeast gene (e.g. YOR128C).\n    :rtype: str\n\n    '''\n    from intermine.webservice import Service\n\n    service = Service('http://yeastmine.yeastgenome.org/yeastmine/service')\n\n    # Get a new query on the class (table) you will be querying:\n    query = service.new_query('Gene')\n\n    # The view specifies the output columns\n    query.add_view('primaryIdentifier', 'secondaryIdentifier', 'symbol',\n                   'name', 'sgdAlias', 'crossReferences.identifier',\n                   'crossReferences.source.name')\n\n    # Uncomment and edit the line below (the default) to select a custom sort\n    # order:\n    # query.add_sort_order('Gene.primaryIdentifier', 'ASC')\n\n    # You can edit the constraint values below\n    query.add_constraint('organism.shortName', '=', 'S. cerevisiae', code='B')\n    query.add_constraint('Gene', 'LOOKUP', gene_name, code='A')\n\n    # Uncomment and edit the code below to specify your own custom logic:\n    # query.set_logic('A and B')\n\n    for row in query.rows():\n        gid = row['secondaryIdentifier']\n    return gid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_yeast_promoter_ypa(gene_name):\n    '''Retrieve promoter from Yeast Promoter Atlas\n    (http://ypa.csbb.ntu.edu.tw).\n\n    :param gene_name: Common name for yeast gene.\n    :type gene_name: str\n    :returns: Double-stranded DNA sequence of the promoter.\n    :rtype: coral.DNA\n\n    '''\n    import requests\n\n    loc = get_yeast_gene_location(gene_name)\n    gid = get_gene_id(gene_name)\n    ypa_baseurl = 'http://ypa.csbb.ntu.edu.tw/do'\n    params = {'act': 'download',\n              'nucle': 'InVitro',\n              'right': str(loc[2]),\n              'left': str(loc[1]),\n              'gene': str(gid),\n              'chr': str(loc[0])}\n\n    response = requests.get(ypa_baseurl, params=params)\n    text = response.text\n    # FASTA records are just name-sequence pairs split up by > e.g.\n    # >my_dna_name\n    # GACGATA\n    # TODO: most of this is redundant, as we just want the 2nd record\n    record_split = text.split('>')\n    record_split.pop(0)\n    parsed = []\n    for record in record_split:\n        parts = record.split('\\n')\n        sequence = coral.DNA(''.join(parts[1:]))\n        sequence.name = parts[0]\n        parsed.append(sequence)\n\n    return parsed[1]", "response": "Retrieve promoter from Yeast Promoter Atlas\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngrowing equidistant overlaps until they meet specified constraints.", "response": "def _grow_overlaps(dna, melting_temp, require_even, length_max, overlap_min,\n                   min_exception):\n    '''Grows equidistant overlaps until they meet specified constraints.\n\n    :param dna: Input sequence.\n    :type dna: coral.DNA\n    :param melting_temp: Ideal Tm of the overlaps, in degrees C.\n    :type melting_temp: float\n    :param require_even: Require that the number of oligonucleotides is even.\n    :type require_even: bool\n    :param length_max: Maximum oligo size (e.g. 60bp price point cutoff)\n                       range.\n    :type length_range: int\n    :param overlap_min: Minimum overlap size.\n    :type overlap_min: int\n    :param min_exception: In order to meet melting_temp and overlap_min\n                          settings, allow overlaps less than overlap_min to\n                          continue growing above melting_temp.\n    :type min_exception: bool\n    :returns: Oligos, their overlapping regions, overlap Tms, and overlap\n              indices.\n    :rtype: tuple\n\n    '''\n    # TODO: prevent growing overlaps from bumping into each other -\n    # should halt when it happens, give warning, let user decide if they still\n    # want the current construct\n    # Another option would be to start over, moving the starting positions\n    # near the problem region a little farther from each other - this would\n    # put the AT-rich region in the middle of the spanning oligo\n\n    # Try bare minimum number of oligos\n    oligo_n = len(dna) // length_max + 1\n\n    # Adjust number of oligos if even number required\n    if require_even:\n        oligo_increment = 2\n        if oligo_n % 2 == 1:\n            oligo_n += 1\n    else:\n        oligo_increment = 1\n\n    # Increase oligo number until the minimum oligo_len is less than length_max\n    while float(len(dna)) / oligo_n > length_max:\n        oligo_n += oligo_increment\n\n    # Loop until all overlaps meet minimum Tm and length\n    tm_met = False\n    len_met = False\n\n    while(not tm_met or not len_met):\n        # Calculate initial number of overlaps\n        overlap_n = oligo_n - 1\n\n        # Place overlaps approximately equidistant over sequence length\n        overlap_interval = float(len(dna)) / oligo_n\n        starts = [int(overlap_interval * (i + 1)) for i in range(overlap_n)]\n        ends = [index + 1 for index in starts]\n\n        # Fencepost for while loop\n        # Initial overlaps (1 base) and their tms\n        overlaps = [dna[start:end] for start, end in zip(starts, ends)]\n        overlap_tms = [coral.analysis.tm(overlap) for overlap in overlaps]\n        index = overlap_tms.index(min(overlap_tms))\n        # Initial oligos - includes the 1 base overlaps.\n        # All the oligos are in the same direction - reverse\n        # complementation of every other one happens later\n        oligo_starts = [0] + starts\n        oligo_ends = ends + [len(dna)]\n        oligo_indices = [oligo_starts, oligo_ends]\n\n        oligos = [dna[start:end] for start, end in zip(*oligo_indices)]\n\n        # Oligo won't be maxed in first pass. tm_met and len_met will be false\n        maxed = False\n\n        while not (tm_met and len_met) and not maxed:\n            # Recalculate overlaps and their Tms\n            overlaps = _recalculate_overlaps(dna, overlaps, oligo_indices)\n            # Tm calculation is bottleneck - only recalculate changed overlap\n            overlap_tms[index] = coral.analysis.tm(overlaps[index])\n            # Find lowest-Tm overlap and its index.\n            index = overlap_tms.index(min(overlap_tms))\n            # Move overlap at that index\n            oligos = _expand_overlap(dna, oligo_indices, index, oligos,\n                                     length_max)\n            # Regenerate conditions\n            maxed = any([len(x) == length_max for x in oligos])\n            tm_met = all([x >= melting_temp for x in overlap_tms])\n            if min_exception:\n                len_met = True\n            else:\n                len_met = all([len(x) >= overlap_min for x in overlaps])\n\n        # TODO: add test for min_exception case (use rob's sequence from\n        # 20130624 with 65C Tm)\n        if min_exception:\n            len_met = all([len(x) >= overlap_min for x in overlaps])\n\n            # See if len_met is true - if so do nothing\n            if len_met:\n                break\n            else:\n                while not len_met and not maxed:\n                    # Recalculate overlaps and their Tms\n                    overlaps = _recalculate_overlaps(dna, overlaps,\n                                                     oligo_indices)\n                    # Overlap to increase is the shortest one\n                    overlap_lens = [len(overlap) for overlap in overlaps]\n                    index = overlap_lens.index(min(overlap_lens))\n                    # Increase left or right oligo\n                    oligos = _expand_overlap(dna, oligo_indices, index, oligos,\n                                             length_max)\n                    # Recalculate conditions\n                    maxed = any([len(x) == length_max for x in oligos])\n                    len_met = all([len(x) >= overlap_min for x in overlaps])\n\n                # Recalculate tms to reflect any changes (some are redundant)\n                overlap_tms[index] = coral.analysis.tm(overlaps[index])\n\n                # Outcome could be that len_met happened *or* maxed out\n                # length of one of the oligos. If len_met happened, should be\n                # done so long as tm_met has been satisfied. If maxed happened,\n                # len_met will not have been met, even if tm_met is satisfied,\n                # and script will reattempt with more oligos\n\n        oligo_n += oligo_increment\n\n    # Calculate location of overlaps\n    overlap_indices = [(oligo_indices[0][x + 1], oligo_indices[1][x]) for x in\n                       range(overlap_n)]\n\n    return oligos, overlaps, overlap_tms, overlap_indices"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _recalculate_overlaps(dna, overlaps, oligo_indices):\n    '''Recalculate overlap sequences based on the current overlap indices.\n\n    :param dna: Sequence being split into oligos.\n    :type dna: coral.DNA\n    :param overlaps: Current overlaps - a list of DNA sequences.\n    :type overlaps: coral.DNA list\n    :param oligo_indices: List of oligo indices (starts and stops).\n    :type oligo_indices: list\n    :returns: Overlap sequences.\n    :rtype: coral.DNA list\n\n    '''\n    for i, overlap in enumerate(overlaps):\n        first_index = oligo_indices[0][i + 1]\n        second_index = oligo_indices[1][i]\n        overlap = dna[first_index:second_index]\n        overlaps[i] = overlap\n\n    return overlaps", "response": "Recalculate the overlaps of the current sequence based on the current overlap indices."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives an overlap to increase increases smaller oligo.", "response": "def _expand_overlap(dna, oligo_indices, index, oligos, length_max):\n    '''Given an overlap to increase, increases smaller oligo.\n\n    :param dna: Sequence being split into oligos.\n    :type dna: coral.DNA\n    :param oligo_indices: index of oligo starts and stops\n    :type oligo_indices: list\n    :param index: index of the oligo\n    :type index: int\n    :param left_len: length of left oligo\n    :type left_len: int\n    :param right_len: length of right oligo\n    :type right_len: int\n    :param length_max: length ceiling\n    :type length_max: int\n    :returns: New oligo list with one expanded.\n    :rtype: list\n\n    '''\n    left_len = len(oligos[index])\n    right_len = len(oligos[index + 1])\n\n    # If one of the oligos is max size, increase the other one\n    if right_len == length_max:\n        oligo_indices[1] = _adjust_overlap(oligo_indices[1], index, 'right')\n    elif left_len == length_max:\n        oligo_indices[0] = _adjust_overlap(oligo_indices[0], index, 'left')\n    else:\n        if left_len > right_len:\n            oligo_indices[0] = _adjust_overlap(oligo_indices[0], index, 'left')\n        else:\n            oligo_indices[1] = _adjust_overlap(oligo_indices[1], index,\n                                               'right')\n\n    # Recalculate oligos from start and end indices\n    oligos = [dna[start:end] for start, end in zip(*oligo_indices)]\n\n    return oligos"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _adjust_overlap(positions_list, index, direction):\n    '''Increase overlap to the right or left of an index.\n\n    :param positions_list: list of overlap positions\n    :type positions_list: list\n    :param index: index of the overlap to increase.\n    :type index: int\n    :param direction: which side of the overlap to increase - left or right.\n    :type direction: str\n    :returns: A list of overlap positions (2-element lists)\n    :rtype: list\n    :raises: ValueError if direction isn't \\'left\\' or \\'right\\'.\n\n    '''\n    if direction == 'left':\n        positions_list[index + 1] -= 1\n    elif direction == 'right':\n        positions_list[index] += 1\n    else:\n        raise ValueError('direction must be \\'left\\' or \\'right\\'.')\n    return positions_list", "response": "Increase the overlap to the right or left of an index."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndesigns the overlapping oligos and sequences Tms and indices of their respective overlapping regions.", "response": "def design_assembly(self):\n        '''Design the overlapping oligos.\n\n        :returns: Assembly oligos, and the sequences, Tms, and indices of their\n                  overlapping regions.\n        :rtype: dict\n\n        '''\n        # Input parameters needed to design the oligos\n        length_range = self.kwargs['length_range']\n        oligo_number = self.kwargs['oligo_number']\n        require_even = self.kwargs['require_even']\n        melting_temp = self.kwargs['tm']\n        overlap_min = self.kwargs['overlap_min']\n        min_exception = self.kwargs['min_exception']\n        start_5 = self.kwargs['start_5']\n\n        if len(self.template) < length_range[0]:\n            # If sequence can be built with just two oligos, do that\n            oligos = [self.template, self.template.reverse_complement()]\n            overlaps = [self.template]\n            overlap_tms = [coral.analysis.tm(self.template)]\n            assembly_dict = {'oligos': oligos, 'overlaps': overlaps,\n                             'overlap_tms': overlap_tms}\n\n            self.oligos = assembly_dict['oligos']\n            self.overlaps = assembly_dict['overlaps']\n            self.overlap_tms = assembly_dict['overlap_tms']\n            return assembly_dict\n\n        if oligo_number:\n            # Make first attempt using length_range[1] and see what happens\n            step = 3  # Decrease max range by this amount each iteration\n\n            length_max = length_range[1]\n            current_oligo_n = oligo_number + 1\n            oligo_n_met = False\n            above_min_len = length_max > length_range[0]\n            if oligo_n_met or not above_min_len:\n                raise Exception('Failed to design assembly.')\n            while not oligo_n_met and above_min_len:\n                # Starting with low range and going up doesnt work for longer\n                # sequence (overlaps become longer than 80)\n                assembly = _grow_overlaps(self.template, melting_temp,\n                                          require_even, length_max,\n                                          overlap_min, min_exception)\n                current_oligo_n = len(assembly[0])\n                if current_oligo_n > oligo_number:\n                    break\n                length_max -= step\n                oligo_n_met = current_oligo_n == oligo_number\n        else:\n            assembly = _grow_overlaps(self.template, melting_temp,\n                                      require_even, length_range[1],\n                                      overlap_min, min_exception)\n\n        oligos, overlaps, overlap_tms, overlap_indices = assembly\n\n        if start_5:\n            for i in [x for x in range(len(oligos)) if x % 2 == 1]:\n                oligos[i] = oligos[i].reverse_complement()\n        else:\n            for i in [x for x in range(len(oligos)) if x % 2 == 0]:\n                oligos[i] = oligos[i].reverse_complement()\n\n        # Make single-stranded\n        oligos = [oligo.top for oligo in oligos]\n\n        assembly_dict = {'oligos': oligos,\n                         'overlaps': overlaps,\n                         'overlap_tms': overlap_tms,\n                         'overlap_indices': overlap_indices}\n\n        self.oligos = assembly_dict['oligos']\n        self.overlaps = assembly_dict['overlaps']\n        self.overlap_tms = assembly_dict['overlap_tms']\n        self.overlap_indices = assembly_dict['overlap_indices']\n\n        for i in range(len(self.overlap_indices) - 1):\n            # TODO: either raise an exception or prevent this from happening\n            # at all\n            current_start = self.overlap_indices[i + 1][0]\n            current_end = self.overlap_indices[i][1]\n            if current_start <= current_end:\n                self.warning = 'warning: overlapping overlaps!'\n                print self.warning\n\n        self._has_run = True\n        return assembly_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef primers(self, tm=60):\n        '''Design primers for amplifying the assembled sequence.\n\n        :param tm: melting temperature (lower than overlaps is best).\n        :type tm: float\n        :returns: Primer list (the output of coral.design.primers).\n        :rtype: list\n\n        '''\n        self.primers = coral.design.primers(self.template, tm=tm)\n        return self.primers", "response": "Design primers for amplifying the assembled sequence."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite assembly oligos and primers to a CSV file.", "response": "def write(self, path):\n        '''Write assembly oligos and (if applicable) primers to csv.\n\n        :param path: path to csv file, including .csv extension.\n        :type path: str\n\n        '''\n        with open(path, 'wb') as oligo_file:\n            oligo_writer = csv.writer(oligo_file, delimiter=',',\n                                      quoting=csv.QUOTE_MINIMAL)\n            oligo_writer.writerow(['name', 'oligo', 'notes'])\n            for i, oligo in enumerate(self.oligos):\n                name = 'oligo {}'.format(i + 1)\n                oligo_len = len(oligo)\n                if i != len(self.oligos) - 1:\n                    oligo_tm = self.overlap_tms[i]\n                    notes = 'oligo length: {}, '.format(oligo_len) + \\\n                            'overlap Tm: {:.2f}'.format(oligo_tm)\n                else:\n                    notes = 'oligo length: {}'.format(oligo_len)\n                oligo_writer.writerow([name, oligo, notes])\n            if self.primers:\n                for i, (primer, melt) in enumerate(self.primers):\n                    oligo_writer.writerow(['primer {}'.format(i + 1),\n                                           primer,\n                                           'Tm: {:.2f}'.format(melt)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites genbank map that highlights overlaps.", "response": "def write_map(self, path):\n        '''Write genbank map that highlights overlaps.\n\n        :param path: full path to .gb file to write.\n        :type path: str\n\n        '''\n        starts = [index[0] for index in self.overlap_indices]\n        features = []\n        for i, start in enumerate(starts):\n            stop = start + len(self.overlaps[i])\n            name = 'overlap {}'.format(i + 1)\n            feature_type = 'misc'\n            strand = 0\n            features.append(coral.Feature(name, start, stop, feature_type,\n                                          strand=strand))\n        seq_map = coral.DNA(self.template, features=features)\n        coral.seqio.write_dna(seq_map, path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract a coding sequence from an RNA sequence.", "response": "def coding_sequence(rna):\n    '''Extract coding sequence from an RNA template.\n\n    :param seq: Sequence from which to extract a coding sequence.\n    :type seq: coral.RNA\n    :param material: Type of sequence ('dna' or 'rna')\n    :type material: str\n    :returns: The first coding sequence (start codon -> stop codon) matched\n              from 5' to 3'.\n    :rtype: coral.RNA\n    :raises: ValueError if rna argument has no start codon.\n             ValueError if rna argument has no stop codon in-frame with the\n             first start codon.\n\n    '''\n    if isinstance(rna, coral.DNA):\n        rna = transcribe(rna)\n    codons_left = len(rna) // 3\n    start_codon = coral.RNA('aug')\n    stop_codons = [coral.RNA('uag'), coral.RNA('uga'), coral.RNA('uaa')]\n    start = None\n    stop = None\n    valid = [None, None]\n    index = 0\n    while codons_left:\n        codon = rna[index:index + 3]\n        if valid[0] is None:\n            if codon in start_codon:\n                start = index\n                valid[0] = True\n        else:\n            if codon in stop_codons:\n                stop = index + 3\n                valid[1] = True\n                break\n        index += 3\n        codons_left -= 1\n\n    if valid[0] is None:\n        raise ValueError('Sequence has no start codon.')\n    elif stop is None:\n        raise ValueError('Sequence has no stop codon.')\n    coding_rna = rna[start:stop]\n\n    return coding_rna"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self):\n        '''Update definitions.'''\n        # Download http://rebase.neb.com/rebase/link_withref to tmp\n        self._tmpdir = tempfile.mkdtemp()\n        try:\n            self._rebase_file = self._tmpdir + '/rebase_file'\n            print 'Downloading latest enzyme definitions'\n            url = 'http://rebase.neb.com/rebase/link_withref'\n            header = {'User-Agent': 'Mozilla/5.0'}\n            req = urllib2.Request(url, headers=header)\n            con = urllib2.urlopen(req)\n            with open(self._rebase_file, 'wb') as rebase_file:\n                rebase_file.write(con.read())\n            # Process into self._enzyme_dict\n            self._process_file()\n        except urllib2.HTTPError, e:\n            print 'HTTP Error: {} {}'.format(e.code, url)\n            print 'Falling back on default enzyme list'\n            self._enzyme_dict = coral.constants.fallback_enzymes\n        except urllib2.URLError, e:\n            print 'URL Error: {} {}'.format(e.reason, url)\n            print 'Falling back on default enzyme list'\n            self._enzyme_dict = coral.constants.fallback_enzymes\n        # Process into RestrictionSite objects? (depends on speed)\n        print 'Processing into RestrictionSite instances.'\n        self.restriction_sites = {}\n        # TODO: make sure all names are unique\n        for key, (site, cuts) in self._enzyme_dict.iteritems():\n            # Make a site\n            try:\n                r = coral.RestrictionSite(coral.DNA(site), cuts, name=key)\n                # Add it to dict with name as key\n                self.restriction_sites[key] = r\n            except ValueError:\n                # Encountered ambiguous sequence, have to ignore it until\n                # coral.DNA can handle ambiguous DNA\n                pass", "response": "Update the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the rebase file into a dict with name and cut site information.", "response": "def _process_file(self):\n        '''Process rebase file into dict with name and cut site information.'''\n        print 'Processing file'\n        with open(self._rebase_file, 'r') as f:\n            raw = f.readlines()\n        names = [line.strip()[3:] for line in raw if line.startswith('<1>')]\n        seqs = [line.strip()[3:] for line in raw if line.startswith('<5>')]\n        if len(names) != len(seqs):\n            raise Exception('Found different number of enzyme names and '\n                            'sequences.')\n        self._enzyme_dict = {}\n        for name, seq in zip(names, seqs):\n            if '?' in seq:\n                # Is unknown sequence, don't keep it\n                pass\n            elif seq.startswith('(') and seq.endswith(')'):\n                # Has four+ cut sites, don't keep it\n                pass\n            elif '^' in seq:\n                # Has reasonable internal cut sites, keep it\n                top_cut = seq.index('^')\n                bottom_cut = len(seq) - top_cut - 1\n                site = seq.replace('^', '')\n                self._enzyme_dict[name] = (site, (top_cut, bottom_cut))\n            elif seq.endswith(')'):\n                # Has reasonable external cut sites, keep it\n                # (4-cutter also starts with '(')\n                # separate site and cut locations\n                site, cuts = seq.split('(')\n                cuts = cuts.replace(')', '')\n                top_cut, bottom_cut = [int(x) + len(site) for x in\n                                       cuts.split('/')]\n                self._enzyme_dict[name] = (site, (top_cut, bottom_cut))\n        shutil.rmtree(self._tmpdir)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self):\n        '''Create a copy of the current instance.\n\n        :returns: A safely editable copy of the current sequence.\n        :rtype: coral.Peptide\n\n        '''\n        return type(self)(str(self._sequence), features=self.features,\n                          run_checks=False)", "response": "Create a safely editable copy of the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_sequence(seq, to_material):\n    '''Translate a DNA sequence into peptide sequence.\n\n    The following conversions are supported:\n        Transcription (seq is DNA, to_material is 'rna')\n        Reverse transcription (seq is RNA, to_material is 'dna')\n        Translation (seq is RNA, to_material is 'peptide')\n\n    :param seq: DNA or RNA sequence.\n    :type seq: coral.DNA or coral.RNA\n    :param to_material: material to which to convert ('rna', 'dna', or\n                        'peptide').\n    :type to_material: str\n    :returns: sequence of type coral.sequence.[material type]\n\n    '''\n    if isinstance(seq, coral.DNA) and to_material == 'rna':\n        # Transcribe\n\n        # Can't transcribe a gap\n        if '-' in seq:\n            raise ValueError('Cannot transcribe gapped DNA')\n        # Convert DNA chars to RNA chars\n        origin = ALPHABETS['dna'][:-1]\n        destination = ALPHABETS['rna']\n        code = dict(zip(origin, destination))\n        converted = ''.join([code.get(str(k), str(k)) for k in seq])\n        # Instantiate RNA object\n        converted = coral.RNA(converted)\n    elif isinstance(seq, coral.RNA):\n        if to_material == 'dna':\n            # Reverse transcribe\n            origin = ALPHABETS['rna']\n            destination = ALPHABETS['dna'][:-1]\n            code = dict(zip(origin, destination))\n            converted = ''.join([code.get(str(k), str(k)) for k in seq])\n            # Instantiate DNA object\n            converted = coral.DNA(converted)\n        elif to_material == 'peptide':\n            # Translate\n            seq_list = list(str(seq))\n            # Convert to peptide until stop codon is found.\n            converted = []\n            while True:\n                if len(seq_list) >= 3:\n                    base_1 = seq_list.pop(0)\n                    base_2 = seq_list.pop(0)\n                    base_3 = seq_list.pop(0)\n                    codon = ''.join(base_1 + base_2 + base_3).upper()\n                    amino_acid = CODONS[codon]\n                    # Stop when stop codon is found\n                    if amino_acid == '*':\n                        break\n                    converted.append(amino_acid)\n                else:\n                    break\n            converted = ''.join(converted)\n            converted = coral.Peptide(converted)\n    else:\n        msg1 = 'Conversion from '\n        msg2 = '{0} to {1} is not supported.'.format(seq.__class__.__name__,\n                                                     to_material)\n        raise ValueError(msg1 + msg2)\n\n    return converted", "response": "Translate a DNA sequence into peptide sequence."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the frequency of G and C in the current sequence.", "response": "def gc(self):\n        '''Find the frequency of G and C in the current sequence.'''\n        gc = len([base for base in self.seq if base == 'C' or base == 'G'])\n        return float(gc) / len(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine whether two sequences are the same just at different rotations.", "response": "def is_rotation(self, other):\n        '''Determine whether two sequences are the same, just at different\n        rotations.\n\n        :param other: The sequence to check for rotational equality.\n        :type other: coral.sequence._sequence.Sequence\n\n        '''\n        if len(self) != len(other):\n            return False\n\n        for i in range(len(self)):\n            if self.rotate(i) == other:\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef linearize(self, index=0):\n        '''Linearize the Sequence at an index.\n\n        :param index: index at which to linearize.\n        :type index: int\n        :returns: A linearized version of the current sequence.\n        :rtype: coral.sequence._sequence.Sequence\n        :raises: ValueError if the input is a linear sequence.\n\n        '''\n        if not self.circular and index != 0:\n            raise ValueError('Cannot relinearize a linear sequence.')\n        copy = self.copy()\n        # Snip at the index\n        if index:\n            return copy[index:] + copy[:index]\n        copy.circular = False\n\n        return copy", "response": "Linearize the Sequence at an index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef locate(self, pattern):\n        '''Find sequences matching a pattern.\n\n        :param pattern: Sequence for which to find matches.\n        :type pattern: str\n        :returns: Indices of pattern matches.\n        :rtype: list of ints\n\n        '''\n        if self.circular:\n            if len(pattern) >= 2 * len(self):\n                raise ValueError('Search pattern longer than searchable ' +\n                                 'sequence.')\n            seq = self + self[:len(pattern) - 1]\n            return super(NucleicAcid, seq).locate(pattern)\n        else:\n            return super(NucleicAcid, self).locate(pattern)", "response": "Find sequences matching a pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the molecular weight of the current sequence in amu.", "response": "def mw(self):\n        '''Calculate the molecular weight.\n\n        :returns: The molecular weight of the current sequence in amu.\n        :rtype: float\n\n        '''\n        counter = collections.Counter(self.seq.lower())\n        mw_a = counter['a'] * 313.2\n        mw_t = counter['t'] * 304.2\n        mw_g = counter['g'] * 289.2\n        mw_c = counter['c'] * 329.2\n        mw_u = counter['u'] * 306.2\n\n        if self.material == 'dna':\n            return mw_a + mw_t + mw_g + mw_c + 79.0\n        else:\n            return mw_a + mw_u + mw_g + mw_c + 159.0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrotates the current sequence by n bases.", "response": "def rotate(self, n):\n        '''Rotate Sequence by n bases.\n\n        :param n: Number of bases to rotate.\n        :type n: int\n        :returns: The current sequence reoriented at `index`.\n        :rtype: coral.sequence._sequence.Sequence\n        :raises: ValueError if applied to linear sequence or `index` is\n                 negative.\n\n        '''\n        if not self.circular and n != 0:\n            raise ValueError('Cannot rotate a linear sequence')\n        else:\n            rotated = self[-n:] + self[:-n]\n            return rotated.circularize()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef five_resect(dna, n_bases):\n    '''Remove bases from 5' end of top strand.\n\n    :param dna: Sequence to resect.\n    :type dna: coral.DNA\n    :param n_bases: Number of bases cut back.\n    :type n_bases: int\n    :returns: DNA sequence resected at the 5' end by n_bases.\n    :rtype: coral.DNA\n\n    '''\n    new_instance = dna.copy()\n    if n_bases >= len(dna):\n        new_instance.top.seq = ''.join(['-' for i in range(len(dna))])\n    else:\n        new_instance.top.seq = '-' * n_bases + str(dna)[n_bases:]\n\n    new_instance = _remove_end_gaps(new_instance)\n\n    return new_instance", "response": "Remove bases from 5 end of top strand."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving double - stranded gaps from ends of the sequence.", "response": "def _remove_end_gaps(sequence):\n    '''Removes double-stranded gaps from ends of the sequence.\n\n    :returns: The current sequence with terminal double-strand gaps ('-')\n              removed.\n    :rtype: coral.DNA\n\n    '''\n    # Count terminal blank sequences\n    def count_end_gaps(seq):\n        gap = coral.DNA('-')\n        count = 0\n        for base in seq:\n            if base == gap:\n                count += 1\n            else:\n                break\n\n        return count\n\n    top_left = count_end_gaps(sequence.top)\n    top_right = count_end_gaps(reversed(sequence.top))\n    bottom_left = count_end_gaps(reversed(sequence.bottom))\n    bottom_right = count_end_gaps(sequence.bottom)\n\n    # Trim sequence\n    left_index = min(top_left, bottom_left)\n    right_index = len(sequence) - min(top_right, bottom_right)\n\n    return sequence[left_index:right_index]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndoes a Needleman - Wunsch alignment against a reference sequence.", "response": "def needle(reference, query, gap_open=-15, gap_extend=0,\n           matrix=submat.DNA_SIMPLE):\n    '''Do a Needleman-Wunsch alignment.\n\n    :param reference: Reference sequence.\n    :type reference: coral.DNA\n    :param query: Sequence to align against the reference.\n    :type query: coral.DNA\n    :param gapopen: Penalty for opening a gap.\n    :type gapopen: float\n    :param gapextend: Penalty for extending a gap.\n    :type gapextend: float\n    :param matrix: Matrix to use for alignment - options are DNA_simple (for\n                   DNA) and BLOSUM62 (for proteins).\n    :type matrix: str\n    :returns: (aligned reference, aligned query, score)\n    :rtype: tuple of two coral.DNA instances and a float\n\n    '''\n    # Align using cython Needleman-Wunsch\n    aligned_ref, aligned_res = aligner(str(reference),\n                                       str(query),\n                                       gap_open=gap_open,\n                                       gap_extend=gap_extend,\n                                       method='global_cfe',\n                                       matrix=matrix.matrix,\n                                       alphabet=matrix.alphabet)\n\n    # Score the alignment\n    score = score_alignment(aligned_ref, aligned_res, gap_open, gap_extend,\n                            matrix.matrix, matrix.alphabet)\n\n    return cr.DNA(aligned_ref), cr.DNA(aligned_res), score"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a multiple sequence alignment based on aligning every result sequence against the reference and then inserting gaps until every aligned result sequence is identical", "response": "def needle_msa(reference, results, gap_open=-15, gap_extend=0,\n               matrix=submat.DNA_SIMPLE):\n    '''Create a multiple sequence alignment based on aligning every result\n    sequence against the reference, then inserting gaps until every aligned\n    reference is identical\n\n    '''\n    gap = '-'\n    # Convert alignments to list of strings\n    alignments = []\n    for result in results:\n        ref_dna, res_dna, score = needle(reference, result, gap_open=gap_open,\n                                         gap_extend=gap_extend,\n                                         matrix=matrix)\n        alignments.append([str(ref_dna), str(res_dna), score])\n\n    def insert_gap(sequence, position):\n        return sequence[:position] + gap + sequence[position:]\n\n    i = 0\n    while True:\n        # Iterate over 'columns' in every reference\n        refs = [alignment[0][i] for alignment in alignments]\n\n        # If there's a non-unanimous gap, insert gap into alignments\n        gaps = [ref == gap for ref in refs]\n        if any(gaps) and not all(gaps):\n            for alignment in alignments:\n                if alignment[0][i] != gap:\n                    alignment[0] = insert_gap(alignment[0], i)\n                    alignment[1] = insert_gap(alignment[1], i)\n\n        # If all references match, we're all done\n        alignment_set = set(alignment[0] for alignment in alignments)\n        if len(alignment_set) == 1:\n            break\n\n        # If we've reach the end of some, but not all sequences, add end gap\n        lens = [len(alignment[0]) for alignment in alignments]\n        if i + 1 in lens:\n            for alignment in alignments:\n                if len(alignment[0]) == i + 1:\n                    alignment[0] = alignment[0] + gap\n                    alignment[1] = alignment[1] + gap\n\n        i += 1\n\n        if i > 20:\n            break\n\n    # Convert into MSA format\n    output_alignment = [cr.DNA(alignments[0][0])]\n    for alignment in alignments:\n        output_alignment.append(cr.DNA(alignment[1]))\n\n    return output_alignment"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef needle_multi(references, queries, gap_open=-15, gap_extend=0,\n                 matrix=submat.DNA_SIMPLE):\n    '''Batch process of sequencing split over several cores. Acts just like\n    needle but sequence inputs are lists.\n\n    :param references: References sequence.\n    :type references: coral.DNA list\n    :param queries: Sequences to align against the reference.\n    :type queries: coral.DNA list\n    :param gap_open: Penalty for opening a gap.\n    :type gap_open: float\n    :param gap_extend: Penalty for extending a gap.\n    :type gap_extend: float\n    :param matrix: Matrix to use for alignment - options are DNA_simple (for\n                   DNA) and BLOSUM62 (for proteins).\n    :type matrix: str\n    :returns: a list of the same output as coral.sequence.needle\n    :rtype: list\n\n    '''\n    pool = multiprocessing.Pool()\n    try:\n        args_list = [[ref, que, gap_open, gap_extend, matrix] for ref, que in\n                     zip(references, queries)]\n        aligned = pool.map(run_needle, args_list)\n    except KeyboardInterrupt:\n        print('Caught KeyboardInterrupt, terminating workers')\n        pool.terminate()\n        pool.join()\n        raise KeyboardInterrupt\n\n    return aligned", "response": "This function is used to split a sequence into multiple cores."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_global(\n        name, modules=None, exceptions=DummyException, locals_=None,\n        globals_=None, level=-1):\n    '''Import the requested items into the global scope\n\n    WARNING! this method _will_ overwrite your global scope\n    If you have a variable named \"path\" and you call import_global('sys')\n    it will be overwritten with sys.path\n\n    Args:\n        name (str): the name of the module to import, e.g. sys\n        modules (str): the modules to import, use None for everything\n        exception (Exception): the exception to catch, e.g. ImportError\n        `locals_`: the `locals()` method (in case you need a different scope)\n        `globals_`: the `globals()` method (in case you need a different scope)\n        level (int): the level to import from, this can be used for\n        relative imports\n    '''\n    frame = None\n    try:\n        # If locals_ or globals_ are not given, autodetect them by inspecting\n        # the current stack\n        if locals_ is None or globals_ is None:\n            import inspect\n            frame = inspect.stack()[1][0]\n\n            if locals_ is None:\n                locals_ = frame.f_locals\n\n            if globals_ is None:\n                globals_ = frame.f_globals\n\n        try:\n            name = name.split('.')\n\n            # Relative imports are supported (from .spam import eggs)\n            if not name[0]:\n                name = name[1:]\n                level = 1\n\n            # raise IOError((name, level))\n            module = __import__(\n                name=name[0] or '.',\n                globals=globals_,\n                locals=locals_,\n                fromlist=name[1:],\n                level=max(level, 0),\n            )\n\n            # Make sure we get the right part of a dotted import (i.e.\n            # spam.eggs should return eggs, not spam)\n            try:\n                for attr in name[1:]:\n                    module = getattr(module, attr)\n            except AttributeError:\n                raise ImportError('No module named ' + '.'.join(name))\n\n            # If no list of modules is given, autodetect from either __all__\n            # or a dir() of the module\n            if not modules:\n                modules = getattr(module, '__all__', dir(module))\n            else:\n                modules = set(modules).intersection(dir(module))\n\n            # Add all items in modules to the global scope\n            for k in set(dir(module)).intersection(modules):\n                if k and k[0] != '_':\n                    globals_[k] = getattr(module, k)\n        except exceptions as e:\n            return e\n    finally:\n        # Clean up, just to be sure\n        del name, modules, exceptions, locals_, globals_, frame", "response": "Import the requested items into the global scope."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef camel_to_underscore(name):\n    '''Convert camel case style naming to underscore style naming\n\n    If there are existing underscores they will be collapsed with the\n    to-be-added underscores. Multiple consecutive capital letters will not be\n    split except for the last one.\n\n    >>> camel_to_underscore('SpamEggsAndBacon')\n    'spam_eggs_and_bacon'\n    >>> camel_to_underscore('Spam_and_bacon')\n    'spam_and_bacon'\n    >>> camel_to_underscore('Spam_And_Bacon')\n    'spam_and_bacon'\n    >>> camel_to_underscore('__SpamAndBacon__')\n    '__spam_and_bacon__'\n    >>> camel_to_underscore('__SpamANDBacon__')\n    '__spam_and_bacon__'\n    '''\n    output = []\n    for i, c in enumerate(name):\n        if i > 0:\n            pc = name[i - 1]\n            if c.isupper() and not pc.isupper() and pc != '_':\n                # Uppercase and the previous character isn't upper/underscore?\n                # Add the underscore\n                output.append('_')\n            elif i > 3 and not c.isupper():\n                # Will return the last 3 letters to check if we are changing\n                # case\n                previous = name[i - 3:i]\n                if previous.isalpha() and previous.isupper():\n                    output.insert(len(output) - 1, '_')\n\n        output.append(c.lower())\n\n    return ''.join(output)", "response": "Convert camel case style naming to underscore style naming"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef timesince(dt, default='just now'):\n    '''\n    Returns string representing 'time since' e.g.\n    3 days ago, 5 hours ago etc.\n\n    >>> now = datetime.datetime.now()\n    >>> timesince(now)\n    'just now'\n    >>> timesince(now - datetime.timedelta(seconds=1))\n    '1 second ago'\n    >>> timesince(now - datetime.timedelta(seconds=2))\n    '2 seconds ago'\n    >>> timesince(now - datetime.timedelta(seconds=60))\n    '1 minute ago'\n    >>> timesince(now - datetime.timedelta(seconds=61))\n    '1 minute and 1 second ago'\n    >>> timesince(now - datetime.timedelta(seconds=62))\n    '1 minute and 2 seconds ago'\n    >>> timesince(now - datetime.timedelta(seconds=120))\n    '2 minutes ago'\n    >>> timesince(now - datetime.timedelta(seconds=121))\n    '2 minutes and 1 second ago'\n    >>> timesince(now - datetime.timedelta(seconds=122))\n    '2 minutes and 2 seconds ago'\n    >>> timesince(now - datetime.timedelta(seconds=3599))\n    '59 minutes and 59 seconds ago'\n    >>> timesince(now - datetime.timedelta(seconds=3600))\n    '1 hour ago'\n    >>> timesince(now - datetime.timedelta(seconds=3601))\n    '1 hour and 1 second ago'\n    >>> timesince(now - datetime.timedelta(seconds=3602))\n    '1 hour and 2 seconds ago'\n    >>> timesince(now - datetime.timedelta(seconds=3660))\n    '1 hour and 1 minute ago'\n    >>> timesince(now - datetime.timedelta(seconds=3661))\n    '1 hour and 1 minute ago'\n    >>> timesince(now - datetime.timedelta(seconds=3720))\n    '1 hour and 2 minutes ago'\n    >>> timesince(now - datetime.timedelta(seconds=3721))\n    '1 hour and 2 minutes ago'\n    >>> timesince(datetime.timedelta(seconds=3721))\n    '1 hour and 2 minutes ago'\n    '''\n    if isinstance(dt, datetime.timedelta):\n        diff = dt\n    else:\n        now = datetime.datetime.now()\n        diff = abs(now - dt)\n\n    periods = (\n        (diff.days / 365, 'year', 'years'),\n        (diff.days % 365 / 30, 'month', 'months'),\n        (diff.days % 30 / 7, 'week', 'weeks'),\n        (diff.days % 7, 'day', 'days'),\n        (diff.seconds / 3600, 'hour', 'hours'),\n        (diff.seconds % 3600 / 60, 'minute', 'minutes'),\n        (diff.seconds % 60, 'second', 'seconds'),\n    )\n\n    output = []\n    for period, singular, plural in periods:\n        if int(period):\n            if int(period) == 1:\n                output.append('%d %s' % (period, singular))\n            else:\n                output.append('%d %s' % (period, plural))\n\n    if output:\n        return '%s ago' % ' and '.join(output[:2])\n\n    return default", "response": "Returns a string representing time since"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef timedelta_to_seconds(delta):\n    '''Convert a timedelta to seconds with the microseconds as fraction\n\n    Note that this method has become largely obsolete with the\n    `timedelta.total_seconds()` method introduced in Python 2.7.\n\n    >>> from datetime import timedelta\n    >>> '%d' % timedelta_to_seconds(timedelta(days=1))\n    '86400'\n    >>> '%d' % timedelta_to_seconds(timedelta(seconds=1))\n    '1'\n    >>> '%.6f' % timedelta_to_seconds(timedelta(seconds=1, microseconds=1))\n    '1.000001'\n    >>> '%.6f' % timedelta_to_seconds(timedelta(microseconds=1))\n    '0.000001'\n    '''\n    # Only convert to float if needed\n    if delta.microseconds:\n        total = delta.microseconds * 1e-6\n    else:\n        total = 0\n    total += delta.seconds\n    total += delta.days * 60 * 60 * 24\n    return total", "response": "Convert a timedelta to seconds with the microseconds as fraction\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_time(timestamp, precision=datetime.timedelta(seconds=1)):\n    '''Formats timedelta/datetime/seconds\n\n    >>> format_time('1')\n    '0:00:01'\n    >>> format_time(1.234)\n    '0:00:01'\n    >>> format_time(1)\n    '0:00:01'\n    >>> format_time(datetime.datetime(2000, 1, 2, 3, 4, 5, 6))\n    '2000-01-02 03:04:05'\n    >>> format_time(datetime.date(2000, 1, 2))\n    '2000-01-02'\n    >>> format_time(datetime.timedelta(seconds=3661))\n    '1:01:01'\n    >>> format_time(None)\n    '--:--:--'\n    >>> format_time(format_time)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    TypeError: Unknown type ...\n\n    '''\n    precision_seconds = precision.total_seconds()\n\n    if isinstance(timestamp, six.string_types + six.integer_types + (float, )):\n        try:\n            castfunc = six.integer_types[-1]\n            timestamp = datetime.timedelta(seconds=castfunc(timestamp))\n        except OverflowError:  # pragma: no cover\n            timestamp = None\n\n    if isinstance(timestamp, datetime.timedelta):\n        seconds = timestamp.total_seconds()\n        # Truncate the number to the given precision\n        seconds = seconds - (seconds % precision_seconds)\n\n        return str(datetime.timedelta(seconds=seconds))\n    elif isinstance(timestamp, datetime.datetime):\n        # Python 2 doesn't have the timestamp method\n        if hasattr(timestamp, 'timestamp'):  # pragma: no cover\n            seconds = timestamp.timestamp()\n        else:\n            seconds = timedelta_to_seconds(timestamp - epoch)\n\n        # Truncate the number to the given precision\n        seconds = seconds - (seconds % precision_seconds)\n\n        try:  # pragma: no cover\n            if six.PY3:\n                dt = datetime.datetime.fromtimestamp(seconds)\n            else:\n                dt = datetime.datetime.utcfromtimestamp(seconds)\n        except ValueError:  # pragma: no cover\n            dt = datetime.datetime.max\n        return str(dt)\n    elif isinstance(timestamp, datetime.date):\n        return str(timestamp)\n    elif timestamp is None:\n        return '--:--:--'\n    else:\n        raise TypeError('Unknown type %s: %r' % (type(timestamp), timestamp))", "response": "Formats a datetime object to be used in the log file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the current size of your terminal.", "response": "def get_terminal_size():  # pragma: no cover\n    '''Get the current size of your terminal\n\n    Multiple returns are not always a good idea, but in this case it greatly\n    simplifies the code so I believe it's justified. It's not the prettiest\n    function but that's never really possible with cross-platform code.\n\n    Returns:\n        width, height: Two integers containing width and height\n    '''\n\n    try:\n        # Default to 79 characters for IPython notebooks\n        from IPython import get_ipython\n        ipython = get_ipython()\n        from ipykernel import zmqshell\n        if isinstance(ipython, zmqshell.ZMQInteractiveShell):\n            return 79, 24\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        # This works for Python 3, but not Pypy3. Probably the best method if\n        # it's supported so let's always try\n        import shutil\n        w, h = shutil.get_terminal_size()\n        if w and h:\n            # The off by one is needed due to progressbars in some cases, for\n            # safety we'll always substract it.\n            return w - 1, h\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        w = int(os.environ.get('COLUMNS'))\n        h = int(os.environ.get('LINES'))\n        if w and h:\n            return w, h\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        import blessings\n        terminal = blessings.Terminal()\n        w = terminal.width\n        h = terminal.height\n        if w and h:\n            return w, h\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        w, h = _get_terminal_size_linux()\n        if w and h:\n            return w, h\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        # Windows detection doesn't always work, let's try anyhow\n        w, h = _get_terminal_size_windows()\n        if w and h:\n            return w, h\n    except Exception:  # pragma: no cover\n        pass\n\n    try:\n        # needed for window's python in cygwin's xterm!\n        w, h = _get_terminal_size_tput()\n        if w and h:\n            return w, h\n    except Exception:  # pragma: no cover\n        pass\n\n    return 79, 24"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Attach(self, Protocol=5, Wait=True):\n        try:\n            self._Api.protocol = Protocol\n            self._Api.attach(self.Timeout, Wait)\n        except SkypeAPIError:\n            self.ResetCache()\n            raise", "response": "Establishes a connection to Skype."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Call(self, Id=0):\n        o = Call(self, Id)\n        o.Status # Test if such a call exists.\n        return o", "response": "Queries a call object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ChangeUserStatus(self, Status):\n        if self.CurrentUserStatus.upper() == Status.upper():\n            return\n        self._ChangeUserStatus_Event = threading.Event()\n        self._ChangeUserStatus_Status = Status.upper()\n        self.RegisterEventHandler('UserStatus', self._ChangeUserStatus_UserStatus)\n        self.CurrentUserStatus = Status\n        self._ChangeUserStatus_Event.wait()\n        self.UnregisterEventHandler('UserStatus', self._ChangeUserStatus_UserStatus)\n        del self._ChangeUserStatus_Event, self._ChangeUserStatus_Status", "response": "Changes the online status for the current user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries a chat object.", "response": "def Chat(self, Name=''):\n        \"\"\"Queries a chat object.\n\n        :Parameters:\n          Name : str\n            Chat name.\n\n        :return: A chat object.\n        :rtype: `chat.Chat`\n        \"\"\"\n        o = Chat(self, Name)\n        o.Status # Tests if such a chat really exists.\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ClearCallHistory(self, Username='ALL', Type=chsAllCalls):\n        cmd = 'CLEAR CALLHISTORY %s %s' % (str(Type), Username)\n        self._DoCommand(cmd, cmd)", "response": "Clears the call history for the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an API command object.", "response": "def Command(self, Command, Reply=u'', Block=False, Timeout=30000, Id=-1):\n        \"\"\"Creates an API command object.\n\n        :Parameters:\n          Command : unicode\n            Command string.\n          Reply : unicode\n            Expected reply. By default any reply is accepted (except errors which raise an\n            `SkypeError` exception).\n          Block : bool\n            If set to True, `SendCommand` method waits for a response from Skype API before\n            returning.\n          Timeout : float, int or long\n            Timeout. Used if Block == True. Timeout may be expressed in milliseconds if the type\n            is int or long or in seconds (or fractions thereof) if the type is float.\n          Id : int\n            Command Id. The default (-1) means it will be assigned automatically as soon as the\n            command is sent.\n\n        :return: A command object.\n        :rtype: `Command`\n\n        :see: `SendCommand`\n        \"\"\"\n        from api import Command as CommandClass\n        return CommandClass(Command, Reply, Block, Timeout, Id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Conference(self, Id=0):\n        o = Conference(self, Id)\n        if Id <= 0 or not o.Calls:\n            raise SkypeError(0, 'Unknown conference')\n        return o", "response": "Queries a call conference object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a chat with one or more users.", "response": "def CreateChatWith(self, *Usernames):\n        \"\"\"Creates a chat with one or more users.\n\n        :Parameters:\n          Usernames : str\n            One or more Skypenames of the users.\n\n        :return: A chat object\n        :rtype: `Chat`\n\n        :see: `Chat.AddMembers`\n        \"\"\"\n        return Chat(self, chop(self._DoCommand('CHAT CREATE %s' % ', '.join(Usernames)), 2)[1])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef CreateGroup(self, GroupName):\n        groups = self.CustomGroups\n        self._DoCommand('CREATE GROUP %s' % tounicode(GroupName))\n        for g in self.CustomGroups:\n            if g not in groups and g.DisplayName == GroupName:\n                return g\n        raise SkypeError(0, 'Group creating failed')", "response": "Creates a custom contact group."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an SMS message.", "response": "def CreateSms(self, MessageType, *TargetNumbers):\n        \"\"\"Creates an SMS message.\n\n        :Parameters:\n          MessageType : `enums`.smsMessageType*\n            Message type.\n          TargetNumbers : str\n            One or more target SMS numbers.\n\n        :return: An sms message object.\n        :rtype: `SmsMessage`\n        \"\"\"\n        return SmsMessage(self, chop(self._DoCommand('CREATE SMS %s %s' % (MessageType, ', '.join(TargetNumbers))), 2)[1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nqueries the greeting used as voicemail.", "response": "def Greeting(self, Username=''):\n        \"\"\"Queries the greeting used as voicemail.\n\n        :Parameters:\n          Username : str\n            Skypename of the user.\n\n        :return: A voicemail object.\n        :rtype: `Voicemail`\n        \"\"\"\n        for v in self.Voicemails:\n            if Username and v.PartnerHandle != Username:\n                continue\n            if v.Type in (vmtDefaultGreeting, vmtCustomGreeting):\n                return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Message(self, Id=0):\n        o = ChatMessage(self, Id)\n        o.Status # Test if such an id is known.\n        return o", "response": "Queries a chat message object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef PlaceCall(self, *Targets):\n        calls = self.ActiveCalls\n        reply = self._DoCommand('CALL %s' % ', '.join(Targets))\n        # Skype for Windows returns the call status which gives us the call Id;\n        if reply.startswith('CALL '):\n            return Call(self, chop(reply, 2)[1])\n        # On linux we get 'OK' as reply so we search for the new call on\n        # list of active calls.\n        for c in self.ActiveCalls:\n            if c not in calls:\n                return c\n        raise SkypeError(0, 'Placing call failed')", "response": "Places a call to a single user or creates a conference call."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Property(self, ObjectType, ObjectId, PropName, Set=None):\n        return self._Property(ObjectType, ObjectId, PropName, Set)", "response": "Queries or sets the properties of an object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend an API command.", "response": "def SendCommand(self, Command):\n        \"\"\"Sends an API command.\n\n        :Parameters:\n          Command : `Command`\n            Command to send. Use `Command` method to create a command.\n        \"\"\"\n        try:\n            self._Api.send_command(Command)\n        except SkypeAPIError:\n            self.ResetCache()\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates and sends an SMS message.", "response": "def SendSms(self, *TargetNumbers, **Properties):\n        \"\"\"Creates and sends an SMS message.\n\n        :Parameters:\n          TargetNumbers : str\n            One or more target SMS numbers.\n          Properties\n            Message properties. Properties available are same as `SmsMessage` object properties.\n\n        :return: An sms message object. The message is already sent at this point.\n        :rtype: `SmsMessage`\n        \"\"\"\n        sms = self.CreateSms(smsMessageTypeOutgoing, *TargetNumbers)\n        for name, value in Properties.items():\n            if isinstance(getattr(sms.__class__, name, None), property):\n                setattr(sms, name, value)\n            else:\n                raise TypeError('Unknown property: %s' % prop)\n        sms.Send()\n        return sms"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a voicemail to a specified user.", "response": "def SendVoicemail(self, Username):\n        \"\"\"Sends a voicemail to a specified user.\n\n        :Parameters:\n          Username : str\n            Skypename of the user.\n\n        :note: Should return a `Voicemail` object. This is not implemented yet.\n        \"\"\"\n        if self._Api.protocol >= 6:\n            self._DoCommand('CALLVOICEMAIL %s' % Username)\n        else:\n            self._DoCommand('VOICEMAIL %s' % Username)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef User(self, Username=''):\n        if not Username:\n            Username = self.CurrentUserHandle\n        o = User(self, Username)\n        o.OnlineStatus # Test if such a user exists.\n        return o", "response": "Queries a user object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Voicemail(self, Id):\n        o = Voicemail(self, Id)\n        o.Type # Test if such a voicemail exists.\n        return o", "response": "Queries the voicemail object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Connect(self, Username, WaitConnected=False):\n        if WaitConnected:\n            self._Connect_Event = threading.Event()\n            self._Connect_Stream = [None]\n            self._Connect_Username = Username\n            self._Connect_ApplicationStreams(self, self.Streams)\n            self._Owner.RegisterEventHandler('ApplicationStreams', self._Connect_ApplicationStreams)\n            self._Alter('CONNECT', Username)\n            self._Connect_Event.wait()\n            self._Owner.UnregisterEventHandler('ApplicationStreams', self._Connect_ApplicationStreams)\n            try:\n                return self._Connect_Stream[0]\n            finally:\n                del self._Connect_Stream, self._Connect_Event, self._Connect_Username\n        else:\n            self._Alter('CONNECT', Username)", "response": "Connects application to user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef SendDatagram(self, Text, Streams=None):\n        if Streams is None:\n            Streams = self.Streams\n        for s in Streams:\n            s.SendDatagram(Text)", "response": "Sends a datagram to the application streams."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef SendDatagram(self, Text):\n        self.Application._Alter('DATAGRAM', '%s %s' % (self.Handle, tounicode(Text)))", "response": "Sends a datagram to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Write(self, Text):\n        self.Application._Alter('WRITE', '%s %s' % (self.Handle, tounicode(Text)))", "response": "Writes data to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef CreateEvent(self, EventId, Caption, Hint):\n        self._Skype._DoCommand('CREATE EVENT %s CAPTION %s HINT %s' % (tounicode(EventId),\n            quote(tounicode(Caption)), quote(tounicode(Hint))))\n        return PluginEvent(self._Skype, EventId)", "response": "Creates a custom event displayed in Skype s events pane."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating custom menu item in Skype client s Do More menus.", "response": "def CreateMenuItem(self, MenuItemId, PluginContext, CaptionText, HintText=u'', IconPath='', Enabled=True,\n                       ContactType=pluginContactTypeAll, MultipleContacts=False):\n        \"\"\"Creates custom menu item in Skype client's \"Do More\" menus.\n\n        :Parameters:\n          MenuItemId : unicode\n            Unique identifier for the menu item.\n          PluginContext : `enums`.pluginContext*\n            Menu item context. Allows to choose in which client windows will the menu item appear.\n          CaptionText : unicode\n            Caption text.\n          HintText : unicode\n            Hint text (optional). Shown when mouse hoovers over the menu item.\n          IconPath : unicode\n            Path to the icon (optional).\n          Enabled : bool\n            Initial state of the menu item. True by default.\n          ContactType : `enums`.pluginContactType*\n            In case of `enums.pluginContextContact` tells which contacts the menu item should appear\n            for. Defaults to `enums.pluginContactTypeAll`.\n          MultipleContacts : bool\n            Set to True if multiple contacts should be allowed (defaults to False).\n\n        :return: Menu item object.\n        :rtype: `PluginMenuItem`\n        \"\"\"\n        cmd = 'CREATE MENU_ITEM %s CONTEXT %s CAPTION %s ENABLED %s' % (tounicode(MenuItemId), PluginContext,\n            quote(tounicode(CaptionText)), cndexp(Enabled, 'true', 'false'))\n        if HintText:\n            cmd += ' HINT %s' % quote(tounicode(HintText))\n        if IconPath:\n            cmd += ' ICON %s' % quote(path2unicode(IconPath))\n        if MultipleContacts:\n            cmd += ' ENABLE_MULTIPLE_CONTACTS true'\n        if PluginContext == pluginContextContact:\n            cmd += ' CONTACT_TYPE_FILTER %s' % ContactType\n        self._Skype._DoCommand(cmd)\n        return PluginMenuItem(self._Skype, MenuItemId, CaptionText, HintText, Enabled)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Focus(self):\n        self._Skype._Api.allow_focus(self._Skype.Timeout)\n        self._Skype._DoCommand('FOCUS')", "response": "Brings the client window into focus."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef OpenDialog(self, Name, *Params):\n        self._Skype._Api.allow_focus(self._Skype.Timeout)\n        params = filter(None, (str(Name),) + Params)\n        self._Skype._DoCommand('OPEN %s' % tounicode(' '.join(params)))", "response": "Open dialog. Use this method to open dialogs added in newer Skype versions if there is no\n        dedicated method in Skype4Py.\n\n        :Parameters:\n          Name : str\n            Dialog name.\n          Params : unicode\n            One or more optional parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen an IM Message dialog.", "response": "def OpenMessageDialog(self, Username, Text=u''):\n        \"\"\"Opens \"Send an IM Message\" dialog.\n\n        :Parameters:\n          Username : str\n            Message target.\n          Text : unicode\n            Message text.\n        \"\"\"\n        self.OpenDialog('IM', Username, tounicode(Text))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting Skype application. :Parameters: Minimized : bool If True, Skype is started minimized in system tray. Nosplash : bool If True, no splash screen is displayed upon startup.", "response": "def Start(self, Minimized=False, Nosplash=False):\n        \"\"\"Starts Skype application.\n\n        :Parameters:\n          Minimized : bool\n            If True, Skype is started minimized in system tray.\n          Nosplash : bool\n            If True, no splash screen is displayed upon startup.\n        \"\"\"\n        self._Skype._Api.startup(Minimized, Nosplash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts the thread associated with this API object.", "response": "def start(self):\n        \"\"\"\n        Start the thread associated with this API object.\n        Ensure that the call is made no more than once,\n        to avoid raising a RuntimeError.\n        \"\"\"\n        if not self.thread_started:\n            super(SkypeAPI, self).start()\n            self.thread_started = True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nenable multithreading support in Xlib and PyGTK.", "response": "def threads_init(gtk=True):\n    \"\"\"Enables multithreading support in Xlib and PyGTK.\n    See the module docstring for more info.\n    \n    :Parameters:\n      gtk : bool\n        May be set to False to skip the PyGTK module.\n    \"\"\"\n    # enable X11 multithreading\n    x11.XInitThreads()\n    if gtk:\n        from gtk.gdk import threads_init\n        threads_init()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning Skype window ID or None if Skype not running.", "response": "def get_skype(self):\n        \"\"\"Returns Skype window ID or None if Skype not running.\"\"\"\n        skype_inst = x11.XInternAtom(self.disp, '_SKYPE_INSTANCE', True)\n        if not skype_inst:\n            return\n        type_ret = Atom()\n        format_ret = c_int()\n        nitems_ret = c_ulong()\n        bytes_after_ret = c_ulong()\n        winp = pointer(Window())\n        fail = x11.XGetWindowProperty(self.disp, self.win_root, skype_inst,\n                            0, 1, False, 33, byref(type_ret), byref(format_ret),\n                            byref(nitems_ret), byref(bytes_after_ret), byref(winp))\n        if not fail and format_ret.value == 32 and nitems_ret.value == 1:\n            return winp.contents.value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Join(self, Id):\n        #self._Alter('JOIN_CONFERENCE', Id)\n        reply = self._Owner._DoCommand('SET CALL %s JOIN_CONFERENCE %s' % (self.Id, Id),\n            'CALL %s CONF_ID' % self.Id)\n        return Conference(self._Owner, reply.split()[-1])", "response": "Joins with another call to form a conference."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting user avatar picture from file.", "response": "def Avatar(self, Id=1, Set=None):\n        \"\"\"Sets user avatar picture from file.\n\n        :Parameters:\n          Id : int\n            Optional avatar Id.\n          Set : str\n            New avatar file name.\n\n        :deprecated: Use `LoadAvatarFromFile` instead.\n        \"\"\"\n        from warnings import warn\n        warn('Settings.Avatar: Use Settings.LoadAvatarFromFile instead.', DeprecationWarning, stacklevel=2)\n        if Set is None:\n            raise TypeError('Argument \\'Set\\' is mandatory!')\n        self.LoadAvatarFromFile(Set, Id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef LoadAvatarFromFile(self, Filename, AvatarId=1):\n        s = 'AVATAR %s %s' % (AvatarId, path2unicode(Filename))\n        self._Skype._DoCommand('SET %s' % s, s)", "response": "Loads user avatar picture from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef RingTone(self, Id=1, Set=None):\n        if Set is None:\n            return unicode2path(self._Skype._Property('RINGTONE', Id, ''))\n        self._Skype._Property('RINGTONE', Id, '', path2unicode(Set))", "response": "Returns or sets a ringtone."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable or disables a ringtone.", "response": "def RingToneStatus(self, Id=1, Set=None):\n        \"\"\"Enables/disables a ringtone.\n\n        :Parameters:\n          Id : int\n            Ringtone Id\n          Set : bool\n            True/False if the ringtone should be enabled/disabled or None if the current status\n            should be queried.\n\n        :return: Current status if Set=None, None otherwise.\n        :rtype: bool\n        \"\"\"\n        if Set is None:\n            return (self._Skype._Property('RINGTONE', Id, 'STATUS') == 'ON')\n        self._Skype._Property('RINGTONE', Id, 'STATUS', cndexp(Set, 'ON', 'OFF'))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving user avatar picture to file.", "response": "def SaveAvatarToFile(self, Filename, AvatarId=1):\n        \"\"\"Saves user avatar picture to file.\n\n        :Parameters:\n          Filename : str\n            Destination path.\n          AvatarId : int\n            Avatar Id\n        \"\"\"\n        s = 'AVATAR %s %s' % (AvatarId, path2unicode(Filename))\n        self._Skype._DoCommand('GET %s' % s, s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave user avatar to a file.", "response": "def SaveAvatarToFile(self, Filename, AvatarId=1):\n        \"\"\"Saves user avatar to a file.\n\n        :Parameters:\n          Filename : str\n            Destination path.\n          AvatarId : int\n            Avatar Id.\n        \"\"\"\n        s = 'USER %s AVATAR %s %s' % (self.Handle, AvatarId, path2unicode(Filename))\n        self._Owner._DoCommand('GET %s' % s, s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef SetBuddyStatusPendingAuthorization(self, Text=u''):\n        self._Property('BUDDYSTATUS', '%d %s' % (budPendingAuthorization, tounicode(Text)), Cache=False)", "response": "Sets the BuddyStatus property to enums. budPendingAuthorization additionally specifying the authorization text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef StreamWrite(stream, *obj):\n    stream.Write(base64.encodestring(pickle.dumps(obj)))", "response": "Writes Python object to Skype application stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ApplicationReceiving(self, app, streams):\n\n        # we should only proceed if we are in TCP mode\n        if stype != socket.SOCK_STREAM:\n            return\n\n        # handle all streams\n        for stream in streams:\n            # read object from the stream\n            obj = StreamRead(stream)\n            if obj:\n                if obj[0] == cmdData:\n                    # data were received, reroute it to the tunnel based on the tunnel ID\n                    try:\n                        TCPTunnel.threads[obj[1]].send(obj[2])\n                    except KeyError:\n                        pass\n                elif obj[0] == cmdConnect:\n                    # a connection request received, connect the socket\n                    n = obj[1]\n                    sock = socket.socket(type=stype)\n                    try:\n                        sock.connect(addr)\n                        # start the tunnel thread\n                        TCPTunnel(sock, stream, n).start()\n                    except socket.error, e:\n                        # connection failed, send an error report back through the stream\n                        print 'error (%s): %s' % (n, e)\n                        StreamWrite(stream, cmdError, n, tuple(e))\n                        StreamWrite(stream, cmdDisconnect, n)\n                elif obj[0] == cmdDisconnect:\n                    # an disconnection request received, close the tunnel\n                    try:\n                        TCPTunnel.threads[obj[1]].close()\n                    except KeyError:\n                        pass\n                elif obj[0] == cmdError:\n                    # connection failed on the other side, display the error\n                    print 'error (%s): %s' % obj[1:2]", "response": "Called when the list of streams with data ready to be read changes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when a datagram is received over a stream.", "response": "def ApplicationDatagram(self, app, stream, text):\n        \"\"\"Called when a datagram is received over a stream.\"\"\"\n\n        # we should only proceed if we are in UDP mode\n        if stype != socket.SOCK_DGRAM:\n            return\n\n        # decode the data\n        data = base64.decodestring(text)\n\n        # open an UDP socket\n        sock = socket.socket(type=stype)\n\n        # send the data\n        try:\n            sock.sendto(data, addr)\n        except socket.error, e:\n            print 'error: %s' % e"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef chop(s, n=1, d=None):\n\n    spl = s.split(d, n)\n    if len(spl) == n:\n        spl.append(s[:0])\n    if len(spl) != n + 1:\n        raise ValueError('chop: Could not chop %d words from \\'%s\\'' % (n, s))\n    return spl", "response": "Chops initial words from a string and returns a list of n first words and rest of the string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a string or comma - separated ARG = a value or ARG = value2 strings into a dictionary.", "response": "def args2dict(s):\n    \"\"\"Converts a string or comma-separated 'ARG=\"a value\"' or 'ARG=value2' strings\n    into a dictionary.\n\n    :Parameters:\n      s : str or unicode\n        Input string.\n\n    :return: ``{'ARG': 'value'}`` dictionary.\n    :rtype: dict\n    \"\"\"\n\n    d = {}\n    while s:\n        t, s = chop(s, 1, '=')\n        if s.startswith('\"'):\n            # XXX: This function is used to parse strings from Skype. The question is,\n            # how does Skype escape the double-quotes. The code below implements the\n            # VisualBasic technique (\"\" -> \").\n            i = 0\n            while True:\n                i = s.find('\"', i+1)\n                try:\n                    if s[i+1] != '\"':\n                        break\n                    else:\n                        i += 1\n                except IndexError:\n                    break\n            if i > 0:\n                d[t] = s[1:i].replace('\"\"', '\"')\n                if s[i+1:i+3] == ', ':\n                    i += 2\n                s = s[i+1:]\n            else:\n                d[t] = s\n                break\n        else:\n            i = s.find(', ')\n            if i >= 0:\n                d[t] = s[:i]\n                s = s[i+2:]\n            else:\n                d[t] = s\n                break\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall all event handlers defined for given Event.", "response": "def _CallEventHandler(self, Event, *Args, **KwArgs):\n        \"\"\"Calls all event handlers defined for given Event, additional parameters\n        will be passed unchanged to event handlers, all event handlers are fired on\n        separate threads.\n        \n        :Parameters:\n          Event : str\n            Name of the event.\n          Args\n            Positional arguments for the event handlers.\n          KwArgs\n            Keyword arguments for the event handlers.\n        \"\"\"\n        if Event not in self._EventHandlers:\n            raise ValueError('%s is not a valid %s event name' % (Event, self.__class__.__name__))\n        args = map(repr, Args) + ['%s=%s' % (key, repr(value)) for key, value in KwArgs.items()]\n        self.__Logger.debug('calling %s: %s', Event, ', '.join(args))\n        # Get a list of handlers for this event.\n        try:\n            handlers = [self._DefaultEventHandlers[Event]]\n        except KeyError:\n            handlers = []\n        try:\n            handlers.append(getattr(self._EventHandlerObject, Event))\n        except AttributeError:\n            pass\n        handlers.extend(self._EventHandlers[Event])\n        # Proceed only if there are handlers.\n        if handlers:\n            # Get the last thread for this event.\n            after = self._EventThreads.get(Event, None)\n            # Create a new thread, pass the last one to it so it can wait until it is finished.\n            thread = EventSchedulerThread(Event, after, handlers, Args, KwArgs)\n            # Store a weak reference to the new thread for this event.\n            self._EventThreads[Event] = thread\n            # Start the thread.\n            thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef RegisterEventHandler(self, Event, Target):\n        if not callable(Target):\n            raise TypeError('%s is not callable' % repr(Target))\n        if Event not in self._EventHandlers:\n            raise ValueError('%s is not a valid %s event name' % (Event, self.__class__.__name__))\n        if Target in self._EventHandlers[Event]:\n            return False\n        self._EventHandlers[Event].append(Target)\n        self.__Logger.info('registered %s: %s', Event, repr(Target))\n        return True", "response": "Registers any callable as an event handler."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef UnregisterEventHandler(self, Event, Target):\n        if not callable(Target):\n            raise TypeError('%s is not callable' % repr(Target))\n        if Event not in self._EventHandlers:\n            raise ValueError('%s is not a valid %s event name' % (Event, self.__class__.__name__))\n        if Target in self._EventHandlers[Event]:\n            self._EventHandlers[Event].remove(Target)\n            self.__Logger.info('unregistered %s: %s', Event, repr(Target))\n            return True\n        return False", "response": "Unregisters an event handler previously registered with RegisterEventHandler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _SetEventHandlerObject(self, Object):\n        self._EventHandlerObject = Object\n        self.__Logger.info('set object: %s', repr(Object))", "response": "Registers an object as events handler."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _AddEvents(cls, Class):\n        def make_event(event):\n            return property(lambda self: self._GetDefaultEventHandler(event),\n                             lambda self, Value: self._SetDefaultEventHandler(event, Value))\n        for event in dir(Class):\n            if not event.startswith('_'):\n                setattr(cls, 'On%s' % event, make_event(event))\n                cls._EventNames.append(event)", "response": "Adds events based on the attributes of the given class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef AddMembers(self, *Members):\n        self._Alter('ADDMEMBERS', ', '.join([x.Handle for x in Members]))", "response": "Adds new members to the chat."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a chat message.", "response": "def SendMessage(self, MessageText):\n        \"\"\"Sends a chat message.\n\n        :Parameters:\n          MessageText : unicode\n            Message text\n\n        :return: Message object\n        :rtype: `ChatMessage`\n        \"\"\"\n        return ChatMessage(self._Owner, chop(self._Owner._DoCommand('CHATMESSAGE %s %s' % (self.Name,\n            tounicode(MessageText))), 2)[1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef SetPassword(self, Password, Hint=''):\n        if ' ' in Password:\n            raise ValueError('Password mut be one word')\n        self._Alter('SETPASSWORD', '%s %s' % (tounicode(Password), tounicode(Hint)))", "response": "Sets the chat password."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the new role can be applied to the member.", "response": "def CanSetRoleTo(self, Role):\n        \"\"\"Checks if the new role can be applied to the member.\n\n        :Parameters:\n          Role : `enums`.chatMemberRole*\n            New chat member role.\n\n        :return: True if the new role can be applied, False otherwise.\n        :rtype: bool\n        \"\"\"\n        t = self._Owner._Alter('CHATMEMBER', self.Id, 'CANSETROLETO', Role,\n                               'ALTER CHATMEMBER CANSETROLETO')\n        return (chop(t, 1)[-1] == 'TRUE')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Connect(self, Skype):\n        self._Skype = Skype\n        self._Skype.RegisterEventHandler('CallStatus', self._CallStatus)\n        del self._Channels[:]", "response": "Connects this call channel manager instance to Skype."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef CreateApplication(self, ApplicationName=None):\n        if ApplicationName is not None:\n            self.Name = tounicode(ApplicationName)\n        self._App = self._Skype.Application(self.Name)\n        self._Skype.RegisterEventHandler('ApplicationStreams', self._ApplicationStreams)\n        self._Skype.RegisterEventHandler('ApplicationReceiving', self._ApplicationReceiving)\n        self._Skype.RegisterEventHandler('ApplicationDatagram', self._ApplicationDatagram)\n        self._App.Create()\n        self._CallEventHandler('Created', self)", "response": "Creates an application context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a text message over the current channel.", "response": "def SendTextMessage(self, Text):\n        \"\"\"Sends a text message over channel.\n\n        :Parameters:\n          Text : unicode\n            Text to send.\n        \"\"\"\n        if self.Type == cctReliable:\n            self.Stream.Write(Text)\n        elif self.Type == cctDatagram:\n            self.Stream.SendDatagram(Text)\n        else:\n            raise SkypeError(0, 'Cannot send using %s channel type' & repr(self.Type))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef TextToAttachmentStatus(self, Text):\n        conv = {'UNKNOWN': enums.apiAttachUnknown,\n                'SUCCESS': enums.apiAttachSuccess,\n                'PENDING_AUTHORIZATION': enums.apiAttachPendingAuthorization,\n                'REFUSED': enums.apiAttachRefused,\n                'NOT_AVAILABLE': enums.apiAttachNotAvailable,\n                'AVAILABLE': enums.apiAttachAvailable}\n        try:\n            return self._TextTo('api', conv[Text.upper()])\n        except KeyError:\n            raise ValueError('Bad text')", "response": "Converts a unicode unicode\n getTerm unicode unicode"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef TextToBuddyStatus(self, Text):\n        conv = {'UNKNOWN': enums.budUnknown,\n                'NEVER_BEEN_FRIEND': enums.budNeverBeenFriend,\n                'DELETED_FRIEND': enums.budDeletedFriend,\n                'PENDING_AUTHORIZATION': enums.budPendingAuthorization,\n                'FRIEND': enums.budFriend}\n        try:\n            return self._TextTo('bud', conv[Text.upper()])\n        except KeyError:\n            raise ValueError('Bad text')", "response": "Converts unicode unicode\n            to Buddy status code."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a dynamic composite field to the current composite_fields dictionary.", "response": "def add_composite_field(self, name, field):\n        \"\"\"\n        Add a dynamic composite field to the already existing ones and\n        initialize it appropriatly.\n        \"\"\"\n        self.composite_fields[name] = field\n        self._init_composite_field(name, field)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the form instance for the given field name.", "response": "def get_composite_field_value(self, name):\n        \"\"\"\n        Return the form/formset instance for the given field name.\n        \"\"\"\n        field = self.composite_fields[name]\n        if hasattr(field, 'get_form'):\n            return self.forms[name]\n        if hasattr(field, 'get_formset'):\n            return self.formsets[name]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_composite_fields(self):\n        # The base_composite_fields class attribute is the *class-wide*\n        # definition of fields. Because a particular *instance* of the class\n        # might want to alter self.composite_fields, we create\n        # self.composite_fields here by copying base_composite_fields.\n        # Instances should always modify self.composite_fields; they should not\n        # modify base_composite_fields.\n        self.composite_fields = copy.deepcopy(self.base_composite_fields)\n        self.forms = OrderedDict()\n        self.formsets = OrderedDict()\n        for name, field in self.composite_fields.items():\n            self._init_composite_field(name, field)", "response": "Setup the forms and formsets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning the form including all formsets and add errors to the errors dict.", "response": "def full_clean(self):\n        \"\"\"\n        Clean the form, including all formsets and add formset errors to the\n        errors dict. Errors of nested forms and formsets are only included if\n        they actually contain errors.\n        \"\"\"\n        super(SuperFormMixin, self).full_clean()\n        for field_name, composite in self.forms.items():\n            composite.full_clean()\n            if not composite.is_valid() and composite._errors:\n                self._errors[field_name] = ErrorDict(composite._errors)\n        for field_name, composite in self.formsets.items():\n            composite.full_clean()\n            if not composite.is_valid() and composite._errors:\n                self._errors[field_name] = ErrorList(composite._errors)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, commit=True):\n        saved_obj = self.save_form(commit=commit)\n        self.save_forms(commit=commit)\n        self.save_formsets(commit=commit)\n        return saved_obj", "response": "Save the current state of the object to the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves all formsets. If ``commit=False``, it will modify the form's ``save_m2m()`` so that it also calls the formsets' ``save_m2m()`` methods.", "response": "def save_formsets(self, commit=True):\n        \"\"\"\n        Save all formsets. If ``commit=False``, it will modify the form's\n        ``save_m2m()`` so that it also calls the formsets' ``save_m2m()``\n        methods.\n        \"\"\"\n        saved_composites = []\n        for name, composite in self.formsets.items():\n            field = self.composite_fields[name]\n            if hasattr(field, 'save'):\n                field.save(self, name, composite, commit=commit)\n                saved_composites.append(composite)\n\n        self._extend_save_m2m('save_formsets_m2m', saved_composites)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the prefix that is used for the formset.", "response": "def get_prefix(self, form, name):\n        \"\"\"\n        Return the prefix that is used for the formset.\n        \"\"\"\n        return '{form_prefix}{prefix_name}-{field_name}'.format(\n            form_prefix=form.prefix + '-' if form.prefix else '',\n            prefix_name=self.prefix_name,\n            field_name=name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_initial(self, form, name):\n\n        if hasattr(form, 'initial'):\n            return form.initial.get(name, None)\n        return None", "response": "Get the initial data that was passed into the superform for thisCOOKIE."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_kwargs(self, form, name):\n        kwargs = {\n            'prefix': self.get_prefix(form, name),\n            'initial': self.get_initial(form, name),\n        }\n        kwargs.update(self.default_kwargs)\n        return kwargs", "response": "Returns the keyword arguments that are used to instantiate the formset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_form(self, form, name):\n        kwargs = self.get_kwargs(form, name)\n        form_class = self.get_form_class(form, name)\n        composite_form = form_class(\n            data=form.data if form.is_bound else None,\n            files=form.files if form.is_bound else None,\n            **kwargs)\n        return composite_form", "response": "Get an instance of the form."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_kwargs(self, form, name):\n        kwargs = super(ModelFormField, self).get_kwargs(form, name)\n        instance = self.get_instance(form, name)\n        kwargs.setdefault('instance', instance)\n        kwargs.setdefault('empty_permitted', not self.required)\n        return kwargs", "response": "Returns the keyword arguments that are used to instantiate the formset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shall_save(self, form, name, composite_form):\n        if composite_form.empty_permitted and not composite_form.has_changed():\n            return False\n        return True", "response": "Return True if the given form and name shall be saved."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, form, name, composite_form, commit):\n        if self.shall_save(form, name, composite_form):\n            return composite_form.save(commit=commit)\n        return None", "response": "Save the nested form."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef allow_blank(self, form, name):\n        if self.blank is not None:\n            return self.blank\n        model = form._meta.model\n        field = model._meta.get_field(self.get_field_name(form, name))\n        return field.blank", "response": "Allow blank determines if the form might be completely empty."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_formset(self, form, name):\n        kwargs = self.get_kwargs(form, name)\n        formset_class = self.get_formset_class(form, name)\n        formset = formset_class(\n            form.data if form.is_bound else None,\n            form.files if form.is_bound else None,\n            **kwargs)\n        return formset", "response": "Get an instance of the formset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_formset_class(self, form, name):\n        if self.formset_class is not None:\n            return self.formset_class\n        formset_class = inlineformset_factory(\n            self.get_parent_model(form, name),\n            self.get_model(form, name),\n            **self.formset_factory_kwargs)\n        return formset_class", "response": "Returns the formset class that was provided as argument to the the\n            class constructor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_app(self, app, config_prefix='MONGOALCHEMY'):\n\n        self.config_prefix = config_prefix\n        def key(suffix):\n            return '%s_%s' % (config_prefix, suffix)\n\n        if key('DATABASE') not in app.config:\n            raise ImproperlyConfiguredError(\"You should provide a database name \"\n                                            \"(the %s setting).\" % key('DATABASE'))\n\n        uri = _get_mongo_uri(app, key)\n        rs = app.config.get(key('REPLICA_SET'))\n        timezone = None\n        if key('TIMEZONE') in app.config:\n            timezone = pytz.timezone(app.config.get(key('TIMEZONE')))\n        self.session = session.Session.connect(app.config.get(key('DATABASE')),\n                                               safe=app.config.get(key('SAFE_SESSION'),\n                                                                   False),\n                                               timezone = timezone,\n                                               host=uri, replicaSet=rs)\n        self.Document._session = self.session", "response": "This callback can be used to initialize an application for the use with this\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prev(self, error_out=False):\n        return self.query.paginate(self.page - 1, self.per_page, error_out)", "response": "Return a : class : Pagination object for the previous page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, mongo_id):\n        try:\n            return self.filter(self.type.mongo_id == mongo_id).first()\n        except exceptions.BadValueException:\n            return None", "response": "Returns a : class : Document instance from its mongo_id or None if not found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlike get but aborts with 404 if not found instead of returning None", "response": "def get_or_404(self, mongo_id):\n        \"\"\"Like :meth:`get` method but aborts with 404 if not found instead of\n        returning `None`\"\"\"\n        document = self.get(mongo_id)\n        if document is None:\n            abort(404)\n        return document"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a pagination object for the given page.", "response": "def paginate(self, page, per_page=20, error_out=True):\n        \"\"\"Returns ``per_page`` items from page ``page`` By default, it will\n        abort with 404 if no items were found and the page was larger than 1.\n        This behaviour can be disabled by setting ``error_out`` to ``False``.\n\n        Returns a :class:`Pagination` object.\"\"\"\n        if page < 1 and error_out:\n            abort(404)\n\n        items = self.skip((page - 1) * per_page).limit(per_page).all()\n\n        if len(items) < 1 and page != 1 and error_out:\n            abort(404)\n\n        return Pagination(self, page, per_page, self.count(), items)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, safe=None):\n        self._session.insert(self, safe=safe)\n        self._session.flush()", "response": "Saves the document itself in the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self, safe=None):\n        self._session.remove(self, safe=None)\n        self._session.flush()", "response": "Removes the document itself from the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist all authors. e.g.: GET /authors", "response": "def list_authors():\n    \"\"\"List all authors.\n\n    e.g.: GET /authors\"\"\"\n    authors = Author.query.all()\n    content = '<p>Authors:</p>'\n    for author in authors:\n        content += '<p>%s</p>' % author.name\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nformatting this diagnostic for display.", "response": "def format(self, options=None):\n        \"\"\"\n        Format this diagnostic for display. The options argument takes\n        Diagnostic.Display* flags, which can be combined using bitwise OR. If\n        the options argument is not provided, the default display options will\n        be used.\n        \"\"\"\n        if options is None:\n            options = conf.lib.clang_defaultDiagnosticDisplayOptions()\n        if options & ~Diagnostic._FormatOptionsMask:\n            raise ValueError('Invalid format options')\n        return conf.lib.clang_formatDiagnostic(self, options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef name(self):\n        if self._name_map is None:\n            self._name_map = {}\n            for key, value in self.__class__.__dict__.items():\n                if isinstance(value, self.__class__):\n                    self._name_map[value] = key\n        return self._name_map[self]", "response": "Get the enumeration name of this cursor kind."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef spelling(self):\n        if not hasattr(self, '_spelling'):\n            self._spelling = conf.lib.clang_getCursorSpelling(self)\n\n        return self._spelling", "response": "Return the spelling of the entity pointed at by the cursor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the display name for the entity referenced by this cursor.", "response": "def displayname(self):\n        \"\"\"\n        Return the display name for the entity referenced by this cursor.\n\n        The display name contains extra information that helps identify the\n        cursor, such as the parameters of a function or template or the\n        arguments of a class template specialization.\n        \"\"\"\n        if not hasattr(self, '_displayname'):\n            self._displayname = conf.lib.clang_getCursorDisplayName(self)\n\n        return self._displayname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mangled_name(self):\n        if not hasattr(self, '_mangled_name'):\n            self._mangled_name = conf.lib.clang_Cursor_getMangling(self)\n\n        return self._mangled_name", "response": "Return the mangled name for the entity referenced by this cursor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef linkage(self):\n        if not hasattr(self, '_linkage'):\n            self._linkage = conf.lib.clang_getCursorLinkage(self)\n\n        return LinkageKind.from_id(self._linkage)", "response": "Return the linkage of this cursor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef availability(self):\n        if not hasattr(self, '_availability'):\n            self._availability = conf.lib.clang_getCursorAvailability(self)\n\n        return AvailabilityKind.from_id(self._availability)", "response": "Returns the availability of the entity pointed at by the cursor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef objc_type_encoding(self):\n        if not hasattr(self, '_objc_type_encoding'):\n            self._objc_type_encoding = \\\n              conf.lib.clang_getDeclObjCTypeEncoding(self)\n\n        return self._objc_type_encoding", "response": "Return the Objective - C type encoding as a str."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_source(cls, filename, args=None, unsaved_files=None, options=0,\n                    index=None):\n        \"\"\"Create a TranslationUnit by parsing source.\n\n        This is capable of processing source code both from files on the\n        filesystem as well as in-memory contents.\n\n        Command-line arguments that would be passed to clang are specified as\n        a list via args. These can be used to specify include paths, warnings,\n        etc. e.g. [\"-Wall\", \"-I/path/to/include\"].\n\n        In-memory file content can be provided via unsaved_files. This is an\n        iterable of 2-tuples. The first element is the str filename. The\n        second element defines the content. Content can be provided as str\n        source code or as file objects (anything with a read() method). If\n        a file object is being used, content will be read until EOF and the\n        read cursor will not be reset to its original position.\n\n        options is a bitwise or of TranslationUnit.PARSE_XXX flags which will\n        control parsing behavior.\n\n        index is an Index instance to utilize. If not provided, a new Index\n        will be created for this TranslationUnit.\n\n        To parse source from the filesystem, the filename of the file to parse\n        is specified by the filename argument. Or, filename could be None and\n        the args list would contain the filename(s) to parse.\n\n        To parse source from an in-memory buffer, set filename to the virtual\n        filename you wish to associate with this source (e.g. \"test.c\"). The\n        contents of that file are then provided in unsaved_files.\n\n        If an error occurs, a TranslationUnitLoadError is raised.\n\n        Please note that a TranslationUnit with parser errors may be returned.\n        It is the caller's responsibility to check tu.diagnostics for errors.\n\n        Also note that Clang infers the source language from the extension of\n        the input filename. If you pass in source code containing a C++ class\n        declaration with the filename \"test.c\" parsing will fail.\n        \"\"\"\n        if args is None:\n            args = []\n\n        if unsaved_files is None:\n            unsaved_files = []\n\n        if index is None:\n            index = Index.create()\n\n        args_array = None\n        if len(args) > 0:\n            args_array = (c_char_p * len(args))(*[b(x) for x in args])\n\n        unsaved_array = None\n        if len(unsaved_files) > 0:\n            unsaved_array = (_CXUnsavedFile * len(unsaved_files))()\n            for i, (name, contents) in enumerate(unsaved_files):\n                if hasattr(contents, \"read\"):\n                    contents = contents.read()\n\n                unsaved_array[i].name = b(name)\n                unsaved_array[i].contents = b(contents)\n                unsaved_array[i].length = len(contents)\n\n        ptr = conf.lib.clang_parseTranslationUnit(index, filename, args_array,\n                                    len(args), unsaved_array,\n                                    len(unsaved_files), options)\n\n        if not ptr:\n            raise TranslationUnitLoadError(\"Error parsing translation unit.\")\n\n        return cls(ptr, index=index)", "response": "Create a TranslationUnit instance from a source code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing all the files with clang and extracts all relevant nodes from the generated AST.", "response": "def process(self):\n        \"\"\"\n        process processes all the files with clang and extracts all relevant\n        nodes from the generated AST\n        \"\"\"\n\n        self.index = cindex.Index.create()\n        self.headers = {}\n\n        for f in self.files:\n            if f in self.processed:\n                continue\n\n            print('Processing {0}'.format(os.path.basename(f)))\n\n            tu = self.index.parse(f, self.flags)\n\n            if len(tu.diagnostics) != 0:\n                fatal = False\n\n                for d in tu.diagnostics:\n                    sys.stderr.write(d.format())\n                    sys.stderr.write(\"\\n\")\n\n                    if d.severity == cindex.Diagnostic.Fatal or \\\n                       d.severity == cindex.Diagnostic.Error:\n                        fatal = True\n\n                if fatal:\n                    sys.stderr.write(\"\\nCould not generate documentation due to parser errors\\n\")\n                    sys.exit(1)\n\n            if not tu:\n                sys.stderr.write(\"Could not parse file %s...\\n\" % (f,))\n                sys.exit(1)\n\n            # Extract comments from files and included files that we are\n            # supposed to inspect\n            extractfiles = [f]\n\n            for inc in tu.get_includes():\n                filename = str(inc.include)\n                self.headers[filename] = True\n\n                if filename in self.processed or (not filename in self.files) or filename in extractfiles:\n                    continue\n\n                extractfiles.append(filename)\n\n            for e in extractfiles:\n                db = comment.CommentsDatabase(e, tu)\n\n                self.add_categories(db.category_names)\n                self.commentsdbs[e] = db\n\n            self.visit(tu.cursor.get_children())\n\n            for f in self.processing:\n                self.processed[f] = True\n\n            self.processing = {}\n\n        # Construct hierarchy of nodes.\n        for node in self.all_nodes:\n            q = node.qid\n\n            if node.parent is None:\n                par = self.find_parent(node)\n\n                # Lookup categories for things in the root\n                if (par is None or par == self.root) and (not node.cursor is None):\n                    location = node.cursor.extent.start\n                    db = self.commentsdbs[location.file.name]\n\n                    if db:\n                        par = self.category_to_node[db.lookup_category(location)]\n\n                if par is None:\n                    par = self.root\n\n                par.append(node)\n\n            # Resolve comment\n            cm = self.find_node_comment(node)\n\n            if cm:\n                node.merge_comment(cm)\n\n        # Keep track of classes to resolve bases and subclasses\n        classes = {}\n\n        # Map final qid to node\n        for node in self.all_nodes:\n            q = node.qid\n            self.qid_to_node[q] = node\n\n            if isinstance(node, nodes.Class):\n                classes[q] = node\n\n        # Resolve bases and subclasses\n        for qid in classes:\n            classes[qid].resolve_bases(classes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvisiting iterates over the cursor iterator and creates nodes from the AST cursors.", "response": "def visit(self, citer, parent=None):\n        \"\"\"\n        visit iterates over the provided cursor iterator and creates nodes\n        from the AST cursors.\n        \"\"\"\n        if not citer:\n            return\n\n        while True:\n            try:\n                item = next(citer)\n            except StopIteration:\n                return\n\n            # Check the source of item\n            if not item.location.file:\n                self.visit(item.get_children())\n                continue\n\n            # Ignore files we already processed\n            if str(item.location.file) in self.processed:\n                continue\n\n            # Ignore files other than the ones we are scanning for\n            if not str(item.location.file) in self.files:\n                continue\n\n            # Ignore unexposed things\n            if item.kind == cindex.CursorKind.UNEXPOSED_DECL:\n                self.visit(item.get_children(), parent)\n                continue\n\n            self.processing[str(item.location.file)] = True\n\n            if item.kind in self.kindmap:\n                cls = self.kindmap[item.kind]\n\n                if not cls:\n                    # Skip\n                    continue\n\n                # see if we already have a node for this thing\n                node = self.usr_to_node[item.get_usr()]\n\n                if not node or self.is_unique_anon_struct(node, parent):\n                    # Only register new nodes if they are exposed.\n                    if self.cursor_is_exposed(item):\n                        node = cls(item, None)\n                        self.register_node(node, parent)\n\n                elif isinstance(parent, nodes.Typedef) and isinstance(node, nodes.Struct):\n                    # Typedefs are handled a bit specially because what happens\n                    # is that clang first exposes an unnamed struct/enum, and\n                    # then exposes the typedef, with as a child again the\n                    # cursor to the already defined struct/enum. This is a\n                    # bit reversed as to how we normally process things.\n                    self.register_anon_typedef(node, parent)\n                else:\n                    self.cursor_to_node[item] = node\n                    node.add_ref(item)\n\n                if node and node.process_children:\n                    self.visit(item.get_children(), node)\n            else:\n                par = self.cursor_to_node[item.semantic_parent]\n\n                if not par:\n                    par = parent\n\n                if par:\n                    ret = par.visit(item, citer)\n\n                    if not ret is None:\n                        for node in ret:\n                            self.register_node(node, par)\n\n                ignoretop = [cindex.CursorKind.TYPE_REF, cindex.CursorKind.PARM_DECL]\n\n                if (not par or ret is None) and not item.kind in ignoretop:\n                    log.warning(\"Unhandled cursor: %s\", item.kind)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract(self, filename, tu):\n        it = tu.get_tokens(extent=tu.get_extent(filename, (0, int(os.stat(filename).st_size))))\n\n        while True:\n            try:\n                self.extract_loop(it)\n            except StopIteration:\n                break", "response": "extract extracts comments from a translation unit for a given file by looking through all the COMMENT tokens in the TU and then extracting the comments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating namedtuple with default values.", "response": "def defaultsnamedtuple(name, fields, defaults=None):\n    '''\n    Generate namedtuple with default values.\n\n    :param name: name\n    :param fields: iterable with field names\n    :param defaults: iterable or mapping with field defaults\n    :returns: defaultdict with given fields and given defaults\n    :rtype: collections.defaultdict\n    '''\n    nt = collections.namedtuple(name, fields)\n    nt.__new__.__defaults__ = (None,) * len(nt._fields)\n    if isinstance(defaults, collections.Mapping):\n        nt.__new__.__defaults__ = tuple(nt(**defaults))\n    elif defaults:\n        nt.__new__.__defaults__ = tuple(nt(*defaults))\n    return nt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing this Flask extension for given app.", "response": "def init_app(self, app):\n        '''\n        Initialize this Flask extension for given app.\n        '''\n        self.app = app\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n        app.extensions['plugin_manager'] = self\n        self.reload()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreloading the internal state of the internal plugins.", "response": "def reload(self):\n        '''\n        Clear plugin manager state and reload plugins.\n\n        This method will make use of :meth:`clear` and :meth:`load_plugin`,\n        so all internal state will be cleared, and all plugins defined in\n        :data:`self.app.config['plugin_modules']` will be loaded.\n        '''\n        self.clear()\n        for plugin in self.app.config.get('plugin_modules', ()):\n            self.load_plugin(plugin)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_plugin(self, plugin):\n        '''\n        Import plugin by given name, looking at :attr:`namespaces`.\n\n        :param plugin: plugin module name\n        :type plugin: str\n        :raises PluginNotFoundError: if not found on any namespace\n        '''\n        names = [\n            '%s%s%s' % (namespace, '' if namespace[-1] == '_' else '.', plugin)\n            if namespace else\n            plugin\n            for namespace in self.namespaces\n            ]\n\n        for name in names:\n            if name in sys.modules:\n                return sys.modules[name]\n\n        for name in names:\n            try:\n                __import__(name)\n                return sys.modules[name]\n            except (ImportError, KeyError):\n                pass\n\n        raise PluginNotFoundError(\n            'No plugin module %r found, tried %r' % (plugin, names),\n            plugin, names)", "response": "Import plugin by given name looking at namespaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads plugin and register related data.", "response": "def load_plugin(self, plugin):\n        '''\n        Import plugin (see :meth:`import_plugin`) and load related data.\n\n        If available, plugin's module-level :func:`register_plugin` function\n        will be called with current plugin manager instance as first argument.\n\n        :param plugin: plugin module name\n        :type plugin: str\n        :raises PluginNotFoundError: if not found on any namespace\n        '''\n        module = super(RegistrablePluginManager, self).load_plugin(plugin)\n        if hasattr(module, 'register_plugin'):\n            module.register_plugin(self)\n        return module"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_blueprint(self, blueprint):\n        '''\n        Register given blueprint on curren app.\n\n        This method is provided for using inside plugin's module-level\n        :func:`register_plugin` functions.\n\n        :param blueprint: blueprint object with plugin endpoints\n        :type blueprint: flask.Blueprint\n        '''\n        if blueprint not in self._blueprint_known:\n            self.app.register_blueprint(blueprint)\n            self._blueprint_known.add(blueprint)", "response": "Register given blueprint on curren app."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresolves widget callable properties into static ones.", "response": "def _resolve_widget(cls, file, widget):\n        '''\n        Resolve widget callable properties into static ones.\n\n        :param file: file will be used to resolve callable properties.\n        :type file: browsepy.file.Node\n        :param widget: widget instance optionally with callable properties\n        :type widget: object\n        :returns: a new widget instance of the same type as widget parameter\n        :rtype: object\n        '''\n        return widget.__class__(*[\n            value(file) if callable(value) else value\n            for value in widget\n            ])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates registered widgets optionally matching given criteria.", "response": "def iter_widgets(self, file=None, place=None):\n        '''\n        Iterate registered widgets, optionally matching given criteria.\n\n        :param file: optional file object will be passed to widgets' filter\n                     functions.\n        :type file: browsepy.file.Node or None\n        :param place: optional template place hint.\n        :type place: str\n        :yields: widget instances\n        :ytype: object\n        '''\n        for filter, dynamic, cwidget in self._widgets:\n            try:\n                if file and filter and not filter(file):\n                    continue\n            except BaseException as e:\n                # Exception is handled  as this method execution is deffered,\n                # making hard to debug for plugin developers.\n                warnings.warn(\n                    'Plugin action filtering failed with error: %s' % e,\n                    RuntimeWarning\n                    )\n                continue\n            if place and place != cwidget.place:\n                continue\n            if file and dynamic:\n                cwidget = self._resolve_widget(file, cwidget)\n            yield cwidget"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a widget object based on given arguments.", "response": "def create_widget(self, place, type, file=None, **kwargs):\n        '''\n        Create a widget object based on given arguments.\n\n        If file object is provided, callable arguments will be resolved:\n        its return value will be used after calling them with file as first\n        parameter.\n\n        All extra `kwargs` parameters will be passed to widget constructor.\n\n        :param place: place hint where widget should be shown.\n        :type place: str\n        :param type: widget type name as taken from :attr:`widget_types` dict\n                     keys.\n        :type type: str\n        :param file: optional file object for widget attribute resolving\n        :type type: browsepy.files.Node or None\n        :returns: widget instance\n        :rtype: object\n        '''\n        widget_class = self.widget_types.get(type, self.widget_types['base'])\n        kwargs.update(place=place, type=type)\n        try:\n            element = widget_class(**kwargs)\n        except TypeError as e:\n            message = e.args[0] if e.args else ''\n            if (\n              'unexpected keyword argument' in message or\n              'required positional argument' in message\n              ):\n                raise WidgetParameterException(\n                    'type %s; %s; available: %r'\n                    % (type, message, widget_class._fields)\n                    )\n            raise e\n        if file and any(map(callable, element)):\n            return self._resolve_widget(file, element)\n        return element"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_widget(self, place=None, type=None, widget=None, filter=None,\n                        **kwargs):\n        '''\n        Create (see :meth:`create_widget`) or use provided widget and register\n        it.\n\n        This method provides this dual behavior in order to simplify widget\n        creation-registration on an functional single step without sacrifycing\n        the reusability of a object-oriented approach.\n\n        :param place: where widget should be placed. This param conflicts\n                      with `widget` argument.\n        :type place: str or None\n        :param type: widget type name as taken from :attr:`widget_types` dict\n                     keys. This param conflicts with `widget` argument.\n        :type type: str or None\n        :param widget: optional widget object will be used as is. This param\n                       conflicts with both place and type arguments.\n        :type widget: object or None\n        :raises TypeError: if both widget and place or type are provided at\n                           the same time (they're mutually exclusive).\n        :returns: created or given widget object\n        :rtype: object\n        '''\n        if bool(widget) == bool(place or type):\n            raise InvalidArgumentError(\n                'register_widget takes either place and type or widget'\n                )\n        widget = widget or self.create_widget(place, type, **kwargs)\n        dynamic = any(map(callable, widget))\n        self._widgets.append((filter, dynamic, widget))\n        return widget", "response": "Create or use provided widget and register it with the internal list of available widgets."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears plugin manager state.", "response": "def clear(self):\n        '''\n        Clear plugin manager state.\n\n        Registered mimetype functions will be disposed after calling this\n        method.\n        '''\n        self._mimetype_functions = list(self._default_mimetype_functions)\n        super(MimetypePluginManager, self).clear()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_mimetype(self, path):\n        '''\n        Get mimetype of given path calling all registered mime functions (and\n        default ones).\n\n        :param path: filesystem path of file\n        :type path: str\n        :returns: mimetype\n        :rtype: str\n        '''\n        for fnc in self._mimetype_functions:\n            mime = fnc(path)\n            if mime:\n                return mime\n        return mimetype.by_default(path)", "response": "Get mimetype of given path calling all registered mime functions and return the mimetype of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a plugin name extracts its registered_arguments as an iterable of ( args kwargs ) tuples.", "response": "def extract_plugin_arguments(self, plugin):\n        '''\n        Given a plugin name, extracts its registered_arguments as an\n        iterable of (args, kwargs) tuples.\n\n        :param plugin: plugin name\n        :type plugin: str\n        :returns: iterable if (args, kwargs) tuples.\n        :rtype: iterable\n        '''\n        module = self.import_plugin(plugin)\n        if hasattr(module, 'register_arguments'):\n            manager = ArgumentPluginManager()\n            module.register_arguments(manager)\n            return manager._argparse_argkwargs\n        return ()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses given argument list based on registered arguments and given base.", "response": "def load_arguments(self, argv, base=None):\n        '''\n        Process given argument list based on registered arguments and given\n        optional base :class:`argparse.ArgumentParser` instance.\n\n        This method saves processed arguments on itself, and this state won't\n        be lost after :meth:`clean` calls.\n\n        Processed argument state will be available via :meth:`get_argument`\n        method.\n\n        :param argv: command-line arguments (without command itself)\n        :type argv: iterable of str\n        :param base: optional base :class:`argparse.ArgumentParser` instance.\n        :type base: argparse.ArgumentParser or None\n        :returns: argparse.Namespace instance with processed arguments as\n                  given by :meth:`argparse.ArgumentParser.parse_args`.\n        :rtype: argparse.Namespace\n        '''\n        plugin_parser = argparse.ArgumentParser(add_help=False)\n        plugin_parser.add_argument('--plugin', action='append', default=[])\n        parent = base or plugin_parser\n        parser = argparse.ArgumentParser(\n            parents=(parent,),\n            add_help=False,\n            **getattr(parent, 'defaults', {})\n            )\n        plugins = [\n            plugin\n            for plugins in plugin_parser.parse_known_args(argv)[0].plugin\n            for plugin in plugins.split(',')\n            ]\n        for plugin in sorted(set(plugins), key=plugins.index):\n            arguments = self.extract_plugin_arguments(plugin)\n            if arguments:\n                group = parser.add_argument_group('%s arguments' % plugin)\n                for argargs, argkwargs in arguments:\n                    group.add_argument(*argargs, **argkwargs)\n        self._argparse_arguments = parser.parse_args(argv)\n        return self._argparse_arguments"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over the sorting - cookie from cookies dictionary.", "response": "def iter_cookie_browse_sorting(cookies):\n    '''\n    Get sorting-cookie from cookies dictionary.\n\n    :yields: tuple of path and sorting property\n    :ytype: 2-tuple of strings\n    '''\n    try:\n        data = cookies.get('browse-sorting', 'e30=').encode('ascii')\n        for path, prop in json.loads(base64.b64decode(data).decode('utf-8')):\n            yield path, prop\n    except (ValueError, TypeError, KeyError) as e:\n        logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cookie_browse_sorting(path, default):\n    '''\n    Get sorting-cookie data for path of current request.\n\n    :returns: sorting property\n    :rtype: string\n    '''\n    if request:\n        for cpath, cprop in iter_cookie_browse_sorting(request.cookies):\n            if path == cpath:\n                return cprop\n    return default", "response": "Get sorting - cookie data for a given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a function that returns a tuple with sorting gunction and reverse bool", "response": "def browse_sortkey_reverse(prop):\n    '''\n    Get sorting function for directory listing based on given attribute\n    name, with some caveats:\n    * Directories will be first.\n    * If *name* is given, link widget lowercase text will be used istead.\n    * If *size* is given, bytesize will be used.\n\n    :param prop: file attribute name\n    :returns: tuple with sorting gunction and reverse bool\n    :rtype: tuple of a dict and a bool\n    '''\n    if prop.startswith('-'):\n        prop = prop[1:]\n        reverse = True\n    else:\n        reverse = False\n\n    if prop == 'text':\n        return (\n            lambda x: (\n                x.is_directory == reverse,\n                x.link.text.lower() if x.link and x.link.text else x.name\n                ),\n            reverse\n            )\n    if prop == 'size':\n        return (\n            lambda x: (\n                x.is_directory == reverse,\n                x.stats.st_size\n                ),\n            reverse\n            )\n    return (\n        lambda x: (\n            x.is_directory == reverse,\n            getattr(x, prop, None)\n            ),\n        reverse\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stream_template(template_name, **context):\n    '''\n    Some templates can be huge, this function returns an streaming response,\n    sending the content in chunks and preventing from timeout.\n\n    :param template_name: template\n    :param **context: parameters for templates.\n    :yields: HTML strings\n    '''\n    app.update_template_context(context)\n    template = app.jinja_env.get_template(template_name)\n    stream = template.generate(context)\n    return Response(stream_with_context(stream))", "response": "Returns a streaming response with the given template."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary with uppercase keys as keys.", "response": "def gendict(cls, *args, **kwargs):\n        '''\n        Pre-translated key dictionary constructor.\n\n        See :type:`dict` for more info.\n\n        :returns: dictionary with uppercase keys\n        :rtype: dict\n        '''\n        gk = cls.genkey\n        return dict((gk(k), v) for k, v in dict(*args, **kwargs).items())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the next state jump.", "response": "def nearest(self):\n        '''\n        Get the next state jump.\n\n        The next jump is calculated looking at :attr:`current` state\n        and its possible :attr:`jumps` to find the nearest and bigger\n        option in :attr:`pending` data.\n\n        If none is found, the returned next state label will be None.\n\n        :returns: tuple with index, substring and next state label\n        :rtype: tuple\n        '''\n        try:\n            options = self.jumps[self.current]\n        except KeyError:\n            raise KeyError(\n                'Current state %r not defined in %s.jumps.'\n                % (self.current, self.__class__)\n                )\n        offset = len(self.start)\n        index = len(self.pending)\n        if self.streaming:\n            index -= max(map(len, options))\n        key = (index, 1)\n        result = (index, '', None)\n        for amark, anext in options.items():\n            asize = len(amark)\n            aindex = self.pending.find(amark, offset, index + asize)\n            if aindex > -1:\n                index = aindex\n                akey = (aindex, -asize)\n                if akey < key:\n                    key = akey\n                    result = (aindex, amark, anext)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transform(self, data, mark, next):\n        '''\n        Apply the appropriate transformation function on current state data,\n        which is supposed to end at this point.\n\n        It is expected transformation logic makes use of :attr:`start`,\n        :attr:`current` and :attr:`streaming` instance attributes to\n        bettee know the state is being left.\n\n        :param data: string to transform (includes start)\n        :type data: str\n        :param mark: string producing the new state jump\n        :type mark: str\n        :param next: state is about to star, None on finish\n        :type next: str or None\n\n        :returns: transformed data\n        :rtype: str\n        '''\n        method = getattr(self, 'transform_%s' % self.current, None)\n        return method(data, mark, next) if method else data", "response": "Apply the appropriate transformation function on current state data and return the transformed data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef feed(self, data=''):\n        '''\n        Optionally add pending data, switch into streaming mode, and yield\n        result chunks.\n\n        :yields: result chunks\n        :ytype: str\n        '''\n        self.streaming = True\n        self.pending += data\n        for i in self:\n            yield i", "response": "Feed the data into a generator."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nyields the result of the next iteration.", "response": "def finish(self, data=''):\n        '''\n        Optionally add pending data, turn off streaming mode, and yield\n        result chunks, which implies all pending data will be consumed.\n\n        :yields: result chunks\n        :ytype: str\n        '''\n        self.pending += data\n        self.streaming = False\n        for i in self:\n            yield i"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfills the internal tar file with the contents of the current object.", "response": "def fill(self):\n        '''\n        Writes data on internal tarfile instance, which writes to current\n        object, using :meth:`write`.\n\n        As this method is blocking, it is used inside a thread.\n\n        This method is called automatically, on a thread, on initialization,\n        so there is little need to call it manually.\n        '''\n        if self.exclude:\n            exclude = self.exclude\n            ap = functools.partial(os.path.join, self.path)\n            self._tarfile.add(\n                self.path, \"\",\n                filter=lambda info: None if exclude(ap(info.name)) else info\n                )\n        else:\n            self._tarfile.add(self.path, \"\")\n        self._tarfile.close()  # force stream flush\n        self._finished += 1\n        if not self._result.is_set():\n            self._result.set()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite method used by internal tarfile instance to output data. This method blocks tarfile execution once internal buffer is full. As this method is blocking, it is used inside the same thread of :meth:`fill`. :param data: bytes to write to internal buffer :type data: bytes :returns: number of bytes written :rtype: int", "response": "def write(self, data):\n        '''\n        Write method used by internal tarfile instance to output data.\n        This method blocks tarfile execution once internal buffer is full.\n\n        As this method is blocking, it is used inside the same thread of\n        :meth:`fill`.\n\n        :param data: bytes to write to internal buffer\n        :type data: bytes\n        :returns: number of bytes written\n        :rtype: int\n        '''\n        self._add.wait()\n        self._data += data\n        if len(self._data) > self._want:\n            self._add.clear()\n            self._result.set()\n        return len(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads method gets data from internal buffer while releasing locks when needed.", "response": "def read(self, want=0):\n        '''\n        Read method, gets data from internal buffer while releasing\n        :meth:`write` locks when needed.\n\n        The lock usage means it must ran on a different thread than\n        :meth:`fill`, ie. the main thread, otherwise will deadlock.\n\n        The combination of both write and this method running on different\n        threads makes tarfile being streamed on-the-fly, with data chunks being\n        processed and retrieved on demand.\n\n        :param want: number bytes to read, defaults to 0 (all available)\n        :type want: int\n        :returns: tarfile data as bytes\n        :rtype: bytes\n        '''\n        if self._finished:\n            if self._finished == 1:\n                self._finished += 1\n                return \"\"\n            return EOFError(\"EOF reached\")\n\n        # Thread communication\n        self._want = want\n        self._add.set()\n        self._result.wait()\n        self._result.clear()\n\n        if want:\n            data = self._data[:want]\n            self._data = self._data[want:]\n        else:\n            data = self._data\n            self._data = bytes()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isexec(path):\n    '''\n    Check if given path points to an executable file.\n\n    :param path: file path\n    :type path: str\n    :return: True if executable, False otherwise\n    :rtype: bool\n    '''\n    return os.path.isfile(path) and os.access(path, os.X_OK)", "response": "Check if given path points to an executable file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode given path. :param path: path will be decoded if using bytes :type path: bytes or str :param os_name: operative system name, defaults to os.name :type os_name: str :param fs_encoding: current filesystem encoding, defaults to autodetected :type fs_encoding: str :return: decoded path :rtype: str", "response": "def fsdecode(path, os_name=os.name, fs_encoding=FS_ENCODING, errors=None):\n    '''\n    Decode given path.\n\n    :param path: path will be decoded if using bytes\n    :type path: bytes or str\n    :param os_name: operative system name, defaults to os.name\n    :type os_name: str\n    :param fs_encoding: current filesystem encoding, defaults to autodetected\n    :type fs_encoding: str\n    :return: decoded path\n    :rtype: str\n    '''\n    if not isinstance(path, bytes):\n        return path\n    if not errors:\n        use_strict = PY_LEGACY or os_name == 'nt'\n        errors = 'strict' if use_strict else 'surrogateescape'\n    return path.decode(fs_encoding, errors=errors)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencodes given path. :param path: path will be encoded if not using bytes :type path: bytes or str :param os_name: operative system name, defaults to os.name :type os_name: str :param fs_encoding: current filesystem encoding, defaults to autodetected :type fs_encoding: str :return: encoded path :rtype: bytes", "response": "def fsencode(path, os_name=os.name, fs_encoding=FS_ENCODING, errors=None):\n    '''\n    Encode given path.\n\n    :param path: path will be encoded if not using bytes\n    :type path: bytes or str\n    :param os_name: operative system name, defaults to os.name\n    :type os_name: str\n    :param fs_encoding: current filesystem encoding, defaults to autodetected\n    :type fs_encoding: str\n    :return: encoded path\n    :rtype: bytes\n    '''\n    if isinstance(path, bytes):\n        return path\n    if not errors:\n        use_strict = PY_LEGACY or os_name == 'nt'\n        errors = 'strict' if use_strict else 'surrogateescape'\n    return path.encode(fs_encoding, errors=errors)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting current work directory s absolute path.", "response": "def getcwd(fs_encoding=FS_ENCODING, cwd_fnc=os.getcwd):\n    '''\n    Get current work directory's absolute path.\n    Like os.getcwd but garanteed to return an unicode-str object.\n\n    :param fs_encoding: filesystem encoding, defaults to autodetected\n    :type fs_encoding: str\n    :param cwd_fnc: callable used to get the path, defaults to os.getcwd\n    :type cwd_fnc: Callable\n    :return: path\n    :rtype: str\n    '''\n    path = fsdecode(cwd_fnc(), fs_encoding=fs_encoding)\n    return os.path.abspath(path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getdebug(environ=os.environ, true_values=TRUE_VALUES):\n    '''\n    Get if app is expected to be ran in debug mode looking at environment\n    variables.\n\n    :param environ: environment dict-like object\n    :type environ: collections.abc.Mapping\n    :returns: True if debug contains a true-like string, False otherwise\n    :rtype: bool\n    '''\n    return environ.get('DEBUG', '').lower() in true_values", "response": "Returns True if the app is expected to be ran in debug mode False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deprecated(func_or_text, environ=os.environ):\n    '''\n    Decorator used to mark functions as deprecated. It will result in a\n    warning being emmitted hen the function is called.\n\n    Usage:\n\n    >>> @deprecated\n    ... def fnc():\n    ...     pass\n\n    Usage (custom message):\n\n    >>> @deprecated('This is deprecated')\n    ... def fnc():\n    ...     pass\n\n    :param func_or_text: message or callable to decorate\n    :type func_or_text: callable\n    :param environ: optional environment mapping\n    :type environ: collections.abc.Mapping\n    :returns: nested decorator or new decorated function (depending on params)\n    :rtype: callable\n    '''\n    def inner(func):\n        message = (\n            'Deprecated function {}.'.format(func.__name__)\n            if callable(func_or_text) else\n            func_or_text\n            )\n\n        @functools.wraps(func)\n        def new_func(*args, **kwargs):\n            with warnings.catch_warnings():\n                if getdebug(environ):\n                    warnings.simplefilter('always', DeprecationWarning)\n                warnings.warn(message, category=DeprecationWarning,\n                              stacklevel=3)\n            return func(*args, **kwargs)\n        return new_func\n    return inner(func_or_text) if callable(func_or_text) else inner", "response": "A decorator used to mark functions as deprecated."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pathsplit(value, sep=os.pathsep):\n    '''\n    Get enviroment PATH elements as list.\n\n    This function only cares about spliting across OSes.\n\n    :param value: path string, as given by os.environ['PATH']\n    :type value: str\n    :param sep: PATH separator, defaults to os.pathsep\n    :type sep: str\n    :yields: every path\n    :ytype: str\n    '''\n    for part in value.split(sep):\n        if part[:1] == part[-1:] == '\"' or part[:1] == part[-1:] == '\\'':\n            part = part[1:-1]\n        yield part", "response": "Returns a generator that yields all the enviroment PATH elements in the given string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pathparse(value, sep=os.pathsep, os_sep=os.sep):\n    '''\n    Get enviroment PATH directories as list.\n\n    This function cares about spliting, escapes and normalization of paths\n    across OSes.\n\n    :param value: path string, as given by os.environ['PATH']\n    :type value: str\n    :param sep: PATH separator, defaults to os.pathsep\n    :type sep: str\n    :param os_sep: OS filesystem path separator, defaults to os.sep\n    :type os_sep: str\n    :yields: every path\n    :ytype: str\n    '''\n    escapes = []\n    normpath = ntpath.normpath if os_sep == '\\\\' else posixpath.normpath\n    if '\\\\' not in (os_sep, sep):\n        escapes.extend((\n            ('\\\\\\\\', '<ESCAPE-ESCAPE>', '\\\\'),\n            ('\\\\\"', '<ESCAPE-DQUOTE>', '\"'),\n            ('\\\\\\'', '<ESCAPE-SQUOTE>', '\\''),\n            ('\\\\%s' % sep, '<ESCAPE-PATHSEP>', sep),\n            ))\n    for original, escape, unescape in escapes:\n        value = value.replace(original, escape)\n    for part in pathsplit(value, sep=sep):\n        if part[-1:] == os_sep and part != os_sep:\n            part = part[:-1]\n        for original, escape, unescape in escapes:\n            part = part.replace(escape, unescape)\n        yield normpath(fsdecode(part))", "response": "A generator function that returns every path in the given path string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all pathconf variables for given path.", "response": "def pathconf(path,\n             os_name=os.name,\n             isdir_fnc=os.path.isdir,\n             pathconf_fnc=getattr(os, 'pathconf', None),\n             pathconf_names=getattr(os, 'pathconf_names', ())):\n    '''\n    Get all pathconf variables for given path.\n\n    :param path: absolute fs path\n    :type path: str\n    :returns: dictionary containing pathconf keys and their values (both str)\n    :rtype: dict\n    '''\n\n    if pathconf_fnc and pathconf_names:\n        return {key: pathconf_fnc(path, key) for key in pathconf_names}\n    if os_name == 'nt':\n        maxpath = 246 if isdir_fnc(path) else 259  # 260 minus <END>\n    else:\n        maxpath = 255  # conservative sane default\n    return {\n        'PC_PATH_MAX': maxpath,\n        'PC_NAME_MAX': maxpath - len(path),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget command absolute path.", "response": "def which(name,\n          env_path=ENV_PATH,\n          env_path_ext=ENV_PATHEXT,\n          is_executable_fnc=isexec,\n          path_join_fnc=os.path.join,\n          os_name=os.name):\n    '''\n    Get command absolute path.\n\n    :param name: name of executable command\n    :type name: str\n    :param env_path: OS environment executable paths, defaults to autodetected\n    :type env_path: list of str\n    :param is_executable_fnc: callable will be used to detect if path is\n                              executable, defaults to `isexec`\n    :type is_executable_fnc: Callable\n    :param path_join_fnc: callable will be used to join path components\n    :type path_join_fnc: Callable\n    :param os_name: os name, defaults to os.name\n    :type os_name: str\n    :return: absolute path\n    :rtype: str or None\n    '''\n    for path in env_path:\n        for suffix in env_path_ext:\n            exe_file = path_join_fnc(path, name) + suffix\n            if is_executable_fnc(exe_file):\n                return exe_file\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nescapes all special regex characters in pattern.", "response": "def re_escape(pattern, chars=frozenset(\"()[]{}?*+|^$\\\\.-#\")):\n    '''\n    Escape all special regex characters in pattern.\n    Logic taken from regex module.\n\n    :param pattern: regex pattern to escape\n    :type patterm: str\n    :returns: escaped pattern\n    :rtype: str\n    '''\n    escape = '\\\\{}'.format\n    return ''.join(\n        escape(c) if c in chars or c.isspace() else\n        '\\\\000' if c == '\\x00' else c\n        for c in pattern\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_plugin(manager):\n    '''\n    Register blueprints and actions using given plugin manager.\n\n    :param manager: plugin manager\n    :type manager: browsepy.manager.PluginManager\n    '''\n    manager.register_blueprint(player)\n    manager.register_mimetype_function(detect_playable_mimetype)\n\n    # add style tag\n    manager.register_widget(\n        place='styles',\n        type='stylesheet',\n        endpoint='player.static',\n        filename='css/browse.css'\n    )\n\n    # register link actions\n    manager.register_widget(\n        place='entry-link',\n        type='link',\n        endpoint='player.audio',\n        filter=PlayableFile.detect\n    )\n    manager.register_widget(\n        place='entry-link',\n        icon='playlist',\n        type='link',\n        endpoint='player.playlist',\n        filter=PlayListFile.detect\n    )\n\n    # register action buttons\n    manager.register_widget(\n        place='entry-actions',\n        css='play',\n        type='button',\n        endpoint='player.audio',\n        filter=PlayableFile.detect\n    )\n    manager.register_widget(\n        place='entry-actions',\n        css='play',\n        type='button',\n        endpoint='player.playlist',\n        filter=PlayListFile.detect\n    )\n\n    # check argument (see `register_arguments`) before registering\n    if manager.get_argument('player_directory_play'):\n        # register header button\n        manager.register_widget(\n            place='header',\n            type='button',\n            endpoint='player.directory',\n            text='Play directory',\n            filter=PlayableDirectory.detect\n            )", "response": "Register plugin with given plugin manager."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake absolute path relative to an absolute base.", "response": "def relativize_path(path, base, os_sep=os.sep):\n    '''\n    Make absolute path relative to an absolute base.\n\n    :param path: absolute path\n    :type path: str\n    :param base: absolute base path\n    :type base: str\n    :param os_sep: path component separator, defaults to current OS separator\n    :type os_sep: str\n    :return: relative path\n    :rtype: str or unicode\n    :raises OutsideDirectoryBase: if path is not below base\n    '''\n    if not check_base(path, base, os_sep):\n        raise OutsideDirectoryBase(\"%r is not under %r\" % (path, base))\n    prefix_len = len(base)\n    if not base.endswith(os_sep):\n        prefix_len += len(os_sep)\n    return path[prefix_len:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake filesystem absolute path uri relative using given absolute base path.", "response": "def abspath_to_urlpath(path, base, os_sep=os.sep):\n    '''\n    Make filesystem absolute path uri relative using given absolute base path.\n\n    :param path: absolute path\n    :param base: absolute base path\n    :param os_sep: path component separator, defaults to current OS separator\n    :return: relative uri\n    :rtype: str or unicode\n    :raises OutsideDirectoryBase: if resulting path is not below base\n    '''\n    return relativize_path(path, base, os_sep).replace(os_sep, '/')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef urlpath_to_abspath(path, base, os_sep=os.sep):\n    '''\n    Make uri relative path fs absolute using a given absolute base path.\n\n    :param path: relative path\n    :param base: absolute base path\n    :param os_sep: path component separator, defaults to current OS separator\n    :return: absolute path\n    :rtype: str or unicode\n    :raises OutsideDirectoryBase: if resulting path is not below base\n    '''\n    prefix = base if base.endswith(os_sep) else base + os_sep\n    realpath = os.path.abspath(prefix + path.replace('/', os_sep))\n    if check_path(base, realpath) or check_under_base(realpath, base):\n        return realpath\n    raise OutsideDirectoryBase(\"%r is not under %r\" % (realpath, base))", "response": "Make uri relative path fs absolute using a given absolute base path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generic_filename(path):\n    '''\n    Extract filename of given path os-indepently, taking care of known path\n    separators.\n\n    :param path: path\n    :return: filename\n    :rtype: str or unicode (depending on given path)\n    '''\n\n    for sep in common_path_separators:\n        if sep in path:\n            _, path = path.rsplit(sep, 1)\n    return path", "response": "Extract filename of given path os - indepently taking care of known path separators."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncleans restricted characters in a path.", "response": "def clean_restricted_chars(path, restricted_chars=restricted_chars):\n    '''\n    Get path without restricted characters.\n\n    :param path: path\n    :return: path without restricted characters\n    :rtype: str or unicode (depending on given path)\n    '''\n    for character in restricted_chars:\n        path = path.replace(character, '_')\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if given filename is forbidden on current OS or filesystem.", "response": "def check_forbidden_filename(filename,\n                             destiny_os=os.name,\n                             restricted_names=restricted_names):\n    '''\n    Get if given filename is forbidden for current OS or filesystem.\n\n    :param filename:\n    :param destiny_os: destination operative system\n    :param fs_encoding: destination filesystem filename encoding\n    :return: wether is forbidden on given OS (or filesystem) or not\n    :rtype: bool\n    '''\n    return (\n      filename in restricted_names or\n      destiny_os == 'nt' and\n      filename.split('.', 1)[0].upper() in nt_device_names\n      )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_path(path, base, os_sep=os.sep):\n    '''\n    Check if both given paths are equal.\n\n    :param path: absolute path\n    :type path: str\n    :param base: absolute base path\n    :type base: str\n    :param os_sep: path separator, defaults to os.sep\n    :type base: str\n    :return: wether two path are equal or not\n    :rtype: bool\n    '''\n    base = base[:-len(os_sep)] if base.endswith(os_sep) else base\n    return os.path.normcase(path) == os.path.normcase(base)", "response": "Checks if two given paths are equal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if given absolute path is under given base.", "response": "def check_base(path, base, os_sep=os.sep):\n    '''\n    Check if given absolute path is under or given base.\n\n    :param path: absolute path\n    :type path: str\n    :param base: absolute base path\n    :type base: str\n    :param os_sep: path separator, defaults to os.sep\n    :return: wether path is under given base or not\n    :rtype: bool\n    '''\n    return (\n        check_path(path, base, os_sep) or\n        check_under_base(path, base, os_sep)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_under_base(path, base, os_sep=os.sep):\n    '''\n    Check if given absolute path is under given base.\n\n    :param path: absolute path\n    :type path: str\n    :param base: absolute base path\n    :type base: str\n    :param os_sep: path separator, defaults to os.sep\n    :return: wether file is under given base or not\n    :rtype: bool\n    '''\n    prefix = base if base.endswith(os_sep) else base + os_sep\n    return os.path.normcase(path).startswith(os.path.normcase(prefix))", "response": "Check if given absolute path is under given base."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a secure filename for the given path.", "response": "def secure_filename(path, destiny_os=os.name, fs_encoding=compat.FS_ENCODING):\n    '''\n    Get rid of parent path components and special filenames.\n\n    If path is invalid or protected, return empty string.\n\n    :param path: unsafe path, only basename will be used\n    :type: str\n    :param destiny_os: destination operative system (defaults to os.name)\n    :type destiny_os: str\n    :param fs_encoding: fs path encoding (defaults to detected)\n    :type fs_encoding: str\n    :return: filename or empty string\n    :rtype: str\n    '''\n    path = generic_filename(path)\n    path = clean_restricted_chars(\n        path,\n        restricted_chars=(\n            nt_restricted_chars\n            if destiny_os == 'nt' else\n            restricted_chars\n            ))\n    path = path.strip(' .')  # required by nt, recommended for others\n\n    if check_forbidden_filename(path, destiny_os=destiny_os):\n        return ''\n\n    if isinstance(path, bytes):\n        path = path.decode('latin-1', errors=underscore_replace)\n\n    # Decode and recover from filesystem encoding in order to strip unwanted\n    # characters out\n    kwargs = {\n        'os_name': destiny_os,\n        'fs_encoding': fs_encoding,\n        'errors': underscore_replace,\n        }\n    fs_encoded_path = compat.fsencode(path, **kwargs)\n    fs_decoded_path = compat.fsdecode(fs_encoded_path, **kwargs)\n    return fs_decoded_path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef alternative_filename(filename, attempt=None):\n    '''\n    Generates an alternative version of given filename.\n\n    If an number attempt parameter is given, will be used on the alternative\n    name, a random value will be used otherwise.\n\n    :param filename: original filename\n    :param attempt: optional attempt number, defaults to null\n    :return: new filename\n    :rtype: str or unicode\n    '''\n    filename_parts = filename.rsplit(u'.', 2)\n    name = filename_parts[0]\n    ext = ''.join(u'.%s' % ext for ext in filename_parts[1:])\n    if attempt is None:\n        choose = random.choice\n        extra = u' %s' % ''.join(choose(fs_safe_characters) for i in range(8))\n    else:\n        extra = u' (%d)' % attempt\n    return u'%s%s%s' % (name, extra, ext)", "response": "Generates an alternative version of given filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scandir(path, app=None):\n    '''\n    Config-aware scandir. Currently, only aware of ``exclude_fnc``.\n\n    :param path: absolute path\n    :type path: str\n    :param app: flask application\n    :type app: flask.Flask or None\n    :returns: filtered scandir entries\n    :rtype: iterator\n    '''\n    exclude = app and app.config.get('exclude_fnc')\n    if exclude:\n        return (\n            item\n            for item in compat.scandir(path)\n            if not exclude(item.path)\n            )\n    return compat.scandir(path)", "response": "Config - aware scandir. Currently only aware of exclude_fnc."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if current node should be shown False otherwise.", "response": "def is_excluded(self):\n        '''\n        Get if current node shouldn't be shown, using :attt:`app` config's\n        exclude_fnc.\n\n        :returns: True if excluded, False otherwise\n        '''\n        exclude = self.app and self.app.config['exclude_fnc']\n        return exclude and exclude(self.path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of namedtuples containing the widgets that are available for this node.", "response": "def widgets(self):\n        '''\n        List widgets with filter return True for this node (or without filter).\n\n        Remove button is prepended if :property:can_remove returns true.\n\n        :returns: list of widgets\n        :rtype: list of namedtuple instances\n        '''\n        widgets = []\n        if self.can_remove:\n            widgets.append(\n                self.plugin_manager.create_widget(\n                    'entry-actions',\n                    'button',\n                    file=self,\n                    css='remove',\n                    endpoint='remove'\n                    )\n                )\n        return widgets + self.plugin_manager.get_widgets(file=self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef link(self):\n        '''\n        Get last widget with place \"entry-link\".\n\n        :returns: widget on entry-link (ideally a link one)\n        :rtype: namedtuple instance\n        '''\n        link = None\n        for widget in self.widgets:\n            if widget.place == 'entry-link':\n                link = widget\n        return link", "response": "Get last widget with place entry - link."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef can_remove(self):\n        '''\n        Get if current node can be removed based on app config's\n        directory_remove.\n\n        :returns: True if current node can be removed, False otherwise.\n        :rtype: bool\n        '''\n        dirbase = self.app.config[\"directory_remove\"]\n        return bool(dirbase and check_under_base(self.path, dirbase))", "response": "Returns True if current node can be removed based on app config s\n        directory_remove."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parent(self):\n        '''\n        Get parent node if available based on app config's directory_base.\n\n        :returns: parent object if available\n        :rtype: Node instance or None\n        '''\n        if check_path(self.path, self.app.config['directory_base']):\n            return None\n        parent = os.path.dirname(self.path) if self.path else None\n        return self.directory_class(parent, self.app) if parent else None", "response": "Get parent node if available based on app config s directory_base."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ancestors(self):\n        '''\n        Get list of ancestors until app config's directory_base is reached.\n\n        :returns: list of ancestors starting from nearest.\n        :rtype: list of Node objects\n        '''\n        ancestors = []\n        parent = self.parent\n        while parent:\n            ancestors.append(parent)\n            parent = parent.parent\n        return ancestors", "response": "Get list of ancestors until app config s directory_base is reached."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets human - readable last modification date - time.", "response": "def modified(self):\n        '''\n        Get human-readable last modification date-time.\n\n        :returns: iso9008-like date-time string (without timezone)\n        :rtype: str\n        '''\n        try:\n            dt = datetime.datetime.fromtimestamp(self.stats.st_mtime)\n            return dt.strftime('%Y.%m.%d %H:%M:%S')\n        except OSError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_urlpath(cls, path, app=None):\n        '''\n        Alternative constructor which accepts a path as taken from URL and uses\n        the given app or the current app config to get the real path.\n\n        If class has attribute `generic` set to True, `directory_class` or\n        `file_class` will be used as type.\n\n        :param path: relative path as from URL\n        :param app: optional, flask application\n        :return: file object pointing to path\n        :rtype: File\n        '''\n        app = app or current_app\n        base = app.config['directory_base']\n        path = urlpath_to_abspath(path, base)\n        if not cls.generic:\n            kls = cls\n        elif os.path.isdir(path):\n            kls = cls.directory_class\n        else:\n            kls = cls.file_class\n        return kls(path=path, app=app)", "response": "Alternative constructor which accepts a path as taken from URL and uses\n        the given app or current app config to get the real path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_paths(self, current_dir, patterns):\n        pattern = patterns[0]\n        patterns = patterns[1:]\n        has_wildcard = is_pattern(pattern)\n        using_globstar = pattern == \"**\"\n\n        # This avoids os.listdir() for performance\n        if has_wildcard:\n            entries = [x.name for x in scandir(current_dir)]\n        else:\n            entries = [pattern]\n\n        if using_globstar:\n            matching_subdirs = map(lambda x: x[0], walk(current_dir))\n        else:\n            subdirs = [e for e in entries\n                       if os.path.isdir(os.path.join(current_dir, e))]\n            matching_subdirs = match_entries(subdirs, pattern)\n\n        # For terminal globstar, add a pattern for all files in subdirs\n        if using_globstar and not patterns:\n            patterns = ['*']\n\n        if patterns:  # we've still got more directories to traverse\n            for subdir in matching_subdirs:\n                absolute_path = os.path.join(current_dir, subdir)\n                for match in self._find_paths(absolute_path, patterns):\n                    yield match\n\n        else:  # we've got the last pattern\n            if not has_wildcard:\n                entries = [pattern + '.wsp', pattern + '.wsp.gz']\n            files = [e for e in entries\n                     if os.path.isfile(os.path.join(current_dir, e))]\n            matching_files = match_entries(files, pattern + '.*')\n\n            for _basename in matching_files + matching_subdirs:\n                yield os.path.join(current_dir, _basename)", "response": "Recursively generates absolute paths whose components\nAttributeNames underneath current_dir match the corresponding pattern in patterns"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef union_overlapping(intervals):\n    disjoint_intervals = []\n\n    for interval in intervals:\n        if disjoint_intervals and disjoint_intervals[-1].overlaps(interval):\n            disjoint_intervals[-1] = disjoint_intervals[-1].union(interval)\n        else:\n            disjoint_intervals.append(interval)\n\n    return disjoint_intervals", "response": "Union any overlapping intervals in the given set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recurse(query, index):\n    for node in app.store.find(query):\n        if node.is_leaf:\n            index.add(node.path)\n        else:\n            recurse('{0}.*'.format(node.path), index)", "response": "Recursively walk across paths adding leaves to the index as they re found."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the aggregation method of the file at the given path.", "response": "def setAggregationMethod(path, aggregationMethod, xFilesFactor=None):\n  \"\"\"setAggregationMethod(path,aggregationMethod,xFilesFactor=None)\n\npath is a string\naggregationMethod specifies the method to use when propagating data (see ``whisper.aggregationMethods``)\nxFilesFactor specifies the fraction of data points in a propagation interval that must have known values for a propagation to occur.  If None, the existing xFilesFactor in path will not be changed\n\"\"\"\n  fh = None\n  try:\n\n    fh = open(path,'r+b')\n    if LOCK:\n      fcntl.flock( fh.fileno(), fcntl.LOCK_EX )\n\n    packedMetadata = fh.read(metadataSize)\n\n    try:\n      (aggregationType,maxRetention,xff,archiveCount) = struct.unpack(metadataFormat,packedMetadata)\n    except:\n      raise CorruptWhisperFile(\"Unable to read header\", fh.name)\n\n    try:\n      newAggregationType = struct.pack( longFormat, aggregationMethodToType[aggregationMethod] )\n    except KeyError:\n      raise InvalidAggregationMethod(\"Unrecognized aggregation method: %s\" %\n            aggregationMethod)\n\n    if xFilesFactor is not None:\n        #use specified xFilesFactor\n        xff = struct.pack( floatFormat, float(xFilesFactor) )\n    else:\n\t#retain old value\n        xff = struct.pack( floatFormat, xff )\n\n    #repack the remaining header information\n    maxRetention = struct.pack( longFormat, maxRetention )\n    archiveCount = struct.pack(longFormat, archiveCount)\n\n    packedMetadata = newAggregationType + maxRetention + xff + archiveCount\n    fh.seek(0)\n    #fh.write(newAggregationType)\n    fh.write(packedMetadata)\n\n    if AUTOFLUSH:\n      fh.flush()\n      os.fsync(fh.fileno())\n\n      if CACHE_HEADERS and fh.name in __headerCache:\n        del __headerCache[fh.name]\n\n  finally:\n    if fh:\n      fh.close()\n\n  return aggregationTypeToMethod.get(aggregationType, 'average')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate an archiveList. An ArchiveList must: 1. Have at least one archive config. Example: (60, 86400) 2. No archive may be a duplicate of another. 3. Higher precision archives' precision must evenly divide all lower precision archives' precision. 4. Lower precision archives must cover larger time intervals than higher precision archives. 5. Each archive must have at least enough points to consolidate to the next archive Returns True or False", "response": "def validateArchiveList(archiveList):\n  \"\"\" Validates an archiveList.\n  An ArchiveList must:\n  1. Have at least one archive config. Example: (60, 86400)\n  2. No archive may be a duplicate of another.\n  3. Higher precision archives' precision must evenly divide all lower precision archives' precision.\n  4. Lower precision archives must cover larger time intervals than higher precision archives.\n  5. Each archive must have at least enough points to consolidate to the next archive\n\n  Returns True or False\n  \"\"\"\n\n  if not archiveList:\n    raise InvalidConfiguration(\"You must specify at least one archive configuration!\")\n\n  archiveList = sorted(archiveList, key=lambda a: a[0]) #sort by precision (secondsPerPoint)\n\n  for i,archive in enumerate(archiveList):\n    if i == len(archiveList) - 1:\n      break\n\n    nextArchive = archiveList[i+1]\n    if not archive[0] < nextArchive[0]:\n      raise InvalidConfiguration(\"A Whisper database may not configured having\"\n        \"two archives with the same precision (archive%d: %s, archive%d: %s)\" %\n        (i, archive, i + 1, nextArchive))\n\n    if nextArchive[0] % archive[0] != 0:\n      raise InvalidConfiguration(\"Higher precision archives' precision \"\n        \"must evenly divide all lower precision archives' precision \"\n        \"(archive%d: %s, archive%d: %s)\" %\n        (i, archive[0], i + 1, nextArchive[0]))\n\n    retention = archive[0] * archive[1]\n    nextRetention = nextArchive[0] * nextArchive[1]\n\n    if not nextRetention > retention:\n      raise InvalidConfiguration(\"Lower precision archives must cover \"\n        \"larger time intervals than higher precision archives \"\n        \"(archive%d: %s seconds, archive%d: %s seconds)\" %\n        (i, retention, i + 1, nextRetention))\n\n    archivePoints = archive[1]\n    pointsPerConsolidation = nextArchive[0] // archive[0]\n    if not archivePoints >= pointsPerConsolidation:\n      raise InvalidConfiguration(\"Each archive must have at least enough points \"\n        \"to consolidate to the next archive (archive%d consolidates %d of \"\n        \"archive%d's points but it has only %d total points)\" %\n        (i + 1, pointsPerConsolidation, i, archivePoints))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new file in the Whisper file system.", "response": "def create(path,archiveList,xFilesFactor=None,aggregationMethod=None,sparse=False,useFallocate=False):\n  \"\"\"create(path,archiveList,xFilesFactor=0.5,aggregationMethod='average')\n\npath is a string\narchiveList is a list of archives, each of which is of the form (secondsPerPoint,numberOfPoints)\nxFilesFactor specifies the fraction of data points in a propagation interval that must have known values for a propagation to occur\naggregationMethod specifies the function to use when propagating data (see ``whisper.aggregationMethods``)\n\"\"\"\n  # Set default params\n  if xFilesFactor is None:\n    xFilesFactor = 0.5\n  if aggregationMethod is None:\n    aggregationMethod = 'average'\n\n  #Validate archive configurations...\n  validateArchiveList(archiveList)\n\n  #Looks good, now we create the file and write the header\n  if os.path.exists(path):\n    raise InvalidConfiguration(\"File %s already exists!\" % path)\n  fh = None\n  try:\n    fh = open(path,'wb')\n    if LOCK:\n      fcntl.flock( fh.fileno(), fcntl.LOCK_EX )\n\n    aggregationType = struct.pack( longFormat, aggregationMethodToType.get(aggregationMethod, 1) )\n    oldest = max([secondsPerPoint * points for secondsPerPoint,points in archiveList])\n    maxRetention = struct.pack( longFormat, oldest )\n    xFilesFactor = struct.pack( floatFormat, float(xFilesFactor) )\n    archiveCount = struct.pack(longFormat, len(archiveList))\n    packedMetadata = aggregationType + maxRetention + xFilesFactor + archiveCount\n    fh.write(packedMetadata)\n    headerSize = metadataSize + (archiveInfoSize * len(archiveList))\n    archiveOffsetPointer = headerSize\n\n    for secondsPerPoint,points in archiveList:\n      archiveInfo = struct.pack(archiveInfoFormat, archiveOffsetPointer, secondsPerPoint, points)\n      fh.write(archiveInfo)\n      archiveOffsetPointer += (points * pointSize)\n\n    #If configured to use fallocate and capable of fallocate use that, else\n    #attempt sparse if configure or zero pre-allocate if sparse isn't configured.\n    if CAN_FALLOCATE and useFallocate:\n      remaining = archiveOffsetPointer - headerSize\n      fallocate(fh, headerSize, remaining)\n    elif sparse:\n      fh.seek(archiveOffsetPointer - 1)\n      fh.write('\\x00')\n    else:\n      remaining = archiveOffsetPointer - headerSize\n      chunksize = 16384\n      zeroes = b'\\x00' * chunksize\n      while remaining > chunksize:\n        fh.write(zeroes)\n        remaining -= chunksize\n      fh.write(zeroes[:remaining])\n\n    if AUTOFLUSH:\n      fh.flush()\n      os.fsync(fh.fileno())\n  finally:\n    if fh:\n      fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating a file in the formula", "response": "def update(path,value,timestamp=None):\n  \"\"\"update(path,value,timestamp=None)\n\npath is a string\nvalue is a float\ntimestamp is either an int or float\n\"\"\"\n  value = float(value)\n  fh = None\n  try:\n    fh = open(path,'r+b')\n    return file_update(fh, value, timestamp)\n  finally:\n    if fh:\n      fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches returns a tuple of timeInfo and valueList for the file at path", "response": "def fetch(path,fromTime,untilTime=None,now=None):\n  \"\"\"fetch(path,fromTime,untilTime=None)\n\npath is a string\nfromTime is an epoch time\nuntilTime is also an epoch time, but defaults to now.\n\nReturns a tuple of (timeInfo, valueList)\nwhere timeInfo is itself a tuple of (fromTime, untilTime, step)\n\nReturns None if no data can be returned\n\"\"\"\n  fh = None\n  try:\n    fh = open(path,'rb')\n    return file_fetch(fh, fromTime, untilTime, now)\n  finally:\n    if fh:\n      fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __archive_fetch(fh, archive, fromTime, untilTime):\n  fromInterval = int( fromTime - (fromTime % archive['secondsPerPoint']) ) + archive['secondsPerPoint']\n  untilInterval = int( untilTime - (untilTime % archive['secondsPerPoint']) ) + archive['secondsPerPoint']\n  if fromInterval == untilInterval:\n    # Zero-length time range: always include the next point\n    untilInterval += archive['secondsPerPoint']\n  fh.seek(archive['offset'])\n  packedPoint = fh.read(pointSize)\n  (baseInterval,baseValue) = struct.unpack(pointFormat,packedPoint)\n\n  if baseInterval == 0:\n    step = archive['secondsPerPoint']\n    points = (untilInterval - fromInterval) // step\n    timeInfo = (fromInterval,untilInterval,step)\n    valueList = [None] * points\n    return (timeInfo,valueList)\n\n  #Determine fromOffset\n  timeDistance = fromInterval - baseInterval\n  pointDistance = timeDistance // archive['secondsPerPoint']\n  byteDistance = pointDistance * pointSize\n  fromOffset = archive['offset'] + (byteDistance % archive['size'])\n\n  #Determine untilOffset\n  timeDistance = untilInterval - baseInterval\n  pointDistance = timeDistance // archive['secondsPerPoint']\n  byteDistance = pointDistance * pointSize\n  untilOffset = archive['offset'] + (byteDistance % archive['size'])\n\n  #Read all the points in the interval\n  fh.seek(fromOffset)\n  if fromOffset < untilOffset: #If we don't wrap around the archive\n    seriesString = fh.read(untilOffset - fromOffset)\n  else: #We do wrap around the archive, so we need two reads\n    archiveEnd = archive['offset'] + archive['size']\n    seriesString = fh.read(archiveEnd - fromOffset)\n    fh.seek(archive['offset'])\n    seriesString += fh.read(untilOffset - archive['offset'])\n\n  #Now we unpack the series data we just read (anything faster than unpack?)\n  byteOrder,pointTypes = pointFormat[0],pointFormat[1:]\n  points = len(seriesString) // pointSize\n  seriesFormat = byteOrder + (pointTypes * points)\n  unpackedSeries = struct.unpack(seriesFormat, seriesString)\n\n  #And finally we construct a list of values (optimize this!)\n  valueList = [None] * points #pre-allocate entire list for speed\n  currentInterval = fromInterval\n  step = archive['secondsPerPoint']\n\n  for i in xrange(0,len(unpackedSeries),2):\n    pointTime = unpackedSeries[i]\n    if pointTime == currentInterval:\n      pointValue = unpackedSeries[i+1]\n      valueList[i//2] = pointValue #in-place reassignment is faster than append()\n    currentInterval += step\n\n  timeInfo = (fromInterval,untilInterval,step)\n  return (timeInfo,valueList)", "response": "Fetch data from a single archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmerges the data from one whisper file into another.", "response": "def merge(path_from, path_to):\n  \"\"\" Merges the data from one whisper file into another. Each file must have\n  the same archive configuration\n\"\"\"\n  fh_from = open(path_from, 'rb')\n  fh_to = open(path_to, 'rb+')\n  return file_merge(fh_from, fh_to)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef diff(path_from, path_to, ignore_empty = False):\n  fh_from = open(path_from, 'rb')\n  fh_to = open(path_to, 'rb')\n  diffs = file_diff(fh_from, fh_to, ignore_empty)\n  fh_to.close()\n  fh_from.close()\n  return diffs", "response": "Compare two whisper databases."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd data to the time series", "response": "def add_data(self, path, time_info, data, exprs):\n        \"\"\"\n        Stores data before it can be put into a time series\n        \"\"\"\n        # Dont add if empty\n        if not nonempty(data):\n            for d in self.data[path]:\n                if nonempty(d['values']):\n                    return\n\n        # Add data to path\n        for expr in exprs:\n            self.paths[expr].add(path)\n        self.data[path].append({\n            'time_info': time_info,\n            'values': data\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract_variants(pattern):\n    v1, v2 = pattern.find('{'), pattern.find('}')\n    if v1 > -1 and v2 > v1:\n        variations = pattern[v1+1:v2].split(',')\n        variants = [pattern[:v1] + v + pattern[v2+1:] for v in variations]\n    else:\n        variants = [pattern]\n    return list(_deduplicate(variants))", "response": "Extract the variants from a pattern."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_entries(entries, pattern):\n    matching = []\n\n    for variant in expand_braces(pattern):\n        matching.extend(fnmatch.filter(entries, variant))\n\n    return list(_deduplicate(matching))", "response": "A drop - in replacement for fnmatch. filter that supports pattern\n    variants."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expand_braces(pattern):\n    res = set()\n\n    # Used instead of s.strip('{}') because strip is greedy.\n    # We want to remove only ONE leading { and ONE trailing }, if both exist\n    def remove_outer_braces(s):\n        if s[0] == '{' and s[-1] == '}':\n            return s[1:-1]\n        return s\n\n    match = EXPAND_BRACES_RE.search(pattern)\n    if match is not None:\n        sub = match.group(1)\n        v1, v2 = match.span(1)\n        if \",\" in sub:\n            for pat in sub.strip('{}').split(','):\n                subpattern = pattern[:v1] + pat + pattern[v2:]\n                res.update(expand_braces(subpattern))\n        else:\n            subpattern = pattern[:v1] + remove_outer_braces(sub) + pattern[v2:]\n            res.update(expand_braces(subpattern))\n    else:\n        res.add(pattern.replace('\\\\}', '}'))\n\n    return list(res)", "response": "Find the rightmost innermost set of braces and expand its contents recursively."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_host(self, metric):\n        key = self.keyfunc(metric)\n        nodes = []\n        servers = set()\n        for node in self.hash_ring.get_nodes(key):\n            server, instance = node\n            if server in servers:\n                continue\n            servers.add(server)\n            nodes.append(node)\n            if len(servers) >= self.replication_factor:\n                break\n        available = [n for n in nodes if self.is_available(n)]\n        return random.choice(available or nodes)", "response": "Returns the carbon host that has data for the given metric."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over valid finite values in an iterable.", "response": "def safeArgs(args):\n    \"\"\"Iterate over valid, finite values in an iterable.\n\n    Skip any items that are None, NaN, or infinite.\n    \"\"\"\n    return (arg for arg in args\n            if arg is not None and not math.isnan(arg) and not math.isinf(arg))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dataLimits(data, drawNullAsZero=False, stacked=False):\n    missingValues = any(None in series for series in data)\n    finiteData = [series for series in data\n                  if not series.options.get('drawAsInfinite')]\n\n    yMinValue = safeMin(safeMin(series) for series in finiteData)\n\n    if yMinValue is None:\n        # This can only happen if there are no valid, non-infinite data.\n        return (0.0, 1.0)\n\n    if yMinValue > 0.0 and drawNullAsZero and missingValues:\n        yMinValue = 0.0\n\n    if stacked:\n        length = safeMin(len(series) for series in finiteData)\n        sumSeries = []\n\n        for i in range(0, length):\n            sumSeries.append(safeSum(series[i] for series in finiteData))\n        yMaxValue = safeMax(sumSeries)\n    else:\n        yMaxValue = safeMax(safeMax(series) for series in finiteData)\n\n    if yMaxValue < 0.0 and drawNullAsZero and missingValues:\n        yMaxValue = 0.0\n\n    return (yMinValue, yMaxValue)", "response": "Return the range of values in data as yMinValue yMaxValue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the given value in standardized units.", "response": "def format_units(v, step=None, system=\"si\", units=None):\n    \"\"\"Format the given value in standardized units.\n\n    ``system`` is either 'binary' or 'si'\n\n    For more info, see:\n        http://en.wikipedia.org/wiki/SI_prefix\n        http://en.wikipedia.org/wiki/Binary_prefix\n    \"\"\"\n    if v is None:\n        return 0, ''\n\n    for prefix, size in UnitSystems[system]:\n        if condition(v, size, step):\n            v2 = v / size\n            if v2 - math.floor(v2) < 0.00000000001 and v > 1:\n                v2 = float(math.floor(v2))\n            if units:\n                prefix = \"%s%s\" % (prefix, units)\n            return v2, prefix\n\n    if v - math.floor(v) < 0.00000000001 and v > 1:\n        v = float(math.floor(v))\n    if units:\n        prefix = units\n    else:\n        prefix = ''\n    return v, prefix"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that value is a finite number.", "response": "def checkFinite(value, name='value'):\n        \"\"\"Check that value is a finite number.\n\n        If it is, return it. If not, raise GraphError describing the\n        problem, using name in the error message.\n        \"\"\"\n        if math.isnan(value):\n            raise GraphError('Encountered NaN %s' % (name,))\n        elif math.isinf(value):\n            raise GraphError('Encountered infinite %s' % (name,))\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reconcileLimits(self):\n        if self.minValue < self.maxValue:\n            # The limits are already OK.\n            return\n\n        minFixed = (self.minValueSource in ['min'])\n        maxFixed = (self.maxValueSource in ['max', 'limit'])\n\n        if minFixed and maxFixed:\n            raise GraphError('The %s must be less than the %s' %\n                             (self.minValueSource, self.maxValueSource))\n        elif minFixed:\n            self.maxValue = self.minValue + self.chooseDelta(self.minValue)\n        elif maxFixed:\n            self.minValue = self.maxValue - self.chooseDelta(self.maxValue)\n        else:\n            delta = self.chooseDelta(max(abs(self.minValue),\n                                         abs(self.maxValue)))\n            average = (self.minValue + self.maxValue) / 2.0\n            self.minValue = average - delta\n            self.maxValue = average + delta", "response": "Reconciles the limits of the current value with the values of the current value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply the specified settings to the current axis.", "response": "def applySettings(self, axisMin=None, axisMax=None, axisLimit=None):\n        \"\"\"Apply the specified settings to this axis.\n\n        Set self.minValue, self.minValueSource, self.maxValue,\n        self.maxValueSource, and self.axisLimit reasonably based on the\n        parameters provided.\n\n        Arguments:\n\n        axisMin -- a finite number, or None to choose a round minimum\n            limit that includes all of the data.\n\n        axisMax -- a finite number, 'max' to use the maximum value\n            contained in the data, or None to choose a round maximum limit\n            that includes all of the data.\n\n        axisLimit -- a finite number to use as an upper limit on maxValue,\n            or None to impose no upper limit.\n        \"\"\"\n        if axisMin is not None and not math.isnan(axisMin):\n            self.minValueSource = 'min'\n            self.minValue = self.checkFinite(axisMin, 'axis min')\n\n        if axisMax == 'max':\n            self.maxValueSource = 'extremum'\n        elif axisMax is not None and not math.isnan(axisMax):\n            self.maxValueSource = 'max'\n            self.maxValue = self.checkFinite(axisMax, 'axis max')\n\n        if axisLimit is None or math.isnan(axisLimit):\n            self.axisLimit = None\n        elif axisLimit < self.maxValue:\n            self.maxValue = self.checkFinite(axisLimit, 'axis limit')\n            self.maxValueSource = 'limit'\n            # The limit has already been imposed, so there is no need to\n            # remember it:\n            self.axisLimit = None\n        elif math.isinf(axisLimit):\n            # It must be positive infinity, which is the same as no limit:\n            self.axisLimit = None\n        else:\n            # We still need to remember axisLimit to avoid rounding top to\n            # a value larger than axisLimit:\n            self.axisLimit = axisLimit\n\n        self.reconcileLimits()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef makeLabel(self, value):\n        value, prefix = format_units(value, self.step,\n                                     system=self.unitSystem)\n        span, spanPrefix = format_units(self.span, self.step,\n                                        system=self.unitSystem)\n        if prefix:\n            prefix += \" \"\n        if value < 0.1:\n            return \"%g %s\" % (float(value), prefix)\n        elif value < 1.0:\n            return \"%.2f %s\" % (float(value), prefix)\n        if span > 10 or spanPrefix != prefix:\n            if type(value) is float:\n                return \"%.1f %s\" % (value, prefix)\n            else:\n                return \"%d %s\" % (int(value), prefix)\n        elif span > 3:\n            return \"%.1f %s\" % (float(value), prefix)\n        elif span > 0.1:\n            return \"%.2f %s\" % (float(value), prefix)\n        else:\n            return \"%g %s\" % (float(value), prefix)", "response": "Create a label for the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates allowed steps with step < = minStep in increasing order.", "response": "def generateSteps(self, minStep):\n        \"\"\"Generate allowed steps with step >= minStep in increasing order.\"\"\"\n        self.checkFinite(minStep)\n\n        if self.binary:\n            base = 2.0\n            mantissas = [1.0]\n            exponent = math.floor(math.log(minStep, 2) - EPSILON)\n        else:\n            base = 10.0\n            mantissas = [1.0, 2.0, 5.0]\n            exponent = math.floor(math.log10(minStep) - EPSILON)\n\n        while True:\n            multiplier = base ** exponent\n            for mantissa in mantissas:\n                value = mantissa * multiplier\n                if value >= minStep * (1.0 - EPSILON):\n                    yield value\n            exponent += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef computeSlop(self, step, divisor):\n        bottom = step * math.floor(self.minValue / float(step) + EPSILON)\n        top = bottom + step * divisor\n\n        if top >= self.maxValue - EPSILON * step:\n            return max(top - self.maxValue, self.minValue - bottom)\n        else:\n            return None", "response": "Compute the slop that would result from step and divisor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchoosing a nice pretty size for the steps between axis labels.", "response": "def chooseStep(self, divisors=None, binary=False):\n        \"\"\"Choose a nice, pretty size for the steps between axis labels.\n\n        Our main constraint is that the number of divisions must be taken\n        from the divisors list. We pick a number of divisions and a step\n        size that minimizes the amount of whitespace (\"slop\") that would\n        need to be included outside of the range [self.minValue,\n        self.maxValue] if we were to push out the axis values to the next\n        larger multiples of the step size.\n\n        The minimum step that could possibly cover the variance satisfies\n\n            minStep * max(divisors) >= variance\n\n        or\n\n            minStep = variance / max(divisors)\n\n        It's not necessarily possible to cover the variance with a step\n        that size, but we know that any smaller step definitely *cannot*\n        cover it. So we can start there.\n\n        For a sufficiently large step size, it is definitely possible to\n        cover the variance, but at some point the slop will start growing.\n        Let's define the slop to be\n\n            slop = max(minValue - bottom, top - maxValue)\n\n        Then for a given, step size, we know that\n\n            slop >= (1/2) * (step * min(divisors) - variance)\n\n        (the factor of 1/2 is for the best-case scenario that the slop is\n        distributed equally on the two sides of the range). So suppose we\n        already have a choice that yields bestSlop. Then there is no need\n        to choose steps so large that the slop is guaranteed to be larger\n        than bestSlop. Therefore, the maximum step size that we need to\n        consider is\n\n            maxStep = (2 * bestSlop + variance) / min(divisors)\n\n        \"\"\"\n        self.binary = binary\n        if divisors is None:\n            divisors = [4, 5, 6]\n        else:\n            for divisor in divisors:\n                self.checkFinite(divisor, 'divisor')\n                if divisor < 1:\n                    raise GraphError('Divisors must be greater than or equal '\n                                     'to one')\n\n        if self.minValue == self.maxValue:\n            if self.minValue == 0.0:\n                self.maxValue = 1.0\n            elif self.minValue < 0.0:\n                self.minValue *= 1.1\n                self.maxValue *= 0.9\n            else:\n                self.minValue *= 0.9\n                self.maxValue *= 1.1\n\n        variance = self.maxValue - self.minValue\n\n        bestSlop = None\n        bestStep = None\n        for step in self.generateSteps(variance / float(max(divisors))):\n            if (\n                bestSlop is not None and\n                step * min(divisors) >= 2 * bestSlop + variance\n            ):\n                break\n            for divisor in divisors:\n                slop = self.computeSlop(step, divisor)\n                if slop is not None and (bestSlop is None or slop < bestSlop):\n                    bestSlop = slop\n                    bestStep = step\n\n        self.step = bestStep"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a comma - separated list of unique path expressions.", "response": "def formatPathExpressions(seriesList):\n    \"\"\"\n    Returns a comma-separated list of unique path expressions.\n    \"\"\"\n    pathExpressions = sorted(set([s.pathExpression for s in seriesList]))\n    return ','.join(pathExpressions)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nshorts form: sum() This will add metrics together and return the sum at each datapoint. (See integral for a sum over time) Example:: &target=sum(company.server.application*.requestsHandled) This would show the sum of all requests handled per minute (provided requestsHandled are collected once a minute). If metrics with different retention rates are combined, the coarsest metric is graphed, and the sum of the other metrics is averaged for the metrics with finer retention rates.", "response": "def sumSeries(requestContext, *seriesLists):\n    \"\"\"\n    Short form: sum()\n\n    This will add metrics together and return the sum at each datapoint. (See\n    integral for a sum over time)\n\n    Example::\n\n        &target=sum(company.server.application*.requestsHandled)\n\n    This would show the sum of all requests handled per minute (provided\n    requestsHandled are collected once a minute).     If metrics with different\n    retention rates are combined, the coarsest metric is graphed, and the sum\n    of the other metrics is averaged for the metrics with finer retention\n    rates.\n\n    \"\"\"\n    if not seriesLists or not any(seriesLists):\n        return []\n    seriesList, start, end, step = normalize(seriesLists)\n    name = \"sumSeries(%s)\" % formatPathExpressions(seriesList)\n    values = (safeSum(row) for row in zip_longest(*seriesList))\n    series = TimeSeries(name, start, end, step, values)\n    series.pathExpression = name\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsumming the given seriesList with wildcards at the given positions.", "response": "def sumSeriesWithWildcards(requestContext, seriesList, *positions):\n    \"\"\"\n    Call sumSeries after inserting wildcards at the given position(s).\n\n    Example::\n\n        &target=sumSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value,\n                                       1)\n\n    This would be the equivalent of::\n\n        &target=sumSeries(host.*.cpu-user.value)&target=sumSeries(\n            host.*.cpu-system.value)\n\n    \"\"\"\n    newSeries = {}\n    newNames = list()\n\n    for series in seriesList:\n        newname = '.'.join(map(lambda x: x[1],\n                               filter(lambda i: i[0] not in positions,\n                                      enumerate(series.name.split('.')))))\n        if newname in newSeries:\n            newSeries[newname] = sumSeries(requestContext,\n                                           (series, newSeries[newname]))[0]\n        else:\n            newSeries[newname] = series\n            newNames.append(newname)\n        newSeries[newname].name = newname\n\n    return [newSeries[name] for name in newNames]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef averageSeriesWithWildcards(requestContext, seriesList, *positions):\n    matchedList = defaultdict(list)\n    for series in seriesList:\n        newname = '.'.join(map(lambda x: x[1],\n                               filter(lambda i: i[0] not in positions,\n                                      enumerate(series.name.split('.')))))\n        matchedList[newname].append(series)\n    result = []\n    for name in matchedList:\n        [series] = averageSeries(requestContext, (matchedList[name]))\n        series.name = name\n        result.append(series)\n    return result", "response": "Augment a seriesList with wildcards at the given positions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall multiplySeries after inserting wildcards at the given position(s). Example:: &target=multiplySeriesWithWildcards( web.host-[0-7].{avg-response,total-request}.value, 2) This would be the equivalent of:: &target=multiplySeries(web.host-0.{avg-response,total-request}.value) &target=multiplySeries(web.host-1.{avg-response,total-request}.value) ...", "response": "def multiplySeriesWithWildcards(requestContext, seriesList, *position):\n    \"\"\"\n    Call multiplySeries after inserting wildcards at the given position(s).\n\n    Example::\n\n        &target=multiplySeriesWithWildcards(\n            web.host-[0-7].{avg-response,total-request}.value, 2)\n\n    This would be the equivalent of::\n\n        &target=multiplySeries(web.host-0.{avg-response,total-request}.value)\n        &target=multiplySeries(web.host-1.{avg-response,total-request}.value)\n        ...\n    \"\"\"\n    positions = [position] if isinstance(position, int) else position\n\n    newSeries = {}\n    newNames = []\n\n    for series in seriesList:\n        new_name = \".\".join(map(lambda x: x[1],\n                                filter(lambda i: i[0] not in positions,\n                                       enumerate(series.name.split('.')))))\n\n        if new_name in newSeries:\n            [newSeries[new_name]] = multiplySeries(requestContext,\n                                                   (newSeries[new_name],\n                                                    series))\n        else:\n            newSeries[new_name] = series\n            newNames.append(new_name)\n        newSeries[new_name].name = new_name\n    return [newSeries[name] for name in newNames]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a wildcard seriesList. Distills down a set of inputs into the range of the series.", "response": "def rangeOfSeries(requestContext, *seriesLists):\n    \"\"\"\n    Takes a wildcard seriesList.\n    Distills down a set of inputs into the range of the series\n\n    Example::\n\n        &target=rangeOfSeries(Server*.connections.total)\n\n    \"\"\"\n    if not seriesLists or not any(seriesLists):\n        return []\n    seriesList, start, end, step = normalize(seriesLists)\n    name = \"rangeOfSeries(%s)\" % formatPathExpressions(seriesList)\n    values = (safeSubtract(max(row),\n                           min(row)) for row in zip_longest(*seriesList))\n    series = TimeSeries(name, start, end, step, values)\n    series.pathExpression = name\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef percentileOfSeries(requestContext, seriesList, n, interpolate=False):\n    if n <= 0:\n        raise ValueError(\n            'The requested percent is required to be greater than 0')\n\n    if not seriesList:\n        return []\n    name = 'percentileOfSeries(%s,%g)' % (seriesList[0].pathExpression, n)\n    start, end, step = normalize([seriesList])[1:]\n    values = [_getPercentile(row, n, interpolate)\n              for row in zip_longest(*seriesList)]\n    resultSeries = TimeSeries(name, start, end, step, values)\n    resultSeries.pathExpression = name\n    return [resultSeries]", "response": "Returns a single series which is composed of the n - percentile values taken across a wildcard series at each point."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef keepLastValue(requestContext, seriesList, limit=INF):\n    for series in seriesList:\n        series.name = \"keepLastValue(%s)\" % (series.name)\n        series.pathExpression = series.name\n        consecutiveNones = 0\n        for i, value in enumerate(series):\n            series[i] = value\n\n            # No 'keeping' can be done on the first value because we have no\n            # idea what came before it.\n            if i == 0:\n                continue\n\n            if value is None:\n                consecutiveNones += 1\n            else:\n                if 0 < consecutiveNones <= limit:\n                    # If a non-None value is seen before the limit of Nones is\n                    # hit, backfill all the missing datapoints with the last\n                    # known value.\n                    for index in range(i - consecutiveNones, i):\n                        series[index] = series[i - consecutiveNones - 1]\n\n                consecutiveNones = 0\n\n        # If the series ends with some None values, try to backfill a bit to\n        # cover it.\n        if 0 < consecutiveNones <= limit:\n            for index in range(len(series) - consecutiveNones, len(series)):\n                series[index] = series[len(series) - consecutiveNones - 1]\n\n    return seriesList", "response": "Keep the last value in the given seriesList."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninterpolates the given seriesList with the last known value.", "response": "def interpolate(requestContext, seriesList, limit=INF):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, and optionally a limit to the\n    number of 'None' values to skip over. Continues the line with the last\n    received value when gaps ('None' values) appear in your data, rather than\n    breaking your line.\n\n    Example::\n\n        &target=interpolate(Server01.connections.handled)\n        &target=interpolate(Server01.connections.handled, 10)\n    \"\"\"\n    for series in seriesList:\n        series.name = \"interpolate(%s)\" % (series.name)\n        series.pathExpression = series.name\n        consecutiveNones = 0\n        for i, value in enumerate(series):\n            series[i] = value\n\n            # No 'keeping' can be done on the first value because we have no\n            # idea what came before it.\n            if i == 0:\n                continue\n\n            if value is None:\n                consecutiveNones += 1\n            elif consecutiveNones == 0:\n                # Have a value but no need to interpolate\n                continue\n            elif series[i - consecutiveNones - 1] is None:\n                # Have a value but can't interpolate: reset count\n                consecutiveNones = 0\n                continue\n            else:\n                # Have a value and can interpolate. If a non-None value is\n                # seen before the limit of Nones is hit, backfill all the\n                # missing datapoints with the last known value.\n                if consecutiveNones > 0 and consecutiveNones <= limit:\n                    lastIndex = i - consecutiveNones - 1\n                    lastValue = series[lastIndex]\n                    for index in range(i - consecutiveNones, i):\n                        nextValue = lastValue + (index - lastIndex)\n                        nextValue = nextValue * (value - lastValue)\n                        nextValue = nextValue / (consecutiveNones + 1)\n                        series[index] = nextValue\n\n                consecutiveNones = 0\n\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef changed(requestContext, seriesList):\n    for series in seriesList:\n        series.name = series.pathExpression = 'changed(%s)' % series.name\n        previous = None\n        for index, value in enumerate(series):\n            if previous is None:\n                series[index] = 0\n            elif value is not None and previous != value:\n                series[index] = 1\n            else:\n                series[index] = 0\n            previous = value\n    return seriesList", "response": "Takes one metric or a wildcard seriesList.\n    Output 1 when the value changed 0 when the same\nracket"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef divideSeriesLists(requestContext, dividendSeriesList, divisorSeriesList):\n\n    if len(dividendSeriesList) != len(divisorSeriesList):\n        raise ValueError(\"dividendSeriesList and divisorSeriesList argument\\\n                         must have equal length\")\n\n    results = []\n\n    for dividendSeries, divisorSeries in zip(dividendSeriesList,\n                                             divisorSeriesList):\n        name = \"divideSeries(%s,%s)\" % (dividendSeries.name,\n                                        divisorSeries.name)\n        bothSeries = (dividendSeries, divisorSeries)\n        step = reduce(lcm, [s.step for s in bothSeries])\n\n        for s in bothSeries:\n            s.consolidate(step // s.step)\n\n        start = min([s.start for s in bothSeries])\n        end = max([s.end for s in bothSeries])\n        end -= (end - start) % step\n\n        values = (safeDiv(v1, v2) for v1, v2 in zip(*bothSeries))\n\n        quotientSeries = TimeSeries(name, start, end, step, values)\n        results.append(quotientSeries)\n\n    return results", "response": "Divides two lists of time series into two lists of time series."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a dividend metric and a divisor metric and draws the division result. A constant may *not* be passed. To divide by a constant, use the scale() function (which is essentially a multiplication operation) and use the inverse of the dividend. (Division by 8 = multiplication by 1/8 or 0.125) Example:: &target=divideSeries(Series.dividends,Series.divisors)", "response": "def divideSeries(requestContext, dividendSeriesList, divisorSeriesList):\n    \"\"\"\n    Takes a dividend metric and a divisor metric and draws the division result.\n    A constant may *not* be passed. To divide by a constant, use the scale()\n    function (which is essentially a multiplication operation) and use the\n    inverse of the dividend. (Division by 8 = multiplication by 1/8 or 0.125)\n\n    Example::\n\n        &target=divideSeries(Series.dividends,Series.divisors)\n\n\n    \"\"\"\n    if len(divisorSeriesList) == 0:\n        for series in dividendSeriesList:\n            series.name = \"divideSeries(%s,MISSING)\" % series.name\n            series.pathExpression = series.name\n            for i in range(len(series)):\n                series[i] = None\n            return dividendSeriesList\n    if len(divisorSeriesList) > 1:\n        raise ValueError(\n            \"divideSeries second argument must reference exactly 1 series\"\n            \" (got {0})\".format(len(divisorSeriesList)))\n\n    [divisorSeries] = divisorSeriesList\n    results = []\n\n    for dividendSeries in dividendSeriesList:\n        name = \"divideSeries(%s,%s)\" % (dividendSeries.name,\n                                        divisorSeries.name)\n        bothSeries = (dividendSeries, divisorSeries)\n        step = reduce(lcm, [s.step for s in bothSeries])\n\n        for s in bothSeries:\n            s.consolidate(step / s.step)\n\n        start = min([s.start for s in bothSeries])\n        end = max([s.end for s in bothSeries])\n        end -= (end - start) % step\n\n        values = (safeDiv(v1, v2) for v1, v2 in zip_longest(*bothSeries))\n\n        quotientSeries = TimeSeries(name, start, end, step, values)\n        quotientSeries.pathExpression = name\n        results.append(quotientSeries)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking two or more series and multiplies their points.", "response": "def multiplySeries(requestContext, *seriesLists):\n    \"\"\"\n    Takes two or more series and multiplies their points. A constant may not be\n    used. To multiply by a constant, use the scale() function.\n\n    Example::\n\n        &target=multiplySeries(Series.dividends,Series.divisors)\n\n    \"\"\"\n\n    if not seriesLists or not any(seriesLists):\n        return []\n    seriesList, start, end, step = normalize(seriesLists)\n\n    if len(seriesList) == 1:\n        return seriesList\n\n    name = \"multiplySeries(%s)\" % ','.join([s.name for s in seriesList])\n    product = map(lambda x: safeMul(*x), zip_longest(*seriesList))\n    resultSeries = TimeSeries(name, start, end, step, product)\n    resultSeries.pathExpression = name\n    return [resultSeries]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a series of average values and a series of weights and produces a weighted average for all values.", "response": "def weightedAverage(requestContext, seriesListAvg, seriesListWeight, *nodes):\n    \"\"\"\n    Takes a series of average values and a series of weights and\n    produces a weighted average for all values.\n\n    The corresponding values should share one or more zero-indexed nodes.\n\n    Example::\n\n        &target=weightedAverage(*.transactions.mean,*.transactions.count,0)\n        &target=weightedAverage(*.transactions.mean,*.transactions.count,1,3,4)\n\n    \"\"\"\n\n    if isinstance(nodes, int):\n        nodes = [nodes]\n\n    sortedSeries = {}\n\n    for seriesAvg, seriesWeight in zip_longest(\n            seriesListAvg, seriesListWeight):\n        key = ''\n        for node in nodes:\n            key += seriesAvg.name.split(\".\")[node]\n\n        sortedSeries.setdefault(key, {})\n        sortedSeries[key]['avg'] = seriesAvg\n\n        key = ''\n        for node in nodes:\n            key += seriesWeight.name.split(\".\")[node]\n\n        sortedSeries.setdefault(key, {})\n        sortedSeries[key]['weight'] = seriesWeight\n\n    productList = []\n\n    for key in sortedSeries:\n        if 'weight' not in sortedSeries[key]:\n            continue\n        if 'avg' not in sortedSeries[key]:\n            continue\n\n        seriesWeight = sortedSeries[key]['weight']\n        seriesAvg = sortedSeries[key]['avg']\n\n        productValues = [safeMul(val1, val2)\n                         for val1, val2\n                         in zip_longest(seriesAvg, seriesWeight)]\n        name = 'product(%s,%s)' % (seriesWeight.name, seriesAvg.name)\n        productSeries = TimeSeries(name, seriesAvg.start, seriesAvg.end,\n                                   seriesAvg.step, productValues)\n        productSeries.pathExpression = name\n        productList.append(productSeries)\n\n    if not productList:\n        return []\n\n    [sumProducts] = sumSeries(requestContext, productList)\n    [sumWeights] = sumSeries(requestContext, seriesListWeight)\n\n    resultValues = [safeDiv(val1, val2)\n                    for val1, val2 in zip_longest(sumProducts, sumWeights)]\n    name = \"weightedAverage(%s, %s, %s)\" % (\n        ','.join(sorted(set(s.pathExpression for s in seriesListAvg))),\n        ','.join(sorted(set(s.pathExpression for s in seriesListWeight))),\n        ','.join(map(str, nodes)))\n    resultSeries = TimeSeries(name, sumProducts.start, sumProducts.end,\n                              sumProducts.step, resultValues)\n    resultSeries.pathExpression = name\n    return resultSeries"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exponentialMovingAverage(requestContext, seriesList, windowSize):\n    # EMA = C * (current_value) + (1 - C) + EMA\n    # C = 2 / (windowSize + 1)\n\n    # The following was copied from movingAverage, and altered for ema\n    if not seriesList:\n        return []\n    windowInterval = None\n    if isinstance(windowSize, six.string_types):\n        delta = parseTimeOffset(windowSize)\n        windowInterval = abs(delta.seconds + (delta.days * 86400))\n\n    # set previewSeconds and constant based on windowSize string or integer\n    if windowInterval:\n        previewSeconds = windowInterval\n        constant = (float(2) / (int(windowInterval) + 1))\n    else:\n        previewSeconds = max([s.step for s in seriesList]) * int(windowSize)\n        constant = (float(2) / (int(windowSize) + 1))\n\n    # ignore original data and pull new, including our preview\n    # data from earlier is needed to calculate the early results\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    result = []\n\n    for series in previewList:\n        if windowInterval:\n            windowPoints = windowInterval // series.step\n        else:\n            windowPoints = int(windowSize)\n\n        if isinstance(windowSize, six.string_types):\n            newName = 'exponentialMovingAverage(%s,\"%s\")' % (\n                series.name, windowSize)\n        else:\n            newName = \"exponentialMovingAverage(%s,%s)\" % (\n                series.name, windowSize)\n\n        newSeries = TimeSeries(newName, series.start + previewSeconds,\n                               series.end, series.step, [])\n        newSeries.pathExpression = newName\n        window_sum = safeSum(series[:windowPoints]) or 0\n        count = safeLen(series[:windowPoints])\n        ema = safeDiv(window_sum, count)\n        newSeries.append(ema)\n\n        if ema is None:\n            ema = 0.0\n        else:\n            ema = float(ema)\n\n        for i in range(windowPoints, len(series) - 1):\n            if series[i] is not None:\n                ema = (float(constant) * float(series[i]) +\n                       (1 - float(constant)) * float(ema))\n                newSeries.append(round(ema, 3))\n            else:\n                newSeries.append(None)\n\n        result.append(newSeries)\n\n    return result", "response": "Generates an exponential Moving Average for a list of series and a window size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of nodes that can be used to build a moving median of a metric or metric or a wildcard seriesList followed by a number N of datapoints or a time interval.", "response": "def movingMedian(requestContext, seriesList, windowSize):\n    \"\"\"\n    Graphs the moving median of a metric (or metrics) over a fixed number of\n    past points, or a time interval.\n\n    Takes one metric or a wildcard seriesList followed by a number N of\n    datapoints or a quoted string with a length of time like '1hour' or '5min'\n    (See ``from / until`` in the render\\_api_ for examples of time formats).\n    Graphs the median of the preceding datapoints for each point on the graph.\n\n    Example::\n\n        &target=movingMedian(Server.instance01.threads.busy,10)\n        &target=movingMedian(Server.instance*.threads.idle,'5min')\n\n    \"\"\"\n    if not seriesList:\n        return []\n    windowInterval = None\n    if isinstance(windowSize, six.string_types):\n        delta = parseTimeOffset(windowSize)\n        windowInterval = to_seconds(delta)\n\n    if windowInterval:\n        previewSeconds = windowInterval\n    else:\n        previewSeconds = max([s.step for s in seriesList]) * int(windowSize)\n\n    # ignore original data and pull new, including our preview\n    # data from earlier is needed to calculate the early results\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    result = []\n\n    for series in previewList:\n        if windowInterval:\n            windowPoints = windowInterval // series.step\n        else:\n            windowPoints = int(windowSize)\n\n        if isinstance(windowSize, six.string_types):\n            newName = 'movingMedian(%s,\"%s\")' % (series.name, windowSize)\n        else:\n            newName = \"movingMedian(%s,%s)\" % (series.name, windowSize)\n        newSeries = TimeSeries(newName, series.start + previewSeconds,\n                               series.end, series.step, [])\n        newSeries.pathExpression = newName\n\n        for i in range(windowPoints, len(series)):\n            window = series[i - windowPoints:i]\n            nonNull = [v for v in window if v is not None]\n            if nonNull:\n                m_index = len(nonNull) // 2\n                newSeries.append(sorted(nonNull)[m_index])\n            else:\n                newSeries.append(None)\n        result.append(newSeries)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes one metric or a wildcard seriesList followed by a constant and multiplies the datapoint by the constant provided at each point.", "response": "def scale(requestContext, seriesList, factor):\n    \"\"\"\n    Takes one metric or a wildcard seriesList followed by a constant, and\n    multiplies the datapoint by the constant provided at each point.\n\n    Example::\n\n        &target=scale(Server.instance01.threads.busy,10)\n        &target=scale(Server.instance*.threads.busy,10)\n\n    \"\"\"\n    for series in seriesList:\n        series.name = \"scale(%s,%g)\" % (series.name, float(factor))\n        series.pathExpression = series.name\n        for i, value in enumerate(series):\n            series[i] = safeMul(value, factor)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscales the values of a seriesList to a number of seconds.", "response": "def scaleToSeconds(requestContext, seriesList, seconds):\n    \"\"\"\n    Takes one metric or a wildcard seriesList and returns \"value per seconds\"\n    where seconds is a last argument to this functions.\n\n    Useful in conjunction with derivative or integral function if you want\n    to normalize its result to a known resolution for arbitrary retentions\n    \"\"\"\n\n    for series in seriesList:\n        series.name = \"scaleToSeconds(%s,%d)\" % (series.name, seconds)\n        series.pathExpression = series.name\n        factor = seconds * 1.0 / series.step\n        for i, value in enumerate(series):\n            series[i] = safeMul(value, factor)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking one metric or a wildcard seriesList followed by a constant and raises the datapoint by the power of the constant provided at each point.", "response": "def pow(requestContext, seriesList, factor):\n    \"\"\"\n    Takes one metric or a wildcard seriesList followed by a constant, and\n    raises the datapoint by the power of the constant provided at each point.\n\n    Example::\n\n        &target=pow(Server.instance01.threads.busy,10)\n        &target=pow(Server.instance*.threads.busy,10)\n\n    \"\"\"\n    for series in seriesList:\n        series.name = \"pow(%s,%g)\" % (series.name, float(factor))\n        series.pathExpression = series.name\n        for i, value in enumerate(series):\n            series[i] = safePow(value, factor)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake two or more series and pows their points. A constant line may be be used.", "response": "def powSeries(requestContext, *seriesLists):\n    \"\"\"\n    Takes two or more series and pows their points. A constant line may be\n    used.\n\n    Example::\n\n        &target=powSeries(Server.instance01.app.requests,\n                          Server.instance01.app.replies)\n\n    \"\"\"\n    if not seriesLists or not any(seriesLists):\n        return []\n    seriesList, start, end, step = normalize(seriesLists)\n    name = \"powSeries(%s)\" % ','.join([s.name for s in seriesList])\n    values = []\n    for row in zip_longest(*seriesList):\n        first = True\n        tmpVal = None\n        for element in row:\n            # If it is a first iteration - tmpVal needs to be element\n            if first:\n                tmpVal = element\n                first = False\n            else:\n                tmpVal = safePow(tmpVal, element)\n        values.append(tmpVal)\n    series = TimeSeries(name, start, end, step, values)\n    series.pathExpression = name\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes one metric or a wildcard seriesList and computes the square root of each datapoint.", "response": "def squareRoot(requestContext, seriesList):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, and computes the square root\n    of each datapoint.\n\n    Example::\n\n        &target=squareRoot(Server.instance01.threads.busy)\n\n    \"\"\"\n    for series in seriesList:\n        series.name = \"squareRoot(%s)\" % (series.name)\n        for i, value in enumerate(series):\n            series[i] = safePow(value, 0.5)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes one metric or a wildcard seriesList and applies the mathematical abs function to each datapoint transforming it to its absolute value.", "response": "def absolute(requestContext, seriesList):\n    \"\"\"\n    Takes one metric or a wildcard seriesList and applies the mathematical abs\n    function to each datapoint transforming it to its absolute value.\n\n    Example::\n\n        &target=absolute(Server.instance01.threads.busy)\n        &target=absolute(Server.instance*.threads.busy)\n    \"\"\"\n    for series in seriesList:\n        series.name = \"absolute(%s)\" % (series.name)\n        series.pathExpression = series.name\n        for i, value in enumerate(series):\n            series[i] = safeAbs(value)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef offset(requestContext, seriesList, factor):\n    for series in seriesList:\n        series.name = \"offset(%s,%g)\" % (series.name, float(factor))\n        series.pathExpression = series.name\n        for i, value in enumerate(series):\n            if value is not None:\n                series[i] = value + factor\n    return seriesList", "response": "Adds a constant to each datapoint in seriesList and returns the seriesList with the given factor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noffset a metric or wildcard seriesList by subtracting the minimum value in each datapoint.", "response": "def offsetToZero(requestContext, seriesList):\n    \"\"\"\n    Offsets a metric or wildcard seriesList by subtracting the minimum\n    value in the series from each datapoint.\n\n    Useful to compare different series where the values in each series\n    may be higher or lower on average but you're only interested in the\n    relative difference.\n\n    An example use case is for comparing different round trip time\n    results. When measuring RTT (like pinging a server), different\n    devices may come back with consistently different results due to\n    network latency which will be different depending on how many\n    network hops between the probe and the device. To compare different\n    devices in the same graph, the network latency to each has to be\n    factored out of the results. This is a shortcut that takes the\n    fastest response (lowest number in the series) and sets that to zero\n    and then offsets all of the other datapoints in that series by that\n    amount. This makes the assumption that the lowest response is the\n    fastest the device can respond, of course the more datapoints that\n    are in the series the more accurate this assumption is.\n\n    Example::\n\n        &target=offsetToZero(Server.instance01.responseTime)\n        &target=offsetToZero(Server.instance*.responseTime)\n\n    \"\"\"\n    for series in seriesList:\n        series.name = \"offsetToZero(%s)\" % (series.name)\n        minimum = safeMin(series)\n        for i, value in enumerate(series):\n            if value is not None:\n                series[i] = value - minimum\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef movingAverage(requestContext, seriesList, windowSize):\n    if not seriesList:\n        return []\n    windowInterval = None\n    if isinstance(windowSize, six.string_types):\n        delta = parseTimeOffset(windowSize)\n        windowInterval = to_seconds(delta)\n\n    if windowInterval:\n        previewSeconds = windowInterval\n    else:\n        previewSeconds = max([s.step for s in seriesList]) * int(windowSize)\n\n    # ignore original data and pull new, including our preview\n    # data from earlier is needed to calculate the early results\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    result = []\n\n    for series in previewList:\n        if windowInterval:\n            windowPoints = windowInterval // series.step\n        else:\n            windowPoints = int(windowSize)\n\n        if isinstance(windowSize, six.string_types):\n            newName = 'movingAverage(%s,\"%s\")' % (series.name, windowSize)\n        else:\n            newName = \"movingAverage(%s,%s)\" % (series.name, windowSize)\n        newSeries = TimeSeries(newName, series.start + previewSeconds,\n                               series.end, series.step, [])\n        newSeries.pathExpression = newName\n\n        windowSum = safeSum(series[:windowPoints]) or 0\n        count = safeLen(series[:windowPoints])\n        newSeries.append(safeDiv(windowSum, count))\n        for n, last in enumerate(series[windowPoints:-1]):\n            if series[n] is not None:\n                windowSum -= series[n]\n                count -= 1\n            if last is not None:\n                windowSum += last\n                count += 1\n            newSeries.append(safeDiv(windowSum, count))\n\n        result.append(newSeries)\n\n    return result", "response": "Returns a list of nodes that can be used to calculate the moving average of a metric or metric or metric at a fixed number of points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef movingSum(requestContext, seriesList, windowSize):\n    if not seriesList:\n        return []\n    windowInterval = None\n    if isinstance(windowSize, six.string_types):\n        delta = parseTimeOffset(windowSize)\n        windowInterval = abs(delta.seconds + (delta.days * 86400))\n\n    if windowInterval:\n        previewSeconds = windowInterval\n    else:\n        previewSeconds = max([s.step for s in seriesList]) * int(windowSize)\n\n    # ignore original data and pull new, including our preview\n    # data from earlier is needed to calculate the early results\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    result = []\n\n    for series in previewList:\n        if windowInterval:\n            windowPoints = windowInterval // series.step\n        else:\n            windowPoints = int(windowSize)\n\n        if isinstance(windowSize, six.string_types):\n            newName = 'movingSum(%s,\"%s\")' % (series.name, windowSize)\n        else:\n            newName = \"movingSum(%s,%s)\" % (series.name, windowSize)\n\n        newSeries = TimeSeries(newName, series.start + previewSeconds,\n                               series.end, series.step, [])\n        newSeries.pathExpression = newName\n\n        window_sum = safeSum(series[:windowPoints])\n        newSeries.append(window_sum)\n        for n, last in enumerate(series[windowPoints:-1]):\n            if series[n] is not None:\n                window_sum -= series[n]\n            if last is not None:\n                window_sum = (window_sum or 0) + last\n            newSeries.append(window_sum)\n\n        result.append(newSeries)\n\n    return result", "response": "Returns a list of all the moving sums of a metric or metric or a wildcard seriesList followed by a number N of datapoints or a time interval."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of time series that can be moved over a fixed number of points or a wildcard seriesList followed by a time interval.", "response": "def movingMax(requestContext, seriesList, windowSize):\n    \"\"\"\n    Graphs the moving maximum of a metric (or metrics) over a fixed number of\n    past points, or a time interval.\n\n    Takes one metric or a wildcard seriesList followed by a number N of\n    datapoints or a quoted string with a length of time like '1hour' or '5min'\n    (See ``from / until`` in the render\\_api_ for examples of time formats).\n    Graphs the maximum of the preceeding datapoints for each point on the\n    graph.\n\n    Example::\n\n      &target=movingMax(Server.instance01.requests,10)\n      &target=movingMax(Server.instance*.errors,'5min')\n\n    \"\"\"\n    if not seriesList:\n        return []\n    windowInterval = None\n    if isinstance(windowSize, six.string_types):\n        delta = parseTimeOffset(windowSize)\n        windowInterval = abs(delta.seconds + (delta.days * 86400))\n\n    if windowInterval:\n        previewSeconds = windowInterval\n    else:\n        previewSeconds = max([s.step for s in seriesList]) * int(windowSize)\n\n    # ignore original data and pull new, including our preview\n    # data from earlier is needed to calculate the early results\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    result = []\n\n    for series in previewList:\n        if windowInterval:\n            windowPoints = windowInterval // series.step\n        else:\n            windowPoints = int(windowSize)\n\n        if isinstance(windowSize, six.string_types):\n            newName = 'movingMax(%s,\"%s\")' % (series.name, windowSize)\n        else:\n            newName = \"movingMax(%s,%s)\" % (series.name, windowSize)\n\n        newSeries = TimeSeries(newName, series.start + previewSeconds,\n                               series.end, series.step, [])\n        newSeries.pathExpression = newName\n        for i in range(windowPoints, len(series)):\n            window = series[i - windowPoints:i]\n            newSeries.append(safeMax(window))\n\n        result.append(newSeries)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef consolidateBy(requestContext, seriesList, consolidationFunc):\n    for series in seriesList:\n        # datalib will throw an exception, so it's not necessary to validate\n        # here\n        series.consolidationFunc = consolidationFunc\n        series.name = 'consolidateBy(%s,\"%s\")' % (series.name,\n                                                  series.consolidationFunc)\n        series.pathExpression = series.name\n    return seriesList", "response": "This function is used to consolidate the values of one metric or a wildcard seriesList."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delay(requestContext, seriesList, steps):\n    results = []\n    for series in seriesList:\n        newValues = []\n        prev = []\n        for val in series:\n            if len(prev) < steps:\n                newValues.append(None)\n                prev.append(val)\n                continue\n            newValues.append(prev.pop(0))\n            prev.append(val)\n        newName = \"delay(%s,%d)\" % (series.name, steps)\n        newSeries = TimeSeries(newName, series.start, series.end, series.step,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n    return results", "response": "This function takes a list of series and returns a list of new time - displacement series that will be shifted later by an integer number of steps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef integral(requestContext, seriesList):\n    results = []\n    for series in seriesList:\n        newValues = []\n        current = 0.0\n        for val in series:\n            if val is None:\n                newValues.append(None)\n            else:\n                current += val\n                newValues.append(current)\n        newName = \"integral(%s)\" % series.name\n        newSeries = TimeSeries(newName, series.start, series.end, series.step,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n    return results", "response": "This function is used to add a series to the graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef integralByInterval(requestContext, seriesList, intervalUnit):\n    intervalDuration = int(to_seconds(parseTimeOffset(intervalUnit)))\n    startTime = int(epoch(requestContext['startTime']))\n    results = []\n    for series in seriesList:\n        newValues = []\n        # current time within series iteration\n        currentTime = series.start\n        # current accumulated value\n        current = 0.0\n        for val in series:\n            # reset integral value if crossing an interval boundary\n            if (\n                ((currentTime - startTime) // intervalDuration) !=\n                ((currentTime - startTime - series.step) // intervalDuration)\n            ):\n                current = 0.0\n            if val is None:\n                # keep previous value since val can be None when resetting\n                # current to 0.0\n                newValues.append(current)\n            else:\n                current += val\n                newValues.append(current)\n            currentTime += series.step\n        newName = \"integralByInterval(%s,'%s')\" % (series.name, intervalUnit)\n        newSeries = TimeSeries(newName, series.start, series.end, series.step,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n    return results", "response": "This function is used to integrate a list of seriesList by a given interval."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes one metric or a wildcard seriesList and creates a new series that is stacked.", "response": "def stacked(requestContext, seriesLists, stackName='__DEFAULT__'):\n    \"\"\"\n    Takes one metric or a wildcard seriesList and change them so they are\n    stacked. This is a way of stacking just a couple of metrics without having\n    to use the stacked area mode (that stacks everything). By means of this a\n    mixed stacked and non stacked graph can be made\n\n    It can also take an optional argument with a name of the stack, in case\n    there is more than one, e.g. for input and output metrics.\n\n    Example::\n\n        &target=stacked(company.server.application01.ifconfig.TXPackets, 'tx')\n\n    \"\"\"\n    if 'totalStack' in requestContext:\n        totalStack = requestContext['totalStack'].get(stackName, [])\n    else:\n        requestContext['totalStack'] = {}\n        totalStack = []\n    results = []\n    for series in seriesLists:\n        newValues = []\n        for i in range(len(series)):\n            if len(totalStack) <= i:\n                totalStack.append(0)\n\n            if series[i] is not None:\n                totalStack[i] += series[i]\n                newValues.append(totalStack[i])\n            else:\n                newValues.append(None)\n\n        # Work-around for the case when legend is set\n        if stackName == '__DEFAULT__':\n            newName = \"stacked(%s)\" % series.name\n        else:\n            newName = series.name\n\n        newSeries = TimeSeries(newName, series.start, series.end, series.step,\n                               newValues)\n        newSeries.options['stacked'] = True\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n    requestContext['totalStack'][stackName] = totalStack\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the vertical area in between the two series in seriesList.", "response": "def areaBetween(requestContext, *seriesLists):\n    \"\"\"\n    Draws the vertical area in between the two series in seriesList. Useful for\n    visualizing a range such as the minimum and maximum latency for a service.\n\n    areaBetween expects **exactly one argument** that results in exactly two\n    series (see example below). The order of the lower and higher values\n    series does not matter. The visualization only works when used in\n    conjunction with ``areaMode=stacked``.\n\n    Most likely use case is to provide a band within which another metric\n    should move. In such case applying an ``alpha()``, as in the second\n    example, gives best visual results.\n\n    Example::\n\n      &target=areaBetween(service.latency.{min,max})&areaMode=stacked\n\n      &target=alpha(areaBetween(service.latency.{min,max}),0.3)&areaMode=stacked\n\n    If for instance, you need to build a seriesList, you should use the\n    ``group`` function, like so::\n\n      &target=areaBetween(group(minSeries(a.*.min),maxSeries(a.*.max)))\n    \"\"\"\n    if len(seriesLists) == 1:\n        [seriesLists] = seriesLists\n    assert len(seriesLists) == 2, (\"areaBetween series argument must \"\n                                   \"reference *exactly* 2 series\")\n    lower, upper = seriesLists\n    if len(lower) == 1:\n        [lower] = lower\n    if len(upper) == 1:\n        [upper] = upper\n    lower.options['stacked'] = True\n    lower.options['invisible'] = True\n\n    upper.options['stacked'] = True\n    lower.name = upper.name = \"areaBetween(%s)\" % upper.pathExpression\n    return [lower, upper]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun series names through a regex search and replace.", "response": "def aliasSub(requestContext, seriesList, search, replace):\n    \"\"\"\n    Runs series names through a regex search/replace.\n\n   Example::\n\n        &target=aliasSub(ip.*TCP*,\"^.*TCP(\\d+)\",\"\\\\1\")\n    \"\"\"\n    try:\n        seriesList.name = re.sub(search, replace, seriesList.name)\n    except AttributeError:\n        for series in seriesList:\n            series.name = re.sub(search, replace, series.name)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a metric name to the seriesList.", "response": "def alias(requestContext, seriesList, newName):\n    \"\"\"\n    Takes one metric or a wildcard seriesList and a string in quotes.\n    Prints the string instead of the metric name in the legend.\n\n    Example::\n\n        &target=alias(Sales.widgets.largeBlue,\"Large Blue Widgets\")\n\n    \"\"\"\n    try:\n        seriesList.name = newName\n    except AttributeError:\n        for series in seriesList:\n            series.name = newName\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cactiStyle(requestContext, seriesList, system=None, units=None):\n    def fmt(x):\n        if system:\n            if units:\n                return \"%.2f %s\" % format_units(x, system=system, units=units)\n            else:\n                return \"%.2f%s\" % format_units(x, system=system)\n        else:\n            if units:\n                return \"%.2f %s\" % (x, units)\n            else:\n                return \"%.2f\" % x\n    nameLen = max([0] + [len(series.name) for series in seriesList])\n    lastLen = max([0] + [len(fmt(int(safeLast(series) or 3)))\n                         for series in seriesList]) + 3\n    maxLen = max([0] + [len(fmt(int(safeMax(series) or 3)))\n                        for series in seriesList]) + 3\n    minLen = max([0] + [len(fmt(int(safeMin(series) or 3)))\n                        for series in seriesList]) + 3\n    for series in seriesList:\n        last = safeLast(series)\n        maximum = safeMax(series)\n        minimum = safeMin(series)\n        if last is None:\n            last = NAN\n        else:\n            last = fmt(float(last))\n\n        if maximum is None:\n            maximum = NAN\n        else:\n            maximum = fmt(float(maximum))\n        if minimum is None:\n            minimum = NAN\n        else:\n            minimum = fmt(float(minimum))\n\n        series.name = \"%*s Current:%*s Max:%*s Min:%*s \" % (\n            -nameLen, series.name, -lastLen, last,\n            -maxLen, maximum, -minLen, minimum)\n    return seriesList", "response": "Returns a string that can be used to align a list of series in a cacti file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the first metric path in an expression.", "response": "def _getFirstPathExpression(name):\n    \"\"\"Returns the first metric path in an expression.\"\"\"\n    tokens = grammar.parseString(name)\n    pathExpression = None\n    while pathExpression is None:\n        if tokens.pathExpression:\n            pathExpression = tokens.pathExpression\n        elif tokens.expression:\n            tokens = tokens.expression\n        elif tokens.call:\n            tokens = tokens.call.args[0]\n        else:\n            break\n    return pathExpression"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a seriesList and applies an alias derived from one or more node names.", "response": "def aliasByNode(requestContext, seriesList, *nodes):\n    \"\"\"\n    Takes a seriesList and applies an alias derived from one or more \"node\"\n    portion/s of the target name. Node indices are 0 indexed.\n\n    Example::\n\n        &target=aliasByNode(ganglia.*.cpu.load5,1)\n\n    \"\"\"\n    for series in seriesList:\n        pathExpression = _getFirstPathExpression(series.name)\n        metric_pieces = pathExpression.split('.')\n        series.name = '.'.join(metric_pieces[n] for n in nodes)\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef legendValue(requestContext, seriesList, *valueTypes):\n    valueFuncs = {\n        'avg': lambda s: safeDiv(safeSum(s), safeLen(s)),\n        'total': safeSum,\n        'min': safeMin,\n        'max': safeMax,\n        'last': safeLast,\n    }\n    system = None\n    if valueTypes[-1] in ('si', 'binary'):\n        system = valueTypes[-1]\n        valueTypes = valueTypes[:-1]\n    for valueType in valueTypes:\n        valueFunc = valueFuncs.get(valueType, lambda s: '(?)')\n        if system is None:\n            for series in seriesList:\n                series.name += \" (%s: %s)\" % (valueType, valueFunc(series))\n        else:\n            for series in seriesList:\n                value = valueFunc(series)\n                formatted = None\n                if value is not None:\n                    formatted = \"%.2f%s\" % format_units(value, system=system)\n                series.name = \"%-20s%-5s%-10s\" % (series.name, valueType,\n                                                  formatted)\n    return seriesList", "response": "Adds a value to the name of the current resource in the legend."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nassigning the given alpha transparency setting to the series. Takes a float between 0 and 1.", "response": "def alpha(requestContext, seriesList, alpha):\n    \"\"\"\n    Assigns the given alpha transparency setting to the series. Takes a float\n    value between 0 and 1.\n    \"\"\"\n    for series in seriesList:\n        series.options['alpha'] = alpha\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef color(requestContext, seriesList, theColor):\n    for series in seriesList:\n        series.color = theColor\n    return seriesList", "response": "Assigns the given color to the seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef substr(requestContext, seriesList, start=0, stop=0):\n    for series in seriesList:\n        left = series.name.rfind('(') + 1\n        right = series.name.find(')')\n        if right < 0:\n            right = len(series.name)+1\n        cleanName = series.name[left:right:].split('.')\n        if int(stop) == 0:\n            series.name = '.'.join(cleanName[int(start)::])\n        else:\n            series.name = '.'.join(cleanName[int(start):int(stop):])\n\n        # substr(func(a.b,'c'),1) becomes b instead of b,'c'\n        series.name = re.sub(',.*$', '', series.name)\n    return seriesList", "response": "Takes one metric or a wildcard seriesList followed by 1 or 2 integers. Prints the metric name in the seriesList followed by dots."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logarithm(requestContext, seriesList, base=10):\n    results = []\n    for series in seriesList:\n        newValues = []\n        for val in series:\n            if val is None:\n                newValues.append(None)\n            elif val <= 0:\n                newValues.append(None)\n            else:\n                newValues.append(math.log(val, base))\n        newName = \"log(%s, %s)\" % (series.name, base)\n        newSeries = TimeSeries(newName, series.start, series.end, series.step,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n    return results", "response": "Takes one metric or a wildcard seriesList a base and draws the y - axis in\n    logarithmic format."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes one metric or a wildcard seriesList followed by a constant n Draws only the metrics with a maximum value below n", "response": "def maximumBelow(requestContext, seriesList, n):\n    \"\"\"\n    Takes one metric or a wildcard seriesList followed by a constant n.\n    Draws only the metrics with a maximum value below n.\n\n    Example::\n\n        &target=maximumBelow(system.interface.eth*.packetsSent,1000)\n\n    This would only display interfaces which always sent less than 1000\n    packets/min.\n    \"\"\"\n    results = []\n    for series in seriesList:\n        val = safeMax(series)\n        if val is None or val <= n:\n            results.append(series)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking one metric or a wildcard seriesList followed by a constant n Draws only the metrics with a minimum value below n", "response": "def minimumBelow(requestContext, seriesList, n):\n    \"\"\"\n    Takes one metric or a wildcard seriesList followed by a constant n.\n    Draws only the metrics with a minimum value below n.\n\n    Example::\n\n        &target=minimumBelow(system.interface.eth*.packetsSent,1000)\n\n    This would only display interfaces which sent at one point less than\n    1000 packets/min.\n    \"\"\"\n    results = []\n    for series in seriesList:\n        val = safeMin(series)\n        if val is None or val <= n:\n            results.append(series)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef highestMax(requestContext, seriesList, n=1):\n    result_list = sorted(seriesList, key=lambda s: safeMax(s))[-n:]\n    return sorted(result_list, key=lambda s: max(s), reverse=True)", "response": "Takes one metric or a wildcard seriesList followed by an integer N. Returns a seriesList with the N most busy threads in the time period specified."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake one metric or a wildcard seriesList followed by an integer N. Returns a list of metrics that are above n.", "response": "def currentAbove(requestContext, seriesList, n):\n    \"\"\"\n    Takes one metric or a wildcard seriesList followed by an integer N.\n    Out of all metrics passed, draws only the metrics whose value is above N\n    at the end of the time period specified.\n\n    Example::\n\n        &target=currentAbove(server*.instance*.threads.busy,50)\n\n    Draws the servers with more than 50 busy threads.\n\n    \"\"\"\n    results = []\n    for series in seriesList:\n        val = safeLast(series)\n        if val is not None and val >= n:\n            results.append(series)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef averageAbove(requestContext, seriesList, n):\n    results = []\n    for series in seriesList:\n        val = safeAvg(series)\n        if val is not None and val >= n:\n            results.append(series)\n    return results", "response": "Takes one metric or a wildcard seriesList followed by an integer N and draws only the metrics with an average value above N for the time period specified."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the percentile of a set of points.", "response": "def _getPercentile(points, n, interpolate=False):\n    \"\"\"\n    Percentile is calculated using the method outlined in the NIST Engineering\n    Statistics Handbook:\n    http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\n    \"\"\"\n    sortedPoints = sorted(not_none(points))\n    if len(sortedPoints) == 0:\n        return None\n    fractionalRank = (n/100.0) * (len(sortedPoints) + 1)\n    rank = int(fractionalRank)\n    rankFraction = fractionalRank - rank\n\n    if not interpolate:\n        rank += int(math.ceil(rankFraction))\n\n    if rank == 0:\n        percentile = sortedPoints[0]\n    elif rank - 1 == len(sortedPoints):\n        percentile = sortedPoints[-1]\n    else:\n        percentile = sortedPoints[rank - 1]  # Adjust for 0-index\n\n    if interpolate:\n        if rank != len(sortedPoints):  # if a next value exists\n            nextValue = sortedPoints[rank]\n            percentile = percentile + rankFraction * (nextValue - percentile)\n\n    return percentile"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns n - percent of each series in the seriesList.", "response": "def nPercentile(requestContext, seriesList, n):\n    \"\"\"Returns n-percent of each series in the seriesList.\"\"\"\n    assert n, 'The requested percent is required to be greater than 0'\n\n    results = []\n    for s in seriesList:\n        # Create a sorted copy of the TimeSeries excluding None values in the\n        # values list.\n        s_copy = TimeSeries(s.name, s.start, s.end, s.step,\n                            sorted(not_none(s)))\n        if not s_copy:\n            continue    # Skip this series because it is empty.\n\n        perc_val = _getPercentile(s_copy, n)\n        if perc_val is not None:\n            name = 'nPercentile(%s, %g)' % (s_copy.name, n)\n            point_count = int((s.end - s.start)/s.step)\n            perc_series = TimeSeries(name, s_copy.start, s_copy.end,\n                                     s_copy.step, [perc_val] * point_count)\n            perc_series.pathExpression = name\n            results.append(perc_series)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef averageOutsidePercentile(requestContext, seriesList, n):\n    averages = [safeAvg(s) for s in seriesList]\n\n    if n < 50:\n        n = 100 - n\n\n    lowPercentile = _getPercentile(averages, 100 - n)\n    highPercentile = _getPercentile(averages, n)\n\n    return [s for s in seriesList\n            if not lowPercentile < safeAvg(s) < highPercentile]", "response": "Returns a list of functions lying outside an average percentile interval."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef removeBetweenPercentile(requestContext, seriesList, n):\n    if n < 50:\n        n = 100 - n\n\n    transposed = list(zip_longest(*seriesList))\n\n    lowPercentiles = [_getPercentile(col, 100-n) for col in transposed]\n    highPercentiles = [_getPercentile(col, n) for col in transposed]\n\n    return [l for l in seriesList\n            if sum([not lowPercentiles[index] < val < highPercentiles[index]\n                    for index, val in enumerate(l)]) > 0]", "response": "Removes lines who do not have a value lying in the x - percentile of all\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef removeAboveValue(requestContext, seriesList, n):\n    for s in seriesList:\n        s.name = 'removeAboveValue(%s, %g)' % (s.name, n)\n        s.pathExpression = s.name\n        for (index, val) in enumerate(s):\n            if val is None:\n                continue\n            if val > n:\n                s[index] = None\n\n    return seriesList", "response": "Removes data above the given threshold from the series or list of seriesList provided."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves data below the nth percentile from the series or list of seriesList provided. Values below this percentile are assigned a value of None.", "response": "def removeBelowPercentile(requestContext, seriesList, n):\n    \"\"\"\n    Removes data below the nth percentile from the series or list of series\n    provided. Values below this percentile are assigned a value of None.\n    \"\"\"\n    for s in seriesList:\n        s.name = 'removeBelowPercentile(%s, %g)' % (s.name, n)\n        s.pathExpression = s.name\n        try:\n            percentile = nPercentile(requestContext, [s], n)[0][0]\n        except IndexError:\n            continue\n        for (index, val) in enumerate(s):\n            if val is None:\n                continue\n            if val < percentile:\n                s[index] = None\n\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting the list of metrics by the metric name using either alphabetical or natural sorting.", "response": "def sortByName(requestContext, seriesList, natural=False):\n    \"\"\"\n    Takes one metric or a wildcard seriesList.\n\n    Sorts the list of metrics by the metric name using either alphabetical\n    order or natural sorting. Natural sorting allows names containing numbers\n    to be sorted more naturally, e.g:\n\n    - Alphabetical sorting: server1, server11, server12, server2\n    - Natural sorting: server1, server2, server11, server12\n\n    \"\"\"\n    if natural:\n        return list(sorted(seriesList, key=lambda x: paddedName(x.name)))\n    else:\n        return list(sorted(seriesList, key=lambda x: x.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sortByTotal(requestContext, seriesList):\n    return list(sorted(seriesList, key=safeSum, reverse=True))", "response": "Sorts the list of metrics by the sum of values across the time period\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef useSeriesAbove(requestContext, seriesList, value, search, replace):\n    newSeries = []\n\n    for series in seriesList:\n        newname = re.sub(search, replace, series.name)\n        if safeMax(series) > value:\n            n = evaluateTarget(requestContext, newname)\n            if n is not None and len(n) > 0:\n                newSeries.append(n[0])\n\n    return newSeries", "response": "Compares the maximum of each series against the given value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mostDeviant(requestContext, seriesList, n):\n\n    deviants = []\n    for series in seriesList:\n        mean = safeAvg(series)\n        if mean is None:\n            continue\n        square_sum = sum([(value - mean) ** 2 for value in series\n                          if value is not None])\n        sigma = safeDiv(square_sum, safeLen(series))\n        if sigma is None:\n            continue\n        deviants.append((sigma, series))\n    return [series for sig, series in sorted(deviants,  # sort by sigma\n                                             key=itemgetter(0),\n                                             reverse=True)][:n]", "response": "Returns the most deviant metrics in a seriesList."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stdev(requestContext, seriesList, points, windowTolerance=0.1):\n\n    # For this we take the standard deviation in terms of the moving average\n    # and the moving average of series squares.\n    for seriesIndex, series in enumerate(seriesList):\n        stdevSeries = TimeSeries(\"stdev(%s,%d)\" % (series.name, int(points)),\n                                 series.start, series.end, series.step, [])\n        stdevSeries.pathExpression = \"stdev(%s,%d)\" % (series.name,\n                                                       int(points))\n\n        validPoints = 0\n        currentSum = 0\n        currentSumOfSquares = 0\n        for index, newValue in enumerate(series):\n            # Mark whether we've reached our window size - dont drop points\n            # out otherwise\n            if index < points:\n                bootstrapping = True\n                droppedValue = None\n            else:\n                bootstrapping = False\n                droppedValue = series[index - points]\n\n            # Track non-None points in window\n            if not bootstrapping and droppedValue is not None:\n                validPoints -= 1\n            if newValue is not None:\n                validPoints += 1\n\n            # Remove the value that just dropped out of the window\n            if not bootstrapping and droppedValue is not None:\n                currentSum -= droppedValue\n                currentSumOfSquares -= droppedValue**2\n\n            # Add in the value that just popped in the window\n            if newValue is not None:\n                currentSum += newValue\n                currentSumOfSquares += newValue**2\n\n            if (\n                validPoints > 0 and\n                float(validPoints) / points >= windowTolerance\n            ):\n                try:\n                    deviation = math.sqrt(validPoints * currentSumOfSquares -\n                                          currentSum**2) / validPoints\n                except ValueError:\n                    deviation = None\n                stdevSeries.append(deviation)\n            else:\n                stdevSeries.append(None)\n\n        seriesList[seriesIndex] = stdevSeries\n\n    return seriesList", "response": "This function is used to draw the standard deviation of all the datapoints in a seriesList. The points parameter can be specified as a wildcard seriesList followed by an integer N. The window size is calculated by the number of points in the seriesList."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef secondYAxis(requestContext, seriesList):\n    for series in seriesList:\n        series.options['secondYAxis'] = True\n        series.name = 'secondYAxis(%s)' % series.name\n    return seriesList", "response": "Sets the series options for the secondary Y axis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming a Holt - Winters forecast using the series as input data.", "response": "def holtWintersForecast(requestContext, seriesList):\n    \"\"\"\n    Performs a Holt-Winters forecast using the series as input data. Data from\n    one week previous to the series is used to bootstrap the initial forecast.\n    \"\"\"\n    previewSeconds = 7 * 86400  # 7 days\n    # ignore original data and pull new, including our preview\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    results = []\n    for series in previewList:\n        analysis = holtWintersAnalysis(series)\n        predictions = analysis['predictions']\n        windowPoints = previewSeconds // predictions.step\n        result = TimeSeries(\"holtWintersForecast(%s)\" % series.name,\n                            predictions.start + previewSeconds,\n                            predictions.end, predictions.step,\n                            predictions[windowPoints:])\n        result.pathExpression = result.name\n        results.append(result)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform a Holt-Winters forecast using the series as input data and plots upper and lower bands with the predicted forecast deviations.", "response": "def holtWintersConfidenceBands(requestContext, seriesList, delta=3):\n    \"\"\"\n    Performs a Holt-Winters forecast using the series as input data and plots\n    upper and lower bands with the predicted forecast deviations.\n    \"\"\"\n    previewSeconds = 7 * 86400  # 7 days\n    # ignore original data and pull new, including our preview\n    newContext = requestContext.copy()\n    newContext['startTime'] = (requestContext['startTime'] -\n                               timedelta(seconds=previewSeconds))\n    previewList = evaluateTokens(newContext, requestContext['args'][0])\n    results = []\n    for series in previewList:\n        analysis = holtWintersAnalysis(series)\n\n        data = analysis['predictions']\n        windowPoints = previewSeconds // data.step\n        forecast = TimeSeries(data.name, data.start + previewSeconds,\n                              data.end, data.step, data[windowPoints:])\n        forecast.pathExpression = data.pathExpression\n\n        data = analysis['deviations']\n        windowPoints = previewSeconds // data.step\n        deviation = TimeSeries(data.name, data.start + previewSeconds,\n                               data.end, data.step, data[windowPoints:])\n        deviation.pathExpression = data.pathExpression\n\n        seriesLength = len(forecast)\n        i = 0\n        upperBand = list()\n        lowerBand = list()\n        while i < seriesLength:\n            forecast_item = forecast[i]\n            deviation_item = deviation[i]\n            i = i + 1\n            if forecast_item is None or deviation_item is None:\n                upperBand.append(None)\n                lowerBand.append(None)\n            else:\n                scaled_deviation = delta * deviation_item\n                upperBand.append(forecast_item + scaled_deviation)\n                lowerBand.append(forecast_item - scaled_deviation)\n\n        upperName = \"holtWintersConfidenceUpper(%s)\" % series.name\n        lowerName = \"holtWintersConfidenceLower(%s)\" % series.name\n        upperSeries = TimeSeries(upperName, forecast.start, forecast.end,\n                                 forecast.step, upperBand)\n        lowerSeries = TimeSeries(lowerName, forecast.start, forecast.end,\n                                 forecast.step, lowerBand)\n        upperSeries.pathExpression = series.pathExpression\n        lowerSeries.pathExpression = series.pathExpression\n        results.append(lowerSeries)\n        results.append(upperSeries)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef holtWintersAberration(requestContext, seriesList, delta=3):\n    results = []\n    for series in seriesList:\n        confidenceBands = holtWintersConfidenceBands(requestContext, [series],\n                                                     delta)\n        lowerBand = confidenceBands[0]\n        upperBand = confidenceBands[1]\n        aberration = list()\n        for i, actual in enumerate(series):\n            if actual is None:\n                aberration.append(0)\n            elif upperBand[i] is not None and actual > upperBand[i]:\n                aberration.append(actual - upperBand[i])\n            elif lowerBand[i] is not None and actual < lowerBand[i]:\n                aberration.append(actual - lowerBand[i])\n            else:\n                aberration.append(0)\n\n        newName = \"holtWintersAberration(%s)\" % series.name\n        results.append(TimeSeries(newName, series.start, series.end,\n                                  series.step, aberration))\n    return results", "response": "Performs a Holt - Winters forecast using the series as input data and plots\n    positive or negative deviation of the series data from the forecast."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef holtWintersConfidenceArea(requestContext, seriesList, delta=3):\n    bands = holtWintersConfidenceBands(requestContext, seriesList, delta)\n    results = areaBetween(requestContext, bands)\n    for series in results:\n        series.name = series.name.replace('areaBetween',\n                                          'holtWintersConfidenceArea')\n    return results", "response": "Performs a Holt - Winters forecast using the series as input data and plots\n    the area between the upper and lower bands of the predicted forecast\n    deviations."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate factor and offset of linear regression function by least squares method.", "response": "def linearRegressionAnalysis(series):\n    \"\"\"\n    Returns factor and offset of linear regression function by least\n    squares method.\n\n    \"\"\"\n    n = safeLen(series)\n    sumI = sum([i for i, v in enumerate(series) if v is not None])\n    sumV = sum([v for i, v in enumerate(series) if v is not None])\n    sumII = sum([i * i for i, v in enumerate(series) if v is not None])\n    sumIV = sum([i * v for i, v in enumerate(series) if v is not None])\n    denominator = float(n * sumII - sumI * sumI)\n    if denominator == 0:\n        return None\n    else:\n        factor = (n * sumIV - sumI * sumV) / denominator / series.step\n        offset = sumII * sumV - sumIV * sumI\n        offset = offset / denominator - factor * series.start\n        return factor, offset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of TimeSeries objects that can be used to linear regression.", "response": "def linearRegression(requestContext, seriesList, startSourceAt=None,\n                     endSourceAt=None):\n    \"\"\"\n    Graphs the liner regression function by least squares method.\n\n    Takes one metric or a wildcard seriesList, followed by a quoted string\n    with the time to start the line and another quoted string with the time\n    to end the line. The start and end times are inclusive (default range is\n    from to until). See ``from / until`` in the render\\_api_ for examples of\n    time formats. Datapoints in the range is used to regression.\n\n    Example::\n\n        &target=linearRegression(Server.instance01.threads.busy,'-1d')\n        &target=linearRegression(Server.instance*.threads.busy,\n                                 \"00:00 20140101\",\"11:59 20140630\")\n\n    \"\"\"\n    from .app import evaluateTarget\n    results = []\n    sourceContext = requestContext.copy()\n    if startSourceAt is not None:\n        sourceContext['startTime'] = parseATTime(startSourceAt)\n    if endSourceAt is not None:\n        sourceContext['endTime'] = parseATTime(endSourceAt)\n\n    sourceList = []\n    for series in seriesList:\n        source = evaluateTarget(sourceContext, series.pathExpression)\n        sourceList.extend(source)\n\n    for source, series in zip(sourceList, seriesList):\n        newName = 'linearRegression(%s, %s, %s)' % (\n            series.name,\n            int(epoch(sourceContext['startTime'])),\n            int(epoch(sourceContext['endTime'])))\n        forecast = linearRegressionAnalysis(source)\n        if forecast is None:\n            continue\n        factor, offset = forecast\n        values = [offset + (series.start + i * series.step) * factor\n                  for i in range(len(series))]\n        newSeries = TimeSeries(newName, series.start, series.end,\n                               series.step, values)\n        newSeries.pathExpression = newSeries.name\n        results.append(newSeries)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drawAsInfinite(requestContext, seriesList):\n    for series in seriesList:\n        series.options['drawAsInfinite'] = True\n        series.name = 'drawAsInfinite(%s)' % series.name\n    return seriesList", "response": "Draw a line at infinity if the value is zero."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the line width of the selected metrics in a seriesList.", "response": "def lineWidth(requestContext, seriesList, width):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, followed by a float F.\n\n    Draw the selected metrics with a line width of F, overriding the default\n    value of 1, or the &lineWidth=X.X parameter.\n\n    Useful for highlighting a single metric out of many, or having multiple\n    line widths in one graph.\n\n    Example::\n\n        &target=lineWidth(server01.instance01.memory.free,5)\n\n    \"\"\"\n    for series in seriesList:\n        series.options['lineWidth'] = width\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a dashed line to the seriesList.", "response": "def dashed(requestContext, seriesList, dashLength=5):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, followed by a float F.\n\n    Draw the selected metrics with a dotted line with segments of length F\n    If omitted, the default length of the segments is 5.0\n\n    Example::\n\n        &target=dashed(server01.instance01.memory.free,2.5)\n\n    \"\"\"\n    for series in seriesList:\n        series.name = 'dashed(%s, %g)' % (series.name, dashLength)\n        series.options['dashed'] = dashLength\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake one metric or a wildcard seriesList, followed by a quoted string with the length of time (See ``from / until`` in the render\\_api_ for examples of time formats). Also takes a start multiplier and end multiplier for the length of time- Create a seriesList which is composed the original metric series stacked with time shifts starting time shifts from the start multiplier through the end multiplier. Useful for looking at history, or feeding into averageSeries or stddevSeries. Example:: # create a series for today and each of the previous 7 days &target=timeStack(Sales.widgets.largeBlue,\"1d\",0,7)", "response": "def timeStack(requestContext, seriesList, timeShiftUnit, timeShiftStart,\n              timeShiftEnd):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, followed by a quoted string\n    with the length of time (See ``from / until`` in the render\\_api_ for\n    examples of time formats). Also takes a start multiplier and end\n    multiplier for the length of time-\n\n    Create a seriesList which is composed the original metric series stacked\n    with time shifts starting time shifts from the start multiplier through\n    the end multiplier.\n\n    Useful for looking at history, or feeding into averageSeries or\n    stddevSeries.\n\n    Example::\n\n        # create a series for today and each of the previous 7 days\n        &target=timeStack(Sales.widgets.largeBlue,\"1d\",0,7)\n    \"\"\"\n    # Default to negative. parseTimeOffset defaults to +\n    if timeShiftUnit[0].isdigit():\n        timeShiftUnit = '-' + timeShiftUnit\n    delta = parseTimeOffset(timeShiftUnit)\n    # if len(seriesList) > 1, they will all have the same pathExpression,\n    # which is all we care about.\n    series = seriesList[0]\n    results = []\n    timeShiftStartint = int(timeShiftStart)\n    timeShiftEndint = int(timeShiftEnd)\n\n    for shft in range(timeShiftStartint, timeShiftEndint):\n        myContext = requestContext.copy()\n        innerDelta = delta * shft\n        myContext['startTime'] = requestContext['startTime'] + innerDelta\n        myContext['endTime'] = requestContext['endTime'] + innerDelta\n        for shiftedSeries in evaluateTarget(myContext, series.pathExpression):\n            shiftedSeries.name = 'timeShift(%s, %s, %s)' % (shiftedSeries.name,\n                                                            timeShiftUnit,\n                                                            shft)\n            shiftedSeries.pathExpression = shiftedSeries.name\n            shiftedSeries.start = series.start\n            shiftedSeries.end = series.end\n            results.append(shiftedSeries)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new base stateless version of the given seriesList shifted in time.", "response": "def timeShift(requestContext, seriesList, timeShift, resetEnd=True,\n              alignDST=False):\n    \"\"\"\n    Takes one metric or a wildcard seriesList, followed by a quoted string\n    with the length of time (See ``from / until`` in the render\\_api_ for\n    examples of time formats).\n\n    Draws the selected metrics shifted in time. If no sign is given, a minus\n    sign ( - ) is implied which will shift the metric back in time. If a plus\n    sign ( + ) is given, the metric will be shifted forward in time.\n\n    Will reset the end date range automatically to the end of the base stat\n    unless resetEnd is False. Example case is when you timeshift to last week\n    and have the graph date range set to include a time in the future, will\n    limit this timeshift to pretend ending at the current time. If resetEnd is\n    False, will instead draw full range including future time.\n\n    Because time is shifted by a fixed number of seconds, comparing a time\n    period with DST to a time period without DST, and vice-versa, will result\n    in an apparent misalignment. For example, 8am might be overlaid with 7am.\n    To compensate for this, use the alignDST option.\n\n    Useful for comparing a metric against itself at a past periods or\n    correcting data stored at an offset.\n\n    Example::\n\n        &target=timeShift(Sales.widgets.largeBlue,\"7d\")\n        &target=timeShift(Sales.widgets.largeBlue,\"-7d\")\n        &target=timeShift(Sales.widgets.largeBlue,\"+1h\")\n\n    \"\"\"\n    # Default to negative. parseTimeOffset defaults to +\n    if timeShift[0].isdigit():\n        timeShift = '-' + timeShift\n    delta = parseTimeOffset(timeShift)\n    myContext = requestContext.copy()\n    myContext['startTime'] = requestContext['startTime'] + delta\n    myContext['endTime'] = requestContext['endTime'] + delta\n\n    if alignDST:\n        reqStartDST = localDST(requestContext['startTime'])\n        reqEndDST = localDST(requestContext['endTime'])\n        myStartDST = localDST(myContext['startTime'])\n        myEndDST = localDST(myContext['endTime'])\n\n        dstOffset = timedelta(hours=0)\n        # If the requestContext is entirely in DST, and we are entirely\n        # NOT in DST\n        if (\n            (reqStartDST and reqEndDST) and\n            (not myStartDST and not myEndDST)\n        ):\n            dstOffset = timedelta(hours=1)\n        # Or if the requestContext is entirely NOT in DST, and we are\n        # entirely in DST\n        elif (\n            (not reqStartDST and not reqEndDST) and\n            (myStartDST and myEndDST)\n        ):\n            dstOffset = timedelta(hours=-1)\n        # Otherwise, we don't do anything, because it would be visually\n        # confusing\n        myContext['startTime'] += dstOffset\n        myContext['endTime'] += dstOffset\n\n    results = []\n    if not seriesList:\n        return results\n\n    # if len(seriesList) > 1, they will all have the same pathExpression,\n    # which is all we care about.\n    series = seriesList[0]\n\n    for shiftedSeries in evaluateTarget(myContext, series.pathExpression):\n        shiftedSeries.name = 'timeShift(%s, %s)' % (shiftedSeries.name,\n                                                    timeShift)\n        if resetEnd:\n            shiftedSeries.end = series.end\n        else:\n            shiftedSeries.end = (\n                shiftedSeries.end - shiftedSeries.start + series.start)\n        shiftedSeries.start = series.start\n        results.append(shiftedSeries)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of timeSlice objects for the given seriesList.", "response": "def timeSlice(requestContext, seriesList, startSliceAt, endSliceAt='now'):\n    \"\"\"\n    Takes one metric or a wildcard metric, followed by a quoted\n    string with the time to start the line and another quoted string\n    with the time to end the line. The start and end times are\n    inclusive. See ``from / until`` in the render api for examples of\n    time formats.\n\n    Useful for filtering out a part of a series of data from a wider\n    range of data.\n\n    Example::\n\n        &target=timeSlice(network.core.port1,\"00:00 20140101\",\"11:59 20140630\")\n        &target=timeSlice(network.core.port1,\"12:00 20140630\",\"now\")\n    \"\"\"\n    results = []\n    start = epoch(parseATTime(startSliceAt))\n    end = epoch(parseATTime(endSliceAt))\n\n    for slicedSeries in seriesList:\n        slicedSeries.name = 'timeSlice(%s, %s, %s)' % (slicedSeries.name,\n                                                       int(start), int(end))\n        curr = epoch(requestContext[\"startTime\"])\n        for i, v in enumerate(slicedSeries):\n            if v is None or curr < start or curr > end:\n                slicedSeries[i] = None\n            curr += slicedSeries.step\n        results.append(slicedSeries)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a float F Draws a horizontal line at value F across the graph.", "response": "def constantLine(requestContext, value):\n    \"\"\"\n    Takes a float F.\n\n    Draws a horizontal line at value F across the graph.\n\n    Example::\n\n        &target=constantLine(123.456)\n\n    \"\"\"\n    name = \"constantLine(%s)\" % str(value)\n    start = int(epoch(requestContext['startTime']))\n    end = int(epoch(requestContext['endTime']))\n    step = int((end - start) / 2.0)\n    series = TimeSeries(str(value), start, end, step, [value, value, value])\n    series.pathExpression = name\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef aggregateLine(requestContext, seriesList, func='avg'):\n    t_funcs = {'avg': safeAvg, 'min': safeMin, 'max': safeMax}\n\n    if func not in t_funcs:\n        raise ValueError(\"Invalid function %s\" % func)\n\n    results = []\n    for series in seriesList:\n        value = t_funcs[func](series)\n        if value is not None:\n            name = 'aggregateLine(%s, %g)' % (series.name, value)\n        else:\n            name = 'aggregateLine(%s, None)' % (series.name)\n\n        [series] = constantLine(requestContext, value)\n        series.name = name\n        series.pathExpression = series.name\n        results.append(series)\n    return results", "response": "Takes a metric or wildcard seriesList and draws a horizontal line of the available data points by applying a function to each series."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of vertical lines at the designated timestamp.", "response": "def verticalLine(requestContext, ts, label=None, color=None):\n    \"\"\"\n    Takes a timestamp string ts.\n\n    Draws a vertical line at the designated timestamp with optional\n    'label' and 'color'. Supported timestamp formats include both\n    relative (e.g. -3h) and absolute (e.g. 16:00_20110501) strings,\n    such as those used with ``from`` and ``until`` parameters. When\n    set, the 'label' will appear in the graph legend.\n\n    Note: Any timestamps defined outside the requested range will\n    raise a 'ValueError' exception.\n\n    Example::\n\n        &target=verticalLine(\"12:3420131108\",\"event\",\"blue\")\n        &target=verticalLine(\"16:00_20110501\",\"event\")\n        &target=verticalLine(\"-5mins\")\n\n    \"\"\"\n    ts = int(epoch(parseATTime(ts, requestContext['tzinfo'])))\n    start = int(epoch(requestContext['startTime']))\n    end = int(epoch(requestContext['endTime']))\n    if ts < start:\n        raise ValueError(\"verticalLine(): timestamp %s exists \"\n                         \"before start of range\" % ts)\n    elif ts > end:\n        raise ValueError(\"verticalLine(): timestamp %s exists \"\n                         \"after end of range\" % ts)\n    start = end = ts\n    step = 1.0\n    series = TimeSeries(label, start, end, step, [1.0, 1.0])\n    series.options['drawAsInfinite'] = True\n    if color:\n        series.color = color\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a float F, followed by a label (in double quotes) and a color. (See ``bgcolor`` in the render\\_api_ for valid color names & formats.) Draws a horizontal line at value F across the graph. Example:: &target=threshold(123.456, \"omgwtfbbq\", \"red\")", "response": "def threshold(requestContext, value, label=None, color=None):\n    \"\"\"\n    Takes a float F, followed by a label (in double quotes) and a color.\n    (See ``bgcolor`` in the render\\_api_ for valid color names & formats.)\n\n    Draws a horizontal line at value F across the graph.\n\n    Example::\n\n        &target=threshold(123.456, \"omgwtfbbq\", \"red\")\n\n    \"\"\"\n    [series] = constantLine(requestContext, value)\n    if label:\n        series.name = label\n    if color:\n        series.color = color\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a metric or wildcard seriesList and replaces null values with the value specified by default.", "response": "def transformNull(requestContext, seriesList, default=0, referenceSeries=None):\n    \"\"\"\n    Takes a metric or wildcard seriesList and replaces null values with\n    the value specified by `default`.  The value 0 used if not specified.\n    The optional referenceSeries, if specified, is a metric or wildcard\n    series list that governs which time intervals nulls should be replaced.\n    If specified, nulls are replaced only in intervals where a non-null is\n    found for the same interval in any of referenceSeries. This method\n    compliments the drawNullAsZero function in graphical mode, but also\n    works in text-only mode.\n\n    Example::\n\n        &target=transformNull(webapp.pages.*.views,-1)\n\n    This would take any page that didn't have values and supply negative 1 as\n    a default. Any other numeric value may be used as well.\n    \"\"\"\n    def transform(v, d):\n        if v is None:\n            return d\n        else:\n            return v\n\n    if referenceSeries:\n        defaults = [default if any(v is not None for v in x) else None\n                    for x in zip_longest(*referenceSeries)]\n    else:\n        defaults = None\n\n    for series in seriesList:\n        if referenceSeries:\n            series.name = \"transformNull(%s,%g,referenceSeries)\" % (\n                series.name, default)\n        else:\n            series.name = \"transformNull(%s,%g)\" % (series.name, default)\n        series.pathExpression = series.name\n        if defaults:\n            values = [transform(v, d) for v, d in zip_longest(series,\n                                                              defaults)]\n        else:\n            values = [transform(v, default) for v in series]\n        series.extend(values)\n        del series[:len(values)]\n    return seriesList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isNonNull(requestContext, seriesList):\n\n    def transform(v):\n        if v is None:\n            return 0\n        else:\n            return 1\n\n    for series in seriesList:\n        series.name = \"isNonNull(%s)\" % (series.name)\n        series.pathExpression = series.name\n        values = [transform(v) for v in series]\n        series.extend(values)\n        del series[:len(values)]\n    return seriesList", "response": "Takes a metric or wild card seriesList and counts up how many\nvms non - null values are specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef identity(requestContext, name, step=60):\n    start = int(epoch(requestContext[\"startTime\"]))\n    end = int(epoch(requestContext[\"endTime\"]))\n    values = range(start, end, step)\n    series = TimeSeries(name, start, end, step, values)\n    series.pathExpression = 'identity(\"%s\")' % name\n\n    return [series]", "response": "This function returns a series with the given name equal to the timestamp of the datapoint."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef countSeries(requestContext, *seriesLists):\n    if not seriesLists or not any(seriesLists):\n        series = constantLine(requestContext, 0).pop()\n        series.pathExpression = \"countSeries()\"\n    else:\n        seriesList, start, end, step = normalize(seriesLists)\n        name = \"countSeries(%s)\" % formatPathExpressions(seriesList)\n        values = (int(len(row)) for row in zip_longest(*seriesList))\n        series = TimeSeries(name, start, end, step, values)\n        series.pathExpression = name\n\n    return [series]", "response": "Draw a horizontal line representing the number of nodes found in the specified seriesList."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a seriesList that contains all the seriesLists in seriesLists.", "response": "def group(requestContext, *seriesLists):\n    \"\"\"\n    Takes an arbitrary number of seriesLists and adds them to a single\n    seriesList. This is used to pass multiple seriesLists to a function which\n    only takes one.\n    \"\"\"\n    seriesGroup = []\n    for s in seriesLists:\n        seriesGroup.extend(s)\n\n    return seriesGroup"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a seriesList and maps it to a list of sub - seriesList.", "response": "def mapSeries(requestContext, seriesList, mapNode):\n    \"\"\"\n    Short form: ``map()``.\n\n    Takes a seriesList and maps it to a list of sub-seriesList. Each\n    sub-seriesList has the given mapNode in common.\n\n    Example (note: This function is not very useful alone. It should be used\n    with :py:func:`reduceSeries`)::\n\n        mapSeries(servers.*.cpu.*,1) =>\n            [\n                servers.server1.cpu.*,\n                servers.server2.cpu.*,\n                ...\n                servers.serverN.cpu.*\n            ]\n    \"\"\"\n    metaSeries = {}\n    keys = []\n    for series in seriesList:\n        key = series.name.split(\".\")[mapNode]\n        if key not in metaSeries:\n            metaSeries[key] = [series]\n            keys.append(key)\n        else:\n            metaSeries[key].append(series)\n    return [metaSeries[k] for k in keys]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshorts form: ``reduce()``. Takes a list of seriesLists and reduces it to a list of series by means of the reduceFunction. Reduction is performed by matching the reduceNode in each series against the list of reduceMatchers. The each series is then passed to the reduceFunction as arguments in the order given by reduceMatchers. The reduceFunction should yield a single series. The resulting list of series are aliased so that they can easily be nested in other functions. **Example**: Map/Reduce asPercent(bytes_used,total_bytes) for each server. Assume that metrics in the form below exist:: servers.server1.disk.bytes_used servers.server1.disk.total_bytes servers.server2.disk.bytes_used servers.server2.disk.total_bytes servers.server3.disk.bytes_used servers.server3.disk.total_bytes ... servers.serverN.disk.bytes_used servers.serverN.disk.total_bytes To get the percentage of disk used for each server:: reduceSeries(mapSeries(servers.*.disk.*,1), \"asPercent\",3,\"bytes_used\",\"total_bytes\") => alias(asPercent(servers.server1.disk.bytes_used, servers.server1.disk.total_bytes), \"servers.server1.disk.reduce.asPercent\"), alias(asPercent(servers.server2.disk.bytes_used, servers.server2.disk.total_bytes), \"servers.server2.disk.reduce.asPercent\"), ... alias(asPercent(servers.serverN.disk.bytes_used, servers.serverN.disk.total_bytes), \"servers.serverN.disk.reduce.asPercent\") In other words, we will get back the following metrics:: servers.server1.disk.reduce.asPercent, servers.server2.disk.reduce.asPercent, ... servers.serverN.disk.reduce.asPercent .. seealso:: :py:func:`mapSeries`", "response": "def reduceSeries(requestContext, seriesLists, reduceFunction, reduceNode,\n                 *reduceMatchers):\n    \"\"\"\n    Short form: ``reduce()``.\n\n    Takes a list of seriesLists and reduces it to a list of series by means of\n    the reduceFunction.\n\n    Reduction is performed by matching the reduceNode in each series against\n    the list of reduceMatchers. The each series is then passed to the\n    reduceFunction as arguments in the order given by reduceMatchers. The\n    reduceFunction should yield a single series.\n\n    The resulting list of series are aliased so that they can easily be\n    nested in other functions.\n\n    **Example**: Map/Reduce asPercent(bytes_used,total_bytes) for each server.\n\n    Assume that metrics in the form below exist::\n\n        servers.server1.disk.bytes_used\n        servers.server1.disk.total_bytes\n        servers.server2.disk.bytes_used\n        servers.server2.disk.total_bytes\n        servers.server3.disk.bytes_used\n        servers.server3.disk.total_bytes\n        ...\n        servers.serverN.disk.bytes_used\n        servers.serverN.disk.total_bytes\n\n    To get the percentage of disk used for each server::\n\n        reduceSeries(mapSeries(servers.*.disk.*,1),\n                     \"asPercent\",3,\"bytes_used\",\"total_bytes\") =>\n\n            alias(asPercent(servers.server1.disk.bytes_used,\n                            servers.server1.disk.total_bytes),\n                  \"servers.server1.disk.reduce.asPercent\"),\n            alias(asPercent(servers.server2.disk.bytes_used,\n                            servers.server2.disk.total_bytes),\n                  \"servers.server2.disk.reduce.asPercent\"),\n            ...\n            alias(asPercent(servers.serverN.disk.bytes_used,\n                            servers.serverN.disk.total_bytes),\n                  \"servers.serverN.disk.reduce.asPercent\")\n\n    In other words, we will get back the following metrics::\n\n        servers.server1.disk.reduce.asPercent,\n        servers.server2.disk.reduce.asPercent,\n        ...\n        servers.serverN.disk.reduce.asPercent\n\n    .. seealso:: :py:func:`mapSeries`\n    \"\"\"\n    metaSeries = {}\n    keys = []\n    for seriesList in seriesLists:\n        for series in seriesList:\n            nodes = series.name.split('.')\n            node = nodes[reduceNode]\n            reduceSeriesName = '.'.join(\n                nodes[0:reduceNode]) + '.reduce.' + reduceFunction\n            if node in reduceMatchers:\n                if reduceSeriesName not in metaSeries:\n                    metaSeries[reduceSeriesName] = [None] * len(reduceMatchers)\n                    keys.append(reduceSeriesName)\n                i = reduceMatchers.index(node)\n                metaSeries[reduceSeriesName][i] = series\n    for key in keys:\n        metaSeries[key] = app.functions[reduceFunction](\n            requestContext, *[[s] for s in metaSeries[key]])[0]\n        metaSeries[key].name = key\n    return [metaSeries[key] for key in keys]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a seriesList and applies a template function to each series in the seriesList and replaces any % characters with the unique prefix of the series.", "response": "def applyByNode(requestContext, seriesList, nodeNum, templateFunction,\n                newName=None):\n    \"\"\"\n    Takes a seriesList and applies some complicated function (described by\n    a string), replacing templates with unique prefixes of keys from the\n    seriesList (the key is all nodes up to the index given as `nodeNum`).\n\n    If the `newName` parameter is provided, the name of the resulting series\n    will be given by that parameter, with any \"%\" characters replaced by the\n    unique prefix.\n\n    Example::\n\n        &target=applyByNode(servers.*.disk.bytes_free,1,\n                \"divideSeries(%.disk.bytes_free,sumSeries(%.disk.bytes_*))\")\n\n    Would find all series which match `servers.*.disk.bytes_free`, then trim\n    them down to unique series up to the node given by nodeNum, then fill them\n    into the template function provided (replacing % by the prefixes).\n\n    \"\"\"\n    from .app import evaluateTarget\n    prefixes = set()\n    for series in seriesList:\n        prefix = '.'.join(series.name.split('.')[:nodeNum + 1])\n        prefixes.add(prefix)\n    results = []\n    for prefix in sorted(prefixes):\n        target = templateFunction.replace('%', prefix)\n        for resultSeries in evaluateTarget(requestContext, target):\n            if newName:\n                resultSeries.name = newName.replace('%', prefix)\n            resultSeries.pathExpression = prefix\n            resultSeries.start = series.start\n            resultSeries.end = series.end\n            results.append(resultSeries)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake a serieslist and maps a callback to subgroups within a common node.", "response": "def groupByNode(requestContext, seriesList, nodeNum, callback):\n    \"\"\"\n    Takes a serieslist and maps a callback to subgroups within as defined by a\n    common node.\n\n    Example::\n\n        &target=groupByNode(ganglia.by-function.*.*.cpu.load5,2,\"sumSeries\")\n\n    Would return multiple series which are each the result of applying the\n    \"sumSeries\" function to groups joined on the second node (0 indexed)\n    resulting in a list of targets like::\n\n        sumSeries(ganglia.by-function.server1.*.cpu.load5),\n        sumSeries(ganglia.by-function.server2.*.cpu.load5),...\n\n    \"\"\"\n    return groupByNodes(requestContext, seriesList, callback, nodeNum)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef groupByNodes(requestContext, seriesList, callback, *nodes):\n    from .app import app\n    metaSeries = {}\n    keys = []\n    if isinstance(nodes, int):\n        nodes = [nodes]\n    for series in seriesList:\n        key = '.'.join(series.name.split(\".\")[n] for n in nodes)\n        if key not in metaSeries:\n            metaSeries[key] = [series]\n            keys.append(key)\n        else:\n            metaSeries[key].append(series)\n    for key in metaSeries:\n        metaSeries[key] = app.functions[callback](requestContext,\n                                                  metaSeries[key])[0]\n        metaSeries[key].name = key\n    return [metaSeries[key] for key in keys]", "response": "Takes a seriesList and maps a callback to subgroups within a set of nodes. Returns a list of series which are grouped by the given nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exclude(requestContext, seriesList, pattern):\n    regex = re.compile(pattern)\n    return [s for s in seriesList if not regex.search(s.name)]", "response": "Exclude metrics that match the regular expression pattern."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef smartSummarize(requestContext, seriesList, intervalString, func='sum'):\n    results = []\n    delta = parseTimeOffset(intervalString)\n    interval = to_seconds(delta)\n\n    # Adjust the start time to fit an entire day for intervals >= 1 day\n    requestContext = requestContext.copy()\n    tzinfo = requestContext['tzinfo']\n    s = requestContext['startTime']\n    if interval >= DAY:\n        requestContext['startTime'] = datetime(s.year, s.month, s.day,\n                                               tzinfo=tzinfo)\n    elif interval >= HOUR:\n        requestContext['startTime'] = datetime(s.year, s.month, s.day, s.hour,\n                                               tzinfo=tzinfo)\n    elif interval >= MINUTE:\n        requestContext['startTime'] = datetime(s.year, s.month, s.day, s.hour,\n                                               s.minute, tzinfo=tzinfo)\n\n    paths = []\n    for series in seriesList:\n        paths.extend(pathsFromTarget(requestContext, series.pathExpression))\n    data_store = fetchData(requestContext, paths)\n\n    for series in seriesList:\n        # XXX: breaks with summarize(metric.{a,b})\n        #            each series.pathExpression == metric.{a,b}\n        newSeries = evaluateTarget(requestContext,\n                                   series.pathExpression,\n                                   data_store)[0]\n        series[0:len(series)] = newSeries\n        series.start = newSeries.start\n        series.end = newSeries.end\n        series.step = newSeries.step\n\n    for series in seriesList:\n        buckets = {}  # {timestamp: [values]}\n\n        timestamps = range(int(series.start), int(series.end),\n                           int(series.step))\n        datapoints = zip_longest(timestamps, series)\n\n        # Populate buckets\n        for timestamp, value in datapoints:\n            # ISSUE: Sometimes there is a missing timestamp in datapoints when\n            #        running a smartSummary\n            if not timestamp:\n                continue\n            bucketInterval = int((timestamp - series.start) / interval)\n\n            if bucketInterval not in buckets:\n                buckets[bucketInterval] = []\n\n            if value is not None:\n                buckets[bucketInterval].append(value)\n\n        newValues = []\n        for timestamp in range(series.start, series.end, interval):\n            bucketInterval = int((timestamp - series.start) / interval)\n            bucket = buckets.get(bucketInterval, [])\n\n            if bucket:\n                if func == 'avg':\n                    newValues.append(float(sum(bucket)) / float(len(bucket)))\n                elif func == 'last':\n                    newValues.append(bucket[len(bucket)-1])\n                elif func == 'max':\n                    newValues.append(max(bucket))\n                elif func == 'min':\n                    newValues.append(min(bucket))\n                else:\n                    newValues.append(sum(bucket))\n            else:\n                newValues.append(None)\n\n        newName = \"smartSummarize(%s, \\\"%s\\\", \\\"%s\\\")\" % (series.name,\n                                                          intervalString,\n                                                          func)\n        alignedEnd = series.start + (bucketInterval * interval) + interval\n        newSeries = TimeSeries(newName, series.start, alignedEnd, interval,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n\n    return results", "response": "Smarter experimental version of summarize."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef summarize(requestContext, seriesList, intervalString, func='sum',\n              alignToFrom=False):\n    \"\"\"\n    Summarize the data into interval buckets of a certain size.\n\n    By default, the contents of each interval bucket are summed together.\n    This is useful for counters where each increment represents a discrete\n    event and retrieving a \"per X\" value requires summing all the events in\n    that interval.\n\n    Specifying 'avg' instead will return the mean for each bucket, which can\n    be more useful when the value is a gauge that represents a certain value\n    in time.\n\n    'max', 'min' or 'last' can also be specified.\n\n    By default, buckets are calculated by rounding to the nearest interval.\n    This works well for intervals smaller than a day. For example, 22:32 will\n    end up in the bucket 22:00-23:00 when the interval=1hour.\n\n    Passing alignToFrom=true will instead create buckets starting at the from\n    time. In this case, the bucket for 22:32 depends on the from time. If\n    from=6:30 then the 1hour bucket for 22:32 is 22:30-23:30.\n\n    Example::\n\n        # total errors per hour\n        &target=summarize(counter.errors, \"1hour\")\n\n        # new users per week\n        &target=summarize(nonNegativeDerivative(gauge.num_users), \"1week\")\n\n        # average queue size per hour\n        &target=summarize(queue.size, \"1hour\", \"avg\")\n\n        # maximum queue size during each hour\n        &target=summarize(queue.size, \"1hour\", \"max\")\n\n        # 2010 Q1-4\n        &target=summarize(metric, \"13week\", \"avg\", true)&from=midnight+20100101\n    \"\"\"\n    results = []\n    delta = parseTimeOffset(intervalString)\n    interval = to_seconds(delta)\n\n    for series in seriesList:\n        buckets = {}\n\n        timestamps = range(int(series.start), int(series.end) + 1,\n                           int(series.step))\n        datapoints = zip_longest(timestamps, series)\n\n        for timestamp, value in datapoints:\n            if timestamp is None:\n                continue\n            if alignToFrom:\n                bucketInterval = int((timestamp - series.start) / interval)\n            else:\n                bucketInterval = timestamp - (timestamp % interval)\n\n            if bucketInterval not in buckets:\n                buckets[bucketInterval] = []\n\n            if value is not None:\n                buckets[bucketInterval].append(value)\n\n        if alignToFrom:\n            newStart = series.start\n            newEnd = series.end\n        else:\n            newStart = series.start - (series.start % interval)\n            newEnd = series.end - (series.end % interval) + interval\n\n        newValues = []\n        for timestamp in range(newStart, newEnd, interval):\n            if alignToFrom:\n                newEnd = timestamp\n                bucketInterval = int((timestamp - series.start) / interval)\n            else:\n                bucketInterval = timestamp - (timestamp % interval)\n\n            bucket = buckets.get(bucketInterval, [])\n\n            if bucket:\n                if func == 'avg':\n                    newValues.append(float(sum(bucket)) / float(len(bucket)))\n                elif func == 'last':\n                    newValues.append(bucket[len(bucket)-1])\n                elif func == 'max':\n                    newValues.append(max(bucket))\n                elif func == 'min':\n                    newValues.append(min(bucket))\n                else:\n                    newValues.append(sum(bucket))\n            else:\n                newValues.append(None)\n\n        if alignToFrom:\n            newEnd += interval\n\n        newName = \"summarize(%s, \\\"%s\\\", \\\"%s\\\"%s)\" % (\n            series.name, intervalString, func, alignToFrom and \", true\" or \"\")\n        newSeries = TimeSeries(newName, newStart, newEnd, interval, newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n\n    return results", "response": "Summarize the data into a list of buckets."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nestimates the hit count of a list of time series.", "response": "def hitcount(requestContext, seriesList, intervalString,\n             alignToInterval=False):\n    \"\"\"\n    Estimate hit counts from a list of time series.\n\n    This function assumes the values in each time series represent\n    hits per second.    It calculates hits per some larger interval\n    such as per day or per hour.    This function is like summarize(),\n    except that it compensates automatically for different time scales\n    (so that a similar graph results from using either fine-grained\n    or coarse-grained records) and handles rarely-occurring events\n    gracefully.\n    \"\"\"\n    results = []\n    delta = parseTimeOffset(intervalString)\n    interval = to_seconds(delta)\n\n    if alignToInterval:\n        requestContext = requestContext.copy()\n        tzinfo = requestContext['tzinfo']\n        s = requestContext['startTime']\n        if interval >= DAY:\n            requestContext['startTime'] = datetime(s.year, s.month, s.day,\n                                                   tzinfo=tzinfo)\n        elif interval >= HOUR:\n            requestContext['startTime'] = datetime(s.year, s.month, s.day,\n                                                   s.hour, tzinfo=tzinfo)\n        elif interval >= MINUTE:\n            requestContext['startTime'] = datetime(s.year, s.month, s.day,\n                                                   s.hour, s.minute,\n                                                   tzinfo=tzinfo)\n\n        # Gather all paths first, then the data\n        paths = []\n        for series in seriesList:\n            paths.extend(pathsFromTarget(requestContext,\n                                         series.pathExpression))\n        data_store = fetchData(requestContext, paths)\n\n        for series in seriesList:\n            newSeries = evaluateTarget(requestContext,\n                                       series.pathExpression,\n                                       data_store)[0]\n            intervalCount = int((series.end - series.start) / interval)\n            series[0:len(series)] = newSeries\n            series.start = newSeries.start\n            series.end = newSeries.start + (\n                intervalCount * interval) + interval\n            series.step = newSeries.step\n\n    for series in seriesList:\n        step = int(series.step)\n        bucket_count = int(math.ceil(\n            float(series.end - series.start) / interval))\n        buckets = [[] for _ in range(bucket_count)]\n        newStart = int(series.end - bucket_count * interval)\n\n        for i, value in enumerate(series):\n            if value is None:\n                continue\n\n            start_time = int(series.start + i * step)\n            start_bucket, start_mod = divmod(start_time - newStart, interval)\n            end_time = start_time + step\n            end_bucket, end_mod = divmod(end_time - newStart, interval)\n\n            if end_bucket >= bucket_count:\n                end_bucket = bucket_count - 1\n                end_mod = interval\n\n            if start_bucket == end_bucket:\n                # All of the hits go to a single bucket.\n                if start_bucket >= 0:\n                    buckets[start_bucket].append(value * (end_mod - start_mod))\n\n            else:\n                # Spread the hits among 2 or more buckets.\n                if start_bucket >= 0:\n                    buckets[start_bucket].append(\n                        value * (interval - start_mod))\n                hits_per_bucket = value * interval\n                for j in range(start_bucket + 1, end_bucket):\n                    buckets[j].append(hits_per_bucket)\n                if end_mod > 0:\n                    buckets[end_bucket].append(value * end_mod)\n\n        newValues = []\n        for bucket in buckets:\n            if bucket:\n                newValues.append(sum(bucket))\n            else:\n                newValues.append(None)\n\n        newName = 'hitcount(%s, \"%s\"%s)' % (series.name, intervalString,\n                                            alignToInterval and \", true\" or \"\")\n        newSeries = TimeSeries(newName, newStart, series.end, interval,\n                               newValues)\n        newSeries.pathExpression = newName\n        results.append(newSeries)\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshorts Alias: time() Just returns the timestamp for each X value. T Example:: &target=time(\"The.time.series\") This would create a series named \"The.time.series\" that contains in Y the same value (in seconds) as X. A second argument can be provided as a step parameter (default is 60 secs)", "response": "def timeFunction(requestContext, name, step=60):\n    \"\"\"\n    Short Alias: time()\n\n    Just returns the timestamp for each X value. T\n\n    Example::\n\n        &target=time(\"The.time.series\")\n\n    This would create a series named \"The.time.series\" that contains in Y\n    the same value (in seconds) as X.\n\n    A second argument can be provided as a step parameter (default is 60 secs)\n\n    \"\"\"\n    start = int(epoch(requestContext[\"startTime\"]))\n    end = int(epoch(requestContext[\"endTime\"]))\n    delta = timedelta(seconds=step)\n    when = requestContext[\"startTime\"]\n    values = []\n\n    while when < requestContext[\"endTime\"]:\n        values.append(epoch(when))\n        when += delta\n\n    series = TimeSeries(name, start, end, step, values)\n    series.pathExpression = name\n\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions that returns the sine of the current time.", "response": "def sinFunction(requestContext, name, amplitude=1, step=60):\n    \"\"\"\n    Short Alias: sin()\n\n    Just returns the sine of the current time. The optional amplitude parameter\n    changes the amplitude of the wave.\n\n    Example::\n\n        &target=sin(\"The.time.series\", 2)\n\n    This would create a series named \"The.time.series\" that contains sin(x)*2.\n\n    A third argument can be provided as a step parameter (default is 60 secs).\n    \"\"\"\n    delta = timedelta(seconds=step)\n    when = requestContext[\"startTime\"]\n    values = []\n\n    while when < requestContext[\"endTime\"]:\n        values.append(math.sin(epoch(when))*amplitude)\n        when += delta\n\n    series = TimeSeries(\n        name, int(epoch(requestContext[\"startTime\"])),\n        int(epoch(requestContext[\"endTime\"])),\n        step, values)\n    series.pathExpression = 'sin({0})'.format(name)\n    return [series]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef randomWalkFunction(requestContext, name, step=60):\n    delta = timedelta(seconds=step)\n    when = requestContext[\"startTime\"]\n    values = []\n    current = 0\n    while when < requestContext[\"endTime\"]:\n        values.append(current)\n        current += random.random() - 0.5\n        when += delta\n\n    return [TimeSeries(\n        name, int(epoch(requestContext[\"startTime\"])),\n        int(epoch(requestContext[\"endTime\"])),\n        step, values)]", "response": "This function is used to generate a random walk of the time series."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(self, model, checks=[]):\n        custom = [\n            check_partial(reaction_id_check,\n                          frozenset(r.id for r in model.reactions))\n        ]\n        super(Medium, self).validate(model=model, checks=checks + custom)", "response": "Use a defined schema to validate the medium table format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the defined medium on the given model.", "response": "def apply(self, model):\n        \"\"\"Set the defined medium on the given model.\"\"\"\n        model.medium = {row.exchange: row.uptake\n                        for row in self.data.itertuples(index=False)}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_environment_information(meta):\n        meta[\"timestamp\"] = datetime.utcnow().isoformat(\" \")\n        meta[\"platform\"] = platform.system()\n        meta[\"release\"] = platform.release()\n        meta[\"python\"] = platform.python_version()\n        meta[\"packages\"] = get_pkg_info(\"memote\")", "response": "Add environment information to the metadata dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_transported_elements(rxn):\n    element_dist = defaultdict()\n    # Collecting elements for each metabolite.\n    for met in rxn.metabolites:\n        if met.compartment not in element_dist:\n            # Multiplication by the metabolite stoichiometry.\n            element_dist[met.compartment] = \\\n                {k: v * rxn.metabolites[met]\n                 for (k, v) in iteritems(met.elements)}\n        else:\n            x = {k: v * rxn.metabolites[met] for (k, v) in\n                 iteritems(met.elements)}\n            y = element_dist[met.compartment]\n            element_dist[met.compartment] = \\\n                {k: x.get(k, 0) + y.get(k, 0) for k in set(x) | set(y)}\n    delta_dict = defaultdict()\n    # Simplification of the resulting dictionary of dictionaries.\n    for elements in itervalues(element_dist):\n        delta_dict.update(elements)\n    # Only non-zero values get included in the returned delta-dict.\n    delta_dict = {k: abs(v) for (k, v) in iteritems(delta_dict) if v != 0}\n    return delta_dict", "response": "Find transported elements of a reaction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_transport_reactions(model):\n    transport_reactions = []\n    transport_rxn_candidates = set(model.reactions) - set(model.boundary) \\\n        - set(find_biomass_reaction(model))\n    transport_rxn_candidates = set(\n        [rxn for rxn in transport_rxn_candidates if len(rxn.compartments) >= 2]\n    )\n    # Add all labeled transport reactions\n    sbo_matches = set([rxn for rxn in transport_rxn_candidates if\n                       rxn.annotation is not None and\n                       'sbo' in rxn.annotation and\n                       rxn.annotation['sbo'] in TRANSPORT_RXN_SBO_TERMS])\n    if len(sbo_matches) > 0:\n        transport_reactions += list(sbo_matches)\n    # Find unlabeled transport reactions via formula or annotation checks\n    for rxn in transport_rxn_candidates:\n        # Check if metabolites have formula field\n        rxn_mets = set([met.formula for met in rxn.metabolites])\n        if (None not in rxn_mets) and (len(rxn_mets) != 0):\n            if is_transport_reaction_formulae(rxn):\n                transport_reactions.append(rxn)\n        elif is_transport_reaction_annotations(rxn):\n            transport_reactions.append(rxn)\n\n    return set(transport_reactions)", "response": "Returns a list of all transport reactions in the given metabolite model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_transport_reaction_formulae(rxn):\n    # Collecting criteria to classify transporters by.\n    rxn_reactants = set([met.formula for met in rxn.reactants])\n    rxn_products = set([met.formula for met in rxn.products])\n    # Looking for formulas that stay the same on both side of the reaction.\n    transported_mets = \\\n        [formula for formula in rxn_reactants if formula in rxn_products]\n    # Collect information on the elemental differences between\n    # compartments in the reaction.\n    delta_dicts = find_transported_elements(rxn)\n    non_zero_array = [v for (k, v) in iteritems(delta_dicts) if v != 0]\n    # Excluding reactions such as oxidoreductases where no net\n    # transport of Hydrogen is occurring, but rather just an exchange of\n    # electrons or charges effecting a change in protonation.\n    if set(transported_mets) != set('H') and list(\n        delta_dicts.keys()\n    ) == ['H']:\n        pass\n    # All other reactions for which the amount of transported elements is\n    # not zero, which are not part of the model's exchange nor\n    # biomass reactions, are defined as transport reactions.\n    # This includes reactions where the transported metabolite reacts with\n    # a carrier molecule.\n    elif sum(non_zero_array):\n        return True", "response": "Returns a boolean if a reaction is a transport reaction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_transport_reaction_annotations(rxn):\n    reactants = set([(k, tuple(v)) for met in rxn.reactants\n                     for k, v in iteritems(met.annotation)\n                     if met.id != \"H\"\n                     and k is not None and k != 'sbo' and v is not None])\n    products = set([(k, tuple(v)) for met in rxn.products\n                    for k, v in iteritems(met.annotation)\n                    if met.id != \"H\"\n                    and k is not None and k != 'sbo' and v is not None])\n    # Find intersection between reactant annotations and\n    # product annotations to find common metabolites between them,\n    # satisfying the requirements for a transport reaction. Reactions such\n    # as those involving oxidoreductases (where no net transport of\n    # Hydrogen is occurring, but rather just an exchange of electrons or\n    # charges effecting a change in protonation) are excluded.\n    transported_mets = reactants & products\n    if len(transported_mets) > 0:\n        return True", "response": "Returns a boolean if a reaction is a transport reaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_converting_reactions(model, pair):\n    first = set(find_met_in_model(model, pair[0]))\n    second = set(find_met_in_model(model, pair[1]))\n    hits = list()\n    for rxn in model.reactions:\n        # FIXME: Use `set.issubset` much more idiomatic.\n        if len(first & set(rxn.reactants)) > 0 and len(\n                second & set(rxn.products)) > 0:\n            hits.append(rxn)\n        elif len(first & set(rxn.products)) > 0 and len(\n                second & set(rxn.reactants)) > 0:\n            hits.append(rxn)\n    return frozenset(hits)", "response": "Find all reactions which convert a given metabolite pair."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of the biomass reaction(s) of the model. This function identifies possible biomass reactions using two steps: 1. Return reactions that include the SBO annotation \"SBO:0000629\" for biomass. If no reactions can be identifies this way: 2. Look for the ``buzzwords`` \"biomass\", \"growth\" and \"bof\" in reaction IDs. 3. Look for metabolite IDs or names that contain the ``buzzword`` \"biomass\" and obtain the set of reactions they are involved in. 4. Remove boundary reactions from this set. 5. Return the union of reactions that match the buzzwords and of the reactions that metabolites are involved in that match the buzzword. Parameters ---------- model : cobra.Model The metabolic model under investigation. Returns ------- list Identified biomass reactions.", "response": "def find_biomass_reaction(model):\n    \"\"\"\n    Return a list of the biomass reaction(s) of the model.\n\n    This function identifies possible biomass reactions using two steps:\n    1. Return reactions that include the SBO annotation \"SBO:0000629\" for\n    biomass.\n    If no reactions can be identifies this way:\n    2. Look for the ``buzzwords`` \"biomass\", \"growth\" and \"bof\" in reaction IDs.\n    3. Look for metabolite IDs or names that contain the ``buzzword`` \"biomass\"\n    and obtain the set of reactions they are involved in.\n    4. Remove boundary reactions from this set.\n    5. Return the union of reactions that match the buzzwords and of the\n    reactions that metabolites are involved in that match the buzzword.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Returns\n    -------\n    list\n        Identified biomass reactions.\n\n    \"\"\"\n    sbo_matches = set([rxn for rxn in model.reactions if\n                       rxn.annotation is not None and\n                       'sbo' in rxn.annotation and\n                       rxn.annotation['sbo'] == 'SBO:0000629'])\n\n    if len(sbo_matches) > 0:\n        return list(sbo_matches)\n\n    buzzwords = ['biomass', 'growth', 'bof']\n\n    buzzword_matches = set([rxn for rxn in model.reactions if any(\n        string in rxn.id.lower() for string in buzzwords)])\n\n    biomass_met = []\n    for met in model.metabolites:\n        if 'biomass' in met.id.lower() or (\n                met.name is not None and 'biomass' in met.name.lower()):\n            biomass_met.append(met)\n    if biomass_met == 1:\n        biomass_met_matches = set(\n            biomass_met.reactions\n        ) - set(model.boundary)\n    else:\n        biomass_met_matches = set()\n\n    return list(buzzword_matches | biomass_met_matches)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_demand_reactions(model):\n    try:\n        extracellular = find_compartment_id_in_model(model, 'e')\n    except KeyError:\n        extracellular = None\n    return find_boundary_types(model, 'demand', extracellular)", "response": "u Returns a list of demand reactions in the given metabolic model."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the set of all transport boundary and biomass reactions.", "response": "def find_interchange_biomass_reactions(model, biomass=None):\n    \"\"\"\n    Return the set of all transport, boundary, and biomass reactions.\n\n    These reactions are either pseudo-reactions, or incorporated to allow\n    metabolites to pass between compartments. Some tests focus on purely\n    metabolic reactions and hence exclude this set.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n    biomass : list or cobra.Reaction, optional\n        A list of cobrapy biomass reactions.\n\n    \"\"\"\n    boundary = set(model.boundary)\n    transporters = find_transport_reactions(model)\n    if biomass is None:\n        biomass = set(find_biomass_reaction(model))\n    return boundary | transporters | biomass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_fba(model, rxn_id, direction=\"max\", single_value=True):\n    model.objective = model.reactions.get_by_id(rxn_id)\n    model.objective_direction = direction\n    if single_value:\n        try:\n            return model.slim_optimize()\n        except Infeasible:\n            return np.nan\n    else:\n        try:\n            solution = model.optimize()\n            return solution\n        except Infeasible:\n            return np.nan", "response": "Runs a FBA problem on a set of reactions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close_boundaries_sensibly(model):\n    for rxn in model.reactions:\n        if rxn.reversibility:\n            rxn.bounds = -1, 1\n        else:\n            rxn.bounds = 0, 1\n    for boundary in model.boundary:\n        boundary.bounds = (0, 0)", "response": "Solve a metabolic model with all boundaries closed and changed constraints."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all metabolites belonging to a given compartment.", "response": "def metabolites_per_compartment(model, compartment_id):\n    \"\"\"\n    Identify all metabolites that belong to a given compartment.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n    compartment_id : string\n        Model specific compartment identifier.\n\n    Returns\n    -------\n    list\n        List of metabolites belonging to a given compartment.\n\n    \"\"\"\n    return [met for met in model.metabolites\n            if met.compartment == compartment_id]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef largest_compartment_id_met(model):\n    # Sort compartments by decreasing size and extract the largest two.\n    candidate, second = sorted(\n        ((c, len(metabolites_per_compartment(model, c)))\n         for c in model.compartments), reverse=True, key=itemgetter(1))[:2]\n    # Compare the size of the compartments.\n    if candidate[1] == second[1]:\n        raise RuntimeError(\"There is a tie for the largest compartment. \"\n                           \"Compartment {} and {} have equal amounts of \"\n                           \"metabolites.\".format(candidate[0], second[0]))\n    else:\n        return candidate[0]", "response": "Returns the ID of the largest compartment with the most metabolites."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_compartment_id_in_model(model, compartment_id):\n    if compartment_id not in COMPARTMENT_SHORTLIST.keys():\n        raise KeyError(\"{} is not in the COMPARTMENT_SHORTLIST! Make sure \"\n                       \"you typed the ID correctly, if yes, update the \"\n                       \"shortlist manually.\".format(compartment_id))\n\n    if len(model.compartments) == 0:\n        raise KeyError(\n            \"It was not possible to identify the \"\n            \"compartment {}, since the \"\n            \"model has no compartments at \"\n            \"all.\".format(COMPARTMENT_SHORTLIST[compartment_id][0])\n        )\n\n    if compartment_id in model.compartments.keys():\n        return compartment_id\n\n    for name in COMPARTMENT_SHORTLIST[compartment_id]:\n        for c_id, c_name in model.compartments.items():\n            if c_name.lower() == name:\n                return c_id\n\n    if compartment_id == 'c':\n        return largest_compartment_id_met(model)", "response": "Find a model compartment by looking up names in COMPARTMENT_SHORTLIST."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_met_in_model(model, mnx_id, compartment_id=None):\n    def compare_annotation(annotation):\n        \"\"\"\n        Return annotation IDs that match to METANETX_SHORTLIST references.\n\n        Compares the set of METANETX_SHORTLIST references for a given mnx_id\n        and the annotation IDs stored in a given annotation dictionary.\n        \"\"\"\n        query_values = set(utils.flatten(annotation.values()))\n        ref_values = set(utils.flatten(METANETX_SHORTLIST[mnx_id]))\n        return query_values & ref_values\n\n    # Make sure that the MNX ID we're looking up exists in the metabolite\n    # shortlist.\n    if mnx_id not in METANETX_SHORTLIST.columns:\n        raise ValueError(\n            \"{} is not in the MetaNetX Shortlist! Make sure \"\n            \"you typed the ID correctly, if yes, update the \"\n            \"shortlist by updating and re-running the script \"\n            \"generate_mnx_shortlists.py.\".format(mnx_id)\n        )\n    candidates = []\n    # The MNX ID used in the model may or may not be tagged with a compartment\n    # tag e.g. `MNXM23141_c` vs. `MNXM23141`, which is tested with the\n    # following regex.\n    # If the MNX ID itself cannot be found as an ID, we try all other\n    # identifiers that are provided by our shortlist of MetaNetX' mapping\n    # table.\n    regex = re.compile('^{}(_[a-zA-Z0-9]+)?$'.format(mnx_id))\n    if model.metabolites.query(regex):\n        candidates = model.metabolites.query(regex)\n    elif model.metabolites.query(compare_annotation, attribute='annotation'):\n        candidates = model.metabolites.query(\n            compare_annotation, attribute='annotation'\n        )\n    else:\n        for value in METANETX_SHORTLIST[mnx_id]:\n            if value:\n                for ident in value:\n                    regex = re.compile('^{}(_[a-zA-Z0-9]+)?$'.format(ident))\n                    if model.metabolites.query(regex, attribute='id'):\n                        candidates.extend(\n                            model.metabolites.query(regex, attribute='id'))\n\n    # Return a list of all possible candidates if no specific compartment ID\n    # is provided.\n    # Otherwise, just return the candidate in one specific compartment. Raise\n    # an exception if there are more than one possible candidates for a given\n    # compartment.\n    if compartment_id is None:\n        print(\"compartment_id = None?\")\n        return candidates\n    else:\n        candidates_in_compartment = \\\n            [cand for cand in candidates if cand.compartment == compartment_id]\n\n    if len(candidates_in_compartment) == 0:\n        raise RuntimeError(\"It was not possible to identify \"\n                           \"any metabolite in compartment {} corresponding to \"\n                           \"the following MetaNetX identifier: {}.\"\n                           \"Make sure that a cross-reference to this ID in \"\n                           \"the MetaNetX Database exists for your \"\n                           \"identifier \"\n                           \"namespace.\".format(compartment_id, mnx_id))\n    elif len(candidates_in_compartment) > 1:\n        raise RuntimeError(\"It was not possible to uniquely identify \"\n                           \"a single metabolite in compartment {} that \"\n                           \"corresponds to the following MetaNetX \"\n                           \"identifier: {}.\"\n                           \"Instead these candidates were found: {}.\"\n                           \"Check that metabolite compartment tags are \"\n                           \"correct. Consider switching to a namespace scheme \"\n                           \"where identifiers are truly \"\n                           \"unique.\".format(compartment_id,\n                                            mnx_id,\n                                            utils.get_ids(\n                                                candidates_in_compartment\n                                            ))\n                           )\n    else:\n        return candidates_in_compartment", "response": "Find metabolites in a given model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the median upper and lower bound of the metabolic model.", "response": "def find_bounds(model):\n    \"\"\"\n    Return the median upper and lower bound of the metabolic model.\n\n    Bounds can vary from model to model. Cobrapy defaults to (-1000, 1000) but\n    this may not be the case for merged or autogenerated models. In these\n    cases, this function is used to iterate over all the bounds of all the\n    reactions and find the median bound values in the model, which are\n    then used as the 'most common' bounds.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    \"\"\"\n    lower_bounds = np.asarray([rxn.lower_bound for rxn in model.reactions],\n                              dtype=float)\n    upper_bounds = np.asarray([rxn.upper_bound for rxn in model.reactions],\n                              dtype=float)\n    lower_bound = np.nanmedian(lower_bounds[lower_bounds != 0.0])\n    upper_bound = np.nanmedian(upper_bounds[upper_bounds != 0.0])\n    if np.isnan(lower_bound):\n        LOGGER.warning(\"Could not identify a median lower bound.\")\n        lower_bound = -1000.0\n    if np.isnan(upper_bound):\n        LOGGER.warning(\"Could not identify a median upper bound.\")\n        upper_bound = 1000.0\n    return lower_bound, upper_bound"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_html(self):\n        return self._template.safe_substitute(\n            report_type=self._report_type,\n            results=self.render_json()\n        )", "response": "Render an HTML report."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compute_score(self):\n        # LOGGER.info(\"Begin scoring\")\n        cases = self.get_configured_tests() | set(self.result.cases)\n        scores = DataFrame({\"score\": 0.0, \"max\": 1.0},\n                           index=sorted(cases))\n        self.result.setdefault(\"score\", dict())\n        self.result[\"score\"][\"sections\"] = list()\n        # Calculate the scores for each test individually.\n        for test, result in iteritems(self.result.cases):\n            # LOGGER.info(\"Calculate score for test: '%s'.\", test)\n            # Test metric may be a dictionary for a parametrized test.\n            metric = result[\"metric\"]\n            if hasattr(metric, \"items\"):\n                result[\"score\"] = test_score = dict()\n                total = 0.0\n                for key, value in iteritems(metric):\n                    value = 1.0 - value\n                    total += value\n                    test_score[key] = value\n                # For some reason there are parametrized tests without cases.\n                if len(metric) == 0:\n                    metric = 0.0\n                else:\n                    metric = total / len(metric)\n            else:\n                metric = 1.0 - metric\n            scores.at[test, \"score\"] = metric\n            scores.loc[test, :] *= self.config[\"weights\"].get(test, 1.0)\n        score = 0.0\n        maximum = 0.0\n        # Calculate the scores for each section considering the individual test\n        # case scores.\n        for section_id, card in iteritems(\n            self.config['cards']['scored']['sections']\n        ):\n            # LOGGER.info(\"Calculate score for section: '%s'.\", section_id)\n            cases = card.get(\"cases\", None)\n            if cases is None:\n                continue\n            card_score = scores.loc[cases, \"score\"].sum()\n            card_total = scores.loc[cases, \"max\"].sum()\n            # Format results nicely to work immediately with Vega Bar Chart.\n            section_score = {\"section\": section_id,\n                             \"score\": card_score / card_total}\n            self.result[\"score\"][\"sections\"].append(section_score)\n            # Calculate the final score for the entire model.\n            weight = card.get(\"weight\", 1.0)\n            score += card_score * weight\n            maximum += card_total * weight\n        self.result[\"score\"][\"total_score\"] = score / maximum", "response": "Calculate the overall test score using the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_components_without_sbo_terms(model, components):\n    return [elem for elem in getattr(model, components) if\n            elem.annotation is None or 'sbo' not in elem.annotation]", "response": "Returns a list of model components that are not annotated with any SBO terms."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_component_for_specific_sbo_term(items, term):\n    # check for multiple allowable SBO terms\n    if isinstance(term, list):\n        return [elem for elem in items if\n                elem.annotation is None or\n                'sbo' not in elem.annotation or\n                not any(i in elem.annotation['sbo'] for i in term)]\n    else:\n        return [elem for elem in items if\n                elem.annotation is None or\n                'sbo' not in elem.annotation or\n                term not in elem.annotation['sbo']]", "response": "r Checks if a specific SBO term is present in the model components."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the smallest KEGG compound identifier from a list of mixed KEGG identifiers.", "response": "def get_smallest_compound_id(compounds_identifiers):\n    \"\"\"\n    Return the smallest KEGG compound identifier from a list.\n\n    KEGG identifiers may map to compounds, drugs or glycans prefixed\n    respectively with \"C\", \"D\", and \"G\" followed by at least 5 digits. We\n    choose the lowest KEGG identifier with the assumption that several\n    identifiers are due to chirality and that the lower one represents the\n    more common form.\n\n    Parameters\n    ----------\n    compounds_identifiers : list\n        A list of mixed KEGG identifiers.\n\n    Returns\n    -------\n    str\n        The KEGG compound identifier with the smallest number.\n\n    Raises\n    ------\n    ValueError\n        When compound_identifiers contains no KEGG compound identifiers.\n\n    \"\"\"\n    return min((c for c in compounds_identifiers if c.startswith(\"C\")),\n               key=lambda c: int(c[1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef map_metabolite2kegg(metabolite):\n    logger.debug(\"Looking for KEGG compound identifier for %s.\", metabolite.id)\n    kegg_annotation = metabolite.annotation.get(\"kegg.compound\")\n    if kegg_annotation is None:\n        # TODO (Moritz Beber): Currently name matching is very slow and\n        #  inaccurate. We disable it until there is a better solution.\n        # if metabolite.name:\n        #     # The compound matcher uses regular expression and chokes\n        #     # with a low level error on `[` in the name, for example.\n        #     df = compound_matcher.match(metabolite.name)\n        #     try:\n        #         return df.loc[df[\"score\"] > threshold, \"CID\"].iat[0]\n        #     except (IndexError, AttributeError):\n        #         logger.warning(\n        #             \"Could not match the name %r to any kegg.compound \"\n        #             \"annotation for metabolite %s.\",\n        #             metabolite.name, metabolite.id\n        #         )\n        #         return\n        # else:\n        logger.warning(\"No kegg.compound annotation for metabolite %s.\",\n                       metabolite.id)\n        return\n    if isinstance(kegg_annotation, string_types) and \\\n            kegg_annotation.startswith(\"C\"):\n        return kegg_annotation\n    elif isinstance(kegg_annotation, Iterable):\n        try:\n            return get_smallest_compound_id(kegg_annotation)\n        except ValueError:\n            return\n    logger.warning(\n        \"No matching kegg.compound annotation for metabolite %s.\",\n        metabolite.id\n    )\n    return", "response": "Map a metabolite to its KEGG compound identifier."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef translate_reaction(reaction, metabolite_mapping):\n    # Transport reactions where the same metabolite occurs in different\n    # compartments should have been filtered out but just to be sure, we add\n    # coefficients in the mapping.\n    stoichiometry = defaultdict(float)\n    for met, coef in iteritems(reaction.metabolites):\n        kegg_id = metabolite_mapping.setdefault(met, map_metabolite2kegg(met))\n        if kegg_id is None:\n            continue\n        stoichiometry[kegg_id] += coef\n    return dict(stoichiometry)", "response": "Translate a reaction into a KEGG compound identifier to coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_thermodynamic_reversibility_index(reactions):\n    incomplete_mapping = []\n    problematic_calculation = []\n    reversibility_indexes = []\n    unbalanced = []\n    metabolite_mapping = {}\n\n    for rxn in reactions:\n        stoich = translate_reaction(rxn, metabolite_mapping)\n        if len(stoich) < len(rxn.metabolites):\n            incomplete_mapping.append(rxn)\n            continue\n        try:\n            # Remove protons from stoichiometry.\n            if \"C00080\" in stoich:\n                del stoich[\"C00080\"]\n            eq_rxn = Reaction(stoich, rxn.id)\n        except KeyError:\n            incomplete_mapping.append(rxn)\n            continue\n        if eq_rxn.check_full_reaction_balancing():\n            try:\n                ln_rev_index = eq_rxn.reversibility_index()\n            # TODO (Moritz Beber): Which exceptions can we expect here?\n            except Exception:\n                problematic_calculation.append(rxn)\n                continue\n            reversibility_indexes.append((rxn, ln_rev_index))\n        else:\n            unbalanced.append(rxn)\n    reversibility_indexes.sort(key=lambda p: abs(p[1]), reverse=True)\n    return (\n        reversibility_indexes, incomplete_mapping, problematic_calculation,\n        unbalanced\n    )", "response": "u This function returns the reversibility index of the given reactions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_stoichiometric_consistency(model):\n    problem = model.problem\n    # The transpose of the stoichiometric matrix N.T in the paper.\n    stoich_trans = problem.Model()\n    internal_rxns = con_helpers.get_internals(model)\n    metabolites = set(met for rxn in internal_rxns for met in rxn.metabolites)\n    LOGGER.info(\"model '%s' has %d internal reactions\", model.id,\n                len(internal_rxns))\n    LOGGER.info(\"model '%s' has %d internal metabolites\", model.id,\n                len(metabolites))\n\n    stoich_trans.add([problem.Variable(m.id, lb=1) for m in metabolites])\n    stoich_trans.update()\n    con_helpers.add_reaction_constraints(\n        stoich_trans, internal_rxns, problem.Constraint)\n    # The objective is to minimize the metabolite mass vector.\n    stoich_trans.objective = problem.Objective(\n        Zero, direction=\"min\", sloppy=True)\n    stoich_trans.objective.set_linear_coefficients(\n        {var: 1. for var in stoich_trans.variables})\n    status = stoich_trans.optimize()\n    if status == OPTIMAL:\n        return True\n    elif status == INFEASIBLE:\n        return False\n    else:\n        raise RuntimeError(\n            \"Could not determine stoichiometric consistencty.\"\n            \" Solver status is '{}'\"\n            \" (only optimal or infeasible expected).\".format(status))", "response": "Verify consistency of the metabolic model s stoichiometry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_unconserved_metabolites(model):\n    problem = model.problem\n    stoich_trans = problem.Model()\n    internal_rxns = con_helpers.get_internals(model)\n    metabolites = set(met for rxn in internal_rxns for met in rxn.metabolites)\n    # The binary variables k[i] in the paper.\n    k_vars = list()\n    for met in metabolites:\n        # The element m[i] of the mass vector.\n        m_var = problem.Variable(met.id)\n        k_var = problem.Variable(\"k_{}\".format(met.id), type=\"binary\")\n        k_vars.append(k_var)\n        stoich_trans.add([m_var, k_var])\n        # This constraint is equivalent to 0 <= k[i] <= m[i].\n        stoich_trans.add(problem.Constraint(\n            k_var - m_var, ub=0, name=\"switch_{}\".format(met.id)))\n    stoich_trans.update()\n    con_helpers.add_reaction_constraints(\n        stoich_trans, internal_rxns, problem.Constraint)\n    # The objective is to maximize the binary indicators k[i], subject to the\n    # above inequality constraints.\n    stoich_trans.objective = problem.Objective(\n        Zero, sloppy=True, direction=\"max\")\n    stoich_trans.objective.set_linear_coefficients(\n        {var: 1. for var in k_vars})\n    status = stoich_trans.optimize()\n    if status == OPTIMAL:\n        # TODO: See if that could be a Boolean test `bool(var.primal)`.\n        return set([model.metabolites.get_by_id(var.name[2:])\n                    for var in k_vars if var.primal < 0.8])\n    else:\n        raise RuntimeError(\n            \"Could not compute list of unconserved metabolites.\"\n            \" Solver status is '{}' (only optimal expected).\".format(status))", "response": "Detect unconserved metabolites.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Notes\n    -----\n    See [1]_ section 3.2 for a complete description of the algorithm.\n\n\n    .. [1] Gevorgyan, A., M. G Poolman, and D. A Fell.\n           \"Detection of Stoichiometric Inconsistencies in Biomolecular\n           Models.\"\n           Bioinformatics 24, no. 19 (2008): 2245."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetects inconsistent minimal net stoichiometries in Biomolecular Models.", "response": "def find_inconsistent_min_stoichiometry(model, atol=1e-13):\n    \"\"\"\n    Detect inconsistent minimal net stoichiometries.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n    atol : float, optional\n        Values below the absolute tolerance are treated as zero. Expected to be\n        very small but larger than zero.\n\n    Notes\n    -----\n    See [1]_ section 3.3 for a complete description of the algorithm.\n\n    References\n    ----------\n    .. [1] Gevorgyan, A., M. G Poolman, and D. A Fell.\n           \"Detection of Stoichiometric Inconsistencies in Biomolecular\n           Models.\"\n           Bioinformatics 24, no. 19 (2008): 2245.\n\n    \"\"\"\n    if check_stoichiometric_consistency(model):\n        return set()\n    Model, Constraint, Variable, Objective = con_helpers.get_interface(model)\n    unconserved_mets = find_unconserved_metabolites(model)\n    LOGGER.info(\"model has %d unconserved metabolites\", len(unconserved_mets))\n    internal_rxns = con_helpers.get_internals(model)\n    internal_mets = set(\n        met for rxn in internal_rxns for met in rxn.metabolites)\n    get_id = attrgetter(\"id\")\n    reactions = sorted(internal_rxns, key=get_id)\n    metabolites = sorted(internal_mets, key=get_id)\n    stoich, met_index, rxn_index = con_helpers.stoichiometry_matrix(\n        metabolites, reactions)\n    left_ns = con_helpers.nullspace(stoich.T)\n    # deal with numerical instabilities\n    left_ns[np.abs(left_ns) < atol] = 0.0\n    LOGGER.info(\"nullspace has dimension %d\", left_ns.shape[1])\n    inc_minimal = set()\n    (problem, indicators) = con_helpers.create_milp_problem(\n        left_ns, metabolites, Model, Variable, Constraint, Objective)\n    LOGGER.debug(str(problem))\n    cuts = list()\n    for met in unconserved_mets:\n        row = met_index[met]\n        if (left_ns[row] == 0.0).all():\n            LOGGER.debug(\"%s: singleton minimal unconservable set\", met.id)\n            # singleton set!\n            inc_minimal.add((met,))\n            continue\n        # expect a positive mass for the unconserved metabolite\n        problem.variables[met.id].lb = 1e-3\n        status = problem.optimize()\n        while status == \"optimal\":\n            LOGGER.debug(\"%s: status %s\", met.id, status)\n            LOGGER.debug(\"sum of all primal values: %f\",\n                         sum(problem.primal_values.values()))\n            LOGGER.debug(\"sum of binary indicators: %f\",\n                         sum(var.primal for var in indicators))\n            solution = [model.metabolites.get_by_id(var.name[2:])\n                        for var in indicators if var.primal > 0.2]\n            LOGGER.debug(\"%s: set size %d\", met.id, len(solution))\n            inc_minimal.add(tuple(solution))\n            if len(solution) == 1:\n                break\n            cuts.append(con_helpers.add_cut(\n                problem, indicators, len(solution) - 1, Constraint))\n            status = problem.optimize()\n        LOGGER.debug(\"%s: last status %s\", met.id, status)\n        # reset\n        problem.variables[met.id].lb = 0.0\n        problem.remove(cuts)\n        cuts.clear()\n    return inc_minimal"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef detect_energy_generating_cycles(model, metabolite_id):\n    main_comp = helpers.find_compartment_id_in_model(model, 'c')\n    met = helpers.find_met_in_model(model, metabolite_id, main_comp)[0]\n\n    dissipation_rxn = Reaction('Dissipation')\n    if metabolite_id in ['MNXM3', 'MNXM63', 'MNXM51', 'MNXM121', 'MNXM423']:\n        # build nucleotide-type dissipation reaction\n        dissipation_rxn.add_metabolites({\n            helpers.find_met_in_model(model, 'MNXM2', main_comp)[0]: -1,\n            helpers.find_met_in_model(model, 'MNXM1', main_comp)[0]: 1,\n            helpers.find_met_in_model(model, 'MNXM9', main_comp)[0]: 1,\n        })\n    elif metabolite_id in ['MNXM6', 'MNXM10']:\n        # build nicotinamide-type dissipation reaction\n        dissipation_rxn.add_metabolites({\n            helpers.find_met_in_model(model, 'MNXM1', main_comp)[0]: 1\n        })\n    elif metabolite_id in ['MNXM38', 'MNXM208', 'MNXM191', 'MNXM223',\n                           'MNXM7517', 'MNXM12233', 'MNXM558']:\n        # build redox-partner-type dissipation reaction\n        dissipation_rxn.add_metabolites({\n            helpers.find_met_in_model(model, 'MNXM1', main_comp)[0]: 2\n        })\n    elif metabolite_id == 'MNXM21':\n        dissipation_rxn.add_metabolites({\n            helpers.find_met_in_model(model, 'MNXM2', main_comp)[0]: -1,\n            helpers.find_met_in_model(model, 'MNXM1', main_comp)[0]: 1,\n            helpers.find_met_in_model(model, 'MNXM26', main_comp)[0]: 1,\n        })\n    elif metabolite_id == 'MNXM89557':\n        dissipation_rxn.add_metabolites({\n            helpers.find_met_in_model(model, 'MNXM2', main_comp)[0]: -1,\n            helpers.find_met_in_model(model, 'MNXM1', main_comp)[0]: 2,\n            helpers.find_met_in_model(model, 'MNXM15', main_comp)[0]: 1,\n        })\n\n    dissipation_product = helpers.find_met_in_model(\n        model,\n        ENERGY_COUPLES[metabolite_id],\n        main_comp)[0]\n\n    dissipation_rxn.add_metabolites(\n        {met: -1, dissipation_product: 1})\n    helpers.close_boundaries_sensibly(model)\n    model.add_reactions([dissipation_rxn])\n    model.objective = dissipation_rxn\n    solution = model.optimize(raise_error=True)\n\n    if solution.objective_value > 0.0:\n        return solution.fluxes[solution.fluxes.abs() > 0.0].index. \\\n            drop([\"Dissipation\"]).tolist()\n    else:\n        return []", "response": "u Detect erroneous energy - generating cycles for a single metabolite."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_stoichiometrically_balanced_cycles(model):\n    helpers.close_boundaries_sensibly(model)\n    fva_result = flux_variability_analysis(model, loopless=False)\n    return fva_result.index[\n        (fva_result[\"minimum\"] <= (-1 + TOLERANCE_THRESHOLD)) |\n        (fva_result[\"maximum\"] >= (1 - TOLERANCE_THRESHOLD))\n    ].tolist()", "response": "u Find metabolic reactions that carry a non - balanced cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns metabolites that are only consumed in reactions and are not involved in exchange.", "response": "def find_orphans(model):\n    \"\"\"\n    Return metabolites that are only consumed in reactions.\n\n    Metabolites that are involved in an exchange reaction are never\n    considered to be orphaned.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    \"\"\"\n    exchange = frozenset(model.exchanges)\n    return [\n        met for met in model.metabolites\n        if (len(met.reactions) > 0) and all(\n            (not rxn.reversibility) and (rxn not in exchange) and\n            (rxn.metabolites[met] < 0) for rxn in met.reactions\n        )\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding metabolites that cannot be produced with open exchange reactions.", "response": "def find_metabolites_not_produced_with_open_bounds(model):\n    \"\"\"\n    Return metabolites that cannot be produced with open exchange reactions.\n\n    A perfect model should be able to produce each and every metabolite when\n    all medium components are available.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Returns\n    -------\n    list\n        Those metabolites that could not be produced.\n\n    \"\"\"\n    mets_not_produced = list()\n    helpers.open_exchanges(model)\n    for met in model.metabolites:\n        with model:\n            exch = model.add_boundary(\n                met, type=\"irrex\", reaction_id=\"IRREX\", lb=0, ub=1000)\n            solution = helpers.run_fba(model, exch.id)\n            if np.isnan(solution) or solution < TOLERANCE_THRESHOLD:\n                mets_not_produced.append(met)\n    return mets_not_produced"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_metabolites_not_consumed_with_open_bounds(model):\n    mets_not_consumed = list()\n    helpers.open_exchanges(model)\n    for met in model.metabolites:\n        with model:\n            exch = model.add_boundary(\n                met, type=\"irrex\", reaction_id=\"IRREX\", lb=-1000, ub=0)\n            solution = helpers.run_fba(model, exch.id, direction=\"min\")\n            if np.isnan(solution) or abs(solution) < TOLERANCE_THRESHOLD:\n                mets_not_consumed.append(met)\n    return mets_not_consumed", "response": "Finds metabolites that cannot be consumed with open boundary reactions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_reactions_with_unbounded_flux_default_condition(model):\n    try:\n        fva_result = flux_variability_analysis(model, fraction_of_optimum=1.0)\n    except Infeasible as err:\n        LOGGER.error(\"Failed to find reactions with unbounded flux \"\n                     \"because '{}'. This may be a bug.\".format(err))\n        raise Infeasible(\"It was not possible to run flux variability \"\n                         \"analysis on the model. Make sure that the model \"\n                         \"can be solved! Check if the constraints are not \"\n                         \"too strict.\")\n    # Per reaction (row) the flux is below threshold (close to zero).\n    conditionally_blocked = fva_result.loc[\n        fva_result.abs().max(axis=1) < TOLERANCE_THRESHOLD\n    ].index.tolist()\n    small, large = helpers.find_bounds(model)\n    # Find those reactions whose flux is close to or outside of the median\n    # upper or lower bound, i.e., appears unconstrained.\n    unlimited_flux = fva_result.loc[\n        np.isclose(fva_result[\"maximum\"], large, atol=TOLERANCE_THRESHOLD) |\n        (fva_result[\"maximum\"] > large) |\n        np.isclose(fva_result[\"minimum\"], small, atol=TOLERANCE_THRESHOLD) |\n        (fva_result[\"minimum\"] < small)\n    ].index.tolist()\n    try:\n        fraction = len(unlimited_flux) / \\\n            (len(model.reactions) - len(conditionally_blocked))\n    except ZeroDivisionError:\n        LOGGER.error(\"Division by Zero! Failed to calculate the \"\n                     \"fraction of unbounded reactions. Does this model \"\n                     \"have any reactions at all?\")\n        raise ZeroDivisionError(\"It was not possible to calculate the \"\n                                \"fraction of unbounded reactions to \"\n                                \"un-blocked reactions. This may be because\"\n                                \"the model doesn't have any reactions at \"\n                                \"all or that none of the reactions can \"\n                                \"carry a flux larger than zero!\")\n\n    return unlimited_flux, fraction, conditionally_blocked", "response": "Find reactions whose flux is unbounded in the default condition."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_tabular(filename, dtype_conversion=None):\n    if dtype_conversion is None:\n        dtype_conversion = {}\n    name, ext = filename.split(\".\", 1)\n    ext = ext.lower()\n    # Completely empty columns are interpreted as float by default.\n    dtype_conversion[\"comment\"] = str\n    if \"csv\" in ext:\n        df = pd.read_csv(filename, dtype=dtype_conversion, encoding=\"utf-8\")\n    elif \"tsv\" in ext:\n        df = pd.read_table(filename, dtype=dtype_conversion, encoding=\"utf-8\")\n    elif \"xls\" in ext or \"xlsx\" in ext:\n        df = pd.read_excel(filename, dtype=dtype_conversion, encoding=\"utf-8\")\n    # TODO: Add a function to parse ODS data into a pandas data frame.\n    else:\n        raise ValueError(\"Unknown file format '{}'.\".format(ext))\n    return df", "response": "Read a tabular data file which can be CSV TSV XLS XLSX or ExcelX."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a snapshot of a model and generate a report.", "response": "def snapshot(model, filename, pytest_args, exclusive, skip, solver,\n             experimental, custom_tests, custom_config):\n    \"\"\"\n    Take a snapshot of a model's state and generate a report.\n\n    MODEL: Path to model file. Can also be supplied via the environment variable\n    MEMOTE_MODEL or configured in 'setup.cfg' or 'memote.ini'.\n    \"\"\"\n    model_obj, sbml_ver, notifications = api.validate_model(\n        model)\n    if model_obj is None:\n        LOGGER.critical(\n            \"The model could not be loaded due to the following SBML errors.\")\n        utils.stdout_notifications(notifications)\n        api.validation_report(model, notifications, filename)\n        sys.exit(1)\n    if not any(a.startswith(\"--tb\") for a in pytest_args):\n        pytest_args = [\"--tb\", \"no\"] + pytest_args\n    # Add further directories to search for tests.\n    pytest_args.extend(custom_tests)\n    config = ReportConfiguration.load()\n    # Update the default test configuration with custom ones (if any).\n    for custom in custom_config:\n        config.merge(ReportConfiguration.load(custom))\n    model_obj.solver = solver\n    _, results = api.test_model(model_obj, sbml_version=sbml_ver, results=True,\n                                pytest_args=pytest_args, skip=skip,\n                                exclusive=exclusive, experimental=experimental)\n    with open(filename, \"w\", encoding=\"utf-8\") as file_handle:\n        LOGGER.info(\"Writing snapshot report to '%s'.\", filename)\n        file_handle.write(api.snapshot_report(results, config))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a report over a model s git commit history.", "response": "def history(location, model, filename, deployment, custom_config):\n    \"\"\"Generate a report over a model's git commit history.\"\"\"\n    callbacks.git_installed()\n    LOGGER.info(\"Initialising history report generation.\")\n    if location is None:\n        raise click.BadParameter(\"No 'location' given or configured.\")\n    try:\n        repo = git.Repo()\n    except git.InvalidGitRepositoryError:\n        LOGGER.critical(\n            \"The history report requires a git repository in order to check \"\n            \"the model's commit history.\")\n        sys.exit(1)\n    LOGGER.info(\"Obtaining history of results from \"\n                \"the deployment branch {}.\".format(deployment))\n    repo.git.checkout(deployment)\n    try:\n        manager = managers.SQLResultManager(repository=repo, location=location)\n    except (AttributeError, ArgumentError):\n        manager = managers.RepoResultManager(\n            repository=repo, location=location)\n    config = ReportConfiguration.load()\n    # Update the default test configuration with custom ones (if any).\n    for custom in custom_config:\n        config.merge(ReportConfiguration.load(custom))\n    LOGGER.info(\"Tracing the commit history.\")\n    history = managers.HistoryManager(repository=repo, manager=manager)\n    history.load_history(model, skip={deployment})\n    LOGGER.info(\"Composing the history report.\")\n    report = api.history_report(history, config=config)\n    with open(filename, \"w\", encoding=\"utf-8\") as file_handle:\n        file_handle.write(report)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef diff(models, filename, pytest_args, exclusive, skip, solver,\n         experimental, custom_tests, custom_config):\n    \"\"\"\n    Take a snapshot of all the supplied models and generate a diff report.\n\n    MODELS: List of paths to two or more model files.\n    \"\"\"\n    if not any(a.startswith(\"--tb\") for a in pytest_args):\n        pytest_args = [\"--tb\", \"no\"] + pytest_args\n    # Add further directories to search for tests.\n    pytest_args.extend(custom_tests)\n    config = ReportConfiguration.load()\n    # Update the default test configuration with custom ones (if any).\n    for custom in custom_config:\n        config.merge(ReportConfiguration.load(custom))\n    # Build the diff report specific data structure\n    diff_results = dict()\n    model_and_model_ver_tuple = list()\n    for model_path in models:\n        try:\n            model_filename = os.path.basename(model_path)\n            diff_results.setdefault(model_filename, dict())\n            model, model_ver, notifications = api.validate_model(model_path)\n            if model is None:\n                head, tail = os.path.split(filename)\n                report_path = os.path.join(\n                    head, '{}_structural_report.html'.format(model_filename))\n                api.validation_report(\n                    model_path, notifications, report_path)\n                LOGGER.critical(\n                    \"The model {} could not be loaded due to SBML errors \"\n                    \"reported in {}.\".format(model_filename, report_path))\n                continue\n            model.solver = solver\n            model_and_model_ver_tuple.append((model, model_ver))\n        except (IOError, SBMLError):\n            LOGGER.debug(exc_info=True)\n            LOGGER.warning(\"An error occurred while loading the model '%s'. \"\n                           \"Skipping.\", model_filename)\n    # Abort the diff report unless at least two models can be loaded\n    # successfully.\n    if len(model_and_model_ver_tuple) < 2:\n        LOGGER.critical(\n            \"Out of the %d provided models only %d could be loaded. Please, \"\n            \"check if the models that could not be loaded are valid SBML. \"\n            \"Aborting.\",\n            len(models), len(model_and_model_ver_tuple))\n        sys.exit(1)\n    # Running pytest in individual processes to avoid interference\n    partial_test_diff = partial(_test_diff, pytest_args=pytest_args,\n                                skip=skip, exclusive=exclusive,\n                                experimental=experimental)\n    pool = Pool(min(len(models), cpu_count()))\n    results = pool.map(partial_test_diff, model_and_model_ver_tuple)\n\n    for model_path, result in zip(models, results):\n        model_filename = os.path.basename(model_path)\n        diff_results[model_filename] = result\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file_handle:\n        LOGGER.info(\"Writing diff report to '%s'.\", filename)\n        file_handle.write(api.diff_report(diff_results, config))", "response": "Generate a diff report for all the supplied models."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninspects and record the repo s branches and their history.", "response": "def build_branch_structure(self, model, skip):\n        \"\"\"Inspect and record the repo's branches and their history.\"\"\"\n        self._history = dict()\n        self._history[\"commits\"] = commits = dict()\n        self._history[\"branches\"] = branches = dict()\n        for branch in self._repo.refs:\n            LOGGER.debug(branch.name)\n            if branch.name in skip:\n                continue\n            branches[branch.name] = branch_history = list()\n            latest = branch.commit\n            history = [latest] + list(latest.iter_parents())\n            for commit in history:\n                # Find model in committed files.\n                if not is_modified(model, commit):\n                    LOGGER.info(\n                        \"The model was not modified in commit '{}'. \"\n                        \"Skipping.\".format(commit))\n                    continue\n                branch_history.append(commit.hexsha)\n                if commit.hexsha not in commits:\n                    commits[commit.hexsha] = sub = dict()\n                    sub[\"timestamp\"] = commit.authored_datetime.isoformat(\" \")\n                    sub[\"author\"] = commit.author.name\n                    sub[\"email\"] = commit.author.email\n        LOGGER.debug(\"%s\", json.dumps(self._history, indent=2))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_history(self, model, skip={\"gh-pages\"}):\n        if self._history is None:\n            self.build_branch_structure(model, skip)\n        self._results = dict()\n        all_commits = list(self._history[\"commits\"])\n        for commit in all_commits:\n            try:\n                self._results[commit] = self.manager.load(commit)\n            except (IOError, NoResultFound) as err:\n                LOGGER.error(\"Could not load result '%s'.\", commit)\n                LOGGER.debug(\"%s\", str(err))", "response": "Load the entire results history into memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an individual result from the history if it exists.", "response": "def get_result(self, commit, default=MemoteResult()):\n        \"\"\"Return an individual result from the history if it exists.\"\"\"\n        assert self._results is not None, \\\n            \"Please call the method `load_history` first.\"\n        return self._results.get(commit, default)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the maximum and minimum absolute non - zero coefficients.", "response": "def absolute_extreme_coefficient_ratio(model):\n    \"\"\"\n    Return the maximum and minimum absolute, non-zero coefficients.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    \"\"\"\n    s_matrix, _, _ = con_helpers.stoichiometry_matrix(\n        model.metabolites, model.reactions\n    )\n    abs_matrix = np.abs(s_matrix)\n    return abs_matrix.max(), abs_matrix[abs_matrix > 0].min()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef number_independent_conservation_relations(model):\n    s_matrix, _, _ = con_helpers.stoichiometry_matrix(\n        model.metabolites, model.reactions\n    )\n    ln_matrix = con_helpers.nullspace(s_matrix.T)\n    return ln_matrix.shape[1]", "response": "Returns the number of independent conserved metabolite pools."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the rank of the stoichiometric matrix of the metabolic model.", "response": "def matrix_rank(model):\n    \"\"\"\n    Return the rank of the model's stoichiometric matrix.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    \"\"\"\n    s_matrix, _, _ = con_helpers.stoichiometry_matrix(\n        model.metabolites, model.reactions\n    )\n    return con_helpers.rank(s_matrix)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef degrees_of_freedom(model):\n    s_matrix, _, _ = con_helpers.stoichiometry_matrix(\n        model.metabolites, model.reactions\n    )\n    return s_matrix.shape[1] - matrix_rank(model)", "response": "Returns the degrees of freedom of the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading all information from an experimental configuration file.", "response": "def load(self, model):\n        \"\"\"\n        Load all information from an experimental configuration file.\n\n        Parameters\n        ----------\n        model : cobra.Model\n            The metabolic model under investigation.\n\n        \"\"\"\n        self.load_medium(model)\n        self.load_essentiality(model)\n        self.load_growth(model)\n        # self.load_experiment(config.config.get(\"growth\"), model)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the configuration file.", "response": "def validate(self):\n        \"\"\"Validate the configuration file.\"\"\"\n        validator = Draft4Validator(self.SCHEMA)\n        if not validator.is_valid(self.config):\n            for err in validator.iter_errors(self.config):\n                LOGGER.error(str(err.message))\n            validator.validate(self.config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_medium(self, model):\n        media = self.config.get(\"medium\")\n        if media is None:\n            return\n        definitions = media.get(\"definitions\")\n        if definitions is None or len(definitions) == 0:\n            return\n        path = self.get_path(media, join(\"data\", \"experimental\", \"media\"))\n        for medium_id, medium in iteritems(definitions):\n            if medium is None:\n                medium = dict()\n            filename = medium.get(\"filename\")\n            if filename is None:\n                filename = join(path, \"{}.csv\".format(medium_id))\n            elif not isabs(filename):\n                filename = join(path, filename)\n            tmp = Medium(identifier=medium_id, obj=medium, filename=filename)\n            tmp.load()\n            tmp.validate(model)\n            self.media[medium_id] = tmp", "response": "Load and validate all media."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads and validate all data files.", "response": "def load_essentiality(self, model):\n        \"\"\"Load and validate all data files.\"\"\"\n        data = self.config.get(\"essentiality\")\n        if data is None:\n            return\n        experiments = data.get(\"experiments\")\n        if experiments is None or len(experiments) == 0:\n            return\n        path = self.get_path(data,\n                             join(\"data\", \"experimental\", \"essentiality\"))\n        for exp_id, exp in iteritems(experiments):\n            if exp is None:\n                exp = dict()\n            filename = exp.get(\"filename\")\n            if filename is None:\n                filename = join(path, \"{}.csv\".format(exp_id))\n            elif not isabs(filename):\n                filename = join(path, filename)\n            experiment = EssentialityExperiment(\n                identifier=exp_id, obj=exp, filename=filename)\n            if experiment.medium is not None:\n                assert experiment.medium in self.media, \\\n                    \"Experiment '{}' has an undefined medium '{}'.\".format(\n                        exp_id, experiment.medium)\n                experiment.medium = self.media[experiment.medium]\n            experiment.load()\n            experiment.validate(model)\n            self.essentiality[exp_id] = experiment"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_growth(self, model):\n        data = self.config.get(\"growth\")\n        if data is None:\n            return\n        experiments = data.get(\"experiments\")\n        if experiments is None or len(experiments) == 0:\n            return\n        path = self.get_path(data,\n                             join(\"data\", \"experimental\", \"growth\"))\n        for exp_id, exp in iteritems(experiments):\n            if exp is None:\n                exp = dict()\n            filename = exp.get(\"filename\")\n            if filename is None:\n                filename = join(path, \"{}.csv\".format(exp_id))\n            elif not isabs(filename):\n                filename = join(path, filename)\n            growth = GrowthExperiment(\n                identifier=exp_id, obj=exp, filename=filename)\n            if growth.medium is not None:\n                assert growth.medium in self.media, \\\n                    \"Growth-experiment '{}' has an undefined medium '{}'.\" \\\n                    \"\".format(exp_id, growth.medium)\n                growth.medium = self.media[growth.medium]\n            growth.load()\n            growth.validate(model)\n            self.growth[exp_id] = growth", "response": "Load and validate all data files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_path(self, obj, default):\n        path = obj.get(\"path\")\n        if path is None:\n            path = join(self._base, default)\n        if not isabs(path):\n            path = join(self._base, path)\n        return path", "response": "Return a relative or absolute path to experimental data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding model components with empty annotation attributes.", "response": "def find_components_without_annotation(model, components):\n    \"\"\"\n    Find model components with empty annotation attributes.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        A cobrapy metabolic model.\n    components : {\"metabolites\", \"reactions\", \"genes\"}\n        A string denoting `cobra.Model` components.\n\n    Returns\n    -------\n    list\n        The components without any annotation.\n\n    \"\"\"\n    return [elem for elem in getattr(model, components) if\n            elem.annotation is None or len(elem.annotation) == 0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of elements whose annotation matches the pattern for the given MIRIAM database identifier.", "response": "def generate_component_annotation_miriam_match(elements, component, db):\n    \"\"\"\n    Tabulate which MIRIAM databases the element's annotation match.\n\n    If the relevant MIRIAM identifier is not in an element's annotation it is\n    ignored.\n\n    Parameters\n    ----------\n    elements : list\n        Elements of a model, either metabolites or reactions.\n    component : {\"metabolites\", \"reactions\"}\n        A string denoting a type of ``cobra.Model`` component.\n    db : str\n        One of the MIRIAM database identifiers.\n\n    Returns\n    -------\n    list\n        The components whose annotation does not match the pattern for the\n        MIRIAM database.\n\n    \"\"\"\n    def is_faulty(annotation, key, pattern):\n        # Ignore missing annotation for this database.\n        if key not in annotation:\n            return False\n        test = annotation[key]\n        if isinstance(test, native_str):\n            return pattern.match(test) is None\n        else:\n            return any(pattern.match(elem) is None for elem in test)\n\n    pattern = {\n        \"metabolites\": METABOLITE_ANNOTATIONS,\n        \"reactions\": REACTION_ANNOTATIONS,\n        \"genes\": GENE_PRODUCT_ANNOTATIONS\n    }[component][db]\n    return [elem for elem in elements\n            if is_faulty(elem.annotation, db, pattern)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a table of unique component identifiers for a given set of components.", "response": "def generate_component_id_namespace_overview(model, components):\n    \"\"\"\n    Tabulate which MIRIAM databases the component's identifier matches.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        A cobrapy metabolic model.\n    components : {\"metabolites\", \"reactions\", \"genes\"}\n        A string denoting `cobra.Model` components.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The index of the table is given by the component identifiers. Each\n        column corresponds to one MIRIAM database and a Boolean entry\n        determines whether the annotation matches.\n\n    \"\"\"\n    patterns = {\n        \"metabolites\": METABOLITE_ANNOTATIONS,\n        \"reactions\": REACTION_ANNOTATIONS,\n        \"genes\": GENE_PRODUCT_ANNOTATIONS\n    }[components]\n    databases = list(patterns)\n    data = list()\n    index = list()\n    for elem in getattr(model, components):\n        index.append(elem.id)\n        data.append(tuple(patterns[db].match(elem.id) is not None\n                          for db in databases))\n    df = pd.DataFrame(data, index=index, columns=databases)\n    if components != \"genes\":\n        # Clean up of the dataframe. Unfortunately the Biocyc patterns match\n        # broadly. Hence, whenever a Metabolite or Reaction ID matches to any\n        # DB pattern AND the Biocyc pattern we have to assume that this is a\n        # false positive.\n        # First determine all rows in which 'biocyc' and other entries are\n        # True simultaneously and use this Boolean series to create another\n        # column temporarily.\n        df['duplicate'] = df[df['biocyc']].sum(axis=1) >= 2\n        # Replace all nan values with False\n        df['duplicate'].fillna(False, inplace=True)\n        # Use the additional column to index the original dataframe to identify\n        # false positive biocyc hits and set them to False.\n        df.loc[df['duplicate'], 'biocyc'] = False\n        # Delete the additional column\n        del df['duplicate']\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing a representation of the confusion matrix.", "response": "def confusion_matrix(predicted_essential, expected_essential,\n                     predicted_nonessential, expected_nonessential):\n    \"\"\"\n    Compute a representation of the confusion matrix.\n\n    Parameters\n    ----------\n    predicted_essential : set\n    expected_essential : set\n    predicted_nonessential : set\n    expected_nonessential : set\n\n    Returns\n    -------\n    dict\n        Confusion matrix as different keys of a dictionary. The abbreviated\n        keys correspond to the ones used in [1]_.\n\n    References\n    ----------\n    .. [1] `Wikipedia entry for the Confusion matrix\n           <https://en.wikipedia.org/wiki/Confusion_matrix>`_\n\n    \"\"\"\n    true_positive = predicted_essential & expected_essential\n    tp = len(true_positive)\n    true_negative = predicted_nonessential & expected_nonessential\n    tn = len(true_negative)\n    false_positive = predicted_essential - expected_essential\n    fp = len(false_positive)\n    false_negative = predicted_nonessential - expected_nonessential\n    fn = len(false_negative)\n    # sensitivity or true positive rate\n    try:\n        tpr = tp / (tp + fn)\n    except ZeroDivisionError:\n        tpr = None\n    # specificity or true negative rate\n    try:\n        tnr = tn / (tn + fp)\n    except ZeroDivisionError:\n        tnr = None\n    # precision or positive predictive value\n    try:\n        ppv = tp / (tp + fp)\n    except ZeroDivisionError:\n        ppv = None\n    # false discovery rate\n    fdr = 1 - ppv\n    # accuracy\n    try:\n        acc = (tp + tn) / (tp + tn + fp + fn)\n    except ZeroDivisionError:\n        acc = None\n    # Compute Matthews correlation coefficient.\n    try:\n        mcc = (tp * tn - fp * fn) /\\\n              sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))\n    except ZeroDivisionError:\n        mcc = None\n    return {\n        \"TP\": list(true_positive),\n        \"TN\": list(true_negative),\n        \"FP\": list(false_positive),\n        \"FN\": list(false_negative),\n        \"TPR\": tpr,\n        \"TNR\": tnr,\n        \"PPV\": ppv,\n        \"FDR\": fdr,\n        \"ACC\": acc,\n        \"MCC\": mcc\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_model(path):\n    notifications = {\"warnings\": [], \"errors\": []}\n    model, sbml_ver = val.load_cobra_model(path, notifications)\n    return model, sbml_ver, notifications", "response": "Validate a metabolic model file and optionally store results as JSON."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a snapshot report from a result set and configuration.", "response": "def snapshot_report(result, config=None, html=True):\n    \"\"\"\n    Generate a snapshot report from a result set and configuration.\n\n    Parameters\n    ----------\n    result : memote.MemoteResult\n        Nested dictionary structure as returned from the test suite.\n    config : dict, optional\n        The final test report configuration (default None).\n    html : bool, optional\n        Whether to render the report as full HTML or JSON (default True).\n\n    \"\"\"\n    if config is None:\n        config = ReportConfiguration.load()\n    report = SnapshotReport(result=result, configuration=config)\n    if html:\n        return report.render_html()\n    else:\n        return report.render_json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting a model and save a history report.", "response": "def history_report(history, config=None, html=True):\n    \"\"\"\n    Test a model and save a history report.\n\n    Parameters\n    ----------\n    history : memote.HistoryManager\n        The manager grants access to previous results.\n    config : dict, optional\n        The final test report configuration.\n    html : bool, optional\n        Whether to render the report as full HTML or JSON (default True).\n\n    \"\"\"\n    if config is None:\n        config = ReportConfiguration.load()\n    report = HistoryReport(history=history, configuration=config)\n    if html:\n        return report.render_html()\n    else:\n        return report.render_json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef diff_report(diff_results, config=None, html=True):\n    if config is None:\n        config = ReportConfiguration.load()\n    report = DiffReport(diff_results=diff_results, configuration=config)\n    if html:\n        return report.render_html()\n    else:\n        return report.render_json()", "response": "Generate a diff report from a result set and configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validation_report(path, notifications, filename):\n    env = Environment(\n        loader=PackageLoader('memote.suite', 'templates'),\n        autoescape=select_autoescape(['html', 'xml'])\n    )\n    template = env.get_template('validation_template.html')\n    model = os.path.basename(path)\n    with open(filename, \"w\") as file_h:\n        file_h.write(template.render(model=model, notifications=notifications))", "response": "Generate a validation report from a notification object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a test report configuration.", "response": "def load(cls, filename=None):\n        \"\"\"Load a test report configuration.\"\"\"\n        if filename is None:\n            LOGGER.debug(\"Loading default configuration.\")\n            with open_text(templates, \"test_config.yml\",\n                           encoding=\"utf-8\") as file_handle:\n                content = yaml.load(file_handle)\n        else:\n            LOGGER.debug(\"Loading custom configuration '%s'.\", filename)\n            try:\n                with open(filename, encoding=\"utf-8\") as file_handle:\n                    content = yaml.load(file_handle)\n            except IOError as err:\n                LOGGER.error(\n                    \"Failed to load the custom configuration '%s'. Skipping.\",\n                    filename)\n                LOGGER.debug(str(err))\n                content = dict()\n        return cls(content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding unique elements of both branches of the top level logical AND and the right of the top level logical AND.", "response": "def find_top_level_complex(gpr):\n    \"\"\"\n    Find unique elements of both branches of the top level logical AND.\n\n    Parameters\n    ----------\n    gpr : str\n        The gene-protein-reaction association as a string.\n\n    Returns\n    -------\n    int\n        The size of the symmetric difference between the set of elements to\n        the left of the top level logical AND and the right set.\n\n    \"\"\"\n    logger.debug(\"%r\", gpr)\n    conform = logical_and.sub(\"and\", gpr)\n    conform = logical_or.sub(\"or\", conform)\n    conform = escape_chars.sub(\"_\", conform)\n    expression = ast.parse(conform)\n    walker = GPRVisitor()\n    walker.visit(expression)\n    return len(walker.left ^ walker.right)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up recording of elements with this hook.", "response": "def visit_BoolOp(self, node):\n        \"\"\"Set up recording of elements with this hook.\"\"\"\n        if self._is_top and isinstance(node.op, ast.And):\n            self._is_top = False\n            self._current = self.left\n            self.visit(node.values[0])\n            self._current = self.right\n            for successor in node.values[1:]:\n                self.visit(successor)\n        else:\n            self.generic_visit(node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_nonzero_constrained_reactions(model):\n    lower_bound, upper_bound = helpers.find_bounds(model)\n    return [rxn for rxn in model.reactions if\n            0 > rxn.lower_bound > lower_bound or\n            0 < rxn.upper_bound < upper_bound]", "response": "Return list of reactions with non - zero non - maximal bounds."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_zero_constrained_reactions(model):\n    return [rxn for rxn in model.reactions if\n            rxn.lower_bound == 0 and\n            rxn.upper_bound == 0]", "response": "Return list of reactions that are constrained to zero flux."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_unconstrained_reactions(model):\n    lower_bound, upper_bound = helpers.find_bounds(model)\n    return [rxn for rxn in model.reactions if\n            rxn.lower_bound <= lower_bound and\n            rxn.upper_bound >= upper_bound]", "response": "Return list of reactions that are not constrained at all."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_ngam(model):\n    atp_adp_conv_rxns = helpers.find_converting_reactions(\n        model, (\"MNXM3\", \"MNXM7\")\n    )\n    id_of_main_compartment = helpers.find_compartment_id_in_model(model, 'c')\n\n    reactants = {\n        helpers.find_met_in_model(model, \"MNXM3\", id_of_main_compartment)[0],\n        helpers.find_met_in_model(model, \"MNXM2\", id_of_main_compartment)[0]\n    }\n\n    products = {\n        helpers.find_met_in_model(model, \"MNXM7\", id_of_main_compartment)[0],\n        helpers.find_met_in_model(model, \"MNXM1\", id_of_main_compartment)[0],\n        helpers.find_met_in_model(model, \"MNXM9\", id_of_main_compartment)[0]\n    }\n\n    candidates = [rxn for rxn in atp_adp_conv_rxns\n                  if rxn.reversibility is False and\n                  set(rxn.reactants) == reactants and\n                  set(rxn.products) == products]\n\n    buzzwords = ['maintenance', 'atpm', 'requirement',\n                 'ngam', 'non-growth', 'associated']\n\n    refined_candidates = [rxn for rxn in candidates if any(\n        string in filter_none(rxn.name, '').lower() for string in buzzwords\n    )]\n\n    if refined_candidates:\n        return refined_candidates\n    else:\n        return candidates", "response": "u Return all potential non growth - associated maintenance reactions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_metabolic_coverage(model):\n    if len(model.reactions) == 0 or len(model.genes) == 0:\n        raise ValueError(\"The model contains no reactions or genes.\")\n    return float(len(model.reactions)) / float(len(model.genes))", "response": "u Return the ratio of reactions and genes included in the given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_protein_complexes(model):\n    complexes = []\n    for rxn in model.reactions:\n        if not rxn.gene_reaction_rule:\n            continue\n        size = find_top_level_complex(rxn.gene_reaction_rule)\n        if size >= 2:\n            complexes.append(rxn)\n    return complexes", "response": "Returns a list of reactions that are catalyzed by at least one protein - reaction association."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_constrained_reaction(model, rxn):\n    lower_bound, upper_bound = helpers.find_bounds(model)\n    if rxn.reversibility:\n        return rxn.lower_bound > lower_bound or rxn.upper_bound < upper_bound\n    else:\n        return rxn.lower_bound > 0 or rxn.upper_bound < upper_bound", "response": "Return whether a reaction has fixed constraints."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_oxygen_reactions(model):\n    o2_in_model = helpers.find_met_in_model(model, \"MNXM4\")\n    return set([rxn for met in model.metabolites for\n                rxn in met.reactions if met.formula == \"O2\" or\n                met in o2_in_model])", "response": "Return list of oxygen - produces and - consuming reactions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_unique_metabolites(model):\n    unique = set()\n    for met in model.metabolites:\n        is_missing = True\n        for comp in model.compartments:\n            if met.id.endswith(\"_{}\".format(comp)):\n                unique.add(met.id[:-(len(comp) + 1)])\n                is_missing = False\n                break\n        if is_missing:\n            unique.add(met.id)\n    return unique", "response": "Return set of metabolite IDs without duplicates from compartments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn list of metabolites with duplicates in the same compartment. This function identifies duplicate metabolites in each compartment by determining if any two metabolites have identical InChI-key annotations. For instance, this function would find compounds with IDs ATP1 and ATP2 in the cytosolic compartment, with both having the same InChI annotations. Parameters ---------- model : cobra.Model The metabolic model under investigation. Returns ------- list A list of tuples of duplicate metabolites.", "response": "def find_duplicate_metabolites_in_compartments(model):\n    \"\"\"\n    Return list of metabolites with duplicates in the same compartment.\n\n    This function identifies duplicate metabolites in each compartment by\n    determining if any two metabolites have identical InChI-key annotations.\n    For instance, this function would find compounds with IDs ATP1 and ATP2 in\n    the cytosolic compartment, with both having the same InChI annotations.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Returns\n    -------\n    list\n        A list of tuples of duplicate metabolites.\n\n    \"\"\"\n    unique_identifiers = [\"inchikey\", \"inchi\"]\n    duplicates = []\n    for met_1, met_2 in combinations(model.metabolites, 2):\n        if met_1.compartment == met_2.compartment:\n            for key in unique_identifiers:\n                if key in met_1.annotation and key in met_2.annotation:\n                    if met_1.annotation[key] == met_2.annotation[key]:\n                        duplicates.append((met_1.id, met_2.id))\n                        break\n    return duplicates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind duplicate reactions based on identical annotations.", "response": "def find_reactions_with_partially_identical_annotations(model):\n    \"\"\"\n    Return duplicate reactions based on identical annotation.\n\n    Identify duplicate reactions globally by checking if any two metabolic\n    reactions have the same entries in their annotation attributes. This can be\n    useful to identify one 'type' of reactions that occurs in several\n    compartments, to curate merged models or to clean-up bulk model\n    modifications. The heuristic looks at annotations with the keys\n    \"metanetx.reaction\", \"kegg.reaction\", \"brenda\", \"rhea\", \"biocyc\",\n    \"bigg.reaction\" only.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Returns\n    -------\n    dict\n        A mapping from sets of annotations to groups of reactions with those\n        annotations.\n    int\n        The total number of unique reactions that are duplicated.\n\n    \"\"\"\n    duplicates = {}\n    rxn_db_identifiers = [\"metanetx.reaction\", \"kegg.reaction\", \"brenda\",\n                          \"rhea\", \"biocyc\", \"bigg.reaction\"]\n    # Build a list that associates a reaction with a set of its annotations.\n    ann_rxns = []\n    for rxn in model.reactions:\n        ann = []\n        for key in rxn_db_identifiers:\n            if key in rxn.annotation:\n                if isinstance(rxn.annotation[key], list):\n                    ann.extend([(key, elem) for elem in rxn.annotation[key]])\n                else:\n                    ann.append((key, rxn.annotation[key]))\n        ann_rxns.append((rxn, frozenset(ann)))\n    # Compute the intersection between annotations and record the matching\n    # reaction identifiers.\n    for (rxn_a, ann_a), (rxn_b, ann_b) in combinations(ann_rxns, 2):\n        mutual_pair = tuple(ann_a & ann_b)\n        if len(mutual_pair) > 0:\n            duplicates.setdefault(mutual_pair, set()).update(\n                [rxn_a.id, rxn_b.id])\n    # Transform the object for JSON compatibility\n    num_duplicated = set()\n    duplicated = {}\n    for key in duplicates:\n        # Object keys must be strings in JSON.\n        new_key = \",\".join(sorted(\"{}:{}\".format(ns, term) for ns, term in key))\n        duplicated[new_key] = rxns = list(duplicates[key])\n        num_duplicated.update(rxns)\n    return duplicated, len(num_duplicated)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmapping metabolites to structural space indexes.", "response": "def map_metabolites_to_structures(metabolites, compartments):\n    \"\"\"\n    Map metabolites from the identifier namespace to structural space.\n\n    Metabolites who lack structural annotation (InChI or InChIKey) are ignored.\n\n    Parameters\n    ----------\n    metabolites : iterable\n        The cobra.Metabolites to map.\n    compartments : iterable\n        The different compartments to consider. Structures are treated\n        separately for each compartment.\n\n    Returns\n    -------\n    dict\n        A mapping from a cobra.Metabolite to its compartment specific\n        structure index.\n\n    \"\"\"\n    # TODO (Moritz Beber): Consider SMILES?\n    unique_identifiers = [\"inchikey\", \"inchi\"]\n    met2mol = {}\n    molecules = {c: [] for c in compartments}\n    for met in metabolites:\n        ann = []\n        for key in unique_identifiers:\n            mol = met.annotation.get(key)\n            if mol is not None:\n                ann.append(mol)\n        # Ignore metabolites without the required information.\n        if len(ann) == 0:\n            continue\n        ann = set(ann)\n        # Compare with other structures in the same compartment.\n        mols = molecules[met.compartment]\n        for i, mol_group in enumerate(mols):\n            if len(ann & mol_group) > 0:\n                mol_group.update(ann)\n                # We map to the index of the group because it is hashable and\n                # cheaper to compare later.\n                met2mol[met] = \"{}-{}\".format(met.compartment, i)\n                break\n        if met not in met2mol:\n            # The length of the list corresponds to the 0-index after appending.\n            met2mol[met] = \"{}-{}\".format(met.compartment, len(mols))\n            mols.append(ann)\n    return met2mol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_duplicate_reactions(model):\n    met2mol = map_metabolites_to_structures(model.metabolites,\n                                            model.compartments)\n    # Build a list associating reactions with their stoichiometry in molecular\n    # structure space.\n    structural = []\n    for rxn in model.reactions:\n        # Ignore reactions that have metabolites without structures.\n        if not all(met in met2mol for met in rxn.metabolites):\n            continue\n        # We consider substrates and products separately since, for example,\n        # the InChI for H2O and OH is the same.\n        substrates = {\n            met2mol[met]: rxn.get_coefficient(met) for met in rxn.reactants\n        }\n        products = {\n            met2mol[met]: rxn.get_coefficient(met) for met in rxn.products\n        }\n        structural.append((rxn, substrates, products))\n    # Compare reactions using their structure-based stoichiometries.\n    num_duplicated = set()\n    duplicates = []\n    for (rxn_a, sub_a, prod_a), (rxn_b, sub_b, prod_b) in combinations(\n            structural, 2):\n        # Compare the substrates.\n        if sub_a != sub_b:\n            continue\n        # Compare the products.\n        if prod_a != prod_b:\n            continue\n        # Compare whether they are both (ir-)reversible.\n        if rxn_a.reversibility != rxn_b.reversibility:\n            continue\n        # TODO (Moritz Beber): We could compare bounds here but it might be\n        #  worth knowing about the reactions even if their bounds differ?\n        duplicates.append((rxn_a.id, rxn_b.id))\n        num_duplicated.add(rxn_a.id)\n        num_duplicated.add(rxn_b.id)\n    return duplicates, len(num_duplicated)", "response": "Find duplicate reactions in a single structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_reactions_with_identical_genes(model):\n    duplicates = dict()\n    for rxn_a, rxn_b in combinations(model.reactions, 2):\n        if not (rxn_a.genes and rxn_b.genes):\n            continue\n        if rxn_a.genes == rxn_b.genes:\n            # This works because the `genes` are frozen sets.\n            identifiers = rxn_a.genes\n            duplicates.setdefault(identifiers, set()).update(\n                [rxn_a.id, rxn_b.id])\n    # Transform the object for JSON compatibility\n    num_duplicated = set()\n    duplicated = {}\n    for key in duplicates:\n        # Object keys must be strings in JSON.\n        new_key = \",\".join(sorted(g.id for g in key))\n        duplicated[new_key] = rxns = list(duplicates[key])\n        num_duplicated.update(rxns)\n    return duplicated, len(num_duplicated)", "response": "Find reactions that have identical genes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of metabolites ingested by the model.", "response": "def find_medium_metabolites(model):\n    \"\"\"Return the list of metabolites ingested/excreted by the model.\"\"\"\n    return [met.id for rxn in model.medium\n            for met in model.reactions.get_by_id(rxn).metabolites]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_external_metabolites(model):\n    ex_comp = find_external_compartment(model)\n    return [met for met in model.metabolites if met.compartment == ex_comp]", "response": "Return all metabolites in the external compartment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef store(self, result, filename, pretty=True):\n        LOGGER.info(\"Storing result in '%s'.\", filename)\n        if filename.endswith(\".gz\"):\n            with gzip.open(filename, \"wb\") as file_handle:\n                file_handle.write(\n                    jsonify(result, pretty=pretty).encode(\"utf-8\")\n                )\n        else:\n            with open(filename, \"w\", encoding=\"utf-8\") as file_handle:\n                file_handle.write(jsonify(result, pretty=pretty))", "response": "Store a result in the given file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(self, filename):\n        LOGGER.info(\"Loading result from '%s'.\", filename)\n        if filename.endswith(\".gz\"):\n            with gzip.open(filename, \"rb\") as file_handle:\n                result = MemoteResult(\n                    json.loads(file_handle.read().decode(\"utf-8\"))\n                )\n        else:\n            with open(filename, \"r\", encoding=\"utf-8\") as file_handle:\n                result = MemoteResult(json.load(file_handle))\n        # TODO (Moritz Beber): Validate the read-in JSON maybe? Trade-off\n        #  between extra time taken and correctness. Maybe we re-visit this\n        #  issue when there was a new JSON format version needed.\n        return result", "response": "Load a result from the given JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_cobra_model(path, notifications):\n    doc = libsbml.readSBML(path)\n    fbc = doc.getPlugin(\"fbc\")\n    sbml_ver = doc.getLevel(), doc.getVersion(), fbc if fbc is None else \\\n        fbc.getVersion()\n    with catch_warnings(record=True) as warnings:\n        simplefilter(\"always\")\n        try:\n            model = read_sbml_model(path)\n        except Exception as err:\n            notifications['errors'].append(str(err))\n            model = None\n            validate = True\n        else:\n            validate = False\n        notifications['warnings'].extend([str(w.message) for w in warnings])\n    if validate:\n        run_sbml_validation(doc, notifications)\n    return model, sbml_ver", "response": "Load a COBRA model with meta information from an SBML document."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_failure(failure):\n    return \"Line {}, Column {} - #{}: {} - Category: {}, Severity: {}\".format(\n        failure.getLine(),\n        failure.getColumn(),\n        failure.getErrorId(),\n        failure.getMessage(),\n        failure.getCategoryAsString(),\n        failure.getSeverity()\n    )", "response": "Format a failure message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating an SBML document and report errors and warnings.", "response": "def run_sbml_validation(document, notifications):\n    \"\"\"Report errors and warnings found in an SBML document.\"\"\"\n    validator = libsbml.SBMLValidator()\n    validator.validate(document)\n    for i in range(document.getNumErrors()):\n        notifications['errors'].append(format_failure(document.getError(i)))\n    for i in range(validator.getNumFailures()):\n        failure = validator.getFailure(i)\n        if failure.isWarning():\n            notifications['warnings'].append(format_failure(failure))\n        else:\n            notifications['errors'].append(format_failure(failure))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring a result in a JSON file attaching git meta information.", "response": "def store(self, result, commit=None, **kwargs):\n        \"\"\"\n        Store a result in a JSON file attaching git meta information.\n\n        Parameters\n        ----------\n        result : memote.MemoteResult\n            The dictionary structure of results.\n        commit : str, optional\n            Unique hexsha of the desired commit.\n        kwargs :\n            Passed to parent function.\n\n        \"\"\"\n        git_info = self.record_git_info(commit)\n        try:\n            row = self.session.query(Result). \\\n                filter_by(hexsha=git_info.hexsha). \\\n                one()\n            LOGGER.info(\"Updating result '%s'.\", git_info.hexsha)\n            row.memote_result = result\n        except NoResultFound:\n            row = Result(memote_result=result)\n            LOGGER.info(\"Storing result '%s'.\", git_info.hexsha)\n        row.hexsha = git_info.hexsha\n        row.author = git_info.author\n        row.email = git_info.email\n        row.authored_on = git_info.authored_on\n        self.session.add(row)\n        self.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a result from the database.", "response": "def load(self, commit=None):\n        \"\"\"Load a result from the database.\"\"\"\n        git_info = self.record_git_info(commit)\n        LOGGER.info(\"Loading result from '%s'.\", git_info.hexsha)\n        result = MemoteResult(\n            self.session.query(Result.memote_result).\n            filter_by(hexsha=git_info.hexsha).\n            one().memote_result)\n        # Add git info so the object is equivalent to the one returned by the\n        #  RepoResultManager.\n        self.add_git(result.meta, git_info)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collect_history(self):\n        def format_data(data):\n            \"\"\"Format result data according to the user-defined type.\"\"\"\n            # TODO Remove this failsafe once proper error handling is in place.\n            if type == \"percent\" or data is None:\n                # Return an empty list here to reduce the output file size.\n                # The angular report will ignore the `data` and instead display\n                # the `metric`.\n                return []\n            if type == \"count\":\n                return len(data)\n            return data\n\n        base = dict()\n        tests = base.setdefault(\"tests\", dict())\n        score = base.setdefault(\"score\", dict())\n        score_collection = score.setdefault(\"total_score\", dict())\n        for branch, commits in self._history.iter_branches():\n            for commit in reversed(commits):\n                result = self.result = self._history.get_result(commit)\n                # Calculate the score for each result and store all the total\n                # scores for each commit in the base dictionary.\n                self.compute_score()\n                total_score = self.result[\"score\"][\"total_score\"]\n                score_collection.setdefault(\"history\", list())\n                score_collection[\"format_type\"] = \"score\"\n                score_collection[\"history\"].append({\n                    \"branch\": branch,\n                    \"commit\": commit,\n                    \"metric\": total_score})\n                # Now arrange the results for each test into the appropriate\n                # format. Specifically such that the Accordion and the Vega\n                # Plot components can easily read them.\n                for test in result.cases:\n                    tests.setdefault(test, dict())\n                    if \"title\" not in tests[test]:\n                        tests[test][\"title\"] = result.cases[test][\"title\"]\n                    if \"summary\" not in tests[test]:\n                        tests[test][\"summary\"] = result.cases[test][\"summary\"]\n                    if \"type\" not in tests[test]:\n                        tests[test][\"format_type\"] = result.cases[test][\n                            \"format_type\"]\n                    type = tests[test][\"format_type\"]\n                    metric = result.cases[test].get(\"metric\")\n                    data = result.cases[test].get(\"data\")\n                    res = result.cases[test].get(\"result\")\n                    if isinstance(metric, dict):\n                        tests[test].setdefault(\"history\", dict())\n                        for param in metric:\n                            tests[test][\"history\"].setdefault(param, list()). \\\n                                append({\n                                    \"branch\": branch,\n                                    \"commit\": commit,\n                                    \"metric\": metric.get(param),\n                                    \"data\": format_data(data.get(param)),\n                                    \"result\": res.get(param)})\n                    else:\n                        tests[test].setdefault(\"history\", list()).append({\n                            \"branch\": branch,\n                            \"commit\": commit,\n                            \"metric\": metric,\n                            \"data\": format_data(data),\n                            \"result\": res\n                        })\n        return base", "response": "Collect the history of the results."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_and_score_diff_data(self, diff_results):\n        base = dict()\n        meta = base.setdefault('meta', dict())\n        tests = base.setdefault('tests', dict())\n        score = base.setdefault('score', dict())\n        for model_filename, result in iteritems(diff_results):\n            if meta == dict():\n                meta = result[\"meta\"]\n            for test_id, test_results in iteritems(result[\"tests\"]):\n                tests.setdefault(test_id, dict())\n                if tests[test_id] == dict():\n                    tests[test_id][\"summary\"] = test_results[\"summary\"]\n                    tests[test_id][\"title\"] = test_results[\"title\"]\n                    tests[test_id][\"format_type\"] = test_results[\"format_type\"]\n                if isinstance(test_results[\"metric\"], dict):\n                    tests[test_id].setdefault(\"diff\", dict())\n                    for param in test_results[\"metric\"]:\n                        tests[test_id][\"diff\"].setdefault(param, list()). \\\n                            append({\n                                \"model\": model_filename,\n                                \"data\": test_results[\"data\"].setdefault(param),\n                                \"duration\":\n                                    test_results[\"duration\"].setdefault(param),\n                                \"message\":\n                                    test_results[\"message\"].setdefault(param),\n                                \"metric\":\n                                    test_results[\"metric\"].setdefault(param),\n                                \"result\":\n                                    test_results[\"result\"].setdefault(param)})\n                else:\n                    tests[test_id].setdefault(\"diff\", list())\n                    tests[test_id][\"diff\"].append({\n                        \"model\": model_filename,\n                        \"data\": test_results.setdefault(\"data\"),\n                        \"duration\": test_results.setdefault(\"duration\"),\n                        \"message\": test_results.setdefault(\"message\"),\n                        \"metric\": test_results.setdefault(\"metric\"),\n                        \"result\": test_results.setdefault(\"result\")})\n            self.result = result\n            self.compute_score()\n            score.setdefault('total_score', dict()).setdefault('diff', list())\n            score.setdefault('sections', dict()).setdefault('diff', list())\n            score['total_score']['diff'].append({\n                \"model\": model_filename,\n                \"total_score\": self.result['score']['total_score']})\n            for section in self.result['score']['sections']:\n                section.update({\"model\": model_filename})\n                score['sections']['diff'].append(section)\n        return base", "response": "Reformat the api results to work with the front - end."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_shortlist(mnx_db, shortlist):\n    # Reduce the whole database to targets of interest.\n    xref = mnx_db.loc[mnx_db[\"MNX_ID\"].isin(shortlist[\"MNX_ID\"]), :]\n    # Drop deprecated MetaNetX identifiers. Disabled for now.\n    # xref = xref.loc[~xref[\"XREF\"].str.startswith(\"deprecated\", na=False), :]\n    # Drop self-references for now since they don't follow the format.\n    xref = xref.loc[xref[\"XREF\"] != xref[\"MNX_ID\"], :]\n    # Split namespaces from identifiers.\n    xref[[\"XREF_ID\", \"XREF\"]] = xref[\"XREF\"].str.split(\":\", n=1, expand=True)\n    # Group the data in the xref dataframe so that one MNX ID maps to all\n    # corresponding cross-references from other databases. Then list all\n    # identifiers that belong to these databases:\n    # MNX_ID    XREF_ID\n    # MNXM0     chebi       [23367, 59999]\n    #           metacyc     [UNKNOWN]\n    # Make a separate column for every XREF_ID:\n    # MNX_ID    chebi           metacyc\n    # MNXM0     [23367, 59999]  [UNKNOWN]\n    xref = xref.groupby([\"MNX_ID\", \"XREF_ID\"], as_index=False, sort=False)[\n        \"XREF\"].apply(list).unstack('XREF_ID')\n    # Re-insert MetaNetX identifiers as lists.\n    # FIXME: Shouldn't we use metanetx.chemical here instead of 'mnx'?\n    xref[\"mnx\"] = [[x] for x in xref.index]\n    # Transpose the data frame such that the index are now xref databases and\n    # the column names are MetaNetX identifiers.\n    return xref.T", "response": "Generate a condensed cross - reference format from data in long form."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a shortlist of metabolites with cross - references using MetaNetX.", "response": "def generate(mnx_dump):\n    \"\"\"\n    Annotate a shortlist of metabolites with cross-references using MetaNetX.\n\n    MNX_DUMP : The chemicals dump from MetaNetX usually called 'chem_xref.tsv'.\n        Will be downloaded if it doesn't exist.\n\n    \"\"\"\n    LOGGER.info(\"Read shortlist.\")\n    targets = pd.read_table(join(dirname(__file__), \"shortlist.tsv\"))\n    if not exists(mnx_dump):\n        # Download the MetaNetX chemicals dump if it doesn't exists.\n        # Download done as per https://stackoverflow.com/a/16696317.\n        LOGGER.info(\"MetaNetX dump '%s' does not exist. Downloading...\",\n                    mnx_dump)\n        with open(mnx_dump, \"wb\") as file_handle, \\\n            get(\"https://www.metanetx.org/cgi-bin/mnxget/mnxref/chem_xref.tsv\",\n                stream=True) as stream:\n            for chunk in stream.iter_content(chunk_size=1024):\n                file_handle.write(chunk)\n        LOGGER.info(\"Done.\")\n    LOGGER.info(\"Read the MetaNetX dump with cross-references.\")\n    db = pd.read_table(mnx_dump, comment='#',\n                       names=['XREF', 'MNX_ID', 'Evidence', 'Description'])\n    LOGGER.info(\"Generate the shortlist cross-references.\")\n    res = generate_shortlist(db, targets)\n    LOGGER.info(\"Save result.\")\n    res.to_json(join(dirname(__file__), pardir, \"memote\", \"support\", \"data\",\n                     \"met_id_shortlist.json\"), force_ascii=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, model, checks=[]):\n        custom = [\n            check_partial(gene_id_check, frozenset(g.id for g in model.genes))\n        ]\n        super(EssentialityExperiment, self).validate(\n            model=model, checks=checks + custom)", "response": "Use a defined schema to validate the medium table format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse the defined parameters to predict single gene essentiality.", "response": "def evaluate(self, model):\n        \"\"\"Use the defined parameters to predict single gene essentiality.\"\"\"\n        with model:\n            if self.medium is not None:\n                self.medium.apply(model)\n            if self.objective is not None:\n                model.objective = self.objective\n            model.add_cons_vars(self.constraints)\n            max_val = model.slim_optimize()\n            essen = single_gene_deletion(\n                model, gene_list=self.data[\"gene\"], processes=1)\n        essen[\"gene\"] = [list(g)[0] for g in essen.index]\n        essen.index = essen[\"gene\"]\n        essen[\"essential\"] = (essen[\"growth\"] < (max_val * 0.1)) \\\n            | essen[\"growth\"].isna()\n        return essen"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a passed in object with a registry.", "response": "def register_with(registry):\n    \"\"\"\n    Register a passed in object.\n\n    Intended to be used as a decorator on model building functions with a\n    ``dict`` as a registry.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        REGISTRY = dict()\n        @register_with(REGISTRY)\n        def build_empty(base):\n            return base\n\n    \"\"\"\n    def decorator(func):\n        registry[func.__name__] = func\n        return func\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef annotate(title, format_type, message=None, data=None, metric=1.0):\n    if format_type not in TYPES:\n        raise ValueError(\n            \"Invalid type. Expected one of: {}.\".format(\", \".join(TYPES)))\n\n    def decorator(func):\n        func.annotation = dict(\n            title=title,\n            summary=extended_summary(func),\n            message=message,\n            data=data,\n            format_type=format_type,\n            metric=metric)\n        return func\n    return decorator", "response": "Annotate a test case with info that should be displayed in the reports."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef truncate(sequence):\n    if len(sequence) > LIST_SLICE:\n        return \", \".join(sequence[:LIST_SLICE] + [\"...\"])\n    else:\n        return \", \".join(sequence)", "response": "Returns a potentially shortened text display of a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_json_incompatible_types(obj):\n    keys_to_explore = list(obj)\n    while len(keys_to_explore) > 0:\n        key = keys_to_explore.pop()\n        if not isinstance(key, str):\n            LOGGER.info(type(key))\n        value = obj[key]\n        if isinstance(value, dict):\n            LOGGER.info(\"%s:\", key)\n            log_json_incompatible_types(value)\n        elif not isinstance(value, JSON_TYPES):\n            LOGGER.info(\"%s: %s\", key, type(value))\n        elif isinstance(value, (int, float)) and not isfinite(value):\n            LOGGER.info(\"%s: %f\", key, value)", "response": "Recursively log types that are not JSON compatible."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a nested object into a JSON string.", "response": "def jsonify(obj, pretty=False):\n    \"\"\"\n    Turn a nested object into a (compressed) JSON string.\n\n    Parameters\n    ----------\n    obj : dict\n        Any kind of dictionary structure.\n    pretty : bool, optional\n        Whether to format the resulting JSON in a more legible way (\n        default False).\n\n    \"\"\"\n    if pretty:\n        params = dict(sort_keys=True, indent=2, allow_nan=False,\n                      separators=(\",\", \": \"), ensure_ascii=False)\n    else:\n        params = dict(sort_keys=False, indent=None, allow_nan=False,\n                      separators=(\",\", \":\"), ensure_ascii=False)\n    try:\n        return json.dumps(obj, **params)\n    except (TypeError, ValueError) as error:\n        LOGGER.critical(\n            \"The memote result structure is incompatible with the JSON \"\n            \"standard.\")\n        log_json_incompatible_types(obj)\n        raise_with_traceback(error)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flatten(list_of_lists):\n    flat_list = []\n    for sublist in list_of_lists:\n        if isinstance(sublist, string_types) or isinstance(sublist, int):\n            flat_list.append(sublist)\n        elif sublist is None:\n            continue\n        elif not isinstance(sublist, string_types) and len(sublist) == 1:\n            flat_list.append(sublist[0])\n        else:\n            flat_list.append(tuple(sublist))\n    return flat_list", "response": "Flatten a list of lists but maintain strings and ints as entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint each entry of errors and warnings to stdout.", "response": "def stdout_notifications(notifications):\n    \"\"\"\n    Print each entry of errors and warnings to stdout.\n\n    Parameters\n    ----------\n    notifications: dict\n        A simple dictionary structure containing a list of errors and warnings.\n\n    \"\"\"\n    for error in notifications[\"errors\"]:\n        LOGGER.error(error)\n    for warn in notifications[\"warnings\"]:\n        LOGGER.warning(warn)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the data table and validation schema.", "response": "def load(self, dtype_conversion=None):\n        \"\"\"\n        Load the data table and corresponding validation schema.\n\n        Parameters\n        ----------\n        dtype_conversion : dict\n            Column names as keys and corresponding type for loading the data.\n            Please take a look at the `pandas documentation\n            <https://pandas.pydata.org/pandas-docs/stable/io.html#specifying-column-data-types>`__\n            for detailed explanations.\n\n        \"\"\"\n        self.data = read_tabular(self.filename, dtype_conversion)\n        with open_text(memote.experimental.schemata, self.SCHEMA,\n                       encoding=\"utf-8\") as file_handle:\n            self.schema = json.load(file_handle)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self, model, checks=[]):\n        records = self.data.to_dict(\"records\")\n        self.evaluate_report(\n            validate(records, headers=list(records[0]),\n                     preset='table', schema=self.schema,\n                     order_fields=True, custom_checks=checks))", "response": "Use a defined schema to validate the given table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef evaluate_report(report):\n        if report[\"valid\"]:\n            return\n        for warn in report[\"warnings\"]:\n            LOGGER.warning(warn)\n        # We only ever test one table at a time.\n        for err in report[\"tables\"][0][\"errors\"]:\n            LOGGER.error(err[\"message\"])\n        raise ValueError(\"Invalid data file. Please see errors above.\")", "response": "Iterate over validation errors and return the valid object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the stoichiometric coefficients as constraints.", "response": "def add_reaction_constraints(model, reactions, Constraint):\n    \"\"\"\n    Add the stoichiometric coefficients as constraints.\n\n    Parameters\n    ----------\n    model : optlang.Model\n        The transposed stoichiometric matrix representation.\n    reactions : iterable\n        Container of `cobra.Reaction` instances.\n    Constraint : optlang.Constraint\n        The constraint class for the specific interface.\n\n    \"\"\"\n    constraints = []\n    for rxn in reactions:\n        expression = add(\n            [c * model.variables[m.id] for m, c in rxn.metabolites.items()])\n        constraints.append(Constraint(expression, lb=0, ub=0, name=rxn.id))\n    model.add(constraints)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stoichiometry_matrix(metabolites, reactions):\n    matrix = np.zeros((len(metabolites), len(reactions)))\n    met_index = dict((met, i) for i, met in enumerate(metabolites))\n    rxn_index = dict()\n    for i, rxn in enumerate(reactions):\n        rxn_index[rxn] = i\n        for met, coef in iteritems(rxn.metabolites):\n            j = met_index[met]\n            matrix[j, i] = coef\n    return matrix, met_index, rxn_index", "response": "Returns the stoichiometry matrix representation of a set of reactions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rank(matrix, atol=1e-13, rtol=0):\n    matrix = np.atleast_2d(matrix)\n    sigma = svd(matrix, compute_uv=False)\n    tol = max(atol, rtol * sigma[0])\n    return int((sigma >= tol).sum())", "response": "Estimate the rank of a set of items in the column space of a given matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nullspace(matrix, atol=1e-13, rtol=0.0):  # noqa: D402\n    matrix = np.atleast_2d(matrix)\n    _, sigma, vh = svd(matrix)\n    tol = max(atol, rtol * sigma[0])\n    num_nonzero = (sigma >= tol).sum()\n    return vh[num_nonzero:].conj().T", "response": "Compute an approximate null space for a given matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the interface specific classes.", "response": "def get_interface(model):\n    \"\"\"\n    Return the interface specific classes.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    \"\"\"\n    return (\n        model.solver.interface.Model,\n        model.solver.interface.Constraint,\n        model.solver.interface.Variable,\n        model.solver.interface.Objective\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_internals(model):\n    biomass = set(find_biomass_reaction(model))\n    if len(biomass) == 0:\n        LOGGER.warning(\"No biomass reaction detected. Consistency test results \"\n                       \"are unreliable if one exists.\")\n    return set(model.reactions) - (set(model.boundary) | biomass)", "response": "Returns non - boundary reactions and their metabolites."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the MILP problem for a set of metabolites.", "response": "def create_milp_problem(kernel, metabolites, Model, Variable, Constraint,\n                        Objective):\n    \"\"\"\n    Create the MILP as defined by equation (13) in [1]_.\n\n    Parameters\n    ----------\n    kernel : numpy.array\n        A 2-dimensional array that represents the left nullspace of the\n        stoichiometric matrix which is the nullspace of the transpose of the\n        stoichiometric matrix.\n    metabolites : iterable\n        The metabolites in the nullspace. The length of this vector must equal\n        the first dimension of the nullspace.\n    Model : optlang.Model\n        Model class for a specific optlang interface.\n    Variable : optlang.Variable\n        Variable class for a specific optlang interface.\n    Constraint : optlang.Constraint\n        Constraint class for a specific optlang interface.\n    Objective : optlang.Objective\n        Objective class for a specific optlang interface.\n\n    References\n    ----------\n    .. [1] Gevorgyan, A., M. G Poolman, and D. A Fell.\n           \"Detection of Stoichiometric Inconsistencies in Biomolecular\n           Models.\"\n           Bioinformatics 24, no. 19 (2008): 2245.\n\n    \"\"\"\n    assert len(metabolites) == kernel.shape[0],\\\n        \"metabolite vector and first nullspace dimension must be equal\"\n    ns_problem = Model()\n    k_vars = list()\n    for met in metabolites:\n        # The element y[i] of the mass vector.\n        y_var = Variable(met.id)\n        k_var = Variable(\"k_{}\".format(met.id), type=\"binary\")\n        k_vars.append(k_var)\n        ns_problem.add([y_var, k_var])\n        # This constraint is equivalent to 0 <= y[i] <= k[i].\n        ns_problem.add(Constraint(\n            y_var - k_var, ub=0, name=\"switch_{}\".format(met.id)))\n    ns_problem.update()\n    # add nullspace constraints\n    for (j, column) in enumerate(kernel.T):\n        expression = sympy.Add(\n            *[coef * ns_problem.variables[met.id]\n              for (met, coef) in zip(metabolites, column) if coef != 0.0])\n        constraint = Constraint(expression, lb=0, ub=0,\n                                name=\"ns_{}\".format(j))\n        ns_problem.add(constraint)\n    # The objective is to minimize the binary indicators k[i], subject to\n    # the above inequality constraints.\n    ns_problem.objective = Objective(1)\n    ns_problem.objective.set_linear_coefficients(\n        {k_var: 1. for k_var in k_vars})\n    ns_problem.objective.direction = \"min\"\n    return ns_problem, k_vars"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd an integer cut to the problem.", "response": "def add_cut(problem, indicators, bound, Constraint):\n    \"\"\"\n    Add an integer cut to the problem.\n\n    Ensure that the same solution involving these indicator variables cannot be\n    found by enforcing their sum to be less than before.\n\n    Parameters\n    ----------\n    problem : optlang.Model\n        Specific optlang interface Model instance.\n    indicators : iterable\n        Binary indicator `optlang.Variable`s.\n    bound : int\n        Should be one less than the sum of indicators. Corresponds to P - 1 in\n        equation (14) in [1]_.\n    Constraint : optlang.Constraint\n        Constraint class for a specific optlang interface.\n\n    References\n    ----------\n    .. [1] Gevorgyan, A., M. G Poolman, and D. A Fell.\n           \"Detection of Stoichiometric Inconsistencies in Biomolecular\n           Models.\"\n           Bioinformatics 24, no. 19 (2008): 2245.\n\n    \"\"\"\n    cut = Constraint(sympy.Add(*indicators), ub=bound)\n    problem.add(cut)\n    return cut"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_mass_balanced(reaction):\n    balance = defaultdict(int)\n    for metabolite, coefficient in iteritems(reaction.metabolites):\n        if metabolite.elements is None or len(metabolite.elements) == 0:\n            return False\n        for element, amount in iteritems(metabolite.elements):\n            balance[element] += coefficient * amount\n    return all(amount == 0 for amount in itervalues(balance))", "response": "Confirm that a reaction is mass balanced."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfirms that a reaction is charge balanced.", "response": "def is_charge_balanced(reaction):\n    \"\"\"Confirm that a reaction is charge balanced.\"\"\"\n    charge = 0\n    for metabolite, coefficient in iteritems(reaction.metabolites):\n        if metabolite.charge is None:\n            return False\n        charge += coefficient * metabolite.charge\n    return charge == 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a partial to be used by goodtables.", "response": "def check_partial(func, *args, **kwargs):\n    \"\"\"Create a partial to be used by goodtables.\"\"\"\n    new_func = partial(func, *args, **kwargs)\n    new_func.check = func.check\n    return new_func"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gene_id_check(genes, errors, columns, row_number):\n    message = (\"Gene '{value}' in column {col} and row {row} does not \"\n               \"appear in the metabolic model.\")\n    for column in columns:\n        if \"gene\" in column['header'] and column['value'] not in genes:\n            message = message.format(\n                value=column['value'],\n                row=row_number,\n                col=column['number'])\n            errors.append({\n                'code': 'bad-value',\n                'message': message,\n                'row-number': row_number,\n                'column-number': column['number'],\n            })", "response": "Validate gene identifiers against a known set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate reactions identifiers against a known set.", "response": "def reaction_id_check(reactions, errors, columns, row_number):\n    \"\"\"\n    Validate reactions identifiers against a known set.\n\n    Parameters\n    ----------\n    reactions : set\n        The known set of reaction identifiers.\n    errors :\n        Passed by goodtables.\n    columns :\n        Passed by goodtables.\n    row_number :\n        Passed by goodtables.\n\n    \"\"\"\n    message = (\"Reaction '{value}' in column {col} and row {row} does not \"\n               \"appear in the metabolic model.\")\n    for column in columns:\n        if \"reaction\" in column['header'] and column['value'] not in reactions:\n            message = message.format(\n                value=column['value'],\n                row=row_number,\n                col=column['number'])\n            errors.append({\n                'code': 'bad-value',\n                'message': message,\n                'row-number': row_number,\n                'column-number': column['number'],\n            })"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef metabolite_id_check(metabolites, errors, columns, row_number):\n    message = (\"Metabolite '{value}' in column {col} and row {row} does not \"\n               \"appear in the metabolic model.\")\n    for column in columns:\n        if \"metabolite\" in column['header'] and \\\n                column['value'] not in metabolites:\n            message = message.format(\n                value=column['value'],\n                row=row_number,\n                col=column['number'])\n            errors.append({\n                'code': 'bad-value',\n                'message': message,\n                'row-number': row_number,\n                'column-number': column['number'],\n            })", "response": "Validate metabolite identifiers against a known set."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the memote test suite on a single model and collect results.", "response": "def run(model, collect, filename, location, ignore_git, pytest_args, exclusive,\n        skip, solver, experimental, custom_tests, deployment,\n        skip_unchanged):\n    \"\"\"\n    Run the test suite on a single model and collect results.\n\n    MODEL: Path to model file. Can also be supplied via the environment variable\n    MEMOTE_MODEL or configured in 'setup.cfg' or 'memote.ini'.\n\n    \"\"\"\n    def is_verbose(arg):\n        return (arg.startswith(\"--verbosity\") or\n                arg.startswith(\"-v\") or arg.startswith(\"--verbose\") or\n                arg.startswith(\"-q\") or arg.startswith(\"--quiet\"))\n\n    if ignore_git:\n        repo = None\n    else:\n        callbacks.git_installed()\n        repo = callbacks.probe_git()\n    if collect:\n        if repo is not None:\n            if location is None:\n                LOGGER.critical(\n                    \"Working with a repository requires a storage location.\")\n                sys.exit(1)\n    if not any(a.startswith(\"--tb\") for a in pytest_args):\n        pytest_args = [\"--tb\", \"short\"] + pytest_args\n    if not any(is_verbose(a) for a in pytest_args):\n        pytest_args.append(\"-vv\")\n    # Check if the model was changed in this commit. Exit `memote run` if this\n    # was not the case.\n    if skip_unchanged and repo is not None:\n        commit = repo.head.commit\n        if not is_modified(model, commit):\n            LOGGER.info(\"The model was not modified in commit '%s'. Skipping.\",\n                        commit.hexsha)\n            sys.exit(0)\n    # Add further directories to search for tests.\n    pytest_args.extend(custom_tests)\n    # Check if the model can be loaded at all.\n    model, sbml_ver, notifications = api.validate_model(model)\n    if model is None:\n        LOGGER.critical(\n            \"The model could not be loaded due to the following SBML errors.\")\n        stdout_notifications(notifications)\n        sys.exit(1)\n    model.solver = solver\n    # Load the experimental configuration using model information.\n    if experimental is not None:\n        experimental.load(model)\n    code, result = api.test_model(\n        model=model, sbml_version=sbml_ver, results=True,\n        pytest_args=pytest_args, skip=skip,\n        exclusive=exclusive, experimental=experimental)\n    if collect:\n        if repo is None:\n            manager = ResultManager()\n            manager.store(result, filename=filename)\n        else:\n            LOGGER.info(\"Checking out deployment branch.\")\n            # If the repo HEAD is pointing to the most recent branch then\n            # GitPython's `repo.active_branch` works. Yet, if the repo is in\n            # detached HEAD state, i.e., when a user has checked out a specific\n            # commit as opposed to a branch, this won't work and throw a\n            # `TypeError`, which we are circumventing below.\n            try:\n                previous = repo.active_branch\n                previous_cmt = previous.commit\n                is_branch = True\n            except TypeError:\n                previous_cmt = repo.head.commit\n                is_branch = False\n            repo.git.checkout(deployment)\n            try:\n                manager = SQLResultManager(repository=repo, location=location)\n            except (AttributeError, ArgumentError):\n                manager = RepoResultManager(repository=repo, location=location)\n            LOGGER.info(\n                \"Committing result and changing back to working branch.\")\n            manager.store(result, commit=previous_cmt.hexsha)\n            repo.git.add(\".\")\n            check_call(\n                ['git', 'commit',\n                 '-m', \"chore: add result for {}\".format(previous_cmt.hexsha)]\n            )\n            if is_branch:\n                previous.checkout()\n            else:\n                repo.commit(previous_cmt)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new model repository structure from a template.", "response": "def new(directory, replay):\n    \"\"\"\n    Create a suitable model repository structure from a template.\n\n    By using a cookiecutter template, memote will ask you a couple of questions\n    and set up a new directory structure that will make your life easier. The\n    new directory will be placed in the current directory or respect the given\n    --directory option.\n\n    \"\"\"\n    callbacks.git_installed()\n    if directory is None:\n        directory = os.getcwd()\n    cookiecutter(\"gh:opencobra/cookiecutter-memote\", output_dir=directory,\n                 replay=replay)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload the repository to GitHub and enable testing on Travis CI.", "response": "def online(note, github_repository, github_username):\n    \"\"\"Upload the repository to GitHub and enable testing on Travis CI.\"\"\"\n    callbacks.git_installed()\n    try:\n        repo = git.Repo()\n    except git.InvalidGitRepositoryError:\n        LOGGER.critical(\n            \"'memote online' requires a git repository in order to follow \"\n            \"the current branch's commit history.\")\n        sys.exit(1)\n    if note == \"memote-ci access\":\n        note = \"{} to {}\".format(note, github_repository)\n\n    # Github API calls\n    # Set up the git repository on GitHub via API v3.\n    gh_repo_name, auth_token, repo_access_token = _setup_gh_repo(\n        github_repository,\n        github_username,\n        note\n    )\n\n    # Travis API calls\n    # Configure Travis CI to use Github auth token then return encrypted token.\n    secret = _setup_travis_ci(gh_repo_name, auth_token, repo_access_token)\n\n    # Save the encrypted token in the travis config then commit and push\n    LOGGER.info(\"Storing GitHub token in '.travis.yml'.\")\n    config = te.load_travis_configuration(\".travis.yml\")\n    global_env = config.setdefault(\"env\", {}).get(\"global\")\n    if global_env is None:\n        config[\"env\"][\"global\"] = global_env = {}\n    try:\n        global_env[\"secure\"] = secret\n    except TypeError:\n        global_env.append({\"secure\": secret})\n    te.dump_travis_configuration(config, \".travis.yml\")\n    LOGGER.info(\"Add, commit and push changes to '.travis.yml' to GitHub.\")\n    repo.index.add([\".travis.yml\"])\n    check_call(\n      ['git', 'commit', '-m', \"chore: add encrypted GitHub access token\"]\n    )\n    check_call(\n      ['git', 'push', '--set-upstream', 'origin', repo.active_branch.name]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclone and gzip the mock repo.", "response": "def update_mock_repo():\n    \"\"\"\n    Clone and gzip the memote-mock-repo used for CLI and integration tests.\n\n    The repo is hosted at\n    'https://github.com/ChristianLieven/memote-mock-repo.git' and maintained\n    separately from\n\n    \"\"\"\n    target_file = os.path.abspath(\n        join(\"tests\", \"data\", \"memote-mock-repo.tar.gz\")\n    )\n    temp_dir = mkdtemp(prefix='tmp_mock')\n    previous_wd = os.getcwd()\n    try:\n        LOGGER.info(\"Cloning repository.\")\n        os.chdir(temp_dir)\n        check_output(\n            ['git', 'clone',\n             'https://github.com/ChristianLieven/memote-mock-repo.git']\n        )\n        os.chdir('memote-mock-repo/')\n        LOGGER.info(\"Setting git to ignore filemode changes.\")\n        call(\n            ['git', 'config',\n             'core.fileMode', 'false']\n        )\n        call(\n            ['git', 'config',\n             'user.email', 'memote@opencobra.com']\n        )\n        call(\n            ['git', 'config',\n             'user.name', 'memote-bot']\n        )\n    finally:\n        LOGGER.info(\"Compressing to tarball.\")\n        tar = tarfile.open(target_file, \"w:gz\")\n        tar.add(\n            join(temp_dir, 'memote-mock-repo/'),\n            arcname=\"memote-mock-repo\"\n        )\n        tar.close()\n        LOGGER.info(\"Success!\")\n        LOGGER.info(\"Removing temporary directory.\")\n        rmtree(temp_dir)\n        LOGGER.info(\"Success! The mock repo has been updated.\")\n        os.chdir(previous_wd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the sum of all reaction compounds.", "response": "def sum_biomass_weight(reaction):\n    \"\"\"\n    Compute the sum of all reaction compounds.\n\n    This function expects all metabolites of the biomass reaction to have\n    formula information assigned.\n\n    Parameters\n    ----------\n    reaction : cobra.core.reaction.Reaction\n        The biomass reaction of the model under investigation.\n\n    Returns\n    -------\n    float\n        The molecular weight of the biomass reaction in units of g/mmol.\n\n    \"\"\"\n    return sum(-coef * met.formula_weight\n               for (met, coef) in iteritems(reaction.metabolites)) / 1000.0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all biomass precursors of the given reaction.", "response": "def find_biomass_precursors(model, reaction):\n    \"\"\"\n    Return a list of all biomass precursors excluding ATP and H2O.\n\n    Parameters\n    ----------\n    reaction : cobra.core.reaction.Reaction\n        The biomass reaction of the model under investigation.\n    model : cobra.Model\n        The metabolic model under investigation.\n\n    Returns\n    -------\n    list\n        Metabolite objects that are reactants of the biomass reaction excluding\n        ATP and H2O.\n\n    \"\"\"\n    id_of_main_compartment = helpers.find_compartment_id_in_model(model, 'c')\n    gam_reactants = set()\n    try:\n        gam_reactants.update([\n            helpers.find_met_in_model(\n                model, \"MNXM3\", id_of_main_compartment)[0]])\n    except RuntimeError:\n        pass\n    try:\n        gam_reactants.update([\n            helpers.find_met_in_model(\n                model, \"MNXM2\", id_of_main_compartment)[0]])\n    except RuntimeError:\n        pass\n\n    biomass_precursors = set(reaction.reactants) - gam_reactants\n\n    return list(biomass_precursors)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_blocked_biomass_precursors(reaction, model):\n    LOGGER.debug(\"Finding blocked biomass precursors\")\n    precursors = find_biomass_precursors(model, reaction)\n    blocked_precursors = list()\n    _, ub = helpers.find_bounds(model)\n    for precursor in precursors:\n        with model:\n            dm_rxn = model.add_boundary(\n                precursor,\n                type=\"safe-demand\",\n                reaction_id=\"safe_demand\",\n                lb=0,\n                ub=ub\n            )\n            flux = helpers.run_fba(model, dm_rxn.id, direction='max')\n            if np.isnan(flux) or abs(flux) < 1E-08:\n                blocked_precursors.append(precursor)\n    return blocked_precursors", "response": "Returns a list of all biomass precursors that cannot be produced by flux balance analysis."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gam_in_biomass(model, reaction):\n    id_of_main_compartment = helpers.find_compartment_id_in_model(model, 'c')\n\n    try:\n        left = {\n            helpers.find_met_in_model(\n                model, \"MNXM3\", id_of_main_compartment)[0],\n            helpers.find_met_in_model(\n                model, \"MNXM2\", id_of_main_compartment)[0]\n        }\n        right = {\n            helpers.find_met_in_model(\n                model, \"MNXM7\", id_of_main_compartment)[0],\n            helpers.find_met_in_model(\n                model, \"MNXM1\", id_of_main_compartment)[0],\n            helpers.find_met_in_model(\n                model, \"MNXM9\", id_of_main_compartment)[0]\n        }\n    except RuntimeError:\n        return False\n\n    return (\n        left.issubset(set(reaction.reactants)) and\n        right.issubset(set(reaction.products)))", "response": "Returns a boolean if the reaction includes growth - associated maintenance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of possible direct biomass precursor metabolites for a given reaction.", "response": "def find_direct_metabolites(model, reaction, tolerance=1E-06):\n    \"\"\"\n    Return list of possible direct biomass precursor metabolites.\n\n    The term direct metabolites describes metabolites that are involved only\n    in either transport and/or boundary reactions, AND the biomass reaction(s),\n    but not in any purely metabolic reactions.\n\n    Parameters\n    ----------\n    model : cobra.Model\n        The metabolic model under investigation.\n    reaction : cobra.Reaction\n        The biomass reaction of the model under investigation.\n    tolerance : float, optional\n        Tolerance below which values will be regarded as zero.\n\n    Returns\n    -------\n    list\n        Metabolites that qualify as direct metabolites i.e. biomass precursors\n        that are taken up to be consumed by the biomass reaction only.\n\n    \"\"\"\n    biomass_rxns = set(helpers.find_biomass_reaction(model))\n    tra_bou_bio_rxns = helpers.find_interchange_biomass_reactions(\n        model, biomass_rxns)\n    try:\n        precursors = find_biomass_precursors(model, reaction)\n        main_comp = helpers.find_compartment_id_in_model(model, 'c')\n        ext_space = helpers.find_compartment_id_in_model(model, 'e')\n    except KeyError:\n        LOGGER.error(\"Failed to properly identify cytosolic and extracellular \"\n                     \"compartments.\")\n        raise_with_traceback(KeyError(\"The cytosolic and/or extracellular \"\n                                      \"compartments could not be identified.\"))\n    except RuntimeError:\n        LOGGER.error(\"Failed to properly identify cytosolic and extracellular \"\n                     \"compartments.\")\n        raise_with_traceback(RuntimeError(\"The cytosolic and/or extracellular \"\n                                          \"compartments could not be \"\n                                          \"identified.\"))\n    else:\n        tra_bou_bio_mets = [met for met in precursors if\n                            met.reactions.issubset(tra_bou_bio_rxns)]\n        rxns_of_interest = set([rxn for met in tra_bou_bio_mets\n                                for rxn in met.reactions\n                                if rxn not in biomass_rxns])\n\n    solution = model.optimize(raise_error=True)\n    if np.isclose(solution.objective_value, 0, atol=tolerance):\n        LOGGER.error(\"Failed to generate a non-zero objective value with \"\n                     \"flux balance analysis.\")\n        raise OptimizationError(\n            \"The flux balance analysis on this model returned an \"\n            \"objective value of zero. Make sure the model can \"\n            \"grow! Check if the constraints are not too strict!\")\n\n    tra_bou_bio_fluxes = {r: solution[r.id] for r in rxns_of_interest}\n    met_flux_sum = {m: 0 for m in tra_bou_bio_mets}\n\n    return detect_false_positive_direct_metabolites(\n        tra_bou_bio_mets, biomass_rxns, main_comp, ext_space,\n        tra_bou_bio_fluxes, met_flux_sum)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndetects false positive direct metabolites in the given set of candidates.", "response": "def detect_false_positive_direct_metabolites(\n        candidates, biomass_reactions, cytosol, extra, reaction_fluxes,\n        metabolite_fluxes):\n    \"\"\"\n    Weed out false positive direct metabolites.\n\n    False positives exists in the extracellular\n    compartment with flux from the cytosolic compartment and are part of the\n    biomass reaction(s). It sums fluxes positively or negatively depending\n    on if direct metabolites in the extracellular compartment are defined as\n    reactants or products in various reactions.\n\n    Parameters\n    ----------\n    candidates : list of cobra.Metabolite\n        Candidate direct metabolites.\n    biomass_reactions : set of cobra.Reaction\n        The biomass reactions. Usually one or two.\n    cytosol : str\n        The identifier of the cytosolic compartment.\n    extra : str\n        The identifier of the extracellular compartment.\n\n    Returns\n    -------\n    list\n        Definitive list of direct metabolites, i.e., biomass precursors\n        that are taken up to be consumed by the biomass reaction only.\n\n    \"\"\"\n    for met in candidates:\n        is_internal = met.compartment != extra\n        for rxn in met.reactions:\n            if rxn in biomass_reactions:\n                continue\n            # Internal metabolites can not be false positives.\n            if is_internal:\n                metabolite_fluxes[met] += abs(reaction_fluxes[rxn])\n                continue\n            # if the metabolite is in the \"e\" compartment and a reactant,\n            # sum the fluxes accordingly (outward=negative, inward=positive)\n            if met in rxn.reactants:\n                product_comps = set([p.compartment for p in rxn.products])\n                # if the reaction has no product (outward flux)\n                if len(product_comps) == 0:\n                    metabolite_fluxes[met] += -reaction_fluxes[rxn]\n                # if the reaction has a product in \"c\" (inward flux)\n                elif cytosol in product_comps:\n                    metabolite_fluxes[met] += reaction_fluxes[rxn]\n            # if the metabolite is in the \"e\" compartment and a product,\n            # sum the fluxes accordingly (outward=negative, inward=positive)\n            elif met in rxn.products:\n                reactant_comps = set([p.compartment for p in rxn.reactants])\n                # if the reaction has no reactant (inward flux)\n                if len(reactant_comps) == 0:\n                    metabolite_fluxes[met] += reaction_fluxes[rxn]\n                # if the reaction has a reactant in \"c\" (outward flux)\n                elif cytosol in reactant_comps:\n                    metabolite_fluxes[met] += -reaction_fluxes[rxn]\n    return [m for m, f in iteritems(metabolite_fluxes) if f > 0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bundle_biomass_components(model, reaction):\n    if len(reaction.metabolites) >= 16:\n        return [reaction]\n\n    id_of_main_compartment = helpers.find_compartment_id_in_model(model,\n                                                                  'c')\n    gam_mets = [\"MNXM3\", \"MNXM2\", \"MNXM7\", \"MNXM1\", 'MNXM9']\n    try:\n        gam = set([helpers.find_met_in_model(\n            model, met, id_of_main_compartment)[0] for met in gam_mets])\n    except RuntimeError:\n        gam = set()\n    regex = re.compile('^{}(_[a-zA-Z]+?)*?$'.format('biomass'),\n                       re.IGNORECASE)\n    biomass_metabolite = set(model.metabolites.query(regex))\n\n    macromolecules = set(reaction.metabolites) - gam - biomass_metabolite\n\n    bundled_reactions = set()\n    for met in macromolecules:\n        bundled_reactions = bundled_reactions | set(met.reactions)\n\n    return list(bundled_reactions)", "response": "Return a list of all bundle biomass components for a given reaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef essential_precursors_not_in_biomass(model, reaction):\n    main_comp = helpers.find_compartment_id_in_model(model, 'c')\n    biomass_eq = bundle_biomass_components(model, reaction)\n    pooled_precursors = set(\n        [met for rxn in biomass_eq for met in rxn.metabolites])\n\n    missing_essential_precursors = []\n    for mnx_id in ESSENTIAL_PRECURSOR_IDS:\n        try:\n            met = helpers.find_met_in_model(model, mnx_id, main_comp)[0]\n            if met not in pooled_precursors:\n                missing_essential_precursors.append(met.id)\n        except RuntimeError:\n            missing_essential_precursors.append(mnx_id)\n\n    return missing_essential_precursors", "response": "u Return a list of essential precursors missing from the biomass reaction."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading and validate an experimental data configuration.", "response": "def validate_experimental(context, param, value):\n    \"\"\"Load and validate an experimental data configuration.\"\"\"\n    if value is None:\n        return\n    config = ExperimentConfiguration(value)\n    config.validate()\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a git repository instance if it exists.", "response": "def probe_git():\n    \"\"\"Return a git repository instance if it exists.\"\"\"\n    try:\n        repo = git.Repo()\n    except git.InvalidGitRepositoryError:\n        LOGGER.warning(\n            \"We highly recommend keeping your model in a git repository.\"\n            \" It allows you to track changes and to easily collaborate with\"\n            \" others via online platforms such as https://github.com.\\n\")\n        return\n    if repo.is_dirty():\n        LOGGER.critical(\n            \"Please git commit or git stash all changes before running\"\n            \" the memote suite.\")\n        sys.exit(1)\n    return repo"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninterrupt execution of memote if git has not been installed.", "response": "def git_installed():\n    \"\"\"Interrupt execution of memote if `git` has not been installed.\"\"\"\n    LOGGER.info(\"Checking `git` installation.\")\n    try:\n        check_output(['git', '--version'])\n    except CalledProcessError as e:\n        LOGGER.critical(\n            \"The execution of memote was interrupted since no installation of \"\n            \"`git` could be detected. Please install git to use \"\n            \"this functionality: \"\n            \"https://git-scm.com/book/en/v2/Getting-Started-Installing-Git\")\n        LOGGER.debug(\"Underlying error:\", exc_info=e)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn GitInfo object for the specified commit.", "response": "def record_git_info(self, commit=None):\n        \"\"\"\n        Record git meta information.\n\n        Parameters\n        ----------\n        commit : str, optional\n            Unique hexsha of the desired commit.\n\n        Returns\n        -------\n        GitInfo\n            Git commit meta information.\n\n        \"\"\"\n        if commit is None:\n            commit = self._repo.head.commit\n        else:\n            commit = self._repo.commit(commit)\n        return GitInfo(\n            hexsha=commit.hexsha,\n            author=commit.author.name,\n            email=commit.author.email,\n            authored_on=commit.authored_datetime\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_git(meta, git_info):\n        meta[\"hexsha\"] = git_info.hexsha\n        meta[\"author\"] = git_info.author\n        meta[\"email\"] = git_info.email\n        meta[\"authored_on\"] = git_info.authored_on.isoformat(\" \")", "response": "Enrich the result meta information with commit data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef store(self, result, commit=None, **kwargs):\n        git_info = self.record_git_info(commit)\n        self.add_git(result.meta, git_info)\n        filename = self.get_filename(git_info)\n        super(RepoResultManager, self).store(\n            result, filename=filename, **kwargs)", "response": "Store a result in a JSON file attaching git meta information."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a result from the storage directory.", "response": "def load(self, commit=None):\n        \"\"\"Load a result from the storage directory.\"\"\"\n        git_info = self.record_git_info(commit)\n        LOGGER.debug(\"Loading the result for commit '%s'.\", git_info.hexsha)\n        filename = self.get_filename(git_info)\n        LOGGER.debug(\"Loading the result '%s'.\", filename)\n        result = super(RepoResultManager, self).load(filename)\n        self.add_git(result.meta, git_info)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize(filename):\n        # Default value means we do not resolve a model file.\n        if filename == \"default\":\n            return filename\n        filename = expanduser(filename)\n        if isabs(filename):\n            return filename\n        else:\n            return join(os.getcwd(), filename)", "response": "Return an absolute path of the given file name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the data table and corresponding validation schema.", "response": "def load(self, dtype_conversion=None):\n        \"\"\"\n        Load the data table and corresponding validation schema.\n\n        Parameters\n        ----------\n        dtype_conversion : dict\n            Column names as keys and corresponding type for loading the data.\n            Please take a look at the `pandas documentation\n            <https://pandas.pydata.org/pandas-docs/stable/io.html#specifying-column-data-types>`__\n            for detailed explanations.\n\n        \"\"\"\n        if dtype_conversion is None:\n            dtype_conversion = {\"growth\": str}\n        super(GrowthExperiment, self).load(dtype_conversion=dtype_conversion)\n        self.data[\"growth\"] = self.data[\"growth\"].isin(self.TRUTHY)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef evaluate(self, model, threshold=0.1):\n        with model:\n            if self.medium is not None:\n                self.medium.apply(model)\n            if self.objective is not None:\n                model.objective = self.objective\n            model.add_cons_vars(self.constraints)\n            threshold *= model.slim_optimize()\n            growth = list()\n            for row in self.data.itertuples(index=False):\n                with model:\n                    exchange = model.reactions.get_by_id(row.exchange)\n                    if bool(exchange.reactants):\n                        exchange.lower_bound = -row.uptake\n                    else:\n                        exchange.upper_bound = row.uptake\n                    growth.append(model.slim_optimize() >= threshold)\n        return DataFrame({\n            \"exchange\": self.data[\"exchange\"],\n            \"growth\": growth\n        })", "response": "Evaluate in silico growth rates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the value to a JSON encoded string before storing it.", "response": "def process_bind_param(self, value, dialect):\n        \"\"\"Convert the value to a JSON encoded string before storing it.\"\"\"\n        try:\n            with BytesIO() as stream:\n                with GzipFile(fileobj=stream, mode=\"wb\") as file_handle:\n                    file_handle.write(\n                        jsonify(value, pretty=False).encode(\"utf-8\")\n                    )\n                output = stream.getvalue()\n            return output\n        except TypeError as error:\n            log_json_incompatible_types(value)\n            raise_with_traceback(error)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_result_value(self, value, dialect):\n        if value is not None:\n            with BytesIO(value) as stream:\n                with GzipFile(fileobj=stream, mode=\"rb\") as file_handle:\n                    value = json.loads(file_handle.read().decode(\"utf-8\"))\n        return value", "response": "Convert a JSON encoded string to a dictionary structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders a nosec password strength input.", "response": "def render(self, name, value, attrs=None, **kwargs):\n        \"\"\"Widget render method.\"\"\"\n        min_score = zxcvbn_min_score()\n        message_title = _('Warning')\n        message_body = _(\n            'This password would take '\n            '<em class=\"password_strength_time\"></em> to crack.')\n\n        strength_markup = \"\"\"\n        <div class=\"progress-bloc\" style=\"margin-top: 10px;\">\n            <div class=\"progress\" style=\"margin-bottom: 10px;\">\n                <div class=\"progress-bar\n                            progress-bar-warning\n                            password_strength_bar\"\n                     role=\"progressbar\"\n                     aria-valuenow=\"0\"\n                     aria-valuemin=\"{min_score}\"\n                     aria-valuemax=\"4\"\n                     style=\"width: 0%%\">\n                </div>\n            </div>\n            <p class=\"text-muted password_strength_info hidden\">\n                <span class=\"label label-danger\">\n                    {title}\n                </span>\n                <span style=\"margin-left:5px;\">\n                    {body}\n                </span>\n            </p>\n        </div>\n        \"\"\"\n\n        strength_markup = strength_markup.format(\n            title=message_title,\n            body=message_body,\n            min_score=min_score)\n\n        try:\n            self.attrs['class'] = '%s password_strength'.strip() % self.attrs['class']  # noqa\n        except KeyError:\n            self.attrs['class'] = 'password_strength'\n\n        return mark_safe(super(PasswordStrengthInput, self).render(  # nosec\n            name, value, attrs) + strength_markup)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating method run zxcvbn and check score.", "response": "def validate(self, password, user=None):\n        \"\"\"Validate method, run zxcvbn and check score.\"\"\"\n        user_inputs = []\n        if user is not None:\n            for attribute in self.user_attributes:\n                if hasattr(user, attribute):\n                    user_inputs.append(getattr(user, attribute))\n\n        results = zxcvbn(password, user_inputs=user_inputs)\n        if results.get('score', 0) < self.min_score:\n            feedback = ', '.join(\n                results.get('feedback', {}).get('suggestions', []))\n            raise ValidationError(_(feedback), code=self.code, params={})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_html_contents(html):\n    parser = MyHTMLParser()\n    parser.feed(html)\n    if parser.is_code:\n        return ('code', parser.data.strip())\n    elif parser.is_math:\n        return ('math', parser.data.strip())\n    else:\n        return '', ''", "response": "Process a HTML block and detects whether it is a code block math block or regular HTML block."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn whether an object is a path.", "response": "def _is_path(s):\n    \"\"\"Return whether an object is a path.\"\"\"\n    if isinstance(s, string_types):\n        try:\n            return op.exists(s)\n        except (OSError, ValueError):\n            return False\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the singleton instance creating if necessary", "response": "def format_manager(cls):\n        \"\"\"Return the instance singleton, creating if necessary\n        \"\"\"\n        if cls._instance is None:\n            # Discover the formats and register them with a new singleton.\n            cls._instance = cls().register_entrypoints()\n        return cls._instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_entrypoints(self):\n        for spec in iter_entry_points(self.entry_point_group):\n            format_properties = {\"name\": spec.name}\n            try:\n                format_properties.update(spec.load())\n            except (DistributionNotFound, ImportError) as err:\n                self.log.info(\n                    \"ipymd format {} could not be loaded: {}\".format(\n                        spec.name, err))\n                continue\n\n            self.register(**format_properties)\n\n        return self", "response": "Load all of the formats in the entry_points and register them with the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind a format from its extension.", "response": "def format_from_extension(self, extension):\n        \"\"\"Find a format from its extension.\"\"\"\n        formats = [name\n                   for name, format in self._formats.items()\n                   if format.get('file_extension', None) == extension]\n        if len(formats) == 0:\n            return None\n        elif len(formats) == 2:\n            raise RuntimeError(\"Several extensions are registered with \"\n                               \"that extension; please specify the format \"\n                               \"explicitly.\")\n        else:\n            return formats[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self, file, name=None):\n        if name is None:\n            name = self.format_from_extension(op.splitext(file)[1])\n        file_format = self.file_type(name)\n        if file_format == 'text':\n            return _read_text(file)\n        elif file_format == 'json':\n            return _read_json(file)\n        else:\n            load_function = self._formats[name].get('load', None)\n            if load_function is None:\n                raise IOError(\"The format must declare a file type or \"\n                              \"load/save functions.\")\n            return load_function(file)", "response": "Load a file. The format name can be specified explicitly or inferred from the file extension."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsaving contents into a file.", "response": "def save(self, file, contents, name=None, overwrite=False):\n        \"\"\"Save contents into a file. The format name can be specified\n        explicitly or inferred from the file extension.\"\"\"\n        if name is None:\n            name = self.format_from_extension(op.splitext(file)[1])\n        file_format = self.file_type(name)\n        if file_format == 'text':\n            _write_text(file, contents)\n        elif file_format == 'json':\n            _write_json(file, contents)\n        else:\n            write_function = self._formats[name].get('save', None)\n            if write_function is None:\n                raise IOError(\"The format must declare a file type or \"\n                              \"load/save functions.\")\n            if op.exists(file) and not overwrite:\n                print(\"The file already exists, please use overwrite=True.\")\n                return\n            write_function(file, contents)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_reader(self, name, *args, **kwargs):\n        self._check_format(name)\n        return self._formats[name]['reader'](*args, **kwargs)", "response": "Create a new reader instance for a given format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new writer instance for a given format.", "response": "def create_writer(self, name, *args, **kwargs):\n        \"\"\"Create a new writer instance for a given format.\"\"\"\n        self._check_format(name)\n        return self._formats[name]['writer'](*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert(self,\n                contents_or_path,\n                from_=None,\n                to=None,\n                reader=None,\n                writer=None,\n                from_kwargs=None,\n                to_kwargs=None,\n                ):\n        \"\"\"Convert contents between supported formats.\n\n        Parameters\n        ----------\n\n        contents : str\n            The contents to convert from.\n        from_ : str or None\n            The name of the source format. If None, this is the\n            ipymd_cells format.\n        to : str or None\n            The name of the target format. If None, this is the\n            ipymd_cells format.\n        reader : a Reader instance or None\n        writer : a Writer instance or None\n        from_kwargs : dict\n            Optional keyword arguments to pass to the reader instance.\n        to_kwargs : dict\n            Optional keyword arguments to pass to the writer instance.\n\n        \"\"\"\n\n        # Load the file if 'contents_or_path' is a path.\n        if _is_path(contents_or_path):\n            contents = self.load(contents_or_path, from_)\n        else:\n            contents = contents_or_path\n\n        if from_kwargs is None:\n            from_kwargs = {}\n        if to_kwargs is None:\n            to_kwargs = {}\n\n        if reader is None:\n            reader = (self.create_reader(from_, **from_kwargs)\n                      if from_ is not None else None)\n\n        if writer is None:\n            writer = (self.create_writer(to, **to_kwargs)\n                      if to is not None else None)\n\n        if reader is not None:\n            # Convert from the source format to ipymd cells.\n            cells = [cell for cell in reader.read(contents)]\n        else:\n            # If no reader is specified, 'contents' is assumed to already be\n            # a list of ipymd cells.\n            cells = contents\n\n        notebook_metadata = [cell for cell in cells\n                             if cell[\"cell_type\"] == \"notebook_metadata\"]\n\n        if writer is not None:\n            if notebook_metadata:\n                [cells.remove(cell) for cell in notebook_metadata]\n                notebook_metadata = self.clean_meta(\n                    notebook_metadata[0][\"metadata\"]\n                )\n                if hasattr(writer, \"write_notebook_metadata\"):\n                    writer.write_notebook_metadata(notebook_metadata)\n                else:\n                    print(\"{} does not support notebook metadata, \"\n                          \"dropping metadata: {}\".format(\n                              writer,\n                              notebook_metadata))\n\n            # Convert from ipymd cells to the target format.\n            for cell in cells:\n                meta = self.clean_cell_meta(cell.get(\"metadata\", {}))\n                if not meta:\n                    cell.pop(\"metadata\", None)\n                writer.write(cell)\n\n            return writer.contents\n        else:\n            # If no writer is specified, the output is supposed to be\n            # a list of ipymd cells.\n            return cells", "response": "Convert contents between the ipymd cells and the notebook metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves unwanted metadata from the Notebook metadata.", "response": "def clean_meta(self, meta):\n        \"\"\"Removes unwanted metadata\n\n        Parameters\n        ----------\n\n        meta : dict\n            Notebook metadata.\n        \"\"\"\n        if not self.verbose_metadata:\n            default_kernel_name = (self.default_kernel_name or\n                                   self._km.kernel_name)\n\n            if (meta.get(\"kernelspec\", {})\n                    .get(\"name\", None) == default_kernel_name):\n                del meta[\"kernelspec\"]\n                meta.pop(\"language_info\", None)\n\n        return meta"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_cell_meta(self, meta):\n        for k, v in DEFAULT_CELL_METADATA.items():\n            if meta.get(k, None) == v:\n                meta.pop(k, None)\n        return meta", "response": "Remove cell metadata that matches the default cell metadata."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning whether a line starts with a regex.", "response": "def _starts_with_regex(line, regex):\n    \"\"\"Return whether a line starts with a regex or not.\"\"\"\n    if not regex.startswith('^'):\n        regex = '^' + regex\n    reg = re.compile(regex)\n    return reg.match(line)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a prompt manager.", "response": "def create_prompt(prompt):\n    \"\"\"Create a prompt manager.\n\n    Parameters\n    ----------\n\n    prompt : str or class driving from BasePromptManager\n        The prompt name ('python' or 'ipython') or a custom PromptManager\n        class.\n\n    \"\"\"\n    if prompt is None:\n        prompt = 'python'\n    if prompt == 'python':\n        prompt = PythonPromptManager\n    elif prompt == 'ipython':\n        prompt = IPythonPromptManager\n    # Instanciate the class.\n    if isinstance(prompt, BasePromptManager):\n        return prompt\n    else:\n        return prompt()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_input_output(self, text):\n        lines = _to_lines(text)\n        i = 0\n        for line in lines:\n            if _starts_with_regex(line, self.input_prompt_regex):\n                i += 1\n            else:\n                break\n        return lines[:i], lines[i:]", "response": "Split code into input lines and output lines according to the\n        input and output prompt templates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary containing the contents of a file or directory.", "response": "def get(self, path, content=True, type=None, format=None):\n        \"\"\" Takes a path for an entity and returns its model\n        Parameters\n        ----------\n        path : str\n            the API path that describes the relative path for the target\n        content : bool\n            Whether to include the contents in the reply\n        type : str, optional\n            The requested type - 'file', 'notebook', or 'directory'.\n            Will raise HTTPError 400 if the content doesn't match.\n        format : str, optional\n            The requested format for file contents. 'text' or 'base64'.\n            Ignored if this returns a notebook or directory model.\n        Returns\n        -------\n        model : dict\n            the contents model. If content=True, returns the contents\n            of the file or directory as well.\n        \"\"\"\n        path = path.strip('/')\n\n        # File extension of the chosen format.\n        file_extension = format_manager().file_extension(self.format)\n\n        if not self.exists(path):\n            raise web.HTTPError(404, u'No such file or directory: %s' % path)\n\n        os_path = self._get_os_path(path)\n        if os.path.isdir(os_path):\n            if type not in (None, 'directory'):\n                raise web.HTTPError(400,\n                                u'%s is a directory, not a %s' % (path, type), reason='bad type')\n            model = self._dir_model(path, content=content)\n        elif type == 'notebook' or (type is None and\n                                    (path.endswith('.ipynb') or\n                                     path.endswith(file_extension))):  # NEW\n            model = self._notebook_model(path, content=content)\n        else:\n            if type == 'directory':\n                raise web.HTTPError(400,\n                                u'%s is not a directory', reason='bad type')\n            model = self._file_model(path, content=content, format=format)\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads a notebook from an os path.", "response": "def _read_notebook(self, os_path, as_version=4):\n        \"\"\"Read a notebook from an os path.\"\"\"\n        with self.open(os_path, 'r', encoding='utf-8') as f:\n            try:\n\n                # NEW\n                file_ext = _file_extension(os_path)\n                if file_ext == '.ipynb':\n                    return nbformat.read(f, as_version=as_version)\n                else:\n                    return convert(os_path, from_=self.format, to='notebook')\n\n            except Exception as e:\n                raise HTTPError(\n                    400,\n                    u\"Unreadable Notebook: %s %r\" % (os_path, e),\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the file model and return the model with no content.", "response": "def save(self, model, path=''):\n        \"\"\"Save the file model and return the model with no content.\"\"\"\n        path = path.strip('/')\n\n        if 'type' not in model:\n            raise web.HTTPError(400, u'No file type provided')\n        if 'content' not in model and model['type'] != 'directory':\n            raise web.HTTPError(400, u'No file content provided')\n\n        self.run_pre_save_hook(model=model, path=path)\n\n        os_path = self._get_os_path(path)\n        self.log.debug(\"Saving %s\", os_path)\n        try:\n            if model['type'] == 'notebook':\n\n                # NEW\n                file_ext = _file_extension(os_path)\n                if file_ext == '.ipynb':\n                    nb = nbformat.from_dict(model['content'])\n                    self.check_and_sign(nb, path)\n                    self._save_notebook(os_path, nb)\n                else:\n\n                    contents = convert(model['content'],\n                                       from_='notebook',\n                                       to=self.format)\n\n                    # Save a text file.\n                    if (format_manager().file_type(self.format) in\n                        ('text', 'json')):\n                        self._save_file(os_path, contents, 'text')\n                    # Save to a binary file.\n                    else:\n                        format_manager().save(os_path, contents,\n                                              name=self.format,\n                                              overwrite=True)\n\n                # One checkpoint should always exist for notebooks.\n                if not self.checkpoints.list_checkpoints(path):\n                    self.create_checkpoint(path)\n            elif model['type'] == 'file':\n                # Missing format will be handled internally by _save_file.\n                self._save_file(os_path, model['content'], model.get('format'))\n            elif model['type'] == 'directory':\n                self._save_directory(os_path, model, path)\n            else:\n                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model['type'])\n        except web.HTTPError:\n            raise\n        except Exception as e:\n            self.log.error(u'Error while saving file: %s %s', path, e, exc_info=True)\n            raise web.HTTPError(500, u'Unexpected error while saving file: %s %s' % (path, e))\n\n        validation_message = None\n        if model['type'] == 'notebook':\n            self.validate_notebook_model(model)\n            validation_message = model.get('message', None)\n\n        model = self.get(path, content=False)\n        if validation_message:\n            model['message'] = validation_message\n\n        self.run_post_save_hook(model=model, os_path=os_path)\n\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _split_python(python):\n    python = _preprocess(python)\n    if not python:\n        return []\n    lexer = PythonSplitLexer()\n    lexer.read(python)\n    return lexer.chunks", "response": "Split Python source into chunks."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn whether a chunk contains Markdown contents.", "response": "def _is_chunk_markdown(source):\n    \"\"\"Return whether a chunk contains Markdown contents.\"\"\"\n    lines = source.splitlines()\n    if all(line.startswith('# ') for line in lines):\n        # The chunk is a Markdown *unless* it is commented Python code.\n        source = '\\n'.join(line[2:] for line in lines\n                           if not line[2:].startswith('#'))  # skip headers\n        if not source:\n            return True\n        # Try to parse the chunk: if it fails, it is Markdown, otherwise,\n        # it is Python.\n        return not _is_python(source)\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a leading hash '#' at the beginning of every line in the source.", "response": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _filter_markdown(source, filters):\n    lines = source.splitlines()\n    # Filters is a list of 'hN' strings where 1 <= N <= 6.\n    headers = [_replace_header_filter(filter) for filter in filters]\n    lines = [line for line in lines if line.startswith(tuple(headers))]\n    return '\\n'.join(lines)", "response": "Only keep some Markdown headers from a Markdown string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ensure_newline(self, n):\n        assert n >= 0\n        text = self._output.getvalue().rstrip('\\n')\n        if not text:\n            return\n        self._output = StringIO()\n        self._output.write(text)\n        self._output.write('\\n' * n)\n        text = self._output.getvalue()\n        assert text[-n-1] != '\\n'\n        assert text[-n:] == '\\n' * n", "response": "Make sure there are n line breaks at the end."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract and parse YAML metadata from a regex match.", "response": "def _meta_from_regex(self, m):\n        \"\"\"Extract and parse YAML metadata from a meta match\n\n        Notebook metadata must appear at the beginning of the file and follows\n        the Jekyll front-matter convention of dashed delimiters:\n\n            ---\n            some: yaml\n            ---\n\n        Cell metadata follows the YAML spec of dashes and periods\n\n            ---\n            some: yaml\n            ...\n\n        Both must be followed by at least one blank line (\\n\\n).\n        \"\"\"\n        body = m.group('body')\n        is_notebook = m.group('sep_close') == '---'\n\n        if is_notebook:\n            # make it into a valid YAML object by stripping ---\n            body = body.strip()[:-3] + '...'\n        try:\n            if body:\n                return self._meta(yaml.safe_load(m.group('body')), is_notebook)\n            else:\n                return self._meta({'ipymd': {'empty_meta': True}}, is_notebook)\n        except Exception as err:\n            raise Exception(body, err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _code_cell(self, source):\n        input, output = self._prompt.to_cell(source)\n        return {'cell_type': 'code',\n                'input': input,\n                'output': output}", "response": "Split the source into input and output."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a diff between two strings.", "response": "def _diff(text_0, text_1):\n    \"\"\"Return a diff between two strings.\"\"\"\n    diff = difflib.ndiff(text_0.splitlines(), text_1.splitlines())\n    return _diff_removed_lines(diff)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _write_json(file, contents):\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "response": "Write a dict to a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _numbered_style():\n\n    style = ListStyle(name='_numbered_list')\n\n    lls = ListLevelStyleNumber(level=1)\n\n    lls.setAttribute('displaylevels', 1)\n    lls.setAttribute('numsuffix', '. ')\n    lls.setAttribute('numformat', '1')\n\n    llp = ListLevelProperties()\n    llp.setAttribute('listlevelpositionandspacemode', 'label-alignment')\n\n    llla = ListLevelLabelAlignment(labelfollowedby='listtab')\n    llla.setAttribute('listtabstopposition', '1.27cm')\n    llla.setAttribute('textindent', '-0.635cm')\n    llla.setAttribute('marginleft', '1.27cm')\n\n    llp.addElement(llla)\n\n    # llp.setAttribute('spacebefore', '')\n    # llp.setAttribute('minlabelwidth', '')\n    lls.addElement(llp)\n\n    style.addElement(lls)\n\n    return style", "response": "Create a numbered list style."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_style(name, family=None, **kwargs):\n    if family == 'paragraph' and 'marginbottom' not in kwargs:\n        kwargs['marginbottom'] = '.5cm'\n    style = Style(name=name, family=family)\n    # Extract paragraph properties.\n    kwargs_par = {}\n    keys = sorted(kwargs.keys())\n    for k in keys:\n        if 'margin' in k:\n            kwargs_par[k] = kwargs.pop(k)\n    style.addElement(TextProperties(**kwargs))\n    if kwargs_par:\n        style.addElement(ParagraphProperties(**kwargs_par))\n    return style", "response": "Helper function for creating a new style."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating default styles for an ODF file.", "response": "def default_styles():\n    \"\"\"Generate default ODF styles.\"\"\"\n\n    styles = {}\n\n    def _add_style(name, **kwargs):\n        styles[name] = _create_style(name, **kwargs)\n\n    _add_style('heading-1',\n               family='paragraph',\n               fontsize='24pt',\n               fontweight='bold',\n               )\n    _add_style('heading-2',\n               family='paragraph',\n               fontsize='22pt',\n               fontweight='bold',\n               )\n    _add_style('heading-3',\n               family='paragraph',\n               fontsize='20pt',\n               fontweight='bold',\n               )\n    _add_style('heading-4',\n               family='paragraph',\n               fontsize='18pt',\n               fontweight='bold',\n               )\n    _add_style('heading-5',\n               family='paragraph',\n               fontsize='16pt',\n               fontweight='bold',\n               )\n    _add_style('heading-6',\n               family='paragraph',\n               fontsize='14pt',\n               fontweight='bold',\n               )\n    _add_style('normal-paragraph',\n               family='paragraph',\n               fontsize='12pt',\n               marginbottom='0.25cm',\n               )\n    _add_style('code',\n               family='paragraph',\n               fontsize='10pt',\n               fontweight='bold',\n               fontfamily='Courier New',\n               color='#555555',\n               )\n    _add_style('quote',\n               family='paragraph',\n               fontsize='12pt',\n               fontstyle='italic',\n               )\n    _add_style('list-paragraph',\n               family='paragraph',\n               fontsize='12pt',\n               marginbottom='.1cm',\n               )\n    _add_style('sublist-paragraph',\n               family='paragraph',\n               fontsize='12pt',\n               marginbottom='.1cm',\n               )\n    _add_style('numbered-list-paragraph',\n               family='paragraph',\n               fontsize='12pt',\n               marginbottom='.1cm',\n               )\n\n    _add_style('normal-text',\n               family='text',\n               fontsize='12pt',\n               )\n    _add_style('italic',\n               family='text',\n               fontstyle='italic',\n               fontsize='12pt',\n               )\n    _add_style('bold',\n               family='text',\n               fontweight='bold',\n               fontsize='12pt',\n               )\n    _add_style('url',\n               family='text',\n               fontsize='12pt',\n               fontweight='bold',\n               fontfamily='Courier',\n               )\n    _add_style('inline-code',\n               family='text',\n               fontsize='10pt',\n               fontweight='bold',\n               fontfamily='Courier New',\n               color='#555555',\n               )\n\n    styles['_numbered_list'] = _numbered_style()\n\n    return styles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of all styles contained in an ODF document.", "response": "def load_styles(path_or_doc):\n    \"\"\"Return a dictionary of all styles contained in an ODF document.\"\"\"\n    if isinstance(path_or_doc, string_types):\n        doc = load(path_or_doc)\n    else:\n        # Recover the OpenDocumentText instance.\n        if isinstance(path_or_doc, ODFDocument):\n            doc = path_or_doc._doc\n        else:\n            doc = path_or_doc\n        assert isinstance(doc, OpenDocument), doc\n    styles = {_style_name(style): style for style in doc.styles.childNodes}\n    return styles"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nindicating to the ODF reader the type of the block or text.", "response": "def _item_type(item):\n    \"\"\"Indicate to the ODF reader the type of the block or text.\"\"\"\n    tag = item['tag']\n    style = item.get('style', None)\n    if tag == 'p':\n        if style is None or 'paragraph' in style:\n            return 'paragraph'\n        else:\n            return style\n    elif tag == 'span':\n        if style in (None, 'normal-text'):\n            return 'text'\n        elif style == 'url':\n            return 'link'\n        else:\n            return style\n    elif tag == 'h':\n        assert style is not None\n        return style\n    elif tag in ('list', 'list-item', 'line-break'):\n        if style == '_numbered_list':\n            return 'numbered-list'\n        else:\n            return tag\n    elif tag == 's':\n        return 'spaces'\n    raise Exception(\"The tag '{0}' with style '{1}' hasn't \"\n                    \"been implemented.\".format(tag, style))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_styles(self, **styles):\n        for stylename in sorted(styles):\n            self._doc.styles.addElement(styles[stylename])", "response": "Add ODF styles to the current document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an element to the document.", "response": "def _add_element(self, cls, **kwargs):\n        \"\"\"Add an element.\"\"\"\n        # Convert stylename strings to actual style elements.\n        kwargs = self._replace_stylename(kwargs)\n        el = cls(**kwargs)\n        self._doc.text.addElement(el)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the style name of an element.", "response": "def _style_name(self, el):\n        \"\"\"Return the style name of an element.\"\"\"\n        if el.attributes is None:\n            return None\n        style_field = ('urn:oasis:names:tc:opendocument:xmlns:text:1.0',\n                       'style-name')\n        name = el.attributes.get(style_field, None)\n        if not name:\n            return None\n        return self._get_style_name(name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_container(self, cls, **kwargs):\n        # Convert stylename strings to actual style elements.\n        kwargs = self._replace_stylename(kwargs)\n        # Create the container.\n        container = cls(**kwargs)\n        self._containers.append(container)", "response": "Append a new container."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef end_container(self, cancel=None):\n        if not self._containers:\n            return\n        container = self._containers.pop()\n        if len(self._containers) >= 1:\n            parent = self._containers[-1]\n        else:\n            parent = self._doc.text\n        if not cancel:\n            parent.addElement(container)", "response": "Finishes and registers the currently - active container unless cancel is True."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef container(self, cls, **kwargs):\n        self.start_container(cls, **kwargs)\n        yield\n        self.end_container()", "response": "Context manager for handling container classes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start_paragraph(self, stylename=None):\n        # Use the next paragraph style if one was set.\n        if stylename is None:\n            stylename = self._next_p_style or 'normal-paragraph'\n        self.start_container(P, stylename=stylename)", "response": "Start a new paragraph."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new paragraph unless the currently - active container is already a paragraph.", "response": "def require_paragraph(self):\n        \"\"\"Create a new paragraph unless the currently-active container\n        is already a paragraph.\"\"\"\n        if self._containers and _is_paragraph(self._containers[-1]):\n            return False\n        else:\n            self.start_paragraph()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a code line.", "response": "def _code_line(self, line):\n        \"\"\"Add a code line.\"\"\"\n        assert self._containers\n        container = self._containers[-1]\n        # Handle extra spaces.\n        text = line\n        while text:\n            if text.startswith('  '):\n                r = re.match(r'(^ +)', text)\n                n = len(r.group(1))\n                container.addElement(S(c=n))\n                text = text[n:]\n            elif '  ' in text:\n                assert not text.startswith(' ')\n                i = text.index('  ')\n                container.addElement(Span(text=text[:i]))\n                text = text[i:]\n            else:\n                container.addElement(Span(text=text))\n                text = ''"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a code block.", "response": "def code(self, text, lang=None):\n        \"\"\"Add a code block.\"\"\"\n        # WARNING: lang is discarded currently.\n        with self.paragraph(stylename='code'):\n            lines = text.splitlines()\n            for line in lines[:-1]:\n                self._code_line(line)\n                self.linebreak()\n            self._code_line(lines[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart a numbered list.", "response": "def start_numbered_list(self):\n        \"\"\"Start a numbered list.\"\"\"\n        self._ordered = True\n        self.start_container(List, stylename='_numbered_list')\n        self.set_next_paragraph_style('numbered-list-paragraph'\n                                      if self._item_level <= 0\n                                      else 'sublist-paragraph')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef text(self, text, stylename=None):\n        assert self._containers\n        container = self._containers[-1]\n        if stylename is not None:\n            stylename = self._get_style_name(stylename)\n            container.addElement(Span(stylename=stylename, text=text))\n        else:\n            container.addElement(Span(text=text))", "response": "Add text within the current container."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _cell_output(cell):\n    outputs = cell.get('outputs', [])\n    # Add stdout.\n    stdout = ('\\n'.join(_ensure_string(output.get('text', ''))\n                        for output in outputs)).rstrip()\n    # Add text output.\n    text_outputs = []\n    for output in outputs:\n        out = output.get('data', {}).get('text/plain', [])\n        out = _ensure_string(out)\n        # HACK: skip <matplotlib ...> outputs.\n        if out.startswith('<matplotlib'):\n            continue\n        text_outputs.append(out)\n    return stdout + '\\n'.join(text_outputs).rstrip()", "response": "Return the output of an ipynb cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dump_add_vspacing(buff, vspacing):\n\t'Post-processing to add some nice-ish spacing for deeper map/list levels.'\n\tif isinstance(vspacing, int):\n\t\tvspacing = ['\\n']*(vspacing+1)\n\tbuff.seek(0)\n\tresult = list()\n\tfor line in buff:\n\t\tlevel = 0\n\t\tline = line.decode('utf-8')\n\t\tresult.append(line)\n\t\tif ':' in line or re.search(r'---(\\s*$|\\s)', line):\n\t\t\twhile line.startswith('  '):\n\t\t\t\tlevel, line = level + 1, line[2:]\n\t\t\tif len(vspacing) > level and len(result) != 1:\n\t\t\t\tvspace = vspacing[level]\n\t\t\t\tresult.insert( -1, vspace\n\t\t\t\t\tif not isinstance(vspace, int) else '\\n'*vspace )\n\tbuff.seek(0), buff.truncate()\n\tbuff.write(''.join(result).encode('utf-8'))", "response": "Post - processing to add some nice -ish spacing for deeper map / list levels."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a service dump.", "response": "def _dump(self, service, grep=None):\n        \"\"\"Perform a service dump.\n\n        :param service: Service to dump.\n        :param grep: Grep for this string.\n        :returns: Dump, optionally grepped.\n        \"\"\"\n        if grep:\n            return self.adb_shell('dumpsys {0} | grep \"{1}\"'.format(service, grep))\n        return self.adb_shell('dumpsys {0}'.format(service))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a dump has particular content.", "response": "def _dump_has(self, service, grep, search):\n        \"\"\"Check if a dump has particular content.\n\n        :param service: Service to dump.\n        :param grep: Grep for this string.\n        :param search: Check for this substring.\n        :returns: Found or not.\n        \"\"\"\n        dump_grep = self._dump(service, grep=grep)\n\n        if not dump_grep:\n            return False\n\n        return dump_grep.strip().find(search) > -1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming a ps command with optional filtering.", "response": "def _ps(self, search=''):\n        \"\"\"Perform a ps command with optional filtering.\n\n        :param search: Check for this substring.\n        :returns: List of matching fields\n        \"\"\"\n        if not self.available:\n            return\n        result = []\n        ps = self.adb_streaming_shell('ps')\n        try:\n            for bad_line in ps:\n                # The splitting of the StreamingShell doesn't always work\n                # this is to ensure that we get only one line\n                for line in bad_line.splitlines():\n                    if search in line:\n                        result.append(line.strip().rsplit(' ', 1)[-1])\n            return result\n        except InvalidChecksumError as e:\n            print(e)\n            self.connect()\n            raise IOError"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect to an Amazon Fire TV device.", "response": "def connect(self, always_log_errors=True):\n        \"\"\"Connect to an Amazon Fire TV device.\n\n        Will attempt to establish ADB connection to the given host.\n        Failure sets state to UNKNOWN and disables sending actions.\n\n        :returns: True if successful, False otherwise\n        \"\"\"\n        self._adb_lock.acquire(**LOCK_KWARGS)\n        try:\n            if not self.adb_server_ip:\n                # python-adb\n                try:\n                    if self.adbkey:\n                        signer = Signer(self.adbkey)\n\n                        # Connect to the device\n                        self._adb = adb_commands.AdbCommands().ConnectDevice(serial=self.host, rsa_keys=[signer], default_timeout_ms=9000)\n                    else:\n                        self._adb = adb_commands.AdbCommands().ConnectDevice(serial=self.host, default_timeout_ms=9000)\n\n                    # ADB connection successfully established\n                    self._available = True\n\n                except socket_error as serr:\n                    if self._available or always_log_errors:\n                        if serr.strerror is None:\n                            serr.strerror = \"Timed out trying to connect to ADB device.\"\n                        logging.warning(\"Couldn't connect to host: %s, error: %s\", self.host, serr.strerror)\n\n                    # ADB connection attempt failed\n                    self._adb = None\n                    self._available = False\n\n                finally:\n                    return self._available\n\n            else:\n                # pure-python-adb\n                try:\n                    self._adb_client = AdbClient(host=self.adb_server_ip, port=self.adb_server_port)\n                    self._adb_device = self._adb_client.device(self.host)\n                    self._available = bool(self._adb_device)\n\n                except:\n                    self._available = False\n\n                finally:\n                    return self._available\n\n        finally:\n            self._adb_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the state of the current app and the device.", "response": "def update(self, get_running_apps=True):\n        \"\"\"Get the state of the device, the current app, and the running apps.\n\n        :param get_running_apps: whether or not to get the ``running_apps`` property\n        :return state: the state of the device\n        :return current_app: the current app\n        :return running_apps: the running apps\n        \"\"\"\n        # The `screen_on`, `awake`, `wake_lock_size`, `current_app`, and `running_apps` properties.\n        screen_on, awake, wake_lock_size, _current_app, running_apps = self.get_properties(get_running_apps=get_running_apps, lazy=True)\n\n        # Check if device is off.\n        if not screen_on:\n            state = STATE_OFF\n            current_app = None\n            running_apps = None\n\n        # Check if screen saver is on.\n        elif not awake:\n            state = STATE_IDLE\n            current_app = None\n            running_apps = None\n\n        else:\n            # Get the current app.\n            if isinstance(_current_app, dict) and 'package' in _current_app:\n                current_app = _current_app['package']\n            else:\n                current_app = None\n\n            # Get the running apps.\n            if running_apps is None and current_app:\n                running_apps = [current_app]\n\n            # Get the state.\n            # TODO: determine the state differently based on the `current_app`.\n            if current_app in [PACKAGE_LAUNCHER, PACKAGE_SETTINGS]:\n                state = STATE_STANDBY\n\n            # Amazon Video\n            elif current_app == AMAZON_VIDEO:\n                if wake_lock_size == 5:\n                    state = STATE_PLAYING\n                else:\n                    # wake_lock_size == 2\n                    state = STATE_PAUSED\n\n            # Netflix\n            elif current_app == NETFLIX:\n                if wake_lock_size > 3:\n                    state = STATE_PLAYING\n                else:\n                    state = STATE_PAUSED\n\n            # Check if `wake_lock_size` is 1 (device is playing).\n            elif wake_lock_size == 1:\n                state = STATE_PLAYING\n\n            # Otherwise, device is paused.\n            else:\n                state = STATE_PAUSED\n\n        return state, current_app, running_apps"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef app_state(self, app):\n        if not self.available or not self.screen_on:\n            return STATE_OFF\n        if self.current_app[\"package\"] == app:\n            return STATE_ON\n        return STATE_OFF", "response": "Informs if application is running."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes and return the device state.", "response": "def state(self):\n        \"\"\"Compute and return the device state.\n\n        :returns: Device state.\n        \"\"\"\n        # Check if device is disconnected.\n        if not self.available:\n            return STATE_UNKNOWN\n        # Check if device is off.\n        if not self.screen_on:\n            return STATE_OFF\n        # Check if screen saver is on.\n        if not self.awake:\n            return STATE_IDLE\n        # Check if the launcher is active.\n        if self.launcher or self.settings:\n            return STATE_STANDBY\n        # Check for a wake lock (device is playing).\n        if self.wake_lock:\n            return STATE_PLAYING\n        # Otherwise, device is paused.\n        return STATE_PAUSED"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck whether the ADB connection is intact.", "response": "def available(self):\n        \"\"\"Check whether the ADB connection is intact.\"\"\"\n        if not self.adb_server_ip:\n            # python-adb\n            return bool(self._adb)\n\n        # pure-python-adb\n        try:\n            # make sure the server is available\n            adb_devices = self._adb_client.devices()\n\n            # make sure the device is available\n            try:\n                # case 1: the device is currently available\n                if any([self.host in dev.get_serial_no() for dev in adb_devices]):\n                    if not self._available:\n                        self._available = True\n                    return True\n\n                # case 2: the device is not currently available\n                if self._available:\n                    logging.error('ADB server is not connected to the device.')\n                    self._available = False\n                return False\n\n            except RuntimeError:\n                if self._available:\n                    logging.error('ADB device is unavailable; encountered an error when searching for device.')\n                    self._available = False\n                return False\n\n        except RuntimeError:\n            if self._available:\n                logging.error('ADB server is unavailable.')\n                self._available = False\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef running_apps(self):\n        ps = self.adb_shell(RUNNING_APPS_CMD)\n        if ps:\n            return [line.strip().rsplit(' ', 1)[-1] for line in ps.splitlines() if line.strip()]\n        return []", "response": "Return a list of running user applications."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current app.", "response": "def current_app(self):\n        \"\"\"Return the current app.\"\"\"\n        current_focus = self.adb_shell(CURRENT_APP_CMD)\n        if current_focus is None:\n            return None\n\n        current_focus = current_focus.replace(\"\\r\", \"\")\n        matches = WINDOW_REGEX.search(current_focus)\n\n        # case 1: current app was successfully found\n        if matches:\n            (pkg, activity) = matches.group(\"package\", \"activity\")\n            return {\"package\": pkg, \"activity\": activity}\n\n        # case 2: current app could not be found\n        logging.warning(\"Couldn't get current app, reply was %s\", current_focus)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wake_lock_size(self):\n        output = self.adb_shell(WAKE_LOCK_SIZE_CMD)\n        if not output:\n            return None\n        return int(output.split(\"=\")[1].strip())", "response": "Get the size of the current wake lock."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_properties(self, get_running_apps=True, lazy=False):\n        if get_running_apps:\n            output = self.adb_shell(SCREEN_ON_CMD + (SUCCESS1 if lazy else SUCCESS1_FAILURE0) + \" && \" +\n                                    AWAKE_CMD + (SUCCESS1 if lazy else SUCCESS1_FAILURE0) + \" && \" +\n                                    WAKE_LOCK_SIZE_CMD + \" && \" +\n                                    CURRENT_APP_CMD + \" && \" +\n                                    RUNNING_APPS_CMD)\n        else:\n            output = self.adb_shell(SCREEN_ON_CMD + (SUCCESS1 if lazy else SUCCESS1_FAILURE0) + \" && \" +\n                                    AWAKE_CMD + (SUCCESS1 if lazy else SUCCESS1_FAILURE0) + \" && \" +\n                                    WAKE_LOCK_SIZE_CMD + \" && \" +\n                                    CURRENT_APP_CMD)\n\n        # ADB command was unsuccessful\n        if output is None:\n            return None, None, None, None, None\n\n        # `screen_on` property\n        if not output:\n            return False, False, -1, None, None\n        screen_on = output[0] == '1'\n\n        # `awake` property\n        if len(output) < 2:\n            return screen_on, False, -1, None, None\n        awake = output[1] == '1'\n\n        lines = output.strip().splitlines()\n\n        # `wake_lock_size` property\n        if len(lines[0]) < 3:\n            return screen_on, awake, -1, None, None\n        wake_lock_size = int(lines[0].split(\"=\")[1].strip())\n\n        # `current_app` property\n        if len(lines) < 2:\n            return screen_on, awake, wake_lock_size, None, None\n\n        matches = WINDOW_REGEX.search(lines[1])\n        if matches:\n            # case 1: current app was successfully found\n            (pkg, activity) = matches.group(\"package\", \"activity\")\n            current_app = {\"package\": pkg, \"activity\": activity}\n        else:\n            # case 2: current app could not be found\n            current_app = None\n\n        # `running_apps` property\n        if not get_running_apps or len(lines) < 3:\n            return screen_on, awake, wake_lock_size, current_app, None\n\n        running_apps = [line.strip().rsplit(' ', 1)[-1] for line in lines[2:] if line.strip()]\n\n        return screen_on, awake, wake_lock_size, current_app, running_apps", "response": "Get the screen_on awake current_app and running_apps properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if device identifier is valid.", "response": "def is_valid_device_id(device_id):\n    \"\"\" Check if device identifier is valid.\n\n    A valid device identifier contains only ascii word characters or dashes.\n\n    :param device_id: Device identifier\n    :returns: Valid or not.\n    \"\"\"\n    valid = valid_device_id.match(device_id)\n    if not valid:\n        logging.error(\"A valid device identifier contains \"\n                      \"only ascii word characters or dashes. \"\n                      \"Device '%s' not added.\", device_id)\n    return valid"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a device to the list of FireTV devices.", "response": "def add(device_id, host, adbkey='', adb_server_ip='', adb_server_port=5037):\n    \"\"\" Add a device.\n\n    Creates FireTV instance associated with device identifier.\n\n    :param device_id: Device identifier.\n    :param host: Host in <address>:<port> format.\n    :param adbkey: The path to the \"adbkey\" file\n    :param adb_server_ip: the IP address for the ADB server\n    :param adb_server_port: the port for the ADB server\n    :returns: Added successfully or not.\n    \"\"\"\n    valid = is_valid_device_id(device_id) and is_valid_host(host)\n    if valid:\n        devices[device_id] = FireTV(str(host), str(adbkey), str(adb_server_ip), str(adb_server_port))\n    return valid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_device():\n    req = request.get_json()\n    success = False\n    if 'device_id' in req and 'host' in req:\n        success = add(req['device_id'], req['host'], req.get('adbkey', ''), req.get('adb_server_ip', ''), req.get('adb_server_port', 5037))\n    return jsonify(success=success)", "response": "Add a device via HTTP POST."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_devices():\n    output = {}\n    for device_id, device in devices.items():\n        output[device_id] = {\n            'host': device.host,\n            'state': device.state\n        }\n    return jsonify(devices=output)", "response": "List all devices in a node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef device_state(device_id):\n    if device_id not in devices:\n        return jsonify(success=False)\n    return jsonify(state=devices[device_id].state)", "response": "Get device state via HTTP GET."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting currently running app.", "response": "def current_app(device_id):\n    \"\"\" Get currently running app. \"\"\"\n    if not is_valid_device_id(device_id):\n        abort(403)\n    if device_id not in devices:\n        abort(404)\n\n    current = devices[device_id].current_app\n    if current is None:\n        abort(404)\n\n    return jsonify(current_app=current)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget running apps via HTTP GET.", "response": "def running_apps(device_id):\n    \"\"\" Get running apps via HTTP GET. \"\"\"\n    if not is_valid_device_id(device_id):\n        abort(403)\n    if device_id not in devices:\n        abort(404)\n    return jsonify(running_apps=devices[device_id].running_apps)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_app_state(device_id, app_id):\n    if not is_valid_app_id(app_id):\n        abort(403)\n    if not is_valid_device_id(device_id):\n        abort(403)\n    if device_id not in devices:\n        abort(404)\n    app_state = devices[device_id].app_state(app_id)\n    return jsonify(state=app_state, status=app_state)", "response": "Get the state of the requested app"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitiate device action via HTTP GET.", "response": "def device_action(device_id, action_id):\n    \"\"\" Initiate device action via HTTP GET. \"\"\"\n    success = False\n    if device_id in devices:\n        input_cmd = getattr(devices[device_id], action_id, None)\n        if callable(input_cmd):\n            input_cmd()\n            success = True\n    return jsonify(success=success)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts an app with corresponding package name", "response": "def app_start(device_id, app_id):\n    \"\"\" Starts an app with corresponding package name\"\"\"\n    if not is_valid_app_id(app_id):\n        abort(403)\n    if not is_valid_device_id(device_id):\n        abort(403)\n    if device_id not in devices:\n        abort(404)\n\n    success = devices[device_id].launch_app(app_id)\n    return jsonify(success=success)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping an app with corresponding package name", "response": "def app_stop(device_id, app_id):\n    \"\"\" stops an app with corresponding package name\"\"\"\n    if not is_valid_app_id(app_id):\n        abort(403)\n    if not is_valid_device_id(device_id):\n        abort(403)\n    if device_id not in devices:\n        abort(404)\n\n    success = devices[device_id].stop_app(app_id)\n    return jsonify(success=success)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nforces a connection attempt via HTTP GET.", "response": "def device_connect(device_id):\n    \"\"\" Force a connection attempt via HTTP GET. \"\"\"\n    success = False\n    if device_id in devices:\n        devices[device_id].connect()\n        success = True\n    return jsonify(success=success)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_config(config_file_path):\n    config_file = open(config_file_path, 'r')\n    config = yaml.load(config_file)\n    config_file.close()\n    return config", "response": "Parse Config File from yaml file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_devices_from_config(args):\n    config = _parse_config(args.config)\n    for device in config['devices']:\n        if args.default:\n            if device == \"default\":\n                raise ValueError('devicename \"default\" in config is not allowed if default param is set')\n            if config['devices'][device]['host'] == args.default:\n                raise ValueError('host set in default param must not be defined in config')\n        add(device, config['devices'][device]['host'], config['devices'][device].get('adbkey', ''),\n            config['devices'][device].get('adb_server_ip', ''), config['devices'][device].get('adb_server_port', 5037))", "response": "Add devices from config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset up the server.", "response": "def main():\n    \"\"\" Set up the server. \"\"\"\n    parser = argparse.ArgumentParser(description='AFTV Server')\n    parser.add_argument('-p', '--port', type=int, help='listen port', default=5556)\n    parser.add_argument('-d', '--default', help='default Amazon Fire TV host', nargs='?')\n    parser.add_argument('-c', '--config', type=str, help='Path to config file')\n    args = parser.parse_args()\n\n    if args.config:\n        _add_devices_from_config(args)\n\n    if args.default and not add('default', args.default):\n        exit('invalid hostname')\n    app.run(host='0.0.0.0', port=args.port)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_words(self):\n        with open(self._words_file, 'r') as f:\n            self._censor_list = [line.strip() for line in f.readlines()]", "response": "Loads the list of profane words from file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace the original censor character '*' with character.", "response": "def set_censor(self, character):\n        \"\"\"Replaces the original censor character '*' with ``character``.\"\"\"\n        # TODO: what if character isn't str()-able?\n        if isinstance(character, int):\n            character = str(character)\n        self._censor_char = character"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_profane_words(self):\n        profane_words = []\n\n        if self._custom_censor_list:\n            profane_words = [w for w in self._custom_censor_list]  # Previous versions of Python don't have list.copy()\n        else:\n            profane_words = [w for w in self._censor_list]\n\n        profane_words.extend(self._extra_censor_list)\n        profane_words.extend([inflection.pluralize(word) for word in profane_words])\n        profane_words = list(set(profane_words))\n        \n        # We sort the list based on decreasing word length so that words like\n        # 'fu' aren't substituted before 'fuck' if no_word_boundaries = true\n        profane_words.sort(key=len)\n        profane_words.reverse()\n\n        return profane_words", "response": "Returns all profane words currently in use."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef censor(self, input_text):\n        bad_words = self.get_profane_words()\n        res = input_text\n\n        for word in bad_words:\n            # Apply word boundaries to the bad word\n            regex_string = r'{0}' if self._no_word_boundaries else r'\\b{0}\\b'\n            regex_string = regex_string.format(word)  \n            regex = re.compile(regex_string, re.IGNORECASE)\n            res = regex.sub(self._censor_char * len(word), res)\n\n        return res", "response": "Returns input_text with any profane words censored."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack_multiple(data):\n        chunks = []\n        while data:\n            info = SMB2NetworkInterfaceInfo()\n            data = info.unpack(data)\n            chunks.append(info)\n\n        return chunks", "response": "Unpacks a list of SMB2NetworkInterfaceInfo messages from the byte value passed in."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_response_structure(name):\n        return {\n            CreateContextName.SMB2_CREATE_DURABLE_HANDLE_REQUEST:\n                SMB2CreateDurableHandleResponse(),\n            CreateContextName.SMB2_CREATE_DURABLE_HANDLE_RECONNECT:\n                SMB2CreateDurableHandleReconnect(),\n            CreateContextName.SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST:\n                SMB2CreateQueryMaximalAccessResponse(),\n            CreateContextName.SMB2_CREATE_REQUEST_LEASE:\n                SMB2CreateResponseLease(),\n            CreateContextName.SMB2_CREATE_QUERY_ON_DISK_ID:\n                SMB2CreateQueryOnDiskIDResponse(),\n            CreateContextName.SMB2_CREATE_REQUEST_LEASE_V2:\n                SMB2CreateResponseLeaseV2(),\n            CreateContextName.SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2:\n                SMB2CreateDurableHandleResponseV2(),\n            CreateContextName.SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2:\n                SMB2CreateDurableHandleReconnectV2,\n            CreateContextName.SMB2_CREATE_APP_INSTANCE_ID:\n                SMB2CreateAppInstanceId(),\n            CreateContextName.SMB2_CREATE_APP_INSTANCE_VERSION:\n                SMB2CreateAppInstanceVersion()\n\n        }.get(name, None)", "response": "Returns the response structure for a specific create context."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the buffer_data value of a context response and try to convert it to the relevant structure based on the buffer_name used.", "response": "def get_context_data(self):\n        \"\"\"\n        Get the buffer_data value of a context response and try to convert it\n        to the relevant structure based on the buffer_name used. If it is an\n        unknown structure then the raw bytes are returned.\n\n        :return: relevant Structure of buffer_data or bytes if unknown name\n        \"\"\"\n        buffer_name = self['buffer_name'].get_value()\n        structure = CreateContextName.get_response_structure(buffer_name)\n        if structure:\n            structure.unpack(self['buffer_data'].get_value())\n            return structure\n        else:\n            # unknown structure, just return the raw bytes\n            return self['buffer_data'].get_value()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a list of SMB2CreateEABuffer structures and packs them as a bytes object that is used when setting to the SMB2CreateContextRequest buffer_data field. This function is used to pack the contents of the SMB2CreateContextRequest buffer_data field.", "response": "def pack_multiple(messages):\n        \"\"\"\n        Converts a list of SMB2CreateEABuffer structures and packs them as a\n        bytes object used when setting to the SMB2CreateContextRequest\n        buffer_data field. This should be used as it would calculate the\n        correct next_entry_offset field value for each buffer entry.\n\n        :param messages: List of SMB2CreateEABuffer structures\n        :return: bytes object that is set on the SMB2CreateContextRequest\n            buffer_data field.\n        \"\"\"\n        data = b\"\"\n        msg_count = len(messages)\n        for i, msg in enumerate(messages):\n            if i == msg_count - 1:\n                msg['next_entry_offset'] = 0\n            else:\n                # because the end padding val won't be populated if the entry\n                # offset is 0, we set to 1 so the len calc is correct\n                msg['next_entry_offset'] = 1\n                msg['next_entry_offset'] = len(msg)\n            data += msg.pack()\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the print name and length of the message with the values passed in.", "response": "def set_name(self, print_name, substitute_name):\n        \"\"\"\n        Set's the path_buffer and print/substitute name length of the message\n        with the values passed in. These values should be a string and not a\n        byte string as it is encoded in this function.\n\n        :param print_name: The print name string to set\n        :param substitute_name: The substitute name string to set\n        \"\"\"\n        print_bytes = print_name.encode('utf-16-le')\n        sub_bytes = substitute_name.encode('utf-16-le')\n        path_buffer = print_bytes + sub_bytes\n\n        self['print_name_offset'].set_value(0)\n        self['print_name_length'].set_value(len(print_bytes))\n        self['substitute_name_offset'].set_value(len(print_bytes))\n        self['substitute_name_length'].set_value(len(sub_bytes))\n        self['path_buffer'].set_value(path_buffer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect to the tree share.", "response": "def connect(self, require_secure_negotiate=True):\n        \"\"\"\n        Connect to the share.\n\n        :param require_secure_negotiate: For Dialects 3.0 and 3.0.2, will\n            verify the negotiation parameters with the server to prevent\n            SMB downgrade attacks\n        \"\"\"\n        log.info(\"Session: %s - Creating connection to share %s\"\n                 % (self.session.username, self.share_name))\n        utf_share_name = self.share_name.encode('utf-16-le')\n        connect = SMB2TreeConnectRequest()\n        connect['buffer'] = utf_share_name\n\n        log.info(\"Session: %s - Sending Tree Connect message\"\n                 % self.session.username)\n        log.debug(str(connect))\n        request = self.session.connection.send(connect,\n                                               sid=self.session.session_id)\n\n        log.info(\"Session: %s - Receiving Tree Connect response\"\n                 % self.session.username)\n        response = self.session.connection.receive(request)\n        tree_response = SMB2TreeConnectResponse()\n        tree_response.unpack(response['data'].get_value())\n        log.debug(str(tree_response))\n\n        # https://msdn.microsoft.com/en-us/library/cc246687.aspx\n        self.tree_connect_id = response['tree_id'].get_value()\n        log.info(\"Session: %s - Created tree connection with ID %d\"\n                 % (self.session.username, self.tree_connect_id))\n        self._connected = True\n        self.session.tree_connect_table[self.tree_connect_id] = self\n\n        capabilities = tree_response['capabilities']\n        self.is_dfs_share = capabilities.has_flag(\n            ShareCapabilities.SMB2_SHARE_CAP_DFS)\n        self.is_ca_share = capabilities.has_flag(\n            ShareCapabilities.SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\n        dialect = self.session.connection.dialect\n        if dialect >= Dialects.SMB_3_0_0 and \\\n                self.session.connection.supports_encryption:\n            self.encrypt_data = tree_response['share_flags'].has_flag(\n                ShareFlags.SMB2_SHAREFLAG_ENCRYPT_DATA)\n\n            self.is_scaleout_share = capabilities.has_flag(\n                ShareCapabilities.SMB2_SHARE_CAP_SCALEOUT)\n\n            # secure negotiate is only valid for SMB 3 dialects before 3.1.1\n            if dialect < Dialects.SMB_3_1_1 and require_secure_negotiate:\n                self._verify_dialect_negotiate()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisconnecting the tree connection from the tree connection.", "response": "def disconnect(self):\n        \"\"\"\n        Disconnects the tree connection.\n        \"\"\"\n        if not self._connected:\n            return\n\n        log.info(\"Session: %s, Tree: %s - Disconnecting from Tree Connect\"\n                 % (self.session.username, self.share_name))\n\n        req = SMB2TreeDisconnect()\n        log.info(\"Session: %s, Tree: %s - Sending Tree Disconnect message\"\n                 % (self.session.username, self.share_name))\n        log.debug(str(req))\n        request = self.session.connection.send(req,\n                                               sid=self.session.session_id,\n                                               tid=self.tree_connect_id)\n\n        log.info(\"Session: %s, Tree: %s - Receiving Tree Disconnect response\"\n                 % (self.session.username, self.share_name))\n        res = self.session.connection.receive(request)\n        res_disconnect = SMB2TreeDisconnect()\n        res_disconnect.unpack(res['data'].get_value())\n        log.debug(str(res_disconnect))\n        self._connected = False\n        del self.session.tree_connect_table[self.tree_connect_id]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, dialect=None, timeout=60):\n        log.info(\"Setting up transport connection\")\n        self.transport.connect()\n\n        log.info(\"Starting negotiation with SMB server\")\n        smb_response = self._send_smb2_negotiate(dialect, timeout)\n        log.info(\"Negotiated dialect: %s\"\n                 % str(smb_response['dialect_revision']))\n        self.dialect = smb_response['dialect_revision'].get_value()\n        self.max_transact_size = smb_response['max_transact_size'].get_value()\n        self.max_read_size = smb_response['max_read_size'].get_value()\n        self.max_write_size = smb_response['max_write_size'].get_value()\n        self.server_guid = smb_response['server_guid'].get_value()\n        self.gss_negotiate_token = smb_response['buffer'].get_value()\n\n        if not self.require_signing and \\\n                smb_response['security_mode'].has_flag(\n                    SecurityMode.SMB2_NEGOTIATE_SIGNING_REQUIRED):\n            self.require_signing = True\n        log.info(\"Connection require signing: %s\" % self.require_signing)\n        capabilities = smb_response['capabilities']\n\n        # SMB 2.1\n        if self.dialect >= Dialects.SMB_2_1_0:\n            self.supports_file_leasing = \\\n                capabilities.has_flag(Capabilities.SMB2_GLOBAL_CAP_LEASING)\n            self.supports_multi_credit = \\\n                capabilities.has_flag(Capabilities.SMB2_GLOBAL_CAP_LARGE_MTU)\n\n        # SMB 3.x\n        if self.dialect >= Dialects.SMB_3_0_0:\n            self.supports_directory_leasing = capabilities.has_flag(\n                Capabilities.SMB2_GLOBAL_CAP_DIRECTORY_LEASING)\n            self.supports_multi_channel = capabilities.has_flag(\n                Capabilities.SMB2_GLOBAL_CAP_MULTI_CHANNEL)\n\n            # TODO: SMB2_GLOBAL_CAP_PERSISTENT_HANDLES\n            self.supports_persistent_handles = False\n            self.supports_encryption = capabilities.has_flag(\n                Capabilities.SMB2_GLOBAL_CAP_ENCRYPTION) \\\n                and self.dialect < Dialects.SMB_3_1_1\n            self.server_capabilities = capabilities\n            self.server_security_mode = \\\n                smb_response['security_mode'].get_value()\n\n            # TODO: Check/add server to server_list in Client Page 203\n\n        # SMB 3.1\n        if self.dialect >= Dialects.SMB_3_1_1:\n            for context in smb_response['negotiate_context_list']:\n                if context['context_type'].get_value() == \\\n                        NegotiateContextType.SMB2_ENCRYPTION_CAPABILITIES:\n                    cipher_id = context['data']['ciphers'][0]\n                    self.cipher_id = Ciphers.get_cipher(cipher_id)\n                    self.supports_encryption = self.cipher_id != 0\n                else:\n                    hash_id = context['data']['hash_algorithms'][0]\n                    self.preauth_integrity_hash_id = \\\n                        HashAlgorithms.get_algorithm(hash_id)", "response": "Connects to the server and negotiates the capabilities of the current server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef disconnect(self, close=True):\n        if close:\n            for session in list(self.session_table.values()):\n                session.disconnect(True)\n\n        log.info(\"Disconnecting transport connection\")\n        self.transport.disconnect()", "response": "Disconnects the connection to the transport and all the active session tables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_compound(self, messages, sid, tid, related=False):\n        send_data = b\"\"\n        session = self.session_table[sid]\n        tree = session.tree_connect_table[tid]\n        requests = []\n\n        total_requests = len(messages)\n        for i, message in enumerate(messages):\n            if i == total_requests - 1:\n                next_command = 0\n                padding = b\"\"\n            else:\n                msg_length = 64 + len(message)\n\n                # each compound message must start at the 8-byte boundary\n                mod = msg_length % 8\n                padding_length = 8 - mod if mod > 0 else 0\n                padding = b\"\\x00\" * padding_length\n                next_command = msg_length + padding_length\n\n            header = self._generate_packet_header(message, sid, tid, None)\n            header['next_command'] = next_command\n            if i != 0 and related:\n                header['session_id'] = b\"\\xff\" * 8\n                header['tree_id'] = b\"\\xff\" * 4\n                header['flags'].set_flag(\n                    Smb2Flags.SMB2_FLAGS_RELATED_OPERATIONS\n                )\n\n            if session.signing_required and session.signing_key:\n                self._sign(header, session, padding=padding)\n            send_data += header.pack() + padding\n\n            request = Request(header)\n            requests.append(request)\n            self.outstanding_requests[header['message_id'].get_value()] = \\\n                request\n\n        if session.encrypt_data or tree.encrypt_data:\n            send_data = self._encrypt(send_data, session)\n\n        self.transport.send(send_data)\n\n        return requests", "response": "Sends multiple messages within one TCP request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npolling the message buffer of the TCP connection and waits until a valid message is received based on the message_id passed in. :param request: The Request object to wait get the response for :param wait: Wait for the final response in the case of a STATUS_PENDING response, the pending response is returned in the case of wait=False :param timeout: Set a timeout used while waiting for a response from the server :return: SMB2HeaderResponse of the received message", "response": "def receive(self, request, wait=True, timeout=None):\n        \"\"\"\n        Polls the message buffer of the TCP connection and waits until a valid\n        message is received based on the message_id passed in.\n\n        :param request: The Request object to wait get the response for\n        :param wait: Wait for the final response in the case of a\n            STATUS_PENDING response, the pending response is returned in the\n            case of wait=False\n        :param timeout: Set a timeout used while waiting for a response from\n            the server\n        :return: SMB2HeaderResponse of the received message\n        \"\"\"\n        start_time = time.time()\n\n        # check if we have received a response\n        while True:\n            self._flush_message_buffer()\n            status = request.response['status'].get_value() if \\\n                request.response else None\n            if status is not None and (wait and\n                                       status != NtStatus.STATUS_PENDING):\n                break\n            current_time = time.time() - start_time\n            if timeout and (current_time > timeout):\n                error_msg = \"Connection timeout of %d seconds exceeded while\" \\\n                            \" waiting for a response from the server\" \\\n                            % timeout\n                raise smbprotocol.exceptions.SMBException(error_msg)\n\n        response = request.response\n        status = response['status'].get_value()\n        if status not in [NtStatus.STATUS_SUCCESS, NtStatus.STATUS_PENDING]:\n            raise smbprotocol.exceptions.SMBResponseException(response, status)\n\n        # now we have a retrieval request for the response, we can delete\n        # the request from the outstanding requests\n        message_id = request.message['message_id'].get_value()\n        del self.outstanding_requests[message_id]\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend an SMB2 Echo request to the server and return the number of credits that were granted by the server.", "response": "def echo(self, sid=0, timeout=60, credit_request=1):\n        \"\"\"\n        Sends an SMB2 Echo request to the server. This can be used to request\n        more credits from the server with the credit_request param.\n\n        On a Samba server, the sid can be 0 but for a Windows SMB Server, the\n        sid of an authenticated session must be passed into this function or\n        else the socket will close.\n\n        :param sid: When talking to a Windows host this must be populated with\n            a valid session_id from a negotiated session\n        :param timeout: The timeout in seconds to wait for the Echo Response\n        :param credit_request: The number of credits to request\n        :return: the credits that were granted by the server\n        \"\"\"\n        log.info(\"Sending Echo request with a timeout of %d and credit \"\n                 \"request of %d\" % (timeout, credit_request))\n\n        echo_msg = SMB2Echo()\n        log.debug(str(echo_msg))\n        req = self.send(echo_msg, sid=sid, credit_request=credit_request)\n\n        log.info(\"Receiving Echo response\")\n        response = self.receive(req, timeout=timeout)\n        log.info(\"Credits granted from the server echo response: %d\"\n                 % response['credit_response'].get_value())\n        echo_resp = SMB2Echo()\n        echo_resp.unpack(response['data'].get_value())\n        log.debug(str(echo_resp))\n\n        return response['credit_response'].get_value()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nloop through the transport message_buffer until there are no messages left in the queue. Each response is assigned to the Request object based on the message_id which are then available in self.outstanding_requests", "response": "def _flush_message_buffer(self):\n        \"\"\"\n        Loops through the transport message_buffer until there are no messages\n        left in the queue. Each response is assigned to the Request object\n        based on the message_id which are then available in\n        self.outstanding_requests\n        \"\"\"\n        while True:\n            message_bytes = self.transport.receive()\n\n            # there were no messages receives, so break from the loop\n            if message_bytes is None:\n                break\n\n            # check if the message is encrypted and decrypt if necessary\n            if message_bytes[:4] == b\"\\xfdSMB\":\n                message = SMB2TransformHeader()\n                message.unpack(message_bytes)\n                message_bytes = self._decrypt(message)\n\n            # now retrieve message(s) from response\n            is_last = False\n            session_id = None\n            while not is_last:\n                next_command = struct.unpack(\"<L\", message_bytes[20:24])[0]\n                header_length = \\\n                    next_command if next_command != 0 else len(message_bytes)\n                header_bytes = message_bytes[:header_length]\n                message = SMB2HeaderResponse()\n                message.unpack(header_bytes)\n\n                flags = message['flags']\n                if not flags.has_flag(Smb2Flags.SMB2_FLAGS_RELATED_OPERATIONS):\n                    session_id = message['session_id'].get_value()\n\n                self._verify(message, session_id)\n                message_id = message['message_id'].get_value()\n                request = self.outstanding_requests.get(message_id, None)\n                if not request:\n                    error_msg = \"Received response with an unknown message \" \\\n                                \"ID: %d\" % message_id\n                    raise smbprotocol.exceptions.SMBException(error_msg)\n\n                # add the upper credit limit based on the credits granted by\n                # the server\n                credit_response = message['credit_response'].get_value()\n                self.sequence_window['high'] += \\\n                    credit_response if credit_response > 0 else 1\n\n                request.response = message\n                self.outstanding_requests[message_id] = request\n\n                message_bytes = message_bytes[header_length:]\n                is_last = next_command == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the credit charge for a request based on the command.", "response": "def _calculate_credit_charge(self, message):\n        \"\"\"\n        Calculates the credit charge for a request based on the command. If\n        connection.supports_multi_credit is not True then the credit charge\n        isn't valid so it returns 0.\n\n        The credit charge is the number of credits that are required for\n        sending/receiving data over 64 kilobytes, in the existing messages only\n        the Read, Write, Query Directory or IOCTL commands will end in this\n        scenario and each require their own calculation to get the proper\n        value. The generic formula for calculating the credit charge is\n\n        https://msdn.microsoft.com/en-us/library/dn529312.aspx\n        (max(SendPayloadSize, Expected ResponsePayloadSize) - 1) / 65536 + 1\n\n        :param message: The message being sent\n        :return: The credit charge to set on the header\n        \"\"\"\n        credit_size = 65536\n\n        if not self.supports_multi_credit:\n            credit_charge = 0\n        elif message.COMMAND == Commands.SMB2_READ:\n            max_size = message['length'].get_value() + \\\n                       message['read_channel_info_length'].get_value() - 1\n            credit_charge = math.ceil(max_size / credit_size)\n        elif message.COMMAND == Commands.SMB2_WRITE:\n            max_size = message['length'].get_value() + \\\n                       message['write_channel_info_length'].get_value() - 1\n            credit_charge = math.ceil(max_size / credit_size)\n        elif message.COMMAND == Commands.SMB2_IOCTL:\n            max_in_size = len(message['buffer'])\n            max_out_size = message['max_output_response'].get_value()\n            max_size = max(max_in_size, max_out_size) - 1\n            credit_charge = math.ceil(max_size / credit_size)\n        elif message.COMMAND == Commands.SMB2_QUERY_DIRECTORY:\n            max_in_size = len(message['buffer'])\n            max_out_size = message['output_buffer_length'].get_value()\n            max_size = max(max_in_size, max_out_size) - 1\n            credit_charge = math.ceil(max_size / credit_size)\n        else:\n            credit_charge = 1\n\n        # python 2 returns a float where we need an integer\n        return int(credit_charge)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disconnect(self, close=True):\n        if not self._connected:\n            # already disconnected so let's return\n            return\n\n        if close:\n            for open in list(self.open_table.values()):\n                open.close(False)\n\n            for tree in list(self.tree_connect_table.values()):\n                tree.disconnect()\n\n        log.info(\"Session: %s - Logging off of SMB Session\" % self.username)\n        logoff = SMB2Logoff()\n        log.info(\"Session: %s - Sending Logoff message\" % self.username)\n        log.debug(str(logoff))\n        request = self.connection.send(logoff, sid=self.session_id)\n\n        log.info(\"Session: %s - Receiving Logoff response\" % self.username)\n        res = self.connection.receive(request)\n        res_logoff = SMB2Logoff()\n        res_logoff.unpack(res['data'].get_value())\n        log.debug(str(res_logoff))\n        self._connected = False\n        del self.connection.session_table[self.session_id]", "response": "Logs off the session and closes all open and tree - connect tables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _smb3kdf(self, ki, label, context):\n        kdf = KBKDFHMAC(\n            algorithm=hashes.SHA256(),\n            mode=Mode.CounterMode,\n            length=16,\n            rlen=4,\n            llen=4,\n            location=CounterLocation.BeforeFixed,\n            label=label,\n            context=context,\n            fixed=None,\n            backend=default_backend()\n        )\n        return kdf.derive(ki)", "response": "Derive the session key from the SMB 3. x key derivation function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npacking the value into a byte string so it can be sent to the server.", "response": "def pack(self):\n        \"\"\"\n        Packs the field value into a byte string so it can be sent to the\n        server.\n\n        :param structure: The message structure class object\n        :return: A byte string of the packed field's value\n        \"\"\"\n        value = self._get_calculated_value(self.value)\n        packed_value = self._pack_value(value)\n        size = self._get_calculated_size(self.size, packed_value)\n        if len(packed_value) != size:\n            raise ValueError(\"Invalid packed data length for field %s of %d \"\n                             \"does not fit field size of %d\"\n                             % (self.name, len(packed_value), size))\n\n        return packed_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse and sets the value attribute for the field.", "response": "def set_value(self, value):\n        \"\"\"\n        Parses, and sets the value attribute for the field.\n\n        :param value: The value to be parsed and set, the allowed input types\n            vary depending on the Field used\n        \"\"\"\n        parsed_value = self._parse_value(value)\n        self.value = parsed_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes in a byte string and sets the value based on the field s definition.", "response": "def unpack(self, data):\n        \"\"\"\n        Takes in a byte string and set's the field value based on field\n        definition.\n\n        :param structure: The message structure class object\n        :param data: The byte string of the data to unpack\n        :return: The remaining data for subsequent fields\n        \"\"\"\n        size = self._get_calculated_size(self.size, data)\n        self.set_value(data[0:size])\n        return data[len(self):]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the final value of the field and runs the lambda functions recursively until a final value is derived.", "response": "def _get_calculated_value(self, value):\n        \"\"\"\n        Get's the final value of the field and runs the lambda functions\n        recursively until a final value is derived.\n\n        :param value: The value to calculate/expand\n        :return: The final value\n        \"\"\"\n        if isinstance(value, types.LambdaType):\n            expanded_value = value(self.structure)\n            return self._get_calculated_value(expanded_value)\n        else:\n            # perform one final parsing of the value in case lambda value\n            # returned a different type\n            return self._parse_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_calculated_size(self, size, data):\n        # if the size is derived from a lambda function, run it now; otherwise\n        # return the value we passed in or the length of the data if the size\n        # is None (last field value)\n        if size is None:\n            return len(data)\n        elif isinstance(size, types.LambdaType):\n            expanded_size = size(self.structure)\n            return self._get_calculated_size(expanded_size, data)\n        else:\n            return size", "response": "Get the final size of the field and runs the lambda functions\n        recursively until a final size is found."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_struct_format(self, size):\n        if isinstance(size, types.LambdaType):\n            size = size(self.structure)\n\n        struct_format = {\n            1: 'B',\n            2: 'H',\n            4: 'L',\n            8: 'Q'\n        }\n        if size not in struct_format.keys():\n            raise InvalidFieldDefinition(\"Cannot struct format of size %s\"\n                                         % size)\n        return struct_format[size]", "response": "Get s the format specifier for use in struct."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack_response(file_information_class, buffer):\n        structs = smbprotocol.query_info\n        resp_structure = {\n            FileInformationClass.FILE_DIRECTORY_INFORMATION:\n                structs.FileDirectoryInformation,\n            FileInformationClass.FILE_NAMES_INFORMATION:\n                structs.FileNamesInformation,\n            FileInformationClass.FILE_BOTH_DIRECTORY_INFORMATION:\n                structs.FileBothDirectoryInformation,\n            FileInformationClass.FILE_ID_BOTH_DIRECTORY_INFORMATION:\n                structs.FileIdBothDirectoryInformation,\n            FileInformationClass.FILE_FULL_DIRECTORY_INFORMATION:\n                structs.FileFullDirectoryInformation,\n            FileInformationClass.FILE_ID_FULL_DIRECTORY_INFORMATION:\n                structs.FileIdFullDirectoryInformation,\n        }[file_information_class]\n        query_results = []\n\n        current_offset = 0\n        is_next = True\n        while is_next:\n            result = resp_structure()\n            result.unpack(buffer[current_offset:])\n            query_results.append(result)\n            current_offset += result['next_entry_offset'].get_value()\n            is_next = result['next_entry_offset'].get_value() != 0\n\n        return query_results", "response": "Unpacks the SMB2QueryDirectoryResponse object into a list of query_info. structures."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, impersonation_level, desired_access, file_attributes,\n               share_access, create_disposition, create_options,\n               create_contexts=None, send=True):\n        \"\"\"\n        This will open the file based on the input parameters supplied. Any\n        file open should also be called with Open.close() when it is finished.\n\n        More details on how each option affects the open process can be found\n        here https://msdn.microsoft.com/en-us/library/cc246502.aspx.\n\n        Supports out of band send function, call this function with send=False\n        to return a tuple of (SMB2CreateRequest, receive_func) instead of\n        sending the the request and waiting for the response. The receive_func\n        can be used to get the response from the server by passing in the\n        Request that was used to sent it out of band.\n\n        :param impersonation_level: (ImpersonationLevel) The type of\n            impersonation level that is issuing the create request.\n        :param desired_access: The level of access that is required of the\n            open. FilePipePrinterAccessMask or DirectoryAccessMask should be\n            used depending on the type of file being opened.\n        :param file_attributes: (FileAttributes) attributes to set on the file\n            being opened, this usually is for opens that creates a file.\n        :param share_access: (ShareAccess) Specifies the sharing mode for the\n            open.\n        :param create_disposition: (CreateDisposition) Defines the action the\n            server MUST take if the file already exists.\n        :param create_options: (CreateOptions) Specifies the options to be\n            applied when creating or opening the file.\n        :param create_contexts: (List<SMB2CreateContextRequest>) List of\n            context request values to be applied to the create.\n\n        Create Contexts are used to encode additional flags and attributes when\n        opening files. More details on create context request values can be\n        found here https://msdn.microsoft.com/en-us/library/cc246504.aspx.\n\n        :param send: Whether to send the request in the same call or return the\n            message to the caller and the unpack function\n\n        :return: List of context response values or None if there are no\n            context response values. If the context response value is not known\n            to smbprotocol then the list value would be raw bytes otherwise\n            it is a Structure defined in create_contexts.py\n        \"\"\"\n        create = SMB2CreateRequest()\n        create['impersonation_level'] = impersonation_level\n        create['desired_access'] = desired_access\n        create['file_attributes'] = file_attributes\n        create['share_access'] = share_access\n        create['create_disposition'] = create_disposition\n        create['create_options'] = create_options\n        if self.file_name == \"\":\n            create['buffer_path'] = b\"\\x00\\x00\"\n        else:\n            create['buffer_path'] = self.file_name.encode('utf-16-le')\n        if create_contexts:\n            create['buffer_contexts'] = smbprotocol.create_contexts.\\\n                SMB2CreateContextRequest.pack_multiple(create_contexts)\n\n        if self.connection.dialect >= Dialects.SMB_3_0_0:\n            self.desired_access = desired_access\n            self.share_mode = share_access\n            self.create_options = create_options\n            self.file_attributes = file_attributes\n            self.create_disposition = create_disposition\n\n        if not send:\n            return create, self._create_response\n\n        log.info(\"Session: %s, Tree Connect: %s - sending SMB2 Create Request \"\n                 \"for file %s\" % (self.tree_connect.session.username,\n                                  self.tree_connect.share_name,\n                                  self.file_name))\n\n        log.debug(str(create))\n        request = self.connection.send(create,\n                                       self.tree_connect.session.session_id,\n                                       self.tree_connect.tree_connect_id)\n        return self._create_response(request)", "response": "This method creates an Any ArcGIS file and returns a tuple of SMB2CreateRequest and SMB2CreateResponse."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, offset, length, min_length=0, unbuffered=False, wait=True,\n             send=True):\n        \"\"\"\n        Reads from an opened file or pipe\n\n        Supports out of band send function, call this function with send=False\n        to return a tuple of (SMB2ReadRequest, receive_func) instead of\n        sending the the request and waiting for the response. The receive_func\n        can be used to get the response from the server by passing in the\n        Request that was used to sent it out of band.\n\n        :param offset: The offset to start the read of the file.\n        :param length: The number of bytes to read from the offset.\n        :param min_length: The minimum number of bytes to be read for a\n            successful operation.\n        :param unbuffered: Whether to the server should cache the read data at\n            intermediate layers, only value for SMB 3.0.2 or newer\n        :param wait: If send=True, whether to wait for a response if\n            STATUS_PENDING was received from the server or fail.\n        :param send: Whether to send the request in the same call or return the\n            message to the caller and the unpack function\n        :return: A byte string of the bytes read\n        \"\"\"\n        if length > self.connection.max_read_size:\n            raise SMBException(\"The requested read length %d is greater than \"\n                               \"the maximum negotiated read size %d\"\n                               % (length, self.connection.max_read_size))\n\n        read = SMB2ReadRequest()\n        read['length'] = length\n        read['offset'] = offset\n        read['minimum_count'] = min_length\n        read['file_id'] = self.file_id\n        read['padding'] = b\"\\x50\"\n\n        if unbuffered:\n            if self.connection.dialect < Dialects.SMB_3_0_2:\n                raise SMBUnsupportedFeature(self.connection.dialect,\n                                            Dialects.SMB_3_0_2,\n                                            \"SMB2_READFLAG_READ_UNBUFFERED\",\n                                            True)\n            read['flags'].set_flag(ReadFlags.SMB2_READFLAG_READ_UNBUFFERED)\n\n        if not send:\n            return read, self._read_response\n\n        log.info(\"Session: %s, Tree Connect ID: %s - sending SMB2 Read \"\n                 \"Request for file %s\" % (self.tree_connect.session.username,\n                                          self.tree_connect.share_name,\n                                          self.file_name))\n        log.debug(str(read))\n        request = self.connection.send(read,\n                                       self.tree_connect.session.session_id,\n                                       self.tree_connect.tree_connect_id)\n        return self._read_response(request, wait)", "response": "Reads from an opened file or pipe and returns a byte string containing the read data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, data, offset=0, write_through=False, unbuffered=False,\n              wait=True, send=True):\n        \"\"\"\n        Writes data to an opened file.\n\n        Supports out of band send function, call this function with send=False\n        to return a tuple of (SMBWriteRequest, receive_func) instead of\n        sending the the request and waiting for the response. The receive_func\n        can be used to get the response from the server by passing in the\n        Request that was used to sent it out of band.\n\n        :param data: The bytes data to write.\n        :param offset: The offset in the file to write the bytes at\n        :param write_through: Whether written data is persisted to the\n            underlying storage, not valid for SMB 2.0.2.\n        :param unbuffered: Whether to the server should cache the write data at\n            intermediate layers, only value for SMB 3.0.2 or newer\n        :param wait: If send=True, whether to wait for a response if\n            STATUS_PENDING was received from the server or fail.\n        :param send: Whether to send the request in the same call or return the\n            message to the caller and the unpack function\n        :return: The number of bytes written\n        \"\"\"\n        data_len = len(data)\n        if data_len > self.connection.max_write_size:\n            raise SMBException(\"The requested write length %d is greater than \"\n                               \"the maximum negotiated write size %d\"\n                               % (data_len, self.connection.max_write_size))\n\n        write = SMB2WriteRequest()\n        write['length'] = len(data)\n        write['offset'] = offset\n        write['file_id'] = self.file_id\n        write['buffer'] = data\n\n        if write_through:\n            if self.connection.dialect < Dialects.SMB_2_1_0:\n                raise SMBUnsupportedFeature(self.connection.dialect,\n                                            Dialects.SMB_2_1_0,\n                                            \"SMB2_WRITEFLAG_WRITE_THROUGH\",\n                                            True)\n            write['flags'].set_flag(WriteFlags.SMB2_WRITEFLAG_WRITE_THROUGH)\n\n        if unbuffered:\n            if self.connection.dialect < Dialects.SMB_3_0_2:\n                raise SMBUnsupportedFeature(self.connection.dialect,\n                                            Dialects.SMB_3_0_2,\n                                            \"SMB2_WRITEFLAG_WRITE_UNBUFFERED\",\n                                            True)\n            write['flags'].set_flag(WriteFlags.SMB2_WRITEFLAG_WRITE_UNBUFFERED)\n\n        if not send:\n            return write, self._write_response\n\n        log.info(\"Session: %s, Tree Connect: %s - sending SMB2 Write Request \"\n                 \"for file %s\" % (self.tree_connect.session.username,\n                                  self.tree_connect.share_name,\n                                  self.file_name))\n        log.debug(str(write))\n        request = self.connection.send(write,\n                                       self.tree_connect.session.session_id,\n                                       self.tree_connect.tree_connect_id)\n        return self._write_response(request, wait)", "response": "Writes data to an opened file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a SMB2FlushRequest to the server to flush all cached file information for the opened file.", "response": "def flush(self, send=True):\n        \"\"\"\n        A command sent by the client to request that a server flush all cached\n        file information for the opened file.\n\n        Supports out of band send function, call this function with send=False\n        to return a tuple of (SMB2FlushRequest, receive_func) instead of\n        sending the the request and waiting for the response. The receive_func\n        can be used to get the response from the server by passing in the\n        Request that was used to sent it out of band.\n\n        :param send: Whether to send the request in the same call or return the\n            message to the caller and the unpack function\n        :return: The SMB2FlushResponse received from the server\n        \"\"\"\n        flush = SMB2FlushRequest()\n        flush['file_id'] = self.file_id\n\n        if not send:\n            return flush, self._flush_response\n\n        log.info(\"Session: %s, Tree Connect: %s - sending SMB2 Flush Request \"\n                 \"for file %s\" % (self.tree_connect.session.username,\n                                  self.tree_connect.share_name,\n                                  self.file_name))\n        log.debug(str(flush))\n        request = self.connection.send(flush,\n                                       self.tree_connect.session.session_id,\n                                       self.tree_connect.tree_connect_id)\n        return self._flush_response(request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclosing an opened file.", "response": "def close(self, get_attributes=False, send=True):\n        \"\"\"\n        Closes an opened file.\n\n        Supports out of band send function, call this function with send=False\n        to return a tuple of (SMB2CloseRequest, receive_func) instead of\n        sending the the request and waiting for the response. The receive_func\n        can be used to get the response from the server by passing in the\n        Request that was used to sent it out of band.\n\n        :param get_attributes: (Bool) whether to get the latest attributes on\n            the close and set them on the Open object\n        :param send: Whether to send the request in the same call or return the\n            message to the caller and the unpack function\n        :return: SMB2CloseResponse message received from the server\n        \"\"\"\n        # it is already closed and this isn't for an out of band request\n        if not self._connected and send:\n            return\n\n        close = SMB2CloseRequest()\n\n        close['file_id'] = self.file_id\n        if get_attributes:\n            close['flags'] = CloseFlags.SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB\n\n        if not send:\n            return close, self._close_response\n\n        log.info(\"Session: %s, Tree Connect: %s - sending SMB2 Close Request \"\n                 \"for file %s\" % (self.tree_connect.session.username,\n                                  self.tree_connect.share_name,\n                                  self.file_name))\n        log.debug(str(close))\n        request = self.connection.send(close,\n                                       self.tree_connect.session.session_id,\n                                       self.tree_connect.tree_connect_id)\n        return self._close_response(request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing to set the structure parameters based on the input string :param sid_string: String of the sid in S-x-x-x-x form", "response": "def from_string(self, sid_string):\n        \"\"\"\n        Used to set the structure parameters based on the input string\n\n        :param sid_string: String of the sid in S-x-x-x-x form\n        \"\"\"\n        if not sid_string.startswith(\"S-\"):\n            raise ValueError(\"A SID string must start with S-\")\n\n        sid_entries = sid_string.split(\"-\")\n        if len(sid_entries) < 3:\n            raise ValueError(\"A SID string must start with S and contain a \"\n                             \"revision and identifier authority, e.g. S-1-0\")\n\n        revision = int(sid_entries[1])\n        id_authority = int(sid_entries[2])\n        sub_authorities = [int(i) for i in sid_entries[3:]]\n\n        self['revision'].set_value(revision)\n        self['identifier_authority'].set_value(id_authority)\n        self['sub_authorities'] = sub_authorities"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef poll(self):\n        if not self.status[\"done\"]:\n            r = Request(\"get\", self.url + \".json\", {\"token\": self.payload[\"token\"]})\n            for param, when in MessageRequest.params.iteritems():\n                self.status[param] = bool(r.answer[param])\n                self.status[when] = int(r.answer[when])\n            for param in [\"acknowledged_by\", \"acknowledged_by_device\"]:\n                self.status[param] = r.answer[param]\n            self.status[\"last_delivered_at\"] = int(r.answer[\"last_delivered_at\"])\n            if any(self.status[param] for param in MessageRequest.params):\n                self.status[\"done\"] = True\n        return self.status[\"done\"]", "response": "This method is used to poll the status of the current message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sounds(self):\n        if not Pushover._SOUNDS:\n            request = Request(\"get\", SOUND_URL, {\"token\": self.token})\n            Pushover._SOUNDS = request.answer[\"sounds\"]\n        return Pushover._SOUNDS", "response": "Return a dictionary of sounds recognized by Pushover and that can be\n        used in a notification message."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to the user specified by user.", "response": "def message(self, user, message, **kwargs):\n        \"\"\"Send `message` to the user specified by `user`. It is possible\n        to specify additional properties of the message by passing keyword\n        arguments. The list of valid keywords is ``title, priority, sound,\n        callback, timestamp, url, url_title, device, retry, expire and html``\n        which are described in the Pushover API documentation.\n\n        For convenience, you can simply set ``timestamp=True`` to set the\n        timestamp to the current timestamp.\n\n        An image can be attached to a message by passing a file-like object\n        to the `attachment` keyword argument.\n\n        This method returns a :class:`MessageRequest` object.\n        \"\"\"\n\n        payload = {\"message\": message, \"user\": user, \"token\": self.token}\n        for key, value in kwargs.iteritems():\n            if key not in Pushover.message_keywords:\n                raise ValueError(\"{0}: invalid message parameter\".format(key))\n            elif key == \"timestamp\" and value is True:\n                payload[key] = int(time.time())\n            elif key == \"sound\" and value not in self.sounds:\n                raise ValueError(\"{0}: invalid sound\".format(value))\n            else:\n                payload[key] = value\n\n        return MessageRequest(payload)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a glance to the user.", "response": "def glance(self, user, **kwargs):\n        \"\"\"Send a glance to the user. The default property is ``text``, as this\n        is used on most glances, however a valid glance does not need to\n        require text and can be constructed using any combination of valid\n        keyword properties. The list of valid keywords is ``title, text,\n        subtext, count, percent and device`` which are  described in the\n        Pushover Glance API documentation.\n\n        This method returns a :class:`GlanceRequest` object.\n        \"\"\"\n        payload = {\"user\": user, \"token\": self.token}\n\n        for key, value in kwargs.iteritems():\n            if key not in Pushover.glance_keywords:\n                raise ValueError(\"{0}: invalid glance parameter\".format(key))\n            else:\n                payload[key] = value\n\n        return Request(\"post\", GLANCE_URL, payload)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mswe(w, v):\n    # Ensure inputs are numpy arrays\n    w = np.array(w)\n    v = np.array(v)\n    # Check dimensions\n    if(len(w.shape) != 2):\n        raise TypeError('Estimated coefficients must be in NxM matrix')\n    if(len(v.shape) != 1):\n        raise TypeError('Real coefficients must be in 1d array')\n    # Ensure equal length between estimated and real coeffs\n    N, M = w.shape\n    L = v.size\n    if(M < L):\n        v = v[:-(L-M)]\n    elif(M > L):\n        v = np.concatenate((v, np.zeros(M-L)))\n\n    # Calculate and return MSWE\n    mswe = np.mean((w - v)**2, axis=1)\n    return mswe", "response": "Calculates the mean squared weight error between estimated and true filter coefficients in respect to iterations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform normalized least-mean-squares (NLMS) adaptive filtering on u to minimize error given by e=d-y, where y is the output of the adaptive filter. Parameters ---------- u : array-like One-dimensional filter input. d : array-like One-dimensional desired signal, i.e., the output of the unknown FIR system which the adaptive filter should identify. Must have length >= len(u), or N+M-1 if number of iterations are limited (via the N parameter). M : int Desired number of filter taps (desired filter order + 1), must be non-negative. step : float Step size of the algorithm, must be non-negative. Optional Parameters ------------------- eps : float Regularization factor to avoid numerical issues when power of input is close to zero. Defaults to 0.001. Must be non-negative. leak : float Leakage factor, must be equal to or greater than zero and smaller than one. When greater than zero a leaky LMS filter is used. Defaults to 0, i.e., no leakage. initCoeffs : array-like Initial filter coefficients to use. Should match desired number of filter taps, defaults to zeros. N : int Number of iterations to run. Must be less than or equal to len(u)-M+1. Defaults to len(u)-M+1. returnCoeffs : boolean If true, will return all filter coefficients for every iteration in an N x M matrix. Does not include the initial coefficients. If false, only the latest coefficients in a vector of length M is returned. Defaults to false. Returns ------- y : numpy.array Output values of LMS filter, array of length N. e : numpy.array Error signal, i.e, d-y. Array of length N. w : numpy.array Final filter coefficients in array of length M if returnCoeffs is False. NxM array containing all filter coefficients for all iterations otherwise. Raises ------ TypeError If number of filter taps M is not type integer, number of iterations N is not type integer, or leakage leak is not type float/int. ValueError If number of iterations N is greater than len(u)-M, number of filter taps M is negative, or if step-size or leakage is outside specified range. Minimal Working Example ----------------------- >>> import numpy as np >>> >>> np.random.seed(1337) >>> ulen = 2000 >>> coeff = np.concatenate(([4], np.zeros(10), [-11], np.zeros(7), [0.7])) >>> u = np.random.randn(ulen) >>> d = np.convolve(u, coeff) >>> >>> M = 20 # No. of taps >>> step = 1 # Step size >>> y, e, w = nlms(u, d, M, step) >>> print np.allclose(w, coeff) True Extended Example ---------------- >>> import numpy as np >>> >>> np.random.seed(1337) >>> N = 1000 >>> coeffs = np.concatenate(([13], np.zeros(9), [-3], np.zeros(8), [-.2])) >>> u = np.random.randn(20000) # Note len(u) >> N but we limit iterations >>> d = np.convolve(u, coeffs) >>> >>> M = 20 # No. of taps >>> step = 1 # Step size >>> y, e, w = nlms(u, d, M, step, N=N, returnCoeffs=True) >>> y.shape == (N,) True >>> e.shape == (N,) True >>> w.shape == (N, M) True >>> # Calculate mean square weight error >>> mswe = np.mean((w - coeffs)**2, axis=1) >>> # Should never increase so diff should above be > 0 >>> diff = np.diff(mswe) >>> (diff <= 1e-10).all() True", "response": "def nlms(u, d, M, step, eps=0.001, leak=0, initCoeffs=None, N=None,\n         returnCoeffs=False):\n    \"\"\"\n    Perform normalized least-mean-squares (NLMS) adaptive filtering on u to\n    minimize error given by e=d-y, where y is the output of the adaptive\n    filter.\n\n    Parameters\n    ----------\n    u : array-like\n        One-dimensional filter input.\n    d : array-like\n        One-dimensional desired signal, i.e., the output of the unknown FIR\n        system which the adaptive filter should identify. Must have length >=\n        len(u), or N+M-1 if number of iterations are limited (via the N\n        parameter).\n    M : int\n        Desired number of filter taps (desired filter order + 1), must be\n        non-negative.\n    step : float\n        Step size of the algorithm, must be non-negative.\n\n    Optional Parameters\n    -------------------\n    eps : float\n        Regularization factor to avoid numerical issues when power of input\n        is close to zero. Defaults to 0.001. Must be non-negative.\n    leak : float\n        Leakage factor, must be equal to or greater than zero and smaller than\n        one. When greater than zero a leaky LMS filter is used. Defaults to 0,\n        i.e., no leakage.\n    initCoeffs : array-like\n        Initial filter coefficients to use. Should match desired number of\n        filter taps, defaults to zeros.\n    N : int\n        Number of iterations to run. Must be less than or equal to len(u)-M+1.\n        Defaults to len(u)-M+1.\n    returnCoeffs : boolean\n        If true, will return all filter coefficients for every iteration in an\n        N x M matrix. Does not include the initial coefficients. If false, only\n        the latest coefficients in a vector of length M is returned. Defaults\n        to false.\n\n    Returns\n    -------\n    y : numpy.array\n        Output values of LMS filter, array of length N.\n    e : numpy.array\n        Error signal, i.e, d-y. Array of length N.\n    w : numpy.array\n        Final filter coefficients in array of length M if returnCoeffs is\n        False. NxM array containing all filter coefficients for all iterations\n        otherwise.\n\n    Raises\n    ------\n    TypeError\n        If number of filter taps M is not type integer, number of iterations N\n        is not type integer, or leakage leak is not type float/int.\n    ValueError\n        If number of iterations N is greater than len(u)-M, number of filter\n        taps M is negative, or if step-size or leakage is outside specified\n        range.\n\n    Minimal Working Example\n    -----------------------\n    >>> import numpy as np\n    >>>\n    >>> np.random.seed(1337)\n    >>> ulen = 2000\n    >>> coeff = np.concatenate(([4], np.zeros(10), [-11], np.zeros(7), [0.7]))\n    >>> u = np.random.randn(ulen)\n    >>> d = np.convolve(u, coeff)\n    >>>\n    >>> M = 20  # No. of taps\n    >>> step = 1  # Step size\n    >>> y, e, w = nlms(u, d, M, step)\n    >>> print np.allclose(w, coeff)\n    True\n\n    Extended Example\n    ----------------\n    >>> import numpy as np\n    >>>\n    >>> np.random.seed(1337)\n    >>> N = 1000\n    >>> coeffs = np.concatenate(([13], np.zeros(9), [-3], np.zeros(8), [-.2]))\n    >>> u = np.random.randn(20000)  # Note len(u) >> N but we limit iterations\n    >>> d = np.convolve(u, coeffs)\n    >>>\n    >>> M = 20  # No. of taps\n    >>> step = 1  # Step size\n    >>> y, e, w = nlms(u, d, M, step, N=N, returnCoeffs=True)\n    >>> y.shape == (N,)\n    True\n    >>> e.shape == (N,)\n    True\n    >>> w.shape == (N, M)\n    True\n    >>> # Calculate mean square weight error\n    >>> mswe = np.mean((w - coeffs)**2, axis=1)\n    >>> # Should never increase so diff should above be > 0\n    >>> diff = np.diff(mswe)\n    >>> (diff <= 1e-10).all()\n    True\n    \"\"\"\n    # Check epsilon\n    _pchk.checkRegFactor(eps)\n    # Num taps check\n    _pchk.checkNumTaps(M)\n    # Max iteration check\n    if N is None:\n        N = len(u)-M+1\n    _pchk.checkIter(N, len(u)-M+1)\n    # Check len(d)\n    _pchk.checkDesiredSignal(d, N, M)\n    # Step check\n    _pchk.checkStep(step)\n    # Leakage check\n    _pchk.checkLeakage(leak)\n    # Init. coeffs check\n    if initCoeffs is None:\n        initCoeffs = np.zeros(M)\n    else:\n        _pchk.checkInitCoeffs(initCoeffs, M)\n\n    # Initialization\n    y = np.zeros(N)  # Filter output\n    e = np.zeros(N)  # Error signal\n    w = initCoeffs  # Initial filter coeffs\n    leakstep = (1 - step*leak)\n    if returnCoeffs:\n        W = np.zeros((N, M))  # Matrix to hold coeffs for each iteration\n\n    # Perform filtering\n    for n in xrange(N):\n        x = np.flipud(u[n:n+M])  # Slice to get view of M latest datapoints\n        y[n] = np.dot(x, w)\n        e[n] = d[n+M-1] - y[n]\n\n        normFactor = 1./(np.dot(x, x) + eps)\n        w = leakstep * w + step * normFactor * x * e[n]\n        y[n] = np.dot(x, w)\n        if returnCoeffs:\n            W[n] = w\n\n    if returnCoeffs:\n        w = W\n\n    return y, e, w"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ap(u, d, M, step, K, eps=0.001, leak=0, initCoeffs=None, N=None,\n       returnCoeffs=False):\n    \"\"\"\n    Perform affine projection (AP) adaptive filtering on u to minimize error\n    given by e=d-y, where y is the output of the adaptive filter.\n\n    Parameters\n    ----------\n    u : array-like\n        One-dimensional filter input.\n    d : array-like\n        One-dimensional desired signal, i.e., the output of the unknown FIR\n        system which the adaptive filter should identify. Must have length >=\n        len(u), or N+M-1 if number of iterations are limited (via the N\n        parameter).\n    M : int\n        Desired number of filter taps (desired filter order + 1), must be\n        non-negative.\n    step : float\n        Step size of the algorithm, must be non-negative.\n    K : int\n        Projection order, must be integer larger than zero.\n\n    Optional Parameters\n    -------------------\n    eps : float\n        Regularization factor to avoid numerical issues when power of input\n        is close to zero. Defaults to 0.001. Must be non-negative.\n    leak : float\n        Leakage factor, must be equal to or greater than zero and smaller than\n        one. When greater than zero a leaky LMS filter is used. Defaults to 0,\n        i.e., no leakage.\n    initCoeffs : array-like\n        Initial filter coefficients to use. Should match desired number of\n        filter taps, defaults to zeros.\n    N : int\n        Number of iterations to run. Must be less than or equal to len(u)-M+1.\n        Defaults to len(u)-M+1.\n    returnCoeffs : boolean\n        If true, will return all filter coefficients for every iteration in an\n        N x M matrix. Does not include the initial coefficients. If false, only\n        the latest coefficients in a vector of length M is returned. Defaults\n        to false.\n\n    Returns\n    -------\n    y : numpy.array\n        Output values of LMS filter, array of length N.\n    e : numpy.array\n        Error signal, i.e, d-y. Array of length N.\n    w : numpy.array\n        Final filter coefficients in array of length M if returnCoeffs is\n        False. NxM array containing all filter coefficients for all iterations\n        otherwise.\n\n    Raises\n    ------\n    TypeError\n        If number of filter taps M is not type integer, number of iterations N\n        is not type integer, or leakage leak is not type float/int.\n    ValueError\n        If number of iterations N is greater than len(u)-M, number of filter\n        taps M is negative, or if step-size or leakage is outside specified\n        range.\n\n    Minimal Working Example\n    -----------------------\n    >>> import numpy as np\n    >>>\n    >>> np.random.seed(1337)\n    >>> ulen = 2000\n    >>> coeff = np.concatenate(([4], np.zeros(10), [-11], np.zeros(7), [0.7]))\n    >>> u = np.random.randn(ulen)\n    >>> d = np.convolve(u, coeff)\n    >>>\n    >>> M = 20  # No. of taps\n    >>> step = 1  # Step size\n    >>> K = 5  # Projection order\n    >>> y, e, w = ap(u, d, M, step, K)\n    >>> print np.allclose(w, coeff)\n    True\n\n    Extended Example\n    ----------------\n    >>> import numpy as np\n    >>>\n    >>> np.random.seed(1337)\n    >>> N = 1000\n    >>> coeffs = np.concatenate(([13], np.zeros(9), [-3], np.zeros(8), [-.2]))\n    >>> u = np.random.randn(20000)  # Note: len(u) >> N but we limit iterations\n    >>> d = np.convolve(u, coeffs)\n    >>>\n    >>> M = 20  # No. of taps\n    >>> step = 1  # Step size\n    >>> K = 5  # Projection order\n    >>> y, e, w = ap(u, d, M, step, K, N=N, returnCoeffs=True)\n    >>> y.shape == (N,)\n    True\n    >>> e.shape == (N,)\n    True\n    >>> w.shape == (N, M)\n    True\n    >>> # Calculate mean square weight error\n    >>> mswe = np.mean((w - coeffs)**2, axis=1)\n    >>> # Should never increase so diff should above be > 0\n    >>> diff = np.diff(mswe)\n    >>> (diff <= 1e-10).all()\n    True\n    \"\"\"\n    # Check epsilon\n    _pchk.checkRegFactor(eps)\n    # Check projection order\n    _pchk.checkProjectOrder(K)\n    # Num taps check\n    _pchk.checkNumTaps(M)\n    # Max iteration check\n    if N is None:\n        N = len(u)-M-K+1\n    _pchk.checkIter(N, len(u)-M+1)\n    # Check len(d)\n    _pchk.checkDesiredSignal(d, N, M)\n    # Step check\n    _pchk.checkStep(step)\n    # Leakage check\n    _pchk.checkLeakage(leak)\n    # Init. coeffs check\n    if initCoeffs is None:\n        initCoeffs = np.zeros(M)\n    else:\n        _pchk.checkInitCoeffs(initCoeffs, M)\n\n    # Initialization\n    y_out = np.zeros(N)  # Filter output\n    e_out = np.zeros(N)  # Error signal\n    w = initCoeffs  # Initial filter coeffs\n    I = np.identity(K)  # Init. identity matrix for faster loop matrix inv.\n    epsI = eps * np.identity(K)  # Init. epsilon identiy matrix\n    leakstep = (1 - step*leak)\n\n    if returnCoeffs:\n        W = np.zeros((N, M))  # Matrix to hold coeffs for each iteration\n\n    # Perform filtering\n    for n in xrange(N):\n        # Generate U matrix and D vector with current data\n        U = np.zeros((M, K))\n        for k in np.arange(K):\n            U[:, (K-k-1)] = u[n+k:n+M+k]\n        U = np.flipud(U)\n        D = np.flipud(d[n+M-1:n+M+K-1])\n\n        # Filter\n        y = np.dot(U.T, w)\n        e = D - y\n\n        y_out[n] = y[0]\n        e_out[n] = e[0]\n\n        # Normalization factor\n        normFactor = np.linalg.solve(epsI + np.dot(U.T, U), I)\n        # Naive alternative\n        # normFactor = np.linalg.inv(epsI + np.dot(U.T, U))\n\n        w = leakstep * w + step * np.dot(U, np.dot(normFactor, e))\n\n        if returnCoeffs:\n            W[n] = w\n\n    if returnCoeffs:\n        w = W\n\n    return y_out, e_out, w", "response": "This function performs an affine projection on u to minimize error by analytical adaptive filter given by e = d - y."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting a bugreport command on the current page of the adb device and save it to dest_file", "response": "def bugreport(dest_file=\"default.log\"):\n    \"\"\"\n    Prints dumpsys, dumpstate, and logcat data to the screen, for the purposes of bug reporting\n    :return: result of _exec_command() execution\n    \"\"\"\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_BUGREPORT]\n    try:\n        dest_file_handler = open(dest_file, \"w\")\n    except IOError:\n        print(\"IOError: Failed to create a log file\")\n    \n    # We have to check if device is available or not before executing this command\n    # as adb bugreport will wait-for-device infinitely and does not come out of \n    # loop\n    # Execute only if device is available only\n    if _isDeviceAvailable():\n        result = _exec_command_to_file(adb_full_cmd, dest_file_handler)\n        return (result, \"Success: Bug report saved to: \" + dest_file)\n    else:\n        return (0, \"Device Not Found\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push(src, dest):\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_PUSH, src, dest]\n    return _exec_command(adb_full_cmd)", "response": "Push object from host to target\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pull(src, dest):\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_PULL, src, dest]\n    return _exec_command(adb_full_cmd)", "response": "Pull object from target to host\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting list of all available devices including emulators", "response": "def devices(opts=[]):\n    \"\"\"\n    Get list of all available devices including emulators\n    :param opts: list command options (e.g. [\"-r\", \"-a\"])\n    :return: result of _exec_command() execution\n    \"\"\"\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_DEVICES, _convert_opts(opts)]\n    return _exec_command(adb_full_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes shell command on target", "response": "def shell(cmd):\n    \"\"\"\n    Execute shell command on target\n    :param cmd: string shell command to execute\n    :return: result of _exec_command() execution\n    \"\"\"\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_SHELL, cmd]\n    return _exec_command(adb_full_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninstalls a single. apk on the target", "response": "def install(apk, opts=[]):\n    \"\"\"\n    Install *.apk on target\n    :param apk: string path to apk on host to install\n    :param opts: list command options (e.g. [\"-r\", \"-a\"])\n    :return: result of _exec_command() execution\n    \"\"\"\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_INSTALL, _convert_opts(opts), apk]\n    return _exec_command(adb_full_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync():\n    adb_full_cmd = [v.ADB_COMMAND_PREFIX, v.ADB_COMMAND_SHELL ,v.ADB_COMMAND_SYNC]\n    return _exec_command(adb_full_cmd)", "response": "Execute the sync command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting adb command and return output", "response": "def _exec_command(adb_cmd):\n    \"\"\"\n    Format adb command and execute it in shell\n    :param adb_cmd: list adb command to execute\n    :return: string '0' and shell command output if successful, otherwise\n    raise CalledProcessError exception and return error code\n    \"\"\"\n    t = tempfile.TemporaryFile()\n    final_adb_cmd = []\n    for e in adb_cmd:\n        if e != '':  # avoid items with empty string...\n            final_adb_cmd.append(e)  # ... so that final command doesn't\n            # contain extra spaces\n    print('\\n*** Executing ' + ' '.join(adb_cmd) + ' ' + 'command')\n\n    try:\n        output = check_output(final_adb_cmd, stderr=t)\n    except CalledProcessError as e:\n        t.seek(0)\n        result = e.returncode, t.read()\n    else:\n        result = 0, output\n        print('\\n' + result[1])\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _exec_command_to_file(adb_cmd, dest_file_handler):\n    t = tempfile.TemporaryFile()\n    final_adb_cmd = []\n    for e in adb_cmd:\n        if e != '':  # avoid items with empty string...\n            final_adb_cmd.append(e)  # ... so that final command doesn't\n            # contain extra spaces\n    print('\\n*** Executing ' + ' '.join(adb_cmd) + ' ' + 'command')\n\n    try:\n        output = call(final_adb_cmd, stdout=dest_file_handler, stderr=t)\n    except CalledProcessError as e:\n        t.seek(0)\n        result = e.returncode, t.read()\n    else:\n        result = output\n        dest_file_handler.close()\n\n    return result", "response": "Execute a list of adb commands and writes the output to a file handler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetect if the data was changed. This is added in 1. 6.", "response": "def has_changed(self, initial, data):\n        \"Detects if the data was changed. This is added in 1.6.\"\n        if initial is None and data is None:\n            return False\n        if data and not hasattr(data, '__iter__'):\n            data = self.widget.decompress(data)\n        initial = self.to_python(initial)\n        data = self.to_python(data)\n        if hasattr(self, '_coerce'):\n            data = self._coerce(data)\n        if isinstance(data, Model) and isinstance(initial, Model):\n            return model_vars(data) != model_vars(initial)\n        else:\n            return data != initial"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef results_decorator(func):\n    # Wrap function to maintian the original doc string, etc\n    @wraps(func)\n    def decorator(lookup_cls):\n        # Construct a class decorator from the original function\n        original = lookup_cls.results\n        def inner(self, request):\n            # Wrap lookup_cls.results by first calling func and checking the result\n            result = func(request)\n            if isinstance(result, HttpResponse):\n                return result\n            return original(self, request)\n        # Replace original lookup_cls.results with wrapped version\n        lookup_cls.results = inner\n        return lookup_cls\n    # Return the constructed decorator\n    return decorator", "response": "A decorator that returns a function which returns a HttpResponse object or a Lookup. results.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef staff_member_required(request):\n    \"Lookup decorator to require the user is a staff member.\"\n    user = getattr(request, 'user', None)\n    if user is None or not user.is_authenticated:\n        return HttpResponse(status=401) # Unauthorized\n    elif not user.is_staff:\n        return HttpResponseForbidden()", "response": "Lookup decorator to require the user is a staff member."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_item(self, item):\n        \"Construct result dictionary for the match item.\"\n        result = {\n            'id': self.get_item_id(item),\n            'value': self.get_item_value(item),\n            'label': self.get_item_label(item),\n        }\n        for key in settings.SELECTABLE_ESCAPED_KEYS:\n            if key in result:\n                result[key] = conditional_escape(result[key])\n        return result", "response": "Construct result dictionary for the match item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef paginate_results(self, results, options):\n        \"Return a django.core.paginator.Page of results.\"\n        limit = options.get('limit', settings.SELECTABLE_MAX_LIMIT)\n        paginator = Paginator(results, limit)\n        page = options.get('page', 1)\n        try:\n            results = paginator.page(page)\n        except (EmptyPage, InvalidPage):\n            results = paginator.page(paginator.num_pages)\n        return results", "response": "Return a django. core. paginator. Page of results."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef results(self, request):\n        \"Match results to given term and return the serialized HttpResponse.\"\n        results = {}\n        form = self.form(request.GET)\n        if form.is_valid():\n            options = form.cleaned_data\n            term = options.get('term', '')\n            raw_data = self.get_query(request, term)\n            results = self.format_results(raw_data, options)\n        return self.response(results)", "response": "Match results to given term and return the serialized HttpResponse."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a python structure that later gets serialized. raw_data full list of objects matching the search term full list of objects matching the search term a dictionary of the given options a dictionary of the given options", "response": "def format_results(self, raw_data, options):\n        '''\n        Returns a python structure that later gets serialized.\n        raw_data\n            full list of objects matching the search term\n        options\n            a dictionary of the given options\n        '''\n        page_data = self.paginate_results(raw_data, options)\n        results = {}\n        meta = options.copy()\n        meta['more'] = _('Show more results')\n        if page_data and page_data.has_next():\n            meta['next_page'] = page_data.next_page_number()\n        if page_data and page_data.has_previous():\n            meta['prev_page'] = page_data.previous_page_number()\n        results['data'] = [self.format_item(item) for item in page_data.object_list]\n        results['meta'] = meta\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_lookup_class(lookup_class):\n    from selectable.base import LookupBase\n    if isinstance(lookup_class, string_types):\n        mod_str, cls_str = lookup_class.rsplit('.', 1)\n        mod = import_module(mod_str)\n        lookup_class = getattr(mod, cls_str)\n    if not issubclass(lookup_class, LookupBase):\n        raise TypeError('lookup_class must extend from selectable.base.LookupBase')\n    return lookup_class", "response": "Imports lookup_class as a dotted base and ensure it extends LookupBase\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring given limit is less than default if defined", "response": "def clean_limit(self):\n        \"Ensure given limit is less than default if defined\"\n        limit = self.cleaned_data.get('limit', None)\n        if (settings.SELECTABLE_MAX_LIMIT is not None and\n            (not limit or limit > settings.SELECTABLE_MAX_LIMIT)):\n            limit = settings.SELECTABLE_MAX_LIMIT\n        return limit"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the results from the API.", "response": "async def parseResults(self, api_data):\n    \"\"\" See CoverSource.parseResults. \"\"\"\n    results = []\n\n    # parse HTML and get results\n    parser = lxml.etree.HTMLParser()\n    html = lxml.etree.XML(api_data.decode(\"latin-1\"), parser)\n\n    for rank, result in enumerate(__class__.RESULTS_SELECTOR(html), 1):\n      # extract url\n      metadata_div = result.find(\"div\")\n      metadata_json = lxml.etree.tostring(metadata_div, encoding=\"unicode\", method=\"text\")\n      metadata_json = json.loads(metadata_json)\n      google_url = result.find(\"a\").get(\"href\")\n      if google_url is not None:\n        query = urllib.parse.urlsplit(google_url).query\n      else:\n        query = None\n      if not query:\n        img_url = metadata_json[\"ou\"]\n      else:\n        query = urllib.parse.parse_qs(query)\n        img_url = query[\"imgurl\"][0]\n      # extract format\n      check_metadata = CoverImageMetadata.NONE\n      format = metadata_json[\"ity\"].lower()\n      try:\n        format = SUPPORTED_IMG_FORMATS[format]\n      except KeyError:\n        # format could not be identified or is unknown\n        format = None\n        check_metadata = CoverImageMetadata.FORMAT\n      # extract size\n      if not query:\n        size = metadata_json[\"ow\"], metadata_json[\"oh\"]\n      else:\n        size = tuple(map(int, (query[\"w\"][0], query[\"h\"][0])))\n      # extract thumbnail url\n      thumbnail_url = metadata_json[\"tu\"]\n      # result\n      results.append(GoogleImagesCoverSourceResult(img_url,\n                                                   size,\n                                                   format,\n                                                   thumbnail_url=thumbnail_url,\n                                                   source=self,\n                                                   rank=rank,\n                                                   check_metadata=check_metadata))\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def waitAccessAsync(self):\n    async with self.lock:\n      while True:\n        last_access_ts = self.__getLastAccess()\n        if last_access_ts is not None:\n          now = time.time()\n          last_access_ts = last_access_ts[0]\n          time_since_last_access = now - last_access_ts\n          if time_since_last_access < self.min_delay_between_accesses:\n            time_to_wait = self.min_delay_between_accesses - time_since_last_access\n            if self.jitter_range_ms is not None:\n              time_to_wait += random.randint(*self.jitter_range_ms) / 1000\n            self.logger.debug(\"Sleeping for %.2fms because of rate limit for domain %s\" % (time_to_wait * 1000,\n                                                                                           self.domain))\n            await asyncio.sleep(time_to_wait)\n\n        access_time = time.time()\n        self.__access(access_time)\n\n        # now we should be good... except if another process did the same query at the same time\n        # the database serves as an atomic lock, query again to be sure the last row is the one\n        # we just inserted\n        last_access_ts = self.__getLastAccess()\n        if last_access_ts[0] == access_time:\n          break", "response": "Wait for the request to be granted to the API."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrecords an API access.", "response": "def __access(self, ts):\n    \"\"\" Record an API access. \"\"\"\n    with self.connection:\n      self.connection.execute(\"INSERT OR REPLACE INTO access_timestamp (timestamp, domain) VALUES (?, ?)\",\n                              (ts, self.domain))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef aiohttp_socket_timeout(socket_timeout_s):\n  return aiohttp.ClientTimeout(total=None,\n                               connect=None,\n                               sock_connect=socket_timeout_s,\n                               sock_read=socket_timeout_s)", "response": "Return a new aiohttp. ClientTimeout object with only socket timeouts set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def query(self, url, *, post_data=None, headers=None, verify=True, cache=None, pre_cache_callback=None):\n    async def store_in_cache_callback():\n      pass\n    if cache is not None:\n      # try from cache first\n      if post_data is not None:\n        if (url, post_data) in cache:\n          self.logger.debug(\"Got data for URL '%s' %s from cache\" % (url, dict(post_data)))\n          return store_in_cache_callback, cache[(url, post_data)]\n      elif url in cache:\n        self.logger.debug(\"Got data for URL '%s' from cache\" % (url))\n        return store_in_cache_callback, cache[url]\n\n    domain_rate_watcher = rate_watcher.AccessRateWatcher(self.watcher_db_filepath,\n                                                         url,\n                                                         self.min_delay_between_accesses,\n                                                         jitter_range_ms=self.jitter_range_ms,\n                                                         logger=self.logger)\n\n    for attempt, time_to_sleep in enumerate(redo.retrier(max_attempts=HTTP_MAX_ATTEMPTS,\n                                                         sleeptime=1,\n                                                         max_sleeptime=HTTP_MAX_RETRY_SLEEP_S,\n                                                         sleepscale=1.5),\n                                            1):\n      await domain_rate_watcher.waitAccessAsync()\n\n      try:\n        if post_data is not None:\n          async with self.session.post(url,\n                                       data=post_data,\n                                       headers=self._buildHeaders(headers),\n                                       timeout=HTTP_NORMAL_TIMEOUT,\n                                       ssl=verify) as response:\n            content = await response.read()\n        else:\n          async with self.session.get(url,\n                                      headers=self._buildHeaders(headers),\n                                      timeout=HTTP_NORMAL_TIMEOUT,\n                                      ssl=verify) as response:\n            content = await response.read()\n\n        if cache is not None:\n          async def store_in_cache_callback():\n            if pre_cache_callback is not None:\n              # process\n              try:\n                data = await pre_cache_callback(content)\n              except Exception:\n                data = content\n            else:\n              data = content\n\n            # add to cache\n            if post_data is not None:\n              cache[(url, post_data)] = data\n            else:\n              cache[url] = data\n\n      except (asyncio.TimeoutError, aiohttp.ClientError) as e:\n        self.logger.warning(\"Querying '%s' failed (attempt %u/%u): %s %s\" % (url,\n                                                                             attempt,\n                                                                             HTTP_MAX_ATTEMPTS,\n                                                                             e.__class__.__qualname__,\n                                                                             e))\n        if attempt == HTTP_MAX_ATTEMPTS:\n          raise\n        else:\n          self.logger.debug(\"Retrying in %.3fs\" % (time_to_sleep))\n          await asyncio.sleep(time_to_sleep)\n\n      else:\n        break  # http retry loop\n\n    response.raise_for_status()\n\n    return store_in_cache_callback, content", "response": "Send a GET or POST request to the specified URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def isReachable(self, url, *, headers=None, verify=True, response_headers=None, cache=None):\n    if (cache is not None) and (url in cache):\n      # try from cache first\n      self.logger.debug(\"Got headers for URL '%s' from cache\" % (url))\n      resp_ok, response_headers = pickle.loads(cache[url])\n      return resp_ok\n\n    domain_rate_watcher = rate_watcher.AccessRateWatcher(self.watcher_db_filepath,\n                                                         url,\n                                                         self.min_delay_between_accesses,\n                                                         jitter_range_ms=self.jitter_range_ms,\n                                                         logger=self.logger)\n    resp_ok = True\n    try:\n      for attempt, time_to_sleep in enumerate(redo.retrier(max_attempts=HTTP_MAX_ATTEMPTS,\n                                                           sleeptime=0.5,\n                                                           max_sleeptime=HTTP_MAX_RETRY_SLEEP_SHORT_S,\n                                                           sleepscale=1.5),\n                                              1):\n        await domain_rate_watcher.waitAccessAsync()\n\n        try:\n          async with self.session.head(url,\n                                       headers=self._buildHeaders(headers),\n                                       timeout=HTTP_SHORT_TIMEOUT,\n                                       ssl=verify) as response:\n            pass\n\n        except (asyncio.TimeoutError, aiohttp.ClientError) as e:\n          self.logger.warning(\"Probing '%s' failed (attempt %u/%u): %s %s\" % (url,\n                                                                              attempt,\n                                                                              HTTP_MAX_ATTEMPTS,\n                                                                              e.__class__.__qualname__,\n                                                                              e))\n          if attempt == HTTP_MAX_ATTEMPTS:\n            resp_ok = False\n          else:\n            self.logger.debug(\"Retrying in %.3fs\" % (time_to_sleep))\n            await asyncio.sleep(time_to_sleep)\n\n        else:\n          response.raise_for_status()\n\n          if response_headers is not None:\n            response_headers.update(response.headers)\n\n          break  # http retry loop\n\n    except aiohttp.ClientResponseError as e:\n      self.logger.debug(\"Probing '%s' failed: %s %s\" % (url, e.__class__.__qualname__, e))\n      resp_ok = False\n\n    if cache is not None:\n      # store in cache\n      cache[url] = pickle.dumps((resp_ok, response_headers))\n\n    return resp_ok", "response": "Send a HEAD request to the given URL and return True if the request is successful."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def fastStreamedQuery(self, url, *, headers=None, verify=True):\n    response = await self.session.get(url,\n                                      headers=self._buildHeaders(headers),\n                                      timeout=HTTP_SHORT_TIMEOUT,\n                                      ssl=verify)\n\n    response.raise_for_status()\n\n    return response", "response": "Send a GET request with short timeout do not retry and return streamed response."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses a query string.", "response": "def processQueryString(self, s):\n    \"\"\" See CoverSource.processQueryString. \"\"\"\n    char_blacklist = set(string.punctuation)\n    char_blacklist.remove(\"'\")\n    char_blacklist.remove(\"&\")\n    char_blacklist = frozenset(char_blacklist)\n    return __class__.unpunctuate(s.lower(), char_blacklist=char_blacklist)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the response from the last. fm API call.", "response": "async def parseResults(self, api_data):\n    \"\"\" See CoverSource.parseResults. \"\"\"\n    results = []\n\n    # get xml results list\n    xml_text = api_data.decode(\"utf-8\")\n    xml_root = xml.etree.ElementTree.fromstring(xml_text)\n    status = xml_root.get(\"status\")\n    if status != \"ok\":\n      raise Exception(\"Unexpected Last.fm response status: %s\" % (status))\n    img_elements = xml_root.findall(\"album/image\")\n\n    # build results from xml\n    thumbnail_url = None\n    thumbnail_size = None\n    for img_element in img_elements:\n      img_url = img_element.text\n      if not img_url:\n        # last.fm returns empty image tag for size it does not have\n        continue\n      lfm_size = img_element.get(\"size\")\n      if lfm_size == \"mega\":\n        check_metadata = CoverImageMetadata.SIZE\n      else:\n        check_metadata = CoverImageMetadata.NONE\n      try:\n        size = __class__.SIZES[lfm_size]\n      except KeyError:\n        continue\n      if (size[0] <= MAX_THUMBNAIL_SIZE) and ((thumbnail_size is None) or (size[0] < thumbnail_size)):\n        thumbnail_url = img_url\n        thumbnail_size = size[0]\n      format = os.path.splitext(img_url)[1][1:].lower()\n      format = SUPPORTED_IMG_FORMATS[format]\n      results.append(LastFmCoverSourceResult(img_url,\n                                             size,\n                                             format,\n                                             thumbnail_url=thumbnail_url,\n                                             source=self,\n                                             check_metadata=check_metadata))\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches and download a cover.", "response": "async def search_and_download(album, artist, format, size, out_filepath, *, size_tolerance_prct, amazon_tlds, no_lq_sources,\n                              async_loop):\n  \"\"\" Search and download a cover, return True if success, False instead. \"\"\"\n  # register sources\n  source_args = (size, size_tolerance_prct)\n  cover_sources = [sources.LastFmCoverSource(*source_args),\n                   sources.AmazonCdCoverSource(*source_args),\n                   sources.AmazonDigitalCoverSource(*source_args)]\n  for tld in amazon_tlds:\n    cover_sources.append(sources.AmazonCdCoverSource(*source_args, tld=tld))\n  if not no_lq_sources:\n    cover_sources.append(sources.GoogleImagesWebScrapeCoverSource(*source_args))\n\n  # schedule search work\n  search_futures = []\n  for cover_source in cover_sources:\n    coroutine = cover_source.search(album, artist)\n    future = asyncio.ensure_future(coroutine, loop=async_loop)\n    search_futures.append(future)\n\n  # wait for it\n  await asyncio.wait(search_futures, loop=async_loop)\n\n  # get results\n  results = []\n  for future in search_futures:\n    source_results = future.result()\n    results.extend(source_results)\n\n  # sort results\n  results = await CoverSourceResult.preProcessForComparison(results, size, size_tolerance_prct)\n  results.sort(reverse=True,\n               key=functools.cmp_to_key(functools.partial(CoverSourceResult.compare,\n                                                          target_size=size,\n                                                          size_tolerance_prct=size_tolerance_prct)))\n  if not results:\n    logging.getLogger(\"Main\").info(\"No results\")\n\n  # download\n  for result in results:\n    try:\n      await result.get(format, size, size_tolerance_prct, out_filepath)\n    except Exception as e:\n      logging.getLogger(\"Main\").warning(\"Download of %s failed: %s %s\" % (result,\n                                                                          e.__class__.__qualname__,\n                                                                          e))\n      continue\n    else:\n      return True\n\n  return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the results from the CoverSource API.", "response": "async def parseResults(self, api_data):\n    \"\"\" See CoverSource.parseResults. \"\"\"\n    results = []\n\n    # parse page\n    parser = lxml.etree.HTMLParser()\n    html = lxml.etree.XML(api_data.decode(\"utf-8\"), parser)\n\n    for page_struct_version, result_selector in enumerate(__class__.RESULTS_SELECTORS):\n      result_nodes = result_selector(html)\n      if result_nodes:\n        break\n\n    for rank, result_node in enumerate(result_nodes, 1):\n      # get thumbnail & full image url\n      img_node = __class__.IMG_SELECTORS[page_struct_version](result_node)[0]\n      thumbnail_url = img_node.get(\"src\")\n      thumbnail_url = thumbnail_url.replace(\"Stripe-Prime-Only\", \"\")\n      url_parts = thumbnail_url.rsplit(\".\", 2)\n      img_url = \".\".join((url_parts[0], url_parts[2]))\n\n      # assume size is fixed\n      size = (500, 500)\n\n      # try to get higher res image...\n      if self.target_size > size[0]:  # ...but only if needed\n        self.logger.debug(\"Looking for optimal subimages configuration...\")\n        product_url = __class__.LINK_SELECTOR(result_node)[0].get(\"href\")\n        product_url = urllib.parse.urlsplit(product_url)\n        product_id = product_url.path.split(\"/\")[3]\n\n        # TODO don't pick up highest res image if user asked less?\n        for amazon_img_format in AMAZON_DIGITAL_IMAGE_FORMATS:\n          # TODO review this, it seem to always fail now\n          self.logger.debug(\"Trying %u subimages...\" % (amazon_img_format.slice_count ** 2))\n          urls = tuple(self.generateImgUrls(product_id,\n                                            __class__.DYNAPI_KEY,\n                                            amazon_img_format.id,\n                                            amazon_img_format.slice_count))\n          url_ok = await self.probeUrl(urls[-1])\n          if not url_ok:\n            # images at this size are not available\n            continue\n\n          # images at this size are available\n          img_url = urls\n          size = (amazon_img_format.total_res,) * 2\n          break\n\n      # assume format is always jpg\n      format = CoverImageFormat.JPEG\n\n      # add result\n      results.append(AmazonDigitalCoverSourceResult(img_url,\n                                                    size,\n                                                    format,\n                                                    thumbnail_url=thumbnail_url,\n                                                    source=self,\n                                                    rank=rank,\n                                                    check_metadata=CoverImageMetadata.SIZE))\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generateImgUrls(self, product_id, dynapi_key, format_id, slice_count):\n    for x in range(slice_count):\n      for y in range(slice_count):\n        yield (\"http://z2-ec2.images-amazon.com/R/1/a=\" + product_id +\n               \"+c=\" + dynapi_key +\n               \"+d=_SCR%28\" + str(format_id) + \",\" + str(x) + \",\" + str(y) + \"%29_=.jpg\")", "response": "Generate URLs for subimages of a product."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retrier(*, max_attempts, sleeptime, max_sleeptime, sleepscale=1.5, jitter=0.2):\n  assert(max_attempts > 1)\n  assert(sleeptime >= 0)\n  assert(0 <= jitter <= sleeptime)\n  assert(sleepscale >= 1)\n\n  cur_sleeptime = min(max_sleeptime, sleeptime)\n\n  for attempt in range(max_attempts):\n    cur_jitter = random.randint(int(-jitter * 1000), int(jitter * 1000)) / 1000\n    yield max(0, cur_sleeptime + cur_jitter)\n    cur_sleeptime = min(max_sleeptime, cur_sleeptime * sleepscale)", "response": "Generator yielding time to wait for a given amount of time."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads cover and process it.", "response": "async def get(self, target_format, target_size, size_tolerance_prct, out_filepath):\n    \"\"\" Download cover and process it. \"\"\"\n    if self.source_quality.value <= CoverSourceQuality.LOW.value:\n      logging.getLogger(\"Cover\").warning(\"Cover is from a potentially unreliable source and may be unrelated to the search\")\n\n    images_data = []\n    for i, url in enumerate(self.urls):\n      # download\n      logging.getLogger(\"Cover\").info(\"Downloading cover '%s' (part %u/%u)...\" % (url, i + 1, len(self.urls)))\n      headers = {}\n      self.source.updateHttpHeaders(headers)\n\n      async def pre_cache_callback(img_data):\n        return await __class__.crunch(img_data, self.format)\n\n      store_in_cache_callback, image_data = await self.source.http.query(url,\n                                                                         headers=headers,\n                                                                         verify=False,\n                                                                         cache=__class__.image_cache,\n                                                                         pre_cache_callback=pre_cache_callback)\n\n      # store immediately in cache\n      await store_in_cache_callback()\n\n      # append for multi images\n      images_data.append(image_data)\n\n    need_format_change = (self.format != target_format)\n    need_size_change = ((max(self.size) > target_size) and\n                        (abs(max(self.size) - target_size) >\n                         target_size * size_tolerance_prct / 100))\n    need_join = len(images_data) > 1\n    if need_join or need_format_change or need_size_change:\n      # post process\n      image_data = self.postProcess(images_data,\n                                    target_format if need_format_change else None,\n                                    target_size if need_size_change else None)\n\n      # crunch image again\n      image_data = await __class__.crunch(image_data, target_format)\n\n    # write it\n    with open(out_filepath, \"wb\") as file:\n      file.write(image_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts binary data to a target format and size and return the processed data.", "response": "def postProcess(self, images_data, new_format, new_size):\n    \"\"\" Convert image binary data to a target format and/or size (None if no conversion needed), and return the processed data. \"\"\"\n    if len(images_data) == 1:\n      in_bytes = io.BytesIO(images_data[0])\n      img = PIL.Image.open(in_bytes)\n      if img.mode != \"RGB\":\n        img = img.convert(\"RGB\")\n\n    else:\n      # images need to be joined before further processing\n      logging.getLogger(\"Cover\").info(\"Joining %u images...\" % (len(images_data)))\n      # TODO find a way to do this losslessly for JPEG\n      new_img = PIL.Image.new(\"RGB\", self.size)\n      assert(is_square(len(images_data)))\n      sq = int(math.sqrt(len(images_data)))\n\n      images_data_it = iter(images_data)\n      img_sizes = {}\n      for x in range(sq):\n        for y in range(sq):\n          current_image_data = next(images_data_it)\n          img_stream = io.BytesIO(current_image_data)\n          img = PIL.Image.open(img_stream)\n          img_sizes[(x, y)] = img.size\n          box = [0, 0]\n          if x > 0:\n            for px in range(x):\n              box[0] += img_sizes[(px, y)][0]\n          if y > 0:\n            for py in range(y):\n              box[1] += img_sizes[(x, py)][1]\n          box.extend((box[0] + img.size[0], box[1] + img.size[1]))\n          new_img.paste(img, box=tuple(box))\n      img = new_img\n\n    out_bytes = io.BytesIO()\n    if new_size is not None:\n      logging.getLogger(\"Cover\").info(\"Resizing from %ux%u to %ux%u...\" % (self.size[0], self.size[1], new_size, new_size))\n      img = img.resize((new_size, new_size), PIL.Image.LANCZOS)\n      # apply unsharp filter to remove resize blur (equivalent to (images/graphics)magick -unsharp 1.5x1+0.7+0.02)\n      # we don't use PIL.ImageFilter.SHARPEN or PIL.ImageEnhance.Sharpness because we want precise control over\n      # parameters\n      unsharper = PIL.ImageFilter.UnsharpMask(radius=1.5, percent=70, threshold=5)\n      img = img.filter(unsharper)\n    if new_format is not None:\n      logging.getLogger(\"Cover\").info(\"Converting to %s...\" % (new_format.name.upper()))\n      target_format = new_format\n    else:\n      target_format = self.format\n    img.save(out_bytes,\n             format=target_format.name,\n             quality=90,\n             optimize=True)\n    return out_bytes.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def updateImageMetadata(self):\n    assert(self.needMetadataUpdate())\n\n    width_sum, height_sum = 0, 0\n\n    # only download metadata for the needed images to get full size\n    idxs = []\n    assert(is_square(len(self.urls)))\n    sq = int(math.sqrt(len(self.urls)))\n    for x in range(sq):\n      for y in range(sq):\n        if x == y:\n          idxs.append((x * sq + y, x, y))\n\n    for idx, x, y in idxs:\n      url = self.urls[idx]\n      format, width, height = None, None, None\n\n      try:\n        format, width, height = pickle.loads(__class__.metadata_cache[url])\n      except KeyError:\n        # cache miss\n        pass\n      except Exception as e:\n        logging.getLogger(\"Cover\").warning(\"Unable to load metadata for URL '%s' from cache: %s %s\" % (url,\n                                                                                                       e.__class__.__qualname__,\n                                                                                                       e))\n      else:\n        # cache hit\n        logging.getLogger(\"Cover\").debug(\"Got metadata for URL '%s' from cache\" % (url))\n        if format is not None:\n          self.setFormatMetadata(format)\n\n      if (self.needMetadataUpdate(CoverImageMetadata.FORMAT) or\n              (self.needMetadataUpdate(CoverImageMetadata.SIZE) and ((width is None) or (height is None)))):\n        # download\n        logging.getLogger(\"Cover\").debug(\"Downloading file header for URL '%s'...\" % (url))\n        try:\n          headers = {}\n          self.source.updateHttpHeaders(headers)\n          response = await self.source.http.fastStreamedQuery(url,\n                                                              headers=headers,\n                                                              verify=False)\n          try:\n            if self.needMetadataUpdate(CoverImageMetadata.FORMAT):\n              # try to get format from response\n              format = __class__.guessImageFormatFromHttpResponse(response)\n              if format is not None:\n                self.setFormatMetadata(format)\n\n            if self.needMetadataUpdate():\n              # try to get metadata from HTTP data\n              metadata = await __class__.guessImageMetadataFromHttpData(response)\n              if metadata is not None:\n                format, width, height = metadata\n                if format is not None:\n                  self.setFormatMetadata(format)\n\n          finally:\n            response.release()\n\n        except Exception as e:\n          logging.getLogger(\"Cover\").warning(\"Failed to get file metadata for URL '%s' \"\n                                             \"(%s %s)\" % (url,\n                                                          e.__class__.__qualname__,\n                                                          e))\n\n        if self.needMetadataUpdate():  # did we fail to get needed metadata at this point?\n          if ((self.format is None) or\n                  ((self.size is None) and ((width is None) or (height is None)))):\n            # if we get here, file is probably not reachable, or not even an image\n            logging.getLogger(\"Cover\").debug(\"Unable to get file metadata from file or HTTP headers for URL '%s', \"\n                                             \"skipping this result\" % (url))\n            return\n\n          if ((self.format is not None) and\n                  ((self.size is not None) and (width is None) and (height is None))):\n            logging.getLogger(\"Cover\").debug(\"Unable to get file metadata from file or HTTP headers for URL '%s', \"\n                                             \"falling back to API data\" % (url))\n            self.check_metadata = CoverImageMetadata.NONE\n            self.reliable_metadata = False\n            return\n\n        # save it to cache\n        __class__.metadata_cache[url] = pickle.dumps((format, width, height))\n\n      # sum sizes\n      if (width is not None) and (height is not None):\n        width_sum += width\n        height_sum += height\n\n    if self.needMetadataUpdate(CoverImageMetadata.SIZE) and (width_sum > 0) and (height_sum > 0):\n      self.setSizeMetadata((width_sum, height_sum))", "response": "Partially download image file to get its real metadata or get it from cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting format image metadata to what has been reliably identified.", "response": "def setFormatMetadata(self, format):\n    \"\"\" Set format image metadata to what has been reliably identified. \"\"\"\n    assert((self.needMetadataUpdate(CoverImageMetadata.FORMAT)) or\n           (self.format is format))\n    self.format = format\n    self.check_metadata &= ~CoverImageMetadata.FORMAT"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset size image metadata to what has been reliably identified.", "response": "def setSizeMetadata(self, size):\n    \"\"\" Set size image metadata to what has been reliably identified. \"\"\"\n    assert((self.needMetadataUpdate(CoverImageMetadata.SIZE)) or\n           (self.size == size))\n    self.size = size\n    self.check_metadata &= ~CoverImageMetadata.SIZE"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def updateSignature(self):\n    assert(self.thumbnail_sig is None)\n\n    if self.thumbnail_url is None:\n      logging.getLogger(\"Cover\").warning(\"No thumbnail available for %s\" % (self))\n      return\n\n    # download\n    logging.getLogger(\"Cover\").debug(\"Downloading cover thumbnail '%s'...\" % (self.thumbnail_url))\n    headers = {}\n    self.source.updateHttpHeaders(headers)\n\n    async def pre_cache_callback(img_data):\n      return await __class__.crunch(img_data, CoverImageFormat.JPEG, silent=True)\n\n    try:\n      store_in_cache_callback, image_data = await self.source.http.query(self.thumbnail_url,\n                                                                         cache=__class__.image_cache,\n                                                                         headers=headers,\n                                                                         pre_cache_callback=pre_cache_callback)\n    except Exception as e:\n      logging.getLogger(\"Cover\").warning(\"Download of '%s' failed: %s %s\" % (self.thumbnail_url,\n                                                                             e.__class__.__qualname__,\n                                                                             e))\n      return\n\n    # compute sig\n    logging.getLogger(\"Cover\").debug(\"Computing signature of %s...\" % (self))\n    try:\n      self.thumbnail_sig = __class__.computeImgSignature(image_data)\n    except Exception as e:\n      logging.getLogger(\"Cover\").warning(\"Failed to compute signature of '%s': %s %s\" % (self,\n                                                                                         e.__class__.__qualname__,\n                                                                                         e))\n    else:\n      await store_in_cache_callback()", "response": "Calculate a cover s signature using its thumbnail url."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compare(first, second, *, target_size, size_tolerance_prct):\n    for c in (first, second):\n      assert(c.format is not None)\n      assert(isinstance(c.size[0], int) and isinstance(c.size[1], int))\n\n    # prefer square covers #1\n    delta_ratio1 = abs(first.size[0] / first.size[1] - 1)\n    delta_ratio2 = abs(second.size[0] / second.size[1] - 1)\n    if abs(delta_ratio1 - delta_ratio2) > 0.15:\n      return -1 if (delta_ratio1 > delta_ratio2) else 1\n\n    # prefer similar to reference\n    sr1 = first.is_similar_to_reference\n    sr2 = second.is_similar_to_reference\n    if sr1 and (not sr2):\n      return 1\n    if (not sr1) and sr2:\n      return -1\n\n    # prefer size above preferred\n    delta_size1 = ((first.size[0] + first.size[1]) / 2) - target_size\n    delta_size2 = ((second.size[0] + second.size[1]) / 2) - target_size\n    if (((delta_size1 < 0) and (delta_size2 >= 0)) or\n            (delta_size1 >= 0) and (delta_size2 < 0)):\n      return -1 if (delta_size1 < delta_size2) else 1\n\n    # if both below target size, prefer closest\n    if (delta_size1 < 0) and (delta_size2 < 0) and (delta_size1 != delta_size2):\n      return -1 if (delta_size1 < delta_size2) else 1\n\n    # prefer covers of most reliable source\n    qs1 = first.source_quality.value\n    qs2 = second.source_quality.value\n    if qs1 != qs2:\n      return -1 if (qs1 < qs2) else 1\n\n    # prefer best ranked\n    if ((first.rank is not None) and\n            (second.rank is not None) and\n            (first.__class__ is second.__class__) and\n            (first.rank != second.rank)):\n      return -1 if (first.rank > second.rank) else 1\n\n    # prefer reliable metadata\n    if first.reliable_metadata != second.reliable_metadata:\n      return 1 if first.reliable_metadata else -1\n\n    # prefer covers with less images to join\n    ic1 = len(first.urls)\n    ic2 = len(second.urls)\n    if ic1 != ic2:\n      return -1 if (ic1 > ic2) else 1\n\n    # prefer the preferred size\n    if abs(delta_size1) != abs(delta_size2):\n      return -1 if (abs(delta_size1) > abs(delta_size2)) else 1\n\n    # prefer png\n    if first.format != second.format:\n      return -1 if (second.format is CoverImageFormat.PNG) else 1\n\n    # prefer square covers #2\n    if (delta_ratio1 != delta_ratio2):\n      return -1 if (delta_ratio1 > delta_ratio2) else 1\n\n    # fuck, they are the same!\n    return 0", "response": "Compare two cover relevance and quality."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncrunch image data and return the processed data.", "response": "async def crunch(image_data, format, silent=False):\n    \"\"\" Crunch image data, and return the processed data, or orignal data if operation failed. \"\"\"\n    if (((format is CoverImageFormat.PNG) and (not HAS_OPTIPNG)) or\n            ((format is CoverImageFormat.JPEG) and (not HAS_JPEGOPTIM))):\n      return image_data\n    with mkstemp_ctx.mkstemp(suffix=\".%s\" % (format.name.lower())) as tmp_out_filepath:\n      if not silent:\n        logging.getLogger(\"Cover\").info(\"Crunching %s image...\" % (format.name.upper()))\n      with open(tmp_out_filepath, \"wb\") as tmp_out_file:\n        tmp_out_file.write(image_data)\n      size_before = len(image_data)\n      if format is CoverImageFormat.PNG:\n        cmd = [\"optipng\", \"-quiet\", \"-o1\"]\n      elif format is CoverImageFormat.JPEG:\n        cmd = [\"jpegoptim\", \"-q\", \"--strip-all\"]\n      cmd.append(tmp_out_filepath)\n      p = await asyncio.create_subprocess_exec(*cmd,\n                                               stdin=asyncio.subprocess.DEVNULL,\n                                               stdout=asyncio.subprocess.DEVNULL,\n                                               stderr=asyncio.subprocess.DEVNULL)\n      await p.wait()\n      if p.returncode != 0:\n        if not silent:\n          logging.getLogger(\"Cover\").warning(\"Crunching image failed\")\n        return image_data\n      with open(tmp_out_filepath, \"rb\") as tmp_out_file:\n        crunched_image_data = tmp_out_file.read()\n      size_after = len(crunched_image_data)\n      pct_saved = 100 * (size_before - size_after) / size_before\n      if not silent:\n        logging.getLogger(\"Cover\").debug(\"Crunching image saved %.2f%% filesize\" % (pct_saved))\n    return crunched_image_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guessImageMetadataFromData(img_data):\n    format, width, height = None, None, None\n    img_stream = io.BytesIO(img_data)\n    try:\n      img = PIL.Image.open(img_stream)\n    except IOError:\n      format = imghdr.what(None, h=img_data)\n      format = SUPPORTED_IMG_FORMATS.get(format, None)\n    else:\n      format = img.format.lower()\n      format = SUPPORTED_IMG_FORMATS.get(format, None)\n      width, height = img.size\n    return format, width, height", "response": "Identify an image format and size from its first bytes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def guessImageMetadataFromHttpData(response):\n    metadata = None\n    img_data = bytearray()\n\n    while len(img_data) < CoverSourceResult.MAX_FILE_METADATA_PEEK_SIZE:\n      new_img_data = await response.content.read(__class__.METADATA_PEEK_SIZE_INCREMENT)\n      if not new_img_data:\n        break\n      img_data.extend(new_img_data)\n\n      metadata = __class__.guessImageMetadataFromData(img_data)\n      if (metadata is not None) and all(metadata):\n        return metadata\n\n    return metadata", "response": "Identify an image format and size from the beginning of its HTTP data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nguess file format from HTTP response.", "response": "def guessImageFormatFromHttpResponse(response):\n    \"\"\" Guess file format from HTTP response, return format or None. \"\"\"\n    extensions = []\n\n    # try to guess extension from response content-type header\n    try:\n      content_type = response.headers[\"Content-Type\"]\n    except KeyError:\n      pass\n    else:\n      ext = mimetypes.guess_extension(content_type, strict=False)\n      if ext is not None:\n        extensions.append(ext)\n\n    # try to extract extension from URL\n    urls = list(response.history) + [response.url]\n    for url in map(str, urls):\n      ext = os.path.splitext(urllib.parse.urlsplit(url).path)[-1]\n      if (ext is not None) and (ext not in extensions):\n        extensions.append(ext)\n\n    # now guess from the extensions\n    for ext in extensions:\n      try:\n        return SUPPORTED_IMG_FORMATS[ext[1:]]\n      except KeyError:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the results to prepare them for comparison and sorting.", "response": "async def preProcessForComparison(results, target_size, size_tolerance_prct):\n    \"\"\" Process results to prepare them for future comparison and sorting. \"\"\"\n    # find reference (=image most likely to match target cover ignoring factors like size and format)\n    reference = None\n    for result in results:\n      if result.source_quality is CoverSourceQuality.REFERENCE:\n        if ((reference is None) or\n            (CoverSourceResult.compare(result,\n                                       reference,\n                                       target_size=target_size,\n                                       size_tolerance_prct=size_tolerance_prct) > 0)):\n          reference = result\n\n    # remove results that are only refs\n    results = list(itertools.filterfalse(operator.attrgetter(\"is_only_reference\"), results))\n\n    # remove duplicates\n    no_dup_results = []\n    for result in results:\n      is_dup = False\n      for result_comp in results:\n        if ((result_comp is not result) and\n            (result_comp.urls == result.urls) and\n            (__class__.compare(result,\n                               result_comp,\n                               target_size=target_size,\n                               size_tolerance_prct=size_tolerance_prct) < 0)):\n          is_dup = True\n          break\n      if not is_dup:\n        no_dup_results.append(result)\n    dup_count = len(results) - len(no_dup_results)\n    if dup_count > 0:\n      logging.getLogger(\"Cover\").info(\"Removed %u duplicate results\" % (dup_count))\n      results = no_dup_results\n\n    if reference is not None:\n      logging.getLogger(\"Cover\").info(\"Reference is: %s\" % (reference))\n      reference.is_similar_to_reference = True\n\n      # calculate sigs\n      futures = []\n      for result in results:\n        coroutine = result.updateSignature()\n        future = asyncio.ensure_future(coroutine)\n        futures.append(future)\n      if reference.is_only_reference:\n        assert(reference not in results)\n        coroutine = reference.updateSignature()\n        future = asyncio.ensure_future(coroutine)\n        futures.append(future)\n      if futures:\n        await asyncio.wait(futures)\n      for future in futures:\n        future.result()  # raise pending exception if any\n\n      # compare other results to reference\n      for result in results:\n        if ((result is not reference) and\n                (result.thumbnail_sig is not None) and\n                (reference.thumbnail_sig is not None)):\n          result.is_similar_to_reference = __class__.areImageSigsSimilar(result.thumbnail_sig,\n                                                                         reference.thumbnail_sig)\n          if result.is_similar_to_reference:\n            logging.getLogger(\"Cover\").debug(\"%s is similar to reference\" % (result))\n          else:\n            logging.getLogger(\"Cover\").debug(\"%s is NOT similar to reference\" % (result))\n    else:\n      logging.getLogger(\"Cover\").warning(\"No reference result found\")\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef computeImgSignature(image_data):\n    parser = PIL.ImageFile.Parser()\n    parser.feed(image_data)\n    img = parser.close()\n    target_size = (__class__.IMG_SIG_SIZE, __class__.IMG_SIG_SIZE)\n    img.thumbnail(target_size, PIL.Image.BICUBIC)\n    if img.size != target_size:\n      logging.getLogger(\"Cover\").debug(\"Non square thumbnail after resize to %ux%u, unable to compute signature\" % target_size)\n      return None\n    img = img.convert(mode=\"RGB\")\n    pixels = img.getdata()\n    pixel_count = target_size[0] * target_size[1]\n    color_count = 3\n    r = bitarray.bitarray(pixel_count * color_count)\n    r.setall(False)\n    for ic in range(color_count):\n      mean = sum(p[ic] for p in pixels) // pixel_count\n      for ip, p in enumerate(pixels):\n        if p[ic] > mean:\n          r[pixel_count * ic + ip] = True\n    return r", "response": "Calculate an image signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef analyze_lib(lib_dir, cover_filename, *, ignore_existing=False):\n  work = {}\n  stats = collections.OrderedDict(((k, 0) for k in(\"files\", \"albums\", \"missing covers\", \"errors\")))\n  with tqdm.tqdm(desc=\"Analyzing library\",\n                 unit=\"dir\",\n                 postfix=stats) as progress, \\\n          tqdm_logging.redirect_logging(progress):\n    for rootpath, rel_dirpaths, rel_filepaths in os.walk(lib_dir):\n      metadata = analyze_dir(stats,\n                             rootpath,\n                             rel_filepaths,\n                             cover_filename,\n                             ignore_existing=ignore_existing)\n      progress.set_postfix(stats, refresh=False)\n      progress.update(1)\n      if all(metadata[:-1]):\n        work[rootpath] = metadata[:-1]\n  return work", "response": "Recursively analyze a library and return a dict of path - > album."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a tuple of album artist has_embedded_album_art from a list of audio files.", "response": "def get_metadata(audio_filepaths):\n  \"\"\" Return a tuple of album, artist, has_embedded_album_art from a list of audio files. \"\"\"\n  artist, album, has_embedded_album_art = None, None, None\n  for audio_filepath in audio_filepaths:\n    try:\n      mf = mutagen.File(audio_filepath)\n    except Exception:\n      continue\n    if mf is None:\n      continue\n\n    # artist\n    for key in (\"albumartist\", \"artist\",  # ogg\n                \"TPE1\", \"TPE2\",  # mp3\n                \"aART\", \"\\xa9ART\"):  # mp4\n      try:\n        val = mf.get(key, None)\n      except ValueError:\n        val = None\n      if val is not None:\n        artist = val[-1]\n        break\n\n    # album\n    for key in (\"_album\", \"album\",  # ogg\n                \"TALB\",  # mp3\n                \"\\xa9alb\"):  # mp4\n      try:\n        val = mf.get(key, None)\n      except ValueError:\n        val = None\n      if val is not None:\n        album = val[-1]\n        break\n\n    if artist and album:\n      # album art\n      if isinstance(mf, mutagen.ogg.OggFileType):\n        has_embedded_album_art = \"metadata_block_picture\" in mf\n      elif isinstance(mf, mutagen.mp3.MP3):\n        has_embedded_album_art = any(map(operator.methodcaller(\"startswith\", \"APIC:\"), mf.keys()))\n      elif isinstance(mf, mutagen.mp4.MP4):\n        has_embedded_album_art = \"covr\" in mf\n\n      # stop at the first file that succeeds (for performance)\n      break\n\n  return artist, album, has_embedded_album_art"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef analyze_dir(stats, parent_dir, rel_filepaths, cover_filename, *, ignore_existing=False):\n  no_metadata = None, None, None\n  metadata = no_metadata\n  audio_filepaths = []\n  for rel_filepath in rel_filepaths:\n    stats[\"files\"] += 1\n    try:\n      ext = os.path.splitext(rel_filepath)[1][1:].lower()\n    except IndexError:\n      continue\n    if ext in AUDIO_EXTENSIONS:\n      audio_filepaths.append(os.path.join(parent_dir, rel_filepath))\n  if audio_filepaths:\n    stats[\"albums\"] += 1\n    if (cover_filename != EMBEDDED_ALBUM_ART_SYMBOL):\n      missing = (not os.path.isfile(os.path.join(parent_dir, cover_filename))) or ignore_existing\n      if missing:\n        metadata = get_metadata(audio_filepaths)\n    else:\n      metadata = get_metadata(audio_filepaths)\n      missing = (not metadata[2]) or ignore_existing\n    if missing:\n      stats[\"missing covers\"] += 1\n      if not all(metadata[:-1]):\n        # failed to get metadata for this album\n        stats[\"errors\"] += 1\n        logging.getLogger(\"sacad_r\").error(\"Unable to read metadata for album directory '%s'\" % (parent_dir))\n    else:\n      metadata = no_metadata\n  return metadata", "response": "Analyze a directory to get album metadata."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nembedding album art into audio files.", "response": "def embed_album_art(cover_filepath, path):\n  \"\"\" Embed album art into audio files. \"\"\"\n  with open(cover_filepath, \"rb\") as f:\n    cover_data = f.read()\n\n  for filename in os.listdir(path):\n    try:\n      ext = os.path.splitext(filename)[1][1:].lower()\n    except IndexError:\n      continue\n\n    if ext in AUDIO_EXTENSIONS:\n      filepath = os.path.join(path, filename)\n      mf = mutagen.File(filepath)\n      if (isinstance(mf.tags, mutagen._vorbis.VComment) or\n              isinstance(mf, mutagen.ogg.OggFileType)):\n        picture = mutagen.flac.Picture()\n        picture.data = cover_data\n        picture.type = mutagen.id3.PictureType.COVER_FRONT\n        picture.mime = \"image/jpeg\"\n        encoded_data = base64.b64encode(picture.write())\n        mf[\"metadata_block_picture\"] = encoded_data.decode(\"ascii\")\n      elif (isinstance(mf.tags, mutagen.id3.ID3) or\n            isinstance(mf, mutagen.id3.ID3FileType)):\n        mf.tags.add(mutagen.id3.APIC(mime=\"image/jpeg\",\n                                     type=mutagen.id3.PictureType.COVER_FRONT,\n                                     data=cover_data))\n      elif (isinstance(mf.tags, mutagen.mp4.MP4Tags) or\n            isinstance(mf, mutagen.mp4.MP4)):\n        mf[\"covr\"] = [mutagen.mp4.MP4Cover(cover_data,\n                                           imageformat=mutagen.mp4.AtomDataType.JPEG)]\n      mf.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ichunk(iterable, n):\n  it = iter(iterable)\n  while True:\n    chunk = tuple(itertools.islice(it, n))\n    if not chunk:\n      return\n    yield chunk", "response": "Split an iterable into n - sized chunks."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for a given album and artist and return an iterable of CoverSourceResult objects.", "response": "async def search(self, album, artist):\n    \"\"\" Search for a given album/artist and return an iterable of CoverSourceResult. \"\"\"\n    self.logger.debug(\"Searching with source '%s'...\" % (self.__class__.__name__))\n    album = self.processAlbumString(album)\n    artist = self.processArtistString(artist)\n    url_data = self.getSearchUrl(album, artist)\n    if isinstance(url_data, tuple):\n      url, post_data = url_data\n    else:\n      url = url_data\n      post_data = None\n    try:\n      store_in_cache_callback, api_data = await self.fetchResults(url, post_data)\n      results = await self.parseResults(api_data)\n    except Exception as e:\n      # raise\n      self.logger.warning(\"Search with source '%s' failed: %s %s\" % (self.__class__.__name__,\n                                                                     e.__class__.__qualname__,\n                                                                     e))\n      return ()\n    else:\n      if results:\n        # only store in cache if parsing succeeds and we have results\n        await store_in_cache_callback()\n\n    # get metadata\n    futures = []\n    for result in filter(operator.methodcaller(\"needMetadataUpdate\"), results):\n      coroutine = result.updateImageMetadata()\n      future = asyncio.ensure_future(coroutine)\n      futures.append(future)\n    if futures:\n      await asyncio.wait(futures)\n    for future in futures:\n      future.result()  # raise pending exception if any\n\n    # filter\n    results_excluded_count = 0\n    reference_only_count = 0\n    results_kept = []\n    for result in results:\n      if ((result.size[0] + (self.size_tolerance_prct * self.target_size / 100) < self.target_size) or  # skip too small images\n              (result.size[1] + (self.size_tolerance_prct * self.target_size / 100) < self.target_size) or\n              (result.format is None) or  # unknown format\n              result.needMetadataUpdate()):  # if still true, it means we failed to grab metadata, so exclude it\n        if result.source_quality is CoverSourceQuality.REFERENCE:\n          # we keep this result just for the reference, it will be excluded from the results\n          result.is_only_reference = True\n          results_kept.append(result)\n          reference_only_count += 1\n        else:\n          results_excluded_count += 1\n      else:\n        results_kept.append(result)\n    result_kept_count = len(results_kept) - reference_only_count\n\n    # log\n    self.logger.info(\"Got %u relevant (%u excluded) results from source '%s'\" % (result_kept_count,\n                                                                                 results_excluded_count + reference_only_count,\n                                                                                 self.__class__.__name__))\n    for result in itertools.filterfalse(operator.attrgetter(\"is_only_reference\"), results_kept):\n      self.logger.debug(\"%s %s%s %4dx%4d %s%s\" % (result.__class__.__name__,\n                                                  (\"(%02d) \" % (result.rank)) if result.rank is not None else \"\",\n                                                  result.format.name,\n                                                  result.size[0],\n                                                  result.size[1],\n                                                  result.urls[0],\n                                                  \" [x%u]\" % (len(result.urls)) if len(result.urls) > 1 else \"\"))\n    return results_kept"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a tuple from an URL.", "response": "async def fetchResults(self, url, post_data=None):\n    \"\"\" Get a (store in cache callback, search results) tuple from an URL. \"\"\"\n    if post_data is not None:\n      self.logger.debug(\"Querying URL '%s' %s...\" % (url, dict(post_data)))\n    else:\n      self.logger.debug(\"Querying URL '%s'...\" % (url))\n    headers = {}\n    self.updateHttpHeaders(headers)\n    return await self.http.query(url,\n                                 post_data=post_data,\n                                 headers=headers,\n                                 cache=__class__.api_cache)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def probeUrl(self, url, response_headers=None):\n    self.logger.debug(\"Probing URL '%s'...\" % (url))\n    headers = {}\n    self.updateHttpHeaders(headers)\n    resp_headers = {}\n    resp_ok = await self.http.isReachable(url,\n                                          headers=headers,\n                                          response_headers=resp_headers,\n                                          cache=__class__.probe_cache)\n\n    if response_headers is not None:\n      response_headers.update(resp_headers)\n\n    return resp_ok", "response": "Probe a URL and return True if it is reachable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreplacing accentuated chars in string by their non accentuated equivalent.", "response": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove punctuation from string s.", "response": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def parseResults(self, api_data):\n    results = []\n\n    # parse page\n    parser = lxml.etree.HTMLParser()\n    html = lxml.etree.XML(api_data.decode(\"utf-8\", \"ignore\"), parser)\n\n    for page_struct_version, result_selector in enumerate(__class__.RESULTS_SELECTORS):\n      result_nodes = result_selector(html)\n      if result_nodes:\n        break\n\n    for rank, result_node in enumerate(result_nodes, 1):\n      try:\n        img_node = __class__.IMG_SELECTORS[page_struct_version](result_node)[0]\n      except IndexError:\n        # no image for that product\n        continue\n      # get thumbnail & full image url\n      thumbnail_url = img_node.get(\"src\")\n      url_parts = thumbnail_url.rsplit(\".\", 2)\n      img_url = \".\".join((url_parts[0], url_parts[2]))\n      # assume size is fixed\n      size = (500, 500)\n      check_metadata = CoverImageMetadata.SIZE\n      # try to get higher res image...\n      if ((self.target_size > size[0]) and  # ...only if needed\n              (rank <= 3)):  # and only for first 3 results because this is time\n                             # consuming (1 more GET request per result)\n        product_url = __class__.PRODUCT_LINK_SELECTORS[page_struct_version](result_node)[0].get(\"href\")\n        product_url_split = urllib.parse.urlsplit(product_url)\n        if not product_url_split.scheme:\n          # relative redirect url\n          product_url_query = urllib.parse.parse_qsl(product_url_split.query)\n          product_url_query = collections.OrderedDict(product_url_query)\n          try:\n            # needed if page_struct_version == 1\n            product_url = product_url_query[\"url\"]\n          except KeyError:\n            # page_struct_version == 0, make url absolute\n            product_url = urllib.parse.urljoin(self.base_url, product_url)\n          product_url_split = urllib.parse.urlsplit(product_url)\n        product_url_query = urllib.parse.parse_qsl(product_url_split.query)\n        product_url_query = collections.OrderedDict(product_url_query)\n        try:\n          # remove timestamp from url to improve future cache hit rate\n          del product_url_query[\"qid\"]\n        except KeyError:\n          pass\n        product_url_query = urllib.parse.urlencode(product_url_query)\n        product_url_no_ts = urllib.parse.urlunsplit(product_url_split[:3] + (product_url_query,) + product_url_split[4:])\n        store_in_cache_callback, product_page_data = await self.fetchResults(product_url_no_ts)\n        product_page_html = lxml.etree.XML(product_page_data.decode(\"latin-1\"), parser)\n        try:\n          img_node = __class__.PRODUCT_PAGE_IMG_SELECTOR(product_page_html)[0]\n        except IndexError:\n          # unable to get better image\n          pass\n        else:\n          better_img_url = img_node.get(\"data-old-hires\")\n          # img_node.get(\"data-a-dynamic-image\") contains json with image urls too, but they are not larger than\n          # previous 500px image and are often covered by autorip badges (can be removed by cleaning url though)\n          if better_img_url:\n            img_url = better_img_url\n            size_url_hint = img_url.rsplit(\".\", 2)[1].strip(\"_\")\n            assert(size_url_hint.startswith(\"SL\"))\n            size_url_hint = int(size_url_hint[2:])\n            size = (size_url_hint, size_url_hint)\n            check_metadata = CoverImageMetadata.NONE\n          await store_in_cache_callback()\n\n      # assume format is always jpg\n      format = CoverImageFormat.JPEG\n      # add result\n      results.append(AmazonCdCoverSourceResult(img_url,\n                                               size,\n                                               format,\n                                               thumbnail_url=thumbnail_url,\n                                               source=self,\n                                               rank=rank,\n                                               check_metadata=check_metadata))\n\n    return results", "response": "Parse the results from the Cover API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall delete on all members of obj that are recognized as instances of pg objects.", "response": "def delete_all(obj):\n    '''Calls `delete()` on all members of `obj` that are recognized as\n    instances of `pg` objects.'''\n    types = tuple([\n        Shader,\n        Mesh,\n        VertexBuffer,\n        IndexBuffer,\n        Texture,\n        Program,\n        Context,\n    ])\n    for name in dir(obj):\n        child = getattr(obj, name)\n        if isinstance(child, types):\n            child.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _glfw_get_version(filename):\n    '''\n    Queries and returns the library version tuple or None by using a\n    subprocess.\n    '''\n    version_checker_source = \"\"\"\n        import sys\n        import ctypes\n\n        def get_version(library_handle):\n            '''\n            Queries and returns the library version tuple or None.\n            '''\n            major_value = ctypes.c_int(0)\n            major = ctypes.pointer(major_value)\n            minor_value = ctypes.c_int(0)\n            minor = ctypes.pointer(minor_value)\n            rev_value = ctypes.c_int(0)\n            rev = ctypes.pointer(rev_value)\n            if hasattr(library_handle, 'glfwGetVersion'):\n                library_handle.glfwGetVersion(major, minor, rev)\n                version = (major_value.value,\n                           minor_value.value,\n                           rev_value.value)\n                return version\n            else:\n                return None\n\n        try:\n            input_func = raw_input\n        except NameError:\n            input_func = input\n        filename = input_func().strip()\n\n        try:\n            library_handle = ctypes.CDLL(filename)\n        except OSError:\n            pass\n        else:\n            version = get_version(library_handle)\n            print(version)\n    \"\"\"\n\n    args = [sys.executable, '-c', textwrap.dedent(version_checker_source)]\n    process = subprocess.Popen(args, universal_newlines=True,\n                               stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n    out = process.communicate(_to_char_p(filename))[0]\n    out = out.strip()\n    if out:\n        return eval(out)\n    else:\n        return None", "response": "Function to get the version of the library."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the error callback.", "response": "def set_error_callback(cbfun):\n    '''\n    Sets the error callback.\n\n    Wrapper for:\n        GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun);\n    '''\n    global _error_callback\n    previous_callback = _error_callback\n    if cbfun is None:\n        cbfun = 0\n    c_cbfun = _GLFWerrorfun(cbfun)\n    _error_callback = (cbfun, c_cbfun)\n    cbfun = c_cbfun\n    _glfw.glfwSetErrorCallback(cbfun)\n    if previous_callback is not None and previous_callback[0] != 0:\n        return previous_callback[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef destroy_window(window):\n    '''\n    Destroys the specified window and its context.\n\n    Wrapper for:\n        void glfwDestroyWindow(GLFWwindow* window);\n    '''\n    _glfw.glfwDestroyWindow(window)\n    window_addr = ctypes.cast(ctypes.pointer(window),\n                              ctypes.POINTER(ctypes.c_ulong)).contents.value\n    for callback_repository in _callback_repositories:\n        if window_addr in callback_repository:\n            del callback_repository[window_addr]", "response": "Destroys the specified window and its context."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unwrap(self):\n        '''\n        Returns a nested python sequence.\n        '''\n        size = self.width, self.height\n        bits = self.red_bits, self.green_bits, self.blue_bits\n        return size, bits, self.refresh_rate", "response": "Returns a nested python sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap a nested python sequence.", "response": "def wrap(self, gammaramp):\n        '''\n        Wraps a nested python sequence.\n        '''\n        red, green, blue = gammaramp\n        size = min(len(red), len(green), len(blue))\n        array_type = ctypes.c_ushort*size\n        self.size = ctypes.c_uint(size)\n        self.red_array = array_type()\n        self.green_array = array_type()\n        self.blue_array = array_type()\n        for i in range(self.size):\n            self.red_array[i] = int(red[i]*65535)\n            self.green_array[i] = int(green[i]*65535)\n            self.blue_array[i] = int(blue[i]*65535)\n        pointer_type = ctypes.POINTER(ctypes.c_ushort)\n        self.red = ctypes.cast(self.red_array, pointer_type)\n        self.green = ctypes.cast(self.green_array, pointer_type)\n        self.blue = ctypes.cast(self.blue_array, pointer_type)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unwrap(self):\n        '''\n        Returns a nested python sequence.\n        '''\n        red = [self.red[i]/65535.0 for i in range(self.size)]\n        green = [self.green[i]/65535.0 for i in range(self.size)]\n        blue = [self.blue[i]/65535.0 for i in range(self.size)]\n        return red, green, blue", "response": "Returns a nested python sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a hexadecimal color value in the format 0xrrggbb and returns an r g b tuple where 0 <= r g b <= 1. 0 and 0 <= g b <= 1. 0", "response": "def hex_color(value):\n    '''Accepts a hexadecimal color `value` in the format ``0xrrggbb`` and\n    returns an (r, g, b) tuple where 0.0 <= r, g, b <= 1.0.\n    '''\n    r = ((value >> (8 * 2)) & 255) / 255.0\n    g = ((value >> (8 * 1)) & 255) / 255.0\n    b = ((value >> (8 * 0)) & 255) / 255.0\n    return (r, g, b)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnormalizes the vector so that its length is 1.", "response": "def normalize(vector):\n    '''Normalizes the `vector` so that its length is 1. `vector` can have\n    any number of components.\n    '''\n    d = sum(x * x for x in vector) ** 0.5\n    return tuple(x / d for x in vector)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes and returns the distance between two points p1 and p2.", "response": "def distance(p1, p2):\n    '''Computes and returns the distance between two points, `p1` and `p2`.\n    The points can have any number of components.\n    '''\n    return sum((a - b) ** 2 for a, b in zip(p1, p2)) ** 0.5"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the cross product of two vectors.", "response": "def cross(v1, v2):\n    '''Computes the cross product of two vectors.\n    '''\n    return (\n        v1[1] * v2[2] - v1[2] * v2[1],\n        v1[2] * v2[0] - v1[0] * v2[2],\n        v1[0] * v2[1] - v1[1] * v2[0],\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the dot product of two vectors.", "response": "def dot(v1, v2):\n    '''Computes the dot product of two vectors.\n    '''\n    x1, y1, z1 = v1\n    x2, y2, z2 = v2\n    return x1 * x2 + y1 * y2 + z1 * z2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef interpolate(v1, v2, t):\n    '''Interpolate from one vector to another.\n    '''\n    return add(v1, mul(sub(v2, v1), t))", "response": "Interpolate from one vector to another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute a normal vector given three points.", "response": "def normal_from_points(a, b, c):\n    '''Computes a normal vector given three points.\n    '''\n    x1, y1, z1 = a\n    x2, y2, z2 = b\n    x3, y3, z3 = c\n    ab = (x2 - x1, y2 - y1, z2 - z1)\n    ac = (x3 - x1, y3 - y1, z3 - z1)\n    x, y, z = cross(ab, ac)\n    d = (x * x + y * y + z * z) ** 0.5\n    return (x / d, y / d, z / d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef smooth_normals(positions, normals):\n    '''Assigns an averaged normal to each position based on all of the normals\n    originally used for the position.\n    '''\n    lookup = defaultdict(list)\n    for position, normal in zip(positions, normals):\n        lookup[position].append(normal)\n    result = []\n    for position in positions:\n        tx = ty = tz = 0\n        for x, y, z in lookup[position]:\n            tx += x\n            ty += y\n            tz += z\n        d = (tx * tx + ty * ty + tz * tz) ** 0.5\n        result.append((tx / d, ty / d, tz / d))\n    return result", "response": "Assigns an averaged normal to each position based on all of the normals\n    originally used for the position."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the bounding box for a list of 3 - dimensional points.", "response": "def bounding_box(positions):\n    '''Computes the bounding box for a list of 3-dimensional points.\n    '''\n    (x0, y0, z0) = (x1, y1, z1) = positions[0]\n    for x, y, z in positions:\n        x0 = min(x0, x)\n        y0 = min(y0, y)\n        z0 = min(z0, z)\n        x1 = max(x1, x)\n        y1 = max(y1, y)\n        z1 = max(z1, z)\n    return (x0, y0, z0), (x1, y1, z1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recenter(positions):\n    '''Returns a list of new positions centered around the origin.\n    '''\n    (x0, y0, z0), (x1, y1, z1) = bounding_box(positions)\n    dx = x1 - (x1 - x0) / 2.0\n    dy = y1 - (y1 - y0) / 2.0\n    dz = z1 - (z1 - z0) / 2.0\n    result = []\n    for x, y, z in positions:\n        result.append((x - dx, y - dy, z - dz))\n    return result", "response": "Returns a list of new positions centered around the origin."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninterleaves the elements of the provided arrays.", "response": "def interleave(*args):\n    '''Interleaves the elements of the provided arrays.\n\n        >>> a = [(0, 0), (1, 0), (2, 0), (3, 0)]\n        >>> b = [(0, 0), (0, 1), (0, 2), (0, 3)]\n        >>> interleave(a, b)\n        [(0, 0, 0, 0), (1, 0, 0, 1), (2, 0, 0, 2), (3, 0, 0, 3)]\n\n    This is useful for combining multiple vertex attributes into a single\n    vertex buffer. The shader attributes can be assigned a slice of the\n    vertex buffer.\n    '''\n    result = []\n    for array in zip(*args):\n        result.append(tuple(flatten(array)))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distinct(iterable, keyfunc=None):\n    '''Yields distinct items from `iterable` in the order that they appear.\n    '''\n    seen = set()\n    for item in iterable:\n        key = item if keyfunc is None else keyfunc(item)\n        if key not in seen:\n            seen.add(key)\n            yield item", "response": "Yields distinct items from iterable in the order that they appear."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ray_triangle_intersection(v1, v2, v3, o, d):\n    '''Computes the distance from a point to a triangle given a ray.\n    '''\n    eps = 1e-6\n    e1 = sub(v2, v1)\n    e2 = sub(v3, v1)\n    p = cross(d, e2)\n    det = dot(e1, p)\n    if abs(det) < eps:\n        return None\n    inv = 1.0 / det\n    t = sub(o, v1)\n    u = dot(t, p) * inv\n    if u < 0 or u > 1:\n        return None\n    q = cross(t, e1)\n    v = dot(d, q) * inv\n    if v < 0 or v > 1:\n        return None\n    t = dot(e2, q) * inv\n    if t > eps:\n        return t\n    return None", "response": "Computes the distance from a point to a triangle given a ray.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pack_list(fmt, data):\n    '''Convert a Python list into a ctypes buffer.\n\n    This appears to be faster than the typical method of creating a ctypes\n    array, e.g. (c_float * len(data))(*data)\n    '''\n    func = struct.Struct(fmt).pack\n    return create_string_buffer(''.join([func(x) for x in data]))", "response": "Convert a Python list into a ctypes buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef click(self, jquery=False):\n        if jquery:\n            e = JQuery(self)\n            e.click()\n        else:\n            super(Clickable, self).click()", "response": "Click by WebElement or JQuery"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an instance of Cookie class from cookielib to a dict.", "response": "def convert_cookie_to_dict(cookie, keys_map=WEB_DRIVER_COOKIE_KEYS_MAP):\n    \"\"\"\n    Converts an instance of Cookie class from cookielib to a dict.\n    The names of attributes can be changed according to keys_map:.\n    For example, this method can be used to create a cookie which compatible with WebDriver format.\n\n    :param cookie: Cookie instance received from requests/sessions using url2lib or requests libraries.\n    :param keys_map: The dict to map cookie attributes for different schemas. By default WebDriver format is used.\n    :return:\n    \"\"\"\n\n    cookie_dict = dict()\n\n    for k in keys_map.keys():\n        key = _to_unicode_if_str(keys_map[k])\n        value = _to_unicode_if_str(getattr(cookie, k))\n        cookie_dict[key] = value\n\n    return cookie_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_cookies_to_web_driver(driver, cookies):\n    for cookie in cookies:\n        driver.add_cookie(convert_cookie_to_dict(cookie))\n    return driver", "response": "Adds cookies to a WebDriver session."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configure(self, options, conf):\n        self.conf = conf\n        self.when = options.browser_closer_when", "response": "Configure plugin. Plugin is enabled by default."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nindex a path. :param root: Either a package directory, a .so or a .py module.", "response": "def index_path(self, root):\n        \"\"\"Index a path.\n\n        :param root: Either a package directory, a .so or a .py module.\n        \"\"\"\n        basename = os.path.basename(root)\n        if os.path.splitext(basename)[0] != '__init__' and basename.startswith('_'):\n            return\n        location = self._determine_location_for(root)\n        if os.path.isfile(root):\n            self._index_module(root, location)\n        elif os.path.isdir(root) and os.path.exists(os.path.join(root, '__init__.py')):\n            self._index_package(root, location)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget or create an index for the current object.", "response": "def get_or_create_index(self, paths=None, name=None, refresh=False):\n        \"\"\"\n        Get index with given name from cache. Create if it doesn't exists.\n        \"\"\"\n        if not paths:\n            paths = sys.path\n        if not name:\n            name = 'default'\n        self._name = name\n\n        idx_dir = get_cache_dir()\n        idx_file = os.path.join(idx_dir, name + '.json')\n\n        if os.path.exists(idx_file) and not refresh:\n            with open(idx_file) as fd:\n                self.deserialize(fd)\n        else:\n            self.build_index(paths)\n            with open(idx_file, 'w') as fd:\n                self.serialize(fd)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds matches for a given symbol.", "response": "def symbol_scores(self, symbol):\n        \"\"\"Find matches for symbol.\n\n        :param symbol: A . separated symbol. eg. 'os.path.basename'\n        :returns: A list of tuples of (score, package, reference|None),\n            ordered by score from highest to lowest.\n        \"\"\"\n        scores = []\n        path = []\n\n        # sys.path              sys path          ->    import sys\n        # os.path.basename      os.path basename  ->    import os.path\n        # basename              os.path basename   ->   from os.path import basename\n        # path.basename         os.path basename   ->   from os import path\n        def fixup(module, variable):\n            prefix = module.split('.')\n            if variable is not None:\n                prefix.append(variable)\n            seeking = symbol.split('.')\n            new_module = []\n            while prefix and seeking[0] != prefix[0]:\n                new_module.append(prefix.pop(0))\n            if new_module:\n                module, variable = '.'.join(new_module), prefix[0]\n            else:\n                variable = None\n            return module, variable\n\n        def score_walk(scope, scale):\n            sub_path, score = self._score_key(scope, full_key)\n            if score > 0.1:\n                try:\n                    i = sub_path.index(None)\n                    sub_path, from_symbol = sub_path[:i], '.'.join(sub_path[i + 1:])\n                except ValueError:\n                    from_symbol = None\n                package_path = '.'.join(path + sub_path)\n                package_path, from_symbol = fixup(package_path, from_symbol)\n                scores.append((score * scale, package_path, from_symbol))\n\n            for key, subscope in scope._tree.items():\n                if type(subscope) is not float:\n                    path.append(key)\n                    score_walk(subscope, subscope.score * scale - 0.1)\n                    path.pop()\n\n        full_key = symbol.split('.')\n        score_walk(self, 1.0)\n        scores.sort(reverse=True)\n        return scores"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the node for a path or None.", "response": "def find(self, path):\n        \"\"\"Return the node for a path, or None.\"\"\"\n        path = path.split('.')\n        node = self\n        while node._parent:\n            node = node._parent\n        for name in path:\n            node = node._tree.get(name, None)\n            if node is None or type(node) is float:\n                return None\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the location code for a path.", "response": "def location_for(self, path):\n        \"\"\"Return the location code for a path.\"\"\"\n        path = path.split('.')\n        node = self\n        while node._parent:\n            node = node._parent\n        location = node.location\n        for name in path:\n            tree = node._tree.get(name, None)\n            if tree is None or type(tree) is float:\n                return location\n            location = tree.location\n        return location"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_option(self, option):\n        items_list = self.get_options()\n        for item in items_list:\n            if item.get_attribute(\"value\") == option:\n                item.click()\n                break", "response": "Selects the specified item from Web List"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_attribute_selected(self, attribute):\n        items_list = self.get_options()\n        return next(iter([item.get_attribute(attribute) for item in items_list if item.is_selected()]), None)", "response": "Returns the attribute of selected item from Web List\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for an item in the Web List by the visible text.", "response": "def select_by_visible_text(self, text):\n        \"\"\"\n        Performs search of selected item from Web List\n\n        @params text - string visible text\n        \"\"\"\n        xpath = './/option[normalize-space(.) = {0}]'.format(self._escape_string(text))\n        opts = self.find_elements_by_xpath(xpath)\n        matched = False\n        for opt in opts:\n            self._set_selected(opt)\n            if not self.is_multiple:\n                return\n            matched = True\n        # in case the target option isn't found by xpath\n        # attempt to find it by direct comparison among options which contain at least the longest token from the text\n        if len(opts) == 0 and ' ' in text:\n            sub_string_without_space = self._get_longest_token(text)\n            if sub_string_without_space == \"\":\n                candidates = self.get_options()\n            else:\n                xpath = \".//option[contains(.,{0})]\".format(self._escape_string(sub_string_without_space))\n                candidates = self.find_elements_by_xpath(xpath)\n            for candidate in candidates:\n                if text == candidate.text:\n                    self._set_selected(candidate)\n                    if not self.is_multiple:\n                        return\n                    matched = True\n        if not matched:\n            raise NoSuchElementException(\"Could not locate element with visible text: \" + str(text))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping the wait method of waiting library with default parameter values.", "response": "def wait(*args, **kwargs):\n    \"\"\"\n    Wrapping 'wait()' method of 'waiting' library with default parameter values.\n    WebDriverException is ignored in the expected exceptions by default.\n    \"\"\"\n    kwargs.setdefault('sleep_seconds', (1, None))\n    kwargs.setdefault('expected_exceptions', WebDriverException)\n    kwargs.setdefault('timeout_seconds', webium.settings.wait_timeout)\n\n    return wait_lib(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_ast(source, filename=None):\n    if isinstance(source, text_type) and sys.version_info[0] == 2:\n        # ast.parse() on Python 2 doesn't like encoding declarations\n        # in Unicode strings\n        source = CODING_COOKIE_RE.sub(r'\\1', source, 1)\n    return ast.parse(source, filename or '<unknown>')", "response": "Parse source into a Python AST taking care of encoding."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds any unresolved symbols and unreferenced symbols from this scope.", "response": "def find_unresolved_and_unreferenced_symbols(self):\n        \"\"\"Find any unresolved symbols, and unreferenced symbols from this scope.\n\n        :returns: ({unresolved}, {unreferenced})\n        \"\"\"\n        unresolved = set()\n        unreferenced = self._definitions.copy()\n        self._collect_unresolved_and_unreferenced(set(), set(), unresolved, unreferenced,\n                                                  frozenset(self._definitions), start=True)\n        return unresolved, unreferenced - Scope.ALL_BUILTINS"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn content in JSON format", "response": "def get_item(key):\r\n    \"\"\"Return content in cached file in JSON format\"\"\"\r\n    CACHED_KEY_FILE = os.path.join(CURRENT_DIR, key)\r\n\r\n    try:\r\n        return json.loads(open(CACHED_KEY_FILE, \"rb\").read().decode('UTF-8'))[\"_\"]\r\n    except (IOError, ValueError):\r\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_item(key,value):\r\n    CACHED_KEY_FILE = os.path.join(CURRENT_DIR, key)\r\n\r\n    open(CACHED_KEY_FILE, \"wb\").write(json.dumps({\"_\": value}).encode('UTF-8'))\r\n\r\n    return value", "response": "Write JSON content from value argument to cached file and return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the item from the cache if present", "response": "def delete_item(key):\r\n    \"\"\"Delete cached file if present\"\"\"\r\n    CACHED_KEY_FILE = os.path.join(CURRENT_DIR, key)\r\n\r\n    if os.path.isfile(CACHED_KEY_FILE):\r\n        os.remove(CACHED_KEY_FILE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __parse_json_data(self, data):\n        if isinstance(data, dict) or isinstance(data, list):\n            self._raw_data = data\n            self._json_data = copy.deepcopy(self._raw_data)\n        else:\n            raise TypeError(\"Provided Data is not json\")", "response": "Process Json data\n\n        :@param data\n        :@type data: json/dict\n\n        :throws TypeError"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the Json file and store the result in self. _json_data.", "response": "def __parse_json_file(self, file_path):\n        \"\"\"Process Json file data\n\n        :@param file_path\n        :@type file_path: string\n\n        :@throws IOError\n        \"\"\"\n        if file_path == '' or os.path.splitext(file_path)[1] != '.json':\n            raise IOError('Invalid Json file')\n\n        with open(file_path) as json_file:\n            self._raw_data = json.load(json_file)\n\n        self._json_data = copy.deepcopy(self._raw_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds value from json data", "response": "def __get_value_from_data(self, key, data):\n        \"\"\"Find value from json data\n\n        :@pram key\n        :@type: string\n\n        :@pram data\n        :@type data: dict\n\n        :@return object\n        :@throws KeyError\n        \"\"\"\n        if key.isdigit():\n            return data[int(key)]\n\n        if key not in data:\n            raise KeyError(\"Key not exists\")\n\n        return data.get(key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef at(self, root):\n        leafs = root.strip(\" \").split('.')\n        for leaf in leafs:\n            if leaf:\n                self._json_data = self.__get_value_from_data(leaf, self._json_data)\n        return self", "response": "Set the object to be the value of the root where PyJsonq start"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets the object s data according to given data or previously given raw Json data.", "response": "def reset(self, data={}):\n        \"\"\"JsonQuery object cen be reset to new data\n\n        according to given data or previously given raw Json data\n\n        :@param data: {}\n        :@type data: json/dict\n\n        :@return self\n        \"\"\"\n        if data and (isinstance(data, dict) or isinstance(data, list)):\n            self._json_data = data\n        else:\n            self._json_data = copy.deepcopy(self._raw_data)\n\n        self.__reset_queries()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __store_query(self, query_items):\n        temp_index = self._current_query_index\n        if len(self._queries) - 1 < temp_index:\n            self._queries.append([])\n\n        self._queries[temp_index].append(query_items)", "response": "Store the query items in the where clause."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __execute_queries(self):\n\n        def func(item):\n            or_check = False\n            for queries in self._queries:\n                and_check = True\n                for query in queries:\n                    and_check &= self._matcher._match(\n                        item.get(query.get('key'), None),\n                        query.get('operator'),\n                        query.get('value')\n                    )\n                or_check |= and_check\n            return or_check\n\n        self._json_data = list(filter(lambda item: func(item), self._json_data))", "response": "Execute all condition and filter result data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef where(self, key, operator, value):\n        self.__store_query({\"key\": key, \"operator\": operator, \"value\": value})\n        return self", "response": "Make where clause\n\n        :@param key\n        :@param operator\n        :@param value\n        :@type key,operator,value: string\n\n        :@return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef or_where(self, key, operator, value):\n        if len(self._queries) > 0:\n            self._current_query_index += 1\n        self.__store_query({\"key\": key, \"operator\": operator, \"value\": value})\n        return self", "response": "Make an or where clause"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the nth element of the collection", "response": "def nth(self, index):\n        \"\"\"Getting the nth element of the collection\n\n        :@param index\n        :@type index: int\n\n        :@return object\n        \"\"\"\n        self.__prepare()\n        return None if self.count() < math.fabs(index) else self._json_data[index]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the sum of the values of the given property", "response": "def sum(self, property):\n        \"\"\"Getting the sum according to the given property\n\n        :@param property\n        :@type property: string\n\n        :@return int/float\n        \"\"\"\n        self.__prepare()\n        total = 0\n        for i in self._json_data:\n            total += i.get(property)\n\n        return total"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef max(self, property):\n        self.__prepare()\n        try:\n            return max(self._json_data, key=lambda x: x[property]).get(property)\n        except KeyError:\n            raise KeyError(\"Key is not exists\")", "response": "Gets the maximum value from the prepared data\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the average value according to given property", "response": "def avg(self, property):\n        \"\"\"Getting average according to given property\n\n        :@param property\n        :@type property: string\n\n        :@return average: int/float\n        \"\"\"\n        self.__prepare()\n        return self.sum(property) / self.count()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngroup the resulted collection to multiple chunk size", "response": "def chunk(self, size=0):\n        \"\"\"Group the resulted collection to multiple chunk\n\n        :@param size: 0\n        :@type size: integer\n\n        :@return Chunked List\n        \"\"\"\n\n        if size == 0:\n            raise ValueError('Invalid chunk size')\n\n        self.__prepare()\n        _new_content = []\n\n        while(len(self._json_data) > 0):\n            _new_content.append(self._json_data[0:size])\n            self._json_data = self._json_data[size:]\n\n        self._json_data = _new_content\n\n        return self._json_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef group_by(self, property):\n        self.__prepare()\n        group_data = {}\n        for data in self._json_data:\n            if data[property] not in group_data:\n                group_data[data[property]] = []\n            group_data[data[property]].append(data)\n        self._json_data = group_data\n\n        return self", "response": "Get the grouped result by the given property"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the sorted result of the given list", "response": "def sort(self, order=\"asc\"):\n        \"\"\"Getting the sorted result of the given list\n\n        :@param order: \"asc\"\n        :@type order: string\n\n        :@return self\n        \"\"\"\n        self.__prepare()\n        if isinstance(self._json_data, list):\n            if order == \"asc\":\n                self._json_data = sorted(self._json_data)\n            else:\n                self._json_data = sorted(self._json_data, reverse=True)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the sorted result by the given property", "response": "def sort_by(self, property, order=\"asc\"):\n        \"\"\"Getting the sorted result by the given property\n\n        :@param property, order: \"asc\"\n        :@type property, order: string\n\n        :@return self\n        \"\"\"\n        self.__prepare()\n        if isinstance(self._json_data, list):\n            if order == \"asc\":\n                self._json_data = sorted(\n                    self._json_data,\n                    key=lambda x: x.get(property)\n                )\n            else:\n                self._json_data = sorted(\n                    self._json_data,\n                    key=lambda x: x.get(property),\n                    reverse=True\n                )\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompare the given x and y based on op.", "response": "def _match(self, x, op, y):\n        \"\"\"Compare the given `x` and `y` based on `op`\n\n        :@param x, y, op\n        :@type x, y: mixed\n        :@type op: string\n\n        :@return bool\n        :@throws ValueError\n        \"\"\"\n        if (op not in self.condition_mapper):\n            raise ValueError('Invalid where condition given')\n\n        func = getattr(self, self.condition_mapper.get(op))\n        return func(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_base_class_names(frame):\n    co, lasti = frame.f_code, frame.f_lasti\n    code = co.co_code\n\n    extends = []\n    for (op, oparg) in op_stream(code, lasti):\n        if op in dis.hasconst:\n            if type(co.co_consts[oparg]) == str:\n                extends = []\n        elif op in dis.hasname:\n            if dis.opname[op] == 'LOAD_NAME':\n                extends.append(('name', co.co_names[oparg]))\n            if dis.opname[op] == 'LOAD_ATTR':\n                extends.append(('attr', co.co_names[oparg]))\n            if dis.opname[op] == 'LOAD_GLOBAL':\n                extends.append(('name', co.co_names[oparg]))\n\n    items = []\n    previous_item = []\n    for t, s in extends:\n        if t == 'name':\n            if previous_item:\n                items.append(previous_item)\n            previous_item = [s]\n        else:\n            previous_item += [s]\n    if previous_item:\n        items.append(previous_item)\n    return items", "response": "Get baseclass names from the code object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the charset of the message", "response": "def get_charset(message, default=\"utf-8\"):\n    \"\"\"Get the message charset\"\"\"\n    if message.get_content_charset():\n        return message.get_content_charset()\n    if message.get_charset():\n        return message.get_charset()\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_tlds():\n    file = os.path.join(os.path.dirname(__file__),\n                        'assets',\n                        'tlds-alpha-by-domain.txt')\n    with open(file) as fobj:\n        return [elem for elem in fobj.read().lower().splitlines()[1:]\n                if \"--\" not in elem]", "response": "Load all legal TLD extensions from assets\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_text_urls(mesg):\n\n    rval = []\n\n    loc = 0\n\n    for match in URLRE.finditer(mesg):\n        if loc < match.start():\n            rval.append(Chunk(mesg[loc:match.start()], None))\n        # Turn email addresses into mailto: links\n        email = match.group(\"email\")\n        if email and \"mailto\" not in email:\n            mailto = \"mailto:{}\".format(email)\n        else:\n            mailto = match.group(1)\n        rval.append(Chunk(None, mailto))\n        loc = match.end()\n\n    if loc < len(mesg):\n        rval.append(Chunk(mesg[loc:], None))\n\n    return rval", "response": "Parse a block of text into its url and non - url components."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract URL and context from a given list of strings.", "response": "def extract_with_context(lst, pred, before_context, after_context):\n    \"\"\"Extract URL and context from a given chunk.\n\n    \"\"\"\n    rval = []\n\n    start = 0\n    length = 0\n    while start < len(lst):\n        usedfirst = False\n        usedlast = False\n        # Extend to the next match.\n        while start + length < len(lst) and length < before_context + 1 \\\n                and not pred(lst[start + length]):\n            length += 1\n\n        # Slide to the next match.\n        while start + length < len(lst) and not pred(lst[start + length]):\n            start += 1\n\n        # If there was no next match, abort here (it's easier\n        # to do this than to try to detect this case later).\n        if start + length == len(lst):\n            break\n\n        # Now extend repeatedly until we can't find anything.\n        while start + length < len(lst) and pred(lst[start + length]):\n            extendlength = 1\n            # Read in the 'after' context and see if it holds a URL.\n            while extendlength < after_context + 1 and start + length + \\\n                    extendlength < len(lst) and \\\n                    not pred(lst[start + length + extendlength]):\n                extendlength += 1\n            length += extendlength\n            if start + length < len(lst) and not pred(lst[start + length]):\n                # Didn't find a matching line, so we either\n                # hit the end or extended to after_context + 1..\n                #\n                # Now read in possible 'before' context\n                # from the next URL; if we don't find one,\n                # we discard the readahead.\n                extendlength = 1\n                while extendlength < before_context and start + length + \\\n                        extendlength < len(lst) and \\\n                        not pred(lst[start + length + extendlength]):\n                    extendlength += 1\n                if start + length + extendlength < len(lst) and \\\n                        pred(lst[start + length + extendlength]):\n                    length += extendlength\n\n        if length > 0 and start + length <= len(lst):\n            if start == 0:\n                usedfirst = True\n            if start + length == len(lst):\n                usedlast = True\n            rval.append((lst[start:start + length], usedfirst, usedlast))\n\n        start += length\n        length = 0\n    return rval"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a text message extract all the URLs found in the message along with their surrounding context.", "response": "def extracturls(mesg):\n    \"\"\"Given a text message, extract all the URLs found in the message, along\n    with their surrounding context.  The output is a list of sequences of Chunk\n    objects, corresponding to the contextual regions extracted from the string.\n\n    \"\"\"\n    lines = NLRE.split(mesg)\n\n    # The number of lines of context above to provide.\n    # above_context = 1\n    # The number of lines of context below to provide.\n    # below_context = 1\n\n    # Plan here is to first transform lines into the form\n    # [line_fragments] where each fragment is a chunk as\n    # seen by parse_text_urls.  Note that this means that\n    # lines with more than one entry or one entry that's\n    # a URL are the only lines containing URLs.\n\n    linechunks = [parse_text_urls(l) for l in lines]\n\n    return extract_with_context(linechunks,\n                                lambda chunk: len(chunk) > 1 or\n                                (len(chunk) == 1 and chunk[0].url is not None),\n                                1, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extracthtmlurls(mesg):\n    chunk = HTMLChunker()\n    chunk.feed(mesg)\n    chunk.close()\n    # above_context = 1\n    # below_context = 1\n\n    def somechunkisurl(chunks):\n        for chnk in chunks:\n            if chnk.url is not None:\n                return True\n        return False\n\n    return extract_with_context(chunk.rval, somechunkisurl, 1, 1)", "response": "Extract URLs with context from html type message. Similar to extracturls.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a byte string or bytes input return a string.", "response": "def decode_bytes(byt, enc='utf-8'):\n    \"\"\"Given a string or bytes input, return a string.\n\n        Args: bytes - bytes or string\n              enc - encoding to use for decoding the byte string.\n\n    \"\"\"\n    try:\n        strg = byt.decode(enc)\n    except UnicodeDecodeError as err:\n        strg = \"Unable to decode message:\\n{}\\n{}\".format(str(byt), err)\n    except (AttributeError, UnicodeEncodeError):\n        # If byt is already a string, just return it\n        return byt\n    return strg"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_msg(msg, enc='utf-8'):\n    # We avoid the get_payload decoding machinery for raw\n    # content-transfer-encodings potentially containing non-ascii characters,\n    # such as 8bit or binary, as these are encoded using raw-unicode-escape which\n    # seems to prevent subsequent utf-8 decoding.\n    cte = str(msg.get('content-transfer-encoding', '')).lower()\n    decode = cte not in (\"8bit\", \"7bit\", \"binary\")\n    res = msg.get_payload(decode=decode)\n    return decode_bytes(res, enc)", "response": "Decodes a message fragment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef msgurls(msg, urlidx=1):\n    # Written as a generator so I can easily choose only\n    # one subpart in the future (e.g., for\n    # multipart/alternative).  Actually, I might even add\n    # a browser for the message structure?\n    enc = get_charset(msg)\n    if msg.is_multipart():\n        for part in msg.get_payload():\n            for chunk in msgurls(part, urlidx):\n                urlidx += 1\n                yield chunk\n    elif msg.get_content_type() == \"text/plain\":\n        decoded = decode_msg(msg, enc)\n        for chunk in extracturls(decoded):\n            urlidx += 1\n            yield chunk\n    elif msg.get_content_type() == \"text/html\":\n        decoded = decode_msg(msg, enc)\n        for chunk in extracthtmlurls(decoded):\n            urlidx += 1\n            yield chunk", "response": "Yields all the urls in a message."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshortens long URLs to fit on one line.", "response": "def shorten_url(url, cols, shorten):\n    \"\"\"Shorten long URLs to fit on one line.\n\n    \"\"\"\n    cols = ((cols - 6) * .85)  # 6 cols for urlref and don't use while line\n    if shorten is False or len(url) < cols:\n        return url\n    split = int(cols * .5)\n    return url[:split] + \"...\" + url[-split:]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef grp_list(items):\n    grp = []\n    res = []\n    for item in items:\n        if isinstance(item, urwid.Divider):\n            res.append(grp)\n            grp = [items[0]]\n        else:\n            grp.append(item)\n    res.append(grp)\n    return res[1:]", "response": "Organize list of items like a 2 3 4 2 1 etc..."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef splittext(text, search, attr):\n    if search:\n        pat = re.compile(\"({})\".format(re.escape(search)), re.IGNORECASE)\n    else:\n        return text\n    final = pat.split(text)\n    final = [(attr, i) if i.lower() == search.lower() else i for i in final]\n    return final", "response": "Split a text string by search string and add Urwid display attribute to\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_keys(self, keys, raw):\n        for j, k in enumerate(keys):\n            if self.search is True:\n                text = \"Search: {}\".format(self.search_string)\n                if k == 'enter':\n                    # Catch 'enter' key to prevent opening URL in mkbrowseto\n                    self.enter = True\n                    if not self.items:\n                        self.search = False\n                        self.enter = False\n                    if self.search_string:\n                        footer = 'search'\n                    else:\n                        footer = 'default'\n                        text = \"\"\n                    footerwid = urwid.AttrMap(urwid.Text(text), footer)\n                    self.top.footer = footerwid\n                elif k in self.activate_keys:\n                    self.search_string += k\n                    self._search()\n                elif k == 'backspace':\n                    self.search_string = self.search_string[:-1]\n                    self._search()\n            elif k in self.activate_keys and \\\n                    self.urls and \\\n                    self.search is False and \\\n                    self.help_menu is False:\n                self._open_url()\n            elif self.help_menu is True:\n                self._help_menu()\n                return []\n            if k == 'up':\n                # Works around bug where the up arrow goes higher than the top list\n                # item and unintentionally triggers context and palette switches.\n                # Remaps 'up' to 'k'\n                keys[j] = 'k'\n            if k == 'home':\n                # Remap 'home' to 'g'. Works around small bug where 'home' takes the cursor\n                # above the top list item.\n                keys[j] = 'g'\n        # filter backspace out before the widget, it has a weird interaction\n        return [i for i in keys if i != 'backspace']", "response": "Handles the keys in the list and returns a list of the keys that are handled"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles other keyboard actions not handled by the ListBox widget.", "response": "def unhandled(self, key):\n        \"\"\"Handle other keyboard actions not handled by the ListBox widget.\n\n        \"\"\"\n        self.key = key\n        self.size = self.tui.get_cols_rows()\n        if self.search is True:\n            if self.enter is False and self.no_matches is False:\n                if len(key) == 1 and key.isprintable():\n                    self.search_string += key\n                self._search()\n            elif self.enter is True and not self.search_string:\n                self.search = False\n                self.enter = False\n            return\n        if not self.urls and key not in \"Qq\":\n            return  # No other actions are useful with no URLs\n        if self.help_menu is False:\n            try:\n                self.keys[key]()\n            except KeyError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _search_key(self):\n        if self.urls:\n            self.search = True\n            if self.compact is True:\n                self.compact = False\n                self.items, self.items_com = self.items_com, self.items\n        else:\n            return\n        self.no_matches = False\n        self.search_string = \"\"\n        # Reset the search highlighting\n        self._search()\n        footerwid = urwid.AttrMap(urwid.Text(\"Search: \"), 'footer')\n        self.top.footer = footerwid\n        self.items = self.items_orig\n        self.top.body = urwid.ListBox(self.items)", "response": "Set the search key to True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the number of the items in the page.", "response": "def _digits(self):\n        \"\"\" 0-9 \"\"\"\n        self.number += self.key\n        try:\n            if self.compact is False:\n                self.top.body.focus_position = \\\n                    self.items.index(self.items_com[max(int(self.number) - 1, 0)])\n            else:\n                self.top.body.focus_position = \\\n                    self.items.index(self.items[max(int(self.number) - 1, 0)])\n        except IndexError:\n            self.number = self.number[:-1]\n        self.top.keypress(self.size, \"\")  # Trick urwid into redisplaying the cursor\n        if self.number:\n            self._footer_start_thread(\"Selection: {}\".format(self.number), 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _top(self):\n        # Goto top of the list\n        self.top.body.focus_position = 2 if self.compact is False else 0\n        self.top.keypress(self.size, \"\")", "response": "g Move to the top of the list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _shorten(self):\n        # Toggle shortened URL for selected item\n        fpo = self.top.body.focus_position\n        url_idx = len([i for i in self.items[:fpo + 1]\n                       if isinstance(i, urwid.Columns)]) - 1\n        if self.compact is False and fpo <= 1:\n            return\n        url = self.urls[url_idx]\n        short = not \"...\" in self.items[fpo][1].label\n        self.items[fpo][1].set_label(shorten_url(url, self.size[0], short))", "response": "s Shortens the URL for the currently selected item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _all_escape(self):\n        # Toggle all escaped URLs\n        self.unesc = not self.unesc\n        self.urls, self.urls_unesc = self.urls_unesc, self.urls\n        urls = iter(self.urls)\n        for item in self.items:\n            # Each Column has (Text, Button). Update the Button label\n            if isinstance(item, urwid.Columns):\n                item[1].set_label(shorten_url(next(urls),\n                                              self.size[0],\n                                              self.shorten))", "response": "u Update all escaped URLs and URLs in the tables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _context(self):\n        # Show/hide context\n        if self.search_string:\n            # Reset search when toggling compact mode\n            footerwid = urwid.AttrMap(urwid.Text(\"\"), 'default')\n            self.top.footer = footerwid\n            self.search_string = \"\"\n            self.items = self.items_orig\n        fpo = self.top.body.focus_position\n        self.items, self.items_com = self.items_com, self.items\n        self.top.body = urwid.ListBox(self.items)\n        self.top.body.focus_position = self._cur_focus(fpo)\n        self.compact = not self.compact", "response": "c Shows context in the top widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _palette(self):\n        # Loop through available palettes\n        self.palette_idx += 1\n        try:\n            self.loop.screen.register_palette(self.palettes[self.palette_names[self.palette_idx]])\n        except IndexError:\n            self.loop.screen.register_palette(self.palettes[self.palette_names[0]])\n            self.palette_idx = 0\n        self.loop.screen.clear()", "response": "p Registers the current palette in the loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates config. json file if it doesn t exist.", "response": "def _config_create(self):\n        \"\"\" --genconf \"\"\"\n        # Create ~/.config/urlscan/config.json if if doesn't exist\n        if not exists(self.conf):\n            try:\n                # Python 2/3 compatible recursive directory creation\n                os.makedirs(dirname(expanduser(self.conf)))\n            except OSError as err:\n                if errno.EEXIST != err.errno:\n                    raise\n            keys = dict(zip(self.keys.keys(),\n                            [i.__name__.strip('_') for i in self.keys.values()]))\n            with open(expanduser(self.conf), 'w') as pals:\n                pals.writelines(json.dumps({\"palettes\": self.palettes, \"keys\": keys},\n                                           indent=4))\n            print(\"Created ~/.config/urlscan/config.json\")\n        else:\n            print(\"~/.config/urlscan/config.json already exists\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _footer_start_thread(self, text, time):\n        footerwid = urwid.AttrMap(urwid.Text(text), 'footer')\n        self.top.footer = footerwid\n        load_thread = Thread(target=self._loading_thread, args=(time,))\n        load_thread.daemon = True\n        load_thread.start()", "response": "Display given text in the footer. Clears after time seconds\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches - Search URLs and text.", "response": "def _search(self):\n        \"\"\" Search - search URLs and text.\n\n        \"\"\"\n        text = \"Search: {}\".format(self.search_string)\n        footerwid = urwid.AttrMap(urwid.Text(text), 'footer')\n        self.top.footer = footerwid\n        search_items = []\n        for grp in self.items_org:\n            done = False\n            for idx, item in enumerate(grp):\n                if isinstance(item, urwid.Columns):\n                    for col_idx, col in enumerate(item.contents):\n                        if isinstance(col[0], urwid.decoration.AttrMap):\n                            grp[idx][col_idx].set_label(splittext(col[0].base_widget.label,\n                                                                  self.search_string,\n                                                                  ''))\n                            if self.search_string.lower() in col[0].base_widget.label.lower():\n                                grp[idx][col_idx].set_label(splittext(col[0].base_widget.label,\n                                                                      self.search_string,\n                                                                      'search'))\n                                done = True\n                elif isinstance(item, urwid.Text):\n                    grp[idx].set_text(splittext(item.text, self.search_string, ''))\n                    if self.search_string.lower() in item.text.lower():\n                        grp[idx].set_text(splittext(item.text, self.search_string, 'search'))\n                        done = True\n            if done is True:\n                search_items.extend(grp)\n        self.items = search_items\n        self.top.body = urwid.ListBox(self.items)\n        if self.items:\n            self.top.body.focus_position = 2 if self.compact is False else 0\n            # Trick urwid into redisplaying the cursor\n            self.top.keypress(self.tui.get_cols_rows(), \"\")\n            self.no_matches = False\n        else:\n            self.no_matches = True\n            footerwid = urwid.AttrMap(urwid.Text(text + \"  No Matches\"), 'footer')\n            self.top.footer = footerwid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate the urwid callback function to open the web browser or call another function with the URL.", "response": "def mkbrowseto(self, url):\n        \"\"\"Create the urwid callback function to open the web browser or call\n        another function with the URL.\n\n        \"\"\"\n        # Try-except block to work around webbrowser module bug\n        # https://bugs.python.org/issue31014\n        try:\n            browser = os.environ['BROWSER']\n        except KeyError:\n            pass\n        else:\n            del os.environ['BROWSER']\n            webbrowser.register(browser, None, webbrowser.GenericBrowser(browser))\n            try_idx = webbrowser._tryorder.index(browser)\n            webbrowser._tryorder.insert(0, webbrowser._tryorder.pop(try_idx))\n\n        def browse(*args):\n            # double ()() to ensure self.search evaluated at runtime, not when\n            # browse() is _created_. [0] is self.search, [1] is self.enter\n            # self.enter prevents opening URL when in search mode\n            if self._get_search()[0]() is True:\n                if self._get_search()[1]() is True:\n                    self.search = False\n                    self.enter = False\n            elif not self.run:\n                webbrowser.open(url)\n            elif self.run and self.pipe:\n                process = Popen(shlex.split(self.run), stdout=PIPE, stdin=PIPE)\n                process.communicate(input=url.encode(sys.getdefaultencoding()))\n            else:\n                Popen(self.run.format(url), shell=True).communicate()\n\n            size = self.tui.get_cols_rows()\n            self.draw_screen(size)\n        return browse"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the extractedurls and ready them for the curses browser or non - interactive output.", "response": "def process_urls(self, extractedurls, dedupe, shorten):\n        \"\"\"Process the 'extractedurls' and ready them for either the curses browser\n        or non-interactive output\n\n        Args: extractedurls\n              dedupe - Remove duplicate URLs from list\n\n        Returns: items - List of widgets for the ListBox\n                 urls - List of all URLs\n\n        \"\"\"\n        cols, _ = urwid.raw_display.Screen().get_cols_rows()\n        items = []\n        urls = []\n        first = True\n        for group, usedfirst, usedlast in extractedurls:\n            if first:\n                first = False\n            items.append(urwid.Divider(div_char='-', top=1, bottom=1))\n            if dedupe is True:\n                # If no unique URLs exist, then skip the group completely\n                if not [chunk for chunks in group for chunk in chunks\n                        if chunk.url is not None and chunk.url not in urls]:\n                    continue\n            groupurls = []\n            markup = []\n            if not usedfirst:\n                markup.append(('msgtext:ellipses', '...\\n'))\n            for chunks in group:\n                i = 0\n                while i < len(chunks):\n                    chunk = chunks[i]\n                    i += 1\n                    if chunk.url is None:\n                        markup.append(('msgtext', chunk.markup))\n                    else:\n                        if (dedupe is True and chunk.url not in urls) \\\n                                or dedupe is False:\n                            urls.append(chunk.url)\n                            groupurls.append(chunk.url)\n                        # Collect all immediately adjacent\n                        # chunks with the same URL.\n                        tmpmarkup = []\n                        if chunk.markup:\n                            tmpmarkup.append(('msgtext', chunk.markup))\n                        while i < len(chunks) and \\\n                                chunks[i].url == chunk.url:\n                            if chunks[i].markup:\n                                tmpmarkup.append(chunks[i].markup)\n                            i += 1\n                        url_idx = urls.index(chunk.url) + 1 if dedupe is True else len(urls)\n                        markup += [tmpmarkup or '<URL>',\n                                   ('urlref:number:braces', ' ['),\n                                   ('urlref:number', repr(url_idx)),\n                                   ('urlref:number:braces', ']')]\n                markup += '\\n'\n            if not usedlast:\n                markup += [('msgtext:ellipses', '...\\n\\n')]\n            items.append(urwid.Text(markup))\n\n            i = len(urls) - len(groupurls)\n            for url in groupurls:\n                i += 1\n                markup = [(6, urwid.Text([('urlref:number:braces', '['),\n                                          ('urlref:number', repr(i)),\n                                          ('urlref:number:braces', ']'),\n                                          ' '])),\n                          urwid.AttrMap(urwid.Button(shorten_url(url,\n                                                                 cols,\n                                                                 shorten),\n                                                     self.mkbrowseto(url),\n                                                     user_data=url),\n                                        'urlref:url', 'url:sel')]\n                items.append(urwid.Columns(markup))\n\n        return items, urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the key file path.", "response": "def _get_key_file_path():\n        \"\"\"Return the key file path.\"\"\"\n        if os.getenv(USER_HOME) is not None and os.access(os.getenv(USER_HOME),\n                                                          os.W_OK):\n            return os.path.join(os.getenv(USER_HOME), KEY_FILE_NAME)\n\n        return os.path.join(os.getcwd(), KEY_FILE_NAME)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_key_file(self):\n        self.client_key = None\n        if self.key_file_path:\n            key_file_path = self.key_file_path\n        else:\n            key_file_path = self._get_key_file_path()\n        key_dict = {}\n\n        logger.debug('load keyfile from %s', key_file_path);\n\n        if os.path.isfile(key_file_path):\n            with open(key_file_path, 'r') as f:\n                raw_data = f.read()\n                if raw_data:\n                    key_dict = json.loads(raw_data)\n\n        logger.debug('getting client_key for %s from %s', self.ip, key_file_path);\n        if self.ip in key_dict:\n            self.client_key = key_dict[self.ip]", "response": "Try to load the client key for the current ip."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_key_file(self):\n        if self.client_key is None:\n            return\n\n        if self.key_file_path:\n            key_file_path = self.key_file_path\n        else:\n            key_file_path = self._get_key_file_path()\n\n        logger.debug('save keyfile to %s', key_file_path);\n\n        with open(key_file_path, 'w+') as f:\n            raw_data = f.read()\n            key_dict = {}\n\n            if raw_data:\n                key_dict = json.loads(raw_data)\n\n            key_dict[self.ip] = self.client_key\n\n            f.write(json.dumps(key_dict))", "response": "Save the current client key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _send_register_payload(self, websocket):\n        file = os.path.join(os.path.dirname(__file__), HANDSHAKE_FILE_NAME)\n\n        data = codecs.open(file, 'r', 'utf-8')\n        raw_handshake = data.read()\n\n        handshake = json.loads(raw_handshake)\n        handshake['payload']['client-key'] = self.client_key\n\n        yield from websocket.send(json.dumps(handshake))\n        raw_response = yield from websocket.recv()\n        response = json.loads(raw_response)\n\n        if response['type'] == 'response' and \\\n                        response['payload']['pairingType'] == 'PROMPT':\n            raw_response = yield from websocket.recv()\n            response = json.loads(raw_response)\n            if response['type'] == 'registered':\n                self.client_key = response['payload']['client-key']\n                self.save_key_file()", "response": "Send the register payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npair client with tv.", "response": "def register(self):\n        \"\"\"Pair client with tv.\"\"\"\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.run_until_complete(self._register())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _command(self, msg):\n        logger.debug('send command to %s', \"ws://{}:{}\".format(self.ip, self.port));\n        try:\n            websocket = yield from websockets.connect(\n                \"ws://{}:{}\".format(self.ip, self.port), timeout=self.timeout_connect)\n        except:\n            logger.debug('command failed to connect to %s', \"ws://{}:{}\".format(self.ip, self.port));\n            return False\n\n        logger.debug('command websocket connected to %s', \"ws://{}:{}\".format(self.ip, self.port));\n\n        try:\n            yield from self._send_register_payload(websocket)\n\n            if not self.client_key:\n                raise PyLGTVPairException(\"Unable to pair\")\n\n            yield from websocket.send(json.dumps(msg))\n\n            if msg['type'] == 'request':\n                raw_response = yield from websocket.recv()\n                self.last_response = json.loads(raw_response)\n\n        finally:\n            logger.debug('close command connection to %s', \"ws://{}:{}\".format(self.ip, self.port));\n            yield from websocket.close()", "response": "Send a command to the tv."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds and send a command.", "response": "def command(self, request_type, uri, payload):\n        \"\"\"Build and send a command.\"\"\"\n        self.command_count += 1\n\n        if payload is None:\n            payload = {}\n\n        message = {\n            'id': \"{}_{}\".format(type, self.command_count),\n            'type': request_type,\n            'uri': \"ssap://{}\".format(uri),\n            'payload': payload,\n        }\n\n        self.last_response = None\n\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            loop.run_until_complete(asyncio.wait_for(self._command(message), self.timeout_connect, loop=loop))\n        finally:\n            loop.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_message(self, message, icon_path=None):\n        icon_encoded_string = ''\n        icon_extension = ''\n\n        if icon_path is not None:\n            icon_extension = os.path.splitext(icon_path)[1][1:]\n            with open(icon_path, 'rb') as icon_file:\n                icon_encoded_string = base64.b64encode(icon_file.read()).decode('ascii')\n\n        self.request(EP_SHOW_MESSAGE, {\n            'message': message,\n            'iconData': icon_encoded_string,\n            'iconExtension': icon_extension\n        })", "response": "Show a floating message."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_current_app(self):\n        self.request(EP_GET_CURRENT_APP_INFO)\n        return None if self.last_response is None else self.last_response.get('payload').get('appId')", "response": "Get the current app id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the current software status.", "response": "def get_software_info(self):\n        \"\"\"Return the current software status.\"\"\"\n        self.request(EP_GET_SOFTWARE_INFO)\n        return {} if self.last_response is None else self.last_response.get('payload')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_audio_status(self):\n        self.request(EP_GET_AUDIO_STATUS)\n        return {} if self.last_response is None else self.last_response.get('payload')", "response": "Get the current audio status"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the current volume.", "response": "def get_volume(self):\n        \"\"\"Get the current volume.\"\"\"\n        self.request(EP_GET_VOLUME)\n        return 0 if self.last_response is None else self.last_response.get('payload').get('volume')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_volume(self, volume):\n        volume = max(0, volume)\n        self.request(EP_SET_VOLUME, {\n            'volume': volume\n        })", "response": "Set the current volume."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_channels(self):\n        self.request(EP_GET_TV_CHANNELS)\n        return {} if self.last_response is None else self.last_response.get('payload').get('channelList')", "response": "Get all tv channels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the current tv channel.", "response": "def get_current_channel(self):\n        \"\"\"Get the current tv channel.\"\"\"\n        self.request(EP_GET_CURRENT_CHANNEL)\n        return {} if self.last_response is None else self.last_response.get('payload')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the current channel info.", "response": "def get_channel_info(self):\n        \"\"\"Get the current channel info.\"\"\"\n        self.request(EP_GET_CHANNEL_INFO)\n        return {} if self.last_response is None else self.last_response.get('payload')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load_plugins_itr(pgroup, safe=True):\n    for res in pkg_resources.iter_entry_points(pgroup):\n        try:\n            yield res.load()\n        except ImportError:\n            if safe:\n                continue\n            raise", "response": "Load all the ITRs in the given plugin group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_by_key(items, sort_fn=sorted):\n    itr = anyconfig.utils.concat(((k, v) for k in ks) for ks, v in items)\n    return list((k, sort_fn(t[1] for t in g))\n                for k, g\n                in anyconfig.utils.groupby(itr, operator.itemgetter(0)))", "response": "Select items from a list of key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of Processor objects grouped by type or extensions given item.", "response": "def list_by_x(prs, key):\n    \"\"\"\n    :param key: Grouping key, \"type\" or \"extensions\"\n    :return:\n        A list of :class:`Processor` or its children classes grouped by\n        given 'item', [(cid, [:class:`Processor`)]] by default\n    \"\"\"\n    if key == \"type\":\n        kfn = operator.methodcaller(key)\n        res = sorted(((k, sort_by_prio(g)) for k, g\n                      in anyconfig.utils.groupby(prs, kfn)),\n                     key=operator.itemgetter(0))\n\n    elif key == \"extensions\":\n        res = select_by_key(((p.extensions(), p) for p in prs),\n                            sort_fn=sort_by_prio)\n    else:\n        raise ValueError(\"Argument 'key' must be 'type' or \"\n                         \"'extensions' but it was '%s'\" % key)\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef findall_with_pred(predicate, prs):\n    return sorted((p for p in prs if predicate(p)),\n                  key=operator.methodcaller(\"priority\"), reverse=True)", "response": "Find all the processor classes that satisfy a predicate."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maybe_processor(type_or_id, cls=anyconfig.models.processor.Processor):\n    if isinstance(type_or_id, cls):\n        return type_or_id\n\n    if type(type_or_id) == type(cls) and issubclass(type_or_id, cls):\n        return type_or_id()\n\n    return None", "response": "Returns the first instance of the specified processor class or None if no processor class is found."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_by_type_or_id(type_or_id, prs):\n    def pred(pcls):\n        \"\"\"Predicate\"\"\"\n        return pcls.cid() == type_or_id or pcls.type() == type_or_id\n\n    pclss = findall_with_pred(pred, prs)\n    if not pclss:\n        raise UnknownProcessorTypeError(type_or_id)\n\n    return pclss", "response": "Find all the processor classes of a given data type or ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_by_fileext(fileext, prs):\n    def pred(pcls):\n        \"\"\"Predicate\"\"\"\n        return fileext in pcls.extensions()\n\n    pclss = findall_with_pred(pred, prs)\n    if not pclss:\n        raise UnknownFileTypeError(\"file extension={}\".format(fileext))\n\n    return pclss", "response": "Returns a list of processor classes to processor files with given file extension."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the list of processor classes that can process a given maybe file.", "response": "def find_by_maybe_file(obj, prs):\n    \"\"\"\n    :param obj:\n        a file path, file or file-like object, pathlib.Path object or an\n        'anyconfig.globals.IOInfo' (namedtuple) object\n    :param cps_by_ext: A list of processor classes\n    :return: A list of processor classes to process given (maybe) file\n    :raises: UnknownFileTypeError\n    \"\"\"\n    if not isinstance(obj, IOInfo):\n        obj = anyconfig.ioinfo.make(obj)\n\n    return find_by_fileext(obj.extension, prs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding all the processors in the hierarchy that are of the given type.", "response": "def findall(obj, prs, forced_type=None,\n            cls=anyconfig.models.processor.Processor):\n    \"\"\"\n    :param obj:\n        a file path, file, file-like object, pathlib.Path object or an\n        'anyconfig.globals.IOInfo` (namedtuple) object\n    :param prs: A list of :class:`anyconfig.models.processor.Processor` classes\n    :param forced_type:\n        Forced processor type of the data to process or ID of the processor\n        class or None\n    :param cls: A class object to compare with 'forced_type' later\n\n    :return: A list of instances of processor classes to process 'obj' data\n    :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n    \"\"\"\n    if (obj is None or not obj) and forced_type is None:\n        raise ValueError(\"The first argument 'obj' or the second argument \"\n                         \"'forced_type' must be something other than \"\n                         \"None or False.\")\n\n    if forced_type is None:\n        pclss = find_by_maybe_file(obj, prs)  # :: [Processor], never []\n    else:\n        pclss = find_by_type_or_id(forced_type, prs)  # Do.\n\n    return pclss"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find(obj, prs, forced_type=None, cls=anyconfig.models.processor.Processor):\n    if forced_type is not None:\n        processor = maybe_processor(forced_type, cls=cls)\n        if processor is not None:\n            return processor\n\n    pclss = findall(obj, prs, forced_type=forced_type, cls=cls)\n    return pclss[0]()", "response": "Find a specific object in the hierarchy of Processor classes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, *pclss):\n        for pcls in pclss:\n            if pcls.cid() not in self._processors:\n                self._processors[pcls.cid()] = pcls", "response": "Registers a list of Processor classes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all Processor instances in this instance.", "response": "def list(self, sort=False):\n        \"\"\"\n        :param sort: Result will be sorted if it's True\n        :return: A list of :class:`Processor` or its children classes\n        \"\"\"\n        prs = self._processors.values()\n        if sort:\n            return sorted(prs, key=operator.methodcaller(\"cid\"))\n\n        return prs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all the Processor s that have the same cid.", "response": "def list_by_cid(self):\n        \"\"\"\n        :return:\n            A list of :class:`Processor` or its children classes grouped by\n            each cid, [(cid, [:class:`Processor`)]]\n        \"\"\"\n        prs = self._processors\n        return sorted(((cid, [prs[cid]]) for cid in sorted(prs.keys())),\n                      key=operator.itemgetter(0))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all children classes grouped by item", "response": "def list_by_x(self, item=None):\n        \"\"\"\n        :param item: Grouping key, one of \"cid\", \"type\" and \"extensions\"\n        :return:\n            A list of :class:`Processor` or its children classes grouped by\n            given 'item', [(cid, [:class:`Processor`)]] by default\n        \"\"\"\n        prs = self._processors\n\n        if item is None or item == \"cid\":  # Default.\n            res = [(cid, [prs[cid]]) for cid in sorted(prs.keys())]\n\n        elif item in (\"type\", \"extensions\"):\n            res = list_by_x(prs.values(), item)\n        else:\n            raise ValueError(\"keyword argument 'item' must be one of \"\n                             \"None, 'cid', 'type' and 'extensions' \"\n                             \"but it was '%s'\" % item)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of x keys.", "response": "def list_x(self, key=None):\n        \"\"\"\n        :param key: Which of key to return from \"cid\", \"type\", and \"extention\"\n        :return: A list of x 'key'\n        \"\"\"\n        if key in (\"cid\", \"type\"):\n            return sorted(set(operator.methodcaller(key)(p)\n                              for p in self._processors.values()))\n        if key == \"extension\":\n            return sorted(k for k, _v in self.list_by_x(\"extensions\"))\n\n        raise ValueError(\"keyword argument 'key' must be one of \"\n                         \"None, 'cid', 'type' and 'extension' \"\n                         \"but it was '%s'\" % key)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding all the processors in the object obj.", "response": "def findall(self, obj, forced_type=None,\n                cls=anyconfig.models.processor.Processor):\n        \"\"\"\n        :param obj:\n            a file path, file, file-like object, pathlib.Path object or an\n            'anyconfig.globals.IOInfo' (namedtuple) object\n        :param forced_type: Forced processor type to find\n        :param cls: A class object to compare with 'ptype'\n\n        :return: A list of instances of processor classes to process 'obj'\n        :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n        \"\"\"\n        return [p() for p in findall(obj, self.list(),\n                                     forced_type=forced_type, cls=cls)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, obj, forced_type=None,\n             cls=anyconfig.models.processor.Processor):\n        \"\"\"\n        :param obj:\n            a file path, file, file-like object, pathlib.Path object or an\n            'anyconfig.globals.IOInfo' (namedtuple) object\n        :param forced_type: Forced processor type to find\n        :param cls: A class object to compare with 'ptype'\n\n        :return: an instance of processor class to process 'obj'\n        :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n        \"\"\"\n        return find(obj, self.list(), forced_type=forced_type, cls=cls)", "response": "Find a specific object in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef yml_fnc(fname, *args, **options):\n    options = common.filter_from_options(\"ac_dict\", options)\n\n    if \"ac_safe\" in options:\n        options[\"typ\"] = \"safe\"  # Override it.\n\n    iopts = anyconfig.utils.filter_options(_YAML_INIT_KWARGS, options)\n    oopts = anyconfig.utils.filter_options(_YAML_INSTANCE_MEMBERS, options)\n\n    yml = ryaml.YAML(**iopts)\n    for attr, val in oopts.items():\n        setattr(yml, attr, val)  # e.g. yml.preserve_quotes = True\n\n    return getattr(yml, fname)(*args)", "response": "Load or dump a single file into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef yml_load(stream, container, **options):\n    ret = yml_fnc(\"load\", stream, **options)\n    if ret is None:\n        return container()\n\n    return ret", "response": "Load a single YAML file into a container."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\navoids bug in python 3.{2,3}. See http://bugs.python.org/issue9257. :param xmlfile: XML file or file-like object", "response": "def _iterparse(xmlfile):\n    \"\"\"\n    Avoid bug in python 3.{2,3}. See http://bugs.python.org/issue9257.\n\n    :param xmlfile: XML file or file-like object\n    \"\"\"\n    try:\n        return ET.iterparse(xmlfile, events=(\"start-ns\", ))\n    except TypeError:\n        return ET.iterparse(xmlfile, events=(b\"start-ns\", ))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _tweak_ns(tag, **options):\n    nspaces = options.get(\"nspaces\", None)\n    if nspaces is not None:\n        matched = _ET_NS_RE.match(tag)\n        if matched:\n            (uri, tag) = matched.groups()\n            prefix = nspaces.get(uri, False)\n            if prefix:\n                return \"%s:%s\" % (prefix, tag)\n\n    return tag", "response": "Tweaks the namespaces of the given XML tag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if all keys of each dict of dics are unique.", "response": "def _dicts_have_unique_keys(dics):\n    \"\"\"\n    :param dics: [<dict or dict-like object>], must not be [] or [{...}]\n    :return: True if all keys of each dict of 'dics' are unique\n\n    # Enable the followings if to allow dics is [], [{...}]:\n    # >>> all(_dicts_have_unique_keys([d]) for [d]\n    # ...     in ({}, {'a': 0}, {'a': 1, 'b': 0}))\n    # True\n    # >>> _dicts_have_unique_keys([{}, {'a': 1}, {'b': 2, 'c': 0}])\n    # True\n\n    >>> _dicts_have_unique_keys([{}, {'a': 1}, {'a': 2}])\n    False\n    >>> _dicts_have_unique_keys([{}, {'a': 1}, {'b': 2}, {'b': 3, 'c': 0}])\n    False\n    >>> _dicts_have_unique_keys([{}, {}])\n    True\n    \"\"\"\n    key_itr = anyconfig.compat.from_iterable(d.keys() for d in dics)\n    return len(set(key_itr)) == sum(len(d) for d in dics)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _merge_dicts(dics, container=dict):\n    dic_itr = anyconfig.compat.from_iterable(d.items() for d in dics)\n    return container(anyconfig.compat.OrderedDict(dic_itr))", "response": "Merge a list of dicts into a single container."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the text value.", "response": "def _parse_text(val, **options):\n    \"\"\"\n    :return: Parsed value or value itself depends on 'ac_parse_value'\n    \"\"\"\n    if val and options.get(\"ac_parse_value\", False):\n        return anyconfig.parser.parse_single(val)\n\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess text in the XML element and update dic and subdic with the result.", "response": "def _process_elem_text(elem, dic, subdic, text=\"@text\", **options):\n    \"\"\"\n    :param elem: ET Element object which has elem.text\n    :param dic: <container> (dict[-like]) object converted from elem\n    :param subdic: Sub <container> object converted from elem\n    :param options:\n        Keyword options, see the description of :func:`elem_to_container` for\n        more details.\n\n    :return: None but updating elem.text, dic and subdic as side effects\n    \"\"\"\n    elem.text = elem.text.strip()\n    if elem.text:\n        etext = _parse_text(elem.text, **options)\n        if len(elem) or elem.attrib:\n            subdic[text] = etext\n        else:\n            dic[elem.tag] = etext"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the attributes of the element and returns a container object.", "response": "def _parse_attrs(elem, container=dict, **options):\n    \"\"\"\n    :param elem: ET Element object has attributes (elem.attrib)\n    :param container: callble to make a container object\n    :return: Parsed value or value itself depends on 'ac_parse_value'\n    \"\"\"\n    adic = dict((_tweak_ns(a, **options), v) for a, v in elem.attrib.items())\n    if options.get(\"ac_parse_value\", False):\n        return container(dict((k, anyconfig.parser.parse_single(v))\n                              for k, v in adic.items()))\n\n    return container(adic)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_elem_attrs(elem, dic, subdic, container=dict, attrs=\"@attrs\",\n                        **options):\n    \"\"\"\n    :param elem: ET Element object or None\n    :param dic: <container> (dict[-like]) object converted from elem\n    :param subdic: Sub <container> object converted from elem\n    :param options:\n        Keyword options, see the description of :func:`elem_to_container` for\n        more details.\n\n    :return: None but updating dic and subdic as side effects\n    \"\"\"\n    adic = _parse_attrs(elem, container=container, **options)\n    if not elem.text and not len(elem) and options.get(\"merge_attrs\"):\n        dic[elem.tag] = adic\n    else:\n        subdic[attrs] = adic", "response": "Process the attributes of the given ET Element and update dic and subdic as side effects\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess children elements in elem into dic and subdic.", "response": "def _process_children_elems(elem, dic, subdic, container=dict,\n                            children=\"@children\", **options):\n    \"\"\"\n    :param elem: ET Element object or None\n    :param dic: <container> (dict[-like]) object converted from elem\n    :param subdic: Sub <container> object converted from elem\n    :param container: callble to make a container object\n    :param children: Tag for children nodes\n    :param options:\n        Keyword options, see the description of :func:`elem_to_container` for\n        more details.\n\n    :return: None but updating dic and subdic as side effects\n    \"\"\"\n    cdics = [elem_to_container(c, container=container, **options)\n             for c in elem]\n    merge_attrs = options.get(\"merge_attrs\", False)\n    sdics = [container(elem.attrib) if merge_attrs else subdic] + cdics\n\n    if _dicts_have_unique_keys(sdics):  # ex. <a><b>1</b><c>c</c></a>\n        dic[elem.tag] = _merge_dicts(sdics, container)\n    elif not subdic:  # There are no attrs nor text and only these children.\n        dic[elem.tag] = cdics\n    else:\n        subdic[children] = cdics"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert an XML ElementTree Element to a collection of container objects.", "response": "def elem_to_container(elem, container=dict, **options):\n    \"\"\"\n    Convert XML ElementTree Element to a collection of container objects.\n\n    Elements are transformed to a node under special tagged nodes, attrs, text\n    and children, to store the type of these elements basically, however, in\n    some special cases like the followings, these nodes are attached to the\n    parent node directly for later convenience.\n\n    - There is only text element\n    - There are only children elements each has unique keys among all\n\n    :param elem: ET Element object or None\n    :param container: callble to make a container object\n    :param options: Keyword options\n\n        - nspaces: A namespaces dict, {uri: prefix} or None\n        - attrs, text, children: Tags for special nodes to keep XML info\n        - merge_attrs: Merge attributes and mix with children nodes, and the\n          information of attributes are lost after its transformation.\n    \"\"\"\n    dic = container()\n    if elem is None:\n        return dic\n\n    elem.tag = _tweak_ns(elem.tag, **options)  # {ns}tag -> ns_prefix:tag\n    subdic = dic[elem.tag] = container()\n    options[\"container\"] = container\n\n    if elem.text:\n        _process_elem_text(elem, dic, subdic, **options)\n\n    if elem.attrib:\n        _process_elem_attrs(elem, dic, subdic, **options)\n\n    if len(elem):\n        _process_children_elems(elem, dic, subdic, **options)\n    elif not elem.text and not elem.attrib:  # ex. <tag/>.\n        dic[elem.tag] = None\n\n    return dic"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _complement_tag_options(options):\n    if not all(nt in options for nt in _TAGS):\n        tags = options.get(\"tags\", {})\n        for ntype, tag in _TAGS.items():\n            options[ntype] = tags.get(ntype, tag)\n\n    return options", "response": "Returns a dict of options that can be used to complement the tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts XML ElementTree Root Element to a collection of container objects.", "response": "def root_to_container(root, container=dict, nspaces=None, **options):\n    \"\"\"\n    Convert XML ElementTree Root Element to a collection of container objects.\n\n    :param root: etree root object or None\n    :param container: callble to make a container object\n    :param nspaces: A namespaces dict, {uri: prefix} or None\n    :param options: Keyword options,\n\n        - tags: Dict of tags for special nodes to keep XML info, attributes,\n          text and children nodes, e.g. {\"attrs\": \"@attrs\", \"text\": \"#text\"}\n    \"\"\"\n    tree = container()\n    if root is None:\n        return tree\n\n    if nspaces is not None:\n        for uri, prefix in nspaces.items():\n            root.attrib[\"xmlns:\" + prefix if prefix else \"xmlns\"] = uri\n\n    return elem_to_container(root, container=container, nspaces=nspaces,\n                             **_complement_tag_options(options))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset attributes of the container instance to string.", "response": "def _elem_set_attrs(obj, parent, to_str):\n    \"\"\"\n    :param obj: Container instance gives attributes of XML Element\n    :param parent: XML ElementTree parent node object\n    :param to_str: Callable to convert value to string or None\n    :param options: Keyword options, see :func:`container_to_etree`\n\n    :return: None but parent will be modified\n    \"\"\"\n    for attr, val in anyconfig.compat.iteritems(obj):\n        parent.set(attr, to_str(val))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_or_update_parent(key, val, to_str, parent=None, **options):\n    elem = ET.Element(key)\n\n    vals = val if anyconfig.utils.is_iterable(val) else [val]\n    for val_ in vals:\n        container_to_etree(val_, parent=elem, to_str=to_str, **options)\n\n    if parent is None:  # 'elem' is the top level etree.\n        return elem\n\n    parent.append(elem)\n    return parent", "response": "Helper function to update the parent node of the current child."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef container_to_etree(obj, parent=None, to_str=None, **options):\n    if to_str is None:\n        to_str = _to_str_fn(**options)\n\n    if not anyconfig.utils.is_dict_like(obj):\n        if parent is not None and obj:\n            parent.text = to_str(obj)  # Parent is a leaf text node.\n        return parent  # All attributes and text should be set already.\n\n    options = _complement_tag_options(options)\n    (attrs, text, children) = operator.itemgetter(*_ATC)(options)\n\n    for key, val in anyconfig.compat.iteritems(obj):\n        if key == attrs:\n            _elem_set_attrs(val, parent, to_str)\n        elif key == text:\n            parent.text = to_str(val)\n        elif key == children:\n            for celem in _elem_from_descendants(val, **options):\n                parent.append(celem)\n        else:\n            parent = _get_or_update_parent(key, val, to_str, parent=parent,\n                                           **options)\n\n    return ET.ElementTree(parent)", "response": "Convert a dict - like object to XML ElementTree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef etree_write(tree, stream):\n    try:\n        tree.write(stream, encoding=\"utf-8\", xml_declaration=True)\n    except TypeError:\n        tree.write(stream, encoding=\"unicode\", xml_declaration=True)", "response": "Writes XML ElementTree root content into stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_from_string(self, content, container, **opts):\n        root = ET.fromstring(content)\n        if anyconfig.compat.IS_PYTHON_3:\n            stream = BytesIO(content)\n        else:\n            stream = anyconfig.compat.StringIO(content)\n        nspaces = _namespaces_from_file(stream)\n        return root_to_container(root, container=container,\n                                 nspaces=nspaces, **opts)", "response": "Load config from a string content."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads a config from a file path.", "response": "def load_from_path(self, filepath, container, **opts):\n        \"\"\"\n        :param filepath: XML file path\n        :param container: callble to make a container object\n        :param opts: optional keyword parameters to be sanitized\n\n        :return: Dict-like object holding config parameters\n        \"\"\"\n        root = ET.parse(filepath).getroot()\n        nspaces = _namespaces_from_file(filepath)\n        return root_to_container(root, container=container,\n                                 nspaces=nspaces, **opts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_from_stream(self, stream, container, **opts):\n        root = ET.parse(stream).getroot()\n        path = anyconfig.utils.get_path_from_stream(stream)\n        nspaces = _namespaces_from_file(path)\n        return root_to_container(root, container=container,\n                                 nspaces=nspaces, **opts)", "response": "Load a configuration from a stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump_to_string(self, cnf, **opts):\n        tree = container_to_etree(cnf, **opts)\n        buf = BytesIO()\n        etree_write(tree, buf)\n        return buf.getvalue()", "response": "Dump the configuration to a string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dump_to_stream(self, cnf, stream, **opts):\n        tree = container_to_etree(cnf, **opts)\n        etree_write(tree, stream)", "response": "Dump the configuration data to a file - like object stream"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_from_options(key, options):\n    return anyconfig.utils.filter_options([k for k in options.keys()\n                                           if k != key], options)", "response": "Filter the options in which the item with key is not in the options dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates or update a loader with customization for the given container.", "response": "def _customized_loader(container, loader=Loader, mapping_tag=_MAPPING_TAG):\n    \"\"\"\n    Create or update loader with making given callble 'container' to make\n    mapping objects such as dict and OrderedDict, used to construct python\n    object from yaml mapping node internally.\n\n    :param container: Set container used internally\n    \"\"\"\n    def construct_mapping(loader, node, deep=False):\n        \"\"\"Construct python object from yaml mapping node, based on\n        :meth:`yaml.BaseConstructor.construct_mapping` in PyYAML (MIT).\n        \"\"\"\n        loader.flatten_mapping(node)\n        if not isinstance(node, yaml.MappingNode):\n            msg = \"expected a mapping node, but found %s\" % node.id\n            raise yaml.constructor.ConstructorError(None, None, msg,\n                                                    node.start_mark)\n        mapping = container()\n        for key_node, value_node in node.value:\n            key = loader.construct_object(key_node, deep=deep)\n            try:\n                hash(key)\n            except TypeError as exc:\n                eargs = (\"while constructing a mapping\",\n                         node.start_mark,\n                         \"found unacceptable key (%s)\" % exc,\n                         key_node.start_mark)\n                raise yaml.constructor.ConstructorError(*eargs)\n            value = loader.construct_object(value_node, deep=deep)\n            mapping[key] = value\n\n        return mapping\n\n    tag = \"tag:yaml.org,2002:python/unicode\"\n\n    def construct_ustr(loader, node):\n        \"\"\"Unicode string constructor\"\"\"\n        return loader.construct_scalar(node)\n\n    try:\n        loader.add_constructor(tag, construct_ustr)\n    except NameError:\n        pass\n\n    if type(container) != dict:\n        loader.add_constructor(mapping_tag, construct_mapping)\n    return loader"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _customized_dumper(container, dumper=Dumper):\n    def container_representer(dumper, data, mapping_tag=_MAPPING_TAG):\n        \"\"\"Container representer.\n        \"\"\"\n        return dumper.represent_mapping(mapping_tag, data.items())\n\n    def ustr_representer(dumper, data):\n        \"\"\"Unicode string representer\"\"\"\n        tag = \"tag:yaml.org,2002:python/unicode\"\n        return dumper.represent_scalar(tag, data)\n\n    try:\n        dumper.add_representer(unicode, ustr_representer)\n    except NameError:\n        pass\n\n    if type(container) != dict:\n        dumper.add_representer(container, container_representer)\n    return dumper", "response": "Customized dumper for the given container."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef yml_fnc(fname, *args, **options):\n    key = \"ac_safe\"\n    fnc = getattr(yaml, r\"safe_\" + fname if options.get(key) else fname)\n    return fnc(*args, **common.filter_from_options(key, options))", "response": "Wrapper of yaml. safe_load yaml. load and yaml. dump.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrap of yaml. safe_load and yaml. load.", "response": "def yml_load(stream, container, yml_fnc=yml_fnc, **options):\n    \"\"\"An wrapper of yaml.safe_load and yaml.load.\n\n    :param stream: a file or file-like object to load YAML content\n    :param container: callble to make a container object\n\n    :return: Mapping object\n    \"\"\"\n    if options.get(\"ac_safe\", False):\n        options = {}  # yaml.safe_load does not process Loader opts.\n    elif not options.get(\"Loader\"):\n        maybe_container = options.get(\"ac_dict\", False)\n        if maybe_container and callable(maybe_container):\n            container = maybe_container\n\n        options[\"Loader\"] = _customized_loader(container)\n\n    ret = yml_fnc(\"load\", stream,\n                  **common.filter_from_options(\"ac_dict\", options))\n    if ret is None:\n        return container()\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef yml_dump(data, stream, yml_fnc=yml_fnc, **options):\n    _is_dict = anyconfig.utils.is_dict_like(data)\n\n    if options.get(\"ac_safe\", False):\n        options = {}\n    elif not options.get(\"Dumper\", False) and _is_dict:\n        # TODO: Any other way to get its constructor?\n        maybe_container = options.get(\"ac_dict\", type(data))\n        options[\"Dumper\"] = _customized_dumper(maybe_container)\n\n    if _is_dict:\n        # Type information and the order of items are lost on dump currently.\n        data = anyconfig.dicts.convert_to(data, ac_dict=dict)\n        options = common.filter_from_options(\"ac_dict\", options)\n\n    return yml_fnc(\"dump\", data, stream, **options)", "response": "A wrapper of yaml. safe_dump and yaml. dump."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _split_path(path, seps=PATH_SEPS):\n    if not path:\n        return []\n\n    for sep in seps:\n        if sep in path:\n            if path == sep:  # Special case, '/' or '.' only.\n                return ['']\n            return [x for x in path.split(sep) if x]\n\n    return [path]", "response": "Parse a path expression and return a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mk_nested_dic(path, val, seps=PATH_SEPS):\n    ret = None\n    for key in reversed(_split_path(path, seps)):\n        ret = {key: val if ret is None else ret.copy()}\n\n    return ret", "response": "Make a nested dict iteratively."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_(dic, path, val, seps=PATH_SEPS):\n    merge(dic, mk_nested_dic(path, val, seps), ac_merge=MS_DICTS)", "response": "setter for nested dicts."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate self with other with value val.", "response": "def _update_with_replace(self, other, key, val=None, **options):\n    \"\"\"\n    Replace value of a mapping object 'self' with 'other' has if both have same\n    keys on update. Otherwise, just keep the value of 'self'.\n\n    :param self: mapping object to update with 'other'\n    :param other: mapping object to update 'self'\n    :param key: key of mapping object to update\n    :param val: value to update self alternatively\n\n    :return: None but 'self' will be updated\n    \"\"\"\n    self[key] = other[key] if val is None else val"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _merge_list(self, key, lst):\n    self[key] += [x for x in lst if x not in self[key]]", "response": "Merge list with another list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the value of self with other.", "response": "def _update_with_merge(self, other, key, val=None, merge_lists=False,\n                       **options):\n    \"\"\"\n    Merge the value of self with other's recursively. Behavior of merge will be\n    vary depends on types of original and new values.\n\n    - mapping vs. mapping -> merge recursively\n    - list vs. list -> vary depends on 'merge_lists'. see its description.\n\n    :param other: a dict[-like] object or a list of (key, value) tuples\n    :param key: key of mapping object to update\n    :param val: value to update self[key]\n    :param merge_lists:\n        Merge not only dicts but also lists. For example,\n\n        [1, 2, 3], [3, 4] ==> [1, 2, 3, 4]\n        [1, 2, 2], [2, 4] ==> [1, 2, 2, 4]\n\n    :return: None but 'self' will be updated\n    \"\"\"\n    if val is None:\n        val = other[key]\n\n    if key in self:\n        val0 = self[key]  # Original value\n        if anyconfig.utils.is_dict_like(val0):  # It needs recursive updates.\n            merge(self[key], val, merge_lists=merge_lists, **options)\n        elif merge_lists and _are_list_like(val, val0):\n            _merge_list(self, key, val)\n        else:\n            _merge_other(self, key, val)\n    else:\n        self[key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a function to update objects of the object.", "response": "def _get_update_fn(strategy):\n    \"\"\"\n    Select dict-like class based on merge strategy and orderness of keys.\n\n    :param merge: Specify strategy from MERGE_STRATEGIES of how to merge dicts.\n    :return: Callable to update objects\n    \"\"\"\n    if strategy is None:\n        strategy = MS_DICTS\n    try:\n        return _MERGE_FNS[strategy]\n    except KeyError:\n        if callable(strategy):\n            return strategy\n\n        raise ValueError(\"Wrong merge strategy: %r\" % strategy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates self with other mapping object or an iterable of dicts or tuples based on merge strategy ac_merge.", "response": "def merge(self, other, ac_merge=MS_DICTS, **options):\n    \"\"\"\n    Update (merge) a mapping object 'self' with other mapping object or an\n    iterable yields (key, value) tuples based on merge strategy 'ac_merge'.\n\n    :param others: a list of dict[-like] objects or (key, value) tuples\n    :param another: optional keyword arguments to update self more\n    :param ac_merge: Merge strategy to choose\n    \"\"\"\n    _update_fn = _get_update_fn(ac_merge)\n\n    if hasattr(other, \"keys\"):\n        for key in other:\n            _update_fn(self, other, key, **options)\n    else:\n        try:\n            for key, val in other:\n                _update_fn(self, other, key, val=val, **options)\n        except (ValueError, TypeError) as exc:  # Re-raise w/ info.\n            raise type(exc)(\"%s other=%r\" % (str(exc), other))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _make_recur(obj, make_fn, ac_ordered=False, ac_dict=None, **options):\n    if ac_dict is None:\n        ac_dict = anyconfig.compat.OrderedDict if ac_ordered else dict\n\n    return ac_dict((k, None if v is None else make_fn(v, **options))\n                   for k, v in obj.items())", "response": "Make a recur object from a dict or OrderedDict."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake an iterator over the object.", "response": "def _make_iter(obj, make_fn, **options):\n    \"\"\"\n    :param obj: A mapping objects or other primitive object\n    :param make_fn: Function to make/convert to\n    :param options: Optional keyword arguments.\n\n    :return: Mapping object\n    \"\"\"\n    return type(obj)(make_fn(v, **options) for v in obj)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_to(obj, ac_ordered=False, ac_dict=None, **options):\n    options.update(ac_ordered=ac_ordered, ac_dict=ac_dict)\n    if anyconfig.utils.is_dict_like(obj):\n        return _make_recur(obj, convert_to, **options)\n    if anyconfig.utils.is_list_like(obj):\n        return _make_iter(obj, convert_to, **options)\n\n    return obj", "response": "Convert a mapping object to a dict or object of to_type recursively."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a line of Java properties file.", "response": "def _parseline(line):\n    \"\"\"\n    Parse a line of Java properties file.\n\n    :param line:\n        A string to parse, must not start with ' ', '#' or '!' (comment)\n    :return: A tuple of (key, value), both key and value may be None\n\n    >>> _parseline(\" \")\n    (None, '')\n    >>> _parseline(\"aaa:\")\n    ('aaa', '')\n    >>> _parseline(\" aaa:\")\n    ('aaa', '')\n    >>> _parseline(\"aaa\")\n    ('aaa', '')\n    >>> _parseline(\"url = http://localhost\")\n    ('url', 'http://localhost')\n    >>> _parseline(\"calendar.japanese.type: LocalGregorianCalendar\")\n    ('calendar.japanese.type', 'LocalGregorianCalendar')\n    \"\"\"\n    pair = re.split(r\"(?:\\s+)?(?:(?<!\\\\)[=:])\", line.strip(), 1)\n    key = pair[0].rstrip()\n\n    if len(pair) < 2:\n        LOGGER.warning(\"Invalid line found: %s\", line)\n        return (key or None, '')\n\n    return (key, pair[1].strip())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(stream, container=dict, comment_markers=_COMMENT_MARKERS):\n    ret = container()\n    prev = \"\"\n\n    for line in stream.readlines():\n        line = _pre_process_line(prev + line.strip().rstrip(),\n                                 comment_markers)\n        # I don't think later case may happen but just in case.\n        if line is None or not line:\n            continue\n\n        prev = \"\"  # re-initialize for later use.\n\n        if line.endswith(\"\\\\\"):\n            prev += line.rstrip(\" \\\\\")\n            continue\n\n        (key, val) = _parseline(line)\n        if key is None:\n            LOGGER.warning(\"Failed to parse the line: %s\", line)\n            continue\n\n        ret[key] = unescape(val)\n\n    return ret", "response": "Load and parse Java properties file given as a fiel or file - like object stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copen(filepath, flag='r', encoding=None):\n\n    \"\"\"\n    FIXME: How to test this ?\n\n    >>> c = copen(__file__)\n    >>> c is not None\n    True\n    \"\"\"\n    if encoding is None:\n        encoding = locale.getdefaultlocale()[1]\n\n    return codecs.open(filepath, flag, encoding)", "response": "Open a file with the specified encoding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking a list of template search paths from given template_file and paths.", "response": "def make_template_paths(template_file, paths=None):\n    \"\"\"\n    Make up a list of template search paths from given 'template_file'\n    (absolute or relative path to the template file) and/or 'paths' (a list of\n    template search paths given by user).\n\n    NOTE: User-given 'paths' will take higher priority over a dir of\n    template_file.\n\n    :param template_file: Absolute or relative path to the template file\n    :param paths: A list of template search paths\n    :return: List of template paths ([str])\n\n    >>> make_template_paths(\"/path/to/a/template\")\n    ['/path/to/a']\n    >>> make_template_paths(\"/path/to/a/template\", [\"/tmp\"])\n    ['/tmp', '/path/to/a']\n    >>> os.chdir(\"/tmp\")\n    >>> make_template_paths(\"./path/to/a/template\")\n    ['/tmp/path/to/a']\n    >>> make_template_paths(\"./path/to/a/template\", [\"/tmp\"])\n    ['/tmp', '/tmp/path/to/a']\n    \"\"\"\n    tmpldir = os.path.abspath(os.path.dirname(template_file))\n    return [tmpldir] if paths is None else paths + [tmpldir]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_s(tmpl_s, ctx=None, paths=None, filters=None):\n    if paths is None:\n        paths = [os.curdir]\n\n    env = tmpl_env(paths)\n\n    if env is None:\n        return tmpl_s\n\n    if filters is not None:\n        env.filters.update(filters)\n\n    if ctx is None:\n        ctx = {}\n\n    return tmpl_env(paths).from_string(tmpl_s).render(**ctx)", "response": "Compile and render given template string tmpl_s with context dict ctx."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders a single template file into a string.", "response": "def render_impl(template_file, ctx=None, paths=None, filters=None):\n    \"\"\"\n    :param template_file: Absolute or relative path to the template file\n    :param ctx: Context dict needed to instantiate templates\n    :param filters: Custom filters to add into template engine\n    :return: Compiled result (str)\n    \"\"\"\n    env = tmpl_env(make_template_paths(template_file, paths))\n\n    if env is None:\n        return copen(template_file).read()\n\n    if filters is not None:\n        env.filters.update(filters)\n\n    if ctx is None:\n        ctx = {}\n\n    return env.get_template(os.path.basename(template_file)).render(**ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render(filepath, ctx=None, paths=None, ask=False, filters=None):\n    try:\n        return render_impl(filepath, ctx, paths, filters)\n    except TemplateNotFound as mtmpl:\n        if not ask:\n            raise\n\n        usr_tmpl = anyconfig.compat.raw_input(os.linesep + \"\"\n                                              \"*** Missing template \"\n                                              \"'%s'. Please enter absolute \"\n                                              \"or relative path starting from \"\n                                              \"'.' to the template file: \" %\n                                              mtmpl)\n        usr_tmpl = os.path.normpath(usr_tmpl.strip())\n        paths = make_template_paths(usr_tmpl, paths)\n\n        return render_impl(usr_tmpl, ctx, paths, filters)", "response": "Compile and render a template file and return the result as a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompile and render a template and return the result as a string.", "response": "def try_render(filepath=None, content=None, **options):\n    \"\"\"\n    Compile and render template and return the result as a string.\n\n    :param filepath: Absolute or relative path to the template file\n    :param content: Template content (str)\n    :param options: Keyword options passed to :func:`render` defined above.\n    :return: Compiled result (str) or None\n    \"\"\"\n    if filepath is None and content is None:\n        raise ValueError(\"Either 'path' or 'content' must be some value!\")\n\n    tmpl_s = filepath or content[:10] + \" ...\"\n    LOGGER.debug(\"Compiling: %s\", tmpl_s)\n    try:\n        if content is None:\n            render_opts = anyconfig.utils.filter_options(RENDER_OPTS, options)\n            return render(filepath, **render_opts)\n        render_s_opts = anyconfig.utils.filter_options(RENDER_S_OPTS, options)\n        return render_s(content, **render_s_opts)\n    except Exception as exc:\n        LOGGER.warning(\"Failed to compile '%s'. It may not be a template.%s\"\n                       \"exc=%r\", tmpl_s, os.linesep, exc)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a string into a list of strings.", "response": "def _parse(val_s, sep=_SEP):\n    \"\"\"\n    FIXME: May be too naive implementation.\n\n    :param val_s: A string represents some value to parse\n    :param sep: separator between values\n\n    >>> _parse(r'\"foo string\"')\n    'foo string'\n    >>> _parse(\"a, b, c\")\n    ['a', 'b', 'c']\n    >>> _parse(\"aaa\")\n    'aaa'\n    \"\"\"\n    if (val_s.startswith('\"') and val_s.endswith('\"')) or \\\n            (val_s.startswith(\"'\") and val_s.endswith(\"'\")):\n        return val_s[1:-1]\n    if sep in val_s:\n        return [P.parse(x) for x in P.parse_list(val_s)]\n\n    return P.parse(val_s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _to_s(val, sep=\", \"):\n    if anyconfig.utils.is_iterable(val):\n        return sep.join(str(x) for x in val)\n\n    return str(val)", "response": "Convert any to string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield the items in the order they appear in the order they appear in the order they appear in the order they appear.", "response": "def _parsed_items(items, sep=_SEP, **options):\n    \"\"\"\n    :param items: List of pairs, [(key, value)], or generator yields pairs\n    :param sep: Seprator string\n    :return: Generator to yield (key, value) pair of 'dic'\n    \"\"\"\n    parse = _parse if options.get(\"ac_parse_value\") else anyconfig.utils.noop\n    for key, val in items:\n        yield (key, parse(val, sep))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _make_parser(**kwargs):\n    # Optional arguements for configparser.SafeConfigParser{,readfp}\n    kwargs_0 = filter_options((\"defaults\", \"dict_type\", \"allow_no_value\"),\n                              kwargs)\n    kwargs_1 = filter_options((\"filename\", ), kwargs)\n\n    try:\n        parser = configparser.SafeConfigParser(**kwargs_0)\n    except TypeError:\n        # .. note::\n        #    It seems ConfigParser.*ConfigParser in python 2.6 does not support\n        #    'allow_no_value' option parameter, and TypeError will be thrown.\n        kwargs_0 = filter_options((\"defaults\", \"dict_type\"), kwargs)\n        parser = configparser.SafeConfigParser(**kwargs_0)\n\n    return (kwargs_1, parser)", "response": "Create a ConfigParser. SafeConfigParser object for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads configuration from file or file - like object.", "response": "def _load(stream, container, sep=_SEP, dkey=DEFAULTSECT, **kwargs):\n    \"\"\"\n    :param stream: File or file-like object provides ini-style conf\n    :param container: any callable to make container\n    :param sep: Seprator string\n    :param dkey: Default section name\n\n    :return: Dict or dict-like object represents config values\n    \"\"\"\n    (kwargs_1, psr) = _make_parser(**kwargs)\n    if IS_PYTHON_3:\n        psr.read_file(stream, **kwargs_1)\n    else:\n        psr.readfp(stream, **kwargs_1)\n\n    cnf = container()\n    kwargs[\"sep\"] = sep\n\n    defaults = psr.defaults()\n    if defaults:\n        cnf[dkey] = container(_parsed_items(iteritems(defaults), **kwargs))\n\n    for sect in psr.sections():\n        cnf[sect] = container(_parsed_items(psr.items(sect), **kwargs))\n\n    return cnf"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _dumps_itr(cnf, dkey=DEFAULTSECT):\n    for sect, params in iteritems(cnf):\n        yield \"[%s]\" % sect\n\n        for key, val in iteritems(params):\n            if sect != dkey and dkey in cnf and cnf[dkey].get(key) == val:\n                continue  # It should be in [DEFAULT] section.\n\n            yield \"%s = %s\" % (key, _to_s(val))\n\n        yield ''", "response": "Dump the configuration data in a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dumps(cnf, **kwargs):\n    return os.linesep.join(l for l in _dumps_itr(cnf))", "response": "Dump the configuration data to INI format"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query(data, **options):\n    expression = options.get(\"ac_query\", None)\n    if expression is None or not expression:\n        return data\n\n    try:\n        pexp = jmespath.compile(expression)\n        return pexp.search(data)\n    except ValueError as exc:  # jmespath.exceptions.*Error inherit from it.\n        LOGGER.warning(\"Failed to compile or search: exp=%s, exc=%r\",\n                       expression, exc)\n    except (NameError, AttributeError):\n        LOGGER.warning(\"Filter module (jmespath) is not available. \"\n                       \"Do nothing.\")\n\n    return data", "response": "Query data with given JMESPath expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_file_extension(file_path):\n    _ext = os.path.splitext(file_path)[-1]\n    if _ext:\n        return _ext[1:] if _ext.startswith('.') else _ext\n\n    return \"\"", "response": "Get the file extension"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if an object is iterable.", "response": "def is_iterable(obj):\n    \"\"\"\n    >>> is_iterable([])\n    True\n    >>> is_iterable(())\n    True\n    >>> is_iterable([x for x in range(10)])\n    True\n    >>> is_iterable((1, 2, 3))\n    True\n    >>> g = (x for x in range(10))\n    >>> is_iterable(g)\n    True\n    >>> is_iterable(\"abc\")\n    False\n    >>> is_iterable(0)\n    False\n    >>> is_iterable({})\n    False\n    \"\"\"\n    return isinstance(obj, (list, tuple, types.GeneratorType)) or \\\n        (not isinstance(obj, (int, str, dict)) and\n         bool(getattr(obj, \"next\", False)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_ioinfo(obj, keys=None):\n    if keys is None:\n        keys = anyconfig.globals.IOI_KEYS\n\n    if isinstance(obj, tuple) and getattr(obj, \"_asdict\", False):\n        return all(k in obj._asdict() for k in keys)\n\n    return False", "response": "Check if given object is a namedtuple object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_path_like_object(obj, marker='*'):\n    return ((is_path(obj) and marker not in obj) or\n            (is_path_obj(obj) and marker not in obj.as_posix()) or\n            is_file_stream(obj) or is_ioinfo(obj))", "response": "Check if the object is a path string a pathlib. Path object a file - like namedtuple object?"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nis given object maybe_paths consist of path or path pattern strings?", "response": "def is_paths(maybe_paths, marker='*'):\n    \"\"\"\n    Does given object 'maybe_paths' consist of path or path pattern strings?\n    \"\"\"\n    return ((is_path(maybe_paths) and marker in maybe_paths) or  # Path str\n            (is_path_obj(maybe_paths) and marker in maybe_paths.as_posix()) or\n            (is_iterable(maybe_paths) and\n             all(is_path(p) or is_ioinfo(p) for p in maybe_paths)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_path_from_stream(strm):\n    if not is_file_stream(strm):\n        raise ValueError(\"Given object does not look a file/file-like \"\n                         \"object: %r\" % strm)\n\n    path = getattr(strm, \"name\", None)\n    if path is not None:\n        try:\n            return normpath(path)\n        except (TypeError, ValueError):\n            pass\n\n    return None", "response": "Try to get file path from given file or file - like object strm."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _try_to_get_extension(obj):\n    if is_path(obj):\n        path = obj\n\n    elif is_path_obj(obj):\n        return obj.suffix[1:]\n\n    elif is_file_stream(obj):\n        try:\n            path = get_path_from_stream(obj)\n        except ValueError:\n            return None\n\n    elif is_ioinfo(obj):\n        path = obj.path\n\n    else:\n        return None\n\n    if path:\n        return get_file_extension(path)\n\n    return None", "response": "Try to get file extension from given path or file - like object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef are_same_file_types(objs):\n    if not objs:\n        return False\n\n    ext = _try_to_get_extension(objs[0])\n    if ext is None:\n        return False\n\n    return all(_try_to_get_extension(p) == ext for p in objs[1:])", "response": "Tests if a list of file objects are given as a list of file paths or file - like objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _expand_paths_itr(paths, marker='*'):\n    for path in paths:\n        if is_path(path):\n            if marker in path:  # glob path pattern\n                for ppath in sglob(path):\n                    yield ppath\n            else:\n                yield path  # a simple file path\n        elif is_path_obj(path):\n            if marker in path.as_posix():\n                for ppath in sglob(path.as_posix()):\n                    yield normpath(ppath)\n            else:\n                yield normpath(path.as_posix())\n        elif is_ioinfo(path):\n            yield path.path\n        else:  # A file or file-like object\n            yield path", "response": "Iterator version of expand_paths."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef expand_paths(paths, marker='*'):\n    if is_path(paths) and marker in paths:\n        return sglob(paths)\n\n    if is_path_obj(paths) and marker in paths.as_posix():\n        # TBD: Is it better to return [p :: pathlib.Path] instead?\n        return [normpath(p) for p in sglob(paths.as_posix())]\n\n    return list(_expand_paths_itr(paths, marker=marker))", "response": "Expand a list of paths to a list of paths."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the object is a list - like object.", "response": "def is_list_like(obj):\n    \"\"\"\n    >>> is_list_like([])\n    True\n    >>> is_list_like(())\n    True\n    >>> is_list_like([x for x in range(10)])\n    True\n    >>> is_list_like((1, 2, 3))\n    True\n    >>> g = (x for x in range(10))\n    >>> is_list_like(g)\n    True\n    >>> is_list_like(\"abc\")\n    False\n    >>> is_list_like(0)\n    False\n    >>> is_list_like({})\n    False\n    \"\"\"\n    return isinstance(obj, _LIST_LIKE_TYPES) and \\\n        not (isinstance(obj, anyconfig.compat.STR_TYPES) or is_dict_like(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfilter options with given keys.", "response": "def filter_options(keys, options):\n    \"\"\"\n    Filter 'options' with given 'keys'.\n\n    :param keys: key names of optional keyword arguments\n    :param options: optional keyword arguments to filter with 'keys'\n\n    >>> filter_options((\"aaa\", ), dict(aaa=1, bbb=2))\n    {'aaa': 1}\n    >>> filter_options((\"aaa\", ), dict(bbb=2))\n    {}\n    \"\"\"\n    return dict((k, options[k]) for k in keys if k in options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _try_validate(cnf, schema, **options):\n    valid = True\n    if schema:\n        (valid, msg) = validate(cnf, schema, **options)\n        if msg:\n            LOGGER.warning(msg)\n\n    if valid:\n        return cnf\n\n    return None", "response": "Try to validate cnf with schema."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the configuration file if it is a template file and try to validate it AAR", "response": "def _maybe_schema(**options):\n    \"\"\"\n    :param options: Optional keyword arguments such as\n\n        - ac_template: Assume configuration file may be a template file and try\n          to compile it AAR if True\n        - ac_context: Mapping object presents context to instantiate template\n        - ac_schema: JSON schema file path to validate configuration files\n\n    :return: Mapping object or None means some errors\n    \"\"\"\n    ac_schema = options.get(\"ac_schema\", None)\n    if ac_schema is not None:\n        # Try to detect the appropriate parser to load the schema data as it\n        # may be different from the original config file's format, perhaps.\n        options[\"ac_parser\"] = None\n        options[\"ac_schema\"] = None  # Avoid infinite loop.\n        LOGGER.info(\"Loading schema: %s\", ac_schema)\n        return load(ac_schema, **options)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open(path, mode=None, ac_parser=None, **options):\n    psr = find(path, forced_type=ac_parser)\n\n    if mode is not None and mode.startswith('w'):\n        return psr.wopen(path, **options)\n\n    return psr.ropen(path, **options)", "response": "Open given configuration file with appropriate open flag."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _single_load(input_, ac_parser=None, ac_template=False,\n                 ac_context=None, **options):\n    \"\"\"\n    :param input_:\n        File path or file or file-like object or pathlib.Path object represents\n        the file or a namedtuple 'anyconfig.globals.IOInfo' object represents\n        some input to load some data from\n    :param ac_parser: Forced parser type or parser object itself\n    :param ac_template:\n        Assume configuration file may be a template file and try to compile it\n        AAR if True\n    :param ac_context: A dict presents context to instantiate template\n    :param options:\n        Optional keyword arguments :func:`single_load` supports except for\n        ac_schema and ac_query\n\n    :return: Mapping object\n    :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n    \"\"\"\n    ioi = anyconfig.ioinfo.make(input_)\n    psr = find(ioi, forced_type=ac_parser)\n    filepath = ioi.path\n\n    # .. note::\n    #    This will be kept for backward compatibility until 'ignore_missing'\n    #    option is deprecated and removed completely.\n    if \"ignore_missing\" in options:\n        warnings.warn(\"keyword option 'ignore_missing' is deprecated, use \"\n                      \"'ac_ignore_missing' instead\", DeprecationWarning)\n        options[\"ac_ignore_missing\"] = options[\"ignore_missing\"]\n\n    LOGGER.info(\"Loading: %s\", filepath)\n    if ac_template and filepath is not None:\n        content = anyconfig.template.try_render(filepath=filepath,\n                                                ctx=ac_context, **options)\n        if content is not None:\n            return psr.loads(content, **options)\n\n    return psr.load(ioi, **options)", "response": "Load a single item from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef single_load(input_, ac_parser=None, ac_template=False,\n                ac_context=None, **options):\n    r\"\"\"\n    Load single configuration file.\n\n    .. note::\n\n       :func:`load` is a preferable alternative and this API should be used\n       only if there is a need to emphasize given input 'input\\_' is single\n       one.\n\n    :param input\\_:\n        File path or file or file-like object or pathlib.Path object represents\n        the file or a namedtuple 'anyconfig.globals.IOInfo' object represents\n        some input to load some data from\n    :param ac_parser: Forced parser type or parser object itself\n    :param ac_template:\n        Assume configuration file may be a template file and try to compile it\n        AAR if True\n    :param ac_context: A dict presents context to instantiate template\n    :param options: Optional keyword arguments such as:\n\n        - Options common in :func:`single_load`, :func:`multi_load`,\n          :func:`load` and :func:`loads`:\n\n          - ac_dict: callable (function or class) to make mapping objects from\n            loaded data if the selected backend can customize that such as JSON\n            which supports that with 'object_pairs_hook' option, or None. If\n            this option was not given or None, dict or\n            :class:`collections.OrderedDict` will be used to make result as\n            mapping object depends on if ac_ordered (see below) is True and\n            selected backend can keep the order of items loaded. See also\n            :meth:`_container_factory` of\n            :class:`anyconfig.backend.base.Parser` for more implementation\n            details.\n\n          - ac_ordered: True if you want to keep resuls ordered. Please note\n            that order of items may be lost depends on the selected backend.\n\n          - ac_schema: JSON schema file path to validate given config file\n          - ac_query: JMESPath expression to query data\n\n        - Common backend options:\n\n          - ac_ignore_missing:\n            Ignore and just return empty result if given file 'input\\_' does\n            not exist actually.\n\n        - Backend specific options such as {\"indent\": 2} for JSON backend\n\n    :return: Mapping object\n    :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n    \"\"\"\n    cnf = _single_load(input_, ac_parser=ac_parser, ac_template=ac_template,\n                       ac_context=ac_context, **options)\n    schema = _maybe_schema(ac_template=ac_template, ac_context=ac_context,\n                           **options)\n    cnf = _try_validate(cnf, schema, **options)\n    return anyconfig.query.query(cnf, **options)", "response": "r Loads a single configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(path_specs, ac_parser=None, ac_dict=None, ac_template=False,\n         ac_context=None, **options):\n    r\"\"\"\n    Load single or multiple config files or multiple config files specified in\n    given paths pattern or pathlib.Path object represents config files or a\n    namedtuple 'anyconfig.globals.IOInfo' object represents some inputs.\n\n    :param path_specs:\n        A list of file path or a glob pattern such as r'/a/b/\\*.json'to list of\n        files, file or file-like object or pathlib.Path object represents the\n        file or a namedtuple 'anyconfig.globals.IOInfo' object represents some\n        inputs to load some data from.\n    :param ac_parser: Forced parser type or parser object\n    :param ac_dict:\n        callable (function or class) to make mapping object will be returned as\n        a result or None. If not given or ac_dict is None, default mapping\n        object used to store resutls is dict or\n        :class:`collections.OrderedDict` if ac_ordered is True and selected\n        backend can keep the order of items in mapping objects.\n\n    :param ac_template: Assume configuration file may be a template file and\n        try to compile it AAR if True\n    :param ac_context: A dict presents context to instantiate template\n    :param options:\n        Optional keyword arguments. See also the description of 'options' in\n        :func:`single_load` and :func:`multi_load`\n\n    :return: Mapping object or any query result might be primitive objects\n    :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n    \"\"\"\n    marker = options.setdefault(\"ac_marker\", options.get(\"marker\", '*'))\n\n    if anyconfig.utils.is_path_like_object(path_specs, marker):\n        return single_load(path_specs, ac_parser=ac_parser, ac_dict=ac_dict,\n                           ac_template=ac_template, ac_context=ac_context,\n                           **options)\n\n    if not anyconfig.utils.is_paths(path_specs, marker):\n        raise ValueError(\"Possible invalid input %r\" % path_specs)\n\n    return multi_load(path_specs, ac_parser=ac_parser, ac_dict=ac_dict,\n                      ac_template=ac_template, ac_context=ac_context,\n                      **options)", "response": "r Loads a single or multiple config files or multiple config files specified in path_specs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a configuration file into a mapping object.", "response": "def loads(content, ac_parser=None, ac_dict=None, ac_template=False,\n          ac_context=None, **options):\n    \"\"\"\n    :param content: Configuration file's content (a string)\n    :param ac_parser: Forced parser type or ID or parser object\n    :param ac_dict:\n        callable (function or class) to make mapping object will be returned as\n        a result or None. If not given or ac_dict is None, default mapping\n        object used to store resutls is dict or\n        :class:`collections.OrderedDict` if ac_ordered is True and selected\n        backend can keep the order of items in mapping objects.\n    :param ac_template: Assume configuration file may be a template file and\n        try to compile it AAR if True\n    :param ac_context: Context dict to instantiate template\n    :param options:\n        Optional keyword arguments. See also the description of 'options' in\n        :func:`single_load` function.\n\n    :return: Mapping object or any query result might be primitive objects\n    :raises: ValueError, UnknownProcessorTypeError\n    \"\"\"\n    if ac_parser is None:\n        LOGGER.warning(\"ac_parser was not given but it's must to find correct \"\n                       \"parser to load configurations from string.\")\n        return None\n\n    psr = find(None, forced_type=ac_parser)\n    schema = None\n    ac_schema = options.get(\"ac_schema\", None)\n    if ac_schema is not None:\n        options[\"ac_schema\"] = None\n        schema = loads(ac_schema, ac_parser=psr, ac_dict=ac_dict,\n                       ac_template=ac_template, ac_context=ac_context,\n                       **options)\n\n    if ac_template:\n        compiled = anyconfig.template.try_render(content=content,\n                                                 ctx=ac_context, **options)\n        if compiled is not None:\n            content = compiled\n\n    cnf = psr.loads(content, ac_dict=ac_dict, **options)\n    cnf = _try_validate(cnf, schema, **options)\n    return anyconfig.query.query(cnf, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndump data to out.", "response": "def dump(data, out, ac_parser=None, **options):\n    \"\"\"\n    Save 'data' to 'out'.\n\n    :param data: A mapping object may have configurations data to dump\n    :param out:\n        An output file path, a file, a file-like object, :class:`pathlib.Path`\n        object represents the file or a namedtuple 'anyconfig.globals.IOInfo'\n        object represents output to dump some data to.\n    :param ac_parser: Forced parser type or parser object\n    :param options:\n        Backend specific optional arguments, e.g. {\"indent\": 2} for JSON\n        loader/dumper backend\n\n    :raises: ValueError, UnknownProcessorTypeError, UnknownFileTypeError\n    \"\"\"\n    ioi = anyconfig.ioinfo.make(out)\n    psr = find(ioi, forced_type=ac_parser)\n    LOGGER.info(\"Dumping: %s\", ioi.path)\n    psr.dump(data, ioi, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps data in forced type format.", "response": "def dumps(data, ac_parser=None, **options):\n    \"\"\"\n    Return string representation of 'data' in forced type format.\n\n    :param data: Config data object to dump\n    :param ac_parser: Forced parser type or ID or parser object\n    :param options: see :func:`dump`\n\n    :return: Backend-specific string representation for the given data\n    :raises: ValueError, UnknownProcessorTypeError\n    \"\"\"\n    psr = find(None, forced_type=ac_parser)\n    return psr.dumps(data, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries the JMES API for the given data and JMESPath expression.", "response": "def query(data, expression, **options):\n    \"\"\"\n    API just wraps :func:`anyconfig.query.query`.\n\n    :param data: Config data object to query\n    :param expression: JMESPath expression to query data\n    :param options: Ignored in current implementation\n\n    :return: Query result object may be a primitive (int, str, etc.) or dict.\n    \"\"\"\n    return anyconfig.query.query(data, ac_query=expression)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a logger with a NullHandler.", "response": "def getLogger(name=\"anyconfig\"):\n    \"\"\"\n    See: \"Configuring Logging for a Library\" in python standard logging howto,\n    e.g. https://docs.python.org/2/howto/logging.html#library-config.\n    \"\"\"\n    logger = logging.getLogger(name)\n    logger.addHandler(anyconfig.compat.NullHandler())\n\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_single(str_):\n    if str_ is None:\n        return ''\n\n    str_ = str_.strip()\n\n    if not str_:\n        return ''\n\n    if BOOL_PATTERN.match(str_) is not None:\n        return bool(str_)\n\n    if INT_PATTERN.match(str_) is not None:\n        return int(str_)\n\n    if STR_PATTERN.match(str_) is not None:\n        return str_[1:-1]\n\n    return str_", "response": "A simple parser to parse a single string into a sequence of Int Bool String"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(str_, lsep=\",\", avsep=\":\", vssep=\",\", avssep=\";\"):\n    if avsep in str_:\n        return parse_attrlist(str_, avsep, vssep, avssep)\n    if lsep in str_:\n        return parse_list(str_, lsep)\n\n    return parse_single(str_)", "response": "Generic parser for the XML file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts logging level to log level.", "response": "def to_log_level(level):\n    \"\"\"\n    :param level: Logging level in int = 0 .. 2\n\n    >>> to_log_level(0) == logging.WARN\n    True\n    >>> to_log_level(5)  # doctest: +IGNORE_EXCEPTION_DETAIL, +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: wrong log level passed: 5\n    >>>\n    \"\"\"\n    if level < 0 or level >= 3:\n        raise ValueError(\"wrong log level passed: \" + str(level))\n\n    return [logging.WARN, logging.INFO, logging.DEBUG][level]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_parser(defaults=None):\n    if defaults is None:\n        defaults = DEFAULTS\n\n    ctypes = API.list_types()\n    ctypes_s = \", \".join(ctypes)\n    type_help = \"Select type of %s config files from \" + \\\n        ctypes_s + \" [Automatically detected by file ext]\"\n\n    mts = API.MERGE_STRATEGIES\n    mts_s = \", \".join(mts)\n    mt_help = \"Select strategy to merge multiple configs from \" + \\\n        mts_s + \" [%(merge)s]\" % defaults\n\n    parser = argparse.ArgumentParser(usage=USAGE)\n    parser.set_defaults(**defaults)\n\n    parser.add_argument(\"inputs\", type=str, nargs='*', help=\"Input files\")\n    parser.add_argument(\"--version\", action=\"version\",\n                        version=\"%%(prog)s %s\" % anyconfig.globals.VERSION)\n\n    lpog = parser.add_argument_group(\"List specific options\")\n    lpog.add_argument(\"-L\", \"--list\", action=\"store_true\",\n                      help=\"List supported config types\")\n\n    spog = parser.add_argument_group(\"Schema specific options\")\n    spog.add_argument(\"--validate\", action=\"store_true\",\n                      help=\"Only validate input files and do not output. \"\n                           \"You must specify schema file with -S/--schema \"\n                           \"option.\")\n    spog.add_argument(\"--gen-schema\", action=\"store_true\",\n                      help=\"Generate JSON schema for givne config file[s] \"\n                           \"and output it instead of (merged) configuration.\")\n\n    gspog = parser.add_argument_group(\"Query/Get/set options\")\n    gspog.add_argument(\"-Q\", \"--query\", help=_QUERY_HELP)\n    gspog.add_argument(\"--get\", help=_GET_HELP)\n    gspog.add_argument(\"--set\", help=_SET_HELP)\n\n    parser.add_argument(\"-o\", \"--output\", help=\"Output file path\")\n    parser.add_argument(\"-I\", \"--itype\", choices=ctypes, metavar=\"ITYPE\",\n                        help=(type_help % \"Input\"))\n    parser.add_argument(\"-O\", \"--otype\", choices=ctypes, metavar=\"OTYPE\",\n                        help=(type_help % \"Output\"))\n    parser.add_argument(\"-M\", \"--merge\", choices=mts, metavar=\"MERGE\",\n                        help=mt_help)\n    parser.add_argument(\"-A\", \"--args\", help=\"Argument configs to override\")\n    parser.add_argument(\"--atype\", choices=ctypes, metavar=\"ATYPE\",\n                        help=_ATYPE_HELP_FMT % ctypes_s)\n\n    cpog = parser.add_argument_group(\"Common options\")\n    cpog.add_argument(\"-x\", \"--ignore-missing\", action=\"store_true\",\n                      help=\"Ignore missing input files\")\n    cpog.add_argument(\"-T\", \"--template\", action=\"store_true\",\n                      help=\"Enable template config support\")\n    cpog.add_argument(\"-E\", \"--env\", action=\"store_true\",\n                      help=\"Load configuration defaults from \"\n                           \"environment values\")\n    cpog.add_argument(\"-S\", \"--schema\", help=\"Specify Schema file[s] path\")\n    cpog.add_argument(\"-e\", \"--extra-opts\",\n                      help=\"Extra options given to the API call, \"\n                           \"--extra-options indent:2 (specify the \"\n                           \"indent for pretty-printing of JSON outputs) \"\n                           \"for example\")\n    cpog.add_argument(\"-v\", \"--verbose\", action=\"count\", dest=\"loglevel\",\n                      help=\"Verbose mode; -v or -vv (more verbose)\")\n    return parser", "response": "Create an argument parser for the base command line interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _exit_with_output(content, exit_code=0):\n    (sys.stdout if exit_code == 0 else sys.stderr).write(content + os.linesep)\n    sys.exit(exit_code)", "response": "Exit the program with printing out messages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing list of info of parsers available", "response": "def _show_psrs():\n    \"\"\"Show list of info of parsers available\n    \"\"\"\n    sep = os.linesep\n\n    types = \"Supported types: \" + \", \".join(API.list_types())\n    cids = \"IDs: \" + \", \".join(c for c, _ps in API.list_by_cid())\n\n    x_vs_ps = [\"  %s: %s\" % (x, \", \".join(p.cid() for p in ps))\n               for x, ps in API.list_by_extension()]\n    exts = \"File extensions:\" + sep + sep.join(x_vs_ps)\n\n    _exit_with_output(sep.join([types, exts, cids]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_args(argv):\n    parser = make_parser()\n    args = parser.parse_args(argv)\n    LOGGER.setLevel(to_log_level(args.loglevel))\n\n    if args.inputs:\n        if '-' in args.inputs:\n            args.inputs = sys.stdin\n    else:\n        if args.list:\n            _show_psrs()\n        elif args.env:\n            cnf = os.environ.copy()\n            _output_result(cnf, args.output, args.otype or \"json\", None, None)\n            sys.exit(0)\n        else:\n            parser.print_usage()\n            sys.exit(1)\n\n    if args.validate and args.schema is None:\n        _exit_with_output(\"--validate option requires --scheme option\", 1)\n\n    return args", "response": "Parse command line arguments and show supported config format types or usage."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_get(cnf, get_path):\n    (cnf, err) = API.get(cnf, get_path)\n    if cnf is None:  # Failed to get the result.\n        _exit_with_output(\"Failed to get result: err=%s\" % err, 1)\n\n    return cnf", "response": "Get a single object from the given configuration object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _output_type_by_input_path(inpaths, itype, fmsg):\n    msg = (\"Specify inpath and/or outpath type[s] with -I/--itype \"\n           \"or -O/--otype option explicitly\")\n    if itype is None:\n        try:\n            otype = API.find(inpaths[0]).type()\n        except API.UnknownFileTypeError:\n            _exit_with_output((fmsg % inpaths[0]) + msg, 1)\n        except (ValueError, IndexError):\n            _exit_with_output(msg, 1)\n    else:\n        otype = itype\n\n    return otype", "response": "Return the type of the object given the input file paths and the input type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to dump a single object to outpath.", "response": "def _try_dump(cnf, outpath, otype, fmsg, extra_opts=None):\n    \"\"\"\n    :param cnf: Configuration object to print out\n    :param outpath: Output file path or None\n    :param otype: Output type or None\n    :param fmsg: message if it cannot detect otype by 'inpath'\n    :param extra_opts: Map object will be given to API.dump as extra options\n    \"\"\"\n    if extra_opts is None:\n        extra_opts = {}\n    try:\n        API.dump(cnf, outpath, otype, **extra_opts)\n    except API.UnknownFileTypeError:\n        _exit_with_output(fmsg % outpath, 1)\n    except API.UnknownProcessorTypeError:\n        _exit_with_output(\"Invalid output type '%s'\" % otype, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _output_result(cnf, outpath, otype, inpaths, itype,\n                   extra_opts=None):\n    \"\"\"\n    :param cnf: Configuration object to print out\n    :param outpath: Output file path or None\n    :param otype: Output type or None\n    :param inpaths: List of input file paths\n    :param itype: Input type or None\n    :param extra_opts: Map object will be given to API.dump as extra options\n    \"\"\"\n    fmsg = (\"Uknown file type and cannot detect appropriate backend \"\n            \"from its extension, '%s'\")\n\n    if not anyconfig.utils.is_dict_like(cnf):\n        _exit_with_output(str(cnf))  # Print primitive types as it is.\n\n    if not outpath or outpath == \"-\":\n        outpath = sys.stdout\n        if otype is None:\n            otype = _output_type_by_input_path(inpaths, itype, fmsg)\n\n    _try_dump(cnf, outpath, otype, fmsg, extra_opts=extra_opts)", "response": "Output the result of the dump of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _load_diff(args, extra_opts):\n    try:\n        diff = API.load(args.inputs, args.itype,\n                        ac_ignore_missing=args.ignore_missing,\n                        ac_merge=args.merge,\n                        ac_template=args.template,\n                        ac_schema=args.schema,\n                        **extra_opts)\n    except API.UnknownProcessorTypeError:\n        _exit_with_output(\"Wrong input type '%s'\" % args.itype, 1)\n    except API.UnknownFileTypeError:\n        _exit_with_output(\"No appropriate backend was found for given file \"\n                          \"'%s'\" % args.itype, 1)\n    _exit_if_load_failure(diff,\n                          \"Failed to load: args=%s\" % \", \".join(args.inputs))\n\n    return diff", "response": "Load the object from the given file and return the object that was loaded."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter the object cnf according to the given arguments", "response": "def _do_filter(cnf, args):\n    \"\"\"\n    :param cnf: Mapping object represents configuration data\n    :param args: :class:`argparse.Namespace` object\n    :return: 'cnf' may be updated\n    \"\"\"\n    if args.query:\n        cnf = API.query(cnf, args.query)\n    elif args.get:\n        cnf = _do_get(cnf, args.get)\n    elif args.set:\n        (key, val) = args.set.split('=')\n        API.set_(cnf, key, anyconfig.parser.parse(val))\n\n    return cnf"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_all(data, schema):\n    vldtr = jsonschema.Draft4Validator(schema)  # :raises: SchemaError, ...\n    errors = list(vldtr.iter_errors(data))\n\n    return (not errors, [err.message for err in errors])", "response": "Validate all data according to schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating data with given schema.", "response": "def _validate(data, schema, ac_schema_safe=True, **options):\n    \"\"\"\n    See the descritpion of :func:`validate` for more details of parameters and\n    return value.\n\n    Validate target object 'data' with given schema object.\n    \"\"\"\n    try:\n        jsonschema.validate(data, schema, **options)\n\n    except (jsonschema.ValidationError, jsonschema.SchemaError,\n            Exception) as exc:\n        if ac_schema_safe:\n            return (False, str(exc))  # Validation was failed.\n        raise\n\n    return (True, '')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating target object with given schema object loaded from JSON schema.", "response": "def validate(data, schema, ac_schema_safe=True, ac_schema_errors=False,\n             **options):\n    \"\"\"\n    Validate target object with given schema object, loaded from JSON schema.\n\n    See also: https://python-jsonschema.readthedocs.org/en/latest/validate/\n\n    :parae data: Target object (a dict or a dict-like object) to validate\n    :param schema: Schema object (a dict or a dict-like object)\n        instantiated from schema JSON file or schema JSON string\n    :param options: Other keyword options such as:\n\n        - ac_schema_safe: Exception (jsonschema.ValidationError or\n          jsonschema.SchemaError or others) will be thrown during validation\n          process due to any validation or related errors. However, these will\n          be catched by default, and will be re-raised if 'ac_safe' is False.\n\n        - ac_schema_errors: Lazily yield each of the validation errors and\n          returns all of them if validation fails.\n\n    :return: (True if validation succeeded else False, error message[s])\n    \"\"\"\n    if not JSONSCHEMA_IS_AVAIL:\n        return (True, _NA_MSG)\n\n    options = anyconfig.utils.filter_options((\"cls\", ), options)\n    if ac_schema_errors:\n        return _validate_all(data, schema, **options)\n\n    return _validate(data, schema, ac_schema_safe, **options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a JSON schema object with type annotation added for given object.", "response": "def array_to_schema(arr, **options):\n    \"\"\"\n    Generate a JSON schema object with type annotation added for given object.\n\n    :param arr: Array of mapping objects like dicts\n    :param options: Other keyword options such as:\n\n        - ac_schema_strict: True if more strict (precise) schema is needed\n        - ac_schema_typemap: Type to JSON schema type mappings\n\n    :return: Another mapping objects represents JSON schema of items\n    \"\"\"\n    (typemap, strict) = _process_options(**options)\n\n    arr = list(arr)\n    scm = dict(type=typemap[list],\n               items=gen_schema(arr[0] if arr else \"str\", **options))\n    if strict:\n        nitems = len(arr)\n        scm[\"minItems\"] = nitems\n        scm[\"uniqueItems\"] = len(set(arr)) == nitems\n\n    return scm"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef object_to_schema(obj, **options):\n    (typemap, strict) = _process_options(**options)\n\n    props = dict((k, gen_schema(v, **options)) for k, v in obj.items())\n    scm = dict(type=typemap[dict], properties=props)\n    if strict:\n        scm[\"required\"] = sorted(props.keys())\n\n    return scm", "response": "Generate a node represents JSON schema object for given object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a node represents JSON schema object for given configuration data object.", "response": "def gen_schema(data, **options):\n    \"\"\"\n    Generate a node represents JSON schema object with type annotation added\n    for given object node.\n\n    :param data: Configuration data object (dict[-like] or namedtuple)\n    :param options: Other keyword options such as:\n\n        - ac_schema_strict: True if more strict (precise) schema is needed\n        - ac_schema_typemap: Type to JSON schema type mappings\n\n    :return: A dict represents JSON schema of this node\n    \"\"\"\n    if data is None:\n        return dict(type=\"null\")\n\n    _type = type(data)\n\n    if _type in _SIMPLE_TYPES:\n        typemap = options.get(\"ac_schema_typemap\", _SIMPLETYPE_MAP)\n        scm = dict(type=typemap[_type])\n\n    elif anyconfig.utils.is_dict_like(data):\n        scm = object_to_schema(data, **options)\n\n    elif anyconfig.utils.is_list_like(data):\n        scm = array_to_schema(data, **options)\n\n    return scm"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ensure_outdir_exists(filepath):\n    outdir = os.path.dirname(filepath)\n\n    if outdir and not os.path.exists(outdir):\n        LOGGER.debug(\"Making output dir: %s\", outdir)\n        os.makedirs(outdir)", "response": "Make dir to dump filepath if that dir does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_method(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"Wrapper function.\n        \"\"\"\n        return func(*args[1:], **kwargs)\n\n    return wrapper", "response": "Converts a function to a method that will be called with the first argument as the first argument."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_with_fn(load_fn, content_or_strm, container, allow_primitives=False,\n                 **options):\n    \"\"\"\n    Load data from given string or stream 'content_or_strm'.\n\n    :param load_fn: Callable to load data\n    :param content_or_strm: data content or stream provides it\n    :param container: callble to make a container object\n    :param allow_primitives:\n        True if the parser.load* may return objects of primitive data types\n        other than mapping types such like JSON parser\n    :param options: keyword options passed to 'load_fn'\n\n    :return: container object holding data\n    \"\"\"\n    ret = load_fn(content_or_strm, **options)\n    if anyconfig.utils.is_dict_like(ret):\n        return container() if (ret is None or not ret) else container(ret)\n\n    return ret if allow_primitives else container(ret)", "response": "Load data from given string or stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump_with_fn(dump_fn, data, stream, **options):\n    if stream is None:\n        return dump_fn(data, **options)\n\n    return dump_fn(data, stream, **options)", "response": "Dump data to a string if stream is None or dump data to a file or file - like object stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _container_factory(self, **options):\n        ac_dict = options.get(\"ac_dict\", False)\n        _dicts = [x for x in (options.get(o) for o in self.dict_options())\n                  if x]\n\n        if self.dict_options() and ac_dict and callable(ac_dict):\n            return ac_dict  # Higher priority than ac_ordered.\n        if _dicts and callable(_dicts[0]):\n            return _dicts[0]\n        if self.ordered() and options.get(\"ac_ordered\", False):\n            return anyconfig.compat.OrderedDict\n\n        return dict", "response": "Returns a class or function that returns the appropriate container class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_options(self, container, **options):\n        # Force set dict option if available in backend. For example,\n        # options[\"object_hook\"] will be OrderedDict if 'container' was\n        # OrderedDict in JSON backend.\n        for opt in self.dict_options():\n            options.setdefault(opt, container)\n\n        return anyconfig.utils.filter_options(self._load_opts, options)", "response": "Select backend specific loading options."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_from_string(self, content, container, **kwargs):\n        _not_implemented(self, content, container, **kwargs)", "response": "Load config from given string content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading config from given filepath.", "response": "def load_from_path(self, filepath, container, **kwargs):\n        \"\"\"\n        Load config from given file path 'filepath`.\n\n        :param filepath: Config file path\n        :param container: callble to make a container object later\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n\n        :return: Dict-like object holding config parameters\n        \"\"\"\n        _not_implemented(self, filepath, container, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_from_stream(self, stream, container, **kwargs):\n        _not_implemented(self, stream, container, **kwargs)", "response": "Load config from given stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading config from given string content.", "response": "def loads(self, content, **options):\n        \"\"\"\n        Load config from given string 'content' after some checks.\n\n        :param content:  Config file content\n        :param options:\n            options will be passed to backend specific loading functions.\n            please note that options have to be sanitized w/\n            :func:`anyconfig.utils.filter_options` later to filter out options\n            not in _load_opts.\n\n        :return: dict or dict-like object holding configurations\n        \"\"\"\n        container = self._container_factory(**options)\n        if not content or content is None:\n            return container()\n\n        options = self._load_options(container, **options)\n        return self.load_from_string(content, container, **options)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads config from a file path or file - like object which contains a namedtuple object containing the configuration and the options.", "response": "def load(self, ioi, ac_ignore_missing=False, **options):\n        \"\"\"\n        Load config from a file path or a file / file-like object which 'ioi'\n        refering after some checks.\n\n        :param ioi:\n            'anyconfig.globals.IOInfo' namedtuple object provides various info\n            of input object to load data from\n\n        :param ac_ignore_missing:\n            Ignore and just return empty result if given `ioi` object does not\n            exist in actual.\n        :param options:\n            options will be passed to backend specific loading functions.\n            please note that options have to be sanitized w/\n            :func:`anyconfig.utils.filter_options` later to filter out options\n            not in _load_opts.\n\n        :return: dict or dict-like object holding configurations\n        \"\"\"\n        container = self._container_factory(**options)\n        options = self._load_options(container, **options)\n\n        if not ioi:\n            return container()\n\n        if anyconfig.utils.is_stream_ioinfo(ioi):\n            cnf = self.load_from_stream(ioi.src, container, **options)\n        else:\n            if ac_ignore_missing and not os.path.exists(ioi.path):\n                return container()\n\n            cnf = self.load_from_path(ioi.path, container, **options)\n\n        return cnf"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump_to_path(self, cnf, filepath, **kwargs):\n        _not_implemented(self, cnf, filepath, **kwargs)", "response": "Dump config cnf to a file filepath."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump_to_stream(self, cnf, stream, **kwargs):\n        _not_implemented(self, cnf, stream, **kwargs)", "response": "Dump the configuration data to a file - like object stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dumps(self, cnf, **kwargs):\n        kwargs = anyconfig.utils.filter_options(self._dump_opts, kwargs)\n        return self.dump_to_string(cnf, **kwargs)", "response": "Dump config cnf to a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump(self, cnf, ioi, **kwargs):\n        kwargs = anyconfig.utils.filter_options(self._dump_opts, kwargs)\n\n        if anyconfig.utils.is_stream_ioinfo(ioi):\n            self.dump_to_stream(cnf, ioi.src, **kwargs)\n        else:\n            ensure_outdir_exists(ioi.path)\n            self.dump_to_path(cnf, ioi.path, **kwargs)", "response": "Dump config cnf to output object of which ioi refering."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads config from given stream.", "response": "def load_from_stream(self, stream, container, **kwargs):\n        \"\"\"\n        Load config from given stream 'stream'.\n\n        :param stream: Config file or file-like object\n        :param container: callble to make a container object later\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n\n        :return: Dict-like object holding config parameters\n        \"\"\"\n        return self.load_from_string(stream.read(), container, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_from_path(self, filepath, container, **kwargs):\n        with self.ropen(filepath) as inp:\n            return self.load_from_stream(inp, container, **kwargs)", "response": "Load config from given filepath."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_from_string(self, content, container, **kwargs):\n        return self.load_from_stream(anyconfig.compat.StringIO(content),\n                                     container, **kwargs)", "response": "Load config from given string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndump the configuration data cnf to a file filepath.", "response": "def dump_to_path(self, cnf, filepath, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a file 'filepath'.\n\n        :param cnf: Configuration data to dump\n        :param filepath: Config file path\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n        \"\"\"\n        with self.wopen(filepath) as out:\n            out.write(self.dump_to_string(cnf, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndumping the config data to a file - like object stream.", "response": "def dump_to_stream(self, cnf, stream, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a file-like object 'stream'.\n\n        TODO: How to process socket objects same as file objects ?\n\n        :param cnf: Configuration data to dump\n        :param stream:  Config file or file like object\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n        \"\"\"\n        stream.write(self.dump_to_string(cnf, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping config cnf to a string.", "response": "def dump_to_string(self, cnf, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a string.\n\n        :param cnf: Configuration data to dump\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n\n        :return: Dict-like object holding config parameters\n        \"\"\"\n        stream = anyconfig.compat.StringIO()\n        self.dump_to_stream(cnf, stream, **kwargs)\n        return stream.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndumps config cnf to a file filepath.", "response": "def dump_to_path(self, cnf, filepath, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a file 'filepath`.\n\n        :param cnf: Configuration data to dump\n        :param filepath: Config file path\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n        \"\"\"\n        with self.wopen(filepath) as out:\n            self.dump_to_stream(cnf, out, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_from_string(self, content, container, **options):\n        return load_with_fn(self._load_from_string_fn, content, container,\n                            allow_primitives=self.allow_primitives(),\n                            **options)", "response": "Load configuration data from given string content."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload data from given stream.", "response": "def load_from_stream(self, stream, container, **options):\n        \"\"\"\n        Load data from given stream 'stream'.\n\n        :param stream: Stream provides configuration data\n        :param container: callble to make a container object\n        :param options: keyword options passed to '_load_from_stream_fn'\n\n        :return: container object holding the configuration data\n        \"\"\"\n        return load_with_fn(self._load_from_stream_fn, stream, container,\n                            allow_primitives=self.allow_primitives(),\n                            **options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndump the configuration data cnf to a file - like object stream.", "response": "def dump_to_stream(self, cnf, stream, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a file-like object 'stream'.\n\n        TODO: How to process socket objects same as file objects ?\n\n        :param cnf: Configuration data to dump\n        :param stream:  Config file or file like object\n        :param kwargs: optional keyword parameters to be sanitized :: dict\n        \"\"\"\n        dump_with_fn(self._dump_to_stream_fn, cnf, stream, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guess_io_type(obj):\n    if obj is None:\n        return IOI_NONE\n    if anyconfig.utils.is_path(obj):\n        return IOI_PATH_STR\n    if anyconfig.utils.is_path_obj(obj):\n        return IOI_PATH_OBJ\n    if anyconfig.utils.is_file_stream(obj):\n        return IOI_STREAM\n\n    raise ValueError(\"Unknown I/O type object: %r\" % obj)", "response": "Guess input or output type of obj."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninspect the object and returns the type path opener and extension of the object.", "response": "def inspect_io_obj(obj):\n    \"\"\"\n    :param obj: a path string, a pathlib.Path or a file / file-like object\n\n    :return: A tuple of (objtype, objpath, objopener)\n    :raises: UnknownFileTypeError\n    \"\"\"\n    itype = guess_io_type(obj)\n\n    if itype == IOI_PATH_STR:\n        ipath = anyconfig.utils.normpath(obj)\n        ext = anyconfig.utils.get_file_extension(ipath)\n        opener = open\n    elif itype == IOI_PATH_OBJ:\n        ipath = anyconfig.utils.normpath(obj.as_posix())\n        ext = anyconfig.utils.get_file_extension(ipath)\n        opener = obj.open\n    elif itype == IOI_STREAM:\n        ipath = anyconfig.utils.get_path_from_stream(obj)\n        ext = anyconfig.utils.get_file_extension(ipath) if ipath else None\n        opener = anyconfig.utils.noop\n    elif itype == IOI_NONE:\n        ipath = ext = None\n        opener = anyconfig.utils.noop\n    else:\n        raise UnknownFileTypeError(\"%r\" % obj)\n\n    return (itype, ipath, opener, ext)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make(obj):\n    if anyconfig.utils.is_ioinfo(obj):\n        return obj\n\n    (itype, ipath, opener, ext) = inspect_io_obj(obj)\n    return IOInfo(src=obj, type=itype, path=ipath, opener=opener,\n                  extension=ext)", "response": "Create a new object from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a line containing shell variable definition.", "response": "def _parseline(line):\n    \"\"\"\n    Parse a line contains shell variable definition.\n\n    :param line: A string to parse, must not start with '#' (comment)\n    :return: A tuple of (key, value), both key and value may be None\n\n    >>> _parseline(\"aaa=\")\n    ('aaa', '')\n    >>> _parseline(\"aaa=bbb\")\n    ('aaa', 'bbb')\n    >>> _parseline(\"aaa='bb b'\")\n    ('aaa', 'bb b')\n    >>> _parseline('aaa=\"bb#b\"')\n    ('aaa', 'bb#b')\n    >>> _parseline('aaa=\"bb\\\\\"b\"')\n    ('aaa', 'bb\"b')\n    >>> _parseline(\"aaa=bbb   # ccc\")\n    ('aaa', 'bbb')\n    \"\"\"\n    match = re.match(r\"^\\s*(export)?\\s*(\\S+)=(?:(?:\"\n                     r\"(?:\\\"(.*[^\\\\])\\\")|(?:'(.*[^\\\\])')|\"\n                     r\"(?:([^\\\"'#\\s]+)))?)\\s*#*\", line)\n    if not match:\n        LOGGER.warning(\"Invalid line found: %s\", line)\n        return (None, None)\n\n    tpl = match.groups()\n    vals = list(itertools.dropwhile(lambda x: x is None, tpl[2:]))\n    return (tpl[1], vals[0] if vals else '')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(stream, container=dict):\n    ret = container()\n\n    for line in stream.readlines():\n        line = line.rstrip()\n        if line is None or not line:\n            continue\n\n        (key, val) = _parseline(line)\n        if key is None:\n            LOGGER.warning(\"Empty val in the line: %s\", line)\n            continue\n\n        ret[key] = val\n\n    return ret", "response": "Load and parse a file or file - like object stream provides simple shell\n    variables and definitions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping the config cnf to a file or file - like object stream.", "response": "def dump_to_stream(self, cnf, stream, **kwargs):\n        \"\"\"\n        Dump config 'cnf' to a file or file-like object 'stream'.\n\n        :param cnf: Shell variables data to dump\n        :param stream: Shell script file or file like object\n        :param kwargs: backend-specific optional keyword parameters :: dict\n        \"\"\"\n        for key, val in anyconfig.compat.iteritems(cnf):\n            stream.write(\"%s='%s'%s\" % (key, val, os.linesep))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmyk(c, m, y, k):\n    return Color(\"cmyk\", c, m, y, k)", "response": "Creates a color object in the CMYK color space."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the color from RGB coordinates to HSL.", "response": "def RgbToHsl(r, g, b):\n    '''Convert the color from RGB coordinates to HSL.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (h, s, l) tuple in the range:\n      h[0...360],\n      s[0...1],\n      l[0...1]\n\n    >>> Color.RgbToHsl(1, 0.5, 0)\n    (30.0, 1.0, 0.5)\n\n    '''\n    minVal = min(r, g, b)       # min RGB value\n    maxVal = max(r, g, b)       # max RGB value\n\n    l = (maxVal + minVal) / 2.0\n    if minVal==maxVal:\n      return (0.0, 0.0, l)    # achromatic (gray)\n\n    d = maxVal - minVal         # delta RGB value\n\n    if l < 0.5: s = d / (maxVal + minVal)\n    else: s = d / (2.0 - maxVal - minVal)\n\n    dr, dg, db = [(maxVal-val) / d for val in (r, g, b)]\n\n    if r==maxVal:\n      h = db - dg\n    elif g==maxVal:\n      h = 2.0 + dr - db\n    else:\n      h = 4.0 + dg - dr\n\n    h = (h*60.0) % 360.0\n    return (h, s, l)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts the color from HSL coordinates to RGB.", "response": "def HslToRgb(h, s, l):\n    '''Convert the color from HSL coordinates to RGB.\n\n    Parameters:\n      :h:\n        The Hue component value [0...1]\n      :s:\n        The Saturation component value [0...1]\n      :l:\n        The Lightness component value [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> Color.HslToRgb(30.0, 1.0, 0.5)\n    (1.0, 0.5, 0.0)\n\n    '''\n    if s==0: return (l, l, l)   # achromatic (gray)\n\n    if l<0.5: n2 = l * (1.0 + s)\n    else: n2 = l+s - (l*s)\n\n    n1 = (2.0 * l) - n2\n\n    h /= 60.0\n    hueToRgb = Color._HueToRgb\n    r = hueToRgb(n1, n2, h + 2)\n    g = hueToRgb(n1, n2, h)\n    b = hueToRgb(n1, n2, h - 2)\n\n    return (r, g, b)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the color from RGB coordinates to HSV.", "response": "def RgbToHsv(r, g, b):\n    '''Convert the color from RGB coordinates to HSV.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (h, s, v) tuple in the range:\n      h[0...360],\n      s[0...1],\n      v[0...1]\n\n    >>> Color.RgbToHsv(1, 0.5, 0)\n    (30.0, 1.0, 1.0)\n\n    '''\n    v = float(max(r, g, b))\n    d = v - min(r, g, b)\n    if d==0: return (0.0, 0.0, v)\n    s = d / v\n\n    dr, dg, db = [(v - val) / d for val in (r, g, b)]\n\n    if r==v:\n      h = db - dg             # between yellow & magenta\n    elif g==v:\n      h = 2.0 + dr - db       # between cyan & yellow\n    else: # b==v\n      h = 4.0 + dg - dr       # between magenta & cyan\n\n    h = (h*60.0) % 360.0\n    return (h, s, v)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef HsvToRgb(h, s, v):\n    '''Convert the color from RGB coordinates to HSV.\n\n    Parameters:\n      :h:\n        The Hus component value [0...1]\n      :s:\n        The Saturation component value [0...1]\n      :v:\n        The Value component [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> Color.HslToRgb(30.0, 1.0, 0.5)\n    (1.0, 0.5, 0.0)\n\n    '''\n    if s==0: return (v, v, v)   # achromatic (gray)\n\n    h /= 60.0\n    h = h % 6.0\n\n    i = int(h)\n    f = h - i\n    if not(i&1): f = 1-f     # if i is even\n\n    m = v * (1.0 - s)\n    n = v * (1.0 - (s * f))\n\n    if i==0: return (v, n, m)\n    if i==1: return (n, v, m)\n    if i==2: return (m, v, n)\n    if i==3: return (m, n, v)\n    if i==4: return (n, m, v)\n    return (v, m, n)", "response": "Convert the color from RGB coordinates to HSV."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef RgbToYiq(r, g, b):\n    '''Convert the color from RGB to YIQ.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (y, i, q) tuple in the range:\n      y[0...1],\n      i[0...1],\n      q[0...1]\n\n    >>> '(%g, %g, %g)' % Color.RgbToYiq(1, 0.5, 0)\n    '(0.592263, 0.458874, -0.0499818)'\n\n    '''\n    y = (r * 0.29895808) + (g * 0.58660979) + (b *0.11443213)\n    i = (r * 0.59590296) - (g * 0.27405705) - (b *0.32184591)\n    q = (r * 0.21133576) - (g * 0.52263517) + (b *0.31129940)\n    return (y, i, q)", "response": "Convert the color from RGB to YIQ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef YiqToRgb(y, i, q):\n    '''Convert the color from YIQ coordinates to RGB.\n\n    Parameters:\n      :y:\n        Tte Y component value [0...1]\n      :i:\n        The I component value [0...1]\n      :q:\n        The Q component value [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> '(%g, %g, %g)' % Color.YiqToRgb(0.592263, 0.458874, -0.0499818)\n    '(1, 0.5, 5.442e-07)'\n\n    '''\n    r = y + (i * 0.9562) + (q * 0.6210)\n    g = y - (i * 0.2717) - (q * 0.6485)\n    b = y - (i * 1.1053) + (q * 1.7020)\n    return (r, g, b)", "response": "Convert the color from YIQ coordinates to RGB."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the color from RGB coordinates to YUV.", "response": "def RgbToYuv(r, g, b):\n    '''Convert the color from RGB coordinates to YUV.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (y, u, v) tuple in the range:\n      y[0...1],\n      u[-0.436...0.436],\n      v[-0.615...0.615]\n\n    >>> '(%g, %g, %g)' % Color.RgbToYuv(1, 0.5, 0)\n    '(0.5925, -0.29156, 0.357505)'\n\n    '''\n    y =  (r * 0.29900) + (g * 0.58700) + (b * 0.11400)\n    u = -(r * 0.14713) - (g * 0.28886) + (b * 0.43600)\n    v =  (r * 0.61500) - (g * 0.51499) - (b * 0.10001)\n    return (y, u, v)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef YuvToRgb(y, u, v):\n    '''Convert the color from YUV coordinates to RGB.\n\n    Parameters:\n      :y:\n        The Y component value [0...1]\n      :u:\n        The U component value [-0.436...0.436]\n      :v:\n        The V component value [-0.615...0.615]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> '(%g, %g, %g)' % Color.YuvToRgb(0.5925, -0.2916, 0.3575)\n    '(0.999989, 0.500015, -6.3276e-05)'\n\n    '''\n    r = y + (v * 1.13983)\n    g = y - (u * 0.39465) - (v * 0.58060)\n    b = y + (u * 2.03211)\n    return (r, g, b)", "response": "Convert the color from YUV coordinates to RGB."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the color from sRGB to XYZ.", "response": "def RgbToXyz(r, g, b):\n    '''Convert the color from sRGB to CIE XYZ.\n\n    The methods assumes that the RGB coordinates are given in the sRGB\n    colorspace (D65).\n\n    .. note::\n\n       Compensation for the sRGB gamma correction is applied before converting.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (x, y, z) tuple in the range:\n      x[0...1],\n      y[0...1],\n      z[0...1]\n\n    >>> '(%g, %g, %g)' % Color.RgbToXyz(1, 0.5, 0)\n    '(0.488941, 0.365682, 0.0448137)'\n\n    '''\n    r, g, b = [((v <= 0.03928) and [v / 12.92] or [((v+0.055) / 1.055) **2.4])[0] for v in (r, g, b)]\n\n    x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805)\n    y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722)\n    z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505)\n    return (x, y, z)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting the color from CIE XYZ coordinates to sRGB.", "response": "def XyzToRgb(x, y, z):\n    '''Convert the color from CIE XYZ coordinates to sRGB.\n\n    .. note::\n\n       Compensation for sRGB gamma correction is applied before converting.\n\n    Parameters:\n      :x:\n        The X component value [0...1]\n      :y:\n        The Y component value [0...1]\n      :z:\n        The Z component value [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> '(%g, %g, %g)' % Color.XyzToRgb(0.488941, 0.365682, 0.0448137)\n    '(1, 0.5, 6.81883e-08)'\n\n    '''\n    r =  (x * 3.2406255) - (y * 1.5372080) - (z * 0.4986286)\n    g = -(x * 0.9689307) + (y * 1.8757561) + (z * 0.0415175)\n    b =  (x * 0.0557101) - (y * 0.2040211) + (z * 1.0569959)\n    return tuple((((v <= _srgbGammaCorrInv) and [v * 12.92] or [(1.055 * (v ** (1/2.4))) - 0.055])[0] for v in (r, g, b)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the color from CIE XYZ to CIE L * a * b.", "response": "def XyzToLab(x, y, z, wref=_DEFAULT_WREF):\n    '''Convert the color from CIE XYZ to CIE L*a*b*.\n\n    Parameters:\n      :x:\n        The X component value [0...1]\n      :y:\n        The Y component value [0...1]\n      :z:\n        The Z component value [0...1]\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      The color as an (L, a, b) tuple in the range:\n      L[0...100],\n      a[-1...1],\n      b[-1...1]\n\n    >>> '(%g, %g, %g)' % Color.XyzToLab(0.488941, 0.365682, 0.0448137)\n    '(66.9518, 0.43084, 0.739692)'\n\n    >>> '(%g, %g, %g)' % Color.XyzToLab(0.488941, 0.365682, 0.0448137, Color.WHITE_REFERENCE['std_D50'])\n    '(66.9518, 0.411663, 0.67282)'\n\n    '''\n    # White point correction\n    x /= wref[0]\n    y /= wref[1]\n    z /= wref[2]\n\n    # Nonlinear distortion and linear transformation\n    x, y, z = [((v > 0.008856) and [v**_oneThird] or [(7.787 * v) + _sixteenHundredsixteenth])[0] for v in (x, y, z)]\n\n    # Vector scaling\n    l = (116 * y) - 16\n    a = 5.0 * (x - y)\n    b = 2.0 * (y - z)\n\n    return (l, a, b)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef LabToXyz(l, a, b, wref=_DEFAULT_WREF):\n    '''Convert the color from CIE L*a*b* to CIE 1931 XYZ.\n\n    Parameters:\n      :l:\n        The L component [0...100]\n      :a:\n        The a component [-1...1]\n      :b:\n        The a component [-1...1]\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      The color as an (x, y, z) tuple in the range:\n      x[0...q],\n      y[0...1],\n      z[0...1]\n\n    >>> '(%g, %g, %g)' % Color.LabToXyz(66.9518, 0.43084, 0.739692)\n    '(0.488941, 0.365682, 0.0448137)'\n\n    >>> '(%g, %g, %g)' % Color.LabToXyz(66.9518, 0.411663, 0.67282, Color.WHITE_REFERENCE['std_D50'])\n    '(0.488941, 0.365682, 0.0448138)'\n\n    '''\n    y = (l + 16) / 116\n    x = (a / 5.0) + y\n    z = y - (b / 2.0)\n    return tuple((((v > 0.206893) and [v**3] or [(v - _sixteenHundredsixteenth) / 7.787])[0] * w for v, w in zip((x, y, z), wref)))", "response": "Convert the color from CIE L * a * b * to CIE 1931 XYZ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef CmykToCmy(c, m, y, k):\n    '''Convert the color from CMYK coordinates to CMY.\n\n    Parameters:\n      :c:\n        The Cyan component value [0...1]\n      :m:\n        The Magenta component value [0...1]\n      :y:\n        The Yellow component value [0...1]\n      :k:\n        The Black component value [0...1]\n\n    Returns:\n      The color as an (c, m, y) tuple in the range:\n      c[0...1],\n      m[0...1],\n      y[0...1]\n\n    >>> '(%g, %g, %g)' % Color.CmykToCmy(1, 0.32, 0, 0.5)\n    '(1, 0.66, 0.5)'\n\n    '''\n    mk = 1-k\n    return ((c*mk + k), (m*mk + k), (y*mk + k))", "response": "Convert the color from CMYK coordinates to CMY."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef CmyToCmyk(c, m, y):\n    '''Convert the color from CMY coordinates to CMYK.\n\n    Parameters:\n      :c:\n        The Cyan component value [0...1]\n      :m:\n        The Magenta component value [0...1]\n      :y:\n        The Yellow component value [0...1]\n\n    Returns:\n      The color as an (c, m, y, k) tuple in the range:\n      c[0...1],\n      m[0...1],\n      y[0...1],\n      k[0...1]\n\n    >>> '(%g, %g, %g, %g)' % Color.CmyToCmyk(1, 0.66, 0.5)\n    '(1, 0.32, 0, 0.5)'\n\n    '''\n    k = min(c, m, y)\n    if k==1.0: return (0.0, 0.0, 0.0, 1.0)\n    mk = 1-k\n    return ((c-k) / mk, (m-k) / mk, (y-k) / mk, k)", "response": "Convert the color from CMY coordinates to CMYK."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef RgbToIntTuple(r, g, b):\n    '''Convert the color from (r, g, b) to an int tuple.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...255],\n      g[0...2551],\n      b[0...2551]\n\n    >>> Color.RgbToIntTuple(1, 0.5, 0)\n    (255, 128, 0)\n\n    '''\n    return tuple(int(round(v*255)) for v in (r, g, b))", "response": "Convert the color from ( r g b ) to an int tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef RgbToHtml(r, g, b):\n    '''Convert the color from (r, g, b) to #RRGGBB.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      A CSS string representation of this color (#RRGGBB).\n\n    >>> Color.RgbToHtml(1, 0.5, 0)\n    '#ff8000'\n\n    '''\n    return '#%02x%02x%02x' % tuple((min(round(v*255), 255) for v in (r, g, b)))", "response": "Convert the color from red green and blue components to html."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef HtmlToRgb(html):\n    '''Convert the HTML color to (r, g, b).\n\n    Parameters:\n      :html:\n        the HTML definition of the color (#RRGGBB or #RGB or a color name).\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    Throws:\n      :ValueError:\n        If html is neither a known color name or a hexadecimal RGB\n        representation.\n\n    >>> '(%g, %g, %g)' % Color.HtmlToRgb('#ff8000')\n    '(1, 0.501961, 0)'\n    >>> '(%g, %g, %g)' % Color.HtmlToRgb('ff8000')\n    '(1, 0.501961, 0)'\n    >>> '(%g, %g, %g)' % Color.HtmlToRgb('#f60')\n    '(1, 0.4, 0)'\n    >>> '(%g, %g, %g)' % Color.HtmlToRgb('f60')\n    '(1, 0.4, 0)'\n    >>> '(%g, %g, %g)' % Color.HtmlToRgb('lemonchiffon')\n    '(1, 0.980392, 0.803922)'\n\n    '''\n    html = html.strip().lower()\n    if html[0]=='#':\n      html = html[1:]\n    elif html in Color.NAMED_COLOR:\n      html = Color.NAMED_COLOR[html][1:]\n\n    if len(html)==6:\n      rgb = html[:2], html[2:4], html[4:]\n    elif len(html)==3:\n      rgb = ['%c%c' % (v,v) for v in html]\n    else:\n      raise ValueError('input #%s is not in #RRGGBB format' % html)\n\n    return tuple(((int(n, 16) / 255.0) for n in rgb))", "response": "Convert the HTML color to RGB."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef RgbToPil(r, g, b):\n    '''Convert the color from RGB to a PIL-compatible integer.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      A PIL compatible integer (0xBBGGRR).\n\n    >>> '0x%06x' % Color.RgbToPil(1, 0.5, 0)\n    '0x0080ff'\n\n    '''\n    r, g, b = [min(int(round(v*255)), 255) for v in (r, g, b)]\n    return (b << 16) + (g << 8) + r", "response": "Convert the color from RGB to PIL - compatible integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the color from a PIL - compatible integer to RGB.", "response": "def PilToRgb(pil):\n    '''Convert the color from a PIL-compatible integer to RGB.\n\n    Parameters:\n      pil: a PIL compatible color representation (0xBBGGRR)\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      the range:\n      r: [0...1]\n      g: [0...1]\n      b: [0...1]\n\n    >>> '(%g, %g, %g)' % Color.PilToRgb(0x0080ff)\n    '(1, 0.501961, 0)'\n\n    '''\n    r = 0xff & pil\n    g = 0xff & (pil >> 8)\n    b = 0xff & (pil >> 16)\n    return tuple((v / 255.0 for v in (r, g, b)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _WebSafeComponent(c, alt=False):\n    '''Convert a color component to its web safe equivalent.\n\n    Parameters:\n      :c:\n        The component value [0...1]\n      :alt:\n        If True, return the alternative value instead of the nearest one.\n\n    Returns:\n      The web safe equivalent of the component value.\n\n    '''\n    # This sucks, but floating point between 0 and 1 is quite fuzzy...\n    # So we just change the scale a while to make the equality tests\n    # work, otherwise it gets wrong at some decimal far to the right.\n    sc = c * 100.0\n\n    # If the color is already safe, return it straight away\n    d = sc % 20\n    if d==0: return c\n\n    # Get the lower and upper safe values\n    l = sc - d\n    u = l + 20\n\n    # Return the 'closest' value according to the alt flag\n    if alt:\n      if (sc-l) >= (u-sc): return l/100.0\n      else: return u/100.0\n    else:\n      if (sc-l) >= (u-sc): return u/100.0\n      else: return l/100.0", "response": "Convert a color component to its web safe equivalent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the color from RGB to web safe RGB", "response": "def RgbToWebSafe(r, g, b, alt=False):\n    '''Convert the color from RGB to 'web safe' RGB\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n      :alt:\n        If True, use the alternative color instead of the nearest one.\n        Can be used for dithering.\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> '(%g, %g, %g)' % Color.RgbToWebSafe(1, 0.55, 0.0)\n    '(1, 0.6, 0)'\n\n    '''\n    webSafeComponent = Color._WebSafeComponent\n    return tuple((webSafeComponent(v, alt) for v in (r, g, b)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts the color from RGB to its greyscale equivalent", "response": "def RgbToGreyscale(r, g, b):\n    '''Convert the color from RGB to its greyscale equivalent\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n\n    Returns:\n      The color as an (r, g, b) tuple in the range:\n      the range:\n      r[0...1],\n      g[0...1],\n      b[0...1]\n\n    >>> '(%g, %g, %g)' % Color.RgbToGreyscale(1, 0.8, 0)\n    '(0.6, 0.6, 0.6)'\n\n    '''\n    v = (r + g + b) / 3.0\n    return (v, v, v)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmap a hue on the RGB color wheel to Itten s RYB wheel.", "response": "def RgbToRyb(hue):\n    '''Maps a hue on the RGB color wheel to Itten's RYB wheel.\n\n    Parameters:\n      :hue:\n        The hue on the RGB color wheel [0...360]\n\n    Returns:\n      An approximation of the corresponding hue on Itten's RYB wheel.\n\n    >>> Color.RgbToRyb(15)\n    26.0\n\n    '''\n    d = hue % 15\n    i = int(hue / 15)\n    x0 = _RybWheel[i]\n    x1 = _RybWheel[i+1]\n    return x0 + (x1-x0) * d / 15"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef RybToRgb(hue):\n    '''Maps a hue on Itten's RYB color wheel to the standard RGB wheel.\n\n    Parameters:\n      :hue:\n        The hue on Itten's RYB color wheel [0...360]\n\n    Returns:\n      An approximation of the corresponding hue on the standard RGB wheel.\n\n    >>> Color.RybToRgb(15)\n    8.0\n\n    '''\n    d = hue % 15\n    i = int(hue / 15)\n    x0 = _RgbWheel[i]\n    x1 = _RgbWheel[i+1]\n    return x0 + (x1-x0) * d / 15", "response": "Maps a hue on Itten s RYB color wheel to the standard RGB wheel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef NewFromRgb(r, g, b, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed RGB values.\n\n    Parameters:\n      :r:\n        The Red component value [0...1]\n      :g:\n        The Green component value [0...1]\n      :b:\n        The Blue component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromRgb(1.0, 0.5, 0.0)\n    (1.0, 0.5, 0.0, 1.0)\n    >>> Color.NewFromRgb(1.0, 0.5, 0.0, 0.5)\n    (1.0, 0.5, 0.0, 0.5)\n\n    '''\n    return Color((r, g, b), 'rgb', alpha, wref)", "response": "Create a new instance based on the specifed RGB values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef NewFromHsl(h, s, l, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed HSL values.\n\n    Parameters:\n      :h:\n        The Hue component value [0...1]\n      :s:\n        The Saturation component value [0...1]\n      :l:\n        The Lightness component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5)\n    (1.0, 0.5, 0.0, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5, 0.5)\n    (1.0, 0.5, 0.0, 0.5)\n\n    '''\n    return Color((h, s, l), 'hsl', alpha, wref)", "response": "Create a new instance based on the specifed HSL values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef NewFromHsv(h, s, v, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed HSV values.\n\n    Parameters:\n      :h:\n        The Hus component value [0...1]\n      :s:\n        The Saturation component value [0...1]\n      :v:\n        The Value component [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsv(30, 1, 1)\n    (1.0, 0.5, 0.0, 1.0)\n    >>> Color.NewFromHsv(30, 1, 1, 0.5)\n    (1.0, 0.5, 0.0, 0.5)\n\n    '''\n    h2, s, l = Color.RgbToHsl(*Color.HsvToRgb(h, s, v))\n    return Color((h, s, l), 'hsl', alpha, wref)", "response": "Create a new instance based on the specifed HSV values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef NewFromYiq(y, i, q, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed YIQ values.\n\n    Parameters:\n      :y:\n        The Y component value [0...1]\n      :i:\n        The I component value [0...1]\n      :q:\n        The Q component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromYiq(0.5922, 0.45885,-0.05))\n    '(0.999902, 0.499955, -6.6905e-05, 1)'\n    >>> str(Color.NewFromYiq(0.5922, 0.45885,-0.05, 0.5))\n    '(0.999902, 0.499955, -6.6905e-05, 0.5)'\n\n    '''\n    return Color(Color.YiqToRgb(y, i, q), 'rgb', alpha, wref)", "response": "Create a new instance based on the specifed YIQ values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new instance based on the specifed YUV values.", "response": "def NewFromYuv(y, u, v, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed YUV values.\n\n    Parameters:\n      :y:\n        The Y component value [0...1]\n      :u:\n        The U component value [-0.436...0.436]\n      :v:\n        The V component value [-0.615...0.615]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromYuv(0.5925, -0.2916, 0.3575))\n    '(0.999989, 0.500015, -6.3276e-05, 1)'\n    >>> str(Color.NewFromYuv(0.5925, -0.2916, 0.3575, 0.5))\n    '(0.999989, 0.500015, -6.3276e-05, 0.5)'\n\n    '''\n    return Color(Color.YuvToRgb(y, u, v), 'rgb', alpha, wref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef NewFromXyz(x, y, z, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed CIE-XYZ values.\n\n    Parameters:\n      :x:\n        The Red component value [0...1]\n      :y:\n        The Green component value [0...1]\n      :z:\n        The Blue component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromXyz(0.488941, 0.365682, 0.0448137))\n    '(1, 0.5, 6.81883e-08, 1)'\n    >>> str(Color.NewFromXyz(0.488941, 0.365682, 0.0448137, 0.5))\n    '(1, 0.5, 6.81883e-08, 0.5)'\n\n    '''\n    return Color(Color.XyzToRgb(x, y, z), 'rgb', alpha, wref)", "response": "Create a new instance based on the specifed CIE - XYZ values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef NewFromLab(l, a, b, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed CIE-LAB values.\n\n    Parameters:\n      :l:\n        The L component [0...100]\n      :a:\n        The a component [-1...1]\n      :b:\n        The a component [-1...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromLab(66.9518, 0.43084, 0.739692))\n    '(1, 0.5, 1.09491e-08, 1)'\n    >>> str(Color.NewFromLab(66.9518, 0.43084, 0.739692, wref=Color.WHITE_REFERENCE['std_D50']))\n    '(1.01238, 0.492011, -0.14311, 1)'\n    >>> str(Color.NewFromLab(66.9518, 0.43084, 0.739692, 0.5))\n    '(1, 0.5, 1.09491e-08, 0.5)'\n    >>> str(Color.NewFromLab(66.9518, 0.43084, 0.739692, 0.5, Color.WHITE_REFERENCE['std_D50']))\n    '(1.01238, 0.492011, -0.14311, 0.5)'\n\n    '''\n    return Color(Color.XyzToRgb(*Color.LabToXyz(l, a, b, wref)), 'rgb', alpha, wref)", "response": "Create a new instance based on the specifed LAB values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new instance based on the specifed CMY values.", "response": "def NewFromCmy(c, m, y, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed CMY values.\n\n    Parameters:\n      :c:\n        The Cyan component value [0...1]\n      :m:\n        The Magenta component value [0...1]\n      :y:\n        The Yellow component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromCmy(0, 0.5, 1)\n    (1, 0.5, 0, 1.0)\n    >>> Color.NewFromCmy(0, 0.5, 1, 0.5)\n    (1, 0.5, 0, 0.5)\n\n    '''\n    return Color(Color.CmyToRgb(c, m, y), 'rgb', alpha, wref)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef NewFromCmyk(c, m, y, k, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed CMYK values.\n\n    Parameters:\n      :c:\n        The Cyan component value [0...1]\n      :m:\n        The Magenta component value [0...1]\n      :y:\n        The Yellow component value [0...1]\n      :k:\n        The Black component value [0...1]\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromCmyk(1, 0.32, 0, 0.5))\n    '(0, 0.34, 0.5, 1)'\n    >>> str(Color.NewFromCmyk(1, 0.32, 0, 0.5, 0.5))\n    '(0, 0.34, 0.5, 0.5)'\n\n    '''\n    return Color(Color.CmyToRgb(*Color.CmykToCmy(c, m, y, k)), 'rgb', alpha, wref)", "response": "Create a new instance based on the specifed CMYK values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new instance based on the specifed HTML color definition.", "response": "def NewFromHtml(html, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed HTML color definition.\n\n    Parameters:\n      :html:\n        The HTML definition of the color (#RRGGBB or #RGB or a color name).\n      :alpha:\n        The color transparency [0...1], default is opaque.\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromHtml('#ff8000'))\n    '(1, 0.501961, 0, 1)'\n    >>> str(Color.NewFromHtml('ff8000'))\n    '(1, 0.501961, 0, 1)'\n    >>> str(Color.NewFromHtml('#f60'))\n    '(1, 0.4, 0, 1)'\n    >>> str(Color.NewFromHtml('f60'))\n    '(1, 0.4, 0, 1)'\n    >>> str(Color.NewFromHtml('lemonchiffon'))\n    '(1, 0.980392, 0.803922, 1)'\n    >>> str(Color.NewFromHtml('#ff8000', 0.5))\n    '(1, 0.501961, 0, 0.5)'\n\n    '''\n    return Color(Color.HtmlToRgb(html), 'rgb', alpha, wref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new instance based on the specifed PIL color.", "response": "def NewFromPil(pil, alpha=1.0, wref=_DEFAULT_WREF):\n    '''Create a new instance based on the specifed PIL color.\n\n    Parameters:\n      :pil:\n        A PIL compatible color representation (0xBBGGRR)\n      :alpha:\n        The color transparency [0...1], default is opaque\n      :wref:\n        The whitepoint reference, default is 2\u00b0 D65.\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> str(Color.NewFromPil(0x0080ff))\n    '(1, 0.501961, 0, 1)'\n    >>> str(Color.NewFromPil(0x0080ff, 0.5))\n    '(1, 0.501961, 0, 0.5)'\n\n    '''\n    return Color(Color.PilToRgb(pil), 'rgb', alpha, wref)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ColorWithWhiteRef(self, wref, labAsRef=False):\n    '''Create a new instance based on this one with a new white reference.\n\n    Parameters:\n      :wref:\n        The whitepoint reference.\n      :labAsRef:\n        If True, the L*a*b* values of the current instance are used as reference\n        for the new color; otherwise, the RGB values are used as reference.\n\n    Returns:\n      A grapefruit.Color instance.\n\n\n    >>> c = Color.NewFromRgb(1.0, 0.5, 0.0, 1.0, Color.WHITE_REFERENCE['std_D65'])\n\n    >>> c2 = c.ColorWithWhiteRef(Color.WHITE_REFERENCE['sup_D50'])\n    >>> c2.rgb\n    (1.0, 0.5, 0.0)\n    >>> '(%g, %g, %g)' % c2.whiteRef\n    '(0.96721, 1, 0.81428)'\n\n    >>> c2 = c.ColorWithWhiteRef(Color.WHITE_REFERENCE['sup_D50'], labAsRef=True)\n    >>> '(%g, %g, %g)' % c2.rgb\n    '(1.01463, 0.490339, -0.148131)'\n    >>> '(%g, %g, %g)' % c2.whiteRef\n    '(0.96721, 1, 0.81428)'\n    >>> '(%g, %g, %g)' % c.lab\n    '(66.9518, 0.43084, 0.739692)'\n    >>> '(%g, %g, %g)' % c2.lab\n    '(66.9518, 0.43084, 0.739693)'\n\n    '''\n    if labAsRef:\n      l, a, b = self.__GetLAB()\n      return Color.NewFromLab(l, a, b, self.__a, wref)\n    else:\n      return Color(self.__rgb, 'rgb', self.__a, wref)", "response": "Create a new instance based on this one with a new white reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new instance based on this one with a new hue.", "response": "def ColorWithHue(self, hue):\n    '''Create a new instance based on this one with a new hue.\n\n    Parameters:\n      :hue:\n        The hue of the new color [0...360].\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithHue(60)\n    (1.0, 1.0, 0.0, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithHue(60).hsl\n    (60, 1, 0.5)\n\n    '''\n    h, s, l = self.__hsl\n    return Color((hue, s, l), 'hsl', self.__a, self.__wref)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new instance based on this one with a new saturation value.", "response": "def ColorWithSaturation(self, saturation):\n    '''Create a new instance based on this one with a new saturation value.\n\n    .. note::\n\n       The saturation is defined for the HSL mode.\n\n    Parameters:\n      :saturation:\n        The saturation of the new color [0...1].\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithSaturation(0.5)\n    (0.75, 0.5, 0.25, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithSaturation(0.5).hsl\n    (30, 0.5, 0.5)\n\n    '''\n    h, s, l = self.__hsl\n    return Color((h, saturation, l), 'hsl', self.__a, self.__wref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new instance based on this one with a new lightness value.", "response": "def ColorWithLightness(self, lightness):\n    '''Create a new instance based on this one with a new lightness value.\n\n    Parameters:\n      :lightness:\n        The lightness of the new color [0...1].\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithLightness(0.25)\n    (0.5, 0.25, 0.0, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5).ColorWithLightness(0.25).hsl\n    (30, 1, 0.25)\n\n    '''\n    h, s, l = self.__hsl\n    return Color((h, s, lightness), 'hsl', self.__a, self.__wref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new instance based on this one but lighter.", "response": "def LighterColor(self, level):\n    '''Create a new instance based on this one but lighter.\n\n    Parameters:\n      :level:\n        The amount by which the color should be lightened to produce\n        the new one [0...1].\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5).LighterColor(0.25)\n    (1.0, 0.75, 0.5, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5).LighterColor(0.25).hsl\n    (30, 1, 0.75)\n\n    '''\n    h, s, l = self.__hsl\n    return Color((h, s, min(l + level, 1)), 'hsl', self.__a, self.__wref)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef WebSafeDither(self):\n    '''Return the two websafe colors nearest to this one.\n\n    Returns:\n      A tuple of two grapefruit.Color instances which are the two\n      web safe colors closest this one.\n\n    >>> c = Color.NewFromRgb(1.0, 0.45, 0.0)\n    >>> c1, c2 = c.WebSafeDither()\n    >>> str(c1)\n    '(1, 0.4, 0, 1)'\n    >>> str(c2)\n    '(1, 0.6, 0, 1)'\n\n    '''\n    return (\n      Color(Color.RgbToWebSafe(*self.__rgb), 'rgb', self.__a, self.__wref),\n      Color(Color.RgbToWebSafe(alt=True, *self.__rgb), 'rgb', self.__a, self.__wref))", "response": "Return the two websafe colors nearest to this one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a list with the gradient colors between this and the other color.", "response": "def Gradient(self, target, steps=100):\n    '''Create a list with the gradient colors between this and the other color.\n\n    Parameters:\n      :target:\n        The grapefruit.Color at the other end of the gradient.\n      :steps:\n        The number of gradients steps to create.\n\n\n    Returns:\n      A list of grapefruit.Color instances.\n\n    >>> c1 = Color.NewFromRgb(1.0, 0.0, 0.0, alpha=1)\n    >>> c2 = Color.NewFromRgb(0.0, 1.0, 0.0, alpha=0)\n    >>> c1.Gradient(c2, 3)\n    [(0.75, 0.25, 0.0, 0.75), (0.5, 0.5, 0.0, 0.5), (0.25, 0.75, 0.0, 0.25)]\n\n    '''\n    gradient = []\n    rgba1 = self.__rgb + (self.__a,)\n    rgba2 = target.__rgb + (target.__a,)\n\n    steps += 1\n    for n in range(1, steps):\n      d = 1.0*n/steps\n      r = (rgba1[0]*(1-d)) + (rgba2[0]*d)\n      g = (rgba1[1]*(1-d)) + (rgba2[1]*d)\n      b = (rgba1[2]*(1-d)) + (rgba2[2]*d)\n      a = (rgba1[3]*(1-d)) + (rgba2[3]*d)\n\n      gradient.append(Color((r, g, b), 'rgb', a, self.__wref))\n\n    return gradient"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ComplementaryColor(self, mode='ryb'):\n    '''Create a new instance which is the complementary color of this one.\n\n    Parameters:\n      :mode:\n        Select which color wheel to use for the generation (ryb/rgb).\n\n\n    Returns:\n      A grapefruit.Color instance.\n\n    >>> Color.NewFromHsl(30, 1, 0.5).ComplementaryColor(mode='rgb')\n    (0.0, 0.5, 1.0, 1.0)\n    >>> Color.NewFromHsl(30, 1, 0.5).ComplementaryColor(mode='rgb').hsl\n    (210, 1, 0.5)\n\n    '''\n    h, s, l = self.__hsl\n\n    if mode == 'ryb': h = Color.RgbToRyb(h)\n    h = (h+180)%360\n    if mode == 'ryb': h = Color.RybToRgb(h)\n\n    return Color((h, s, l), 'hsl', self.__a, self.__wref)", "response": "Create a new instance which is the complementary color of this one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef MonochromeScheme(self):\n    '''Return 4 colors in the same hue with varying saturation/lightness.\n\n    Returns:\n      A tuple of 4 grapefruit.Color in the same hue as this one,\n      with varying saturation/lightness.\n\n    >>> c = Color.NewFromHsl(30, 0.5, 0.5)\n    >>> ['(%g, %g, %g)' % clr.hsl for clr in c.MonochromeScheme()]\n    ['(30, 0.2, 0.8)', '(30, 0.5, 0.3)', '(30, 0.2, 0.6)', '(30, 0.5, 0.8)']\n\n    '''\n    def _wrap(x, min, thres, plus):\n      if (x-min) < thres: return x + plus\n      else: return x-min\n\n    h, s, l = self.__hsl\n\n    s1 = _wrap(s, 0.3, 0.1, 0.3)\n    l1 = _wrap(l, 0.5, 0.2, 0.3)\n\n    s2 = s\n    l2 = _wrap(l, 0.2, 0.2, 0.6)\n\n    s3 = s1\n    l3 = max(0.2, l + (1-l)*0.2)\n\n    s4 = s\n    l4 = _wrap(l, 0.5, 0.2, 0.3)\n\n    return (\n      Color((h, s1,  l1), 'hsl', self.__a, self.__wref),\n      Color((h, s2,  l2), 'hsl', self.__a, self.__wref),\n      Color((h, s3,  l3), 'hsl', self.__a, self.__wref),\n      Color((h, s4,  l4), 'hsl', self.__a, self.__wref))", "response": "Monochrome scheme for the current color."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef TriadicScheme(self, angle=120, mode='ryb'):\n    '''Return two colors forming a triad or a split complementary with this one.\n\n    Parameters:\n      :angle:\n        The angle between the hues of the created colors.\n        The default value makes a triad.\n      :mode:\n        Select which color wheel to use for the generation (ryb/rgb).\n\n    Returns:\n      A tuple of two grapefruit.Color forming a color triad with\n      this one or a split complementary.\n\n    >>> c1 = Color.NewFromHsl(30, 1, 0.5)\n\n    >>> c2, c3 = c1.TriadicScheme(mode='rgb')\n    >>> c2.hsl\n    (150.0, 1, 0.5)\n    >>> c3.hsl\n    (270.0, 1, 0.5)\n\n    >>> c2, c3 = c1.TriadicScheme(angle=40, mode='rgb')\n    >>> c2.hsl\n    (190.0, 1, 0.5)\n    >>> c3.hsl\n    (230.0, 1, 0.5)\n\n    '''\n    h, s, l = self.__hsl\n    angle = min(angle, 120) / 2.0\n\n    if mode == 'ryb': h = Color.RgbToRyb(h)\n    h += 180\n    h1 = (h - angle) % 360\n    h2 = (h + angle) % 360\n    if mode == 'ryb':\n      h1 = Color.RybToRgb(h1)\n      h2 = Color.RybToRgb(h2)\n\n    return (\n      Color((h1, s,  l), 'hsl', self.__a, self.__wref),\n      Color((h2, s,  l), 'hsl', self.__a, self.__wref))", "response": "Return two grapefruit. Color objects forming a triad or a split complementary with this one."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_html(cls, html_string):\n        rgb = GC.NewFromHtml(html_string).rgb\n        return cls(\"rgb\", *rgb)", "response": "Create a Color object from a web - color name or hexcode."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert color to a different color space.", "response": "def to(self, space):\n        \"\"\"\n        Convert color to a different color space.\n\n        :param str space: Name of the color space.\n\n        :rtype: Color\n        :returns: A new spectra.Color in the given color space.\n        \"\"\"\n        if space == self.space: return self\n        new_color = convert_color(self.color_object, COLOR_SPACES[space])\n        return self.__class__(space, *new_color.get_value_tuple())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nblends this color with another color in the same color space.", "response": "def blend(self, other, ratio=0.5):\n        \"\"\"\n        Blend this color with another color in the same color space.\n\n        By default, blends the colors half-and-half (ratio: 0.5).\n\n        :param Color other: The color to blend.\n        :param float ratio: How much to blend (0 -> 1).\n\n        :rtype: Color\n        :returns: A new spectra.Color\n        \"\"\"\n        keep = 1.0 - ratio\n        if not self.space == other.space:\n            raise Exception(\"Colors must belong to the same color space.\")\n        values = tuple(((u * keep) + (v * ratio)\n            for u, v in zip(self.values, other.values)))\n        return self.__class__(self.space, *values)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef brighten(self, amount=10):\n        lch = self.to(\"lch\")\n        l, c, h = lch.values\n        new_lch = self.__class__(\"lch\", l + amount, c, h)\n        return new_lch.to(self.space)", "response": "Brighten this color by amount luminance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef colorspace(self, space):\n        new_colors = [ c.to(space) for c in self.colors ]\n        return self.__class__(new_colors, self._domain)", "response": "Create a new scale in the given color space."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef range(self, count):\n        if count <= 1:\n            raise ValueError(\"Range size must be greater than 1.\")\n        dom = self._domain\n        distance = dom[-1] - dom[0]\n        props = [ self(dom[0] + distance * float(x)/(count-1))\n            for x in range(count) ]\n        return props", "response": "Create a list of spectra. Color objects that are evenly spaced along this scale s domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsorts the keys in a JSON - RPC response object.", "response": "def sort_response(response: Dict[str, Any]) -> OrderedDict:\n    \"\"\"\n    Sort the keys in a JSON-RPC response object.\n\n    This has no effect other than making it nicer to read. Useful in Python 3.5 only,\n    dictionaries are already sorted in newer Python versions.\n\n    Example::\n\n        >>> json.dumps(sort_response({'id': 2, 'result': 5, 'jsonrpc': '2.0'}))\n        {\"jsonrpc\": \"2.0\", \"result\": 5, \"id\": 1}\n\n    Args:\n        response: Deserialized JSON-RPC response.\n\n    Returns:\n        The same response, sorted in an OrderedDict.\n    \"\"\"\n    root_order = [\"jsonrpc\", \"result\", \"error\", \"id\"]\n    error_order = [\"code\", \"message\", \"data\"]\n    req = OrderedDict(sorted(response.items(), key=lambda k: root_order.index(k[0])))\n    if \"error\" in response:\n        req[\"error\"] = OrderedDict(\n            sorted(response[\"error\"].items(), key=lambda k: error_order.index(k[0]))\n        )\n    return req"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the total parsed responses given the return value from parse.", "response": "def total_results(\n    data: Union[List[JSONRPCResponse], JSONRPCResponse, None], *, ok: bool = True\n) -> int:\n    \"\"\"\n    Returns the total parsed responses, given the return value from parse().\n    \"\"\"\n    if isinstance(data, list):\n        return sum([1 for d in data if d.ok == ok])\n    elif isinstance(data, JSONRPCResponse):\n        return int(data.ok == ok)\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def send_message(\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        with async_timeout.timeout(self.timeout):\n            async with self.session.post(\n                self.endpoint, data=request, ssl=self.ssl\n            ) as response:\n                response_text = await response.text()\n                return Response(response_text, raw=response)", "response": "Send a message to the server and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def send_message(\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        await self.socket.send(request)\n        if response_expected:\n            response_text = await self.socket.recv()\n            return Response(response_text)\n        return Response(\"\")", "response": "Send a message to the server and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_callable(path: str) -> Iterator:\n    module = path[: path.rindex(\".\")]\n    callable_name = path[path.rindex(\".\") + 1 :]\n    callable_ = getattr(importlib.import_module(module), callable_name)\n    return callable_()", "response": "Parses a callable from a file path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a random string.", "response": "def random(length: int = 8, chars: str = digits + ascii_lowercase) -> Iterator[str]:\n    \"\"\"\n    A random string.\n\n    Not unique, but has around 1 in a million chance of collision (with the default 8\n    character length). e.g. 'fubui5e6'\n\n    Args:\n        length: Length of the random string.\n        chars: The characters to randomly choose from.\n    \"\"\"\n    while True:\n        yield \"\".join([choice(chars) for _ in range(length)])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_response(response: Dict[str, Any]) -> JSONRPCResponse:\n    if \"error\" in response:\n        return ErrorResponse(**response)\n    return SuccessResponse(**response)", "response": "Converts a deserialized response into a JSONRPCResponse object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the response text into a list of JSON - RPC responses.", "response": "def parse(\n    response_text: str, *, batch: bool, validate_against_schema: bool = True\n) -> Union[JSONRPCResponse, List[JSONRPCResponse]]:\n    \"\"\"\n    Parses response text, returning JSONRPCResponse objects.\n\n    Args:\n        response_text: JSON-RPC response string.\n        batch: If the response_text is an empty string, this determines how to parse.\n        validate_against_schema: Validate against the json-rpc schema.\n\n    Returns:\n        Either a JSONRPCResponse, or a list of them.\n\n    Raises:\n        json.JSONDecodeError: The response was not valid JSON.\n        jsonschema.ValidationError: The response was not a valid JSON-RPC response\n            object.\n    \"\"\"\n    # If the response is empty, we can't deserialize it; an empty string is valid\n    # JSON-RPC, but not valid JSON.\n    if not response_text:\n        if batch:\n            # An empty string is a valid response to a batch request, when there were\n            # only notifications in the batch.\n            return []\n        else:\n            # An empty string is valid response to a Notification request.\n            return NotificationResponse()\n\n    # If a string, ensure it's json-deserializable\n    deserialized = deserialize(response_text)\n\n    # Validate the response against the Response schema (raises\n    # jsonschema.ValidationError if invalid)\n    if validate_against_schema:\n        jsonschema.validate(deserialized, schema)\n\n    # Batch response\n    if isinstance(deserialized, list):\n        return [get_response(r) for r in deserialized if \"id\" in r]\n    # Single response\n    return get_response(deserialized)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a request to the broker.", "response": "async def send(\n        self,\n        request: Union[str, Dict, List],\n        trim_log_values: bool = False,\n        validate_against_schema: bool = True,\n        **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Async version of Client.send.\n        \"\"\"\n        # We need both the serialized and deserialized version of the request\n        if isinstance(request, str):\n            request_text = request\n            request_deserialized = deserialize(request)\n        else:\n            request_text = serialize(request)\n            request_deserialized = request\n        batch = isinstance(request_deserialized, list)\n        response_expected = batch or \"id\" in request_deserialized\n        self.log_request(request_text, trim_log_values=trim_log_values)\n        response = await self.send_message(\n            request_text, response_expected=response_expected, **kwargs\n        )\n        self.log_response(response, trim_log_values=trim_log_values)\n        self.validate_response(response)\n        response.data = parse(\n            response.text, batch=batch, validate_against_schema=validate_against_schema\n        )\n        # If received a single error response, raise\n        if isinstance(response.data, ErrorResponse):\n            raise ReceivedErrorResponseError(response.data)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a message to the server and return the response.", "response": "async def send_message(  # type: ignore\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        headers = dict(self.DEFAULT_HEADERS)\n        headers.update(kwargs.pop(\"headers\", {}))\n\n        response = await self.client.fetch(\n            self.endpoint, method=\"POST\", body=request, headers=headers, **kwargs\n        )\n\n        return Response(response.body.decode(), raw=response)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(\n    context: click.core.Context, method: str, request_type: str, id: Any, send: str\n) -> None:\n    \"\"\"\n    Create a JSON-RPC request.\n    \"\"\"\n    exit_status = 0\n    # Extract the jsonrpc arguments\n    positional = [a for a in context.args if \"=\" not in a]\n    named = {a.split(\"=\")[0]: a.split(\"=\")[1] for a in context.args if \"=\" in a}\n    # Create the request\n    if request_type == \"notify\":\n        req = Notification(method, *positional, **named)\n    else:\n        req = Request(method, *positional, request_id=id, **named)  # type: ignore\n    # Sending?\n    if send:\n        client = HTTPClient(send)\n        try:\n            response = client.send(req)\n        except JsonRpcClientError as e:\n            click.echo(str(e), err=True)\n            exit_status = 1\n        else:\n            click.echo(response.text)\n    # Otherwise, simply output the JSON-RPC request.\n    else:\n        click.echo(str(req))\n    sys.exit(exit_status)", "response": "Create a JSON - RPC request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log_(\n    message: str,\n    logger: logging.Logger,\n    level: str = \"info\",\n    extra: Optional[Dict] = None,\n    trim: bool = False,\n) -> None:\n    \"\"\"\n    Log a request or response\n\n    Args:\n        message: JSON-RPC request or response string.\n        level: Log level.\n        extra: More details to include in the log entry.\n        trim: Abbreviate log messages.\n    \"\"\"\n    if extra is None:\n        extra = {}\n    # Clean up the message for logging\n    if message:\n        message = message.replace(\"\\n\", \"\").replace(\"  \", \" \").replace(\"{ \", \"{\")\n    if trim:\n        message = _trim_message(message)\n    # Log.\n    getattr(logger, level)(message, extra=extra)", "response": "Log a request or response string to the given logger."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sort_request(request: Dict[str, Any]) -> OrderedDict:\n    sort_order = [\"jsonrpc\", \"method\", \"params\", \"id\"]\n    return OrderedDict(sorted(request.items(), key=lambda k: sort_order.index(k[0])))", "response": "Sort a JSON - RPC request dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate basic logging handlers for the current log level.", "response": "def basic_logging(self) -> None:\n        \"\"\"\n        Call this on the client object to create log handlers to output request and\n        response messages.\n        \"\"\"\n        # Request handler\n        if len(request_log.handlers) == 0:\n            request_handler = logging.StreamHandler()\n            request_handler.setFormatter(\n                logging.Formatter(fmt=self.DEFAULT_REQUEST_LOG_FORMAT)\n            )\n            request_log.addHandler(request_handler)\n            request_log.setLevel(logging.INFO)\n        # Response handler\n        if len(response_log.handlers) == 0:\n            response_handler = logging.StreamHandler()\n            response_handler.setFormatter(\n                logging.Formatter(fmt=self.DEFAULT_RESPONSE_LOG_FORMAT)\n            )\n            response_log.addHandler(response_handler)\n            response_log.setLevel(logging.INFO)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_request(\n        self, request: str, trim_log_values: bool = False, **kwargs: Any\n    ) -> None:\n        \"\"\"\n        Log a request.\n\n        Args:\n            request: The JSON-RPC request string.\n            trim_log_values: Log an abbreviated version of the request.\n        \"\"\"\n        return log_(request, request_log, \"info\", trim=trim_log_values, **kwargs)", "response": "Log a request.\n\n        Args:\n            request: The JSON-RPC request string.\n            trim_log_values: Log an abbreviated version of the request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log_response(\n        self, response: Response, trim_log_values: bool = False, **kwargs: Any\n    ) -> None:\n        \"\"\"\n        Log a response.\n\n        Note this is different to log_request, in that it takes a Response object, not a\n        string.\n\n        Args:\n            response: The Response object to log. Note this is different to log_request\n                which takes a string.\n            trim_log_values: Log an abbreviated version of the response.\n        \"\"\"\n        return log_(response.text, response_log, \"info\", trim=trim_log_values, **kwargs)", "response": "Log a response object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a JSON - RPC request to the remote server without expecting a response.", "response": "def notify(\n        self,\n        method_name: str,\n        *args: Any,\n        trim_log_values: Optional[bool] = None,\n        validate_against_schema: Optional[bool] = None,\n        **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Send a JSON-RPC request, without expecting a response.\n\n        Args:\n            method_name: The remote procedure's method name.\n            args: Positional arguments passed to the remote procedure.\n            kwargs: Keyword arguments passed to the remote procedure.\n            trim_log_values: Abbreviate the log entries of requests and responses.\n            validate_against_schema: Validate response against the JSON-RPC schema.\n        \"\"\"\n        return self.send(\n            Notification(method_name, *args, **kwargs),\n            trim_log_values=trim_log_values,\n            validate_against_schema=validate_against_schema,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a request to the remote server.", "response": "def request(\n        self,\n        method_name: str,\n        *args: Any,\n        trim_log_values: bool = False,\n        validate_against_schema: bool = True,\n        id_generator: Optional[Iterator] = None,\n        **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Send a request by passing the method and arguments.\n\n        >>> client.request(\"cat\", name=\"Yoko\")\n        <Response[1]\n\n        Args:\n            method_name: The remote procedure's method name.\n            args: Positional arguments passed to the remote procedure.\n            kwargs: Keyword arguments passed to the remote procedure.\n            trim_log_values: Abbreviate the log entries of requests and responses.\n            validate_against_schema: Validate response against the JSON-RPC schema.\n            id_generator: Iterable of values to use as the \"id\" part of the request.\n        \"\"\"\n        return self.send(\n            Request(method_name, id_generator=id_generator, *args, **kwargs),\n            trim_log_values=trim_log_values,\n            validate_against_schema=validate_against_schema,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_message(\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        payload = str(request) + self.delimiter\n        self.socket.send(payload.encode(self.encoding))\n\n        response = bytes()\n        decoded = None\n\n        # Receive the response until we find the delimiter.\n        # TODO Do not wait for a response if the message sent is a notification.\n        while True:\n            response += self.socket.recv(1024)\n\n            decoded = response.decode(self.encoding)\n            if len(decoded) < self.delimiter_length:\n                continue\n\n            # TODO Check that're not in the middle of the response.\n            elif decoded[-self.delimiter_length :] == self.delimiter:\n                break\n\n        assert decoded is not None\n        return Response(decoded[: -self.delimiter_length])", "response": "Send a message to the server and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_message(\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        response = self.session.post(self.endpoint, data=request.encode(), **kwargs)\n        return Response(response.text, raw=response)", "response": "Send a message to the server and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a message to the server and return the response.", "response": "def send_message(\n        self, request: str, response_expected: bool, **kwargs: Any\n    ) -> Response:\n        \"\"\"\n        Transport the message to the server and return the response.\n\n        Args:\n            request: The JSON-RPC request string.\n            response_expected: Whether the request expects a response.\n\n        Returns:\n            A Response object.\n        \"\"\"\n        self.socket.send_string(request)\n        return Response(self.socket.recv().decode())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init(self, acct: Account, payer_acct: Account, gas_limit: int, gas_price: int) -> str:\n        func = InvokeFunction('init')\n        tx_hash = self.__sdk.get_network().send_neo_vm_transaction(self.__hex_contract_address, acct, payer_acct,\n                                                                   gas_limit, gas_price, func)\n        return tx_hash", "response": "This interface is used to call the TotalSupply method in ope4\n        that initialize smart contract parameter."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_total_supply(self) -> int:\n        func = InvokeFunction('totalSupply')\n        response = self.__sdk.get_network().send_neo_vm_transaction_pre_exec(self.__hex_contract_address, None, func)\n        try:\n            total_supply = ContractDataParser.to_int(response['Result'])\n        except SDKException:\n            total_supply = 0\n        return total_supply", "response": "This interface is used to call the TotalSupply method in ope4\n        that returns the total supply of the oep4 token."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transfer(self, from_acct: Account, b58_to_address: str, value: int, payer_acct: Account, gas_limit: int,\n                 gas_price: int) -> str:\n        \"\"\"\n        This interface is used to call the Transfer method in ope4\n        that transfer an amount of tokens from one account to another account.\n\n        :param from_acct: an Account class that send the oep4 token.\n        :param b58_to_address: a base58 encode address that receive the oep4 token.\n        :param value: an int value that indicate the amount oep4 token that will be transferred in this transaction.\n        :param payer_acct: an Account class that used to pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: the hexadecimal transaction hash value.\n        \"\"\"\n        func = InvokeFunction('transfer')\n        if not isinstance(value, int):\n            raise SDKException(ErrorCode.param_err('the data type of value should be int.'))\n        if value < 0:\n            raise SDKException(ErrorCode.param_err('the value should be equal or great than 0.'))\n        if not isinstance(from_acct, Account):\n            raise SDKException(ErrorCode.param_err('the data type of from_acct should be Account.'))\n        Oep4.__b58_address_check(b58_to_address)\n        from_address = from_acct.get_address().to_bytes()\n        to_address = Address.b58decode(b58_to_address).to_bytes()\n        func.set_params_value(from_address, to_address, value)\n        tx_hash = self.__sdk.get_network().send_neo_vm_transaction(self.__hex_contract_address, from_acct, payer_acct,\n                                                                   gas_limit, gas_price, func, False)\n        return tx_hash", "response": "This interface is used to send a transfer transaction to the network."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transfer_multi(self, transfer_list: list, payer_acct: Account, signers: list, gas_limit: int, gas_price: int):\n        func = InvokeFunction('transferMulti')\n        for index, item in enumerate(transfer_list):\n            Oep4.__b58_address_check(item[0])\n            Oep4.__b58_address_check(item[1])\n            if not isinstance(item[2], int):\n                raise SDKException(ErrorCode.param_err('the data type of value should be int.'))\n            if item[2] < 0:\n                raise SDKException(ErrorCode.param_err('the value should be equal or great than 0.'))\n            from_address_array = Address.b58decode(item[0]).to_bytes()\n            to_address_array = Address.b58decode(item[1]).to_bytes()\n            transfer_list[index] = [from_address_array, to_address_array, item[2]]\n        for item in transfer_list:\n            func.add_params_value(item)\n        params = func.create_invoke_code()\n        unix_time_now = int(time.time())\n        params.append(0x67)\n        bytearray_contract_address = bytearray.fromhex(self.__hex_contract_address)\n        bytearray_contract_address.reverse()\n        for i in bytearray_contract_address:\n            params.append(i)\n        if len(signers) == 0:\n            raise SDKException(ErrorCode.param_err('payer account is None.'))\n        payer_address = payer_acct.get_address().to_bytes()\n        tx = Transaction(0, 0xd1, unix_time_now, gas_price, gas_limit, payer_address, params,\n                         bytearray(), [])\n        for signer in signers:\n            tx.add_sign_transaction(signer)\n        tx_hash = self.__sdk.get_network().send_raw_transaction(tx)\n        return tx_hash", "response": "This interface is used to call the TransferMulti method in ope4."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef approve(self, owner_acct: Account, b58_spender_address: str, amount: int, payer_acct: Account, gas_limit: int,\n                gas_price: int):\n        \"\"\"\n        This interface is used to call the Approve method in ope4\n        that allows spender to withdraw a certain amount of oep4 token from owner account multiple times.\n\n        If this function is called again, it will overwrite the current allowance with new value.\n\n        :param owner_acct: an Account class that indicate the owner.\n        :param b58_spender_address: a base58 encode address that be allowed to spend the oep4 token in owner's account.\n        :param amount: an int value that indicate the amount oep4 token that will be transferred in this transaction.\n        :param payer_acct: an Account class that used to pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: the hexadecimal transaction hash value.\n        \"\"\"\n        func = InvokeFunction('approve')\n        if not isinstance(amount, int):\n            raise SDKException(ErrorCode.param_err('the data type of amount should be int.'))\n        if amount < 0:\n            raise SDKException(ErrorCode.param_err('the amount should be equal or great than 0.'))\n        owner_address = owner_acct.get_address().to_bytes()\n        Oep4.__b58_address_check(b58_spender_address)\n        spender_address = Address.b58decode(b58_spender_address).to_bytes()\n        func.set_params_value(owner_address, spender_address, amount)\n        tx_hash = self.__sdk.get_network().send_neo_vm_transaction(self.__hex_contract_address, owner_acct, payer_acct,\n                                                                   gas_limit, gas_price, func)\n        return tx_hash", "response": "This interface is used to send an approve transaction to the owner account."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_identity(self, label: str, encrypted_pri_key: str, pwd: str, salt: str, b58_address: str) -> Identity:\n        scrypt_n = Scrypt().n\n        pri_key = Account.get_gcm_decoded_private_key(encrypted_pri_key, pwd, b58_address, salt, scrypt_n, self.scheme)\n        info = self.__create_identity(label, pwd, salt, pri_key)\n        for identity in self.wallet_in_mem.identities:\n            if identity.ont_id == info.ont_id:\n                return identity\n        raise SDKException(ErrorCode.other_error('Import identity failed.'))", "response": "This interface is used to import identity by providing encrypted private key password salt and base58 encode address which should be used in the process of encrypting and decrypting the private key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_account(self, pwd: str, label: str = '') -> Account:\n        pri_key = get_random_hex_str(64)\n        salt = get_random_hex_str(16)\n        if len(label) == 0 or label is None:\n            label = uuid.uuid4().hex[0:8]\n        acct = self.__create_account(label, pwd, salt, pri_key, True)\n        return self.get_account_by_b58_address(acct.get_address_base58(), pwd)", "response": "This interface is used to create an account based on a password and label."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_account(self, label: str, encrypted_pri_key: str, pwd: str, b58_address: str,\n                       b64_salt: str, n: int = 16384) -> AccountData:\n        \"\"\"\n        This interface is used to import account by providing account data.\n\n        :param label: str, wallet label\n        :param encrypted_pri_key: str, an encrypted private key in base64 encoding from\n        :param pwd: str, a password which is used to encrypt and decrypt the private key\n        :param b58_address: str, a base58 encode  wallet address value\n        :param b64_salt: str, a base64 encode salt value which is used in the encryption of private key\n        :param n: int,  CPU/Memory cost parameter. It must be a power of 2 and less than :math:`2^{32}`\n        :return:\n            if succeed, return an data structure which contain the information of a wallet account.\n            if failed, return a None object.\n        \"\"\"\n        salt = base64.b64decode(b64_salt.encode('ascii')).decode('latin-1')\n        private_key = Account.get_gcm_decoded_private_key(encrypted_pri_key, pwd, b58_address, salt, n, self.scheme)\n        acct_info = self.create_account_info(label, pwd, salt, private_key)\n        for acct in self.wallet_in_mem.accounts:\n            if not isinstance(acct, AccountData):\n                raise SDKException(ErrorCode.other_error('Invalid account data in memory.'))\n            if acct_info.address_base58 == acct.b58_address:\n                return acct\n        raise SDKException(ErrorCode.other_error('Import account failed.'))", "response": "This interface is used to import account by providing encrypted private key and a private key in base64 encoding from the encrypted private key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_account_by_ont_id(self, ont_id: str, password: str) -> Account:\n        WalletManager.__check_ont_id(ont_id)\n        for identity in self.wallet_in_mem.identities:\n            if identity.ont_id == ont_id:\n                addr = identity.ont_id.replace(DID_ONT, \"\")\n                key = identity.controls[0].key\n                salt = base64.b64decode(identity.controls[0].salt)\n                n = self.wallet_in_mem.scrypt.n\n                private_key = Account.get_gcm_decoded_private_key(key, password, addr, salt, n, self.scheme)\n                return Account(private_key, self.scheme)\n        raise SDKException(ErrorCode.other_error(f'Get account {ont_id} failed.'))", "response": "This interface is used to get an account by an OntId."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an Account object for the given base58 encode address.", "response": "def get_account_by_b58_address(self, b58_address: str, password: str) -> Account:\n        \"\"\"\n        :param b58_address: a base58 encode address.\n        :param password: a password which is used to decrypt the encrypted private key.\n        :return:\n        \"\"\"\n        acct = self.get_account_data_by_b58_address(b58_address)\n        n = self.wallet_in_mem.scrypt.n\n        salt = base64.b64decode(acct.salt)\n        private_key = Account.get_gcm_decoded_private_key(acct.key, password, b58_address, salt, n, self.scheme)\n        return Account(private_key, self.scheme)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_function(self, name: str) -> AbiFunction or None:\n        for func in self.functions:\n            if func['name'] == name:\n                return AbiFunction(func['name'], func['parameters'], func.get('returntype', ''))\n        return None", "response": "This interface is used to get an AbiFunction object by given function name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __uncompress_public_key(public_key: bytes) -> bytes:\n        is_even = public_key.startswith(b'\\x02')\n        x = string_to_number(public_key[1:])\n\n        curve = NIST256p.curve\n        order = NIST256p.order\n        p = curve.p()\n        alpha = (pow(x, 3, p) + (curve.a() * x) + curve.b()) % p\n        beta = square_root_mod_prime(alpha, p)\n        if is_even == bool(beta & 1):\n            y = p - beta\n        else:\n            y = beta\n        point = Point(curve, x, y, order)\n        return b''.join([number_to_string(point.x(), order), number_to_string(point.y(), order)])", "response": "Uncompress the compressed public key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_version(self, is_full: bool = False) -> dict or str:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_VERSION)\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the version information of the connected node in current network."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_connection_count(self, is_full: bool = False) -> int:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_NODE_COUNT)\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the current number of connections for the current node in current network."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gas_price(self, is_full: bool = False) -> int or dict:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_GAS_PRICE)\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']['gasprice']", "response": "This interface is used to get the gas price in current network."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_network_id(self, is_full: bool = False) -> int:\n\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_NETWORK_ID)\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the network id of current network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_block_by_height(self, height: int, is_full: bool = False) -> dict:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_BLOCK, [height, 1])\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the block information by height."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_block_hash_by_height(self, height: int, is_full: bool = False) -> str:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_BLOCK_HASH, [height, 1])\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the hexadecimal hash value of the specified block height in current network."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_balance(self, b58_address: str, is_full: bool = False) -> dict:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_BALANCE, [b58_address, 1])\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to get the account balance of a base58 encoded address in current network."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_smart_contract_event_by_height(self, height: int, is_full: bool = False) -> List[dict]:\n        payload = self.generate_json_rpc_payload(RpcMethod.GET_SMART_CONTRACT_EVENT, [height, 1])\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        event_list = response['result']\n        if event_list is None:\n            event_list = list()\n        return event_list", "response": "This interface is used to get the information of a smart contract event based on the height of the block."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_raw_transaction(self, tx: Transaction, is_full: bool = False) -> str:\n        tx_data = tx.serialize(is_hex=True)\n        payload = self.generate_json_rpc_payload(RpcMethod.SEND_TRANSACTION, [tx_data])\n        response = self.__post(self.__url, payload)\n        if is_full:\n            return response\n        return response['result']", "response": "This interface is used to send a raw transaction into the network."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_public_key(self, ont_id: str, operator: Account, hex_new_public_key: str, payer: Account, gas_limit: int,\n                       gas_price: int, is_recovery: bool = False):\n        \"\"\"\n        This interface is used to send a Transaction object which is used to add public key.\n\n        :param ont_id: OntId.\n        :param operator: an Account object which indicate who will sign for the transaction.\n        :param hex_new_public_key: the new hexadecimal public key in the form of string.\n        :param payer: an Account object which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :param is_recovery: indicate whether ctrl account is a recovery account.\n        :return: a hexadecimal transaction hash value.\n        \"\"\"\n        if not isinstance(operator, Account) or not isinstance(payer, Account):\n            raise SDKException(ErrorCode.require_acct_params)\n        if is_recovery:\n            bytes_operator = operator.get_address_bytes()\n        else:\n            bytes_operator = operator.get_public_key_bytes()\n        b58_payer_address = payer.get_address_base58()\n        tx = self.new_add_public_key_transaction(ont_id, bytes_operator, hex_new_public_key, b58_payer_address,\n                                                 gas_limit, gas_price, is_recovery)\n        tx.sign_transaction(operator)\n        tx.add_sign_transaction(payer)\n        return self.__sdk.get_network().send_raw_transaction(tx)", "response": "This interface is used to send a Transaction object which is used to add public key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_attribute(self, ont_id: str, ctrl_acct: Account, attributes: Attribute, payer: Account, gas_limit: int,\n                      gas_price: int) -> str:\n        \"\"\"\n        This interface is used to send a Transaction object which is used to add attribute.\n\n        :param ont_id: OntId.\n        :param ctrl_acct: an Account object which indicate who will sign for the transaction.\n        :param attributes: a list of attributes we want to add.\n        :param payer: an Account object which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: a hexadecimal transaction hash value.\n        \"\"\"\n        if not isinstance(ctrl_acct, Account) or not isinstance(payer, Account):\n            raise SDKException(ErrorCode.require_acct_params)\n        pub_key = ctrl_acct.get_public_key_bytes()\n        b58_payer_address = payer.get_address_base58()\n        tx = self.new_add_attribute_transaction(ont_id, pub_key, attributes, b58_payer_address, gas_limit, gas_price)\n        tx.sign_transaction(ctrl_acct)\n        tx.add_sign_transaction(payer)\n        tx_hash = self.__sdk.get_network().send_raw_transaction(tx)\n        return tx_hash", "response": "This interface is used to send a Transaction object which is used to add attributes to an OntId."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef new_registry_ont_id_transaction(self, ont_id: str, pub_key: str or bytes, b58_payer_address: str,\n                                        gas_limit: int, gas_price: int) -> Transaction:\n        \"\"\"\n        This interface is used to generate a Transaction object which is used to register ONT ID.\n\n        :param ont_id: OntId.\n        :param pub_key: the hexadecimal public key in the form of string.\n        :param b58_payer_address: a base58 encode address which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: a Transaction object which is used to register ONT ID.\n        \"\"\"\n        if isinstance(pub_key, str):\n            bytes_ctrl_pub_key = bytes.fromhex(pub_key)\n        elif isinstance(pub_key, bytes):\n            bytes_ctrl_pub_key = pub_key\n        else:\n            raise SDKException(ErrorCode.param_err('a bytes or str type of public key is required.'))\n        args = dict(ontid=ont_id.encode('utf-8'), ctrl_pk=bytes_ctrl_pub_key)\n        tx = self.__generate_transaction('regIDWithPublicKey', args, b58_payer_address, gas_limit, gas_price)\n        return tx", "response": "This interface is used to generate a Transaction object which is used to register ONT ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_revoke_public_key_transaction(self, ont_id: str, bytes_operator: bytes, revoked_pub_key: str or bytes,\n                                          b58_payer_address: str, gas_limit: int, gas_price: int):\n        \"\"\"\n        This interface is used to generate a Transaction object which is used to remove public key.\n\n        :param ont_id: OntId.\n        :param bytes_operator: operator args in from of bytes.\n        :param revoked_pub_key: a public key string which will be removed.\n        :param b58_payer_address: a base58 encode address which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: a Transaction object which is used to remove public key.\n        \"\"\"\n        if isinstance(revoked_pub_key, str):\n            bytes_revoked_pub_key = bytes.fromhex(revoked_pub_key)\n        elif isinstance(revoked_pub_key, bytes):\n            bytes_revoked_pub_key = revoked_pub_key\n        else:\n            raise SDKException(ErrorCode.params_type_error('a bytes or str type of public key is required.'))\n        bytes_ont_id = ont_id.encode('utf-8')\n        args = dict(ontid=bytes_ont_id, pk=bytes_revoked_pub_key, operator=bytes_operator)\n        tx = self.__generate_transaction('removeKey', args, b58_payer_address, gas_limit, gas_price)\n        return tx", "response": "This interface is used to generate a Transaction object which is used to remove a public key from the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_remove_attribute_transaction(self, ont_id: str, pub_key: str or bytes, attrib_key: str,\n                                         b58_payer_address: str, gas_limit: int, gas_price: int):\n        \"\"\"\n        This interface is used to generate a Transaction object which is used to remove attribute.\n\n        :param ont_id: OntId.\n        :param pub_key: the hexadecimal public key in the form of string.\n        :param attrib_key: a string which is used to indicate which attribute we want to remove.\n        :param b58_payer_address: a base58 encode address which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: a Transaction object which is used to remove attribute.\n        \"\"\"\n        if isinstance(pub_key, str):\n            bytes_pub_key = bytes.fromhex(pub_key)\n        elif isinstance(pub_key, bytes):\n            bytes_pub_key = pub_key\n        else:\n            raise SDKException(ErrorCode.params_type_error('a bytes or str type of public key is required.'))\n        args = dict(ontid=ont_id.encode('utf-8'), attrib_key=attrib_key.encode('utf-8'), pk=bytes_pub_key)\n        tx = self.__generate_transaction('removeAttribute', args, b58_payer_address, gas_limit, gas_price)\n        return tx", "response": "This interface is used to generate a Transaction object which is used to remove an attribute from a OntId."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_sign_transaction(self, signer: Account):\n        if self.sig_list is None or len(self.sig_list) == 0:\n            self.sig_list = []\n        elif len(self.sig_list) >= TX_MAX_SIG_SIZE:\n            raise SDKException(ErrorCode.param_err('the number of transaction signatures should not be over 16'))\n        tx_hash = self.hash256()\n        sig_data = signer.generate_signature(tx_hash)\n        sig = Sig([signer.get_public_key_bytes()], 1, [sig_data])\n        self.sig_list.append(sig)", "response": "This interface is used to add signature into the transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_multi_sign_transaction(self, m: int, pub_keys: List[bytes] or List[str], signer: Account):\n        for index, pk in enumerate(pub_keys):\n            if isinstance(pk, str):\n                pub_keys[index] = pk.encode('ascii')\n        pub_keys = ProgramBuilder.sort_public_keys(pub_keys)\n        tx_hash = self.hash256()\n        sig_data = signer.generate_signature(tx_hash)\n        if self.sig_list is None or len(self.sig_list) == 0:\n            self.sig_list = []\n        elif len(self.sig_list) >= TX_MAX_SIG_SIZE:\n            raise SDKException(ErrorCode.param_err('the number of transaction signatures should not be over 16'))\n        else:\n            for i in range(len(self.sig_list)):\n                if self.sig_list[i].public_keys == pub_keys:\n                    if len(self.sig_list[i].sig_data) + 1 > len(pub_keys):\n                        raise SDKException(ErrorCode.param_err('too more sigData'))\n                    if self.sig_list[i].m != m:\n                        raise SDKException(ErrorCode.param_err('M error'))\n                    self.sig_list[i].sig_data.append(sig_data)\n                    return\n        sig = Sig(pub_keys, m, [sig_data])\n        self.sig_list.append(sig)", "response": "This interface is used to generate a Transaction object which has multi signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stream(data=None):\n        if len(__mstreams_available__) == 0:\n            if data:\n                mstream = MemoryStream(data)\n                mstream.seek(0)\n            else:\n                mstream = MemoryStream()\n            __mstreams__.append(mstream)\n            return mstream\n\n        mstream = __mstreams_available__.pop()\n\n        if data is not None and len(data):\n            mstream.clean_up()\n            mstream.write(data)\n\n        mstream.seek(0)\n\n        return mstream", "response": "Get a MemoryStream instance from the given data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating contract address from avm bytecode.", "response": "def address_from_vm_code(code: str):\n        \"\"\"\n        generate contract address from avm bytecode.\n        :param code: str\n        :return: Address\n        \"\"\"\n        script_hash = Address.to_script_hash(bytearray.fromhex(code))[::-1]\n        return Address(script_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_gcm_decoded_private_key(encrypted_key_str: str, password: str, b58_address: str, salt: str, n: int,\n                                    scheme: SignatureScheme) -> str:\n        \"\"\"\n        This interface is used to decrypt an private key which has been encrypted.\n\n        :param encrypted_key_str: an gcm encrypted private key in the form of string.\n        :param password: the secret pass phrase to generate the keys from.\n        :param b58_address: a base58 encode address which should be correspond with the private key.\n        :param salt: a string to use for better protection from dictionary attacks.\n        :param n: CPU/memory cost parameter.\n        :param scheme: the signature scheme.\n        :return: a private key in the form of string.\n        \"\"\"\n        r = 8\n        p = 8\n        dk_len = 64\n        scrypt = Scrypt(n, r, p, dk_len)\n        derived_key = scrypt.generate_kd(password, salt)\n        iv = derived_key[0:12]\n        key = derived_key[32:64]\n        encrypted_key = base64.b64decode(encrypted_key_str).hex()\n        mac_tag = bytes.fromhex(encrypted_key[64:96])\n        cipher_text = bytes.fromhex(encrypted_key[0:64])\n        private_key = AESHandler.aes_gcm_decrypt_with_iv(cipher_text, b58_address.encode(), mac_tag, key, iv)\n        if len(private_key) == 0:\n            raise SDKException(ErrorCode.decrypt_encrypted_private_key_error)\n        acct = Account(private_key, scheme)\n        if acct.get_address().b58encode() != b58_address:\n            raise SDKException(ErrorCode.other_error('Address error.'))\n        return private_key.hex()", "response": "This interface is used to decrypt an encrypted private key which has been encrypted."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export_wif(self) -> str:\n        data = b''.join([b'\\x80', self.__private_key, b'\\01'])\n        checksum = Digest.hash256(data[0:34])\n        wif = base58.b58encode(b''.join([data, checksum[0:4]]))\n        return wif.decode('ascii')", "response": "This interface is used to get export private key in the form of WIF"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_private_key_from_wif(wif: str) -> bytes:\n        if wif is None or wif is \"\":\n            raise Exception(\"none wif\")\n        data = base58.b58decode(wif)\n        if len(data) != 38 or data[0] != 0x80 or data[33] != 0x01:\n            raise Exception(\"wif wrong\")\n        checksum = Digest.hash256(data[0:34])\n        for i in range(4):\n            if data[len(data) - 4 + i] != checksum[i]:\n                raise Exception(\"wif wrong\")\n        return data[1:33]", "response": "This interface is used to decode a WIF encode ECDSA private key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nderives one key from a seed.", "response": "def pbkdf2(seed: str or bytes, dk_len: int) -> bytes:\n    \"\"\"\n    Derive one key from a seed.\n\n    :param seed: the secret pass phrase to generate the keys from.\n    :param dk_len: the length in bytes of every derived key.\n    :return:\n    \"\"\"\n    key = b''\n    index = 1\n    bytes_seed = str_to_bytes(seed)\n    while len(key) < dk_len:\n        key += Digest.sha256(b''.join([bytes_seed, index.to_bytes(4, 'big', signed=True)]))\n        index += 1\n    return key[:dk_len]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sort_public_keys(pub_keys: List[bytes] or List[str]):\n        for index, key in enumerate(pub_keys):\n            if isinstance(key, str):\n                pub_keys[index] = bytes.fromhex(key)\n        return sorted(pub_keys, key=ProgramBuilder.compare_pubkey)", "response": "Sort public keys in format of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unpack(self, fmt, length=1):\n        try:\n            info = struct.unpack(fmt, self.stream.read(length))[0]\n        except struct.error as e:\n            raise SDKException(ErrorCode.unpack_error(e.args[0]))\n        return info", "response": "Unpack the stream contents according to the specified format in fmt."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a single byte. Args: do_ord (bool): (default True) convert the byte to an ordinal first. Returns: bytes: a single byte if successful. 0 (int) if an exception occurred.", "response": "def read_byte(self, do_ord=True) -> int:\n        \"\"\"\n        Read a single byte.\n        Args:\n            do_ord (bool): (default True) convert the byte to an ordinal first.\n        Returns:\n            bytes: a single byte if successful. 0 (int) if an exception occurred.\n        \"\"\"\n        try:\n            if do_ord:\n                return ord(self.stream.read(1))\n            else:\n                return self.stream.read(1)\n        except Exception as e:\n            raise SDKException(ErrorCode.read_byte_error(e.args[0]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the specified number of bytes from the stream.", "response": "def read_bytes(self, length) -> bytes:\n        \"\"\"\n        Read the specified number of bytes from the stream.\n\n        Args:\n            length (int): number of bytes to read.\n\n        Returns:\n            bytes: `length` number of bytes.\n        \"\"\"\n        value = self.stream.read(length)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_float(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack(\"%sf\" % endian, 4)", "response": "Read 4 bytes as a float value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_double(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack(\"%sd\" % endian, 8)", "response": "Read 8 bytes as a double value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_int8(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sb' % endian)", "response": "Read 1 byte as a signed integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_uint8(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sB' % endian)", "response": "Read 1 byte as an unsigned integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_int16(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sh' % endian, 2)", "response": "Read 2 byte as a signed integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_uint16(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sH' % endian, 2)", "response": "Reads 2 byte unsigned integer values from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_int32(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%si' % endian, 4)", "response": "Read 4 bytes as a signed integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_uint32(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sI' % endian, 4)", "response": "Reads 4 bytes as an unsigned integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads 8 bytes as a signed integer value from the stream.", "response": "def read_int64(self, little_endian=True):\n        \"\"\"\n        Read 8 bytes as a signed integer value from the stream.\n\n        Args:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int:\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sq' % endian, 8)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_uint64(self, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.unpack('%sQ' % endian, 8)", "response": "Read 8 bytes as an unsigned integer value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_var_int(self, max_size=sys.maxsize):\n        fb = self.read_byte()\n        if fb is 0:\n            return fb\n        if hex(fb) == '0xfd':\n            value = self.read_uint16()\n        elif hex(fb) == '0xfe':\n            value = self.read_uint32()\n        elif hex(fb) == '0xff':\n            value = self.read_uint64()\n        else:\n            value = fb\n        if value > max_size:\n            raise SDKException(ErrorCode.param_err('Invalid format'))\n        return int(value)", "response": "This function is used to read a variable length integer from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a variable length of bytes from the stream.", "response": "def read_var_bytes(self, max_size=sys.maxsize) -> bytes:\n        \"\"\"\n        Read a variable length of bytes from the stream.\n\n        Args:\n            max_size (int): (Optional) maximum number of bytes to read.\n\n        Returns:\n            bytes:\n        \"\"\"\n        length = self.read_var_int(max_size)\n        return self.read_bytes(length)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a string from the stream.", "response": "def read_str(self):\n        \"\"\"\n        Read a string from the stream.\n\n        Returns:\n            str:\n        \"\"\"\n        length = self.read_uint8()\n        return self.unpack(str(length) + 's', length)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_serializable_array(self, class_name, max_size=sys.maxsize):\n        module = '.'.join(class_name.split('.')[:-1])\n        class_name = class_name.split('.')[-1]\n        class_attr = getattr(importlib.import_module(module), class_name)\n        length = self.read_var_int(max_size=max_size)\n        items = []\n        try:\n            for _ in range(0, length):\n                item = class_attr()\n                item.Deserialize(self)\n                items.append(item)\n        except Exception as e:\n            raise SDKException(ErrorCode.param_err(\"Couldn't deserialize %s\" % e))\n        return items", "response": "This interface is used to deserialize a list of class_name objects from a stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_2000256_list(self):\n        items = []\n        for _ in range(0, 2000):\n            data = self.read_bytes(64)\n            ba = bytearray(binascii.unhexlify(data))\n            ba.reverse()\n            items.append(ba.hex().encode('utf-8'))\n        return items", "response": "Reads 2000 times a 64 byte value from the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a list of hash values from the stream.", "response": "def read_hashes(self):\n        \"\"\"\n        Read Hash values from the stream.\n\n        Returns:\n            list: a list of hash values. Each value is of the bytearray type.\n        \"\"\"\n        var_len = self.read_var_int()\n        items = []\n        for _ in range(0, var_len):\n            ba = bytearray(self.read_bytes(32))\n            ba.reverse()\n            items.append(ba.hex())\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_byte(self, value):\n        if isinstance(value, bytes):\n            self.stream.write(value)\n        elif isinstance(value, str):\n            self.stream.write(value.encode('utf-8'))\n        elif isinstance(value, int):\n            self.stream.write(bytes([value]))", "response": "Writes a single byte to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites bytes by packing them according to the provided format string.", "response": "def pack(self, fmt, data):\n        \"\"\"\n        Write bytes by packing them according to the provided format `fmt`.\n        For more information about the `fmt` format see: https://docs.python.org/3/library/struct.html\n\n        Args:\n            fmt (str): format string.\n            data (object): the data to write to the raw stream.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        return self.write_bytes(struct.pack(fmt, data))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npack the value as a float and write 4 bytes to the stream.", "response": "def write_float(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a float and write 4 bytes to the stream.\n\n        Args:\n            value (number): the value to write to the stream.\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sf' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npack the value as a double and write 8 bytes to the stream.", "response": "def write_double(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a double and write 8 bytes to the stream.\n\n        Args:\n            value (number): the value to write to the stream.\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sd' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npacks the value as a signed byte and write 1 byte to the stream.", "response": "def write_int8(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a signed byte and write 1 byte to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sb' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_uint8(self, value, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sB' % endian, value)", "response": "Pack the value as an unsigned byte and write 1 byte to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npack the value as a signed integer and write 2 bytes to the stream.", "response": "def write_int16(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a signed integer and write 2 bytes to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sh' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_uint16(self, value, little_endian=True):\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sH' % endian, value)", "response": "Pack the value as an unsigned integer and write 2 bytes to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npacking the value as a signed integer and write 4 bytes to the stream.", "response": "def write_int32(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a signed integer and write 4 bytes to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%si' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npacks the value as an unsigned integer and write 4 bytes to the stream.", "response": "def write_uint32(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as an unsigned integer and write 4 bytes to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sI' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npack the value as a signed integer and write 8 bytes to the stream.", "response": "def write_int64(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as a signed integer and write 8 bytes to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sq' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npacks the value as an unsigned integer and write 8 bytes to the stream.", "response": "def write_uint64(self, value, little_endian=True):\n        \"\"\"\n        Pack the value as an unsigned integer and write 8 bytes to the stream.\n\n        Args:\n            value:\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if little_endian:\n            endian = \"<\"\n        else:\n            endian = \">\"\n        return self.pack('%sQ' % endian, value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite an integer value in a space saving way to the stream. Args: value (int): little_endian (bool): specify the endianness. (Default) Little endian. Raises: SDKException: if `value` is not of type int. SDKException: if `value` is < 0. Returns: int: the number of bytes written.", "response": "def write_var_int(self, value, little_endian=True):\n        \"\"\"\n        Write an integer value in a space saving way to the stream.\n\n        Args:\n            value (int):\n            little_endian (bool): specify the endianness. (Default) Little endian.\n\n        Raises:\n            SDKException: if `value` is not of type int.\n            SDKException: if `value` is < 0.\n\n        Returns:\n            int: the number of bytes written.\n        \"\"\"\n        if not isinstance(value, int):\n            raise SDKException(ErrorCode.param_err('%s not int type.' % value))\n\n        if value < 0:\n            raise SDKException(ErrorCode.param_err('%d too small.' % value))\n\n        elif value < 0xfd:\n            return self.write_byte(value)\n\n        elif value <= 0xffff:\n            self.write_byte(0xfd)\n            return self.write_uint16(value, little_endian)\n\n        elif value <= 0xFFFFFFFF:\n            self.write_byte(0xfe)\n            return self.write_uint32(value, little_endian)\n\n        else:\n            self.write_byte(0xff)\n            return self.write_uint64(value, little_endian)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_var_bytes(self, value, little_endian: bool = True):\n        length = len(value)\n        self.write_var_int(length, little_endian)\n        return self.write_bytes(value, to_bytes=False)", "response": "Writes an integer value in a space saving way to the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a string value to the stream.", "response": "def write_var_str(self, value, encoding: str = 'utf-8'):\n        \"\"\"\n        Write a string value to the stream.\n\n        :param value: value to write to the stream.\n        :param encoding: string encoding format.\n        \"\"\"\n        if isinstance(value, str):\n            value = value.encode(encoding)\n        self.write_var_int(len(value))\n        self.write_bytes(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a string value to the stream. Args: value (str): value to write to the stream. length (int): length of the string to write.", "response": "def write_fixed_str(self, value, length):\n        \"\"\"\n        Write a string value to the stream.\n\n        Args:\n            value (str): value to write to the stream.\n            length (int): length of the string to write.\n        \"\"\"\n        towrite = value.encode('utf-8')\n        slen = len(towrite)\n        if slen > length:\n            raise SDKException(ErrorCode.param_err('string longer than fixed length: %s' % length))\n        self.write_bytes(towrite)\n        diff = length - slen\n\n        while diff > 0:\n            self.write_byte(0)\n            diff -= 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite an array of serializable objects to the stream.", "response": "def write_serializable_array(self, array):\n        \"\"\"\n        Write an array of serializable objects to the stream.\n\n        Args:\n            array(list): a list of serializable objects. i.e. extending neo.IO.Mixins.SerializableMixin\n        \"\"\"\n        if array is None:\n            self.write_byte(0)\n        else:\n            self.write_var_int(len(array))\n            for item in array:\n                item.Serialize(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting an array of 32 byte hashes to the stream.", "response": "def write_hashes(self, arr):\n        \"\"\"\n        Write an array of hashes to the stream.\n\n        Args:\n            arr (list): a list of 32 byte hashes.\n        \"\"\"\n        length = len(arr)\n        self.write_var_int(length)\n        for item in arr:\n            ba = bytearray(binascii.unhexlify(item))\n            ba.reverse()\n            self.write_bytes(ba)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_asset_address(self, asset: str) -> bytes:\n        if asset.upper() == 'ONT':\n            return self.__ont_contract\n        elif asset.upper() == 'ONG':\n            return self.__ong_contract\n        else:\n            raise SDKException(ErrorCode.other_error('asset is not equal to ONT or ONG.'))", "response": "This interface is used to get the smart contract address of an asset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query_balance(self, asset: str, b58_address: str) -> int:\n        raw_address = Address.b58decode(b58_address).to_bytes()\n        contract_address = self.get_asset_address(asset)\n        invoke_code = build_native_invoke_code(contract_address, b'\\x00', \"balanceOf\", raw_address)\n        tx = Transaction(0, 0xd1, int(time()), 0, 0, None, invoke_code, bytearray(), list())\n        response = self.__sdk.rpc.send_raw_transaction_pre_exec(tx)\n        try:\n            balance = ContractDataParser.to_int(response['Result'])\n            return balance\n        except SDKException:\n            return 0", "response": "This interface is used to query the account s balance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query_unbound_ong(self, base58_address: str) -> int:\n        contract_address = self.get_asset_address('ont')\n        unbound_ong = self.__sdk.rpc.get_allowance(\"ong\", Address(contract_address).b58encode(), base58_address)\n        return int(unbound_ong)", "response": "This interface is used to query the amount of account s unbound ong."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_transfer_transaction(self, asset: str, b58_from_address: str, b58_to_address: str, amount: int,\n                                 b58_payer_address: str, gas_limit: int, gas_price: int) -> Transaction:\n        \"\"\"\n        This interface is used to generate a Transaction object for transfer.\n\n        :param asset: a string which is used to indicate which asset we want to transfer.\n        :param b58_from_address: a base58 encode address which indicate where the asset from.\n        :param b58_to_address: a base58 encode address which indicate where the asset to.\n        :param amount: the amount of asset that will be transferred.\n        :param b58_payer_address: a base58 encode address which indicate who will pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: a Transaction object which can be used for transfer.\n        \"\"\"\n        if not isinstance(b58_from_address, str) or not isinstance(b58_to_address, str) or not isinstance(\n                b58_payer_address, str):\n            raise SDKException(ErrorCode.param_err('the data type of base58 encode address should be the string.'))\n        if len(b58_from_address) != 34 or len(b58_to_address) != 34 or len(b58_payer_address) != 34:\n            raise SDKException(ErrorCode.param_err('the length of base58 encode address should be 34 bytes.'))\n        if amount <= 0:\n            raise SDKException(ErrorCode.other_error('the amount should be greater than than zero.'))\n        if gas_price < 0:\n            raise SDKException(ErrorCode.other_error('the gas price should be equal or greater than zero.'))\n        if gas_limit < 0:\n            raise SDKException(ErrorCode.other_error('the gas limit should be equal or greater than zero.'))\n        contract_address = self.get_asset_address(asset)\n        raw_from = Address.b58decode(b58_from_address).to_bytes()\n        raw_to = Address.b58decode(b58_to_address).to_bytes()\n        raw_payer = Address.b58decode(b58_payer_address).to_bytes()\n        state = [{\"from\": raw_from, \"to\": raw_to, \"amount\": amount}]\n        invoke_code = build_native_invoke_code(contract_address, b'\\x00', \"transfer\", state)\n        return Transaction(0, 0xd1, int(time()), gas_price, gas_limit, raw_payer, invoke_code, bytearray(), list())", "response": "This interface is used to generate a Transaction object which can be used to transfer an asset from one address to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef approve(self, asset, sender: Account, b58_recv_address: str, amount: int, payer: Account, gas_limit: int,\n                gas_price: int) -> str:\n        \"\"\"\n        This is an interface used to send an approve transaction\n        which allow receiver to spend a amount of ONT or ONG asset in sender's account.\n\n        :param asset: a string which is used to indicate what asset we want to approve.\n        :param sender: an Account class that send the approve transaction.\n        :param b58_recv_address: a base58 encode address which indicate where the approve to.\n        :param amount: the amount of asset want to approve.\n        :param payer: an Account class that used to pay for the transaction.\n        :param gas_limit: an int value that indicate the gas limit.\n        :param gas_price: an int value that indicate the gas price.\n        :return: hexadecimal transaction hash value.\n        \"\"\"\n        if sender is None:\n            raise SDKException(ErrorCode.param_err('the sender should not be None.'))\n        if payer is None:\n            raise SDKException(ErrorCode.param_err('the payer should not be None.'))\n        if amount <= 0:\n            raise SDKException(ErrorCode.other_error('the amount should be greater than than zero.'))\n        if gas_price < 0:\n            raise SDKException(ErrorCode.other_error('the gas price should be equal or greater than zero.'))\n        if gas_limit < 0:\n            raise SDKException(ErrorCode.other_error('the gas limit should be equal or greater than zero.'))\n        b58_sender_address = sender.get_address_base58()\n        b58_payer_address = payer.get_address_base58()\n        tx = self.new_approve_transaction(asset, b58_sender_address, b58_recv_address, amount, b58_payer_address,\n                                          gas_limit, gas_price)\n        tx.sign_transaction(sender)\n        if sender.get_address_base58() != payer.get_address_base58():\n            tx.add_sign_transaction(payer)\n        return self.__sdk.get_network().send_raw_transaction(tx)", "response": "This interface is used to send an approve transaction to the receiver."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_default_account_by_index(self, index: int):\n        if index >= len(self.accounts):\n            raise SDKException(ErrorCode.param_error)\n        for acct in self.accounts:\n            acct.is_default = False\n        self.accounts[index].is_default = True\n        self.default_account_address = self.accounts[index].b58_address", "response": "This interface is used to set default account by given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_credentials(self, email, password):\n\n        self._email = email\n        self._password = password\n        response = requests.post(self._auth_url,\n                                 json=dict(payload=dict(email=self._email, password=self._password, serviceId=4728)))\n        body = response.json()\n        if response.status_code == codes.ok:\n            self._glb_id = body['glbId']\n        else:\n            raise CartolaFCError(body['userMessage'])", "response": "Set the credentials for a user in the cartolafc."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef liga(self, nome=None, slug=None, page=1, order_by=CAMPEONATO):\n\n        if not any((nome, slug)):\n            raise CartolaFCError('Voc\u00ea precisa informar o nome ou o slug da liga que deseja obter')\n\n        slug = slug if slug else convert_team_name_to_slug(nome)\n        url = '{api_url}/auth/liga/{slug}'.format(api_url=self._api_url, slug=slug)\n        data = self._request(url, params=dict(page=page, orderBy=order_by))\n        return Liga.from_dict(data, order_by)", "response": "Return a um objeto representando a liga."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ligas(self, query):\n\n        url = '{api_url}/ligas'.format(api_url=self._api_url)\n        data = self._request(url, params=dict(q=query))\n        return [Liga.from_dict(liga_info) for liga_info in data]", "response": "Retorna o resultado da busca ao Cartola por um determinado termo de pesquisa."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mercado(self):\n\n        url = '{api_url}/mercado/status'.format(api_url=self._api_url)\n        data = self._request(url)\n        return Mercado.from_dict(data)", "response": "Return a Mercado object representing a status do mercado na rodada atual."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parciais(self):\n\n        if self.mercado().status.id == MERCADO_FECHADO:\n            url = '{api_url}/atletas/pontuados'.format(api_url=self._api_url)\n            data = self._request(url)\n            clubes = {clube['id']: Clube.from_dict(clube) for clube in data['clubes'].values()}\n            return {int(atleta_id): Atleta.from_dict(atleta, clubes=clubes, atleta_id=int(atleta_id)) for\n                    atleta_id, atleta in data['atletas'].items() if atleta['clube_id'] > 0}\n\n        raise CartolaFCError('As pontua\u00e7\u00f5es parciais s\u00f3 ficam dispon\u00edveis com o mercado fechado.')", "response": "Return a dictionary of all the parciais in a mercado atual estiver."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef time(self, id=None, nome=None, slug=None, as_json=False):\n        if not any((id, nome, slug)):\n            raise CartolaFCError('Voc\u00ea precisa informar o nome ou o slug do time que deseja obter')\n\n        param = 'id' if id else 'slug'\n        value = id if id else (slug if slug else convert_team_name_to_slug(nome))\n        url = '{api_url}/time/{param}/{value}'.format(api_url=self._api_url, param=param, value=value)\n        data = self._request(url)\n\n        if bool(as_json):\n            return data\n\n        clubes = {clube['id']: Clube.from_dict(clube) for clube in data['clubes'].values()}\n        return Time.from_dict(data, clubes=clubes, capitao=data['capitao_id'])", "response": "Return a dict representation of a time in a cultural language."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_gtf(\n        filepath_or_buffer,\n        chunksize=1024 * 1024,\n        features=None,\n        intern_columns=[\"seqname\", \"source\", \"strand\", \"frame\"],\n        fix_quotes_columns=[\"attribute\"]):\n    \"\"\"\n    Parameters\n    ----------\n\n    filepath_or_buffer : str or buffer object\n\n    chunksize : int\n\n    features : set or None\n        Drop entries which aren't one of these features\n\n    intern_columns : list\n        These columns are short strings which should be interned\n\n    fix_quotes_columns : list\n        Most commonly the 'attribute' column which had broken quotes on\n        some Ensembl release GTF files.\n    \"\"\"\n    if features is not None:\n        features = set(features)\n\n    dataframes = []\n\n    def parse_frame(s):\n        if s == \".\":\n            return 0\n        else:\n            return int(s)\n\n    # GTF columns:\n    # 1) seqname: str (\"1\", \"X\", \"chrX\", etc...)\n    # 2) source : str\n    #      Different versions of GTF use second column as of:\n    #      (a) gene biotype\n    #      (b) transcript biotype\n    #      (c) the annotation source\n    #      See: https://www.biostars.org/p/120306/#120321\n    # 3) feature : str (\"gene\", \"transcript\", &c)\n    # 4) start : int\n    # 5) end : int\n    # 6) score : float or \".\"\n    # 7) strand : \"+\", \"-\", or \".\"\n    # 8) frame : 0, 1, 2 or \".\"\n    # 9) attribute : key-value pairs separated by semicolons\n    # (see more complete description in docstring at top of file)\n\n    chunk_iterator = pd.read_csv(\n        filepath_or_buffer,\n        sep=\"\\t\",\n        comment=\"#\",\n        names=REQUIRED_COLUMNS,\n        skipinitialspace=True,\n        skip_blank_lines=True,\n        error_bad_lines=True,\n        warn_bad_lines=True,\n        chunksize=chunksize,\n        engine=\"c\",\n        dtype={\n            \"start\": np.int64,\n            \"end\": np.int64,\n            \"score\": np.float32,\n            \"seqname\": str,\n        },\n        na_values=\".\",\n        converters={\"frame\": parse_frame})\n    dataframes = []\n    try:\n        for df in chunk_iterator:\n            for intern_column in intern_columns:\n                df[intern_column] = [intern(str(s)) for s in df[intern_column]]\n\n            # compare feature strings after interning\n            if features is not None:\n                df = df[df[\"feature\"].isin(features)]\n\n            for fix_quotes_column in fix_quotes_columns:\n                # Catch mistaken semicolons by replacing \"xyz;\" with \"xyz\"\n                # Required to do this since the Ensembl GTF for Ensembl\n                # release 78 has mistakes such as:\n                #   gene_name = \"PRAMEF6;\" transcript_name = \"PRAMEF6;-201\"\n                df[fix_quotes_column] = [\n                    s.replace(';\\\"', '\\\"').replace(\";-\", \"-\")\n                    for s in df[fix_quotes_column]\n                ]\n            dataframes.append(df)\n    except Exception as e:\n        raise ParsingError(str(e))\n    df = pd.concat(dataframes)\n    return df", "response": "Parses a GTF file into a list of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a GTF file into column - > values dictionary and then expands the attribute values into multiple columns.", "response": "def parse_gtf_and_expand_attributes(\n        filepath_or_buffer,\n        chunksize=1024 * 1024,\n        restrict_attribute_columns=None,\n        features=None):\n    \"\"\"\n    Parse lines into column->values dictionary and then expand\n    the 'attribute' column into multiple columns. This expansion happens\n    by replacing strings of semi-colon separated key-value values in the\n    'attribute' column with one column per distinct key, with a list of\n    values for each row (using None for rows where key didn't occur).\n\n    Parameters\n    ----------\n    filepath_or_buffer : str or buffer object\n\n    chunksize : int\n\n    restrict_attribute_columns : list/set of str or None\n        If given, then only usese attribute columns.\n\n    features : set or None\n        Ignore entries which don't correspond to one of the supplied features\n    \"\"\"\n    result = parse_gtf(\n        filepath_or_buffer,\n        chunksize=chunksize,\n        features=features)\n    attribute_values = result[\"attribute\"]\n    del result[\"attribute\"]\n    for column_name, values in expand_attribute_strings(\n            attribute_values, usecols=restrict_attribute_columns).items():\n        result[column_name] = values\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_gtf(\n        filepath_or_buffer,\n        expand_attribute_column=True,\n        infer_biotype_column=False,\n        column_converters={},\n        usecols=None,\n        features=None,\n        chunksize=1024 * 1024):\n    \"\"\"\n    Parse a GTF into a dictionary mapping column names to sequences of values.\n\n    Parameters\n    ----------\n    filepath_or_buffer : str or buffer object\n        Path to GTF file (may be gzip compressed) or buffer object\n        such as StringIO\n\n    expand_attribute_column : bool\n        Replace strings of semi-colon separated key-value values in the\n        'attribute' column with one column per distinct key, with a list of\n        values for each row (using None for rows where key didn't occur).\n\n    infer_biotype_column : bool\n        Due to the annoying ambiguity of the second GTF column across multiple\n        Ensembl releases, figure out if an older GTF's source column is actually\n        the gene_biotype or transcript_biotype.\n\n    column_converters : dict, optional\n        Dictionary mapping column names to conversion functions. Will replace\n        empty strings with None and otherwise passes them to given conversion\n        function.\n\n    usecols : list of str or None\n        Restrict which columns are loaded to the give set. If None, then\n        load all columns.\n\n    features : set of str or None\n        Drop rows which aren't one of the features in the supplied set\n\n    chunksize : int\n    \"\"\"\n    if isinstance(filepath_or_buffer, string_types) and not exists(filepath_or_buffer):\n        raise ValueError(\"GTF file does not exist: %s\" % filepath_or_buffer)\n\n    if expand_attribute_column:\n        result_df = parse_gtf_and_expand_attributes(\n            filepath_or_buffer,\n            chunksize=chunksize,\n            restrict_attribute_columns=usecols)\n    else:\n        result_df = parse_gtf(result_df, features=features)\n\n    for column_name, column_type in list(column_converters.items()):\n        result_df[column_name] = [\n            column_type(string_value) if len(string_value) > 0 else None\n            for string_value\n            in result_df[column_name]\n        ]\n\n    # Hackishly infer whether the values in the 'source' column of this GTF\n    # are actually representing a biotype by checking for the most common\n    # gene_biotype and transcript_biotype value 'protein_coding'\n    if infer_biotype_column:\n        unique_source_values = set(result_df[\"source\"])\n        if \"protein_coding\" in unique_source_values:\n            column_names = set(result_df.columns)\n            # Disambiguate between the two biotypes by checking if\n            # gene_biotype is already present in another column. If it is,\n            # the 2nd column is the transcript_biotype (otherwise, it's the\n            # gene_biotype)\n            if \"gene_biotype\" not in column_names:\n                logging.info(\"Using column 'source' to replace missing 'gene_biotype'\")\n                result_df[\"gene_biotype\"] = result_df[\"source\"]\n            if \"transcript_biotype\" not in column_names:\n                logging.info(\"Using column 'source' to replace missing 'transcript_biotype'\")\n                result_df[\"transcript_biotype\"] = result_df[\"source\"]\n\n    if usecols is not None:\n        column_names = set(result_df.columns)\n        valid_columns = [c for c in usecols if c in column_names]\n        result_df = result_df[valid_columns]\n\n    return result_df", "response": "Parses a GTF file into a dictionary mapping column names to sequences of values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexpand the list of attribute strings into a single GTF file.", "response": "def expand_attribute_strings(\n        attribute_strings,\n        quote_char='\\\"',\n        missing_value=\"\",\n        usecols=None):\n    \"\"\"\n    The last column of GTF has a variable number of key value pairs\n    of the format: \"key1 value1; key2 value2;\"\n    Parse these into a dictionary mapping each key onto a list of values,\n    where the value is None for any row where the key was missing.\n\n    Parameters\n    ----------\n    attribute_strings : list of str\n\n    quote_char : str\n        Quote character to remove from values\n\n    missing_value : any\n        If an attribute is missing from a row, give it this value.\n\n    usecols : list of str or None\n        If not None, then only expand columns included in this set,\n        otherwise use all columns.\n\n    Returns OrderedDict of column->value list mappings, in the order they\n    appeared in the attribute strings.\n    \"\"\"\n    n = len(attribute_strings)\n\n    extra_columns = {}\n    column_order = []\n\n    #\n    # SOME NOTES ABOUT THE BIZARRE STRING INTERNING GOING ON BELOW\n    #\n    # While parsing millions of repeated strings (e.g. \"gene_id\" and \"TP53\"),\n    # we can save a lot of memory by making sure there's only one string\n    # object per unique string. The canonical way to do this is using\n    # the 'intern' function. One problem is that Py2 won't let you intern\n    # unicode objects, so to get around this we call intern(str(...)).\n    #\n    # It also turns out to be faster to check interned strings ourselves\n    # using a local dictionary, hence the two dictionaries below\n    # and pair of try/except blocks in the loop.\n    column_interned_strings = {}\n    value_interned_strings = {}\n\n    for (i, attribute_string) in enumerate(attribute_strings):\n        for kv in attribute_string.split(\";\"):\n            # We're slicing the first two elements out of split() because\n            # Ensembl release 79 added values like:\n            #   transcript_support_level \"1 (assigned to previous version 5)\";\n            # ...which gets mangled by splitting on spaces.\n            parts = kv.strip().split(\" \", 2)[:2]\n\n            if len(parts) != 2:\n                continue\n\n            column_name, value = parts\n\n            try:\n                column_name = column_interned_strings[column_name]\n            except KeyError:\n                column_name = intern(str(column_name))\n                column_interned_strings[column_name] = column_name\n\n            if usecols is not None and column_name not in usecols:\n                continue\n\n            try:\n                column = extra_columns[column_name]\n            except KeyError:\n                column = [missing_value] * n\n                extra_columns[column_name] = column\n                column_order.append(column_name)\n\n            value = value.replace(quote_char, \"\") if value.startswith(quote_char) else value\n\n            try:\n                value = value_interned_strings[value]\n            except KeyError:\n                value = intern(str(value))\n                value_interned_strings[value] = value\n\n            # if an attribute is used repeatedly then\n            # keep track of all its values in a list\n            old_value = column[i]\n            if old_value is missing_value:\n                column[i] = value\n            else:\n                column[i] = \"%s,%s\" % (old_value, value)\n\n    logging.info(\"Extracted GTF attributes: %s\" % column_order)\n    return OrderedDict(\n        (column_name, extra_columns[column_name])\n        for column_name in column_order)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_missing_features(\n        dataframe,\n        unique_keys={},\n        extra_columns={},\n        missing_value=None):\n    \"\"\"\n    Helper function used to construct a missing feature such as 'transcript'\n    or 'gene'. Some GTF files only have 'exon' and 'CDS' entries, but have\n    transcript_id and gene_id annotations which allow us to construct those\n    missing features.\n\n    Parameters\n    ----------\n    dataframe : pandas.DataFrame\n        Should contain at least the core GTF columns, such as \"seqname\",\n        \"start\", and \"end\"\n\n    unique_keys : dict\n        Mapping from feature names to the name of the column which should\n        act as a unique key for that feature. Example: {\"gene\": \"gene_id\"}\n\n    extra_columns : dict\n        By default the constructed feature row will include only the 8\n        core columns and its unique key. Any other columns that should\n        be included should be associated with the feature name in this\n        dict.\n\n    missing_value : any\n        Which value to fill in for columns that we don't infer values for.\n\n    Returns original dataframe along with all extra rows created for missing\n    features.\n    \"\"\"\n    extra_dataframes = []\n\n    existing_features = set(dataframe[\"feature\"])\n    existing_columns = set(dataframe.keys())\n\n    for (feature_name, groupby_key) in unique_keys.items():\n        if feature_name in existing_features:\n            logging.info(\n                \"Feature '%s' already exists in GTF data\" % feature_name)\n            continue\n        logging.info(\"Creating rows for missing feature '%s'\" % feature_name)\n\n        # don't include rows where the groupby key was missing\n        empty_key_values = dataframe[groupby_key].map(\n            lambda x: x == \"\" or x is None)\n        row_groups = dataframe[~empty_key_values].groupby(groupby_key)\n\n        # Each group corresponds to a unique feature entry for which the\n        # other columns may or may not be uniquely defined. Start off by\n        # assuming the values for every column are missing and fill them in\n        # where possible.\n        feature_values = OrderedDict([\n            (column_name, [missing_value] * row_groups.ngroups)\n            for column_name in dataframe.keys()\n        ])\n\n        # User specifies which non-required columns should we try to infer\n        # values for\n        feature_columns = list(extra_columns.get(feature_name, []))\n\n        for i, (feature_id, group) in enumerate(row_groups):\n            # fill in the required columns by assuming that this feature\n            # is the union of all intervals of other features that were\n            # tagged with its unique ID (e.g. union of exons which had a\n            # particular gene_id).\n            feature_values[\"feature\"][i] = feature_name\n            feature_values[groupby_key][i] = feature_id\n            # set the source to 'gtfparse' to indicate that we made this\n            # entry up from other data\n            feature_values[\"source\"][i] = \"gtfparse\"\n            feature_values[\"start\"][i] = group[\"start\"].min()\n            feature_values[\"end\"][i] = group[\"end\"].max()\n\n            # assume that seqname and strand are the same for all other\n            # entries in the GTF which shared this unique ID\n            feature_values[\"seqname\"][i] = group[\"seqname\"].iat[0]\n            feature_values[\"strand\"][i] = group[\"strand\"].iat[0]\n\n            # there's probably no rigorous way to set the values of\n            # 'score' or 'frame' columns so leave them empty\n            for column_name in feature_columns:\n                if column_name not in existing_columns:\n                    raise ValueError(\n                        \"Column '%s' does not exist in GTF, columns = %s\" % (\n                            column_name, existing_columns))\n\n                # expect that all entries related to a reconstructed feature\n                # are related and are thus within the same interval of\n                # positions on the same chromosome\n                unique_values = group[column_name].dropna().unique()\n                if len(unique_values) == 1:\n                    feature_values[column_name][i] = unique_values[0]\n        extra_dataframes.append(pd.DataFrame(feature_values))\n    return pd.concat([dataframe] + extra_dataframes, ignore_index=True)", "response": "Helper function to construct a missing feature row for a GTF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_action(self, key):\n        index_local_timestamp = self.get_index_local_timestamp(key)\n        real_local_timestamp = self.get_real_local_timestamp(key)\n        remote_timestamp = self.get_remote_timestamp(key)\n        return get_sync_state(\n            index_local_timestamp, real_local_timestamp, remote_timestamp\n        )", "response": "Returns the action to perform on this key based on its current state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlocking the local cache file.", "response": "def lock(self, timeout=10):\n        \"\"\"\n        Advisory lock.\n        Use to ensure that only one LocalSyncClient is working on the Target at the same time.\n        \"\"\"\n        logger.debug(\"Locking %s\", self.lock_file)\n        if not os.path.exists(self.lock_file):\n            self.ensure_path(self.lock_file)\n            with open(self.lock_file, \"w\"):\n                os.utime(self.lock_file)\n        self._lock.acquire(timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unlock(self):\n        logger.debug(\"Releasing lock %s\", self.lock_file)\n        self._lock.release()\n        try:\n            os.unlink(self.lock_file)\n        except FileNotFoundError:\n            pass", "response": "Unlock the active advisory lock."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_input(*args, secret=False, required=False, blank=False, **kwargs):\n\n    while True:\n        if secret:\n            value = getpass.getpass(*args, **kwargs)\n        else:\n            value = input(*args, **kwargs)\n\n        if blank:\n            value = value if value else None\n\n        if not required or value:\n            break\n\n    return value", "response": "Get user input from the user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _no_proxy(method):\n\n        @wraps(method)\n        def wrapper(self, *args, **kwargs):\n            notproxied = _oga(self, \"__notproxied__\")\n            _osa(self, \"__notproxied__\", True)\n            try:\n                return method(self, *args, **kwargs)\n            finally:\n                _osa(self, \"__notproxied__\", notproxied)\n\n        return wrapper", "response": "Returns a wrapped version of the given method that does not proxy the current object s entry set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _should_proxy(self, attr):\n        if attr in type(self).__notproxied__:\n            return False\n        if _oga(self, \"__notproxied__\") is True:\n            return False\n        return True", "response": "Determines whether the attribute attr should be looked up on the proxied object or not."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a method name to the class which returns the value of func called at arg_pos.", "response": "def add_proxy_meth(cls, name, func, arg_pos=0):\n        \"\"\"\n        Add a method `name` to the class, which returns the value of `func`,\n        called with the proxied value inserted at `arg_pos`\n\n        \"\"\"\n\n        @wraps(func)\n        def proxied(self, *args, **kwargs):\n            args = list(args)\n            args.insert(arg_pos, self.__subject__)\n            result = func(*args, **kwargs)\n            return result\n\n        setattr(cls, name, proxied)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(fp, base_uri=\"\", loader=None, jsonschema=False, load_on_repr=True, **kwargs):\n\n    if loader is None:\n        loader = functools.partial(jsonloader, **kwargs)\n\n    return JsonRef.replace_refs(\n        json.load(fp, **kwargs),\n        base_uri=base_uri,\n        loader=loader,\n        jsonschema=jsonschema,\n        load_on_repr=load_on_repr,\n    )", "response": "Load a JSON document into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new JSON document from the given string.", "response": "def loads(s, base_uri=\"\", loader=None, jsonschema=False, load_on_repr=True, **kwargs):\n    \"\"\"\n    Drop in replacement for :func:`json.loads`, where JSON references are\n    proxied to their referent data.\n\n    :param s: String containing JSON document\n    :param kwargs: This function takes any of the keyword arguments from\n        :meth:`JsonRef.replace_refs`. Any other keyword arguments will be passed to\n        :func:`json.loads`\n\n    \"\"\"\n\n    if loader is None:\n        loader = functools.partial(jsonloader, **kwargs)\n\n    return JsonRef.replace_refs(\n        json.loads(s, **kwargs),\n        base_uri=base_uri,\n        loader=loader,\n        jsonschema=jsonschema,\n        load_on_repr=load_on_repr,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload JSON data from URI with JSON references proxied to their referent data.", "response": "def load_uri(uri, base_uri=None, loader=None, jsonschema=False, load_on_repr=True):\n    \"\"\"\n    Load JSON data from ``uri`` with JSON references proxied to their referent\n    data.\n\n    :param uri: URI to fetch the JSON from\n    :param kwargs: This function takes any of the keyword arguments from\n        :meth:`JsonRef.replace_refs`\n\n    \"\"\"\n\n    if loader is None:\n        loader = jsonloader\n    if base_uri is None:\n        base_uri = uri\n\n    return JsonRef.replace_refs(\n        loader(uri),\n        base_uri=base_uri,\n        loader=loader,\n        jsonschema=jsonschema,\n        load_on_repr=load_on_repr,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize obj to a JSON formatted string.", "response": "def dumps(obj, **kwargs):\n    \"\"\"\n    Serialize `obj`, which may contain :class:`JsonRef` objects, to a JSON\n    formatted string. `JsonRef` objects will be dumped as the original\n    reference object they were created from.\n\n    :param obj: Object to serialize\n    :param kwargs: Keyword arguments are the same as to :func:`json.dumps`\n\n    \"\"\"\n    kwargs[\"cls\"] = _ref_encoder_factory(kwargs.get(\"cls\", json.JSONEncoder))\n    return json.dumps(obj, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a deep copy of obj with all contained JSON reference objects replaced with JSONRefs.", "response": "def replace_refs(cls, obj, _recursive=False, **kwargs):\n        \"\"\"\n        Returns a deep copy of `obj` with all contained JSON reference objects\n        replaced with :class:`JsonRef` instances.\n\n        :param obj: If this is a JSON reference object, a :class:`JsonRef`\n            instance will be created. If `obj` is not a JSON reference object,\n            a deep copy of it will be created with all contained JSON\n            reference objects replaced by :class:`JsonRef` instances\n        :param base_uri: URI to resolve relative references against\n        :param loader: Callable that takes a URI and returns the parsed JSON\n            (defaults to global ``jsonloader``, a :class:`JsonLoader` instance)\n        :param jsonschema: Flag to turn on `JSON Schema mode\n            <http://json-schema.org/latest/json-schema-core.html#anchor25>`_.\n            'id' keyword changes the `base_uri` for references contained within\n            the object\n        :param load_on_repr: If set to ``False``, :func:`repr` call on a\n            :class:`JsonRef` object will not cause the reference to be loaded\n            if it hasn't already. (defaults to ``True``)\n\n        \"\"\"\n\n        store = kwargs.setdefault(\"_store\", _URIDict())\n        base_uri, frag = urlparse.urldefrag(kwargs.get(\"base_uri\", \"\"))\n        store_uri = None  # If this does not get set, we won't store the result\n        if not frag and not _recursive:\n            store_uri = base_uri\n        try:\n            if kwargs.get(\"jsonschema\") and isinstance(obj[\"id\"], basestring):\n                kwargs[\"base_uri\"] = urlparse.urljoin(\n                    kwargs.get(\"base_uri\", \"\"), obj[\"id\"]\n                )\n                store_uri = kwargs[\"base_uri\"]\n        except (TypeError, LookupError):\n            pass\n\n        try:\n            if not isinstance(obj[\"$ref\"], basestring):\n                raise TypeError\n        except (TypeError, LookupError):\n            pass\n        else:\n            return cls(obj, **kwargs)\n\n        # If our obj was not a json reference object, iterate through it,\n        # replacing children with JsonRefs\n        kwargs[\"_recursive\"] = True\n        path = list(kwargs.pop(\"_path\", ()))\n        if isinstance(obj, Mapping):\n            obj = type(obj)(\n                (k, cls.replace_refs(v, _path=path + [k], **kwargs))\n                for k, v in iteritems(obj)\n            )\n        elif isinstance(obj, Sequence) and not isinstance(obj, basestring):\n            obj = type(obj)(\n                cls.replace_refs(v, _path=path + [i], **kwargs)\n                for i, v in enumerate(obj)\n            )\n        if store_uri is not None:\n            store[store_uri] = obj\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve_pointer(self, document, pointer):\n        # Do only split at single forward slashes which are not prefixed by a caret\n        parts = re.split(r\"(?<!\\^)/\", unquote(pointer.lstrip(\"/\"))) if pointer else []\n\n        for part in parts:\n            # Restore escaped slashes and carets\n            replacements = {r\"^/\": r\"/\", r\"^^\": r\"^\"}\n            part = re.sub(\n                \"|\".join(re.escape(key) for key in replacements.keys()),\n                lambda k: replacements[k.group(0)],\n                part,\n            )\n            if isinstance(document, Sequence):\n                # Try to turn an array index to an int\n                try:\n                    part = int(part)\n                except ValueError:\n                    pass\n            try:\n                document = document[part]\n            except (TypeError, LookupError) as e:\n                self._error(\"Unresolvable JSON pointer: %r\" % pointer, cause=e)\n        return document", "response": "Resolve a json pointer fragment within the referenced document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dump(obj, fp, container_count=False, sort_keys=False, no_float32=True, default=None):\n    if not callable(fp.write):\n        raise TypeError('fp.write not callable')\n    fp_write = fp.write\n\n    __encode_value(fp_write, obj, {}, container_count, sort_keys, no_float32, default)", "response": "Writes the given object as UBJSON to the provided file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the given object as UBJSON in a bytes instance.", "response": "def dumpb(obj, container_count=False, sort_keys=False, no_float32=True, default=None):\n    \"\"\"Returns the given object as UBJSON in a bytes instance. See dump() for\n       available arguments.\"\"\"\n    with BytesIO() as fp:\n        dump(obj, fp, container_count=container_count, sort_keys=sort_keys, no_float32=no_float32, default=default)\n        return fp.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nresolve version from LATEST version", "response": "def _resolve_version(version):\n    \"\"\"\n    Resolve LATEST version\n    \"\"\"\n    if version is not LATEST:\n        return version\n\n    resp = urlopen('https://pypi.python.org/pypi/setuptools/json')\n    with contextlib.closing(resp):\n        try:\n            charset = resp.info().get_content_charset()\n        except Exception:\n            # Python 2 compat; assume UTF-8\n            charset = 'UTF-8'\n        reader = codecs.getreader(charset)\n        doc = json.load(reader(resp))\n\n    return str(doc['info']['version'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(fp, no_bytes=False, object_hook=None, object_pairs_hook=None, intern_object_keys=False):\n    if object_pairs_hook is None and object_hook is None:\n        object_hook = __object_hook_noop\n\n    if not callable(fp.read):\n        raise TypeError('fp.read not callable')\n    fp_read = fp.read\n\n    marker = fp_read(1)\n    try:\n        try:\n            return __METHOD_MAP[marker](fp_read, marker)\n        except KeyError:\n            pass\n        if marker == ARRAY_START:\n            return __decode_array(fp_read, bool(no_bytes), object_hook, object_pairs_hook, intern_object_keys)\n        elif marker == OBJECT_START:\n            return __decode_object(fp_read, bool(no_bytes), object_hook, object_pairs_hook, intern_object_keys)\n        else:\n            raise DecoderException('Invalid marker')\n    except DecoderException as ex:\n        raise_from(DecoderException(ex.args[0], fp), ex)", "response": "Decodes and returns UBJSON from the given file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode and returns UBJSON from the given bytes or bytesarray object. See load for available arguments.", "response": "def loadb(chars, no_bytes=False, object_hook=None, object_pairs_hook=None, intern_object_keys=False):\n    \"\"\"Decodes and returns UBJSON from the given bytes or bytesarray object. See\n       load() for available arguments.\"\"\"\n    with BytesIO(chars) as fp:\n        return load(fp, no_bytes=no_bytes, object_hook=object_hook, object_pairs_hook=object_pairs_hook,\n                    intern_object_keys=intern_object_keys)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_error_code(self):\n        # start off with STATUS_SUCCESS as a baseline\n        status = NtStatusCodes.STATUS_SUCCESS\n\n        error_code = self['errorCode']\n        if error_code.isValue:\n            # ASN.1 Integer is stored as an signed integer, we need to\n            # convert it to a unsigned integer\n            status = ctypes.c_uint32(error_code).value\n\n        if status != NtStatusCodes.STATUS_SUCCESS:\n            raise NTStatusException(status)", "response": "Check if the error code exists and if not raise an NTStatusException."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_auth_context(hostname, username, password, auth_mech):\n    if auth_mech not in [\"auto\", \"ntlm\", \"kerberos\"]:\n        raise InvalidConfigurationException(\"Invalid auth_mech supplied \"\n                                            \"%s, must be auto, ntlm, or \"\n                                            \"kerberos\" % auth_mech)\n    context_init = False\n    out_token = None\n    context_gen = None\n\n    if HAS_SSPI:\n        # always use SSPI when it is available\n        log.debug(\"SSPI is available and will be used as auth backend\")\n        context = SSPIContext(hostname, username, password, auth_mech)\n    elif HAS_GSSAPI:\n        mechs_available = [\"kerberos\"]\n        # to save on computing costs we only check the mechs that are available\n        # when auth_mech is auto or ntlm as it doesn't matter when kerberos\n        # is set (Kerberos is always available when python-gssapi is installed\n        if auth_mech != \"kerberos\":\n            log.debug(\"GSSAPI is available, determine what mechanism to use \"\n                      \"as auth backend\")\n            mechs_available = GSSAPIContext.get_mechs_available()\n\n        log.debug(\"GSSAPI mechs available: %s\" % \", \".join(mechs_available))\n        if auth_mech in mechs_available or auth_mech == \"kerberos\":\n            log.debug(\"GSSAPI with mech %s is being used as auth backend\"\n                      % auth_mech)\n            context = GSSAPIContext(hostname, username, password, auth_mech)\n        elif auth_mech == \"ntlm\":\n            log.debug(\"GSSAPI is available but does not support NTLM, using \"\n                      \"ntlm-auth as auth backend instead\")\n            context = NTLMContext(username, password)\n        else:\n            # make sure we can actually initialise a GSSAPI context in auto,\n            # otherwise fallback to NTLMContext if that fails\n            # we need to explicitly set auth_mech as kerberos if the GSSAPI\n            # implementation does not support NTLM so we know to use NTLM if\n            # GSSAPI fails\n            try:\n                log.debug(\"Attempting to use GSSAPI Kerberos as auth backend\")\n                context = GSSAPIContext(hostname, username, password,\n                                        \"kerberos\")\n                context.init_context()\n                context_gen = context.step()\n                out_token = next(context_gen)\n                context_init = True\n                log.info(\"GSSAPI with mech kerberos is being used as auth \"\n                         \"backend\")\n            except gssapi.exceptions.GSSError as err:\n                log.warning(\"Failed to initialise GSSAPI context, falling \"\n                            \"back to NTLM: %s\" % str(err))\n                context = NTLMContext(username, password)\n    else:\n        log.debug(\"SSPI or GSSAPI is not available, using ntlm-auth as auth \"\n                  \"backend\")\n        if auth_mech == \"kerberos\":\n            raise InvalidConfigurationException(\"The auth_mechanism is set \"\n                                                \"to kerberos but SSPI or \"\n                                                \"GSSAPI is not available\")\n        context = NTLMContext(username, password)\n\n    # we only init the context when HAS_GSSAPI and it doesn't natively offer\n    # SPNEGO that works with Windows, so let's init it here\n    if not context_init:\n        context.init_context()\n        context_gen = context.step()\n        out_token = next(context_gen)\n\n    return context, context_gen, out_token", "response": "This function returns an AuthContext used in the CredSSP authentication process and the AuthContext generator used in the CredSSP authentication process."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of auth mechanisms that are available to the local one.", "response": "def get_mechs_available():\n        \"\"\"\n        Returns a list of auth mechanisms that are available to the local\n        GSSAPI instance. Because we are interacting with Windows, we only\n        care if SPNEGO, Kerberos and NTLM are available where NTLM is the\n        only wildcard that may not be available by default.\n\n        The only NTLM implementation that works properly is gss-ntlmssp and\n        part of this test is to verify the gss-ntlmssp OID\n        GSS_NTLMSSP_RESET_CRYPTO_OID_LENGTH is implemented which is required\n        for SPNEGO and NTLM to work properly.\n\n        :return: list - A list of supported mechs available in the installed\n            version of GSSAPI\n        \"\"\"\n        ntlm_oid = GSSAPIContext._AUTH_MECHANISMS['ntlm']\n        ntlm_mech = gssapi.OID.from_int_seq(ntlm_oid)\n        # GSS_NTLMSSP_RESET_CRYPTO_OID_LENGTH\n        # github.com/simo5/gss-ntlmssp/blob/master/src/gssapi_ntlmssp.h#L68\n        reset_mech = gssapi.OID.from_int_seq(\"1.3.6.1.4.1.7165.655.1.3\")\n\n        try:\n            # we don't actually care about the account used here so just use\n            # a random username and password\n            ntlm_context = GSSAPIContext._get_security_context(\n                gssapi.NameType.user,\n                ntlm_mech,\n                \"http@server\",\n                \"username\",\n                \"password\"\n            )\n            ntlm_context.step()\n            set_sec_context_option(reset_mech, context=ntlm_context,\n                                   value=b\"\\x00\" * 4)\n        except gssapi.exceptions.GSSError as exc:\n            # failed to init NTLM and verify gss-ntlmssp is available, this\n            # means NTLM is either not available or won't work\n            # (not gss-ntlmssp) so we return kerberos as the only available\n            # mechanism for the GSSAPI Context\n            log.debug(\"Failed to init test NTLM context with GSSAPI: %s\"\n                      % str(exc))\n            return ['kerberos']\n        else:\n            return ['auto', 'kerberos', 'ntlm']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef credssp_generator(self):\n        log.debug(\"Starting TLS handshake process\")\n        self.tls_connection = SSL.Connection(self.tls_context)\n        self.tls_connection.set_connect_state()\n\n        while True:\n            try:\n                self.tls_connection.do_handshake()\n            except SSL.WantReadError:\n                out_token = self.tls_connection.bio_read(self.BIO_BUFFER_SIZE)\n                log.debug(\"Step 1. TLS Handshake, returning token: %s\"\n                          % binascii.hexlify(out_token))\n                in_token = yield out_token, \"Step 1. TLS Handshake\"\n                log.debug(\"Step 1. TLS Handshake, received token: %s\"\n                          % binascii.hexlify(in_token))\n                self.tls_connection.bio_write(in_token)\n            else:\n                break\n        log.debug(\"TLS Handshake complete. Protocol: %s, Cipher: %s\"\n                  % (self.tls_connection.get_protocol_version_name(),\n                     self.tls_connection.get_cipher_name()))\n\n        server_certificate = self.tls_connection.get_peer_certificate()\n        server_public_key = self._get_subject_public_key(server_certificate)\n\n        log.debug(\"Starting Authentication process\")\n        version = 6\n        context, auth_step, out_token = get_auth_context(self.hostname,\n                                                         self.username,\n                                                         self.password,\n                                                         self.auth_mechanism)\n        while not context.complete:\n            nego_token = NegoToken()\n            nego_token['negoToken'] = out_token\n\n            ts_request = TSRequest()\n            ts_request['negoTokens'].append(nego_token)\n\n            ts_request_token = encoder.encode(ts_request)\n            log.debug(\"Step 2. Authenticate, returning token: %s\"\n                      % binascii.hexlify(ts_request_token))\n            in_token = yield self.wrap(ts_request_token), \\\n                \"Step 2. Authenticate\"\n            in_token = self.unwrap(in_token)\n            log.debug(\"Step 3. Authenticate, received token: %s\"\n                      % binascii.hexlify(in_token))\n\n            ts_request = decoder.decode(in_token, asn1Spec=TSRequest())[0]\n            ts_request.check_error_code()\n            version = int(ts_request['version'])\n            out_token = \\\n                auth_step.send(bytes(ts_request['negoTokens'][0]['negoToken']))\n\n        version = min(version, TSRequest.CLIENT_VERSION)\n        log.debug(\"Starting public key verification process at version %d\"\n                  % version)\n        if version < self.minimum_version:\n            raise AuthenticationException(\"The reported server version was %d \"\n                                          \"and did not meet the minimum \"\n                                          \"requirements of %d\"\n                                          % (version, self.minimum_version))\n        if version > 4:\n            nonce = os.urandom(32)\n        else:\n            log.warning(\"Reported server version was %d, susceptible to MitM \"\n                        \"attacks and should be patched - CVE 2018-0886\"\n                        % version)\n            nonce = None\n\n        pub_key_auth = self._build_pub_key_auth(context, nonce,\n                                                out_token,\n                                                server_public_key)\n        log.debug(\"Step 3. Server Authentication, returning token: %s\"\n                  % binascii.hexlify(pub_key_auth))\n        in_token = yield (self.wrap(pub_key_auth),\n                          \"Step 3. Server Authentication\")\n        in_token = self.unwrap(in_token)\n        log.debug(\"Step 3. Server Authentication, received token: %s\"\n                  % binascii.hexlify(in_token))\n\n        log.debug(\"Starting server public key response verification\")\n        ts_request = decoder.decode(in_token, asn1Spec=TSRequest())[0]\n        ts_request.check_error_code()\n        if not ts_request['pubKeyAuth'].isValue:\n            raise AuthenticationException(\"The server did not response with \"\n                                          \"pubKeyAuth info, authentication \"\n                                          \"was rejected\")\n        if len(ts_request['negoTokens']) > 0:\n            # SPNEGO auth returned the mechListMIC for us to verify\n            auth_step.send(bytes(ts_request['negoTokens'][0]['negoToken']))\n\n        response_key = context.unwrap(bytes(ts_request['pubKeyAuth']))\n        self._verify_public_keys(nonce, response_key, server_public_key)\n\n        log.debug(\"Sending encrypted credentials\")\n        enc_credentials = self._get_encrypted_credentials(context)\n\n        yield self.wrap(enc_credentials), \"Step 5. Delegate Credentials\"", "response": "Generator function that yields each CredSSP token sent to the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_pub_key_auth(self, context, nonce, auth_token, public_key):\n        ts_request = TSRequest()\n\n        if auth_token is not None:\n            nego_token = NegoToken()\n            nego_token['negoToken'] = auth_token\n            ts_request['negoTokens'].append(nego_token)\n\n        if nonce is not None:\n            ts_request['clientNonce'] = nonce\n            hash_input = b\"CredSSP Client-To-Server Binding Hash\\x00\" + \\\n                         nonce + public_key\n            pub_value = hashlib.sha256(hash_input).digest()\n        else:\n            pub_value = public_key\n\n        enc_public_key = context.wrap(pub_value)\n        ts_request['pubKeyAuth'] = enc_public_key\n\n        return encoder.encode(ts_request)", "response": "Builds the Pubkey Auth field for the protocol version 2. 5 and 6. 5 +."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _verify_public_keys(self, nonce, server_key, public_key):\n        if nonce is not None:\n            hash_input = b\"CredSSP Server-To-Client Binding Hash\\x00\" + nonce \\\n                         + public_key\n            actual = hashlib.sha256(hash_input).digest()\n            expected = server_key\n        else:\n            first_byte = struct.unpack(\"B\", server_key[0:1])[0]\n            actual_first_byte = struct.pack(\"B\", first_byte - 1)\n\n            actual = actual_first_byte + server_key[1:]\n            expected = public_key\n\n        if actual != expected:\n            raise AuthenticationException(\"Could not verify key sent from the \"\n                                          \"server, potential man in the \"\n                                          \"middle attack\")", "response": "This method verifies the public key received from the server and the server_key field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_encrypted_credentials(self, context):\n        ts_password = TSPasswordCreds()\n        ts_password['domainName'] = context.domain.encode('utf-16-le')\n        ts_password['userName'] = context.username.encode('utf-16-le')\n        ts_password['password'] = context.password.encode('utf-16-le')\n\n        ts_credentials = TSCredentials()\n        ts_credentials['credType'] = ts_password.CRED_TYPE\n        ts_credentials['credentials'] = encoder.encode(ts_password)\n\n        ts_request = TSRequest()\n        enc_credentials = context.wrap(encoder.encode(ts_credentials))\n        ts_request['authInfo'] = enc_credentials\n\n        return encoder.encode(ts_request)", "response": "This method encrypts the user s credentials with the authentication protocol s encryption protocol s encryption\n        services and returns the encrypted TSRequest that contains the user s credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap(self, data):\n        length = self.tls_connection.send(data)\n        encrypted_data = b''\n        counter = 0\n\n        while True:\n            try:\n                encrypted_chunk = \\\n                    self.tls_connection.bio_read(self.BIO_BUFFER_SIZE)\n            except SSL.WantReadError:\n                break\n            encrypted_data += encrypted_chunk\n\n            # in case of a borked TLS connection, break the loop if the current\n            # buffer counter is > the length of the original message plus the\n            # the size of the buffer (to be careful)\n            counter += self.BIO_BUFFER_SIZE\n            if counter > length + self.BIO_BUFFER_SIZE:\n                break\n\n        return encrypted_data", "response": "Encrypts the data in preparation for sending to the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unwrap(self, encrypted_data):\n        length = self.tls_connection.bio_write(encrypted_data)\n        data = b''\n        counter = 0\n\n        while True:\n            try:\n                data_chunk = self.tls_connection.recv(self.BIO_BUFFER_SIZE)\n            except SSL.WantReadError:\n                break\n            data += data_chunk\n\n            counter += self.BIO_BUFFER_SIZE\n            if counter > length:\n                break\n\n        return data", "response": "Decrypts the data sent by the client and the server using the TLS channel negotiated\n        between the client and the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_subject_public_key(cert):\n        public_key = cert.get_pubkey()\n        cryptographic_key = public_key.to_cryptography_key()\n        subject_public_key = cryptographic_key.public_bytes(Encoding.DER,\n                                                            PublicFormat.PKCS1)\n        return subject_public_key", "response": "Returns the SubjectPublicKey asn. 1 field of the SubjectPublicKeyInfo\n        field of the server s certificate. This is used in the serverMacroCertificate verification steps to thwart MitM attacks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnavigate to the KCR homepage page.", "response": "def _to_reader_home(self):\n    \"\"\"Navigate to the Cloud Reader library page.\n\n    Raises:\n      BrowserError: If the KCR homepage could not be loaded.\n      ConnectionError: If there was a connection error.\n    \"\"\"\n    # NOTE: Prevents QueryInterface error caused by getting a URL\n    # while switched to an iframe\n    self.switch_to_default_content()\n    self.get(_KindleCloudReaderBrowser._CLOUD_READER_URL)\n\n    if self.title == u'Problem loading page':\n      raise ConnectionError\n\n    # Wait for either the login page or the reader to load\n    login_or_reader_loaded = lambda br: (\n        br.find_elements_by_id('amzn_kcr') or\n        br.find_elements_by_id('KindleLibraryIFrame'))\n    self._wait(5).until(login_or_reader_loaded)\n\n    try:\n      self._wait(5).until(lambda br: br.title == u'Amazon.com Sign In')\n    except TimeoutException:\n      raise BrowserError('Failed to load Kindle Cloud Reader.')\n    else:\n      self._login()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _login(self, max_tries=2):\n\n    if not self.current_url.startswith(_KindleCloudReaderBrowser._SIGNIN_URL):\n      raise BrowserError(\n          'Current url \"%s\" is not a signin url (\"%s\")' %\n          (self.current_url, _KindleCloudReaderBrowser._SIGNIN_URL))\n\n    email_field_loaded = lambda br: br.find_elements_by_id('ap_email')\n    self._wait().until(email_field_loaded)\n    tries = 0\n    while tries < max_tries:\n      # Enter the username\n      email_elem = self.find_element_by_id('ap_email')\n      email_elem.clear()\n      email_elem.send_keys(self._uname)\n\n      # Enter the password\n      pword_elem = self.find_element_by_id('ap_password')\n      pword_elem.clear()\n      pword_elem.send_keys(self._pword)\n\n      def creds_entered(_):\n        \"\"\"Returns whether the credentials were properly entered.\"\"\"\n\n        email_ok = email_elem.get_attribute('value') == self._uname\n        pword_ok = pword_elem.get_attribute('value') == self._pword\n        return email_ok and pword_ok\n\n      kcr_page_loaded = lambda br: br.title == u'Kindle Cloud Reader'\n      try:\n        self._wait(5).until(creds_entered)\n        self.find_element_by_id('signInSubmit-input').click()\n        self._wait(5).until(kcr_page_loaded)\n      except TimeoutException:\n        tries += 1\n      else:\n        return\n\n    raise LoginError", "response": "Logs in to Kindle Cloud Reader."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _to_reader_frame(self):\n\n    reader_frame = 'KindleReaderIFrame'\n    frame_loaded = lambda br: br.find_elements_by_id(reader_frame)\n    self._wait().until(frame_loaded)\n\n    self.switch_to.frame(reader_frame)  # pylint: disable=no-member\n\n    reader_loaded = lambda br: br.find_elements_by_id('kindleReader_header')\n    self._wait().until(reader_loaded)", "response": "Navigate to the KindleReader iframe."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits for the Kindle Cloud Reader JS modules to initialize.", "response": "def _wait_for_js(self):\n    \"\"\"Wait for the Kindle Cloud Reader JS modules to initialize.\n\n    These modules provide the interface used to execute API queries.\n    \"\"\"\n    # Wait for the Module Manager to load\n    mod_mgr_script = ur\"return window.hasOwnProperty('KindleModuleManager');\"\n    mod_mgr_loaded = lambda br: br.execute_script(mod_mgr_script)\n    self._wait(5).until(mod_mgr_loaded)\n\n    # Wait for the DB Client to load\n    db_client_script = dedent(ur\"\"\"\n        var done = arguments[0];\n        if (!window.hasOwnProperty('KindleModuleManager') ||\n            !KindleModuleManager\n                .isModuleInitialized(Kindle.MODULE.DB_CLIENT)) {\n           done(false);\n        } else {\n            KindleModuleManager\n                .getModuleSync(Kindle.MODULE.DB_CLIENT)\n                .getAppDb()\n                .getAllBooks()\n                .done(function(books) { done(!!books.length); });\n        }\n        \"\"\")\n    db_client_loaded = lambda br: br.execute_async_script(db_client_script)\n    self._wait(5).until(db_client_loaded)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning an API call with javascript - formatted arguments.", "response": "def _get_api_call(self, function_name, *args):\n    \"\"\"Runs an api call with javascript-formatted arguments.\n\n    Args:\n      function_name: The name of the KindleAPI call to run.\n      *args: Javascript-formatted arguments to pass to the API call.\n\n    Returns:\n      The result of the API call.\n\n    Raises:\n      APIError: If the API call fails or times out.\n    \"\"\"\n    api_call = dedent(\"\"\"\n        var done = arguments[0];\n        KindleAPI.%(api_call)s(%(args)s).always(function(a) {\n            done(a);\n        });\n    \"\"\") % {\n        'api_call': function_name,\n        'args': ', '.join(args)\n    }\n    script = '\\n'.join((api.API_SCRIPT, api_call))\n    try:\n      return self._browser.execute_async_script(script)\n    except TimeoutException:\n      # FIXME: KCR will occassionally not load library and fall over\n      raise APIError"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_book_metadata(self, asin):\n    kbm = self._get_api_call('get_book_metadata', '\"%s\"' % asin)\n    return KindleCloudReaderAPI._kbm_to_book(kbm)", "response": "Returns a book s metadata."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_book_progress(self, asin):\n    kbp = self._get_api_call('get_book_progress', '\"%s\"' % asin)\n    return KindleCloudReaderAPI._kbp_to_progress(kbp)", "response": "Returns the progress data available for a book."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the reading progress for all books in the current user s kindle library.", "response": "def get_library_progress(self):\n    \"\"\"Returns the reading progress for all books in the kindle library.\n\n    Returns:\n      A mapping of ASINs to `ReadingProgress` instances corresponding to the\n      books in the current user's library.\n    \"\"\"\n    kbp_dict = self._get_api_call('get_library_progress')\n    return {asin: KindleCloudReaderAPI._kbp_to_progress(kbp)\n            for asin, kbp in kbp_dict.iteritems()}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_instance(*args, **kwargs):\n\n    inst = KindleCloudReaderAPI(*args, **kwargs)\n    try:\n      yield inst\n    except Exception:\n      raise\n    finally:\n      inst.close()", "response": "Context manager for an instance of KindleCloudReaderAPI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_config(path):\n    path = os.path.abspath(path)\n    if os.path.isdir(path):\n        config, wordlists = _load_data(path)\n    elif os.path.isfile(path):\n        config = _load_config(path)\n        wordlists = {}\n    else:\n        raise InitializationError('File or directory not found: {0}'.format(path))\n    for name, wordlist in wordlists.items():\n        if name in config:\n            raise InitializationError(\"Conflict: list {!r} is defined both in config \"\n                                      \"and in *.txt file. If it's a {!r} list, \"\n                                      \"you should remove it from config.\"\n                                      .format(name, _CONF.TYPE.WORDS))\n        config[name] = wordlist\n    return config", "response": "Loads a configuration from a file or directory containing config. json or zero or more *. txt files with word lists or phrase lists."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading data from a directory.", "response": "def _load_data(path):\n    \"\"\"\n    Loads data from a directory.\n    Returns tuple (config_dict, wordlists).\n    Raises Exception on failure (e.g. if data is corrupted).\n    \"\"\"\n    path = os.path.abspath(path)\n    if not os.path.isdir(path):\n        raise InitializationError('Directory not found: {0}'.format(path))\n    wordlists = {}\n    for file_name in os.listdir(path):\n        if os.path.splitext(file_name)[1] != '.txt':\n            continue\n        file_path = os.path.join(path, file_name)\n        name = os.path.splitext(os.path.split(file_path)[1])[0]\n        try:\n            with codecs.open(file_path, encoding='utf-8') as file:\n                wordlists[name] = _load_wordlist(name, file)\n        except OSError as ex:\n            raise InitializationError('Failed to read {}: {}'.format(file_path, ex))\n    config = _load_config(os.path.join(path, 'config.json'))\n    return (config, wordlists)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a line of text into a key - value pair.", "response": "def _parse_option(line):\n    \"\"\"\n    Parses option line.\n    Returns (name, value).\n    Raises ValueError on invalid syntax or unknown option.\n    \"\"\"\n    match = _OPTION_REGEX.match(line)\n    if not match:\n        raise ValueError('Invalid syntax')\n    for name, type_ in _OPTIONS:\n        if name == match.group(1):\n            return name, type_(match.group(2))\n    raise ValueError('Unknown option')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_wordlist(name, stream):\n    items = []\n    max_length = None\n    multiword = False\n    multiword_start = None\n    number_of_words = None\n    for i, line in enumerate(stream, start=1):\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        # Is it an option line, e.g. 'max_length = 10'?\n        if '=' in line:\n            if items:\n                raise ConfigurationError('Invalid assignment at list {!r} line {}: {!r} '\n                                         '(options must be defined before words)'\n                                         .format(name, i, line))\n            try:\n                option, option_value = _parse_option(line)\n            except ValueError as ex:\n                raise ConfigurationError('Invalid assignment at list {!r} line {}: {!r} '\n                                         '({})'\n                                         .format(name, i, line, ex))\n            if option == _CONF.FIELD.MAX_LENGTH:\n                max_length = option_value\n            elif option == _CONF.FIELD.NUMBER_OF_WORDS:\n                number_of_words = option_value\n            continue  # pragma: no cover\n        # Parse words\n        if not multiword and _WORD_REGEX.match(line):\n            if max_length is not None and len(line) > max_length:\n                raise ConfigurationError('Word is too long at list {!r} line {}: {!r}'\n                                         .format(name, i, line))\n            items.append(line)\n        elif _PHRASE_REGEX.match(line):\n            if not multiword:\n                multiword = True\n                multiword_start = len(items)\n            phrase = tuple(line.split(' '))\n            if number_of_words is not None and len(phrase) != number_of_words:\n                raise ConfigurationError('Phrase has {} word(s) (while number_of_words={}) '\n                                         'at list {!r} line {}: {!r}'\n                                         .format(len(phrase), number_of_words, name, i, line))\n            if max_length is not None and sum(len(x) for x in phrase) > max_length:\n                raise ConfigurationError('Phrase is too long at list {!r} line {}: {!r}'\n                                         .format(name, i, line))\n            items.append(phrase)\n        else:\n            raise ConfigurationError('Invalid syntax at list {!r} line {}: {!r}'\n                                     .format(name, i, line))\n    if multiword:\n        # If in phrase mode, convert everything to tuples\n        for i in range(0, multiword_start):\n            items[i] = (items[i], )\n        result = {\n            _CONF.FIELD.TYPE: _CONF.TYPE.PHRASES,\n            _CONF.FIELD.PHRASES: items\n        }\n        if number_of_words is not None:\n            result[_CONF.FIELD.NUMBER_OF_WORDS] = number_of_words\n    else:\n        result = {\n            _CONF.FIELD.TYPE: _CONF.TYPE.WORDS,\n            _CONF.FIELD.WORDS: items\n        }\n    if max_length is not None:\n        result[_CONF.FIELD.MAX_LENGTH] = max_length\n    return result", "response": "Loads a list of words or phrases from a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate_config(config):\n    try:\n        referenced_sublists = set()\n        for key, listdef in list(config.items()):\n            # Check if section is a list\n            if not isinstance(listdef, dict):\n                raise ValueError('Value at key {!r} is not a dict'\n                                 .format(key))\n            # Check if it has correct type\n            if _CONF.FIELD.TYPE not in listdef:\n                raise ValueError('Config at key {!r} has no {!r}'\n                                 .format(key, _CONF.FIELD.TYPE))\n            # Nested or Cartesian\n            if listdef[_CONF.FIELD.TYPE] in (_CONF.TYPE.NESTED, _CONF.TYPE.CARTESIAN):\n                sublists = listdef.get(_CONF.FIELD.LISTS)\n                if sublists is None:\n                    raise ValueError('Config at key {!r} has no {!r}'\n                                     .format(key, _CONF.FIELD.LISTS))\n                if (not isinstance(sublists, list) or not sublists or\n                        not all(_is_str(x) for x in sublists)):\n                    raise ValueError('Config at key {!r} has invalid {!r}'\n                                     .format(key, _CONF.FIELD.LISTS))\n                referenced_sublists.update(sublists)\n            # Const\n            elif listdef[_CONF.FIELD.TYPE] == _CONF.TYPE.CONST:\n                try:\n                    value = listdef[_CONF.FIELD.VALUE]\n                except KeyError:\n                    raise ValueError('Config at key {!r} has no {!r}'\n                                     .format(key, _CONF.FIELD.VALUE))\n                if not _is_str(value):\n                    raise ValueError('Config at key {!r} has invalid {!r}'\n                                     .format(key, _CONF.FIELD.VALUE))\n            # Words\n            elif listdef[_CONF.FIELD.TYPE] == _CONF.TYPE.WORDS:\n                try:\n                    words = listdef[_CONF.FIELD.WORDS]\n                except KeyError:\n                    raise ValueError('Config at key {!r} has no {!r}'\n                                     .format(key, _CONF.FIELD.WORDS))\n                if not isinstance(words, list) or not words:\n                    raise ValueError('Config at key {!r} has invalid {!r}'\n                                     .format(key, _CONF.FIELD.WORDS))\n                # Validate word length\n                try:\n                    max_length = int(listdef[_CONF.FIELD.MAX_LENGTH])\n                except KeyError:\n                    max_length = None\n                if max_length is not None:\n                    for word in words:\n                        if len(word) > max_length:\n                            raise ValueError('Config at key {!r} has invalid word {!r} '\n                                             '(longer than {} characters)'\n                                             .format(key, word, max_length))\n            # Phrases (sequences of one or more words)\n            elif listdef[_CONF.FIELD.TYPE] == _CONF.TYPE.PHRASES:\n                try:\n                    phrases = listdef[_CONF.FIELD.PHRASES]\n                except KeyError:\n                    raise ValueError('Config at key {!r} has no {!r}'\n                                     .format(key, _CONF.FIELD.PHRASES))\n                if not isinstance(phrases, list) or not phrases:\n                    raise ValueError('Config at key {!r} has invalid {!r}'\n                                     .format(key, _CONF.FIELD.PHRASES))\n                # Validate multi-word and max length\n                try:\n                    number_of_words = int(listdef[_CONF.FIELD.NUMBER_OF_WORDS])\n                except KeyError:\n                    number_of_words = None\n                try:\n                    max_length = int(listdef[_CONF.FIELD.MAX_LENGTH])\n                except KeyError:\n                    max_length = None\n                for phrase in phrases:\n                    phrase = _split_phrase(phrase)  # str -> sequence, if necessary\n                    if not isinstance(phrase, (tuple, list)) or not all(isinstance(x, _str_types) for x in phrase):\n                        raise ValueError('Config at key {!r} has invalid {!r}: '\n                                         'must be all string/tuple/list'\n                                         .format(key, _CONF.FIELD.PHRASES))\n                    if number_of_words is not None and len(phrase) != number_of_words:\n                        raise ValueError('Config at key {!r} has invalid phrase {!r} '\n                                         '({} word(s) but {}={})'\n                                         .format(key, ' '.join(phrase),\n                                                 len(phrase), _CONF.FIELD.NUMBER_OF_WORDS, number_of_words))\n                    if max_length is not None and sum(len(word) for word in phrase) > max_length:\n                        raise ValueError('Config at key {!r} has invalid phrase {!r} '\n                                         '(longer than {} characters)'\n                                         .format(key, ' '.join(phrase), max_length))\n            else:\n                raise ValueError('Config at key {!r} has invalid {!r}'\n                                 .format(key, _CONF.FIELD.TYPE))\n        # Check that all sublists are defined\n        diff = referenced_sublists.difference(config.keys())\n        if diff:\n            raise ValueError('Lists are referenced but not defined: {}'\n                             .format(', '.join(sorted(diff)[:10])))\n    except (KeyError, ValueError) as ex:\n        raise ConfigurationError(str(ex))", "response": "Validate the config and return a set of all the relevant resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a tree of lists for the current rule.", "response": "def _create_lists(config, results, current, stack, inside_cartesian=None):\n    \"\"\"\n    An ugly recursive method to transform config dict\n    into a tree of AbstractNestedList.\n    \"\"\"\n    # Have we done it already?\n    try:\n        return results[current]\n    except KeyError:\n        pass\n    # Check recursion depth and detect loops\n    if current in stack:\n        raise ConfigurationError('Rule {!r} is recursive: {!r}'.format(stack[0], stack))\n    if len(stack) > 99:\n        raise ConfigurationError('Rule {!r} is too deep'.format(stack[0]))\n    # Track recursion depth\n    stack.append(current)\n    try:\n        # Check what kind of list we have\n        listdef = config[current]\n        list_type = listdef[_CONF.FIELD.TYPE]\n        # 1. List of words\n        if list_type == _CONF.TYPE.WORDS:\n            results[current] = WordList(listdef['words'])\n        # List of phrases\n        elif list_type == _CONF.TYPE.PHRASES:\n            results[current] = PhraseList(listdef['phrases'])\n        # 2. Simple list of lists\n        elif list_type == _CONF.TYPE.NESTED:\n            results[current] = NestedList([_create_lists(config, results, x, stack,\n                                                         inside_cartesian=inside_cartesian)\n                                           for x in listdef[_CONF.FIELD.LISTS]])\n\n        # 3. Cartesian list of lists\n        elif list_type == _CONF.TYPE.CARTESIAN:\n            if inside_cartesian is not None:\n                raise ConfigurationError(\"Cartesian list {!r} contains another Cartesian list \"\n                                         \"{!r}. Nested Cartesian lists are not allowed.\"\n                                         .format(inside_cartesian, current))\n            results[current] = CartesianList([_create_lists(config, results, x, stack,\n                                                            inside_cartesian=current)\n                                              for x in listdef[_CONF.FIELD.LISTS]])\n        # 4. Scalar\n        elif list_type == _CONF.TYPE.CONST:\n            results[current] = Scalar(listdef[_CONF.FIELD.VALUE])\n        # Unknown type\n        else:\n            raise InitializationError(\"Unknown list type: {!r}\".format(list_type))\n        # Return the result\n        return results[current]\n    finally:\n        stack.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate(self, pattern=None):\n        lst = self._lists[pattern]\n        while True:\n            result = lst[self._randrange(lst.length)]\n            # 1. Check that there are no duplicates\n            # 2. Check that there are no duplicate prefixes\n            # 3. Check max slug length\n            n = len(result)\n            if (self._ensure_unique and len(set(result)) != n or\n                    self._check_prefix and len(set(x[:self._check_prefix] for x in result)) != n or\n                    self._max_slug_length and sum(len(x) for x in result) + n - 1 > self._max_slug_length):\n                continue\n            return result", "response": "Generates and returns random name as a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dump(self, stream, pattern=None, object_ids=False):\n        return self._lists[pattern]._dump(stream, '', object_ids=object_ids)", "response": "Dumps the current tree into a text stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking that the generator is not hanging.", "response": "def _check_not_hanging(self):\n        \"\"\"\n        Rough check that generate() will not hang or be very slow.\n\n        Raises ConfigurationError if generate() spends too much time in retry loop.\n        Issues a warning.warn() if there is a risk of slowdown.\n        \"\"\"\n        # (field_name, predicate, warning_msg, exception_msg)\n        # predicate(g) is a function that returns True if generated combination g must be rejected,\n        # see checks in generate()\n        checks = []\n        # ensure_unique can lead to infinite loops for some tiny erroneous configs\n        if self._ensure_unique:\n            checks.append((\n                _CONF.FIELD.ENSURE_UNIQUE,\n                self._ensure_unique,\n                lambda g: len(set(g)) != len(g),\n                '{generate} may be slow because a significant fraction of combinations contain repeating words and {field_name} is set',  # noqa\n                'Impossible to generate with {field_name}'\n            ))\n        #\n        # max_slug_length can easily slow down or block generation if set too small\n        if self._max_slug_length:\n            checks.append((\n                _CONF.FIELD.MAX_SLUG_LENGTH,\n                self._max_slug_length,\n                lambda g: sum(len(x) for x in g) + len(g) - 1 > self._max_slug_length,\n                '{generate} may be slow because a significant fraction of combinations exceed {field_name}={field_value}',  # noqa\n                'Impossible to generate with {field_name}={field_value}'\n            ))\n        # Perform the relevant checks for all generators, starting from 'all'\n        n = 100\n        warning_treshold = 20  # fail probability: 0.04 for 2 attempts, 0.008 for 3 attempts, etc.\n        for lst_id, lst in sorted(self._lists.items(), key=lambda x: '' if x is None else str(x)):\n            context = {'generate': 'coolname.generate({})'.format('' if lst_id is None else repr(lst_id))}\n            # For each generator, perform checks\n            for field_name, field_value, predicate, warning_msg, exception_msg in checks:\n                context.update({'field_name': field_name, 'field_value': field_value})\n                bad_count = 0\n                for i in range(n):\n                    g = lst[randrange(lst.length)]\n                    if predicate(g):\n                        bad_count += 1\n                if bad_count >= n:\n                    raise ConfigurationError(exception_msg.format(**context))\n                elif bad_count >= warning_treshold:\n                    import warnings\n                    warnings.warn(warning_msg.format(**context))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun given callable against given table and given column in activity table.", "response": "def alter_column(conn, table, column_name, func, schema=None):\n    \"\"\"\n    Run given callable against given table and given column in activity table\n    jsonb data columns. This function is useful when you want to reflect type\n    changes in your schema to activity table.\n\n    In the following example we change the data type of User's age column from\n    string to integer.\n\n\n    ::\n\n        from alembic import op\n        from postgresql_audit import alter_column\n\n\n        def upgrade():\n            op.alter_column(\n                'user',\n                'age',\n                type_=sa.Integer\n            )\n\n            alter_column(\n                op,\n                'user',\n                'age',\n                lambda value, activity_table: sa.cast(value, sa.Integer)\n            )\n\n\n    :param conn:\n        An object that is able to execute SQL (either SQLAlchemy Connection,\n        Engine or Alembic Operations object)\n    :param table:\n        The table to run the column name changes against\n    :param column_name:\n        Name of the column to run callable against\n    :param func:\n        A callable to run against specific column in activity table jsonb data\n        columns. The callable should take two parameters the jsonb value\n        corresponding to given column_name and activity table object.\n    :param schema:\n        Optional name of schema to use.\n    \"\"\"\n    activity_table = get_activity_table(schema=schema)\n    query = (\n        activity_table\n        .update()\n        .values(\n            old_data=(\n                activity_table.c.old_data +\n                sa.cast(sa.func.json_build_object(\n                    column_name,\n                    func(\n                        activity_table.c.old_data[column_name],\n                        activity_table\n                    )\n                ), JSONB)\n            ),\n            changed_data=(\n                activity_table.c.changed_data +\n                sa.cast(sa.func.json_build_object(\n                    column_name,\n                    func(\n                        activity_table.c.changed_data[column_name],\n                        activity_table\n                    )\n                ), JSONB)\n            )\n        )\n        .where(activity_table.c.table_name == table)\n    )\n    return conn.execute(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_column_name(\n    conn,\n    table,\n    old_column_name,\n    new_column_name,\n    schema=None\n):\n    \"\"\"\n    Changes given `activity` jsonb data column key. This function is useful\n    when you want to reflect column name changes to activity table.\n\n    ::\n\n        from alembic import op\n        from postgresql_audit import change_column_name\n\n\n        def upgrade():\n            op.alter_column(\n                'my_table',\n                'my_column',\n                new_column_name='some_column'\n            )\n\n            change_column_name(op, 'my_table', 'my_column', 'some_column')\n\n\n    :param conn:\n        An object that is able to execute SQL (either SQLAlchemy Connection,\n        Engine or Alembic Operations object)\n    :param table:\n        The table to run the column name changes against\n    :param old_column_name:\n        Name of the column to change\n    :param new_column_name:\n        New colum name\n    :param schema:\n        Optional name of schema to use.\n    \"\"\"\n    activity_table = get_activity_table(schema=schema)\n    query = (\n        activity_table\n        .update()\n        .values(\n            old_data=jsonb_change_key_name(\n                activity_table.c.old_data,\n                old_column_name,\n                new_column_name\n            ),\n            changed_data=jsonb_change_key_name(\n                activity_table.c.changed_data,\n                old_column_name,\n                new_column_name\n            )\n        )\n        .where(activity_table.c.table_name == table)\n    )\n    return conn.execute(query)", "response": "Changes the name of a column in an existing activity table."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds given column to the activity table jsonb data columns.", "response": "def add_column(conn, table, column_name, default_value=None, schema=None):\n    \"\"\"\n    Adds given column to `activity` table jsonb data columns.\n\n    In the following example we reflect the changes made to our schema to\n    activity table.\n\n    ::\n\n        import sqlalchemy as sa\n        from alembic import op\n        from postgresql_audit import add_column\n\n\n        def upgrade():\n            op.add_column('article', sa.Column('created_at', sa.DateTime()))\n            add_column(op, 'article', 'created_at')\n\n\n    :param conn:\n        An object that is able to execute SQL (either SQLAlchemy Connection,\n        Engine or Alembic Operations object)\n    :param table:\n        The table to remove the column from\n    :param column_name:\n        Name of the column to add\n    :param default_value:\n        The default value of the column\n    :param schema:\n        Optional name of schema to use.\n    \"\"\"\n    activity_table = get_activity_table(schema=schema)\n    data = {column_name: default_value}\n    query = (\n        activity_table\n        .update()\n        .values(\n            old_data=sa.case(\n                [\n                    (\n                        sa.cast(activity_table.c.old_data, sa.Text) != '{}',\n                        activity_table.c.old_data + data\n                    ),\n                ],\n                else_=sa.cast({}, JSONB)\n            ),\n            changed_data=sa.case(\n                [\n                    (\n                        sa.and_(\n                            sa.cast(\n                                activity_table.c.changed_data,\n                                sa.Text\n                            ) != '{}',\n                            activity_table.c.verb != 'update'\n                        ),\n                        activity_table.c.changed_data + data\n                    )\n                ],\n                else_=activity_table.c.changed_data\n            ),\n        )\n        .where(activity_table.c.table_name == table)\n    )\n    return conn.execute(query)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove given column from the activity jsonb data table.", "response": "def remove_column(conn, table, column_name, schema=None):\n    \"\"\"\n    Removes given `activity` jsonb data column key. This function is useful\n    when you are doing schema changes that require removing a column.\n\n    Let's say you've been using PostgreSQL-Audit for a while for a table called\n    article. Now you want to remove one audited column called 'created_at' from\n    this table.\n\n    ::\n\n        from alembic import op\n        from postgresql_audit import remove_column\n\n\n        def upgrade():\n            op.remove_column('article', 'created_at')\n            remove_column(op, 'article', 'created_at')\n\n\n    :param conn:\n        An object that is able to execute SQL (either SQLAlchemy Connection,\n        Engine or Alembic Operations object)\n    :param table:\n        The table to remove the column from\n    :param column_name:\n        Name of the column to remove\n    :param schema:\n        Optional name of schema to use.\n    \"\"\"\n    activity_table = get_activity_table(schema=schema)\n    remove = sa.cast(column_name, sa.Text)\n    query = (\n        activity_table\n        .update()\n        .values(\n            old_data=activity_table.c.old_data - remove,\n            changed_data=activity_table.c.changed_data - remove,\n        )\n        .where(activity_table.c.table_name == table)\n    )\n    return conn.execute(query)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rename_table(conn, old_table_name, new_table_name, schema=None):\n    activity_table = get_activity_table(schema=schema)\n    query = (\n        activity_table\n        .update()\n        .values(table_name=new_table_name)\n        .where(activity_table.c.table_name == old_table_name)\n    )\n    return conn.execute(query)", "response": "Renames given table in activity table."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncollecting versioned class and add it to pending_classes list. :mapper mapper: SQLAlchemy mapper object :cls cls: SQLAlchemy declarative class", "response": "def instrument_versioned_classes(self, mapper, cls):\n        \"\"\"\n        Collect versioned class and add it to pending_classes list.\n\n        :mapper mapper: SQLAlchemy mapper object\n        :cls cls: SQLAlchemy declarative class\n        \"\"\"\n        if hasattr(cls, '__versioned__') and cls not in self.pending_classes:\n            self.pending_classes.add(cls)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfigure all versioned classes that were collected during instrumentation process.", "response": "def configure_versioned_classes(self):\n        \"\"\"\n        Configures all versioned classes that were collected during\n        instrumentation process.\n        \"\"\"\n        for cls in self.pending_classes:\n            self.audit_table(cls.__table__, cls.__versioned__.get('exclude'))\n        assign_actor(self.base, self.transaction_cls, self.actor_cls)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a citation via the command line using a PubMed ID or PubMed URL", "response": "def pubmed_citation(args=sys.argv[1:], out=sys.stdout):\n    \"\"\"Get a citation via the command line using a PubMed ID or PubMed URL\"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Get a citation using a PubMed ID or PubMed URL')\n    parser.add_argument('query', help='PubMed ID or PubMed URL')\n    parser.add_argument(\n        '-m', '--mini', action='store_true', help='get mini citation')\n    parser.add_argument(\n        '-e', '--email', action='store', help='set user email', default='')\n\n    args = parser.parse_args(args=args)\n\n    lookup = PubMedLookup(args.query, args.email)\n    publication = Publication(lookup, resolve_doi=False)\n\n    if args.mini:\n        out.write(publication.cite_mini() + '\\n')\n    else:\n        out.write(publication.cite() + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pubmed_url(args=sys.argv[1:], resolve_doi=True, out=sys.stdout):\n\n    parser = argparse.ArgumentParser(\n        description='Get a publication URL using a PubMed ID or PubMed URL')\n    parser.add_argument('query', help='PubMed ID or PubMed URL')\n    parser.add_argument(\n        '-d', '--doi', action='store_false', help='get DOI URL')\n    parser.add_argument(\n        '-e', '--email', action='store', help='set user email', default='')\n\n    args = parser.parse_args(args=args)\n\n    lookup = PubMedLookup(args.query, args.email)\n    publication = Publication(lookup, resolve_doi=args.doi)\n\n    out.write(publication.url + '\\n')", "response": "Get a publication URL via the command line using a PubMed ID or PubMed URL"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a truncated author list followed by et al.", "response": "def authors_et_al(self, max_authors=5):\n        \"\"\"\n        Return string with a truncated author list followed by 'et al.'\n        \"\"\"\n        author_list = self._author_list\n        if len(author_list) <= max_authors:\n            authors_et_al = self.authors\n        else:\n            authors_et_al = \", \".join(\n                self._author_list[:max_authors]) + \", et al.\"\n        return authors_et_al"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cite(self, max_authors=5):\n        citation_data = {\n            'title': self.title,\n            'authors': self.authors_et_al(max_authors),\n            'year': self.year,\n            'journal': self.journal,\n            'volume': self.volume,\n            'issue': self.issue,\n            'pages': self.pages,\n        }\n        citation = \"{authors} ({year}). {title} {journal}\".format(\n            **citation_data)\n\n        if self.volume and self.issue and self.pages:\n            citation += \" {volume}({issue}): {pages}.\".format(**citation_data)\n        elif self.volume and self.issue:\n            citation += \" {volume}({issue}).\".format(**citation_data)\n        elif self.volume and self.pages:\n            citation += \" {volume}: {pages}.\".format(**citation_data)\n        elif self.volume:\n            citation += \" {volume}.\".format(**citation_data)\n        elif self.pages:\n            citation += \" {pages}.\".format(**citation_data)\n        else:\n            citation += \".\"\n\n        return citation", "response": "Return a string with a citation for the record."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cite_mini(self):\n        citation_data = [self.first_author]\n\n        if len(self._author_list) > 1:\n            citation_data.append(self.last_author)\n\n        citation_data.extend([self.year, self.journal])\n\n        return \" - \".join(citation_data)", "response": "Return a string with a citation for the record formatted as :"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_abstract(xml_dict):\n        key_path = ['PubmedArticleSet', 'PubmedArticle', 'MedlineCitation',\n                    'Article', 'Abstract', 'AbstractText']\n        abstract_xml = reduce(dict.get, key_path, xml_dict)\n\n        abstract_paragraphs = []\n\n        if isinstance(abstract_xml, str):\n            abstract_paragraphs.append(abstract_xml)\n\n        elif isinstance(abstract_xml, dict):\n            abstract_text = abstract_xml.get('#text')\n            try:\n                abstract_label = abstract_xml['@Label']\n            except KeyError:\n                abstract_paragraphs.append(abstract_text)\n            else:\n                abstract_paragraphs.append(\n                    \"{}: {}\".format(abstract_label, abstract_text))\n\n        elif isinstance(abstract_xml, list):\n            for abstract_section in abstract_xml:\n                try:\n                    abstract_text = abstract_section['#text']\n                except KeyError:\n                    abstract_text = abstract_section\n\n                try:\n                    abstract_label = abstract_section['@Label']\n                except KeyError:\n                    abstract_paragraphs.append(abstract_text)\n                else:\n                    abstract_paragraphs.append(\n                        \"{}: {}\".format(abstract_label, abstract_text))\n\n        else:\n            raise RuntimeError(\"Error parsing abstract.\")\n\n        return \"\\n\\n\".join(abstract_paragraphs)", "response": "Parse PubMed XML dictionary to retrieve abstract."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_pubmed_xml(self):\n        url = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/' \\\n              'efetch.fcgi?db=pubmed&rettype=abstract&id={}' \\\n              .format(self.pmid)\n\n        try:\n            response = urlopen(url)\n        except URLError:\n            xml_dict = ''\n        else:\n            xml = response.read().decode()\n            xml_dict = xmltodict.parse(xml)\n\n        return xml_dict", "response": "Get PubMed metadata in XML form."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_abstract(self, xml_dict):\n        if self.record.get('HasAbstract') == 1 and xml_dict:\n            self.abstract = self.parse_abstract(xml_dict)\n        else:\n            self.abstract = ''", "response": "Set the abstract attribute of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset article URL based on where the DOI points.", "response": "def set_article_url(self, resolve_doi=True):\n        \"\"\"\n        If record has a DOI, set article URL based on where the DOI points.\n        \"\"\"\n        if 'DOI' in self.record:\n            doi_url = \"/\".join(['http://dx.doi.org', self.record['DOI']])\n\n            if resolve_doi:\n                try:\n                    response = urlopen(doi_url)\n                except URLError:\n                    self.url = ''\n                else:\n                    self.url = response.geturl()\n            else:\n                self.url = doi_url\n\n        else:\n            self.url = ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_pub_year_month_day(self, xml_dict):\n        key_path = ['PubmedArticleSet', 'PubmedArticle', 'MedlineCitation',\n                    'Article', 'Journal', 'JournalIssue', 'PubDate']\n        pubdate_xml = reduce(dict.get, key_path, xml_dict)\n\n        if isinstance(pubdate_xml, dict):\n            self.year = pubdate_xml.get('Year')\n            month_short = pubdate_xml.get('Month')\n            self.day = pubdate_xml.get('Day')\n\n            try:\n                self.month = datetime.datetime.strptime(\n                    month_short, \"%b\").month\n            except (ValueError, TypeError):\n                self.month = ''\n\n        else:\n            self.year = ''\n            self.month = ''\n            self.day = ''", "response": "Set publication year month day from PubMed s XML data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_pubmed_url(pubmed_url):\n        parse_result = urlparse(pubmed_url)\n        pattern = re.compile(r'^/pubmed/(\\d+)$')\n        pmid = pattern.match(parse_result.path).group(1)\n        return pmid", "response": "Get PubMed ID from PubMed URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_pubmed_record(pmid):\n        handle = Entrez.esummary(db=\"pubmed\", id=pmid)\n        record = Entrez.read(handle)\n        return record", "response": "Get PubMed record from PubMed ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the internal state of the object.", "response": "def _initialize(self, register_value_map=None, memory_value_map=None, default_value=None):\n        \"\"\" Sets the wire, register, and memory values to default or as specified.\n\n        :param register_value_map: is a map of {Register: value}.\n        :param memory_value_map: is a map of maps {Memory: {address: Value}}.\n        :param default_value: is the value that all unspecified registers and memories will\n         default to. If no default_value is specified, it will use the value stored in the\n         object (default to 0)\n        \"\"\"\n\n        if default_value is None:\n            default_value = self.default_value\n\n        # set registers to their values\n        reg_set = self.block.wirevector_subset(Register)\n        if register_value_map is not None:\n            for r in reg_set:\n                self.value[r] = self.regvalue[r] = register_value_map.get(r, default_value)\n\n        # set constants to their set values\n        for w in self.block.wirevector_subset(Const):\n            self.value[w] = w.val\n            assert isinstance(w.val, numbers.Integral)  # for now\n\n        # set memories to their passed values\n\n        for mem_net in self.block.logic_subset('m@'):\n            memid = mem_net.op_param[1].id\n            if memid not in self.memvalue:\n                self.memvalue[memid] = {}\n\n        if memory_value_map is not None:\n            for (mem, mem_map) in memory_value_map.items():\n                if isinstance(mem, RomBlock):\n                    raise PyrtlError('error, one or more of the memories in the map is a RomBlock')\n                if isinstance(self.block, PostSynthBlock):\n                    mem = self.block.mem_map[mem]  # pylint: disable=maybe-no-member\n                self.memvalue[mem.id] = mem_map\n                max_addr_val, max_bit_val = 2**mem.addrwidth, 2**mem.bitwidth\n                for (addr, val) in mem_map.items():\n                    if addr < 0 or addr >= max_addr_val:\n                        raise PyrtlError('error, address %s in %s outside of bounds' %\n                                         (str(addr), mem.name))\n                    if val < 0 or val >= max_bit_val:\n                        raise PyrtlError('error, %s at %s in %s outside of bounds' %\n                                         (str(val), str(addr), mem.name))\n\n        # set all other variables to default value\n        for w in self.block.wirevector_set:\n            if w not in self.value:\n                self.value[w] = default_value\n\n        self.ordered_nets = tuple((i for i in self.block))\n        self.reg_update_nets = tuple((self.block.logic_subset('r')))\n        self.mem_update_nets = tuple((self.block.logic_subset('@')))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step(self, provided_inputs):\n\n        # Check that all Input have a corresponding provided_input\n        input_set = self.block.wirevector_subset(Input)\n        supplied_inputs = set()\n        for i in provided_inputs:\n            if isinstance(i, WireVector):\n                name = i.name\n            else:\n                name = i\n            sim_wire = self.block.wirevector_by_name[name]\n            if sim_wire not in input_set:\n                raise PyrtlError(\n                    'step provided a value for input for \"%s\" which is '\n                    'not a known input ' % name)\n            if not isinstance(provided_inputs[i], numbers.Integral) or provided_inputs[i] < 0:\n                raise PyrtlError(\n                    'step provided an input \"%s\" which is not a valid '\n                    'positive integer' % provided_inputs[i])\n            if len(bin(provided_inputs[i]))-2 > sim_wire.bitwidth:\n                raise PyrtlError(\n                    'the bitwidth for \"%s\" is %d, but the provided input '\n                    '%d requires %d bits to represent'\n                    % (name, sim_wire.bitwidth,\n                       provided_inputs[i], len(bin(provided_inputs[i]))-2))\n\n            self.value[sim_wire] = provided_inputs[i]\n            supplied_inputs.add(sim_wire)\n\n        # Check that only inputs are specified, and set the values\n        if input_set != supplied_inputs:\n            for i in input_set.difference(supplied_inputs):\n                raise PyrtlError('Input \"%s\" has no input value specified' % i.name)\n\n        self.value.update(self.regvalue)  # apply register updates from previous step\n\n        for net in self.ordered_nets:\n            self._execute(net)\n\n        # Do all of the mem operations based off the new values changed in _execute()\n        for net in self.mem_update_nets:\n            self._mem_update(net)\n\n        # at the end of the step, record the values to the trace\n        # print self.value # Helpful Debug Print\n        if self.tracer is not None:\n            self.tracer.add_step(self.value)\n\n        # Do all of the reg updates based off of the new values\n        for net in self.reg_update_nets:\n            argval = self.value[net.args[0]]\n            self.regvalue[net.dests[0]] = self._sanitize(argval, net.dests[0])\n\n        # finally, if any of the rtl_assert assertions are failing then we should\n        # raise the appropriate exceptions\n        check_rtl_assertions(self)", "response": "Take the simulation forward one cycle and set the value of the current value of the next wire."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of a wirevector in the current simulation cycle.", "response": "def inspect(self, w):\n        \"\"\" Get the value of a wirevector in the last simulation cycle.\n\n        :param w: the name of the WireVector to inspect\n            (passing in a WireVector instead of a name is deprecated)\n        :return: value of w in the current step of simulation\n\n        Will throw KeyError if w does not exist in the simulation.\n        \"\"\"\n        wire = self.block.wirevector_by_name.get(w, w)\n        return self.value[wire]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting the logic update rules for the given net.", "response": "def _execute(self, net):\n        \"\"\"Handle the combinational logic update rules for the given net.\n\n        This function, along with edge_update, defined the semantics\n        of the primitive ops. Function updates self.value accordingly.\n        \"\"\"\n        if net.op in 'r@':\n            return  # registers and memory write ports have no logic function\n        elif net.op in self.simple_func:\n            argvals = (self.value[arg] for arg in net.args)\n            result = self.simple_func[net.op](*argvals)\n        elif net.op == 'c':\n            result = 0\n            for arg in net.args:\n                result = result << len(arg)\n                result = result | self.value[arg]\n        elif net.op == 's':\n            result = 0\n            source = self.value[net.args[0]]\n            for b in net.op_param[::-1]:\n                result = (result << 1) | (0x1 & (source >> b))\n        elif net.op == 'm':\n            # memories act async for reads\n            memid = net.op_param[0]\n            mem = net.op_param[1]\n            read_addr = self.value[net.args[0]]\n            if isinstance(mem, RomBlock):\n                result = mem._get_read_data(read_addr)\n            else:\n                result = self.memvalue[memid].get(read_addr, self.default_value)\n        else:\n            raise PyrtlInternalError('error, unknown op type')\n\n        self.value[net.dests[0]] = self._sanitize(result, net.dests[0])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _mem_update(self, net):\n        if net.op != '@':\n            raise PyrtlInternalError\n        memid = net.op_param[0]\n        write_addr = self.value[net.args[0]]\n        write_val = self.value[net.args[1]]\n        write_enable = self.value[net.args[2]]\n        if write_enable:\n            self.memvalue[memid][write_addr] = write_val", "response": "Handle the mem update for the given net."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef step(self, provided_inputs):\n        # validate_inputs\n        for wire, value in provided_inputs.items():\n            wire = self.block.get_wirevector_by_name(wire) if isinstance(wire, str) else wire\n            if value > wire.bitmask or value < 0:\n                raise PyrtlError(\"Wire {} has value {} which cannot be represented\"\n                                 \" using its bitwidth\".format(wire, value))\n\n        # building the simulation data\n        ins = {self._to_name(wire): value for wire, value in provided_inputs.items()}\n        ins.update(self.regs)\n        ins.update(self.mems)\n\n        # propagate through logic\n        self.regs, self.outs, mem_writes = self.sim_func(ins)\n\n        for mem, addr, value in mem_writes:\n            self.mems[mem][addr] = value\n\n        # for tracer compatibility\n        self.context = self.outs.copy()\n        self.context.update(ins)  # also gets old register values\n        if self.tracer is not None:\n            self.tracer.add_fast_step(self)\n\n        # check the rtl assertions\n        check_rtl_assertions(self)", "response": "Run the simulation for a cycle of the current block."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the value of a wirevector in the last simulation cycle.", "response": "def inspect(self, w):\n        \"\"\" Get the value of a wirevector in the last simulation cycle.\n\n        :param w: the name of the WireVector to inspect\n            (passing in a WireVector instead of a name is deprecated)\n        :return: value of w in the current step of simulation\n\n        Will throw KeyError if w is not being tracked in the simulation.\n        \"\"\"\n        try:\n            return self.context[self._to_name(w)]\n        except AttributeError:\n            raise PyrtlError(\"No context available. Please run a simulation step in \"\n                             \"order to populate values for wires\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the values in a map during the current simulation cycle.", "response": "def inspect_mem(self, mem):\n        \"\"\" Get the values in a map during the current simulation cycle.\n\n        :param mem: the memory to inspect\n        :return: {address: value}\n\n        Note that this returns the current memory state. Modifying the dictonary\n        will also modify the state in the simulator\n        \"\"\"\n        if isinstance(mem, RomBlock):\n            raise PyrtlError(\"ROM blocks are not stored in the simulation object\")\n        return self.mems[self._mem_varname(mem)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _arg_varname(self, wire):\n        if isinstance(wire, (Input, Register)):\n            return 'd[' + repr(wire.name) + ']'  # passed in\n        elif isinstance(wire, Const):\n            return str(wire.val)  # hardcoded\n        else:\n            return self._varname(wire)", "response": "Return the variable name for the passed in argument."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _compiled(self):\n        # Dev Notes:\n        # Because of fast locals in functions in both CPython and PyPy, getting a\n        # function to execute makes the code a few times faster than\n        # just executing it in the global exec scope.\n        prog = [self._prog_start]\n\n        simple_func = {  # OPS\n            'w': lambda x: x,\n            'r': lambda x: x,\n            '~': lambda x: '(~' + x + ')',\n            '&': lambda l, r: '(' + l + '&' + r + ')',\n            '|': lambda l, r: '(' + l + '|' + r + ')',\n            '^': lambda l, r: '(' + l + '^' + r + ')',\n            'n': lambda l, r: '(~(' + l + '&' + r + '))',\n            '+': lambda l, r: '(' + l + '+' + r + ')',\n            '-': lambda l, r: '(' + l + '-' + r + ')',\n            '*': lambda l, r: '(' + l + '*' + r + ')',\n            '<': lambda l, r: 'int(' + l + '<' + r + ')',\n            '>': lambda l, r: 'int(' + l + '>' + r + ')',\n            '=': lambda l, r: 'int(' + l + '==' + r + ')',\n            'x': lambda sel, f, t: '({}) if ({}==0) else ({})'.format(f, sel, t),\n        }\n\n        def shift(value, direction, shift_amt):\n            if shift_amt == 0:\n                return value\n            else:\n                return '(%s %s %d)' % (value, direction, shift_amt)\n\n        def make_split():\n            if split_start_bit == 0:\n                bit = '(%d & %s)' % ((1 << split_length) - 1, source)\n            elif len(net.args[0]) - split_start_bit == split_length:\n                bit = '(%s >> %d)' % (source, split_start_bit)\n            else:\n                bit = '(%d & (%s >> %d))' % ((1 << split_length) - 1, source, split_start_bit)\n            return shift(bit, '<<', split_res_start_bit)\n\n        for net in self.block:\n            if net.op in simple_func:\n                argvals = (self._arg_varname(arg) for arg in net.args)\n                expr = simple_func[net.op](*argvals)\n            elif net.op == 'c':\n                expr = ''\n                for i in range(len(net.args)):\n                    if expr is not '':\n                        expr += ' | '\n                    shiftby = sum(len(j) for j in net.args[i+1:])\n                    expr += shift(self._arg_varname(net.args[i]), '<<', shiftby)\n            elif net.op == 's':\n                source = self._arg_varname(net.args[0])\n                expr = ''\n                split_length = 0\n                split_start_bit = -2\n                split_res_start_bit = -1\n\n                for i, b in enumerate(net.op_param):\n                    if b != split_start_bit + split_length:\n                        if split_start_bit >= 0:\n                            # create a wire\n                            expr += make_split() + '|'\n                        split_length = 1\n                        split_start_bit = b\n                        split_res_start_bit = i\n                    else:\n                        split_length += 1\n                expr += make_split()\n            elif net.op == 'm':\n                read_addr = self._arg_varname(net.args[0])\n                mem = net.op_param[1]\n                if isinstance(net.op_param[1], RomBlock):\n                    expr = 'd[\"%s\"]._get_read_data(%s)' % (self._mem_varname(mem), read_addr)\n                else:  # memories act async for reads\n                    expr = 'd[\"%s\"].get(%s, %s)' % (self._mem_varname(mem),\n                                                    read_addr, self.default_value)\n            elif net.op == '@':\n                mem = self._mem_varname(net.op_param[1])\n                write_addr, write_val, write_enable = (self._arg_varname(a) for a in net.args)\n                prog.append('    if {}:'.format(write_enable))\n                prog.append('        mem_ws.append((\"{}\", {}, {}))'\n                            .format(mem, write_addr, write_val))\n                continue  # memwrites are special\n            else:\n                raise PyrtlError('FastSimulation cannot handle primitive \"%s\"' % net.op)\n\n            # prog.append('    #  ' + str(net))\n            result = self._dest_varname(net.dests[0])\n            if len(net.dests[0]) == self._no_mask_bitwidth[net.op](net):\n                prog.append(\"    %s = %s\" % (result, expr))\n            else:\n                mask = str(net.dests[0].bitmask)\n                prog.append('    %s = %s & %s' % (result, mask, expr))\n\n        # add traced wires to dict\n        if self.tracer is not None:\n            for wire_name in self.tracer.trace:\n                wire = self.block.wirevector_by_name[wire_name]\n                if not isinstance(wire, (Input, Const, Register, Output)):\n                    v_wire_name = self._varname(wire)\n                    prog.append('    outs[\"%s\"] = %s' % (wire_name, v_wire_name))\n\n        prog.append(\"    return regs, outs, mem_ws\")\n        return '\\n'.join(prog)", "response": "Return a string of the self. block compiled to a block of\n         code that can be execed to get a function to execute"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _render_val_with_prev(self, w, n, current_val, symbol_len):\n        sl = symbol_len-1\n        if len(w) > 1:\n            out = self._revstart\n            if current_val != self.prior_val:\n                out += self._x + hex(current_val).rstrip('L').ljust(sl)[:sl]\n            elif n == 0:\n                out += hex(current_val).rstrip('L').ljust(symbol_len)[:symbol_len]\n            else:\n                out += ' '*symbol_len\n            out += self._revstop\n        else:\n            pretty_map = {\n                (0, 0): self._low + self._low * sl,\n                (0, 1): self._up + self._high * sl,\n                (1, 0): self._down + self._low * sl,\n                (1, 1): self._high + self._high * sl,\n            }\n            out = pretty_map[(self.prior_val, current_val)]\n        return out", "response": "Render the value of a given key in a waveform."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_step(self, value_map):\n        if len(self.trace) == 0:\n            raise PyrtlError('error, simulation trace needs at least 1 signal to track '\n                             '(by default, unnamed signals are not traced -- try either passing '\n                             'a name to a WireVector or setting a \"wirevector_subset\" option)')\n        for wire in self.trace:\n            tracelist = self.trace[wire]\n            wirevec = self._wires[wire]\n            tracelist.append(value_map[wirevec])", "response": "Add the values in value_map to the end of the trace."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_fast_step(self, fastsim):\n        for wire_name in self.trace:\n            self.trace[wire_name].append(fastsim.context[wire_name])", "response": "Add the fastsim context to the trace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_trace(self, file=sys.stdout, base=10, compact=False):\n        if len(self.trace) == 0:\n            raise PyrtlError('error, cannot print an empty trace')\n        if base not in (2, 8, 10, 16):\n            raise PyrtlError('please choose a valid base (2,8,10,16)')\n\n        basekey = {2: 'b', 8: 'o', 10: 'd', 16: 'x'}[base]\n        ident_len = max(len(w) for w in self.trace)\n\n        if compact:\n            for w in sorted(self.trace, key=_trace_sort_key):\n                vals = ''.join('{0:{1}}'.format(x, basekey) for x in self.trace[w])\n                file.write(w.rjust(ident_len) + ' ' + vals + '\\n')\n        else:\n            maxlenval = max(len('{0:{1}}'.format(x, basekey))\n                            for w in self.trace for x in self.trace[w])\n            file.write(' ' * (ident_len - 3) + \"--- Values in base %d ---\\n\" % base)\n            for w in sorted(self.trace, key=_trace_sort_key):\n                vals = ' '.join('{0:>{1}{2}}'.format(x, maxlenval, basekey) for x in self.trace[w])\n                file.write(w.ljust(ident_len + 1) + vals + '\\n')\n\n        file.flush()", "response": "Prints a list of wires and their current values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_vcd(self, file=sys.stdout, include_clock=False):\n        # dump header info\n        # file_timestamp = time.strftime(\"%a, %d %b %Y %H:%M:%S (UTC/GMT)\", time.gmtime())\n        # print >>file, \" \".join([\"$date\", file_timestamp, \"$end\"])\n        self.internal_names = _VerilogSanitizer('_vcd_tmp_')\n        for wire in self.wires_to_track:\n            self.internal_names.make_valid_string(wire.name)\n\n        def _varname(wireName):\n            \"\"\" Converts WireVector names to internal names \"\"\"\n            return self.internal_names[wireName]\n\n        print(' '.join(['$timescale', '1ns', '$end']), file=file)\n        print(' '.join(['$scope', 'module logic', '$end']), file=file)\n\n        def print_trace_strs(time):\n            for wn in sorted(self.trace, key=_trace_sort_key):\n                print(' '.join([str(bin(self.trace[wn][time]))[1:], _varname(wn)]), file=file)\n\n        # dump variables\n        if include_clock:\n            print(' '.join(['$var', 'wire', '1', 'clk', 'clk', '$end']), file=file)\n        for wn in sorted(self.trace, key=_trace_sort_key):\n            print(' '.join(['$var', 'wire', str(self._wires[wn].bitwidth),\n                            _varname(wn), _varname(wn), '$end']), file=file)\n        print(' '.join(['$upscope', '$end']), file=file)\n        print(' '.join(['$enddefinitions', '$end']), file=file)\n        print(' '.join(['$dumpvars']), file=file)\n        print_trace_strs(0)\n        print(' '.join(['$end']), file=file)\n\n        # dump values\n        endtime = max([len(self.trace[w]) for w in self.trace])\n        for timestamp in range(endtime):\n            print(''.join(['#', str(timestamp*10)]), file=file)\n            print_trace_strs(timestamp)\n            if include_clock:\n                print('b1 clk', file=file)\n                print('', file=file)\n                print(''.join(['#', str(timestamp*10+5)]), file=file)\n                print('b0 clk', file=file)\n            print('', file=file)\n        print(''.join(['#', str(endtime*10)]), file=file)\n        file.flush()", "response": "Prints out the current trace as a VCD dump."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_trace(\n            self, trace_list=None, file=sys.stdout, render_cls=default_renderer(),\n            symbol_len=5, segment_size=5, segment_delim=' ', extra_line=True):\n\n        \"\"\" Render the trace to a file using unicode and ASCII escape sequences.\n\n        :param trace_list: A list of signals to be output in the specified order.\n        :param file: The place to write output, default to stdout.\n        :param render_cls: A class that translates traces into output bytes.\n        :param symbol_len: The \"length\" of each rendered cycle in characters.\n        :param segment_size: Traces are broken in the segments of this number of cycles.\n        :param segment_delim: The character to be output between segments.\n        :param extra_line: A Boolean to determin if we should print a blank line between signals.\n\n        The resulting output can be viewed directly on the terminal or looked\n        at with \"more\" or \"less -R\" which both should handle the ASCII escape\n        sequences used in rendering. render_trace takes the following optional\n        arguments.\n        \"\"\"\n        if _currently_in_ipython():\n            from IPython.display import display, HTML, Javascript  # pylint: disable=import-error\n            from .inputoutput import trace_to_html\n            htmlstring = trace_to_html(self, trace_list=trace_list, sortkey=_trace_sort_key)\n            html_elem = HTML(htmlstring)\n            display(html_elem)\n            # print(htmlstring)\n            js_stuff = \"\"\"\n            $.when(\n            $.getScript(\"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/1.6.2/skins/default.js\"),\n            $.getScript(\"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/1.6.2/wavedrom.min.js\"),\n            $.Deferred(function( deferred ){\n                $( deferred.resolve );\n            })).done(function(){\n                WaveDrom.ProcessAll();\n            });\"\"\"\n            display(Javascript(js_stuff))\n        else:\n            self.render_trace_to_text(\n                trace_list=trace_list, file=file, render_cls=render_cls,\n                symbol_len=symbol_len, segment_size=segment_size,\n                segment_delim=segment_delim, extra_line=extra_line)", "response": "Render the current signal to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the value in the first wire for which the select bit is 1.", "response": "def prioritized_mux(selects, vals):\n    \"\"\"\n    Returns the value in the first wire for which its select bit is 1\n\n    :param [WireVector] selects: a list of WireVectors signaling whether\n        a wire should be chosen\n    :param [WireVector] vals: values to return when the corresponding select\n        value is 1\n    :return: WireVector\n\n    If none of the items are high, the last val is returned\n    \"\"\"\n    if len(selects) != len(vals):\n        raise pyrtl.PyrtlError(\"Number of select and val signals must match\")\n    if len(vals) == 0:\n        raise pyrtl.PyrtlError(\"Must have a signal to mux\")\n    if len(vals) == 1:\n        return vals[0]\n    else:\n        half = len(vals) // 2\n        return pyrtl.select(pyrtl.rtl_any(*selects[:half]),\n                            truecase=prioritized_mux(selects[:half], vals[:half]),\n                            falsecase=prioritized_mux(selects[half:], vals[half:]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _sparse_mux(sel, vals):\n    items = list(vals.values())\n    if len(vals) <= 1:\n        if len(vals) == 0:\n            raise pyrtl.PyrtlError(\"Needs at least one parameter for val\")\n        return items[0]\n\n    if len(sel) == 1:\n        try:\n            false_result = vals[0]\n            true_result = vals[1]\n        except KeyError:\n            raise pyrtl.PyrtlError(\"Failed to retrieve values for smartmux. \"\n                                   \"The length of sel might be wrong\")\n    else:\n        half = 2**(len(sel) - 1)\n\n        first_dict = {indx: wire for indx, wire in vals.items() if indx < half}\n        second_dict = {indx-half: wire for indx, wire in vals.items() if indx >= half}\n        if not len(first_dict):\n            return sparse_mux(sel[:-1], second_dict)\n        if not len(second_dict):\n            return sparse_mux(sel[:-1], first_dict)\n\n        false_result = sparse_mux(sel[:-1], first_dict)\n        true_result = sparse_mux(sel[:-1], second_dict)\n    if _is_equivelent(false_result, true_result):\n        return true_result\n    return pyrtl.select(sel[-1], falsecase=false_result, truecase=true_result)", "response": "Returns a sparse mux that avoids instantiating unnecessary mux_2s when possible."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef finalize(self):\n        self._check_finalized()\n        self._final = True\n\n        for dest_w, values in self.dest_instrs_info.items():\n            mux_vals = dict(zip(self.instructions, values))\n            dest_w <<= sparse_mux(self.signal_wire, mux_vals)", "response": "Finalizes the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlogging all actions to console as they are dispatched", "response": "def log_middleware(store):\n    \"\"\"log all actions to console as they are dispatched\"\"\"\n    def wrapper(next_):\n        def log_dispatch(action):\n            print('Dispatch Action:', action)\n            return next_(action)\n        return log_dispatch\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the latest value of the wire given if possible.", "response": "def inspect(self, w):\n        \"\"\"Get the latest value of the wire given, if possible.\"\"\"\n        if isinstance(w, WireVector):\n            w = w.name\n        try:\n            vals = self.tracer.trace[w]\n        except KeyError:\n            pass\n        else:\n            if not vals:\n                raise PyrtlError('No context available. Please run a simulation step')\n            return vals[-1]\n        raise PyrtlError('CompiledSimulation does not support inspecting internal WireVectors')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, inputs):\n        steps = len(inputs)\n        # create i/o arrays of the appropriate length\n        ibuf_type = ctypes.c_uint64*(steps*self._ibufsz)\n        obuf_type = ctypes.c_uint64*(steps*self._obufsz)\n        ibuf = ibuf_type()\n        obuf = obuf_type()\n        # these array will be passed to _crun\n        self._crun.argtypes = [ctypes.c_uint64, ibuf_type, obuf_type]\n\n        # build the input array\n        for n, inmap in enumerate(inputs):\n            for w in inmap:\n                if isinstance(w, WireVector):\n                    name = w.name\n                else:\n                    name = w\n                start, count = self._inputpos[name]\n                start += n*self._ibufsz\n                val = inmap[w]\n                if val >= 1 << self._inputbw[name]:\n                    raise PyrtlError(\n                        'Wire {} has value {} which cannot be represented '\n                        'using its bitwidth'.format(name, val))\n                # pack input\n                for pos in range(start, start+count):\n                    ibuf[pos] = val & ((1 << 64)-1)\n                    val >>= 64\n\n        # run the simulation\n        self._crun(steps, ibuf, obuf)\n\n        # save traced wires\n        for name in self.tracer.trace:\n            rname = self._probe_mapping.get(name, name)\n            if rname in self._outputpos:\n                start, count = self._outputpos[rname]\n                buf, sz = obuf, self._obufsz\n            elif rname in self._inputpos:\n                start, count = self._inputpos[rname]\n                buf, sz = ibuf, self._ibufsz\n            else:\n                raise PyrtlInternalError('Untraceable wire in tracer')\n            res = []\n            for n in range(steps):\n                val = 0\n                # unpack output\n                for pos in reversed(range(start, start+count)):\n                    val <<= 64\n                    val |= buf[pos]\n                res.append(val)\n                start += sz\n            self.tracer.trace[name].extend(res)", "response": "Run many steps of the simulation.\n\n        The argument is a list of input mappings for each step,\n        and its length is the number of steps to be executed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a given wv is traceable.", "response": "def _traceable(self, wv):\n        \"\"\"Check if wv is able to be traced\n\n        If it is traceable due to a probe, record that probe in _probe_mapping.\n        \"\"\"\n        if isinstance(wv, (Input, Output)):\n            return True\n        for net in self.block.logic:\n            if net.op == 'w' and net.args[0].name == wv.name and isinstance(net.dests[0], Output):\n                self._probe_mapping[wv.name] = net.dests[0].name\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove from the tracer those wires that CompiledSimulation cannot track.", "response": "def _remove_untraceable(self):\n        \"\"\"Remove from the tracer those wires that CompiledSimulation cannot track.\n\n        Create _probe_mapping for wires only traceable via probes.\n        \"\"\"\n        self._probe_mapping = {}\n        wvs = {wv for wv in self.tracer.wires_to_track if self._traceable(wv)}\n        self.tracer.wires_to_track = wvs\n        self.tracer._wires = {wv.name: wv for wv in wvs}\n        self.tracer.trace.__init__(wvs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a dynamically - linked library implementing the simulation logic.", "response": "def _create_dll(self):\n        \"\"\"Create a dynamically-linked library implementing the simulation logic.\"\"\"\n        self._dir = tempfile.mkdtemp()\n        with open(path.join(self._dir, 'pyrtlsim.c'), 'w') as f:\n            self._create_code(lambda s: f.write(s+'\\n'))\n        if platform.system() == 'Darwin':\n            shared = '-dynamiclib'\n        else:\n            shared = '-shared'\n        subprocess.check_call([\n            'gcc', '-O0', '-march=native', '-std=c99', '-m64',\n            shared, '-fPIC',\n            path.join(self._dir, 'pyrtlsim.c'), '-o', path.join(self._dir, 'pyrtlsim.so'),\n            ], shell=(platform.system() == 'Windows'))\n        self._dll = ctypes.CDLL(path.join(self._dir, 'pyrtlsim.so'))\n        self._crun = self._dll.sim_run_all\n        self._crun.restype = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _makeini(self, w, v):\n        pieces = []\n        for n in range(self._limbs(w)):\n            pieces.append(hex(v & ((1 << 64)-1)))\n            v >>= 64\n        return ','.join(pieces).join('{}')", "response": "A function to make a string for a given wire with a given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a bitmask. The value being masked is of width `res`. Limb number `pos` of `dest` is being assigned to.", "response": "def _makemask(self, dest, res, pos):\n        \"\"\"Create a bitmask.\n\n        The value being masked is of width `res`.\n        Limb number `pos` of `dest` is being assigned to.\n        \"\"\"\n        if (res is None or dest.bitwidth < res) and 0 < (dest.bitwidth - 64*pos) < 64:\n            return '&0x{:X}'.format((1 << (dest.bitwidth % 64))-1)\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _getarglimb(self, arg, n):\n        return '{vn}[{n}]'.format(vn=self.varname[arg], n=n) if arg.bitwidth > 64*n else '0'", "response": "Get the nth limb of the given arg. Returns 0 when the wire does not have sufficient limbs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a C variable name with the given prefix based on the name of obj.", "response": "def _clean_name(self, prefix, obj):\n        \"\"\"Create a C variable name with the given prefix based on the name of obj.\"\"\"\n        return '{}{}_{}'.format(prefix, self._uid(), ''.join(c for c in obj.name if c.isalnum()))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a slow and small multiplication of two sets of wires.", "response": "def simple_mult(A, B, start):\n    \"\"\" Builds a slow, small multiplier using the simple shift-and-add algorithm.\n    Requires very small area (it uses only a single adder), but has long delay\n    (worst case is len(A) cycles). start is a one-bit input to indicate inputs are ready.\n    done is a one-bit output signal raised when the multiplication is finished.\n\n    :param WireVector A, B: two input wires for the multiplication\n    :returns: Register containing the product; the \"done\" signal\n\n    \"\"\"\n    triv_result = _trivial_mult(A, B)\n    if triv_result is not None:\n        return triv_result, pyrtl.Const(1, 1)\n\n    alen = len(A)\n    blen = len(B)\n    areg = pyrtl.Register(alen)\n    breg = pyrtl.Register(blen + alen)\n    accum = pyrtl.Register(blen + alen)\n    done = (areg == 0)  # Multiplication is finished when a becomes 0\n\n    # During multiplication, shift a right every cycle, b left every cycle\n    with pyrtl.conditional_assignment:\n        with start:  # initialization\n            areg.next |= A\n            breg.next |= B\n            accum.next |= 0\n        with ~done:  # don't run when there's no work to do\n            areg.next |= areg[1:]  # right shift\n            breg.next |= pyrtl.concat(breg, pyrtl.Const(0, 1))  # left shift\n            a_0_val = areg[0].sign_extended(len(accum))\n\n            # adds to accum only when LSB of areg is 1\n            accum.next |= accum + (a_0_val & breg)\n\n    return accum, done"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _trivial_mult(A, B):\n    if len(B) == 1:\n        A, B = B, A  # so that we can reuse the code below :)\n    if len(A) == 1:\n        a_vals = A.sign_extended(len(B))\n\n        # keep the wirevector len consistent\n        return pyrtl.concat_list([a_vals & B, pyrtl.Const(0)])", "response": "This function turns a multiplication into an And gate if one of the wires is a bitwidth of 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef complex_mult(A, B, shifts, start):\n\n    alen = len(A)\n    blen = len(B)\n    areg = pyrtl.Register(alen)\n    breg = pyrtl.Register(alen + blen)\n    accum = pyrtl.Register(alen + blen)\n    done = (areg == 0)  # Multiplication is finished when a becomes 0\n    if (shifts > alen) or (shifts > blen):\n        raise pyrtl.PyrtlError(\"shift is larger than one or both of the parameters A or B,\"\n                               \"please choose smaller shift\")\n\n    # During multiplication, shift a right every cycle 'shift' times,\n    # shift b left every cycle 'shift' times\n    with pyrtl.conditional_assignment:\n        with start:  # initialization\n            areg.next |= A\n            breg.next |= B\n            accum.next |= 0\n\n        with ~done:  # don't run when there's no work to do\n            # \"Multiply\" shifted breg by LSB of areg by cond. adding\n            areg.next |= libutils._shifted_reg_next(areg, 'r', shifts)  # right shift\n            breg.next |= libutils._shifted_reg_next(breg, 'l', shifts)  # left shift\n            accum.next |= accum + _one_cycle_mult(areg, breg, shifts)\n\n    return accum, done", "response": "Generates a shift - and - add multiplier that can shift and add multiple bits per clock cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _one_cycle_mult(areg, breg, rem_bits, sum_sf=0, curr_bit=0):\n    if rem_bits == 0:\n        return sum_sf\n    else:\n        a_curr_val = areg[curr_bit].sign_extended(len(breg))\n        if curr_bit == 0:  # if no shift\n            return(_one_cycle_mult(areg, breg, rem_bits-1,  # areg, breg, rem_bits\n                                   sum_sf + (a_curr_val & breg),  # sum_sf\n                                   curr_bit+1))  # curr_bit\n        else:\n            return _one_cycle_mult(\n                areg, breg, rem_bits-1,  # areg, breg, rem_bits\n                sum_sf + (a_curr_val &\n                          pyrtl.concat(breg, pyrtl.Const(0, curr_bit))),  # sum_sf\n                curr_bit+1  # curr_bit\n            )", "response": "This function multiplies the current bit in one cycle of the internal group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a tree multiplier for inputs A and B using a Wallace or Dada Tree multiplier.", "response": "def tree_multiplier(A, B, reducer=adders.wallace_reducer, adder_func=adders.kogge_stone):\n    \"\"\" Build an fast unclocked multiplier for inputs A and B using a Wallace or Dada Tree.\n\n    :param WireVector A, B: two input wires for the multiplication\n    :param function reducer: Reduce the tree using either a Dada recuder or a Wallace reducer\n      determines whether it is a Wallace tree multiplier or a Dada tree multiplier\n    :param function adder_func: an adder function that will be used to do the last addition\n    :return WireVector: The multiplied result\n\n    Delay is order logN, while area is order N^2.\n    \"\"\"\n\n    \"\"\"\n    The two tree multipliers basically works by splitting the multiplication\n    into a series of many additions, and it works by applying 'reductions'.\n    \"\"\"\n    triv_res = _trivial_mult(A, B)\n    if triv_res is not None:\n        return triv_res\n\n    bits_length = (len(A) + len(B))\n\n    # create a list of lists, with slots for all the weights (bit-positions)\n    bits = [[] for weight in range(bits_length)]\n\n    # AND every bit of A with every bit of B (N^2 results) and store by \"weight\" (bit-position)\n    for i, a in enumerate(A):\n        for j, b in enumerate(B):\n            bits[i + j].append(a & b)\n\n    return reducer(bits, bits_length, adder_func)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef signed_tree_multiplier(A, B, reducer=adders.wallace_reducer, adder_func=adders.kogge_stone):\n    if len(A) == 1 or len(B) == 1:\n        raise pyrtl.PyrtlError(\"sign bit required, one or both wires too small\")\n\n    aneg, bneg = A[-1], B[-1]\n    a = _twos_comp_conditional(A, aneg)\n    b = _twos_comp_conditional(B, bneg)\n\n    res = tree_multiplier(a[:-1], b[:-1]).zero_extended(len(A) + len(B))\n    return _twos_comp_conditional(res, aneg ^ bneg)", "response": "Same as tree_multiplier but uses two s - complement signed integers"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn two s complement of wire with sign_bit == 1", "response": "def _twos_comp_conditional(orig_wire, sign_bit, bw=None):\n    \"\"\"Returns two's complement of wire (using bitwidth bw) if sign_bit == 1\"\"\"\n    if bw is None:\n        bw = len(orig_wire)\n    new_wire = pyrtl.WireVector(bw)\n    with pyrtl.conditional_assignment:\n        with sign_bit:\n            new_wire |= ~orig_wire + 1\n        with pyrtl.otherwise:\n            new_wire |= orig_wire\n    return new_wire"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating efficient hardware for a*b+c. Multiplies two wirevectors together and adds a third wirevector to the multiplication result, all in one step. By doing it this way (instead of separately), one reduces both the area and the timing delay of the circuit. :param Bool signed: Currently not supported (will be added in the future) The default will likely be changed to True, so if you want the smallest set of wires in the future, specify this as False :param reducer: (advanced) The tree reducer to use :param adder_func: (advanced) The adder to use to add the two results at the end :return WireVector: The result WireVector", "response": "def fused_multiply_adder(mult_A, mult_B, add, signed=False, reducer=adders.wallace_reducer,\n                         adder_func=adders.kogge_stone):\n    \"\"\" Generate efficient hardware for a*b+c.\n\n    Multiplies two wirevectors together and adds a third wirevector to the\n    multiplication result, all in\n    one step. By doing it this way (instead of separately), one reduces both\n    the area and the timing delay of the circuit.\n\n\n    :param Bool signed: Currently not supported (will be added in the future)\n      The default will likely be changed to True, so if you want the smallest\n      set of wires in the future, specify this as False\n    :param reducer: (advanced) The tree reducer to use\n    :param adder_func: (advanced) The adder to use to add the two results at the end\n    :return WireVector: The result WireVector\n\n    \"\"\"\n\n    # TODO: Specify the length of the result wirevector\n\n    return generalized_fma(((mult_A, mult_B),), (add,), signed, reducer, adder_func)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generalized_fma(mult_pairs, add_wires, signed=False, reducer=adders.wallace_reducer,\n                    adder_func=adders.kogge_stone):\n    \"\"\"Generated an opimitized fused multiply adder.\n\n    A generalized FMA unit that multiplies each pair of numbers in mult_pairs,\n    then adds the resulting numbers and and the values of the add wires all\n    together to form an answer. This is faster than separate adders and\n    multipliers because you avoid unnecessary adder structures for intermediate\n    representations.\n\n    :param mult_pairs: Either None (if there are no pairs to multiply) or\n      a list of pairs of wires to multiply:\n      [(mult1_1, mult1_2), ...]\n    :param add_wires: Either None (if there are no individual\n      items to add other than the mult_pairs), or a list of wires for adding on\n      top of the result of the pair multiplication.\n    :param Bool signed: Currently not supported (will be added in the future)\n      The default will likely be changed to True, so if you want the smallest\n      set of wires in the future, specify this as False\n    :param reducer: (advanced) The tree reducer to use\n    :param adder_func: (advanced) The adder to use to add the two results at the end\n    :return WireVector: The result WireVector\n\n    \"\"\"\n    # first need to figure out the max length\n    if mult_pairs:  # Need to deal with the case when it is empty\n        mult_max = max(len(m[0]) + len(m[1]) - 1 for m in mult_pairs)\n    else:\n        mult_max = 0\n\n    if add_wires:\n        add_max = max(len(x) for x in add_wires)\n    else:\n        add_max = 0\n\n    longest_wire_len = max(add_max, mult_max)\n    bits = [[] for i in range(longest_wire_len)]\n\n    for mult_a, mult_b in mult_pairs:\n        for i, a in enumerate(mult_a):\n            for j, b in enumerate(mult_b):\n                bits[i + j].append(a & b)\n\n    for wire in add_wires:\n        for bit_loc, bit in enumerate(wire):\n            bits[bit_loc].append(bit)\n\n    import math\n    result_bitwidth = (longest_wire_len +\n                       int(math.ceil(math.log(len(add_wires) + len(mult_pairs), 2))))\n    return reducer(bits, result_bitwidth, adder_func)", "response": "This function generates a generalized FMA unit that multiplies each pair of numbers and adds the resulting numbers and values of the add wires at the end of the intermediate ArcGIS tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmaps nets to new sets of nets according to a custom function", "response": "def net_transform(transform_func, block=None, **kwargs):\n    \"\"\"\n    Maps nets to new sets of nets according to a custom function\n\n    :param transform_func:\n        Function signature: func(orig_net (logicnet)) -> keep_orig_net (bool)\n    :return:\n    \"\"\"\n    block = working_block(block)\n    with set_working_block(block, True):\n        for net in block.logic.copy():\n            keep_orig_net = transform_func(net, **kwargs)\n            if not keep_orig_net:\n                block.logic.remove(net)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef all_nets(transform_func):\n    @functools.wraps(transform_func)\n    def t_res(**kwargs):\n        net_transform(transform_func, **kwargs)\n    return t_res", "response": "Decorator that wraps a net transform function and returns a new object that is passed to the next net transform function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmapping Wires to new sets of nets and wires according to a custom function :param transform_func: The function you want to run on all wires Function signature: func(orig_wire (WireVector)) -> src_wire, dst_wire src_wire is the src for the stuff you made in the transform func and dst_wire is the sink to indicate that the wire has not been changed, make src_wire and dst_wire both the original wire :param select_types: Type or Tuple of types of WireVectors to replace :param exclude_types: Type or Tuple of types of WireVectors to exclude from replacement :param block: The Block to replace wires on", "response": "def wire_transform(transform_func, select_types=WireVector,\n                   exclude_types=(Input, Output, Register, Const), block=None):\n    \"\"\"\n    Maps Wires to new sets of nets and wires according to a custom function\n\n    :param transform_func: The function you want to run on all wires\n        Function signature: func(orig_wire (WireVector)) -> src_wire, dst_wire\n        src_wire is the src for the stuff you made in the transform func\n        and dst_wire is the sink\n\n        to indicate that the wire has not been changed, make src_wire and dst_wire both\n        the original wire\n    :param select_types: Type or Tuple of types of WireVectors to replace\n    :param exclude_types: Type or Tuple of types of WireVectors to exclude from replacement\n    :param block: The Block to replace wires on\n    \"\"\"\n    block = working_block(block)\n    for orig_wire in block.wirevector_subset(select_types, exclude_types):\n        new_src, new_dst = transform_func(orig_wire)\n        replace_wire(orig_wire, new_src, new_dst, block)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace_wires(wire_map, block=None):\n    block = working_block(block)\n    src_nets, dst_nets = block.net_connections(include_virtual_nodes=False)\n    for old_w, new_w in wire_map.items():\n        replace_wire_fast(old_w, new_w, new_w, src_nets, dst_nets, block)", "response": "Quickly replace all wires in a block by new ones."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clone_wire(old_wire, name=None):\n    if isinstance(old_wire, Const):\n        return Const(old_wire.val, old_wire.bitwidth)\n    else:\n        if name is None:\n            return old_wire.__class__(old_wire.bitwidth, name=old_wire.name)\n        return old_wire.__class__(old_wire.bitwidth, name=name)", "response": "Makes a copy of any existing wire"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a copy of an existing block", "response": "def copy_block(block=None, update_working_block=True):\n    \"\"\"\n    Makes a copy of an existing block\n\n    :param block: The block to clone. (defaults to the working block)\n    :return: The resulting block\n    \"\"\"\n    block_in = working_block(block)\n    block_out, temp_wv_map = _clone_block_and_wires(block_in)\n    mems = {}\n    for net in block_in.logic:\n        _copy_net(block_out, net, temp_wv_map, mems)\n    block_out.mem_map = mems\n\n    if update_working_block:\n        set_working_block(block_out)\n    return block_out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _clone_block_and_wires(block_in):\n    block_in.sanity_check()  # make sure that everything is valid\n    block_out = block_in.__class__()\n    temp_wv_map = {}\n    with set_working_block(block_out, no_sanity_check=True):\n        for wirevector in block_in.wirevector_subset():\n            new_wv = clone_wire(wirevector)\n            temp_wv_map[wirevector] = new_wv\n\n    return block_out, temp_wv_map", "response": "This function is a generic function to copy the WireVectors for another round of\n    synthesis"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _copy_net(block_out, net, temp_wv_net, mem_map):\n    new_args = tuple(temp_wv_net[a_arg] for a_arg in net.args)\n    new_dests = tuple(temp_wv_net[a_dest] for a_dest in net.dests)\n    if net.op in \"m@\":  # special stuff for copying memories\n        new_param = _get_new_block_mem_instance(net.op_param, mem_map, block_out)\n    else:\n        new_param = net.op_param\n\n    new_net = LogicNet(net.op, new_param, args=new_args, dests=new_dests)\n    block_out.add_net(new_net)", "response": "This function copies a LogicNet to the block_out"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the instance of the memory in the new block that is associated with a memory in a old block that is not already in the mem_map.", "response": "def _get_new_block_mem_instance(op_param, mem_map, block_out):\n    \"\"\" gets the instance of the memory in the new block that is\n    associated with a memory in a old block\n    \"\"\"\n    memid, old_mem = op_param\n    if old_mem not in mem_map:\n        new_mem = old_mem._make_copy(block_out)\n        new_mem.id = old_mem.id\n        mem_map[old_mem] = new_mem\n    return memid, mem_map[old_mem]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint useful information about a WireVector when in debug mode.", "response": "def probe(w, name=None):\n    \"\"\" Print useful information about a WireVector when in debug mode.\n\n    :param w: WireVector from which to get info\n    :param name: optional name for probe (defaults to an autogenerated name)\n    :return: original WireVector w\n\n    Probe can be inserted into a existing design easily as it returns the\n    original wire unmodified. For example ``y <<= x[0:3] + 4`` could be turned\n    into ``y <<= probe(x)[0:3] + 4`` to give visibility into both the origin of\n    ``x`` (including the line that WireVector was originally created) and\n    the run-time values of ``x`` (which will be named and thus show up by\n    default in a trace.  Likewise ``y <<= probe(x[0:3]) + 4``,\n    ``y <<= probe(x[0:3] + 4)``, and ``probe(y) <<= x[0:3] + 4`` are all\n    valid uses of `probe`.\n\n    Note: `probe` does actually add a wire to the working block of w (which can\n    confuse various post-processing transforms such as output to verilog).\n    \"\"\"\n    if not isinstance(w, WireVector):\n        raise PyrtlError('Only WireVectors can be probed')\n\n    if name is None:\n        name = '(%s: %s)' % (probeIndexer.make_valid_string(), w.name)\n    print(\"Probe: \" + name + ' ' + get_stack(w))\n\n    p = Output(name=name)\n    p <<= w  # late assigns len from w automatically\n    return w"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rtl_assert(w, exp, block=None):\n    block = working_block(block)\n\n    if not isinstance(w, WireVector):\n        raise PyrtlError('Only WireVectors can be asserted with rtl_assert')\n    if len(w) != 1:\n        raise PyrtlError('rtl_assert checks only a WireVector of bitwidth 1')\n    if not isinstance(exp, Exception):\n        raise PyrtlError('the second argument to rtl_assert must be an instance of Exception')\n    if isinstance(exp, KeyError):\n        raise PyrtlError('the second argument to rtl_assert cannot be a KeyError')\n    if w not in block.wirevector_set:\n        raise PyrtlError('assertion wire not part of the block to which it is being added')\n    if w not in block.wirevector_set:\n        raise PyrtlError('assertion not a known wirevector in the target block')\n\n    if w in block.rtl_assert_dict:\n        raise PyrtlInternalError('assertion conflicts with existing registered assertion')\n\n    assert_wire = Output(bitwidth=1, name=assertIndexer.make_valid_string(), block=block)\n    assert_wire <<= w\n    block.rtl_assert_dict[assert_wire] = exp\n    return assert_wire", "response": "Add hardware assertions to be checked on the RTL design."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the values in sim to see if any registers assertions fail.", "response": "def check_rtl_assertions(sim):\n    \"\"\" Checks the values in sim to see if any registers assertions fail.\n\n    :param sim: Simulation in which to check the assertions\n    :return: None\n    \"\"\"\n\n    for (w, exp) in sim.block.rtl_assert_dict.items():\n        try:\n            value = sim.inspect(w)\n            if not value:\n                raise exp\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nallocate and return a list of WireVectors.", "response": "def wirevector_list(names, bitwidth=None, wvtype=WireVector):\n    \"\"\" Allocate and return a list of WireVectors.\n\n    :param names: Names for the WireVectors. Can be a list or single comma/space-separated string\n    :param bitwidth: The desired bitwidth for the resulting WireVectors.\n    :param WireVector wvtype: Which WireVector type to create.\n    :return: List of WireVectors.\n\n    Additionally, the ``names`` string can also contain an additional bitwidth specification\n    separated by a ``/`` in the name. This cannot be used in combination with a ``bitwidth``\n    value other than ``1``.\n\n    Examples: ::\n\n        wirevector_list(['name1', 'name2', 'name3'])\n        wirevector_list('name1, name2, name3')\n        wirevector_list('input1 input2 input3', bitwidth=8, wvtype=pyrtl.wire.Input)\n        wirevector_list('output1, output2 output3', bitwidth=3, wvtype=pyrtl.wire.Output)\n        wirevector_list('two_bits/2, four_bits/4, eight_bits/8')\n        wirevector_list(['name1', 'name2', 'name3'], bitwidth=[2, 4, 8])\n\n    \"\"\"\n    if isinstance(names, str):\n        names = names.replace(',', ' ').split()\n\n    if any('/' in name for name in names) and bitwidth is not None:\n        raise PyrtlError('only one of optional \"/\" or bitwidth parameter allowed')\n\n    if bitwidth is None:\n        bitwidth = 1\n    if isinstance(bitwidth, numbers.Integral):\n        bitwidth = [bitwidth]*len(names)\n    if len(bitwidth) != len(names):\n        raise ValueError('number of names ' + str(len(names))\n                         + ' should match number of bitwidths ' + str(len(bitwidth)))\n\n    wirelist = []\n    for fullname, bw in zip(names, bitwidth):\n        try:\n            name, bw = fullname.split('/')\n        except ValueError:\n            name, bw = fullname, bw\n        wirelist.append(wvtype(bitwidth=int(bw), name=name))\n    return wirelist"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a python integer into a signed integer under twos complement.", "response": "def val_to_signed_integer(value, bitwidth):\n    \"\"\" Return value as intrepreted as a signed integer under twos complement.\n\n    :param value: a python integer holding the value to convert\n    :param bitwidth: the length of the integer in bits to assume for conversion\n\n    Given an unsigned integer (not a wirevector!) covert that to a signed\n    integer.  This is useful for printing and interpreting values which are\n    negative numbers in twos complement. ::\n\n        val_to_signed_integer(0xff, 8) == -1\n    \"\"\"\n    if isinstance(value, WireVector) or isinstance(bitwidth, WireVector):\n        raise PyrtlError('inputs must not be wirevectors')\n    if bitwidth < 1:\n        raise PyrtlError('bitwidth must be a positive integer')\n\n    neg_mask = 1 << (bitwidth - 1)\n    neg_part = value & neg_mask\n\n    pos_mask = neg_mask - 1\n    pos_part = value & pos_mask\n\n    return pos_part - neg_part"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a string containing a format string to an unsigned integer.", "response": "def formatted_str_to_val(data, format, enum_set=None):\n    \"\"\" Return an unsigned integer representation of the data given format specified.\n\n    :param data: a string holding the value to convert\n    :param format: a string holding a format which will be used to convert the data string\n    :param enum_set: an iterable of enums which are used as part of the converstion process\n\n    Given a string (not a wirevector!) covert that to an unsigned integer ready for input\n    to the simulation enviornment.  This helps deal with signed/unsigned numbers (simulation\n    assumes the values have been converted via two's complement already), but it also takes\n    hex, binary, and enum types as inputs.  It is easiest to see how it works with some\n    examples. ::\n\n        formatted_str_to_val('2', 's3') == 2  # 0b010\n        formatted_str_to_val('-1', 's3') == 7  # 0b111\n        formatted_str_to_val('101', 'b3') == 5\n        formatted_str_to_val('5', 'u3') == 5\n        formatted_str_to_val('-3', 's3') == 5\n        formatted_str_to_val('a', 'x3') == 10\n        class Ctl(Enum):\n            ADD = 5\n            SUB = 12\n        formatted_str_to_val('ADD', 'e3/Ctl', [Ctl]) == 5\n        formatted_str_to_val('SUB', 'e3/Ctl', [Ctl]) == 12\n\n    \"\"\"\n    type = format[0]\n    bitwidth = int(format[1:].split('/')[0])\n    bitmask = (1 << bitwidth)-1\n    if type == 's':\n        rval = int(data) & bitmask\n    elif type == 'x':\n        rval = int(data, 16)\n    elif type == 'b':\n        rval = int(data, 2)\n    elif type == 'u':\n        rval = int(data)\n        if rval < 0:\n            raise PyrtlError('unsigned format requested, but negative value provided')\n    elif type == 'e':\n        enumname = format.split('/')[1]\n        enum_inst_list = [e for e in enum_set if e.__name__ == enumname]\n        if len(enum_inst_list) == 0:\n            raise PyrtlError('enum \"{}\" not found in passed enum_set \"{}\"'\n                             .format(enumname, enum_set))\n        rval = getattr(enum_inst_list[0], data).value\n    else:\n        raise PyrtlError('unknown format type {}'.format(format))\n    return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the value in format to a string representation of the value in format specified.", "response": "def val_to_formatted_str(val, format, enum_set=None):\n    \"\"\" Return a string representation of the value given format specified.\n\n    :param val: a string holding an unsigned integer to convert\n    :param format: a string holding a format which will be used to convert the data string\n    :param enum_set: an iterable of enums which are used as part of the converstion process\n\n    Given an unsigned integer (not a wirevector!) covert that to a strong ready for output\n    to a human to interpret.  This helps deal with signed/unsigned numbers (simulation\n    operates on values that have been converted via two's complement), but it also generates\n    hex, binary, and enum types as outputs.  It is easiest to see how it works with some\n    examples. ::\n\n        formatted_str_to_val(2, 's3') == '2'\n        formatted_str_to_val(7, 's3') == '-1'\n        formatted_str_to_val(5, 'b3') == '101'\n        formatted_str_to_val(5, 'u3') == '5'\n        formatted_str_to_val(5, 's3') == '-3'\n        formatted_str_to_val(10, 'x3') == 'a'\n        class Ctl(Enum):\n            ADD = 5\n            SUB = 12\n        formatted_str_to_val('ADD', 'e3/Ctl', [Ctl]) == 5\n        formatted_str_to_val('SUB', 'e3/Ctl', [Ctl]) == 12\n\n    \"\"\"\n    type = format[0]\n    bitwidth = int(format[1:].split('/')[0])\n    bitmask = (1 << bitwidth)-1\n    if type == 's':\n        rval = str(val_to_signed_integer(val, bitwidth))\n    elif type == 'x':\n        rval = hex(val)[2:]  # cuts off '0x' at the start\n    elif type == 'b':\n        rval = bin(val)[2:]  # cuts off '0b' at the start\n    elif type == 'u':\n        rval = str(int(val))  # nothing fancy\n    elif type == 'e':\n        enumname = format.split('/')[1]\n        enum_inst_list = [e for e in enum_set if e.__name__ == enumname]\n        if len(enum_inst_list) == 0:\n            raise PyrtlError('enum \"{}\" not found in passed enum_set \"{}\"'\n                             .format(enumname, enum_set))\n        rval = enum_inst_list[0](val).name\n    else:\n        raise PyrtlError('unknown format type {}'.format(format))\n    return rval"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns whether a block has less nets than before", "response": "def shrank(self, block=None, percent_diff=0, abs_diff=1):\n        \"\"\"\n        Returns whether a block has less nets than before\n\n        :param Block block: block to check (if changed)\n        :param Number percent_diff: percentage difference threshold\n        :param int abs_diff: absolute difference threshold\n        :return: boolean\n\n        This function checks whether the change in the number of\n        nets is greater than the percentage and absolute difference\n        thresholds.\n        \"\"\"\n        if block is None:\n            block = self.block\n        cur_nets = len(block.logic)\n        net_goal = self.prev_nets * (1 - percent_diff) - abs_diff\n        less_nets = (cur_nets <= net_goal)\n        self.prev_nets = cur_nets\n        return less_nets"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a Kogge - Stone adder given two WireVectors a and b.", "response": "def kogge_stone(a, b, cin=0):\n    \"\"\"\n    Creates a Kogge-Stone adder given two inputs\n\n    :param WireVector a, b: The two WireVectors to add up (bitwidths don't need to match)\n    :param cin: An optimal carry in WireVector or value\n    :return: a Wirevector representing the output of the adder\n\n    The Kogge-Stone adder is a fast tree-based adder with O(log(n))\n    propagation delay, useful for performance critical designs. However,\n    it has O(n log(n)) area usage, and large fan out.\n    \"\"\"\n    a, b = libutils.match_bitwidth(a, b)\n\n    prop_orig = a ^ b\n    prop_bits = [i for i in prop_orig]\n    gen_bits = [i for i in a & b]\n    prop_dist = 1\n\n    # creation of the carry calculation\n    while prop_dist < len(a):\n        for i in reversed(range(prop_dist, len(a))):\n            prop_old = prop_bits[i]\n            gen_bits[i] = gen_bits[i] | (prop_old & gen_bits[i - prop_dist])\n            if i >= prop_dist * 2:  # to prevent creating unnecessary nets and wires\n                prop_bits[i] = prop_old & prop_bits[i - prop_dist]\n        prop_dist *= 2\n\n    # assembling the result of the addition\n    # preparing the cin (and conveniently shifting the gen bits)\n    gen_bits.insert(0, pyrtl.as_wires(cin))\n    return pyrtl.concat_list(gen_bits) ^ prop_orig"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd two wirevectors up in an efficient manner.", "response": "def carrysave_adder(a, b, c, final_adder=ripple_add):\n    \"\"\"\n    Adds three wirevectors up in an efficient manner\n    :param WireVector a, b, c : the three wires to add up\n    :param function final_adder : The adder to use to do the final addition\n    :return: a wirevector with length 2 longer than the largest input\n    \"\"\"\n    a, b, c = libutils.match_bitwidth(a, b, c)\n    partial_sum = a ^ b ^ c\n    shift_carry = (a | b) & (a | c) & (b | c)\n    return pyrtl.concat(final_adder(partial_sum[1:], shift_carry), partial_sum[0])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cla_adder(a, b, cin=0, la_unit_len=4):\n    a, b = pyrtl.match_bitwidth(a, b)\n    if len(a) <= la_unit_len:\n        sum, cout = _cla_adder_unit(a, b, cin)\n        return pyrtl.concat(cout, sum)\n    else:\n        sum, cout = _cla_adder_unit(a[0:la_unit_len], b[0:la_unit_len], cin)\n        msbits = cla_adder(a[la_unit_len:], b[la_unit_len:], cout, la_unit_len)\n        return pyrtl.concat(msbits, sum)", "response": "A simple algorithm for calculating the carry bits of a single ripple adder."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _cla_adder_unit(a, b, cin):\n    gen = a & b\n    prop = a ^ b\n    assert(len(prop) == len(gen))\n\n    carry = [gen[0] | prop[0] & cin]\n    sum_bit = prop[0] ^ cin\n\n    cur_gen = gen[0]\n    cur_prop = prop[0]\n    for i in range(1, len(prop)):\n        cur_gen = gen[i] | (prop[i] & cur_gen)\n        cur_prop = cur_prop & prop[i]\n        sum_bit = pyrtl.concat(prop[i] ^ carry[i - 1], sum_bit)\n        carry.append(gen[i] | (prop[i] & carry[i-1]))\n    cout = cur_gen | (cur_prop & cin)\n    return sum_bit, cout", "response": "This function calculates the cout signal and the gen and propogation signals for the next unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a write port.", "response": "def _build(self, addr, data, enable):\n        \"\"\" Builds a write port. \"\"\"\n        if self.max_write_ports is not None:\n            self.write_ports += 1\n            if self.write_ports > self.max_write_ports:\n                raise PyrtlError('maximum number of write ports (%d) exceeded' %\n                                 self.max_write_ports)\n        writeport_net = LogicNet(\n            op='@',\n            op_param=(self.id, self),\n            args=(addr, data, enable),\n            dests=tuple())\n        working_block().add_net(writeport_net)\n        self.writeport_nets.append(writeport_net)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a single cycle AES Encryption circuit containing the plaintext and the AES key.", "response": "def encryption(self, plaintext, key):\n        \"\"\"\n        Builds a single cycle AES Encryption circuit\n\n        :param WireVector plaintext: text to encrypt\n        :param WireVector key: AES key to use to encrypt\n        :return: a WireVector containing the ciphertext\n\n        \"\"\"\n        if len(plaintext) != self._key_len:\n            raise pyrtl.PyrtlError(\"Ciphertext length is invalid\")\n        if len(key) != self._key_len:\n            raise pyrtl.PyrtlError(\"key length is invalid\")\n\n        key_list = self._key_gen(key)\n        t = self._add_round_key(plaintext, key_list[0])\n\n        for round in range(1, 11):\n            t = self._sub_bytes(t)\n            t = self._shift_rows(t)\n            if round != 10:\n                t = self._mix_columns(t)\n            t = self._add_round_key(t, key_list[round])\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a multiple cycle AES Encryption state machine.", "response": "def encrypt_state_m(self, plaintext_in, key_in, reset):\n        \"\"\"\n        Builds a multiple cycle AES Encryption state machine circuit\n\n        :param reset: a one bit signal telling the state machine\n          to reset and accept the current plaintext and key\n        :return ready, cipher_text: ready is a one bit signal showing\n          that the encryption result (cipher_text) has been calculated.\n\n        \"\"\"\n        if len(key_in) != len(plaintext_in):\n            raise pyrtl.PyrtlError(\"AES key and plaintext should be the same length\")\n\n        plain_text, key = (pyrtl.Register(len(plaintext_in)) for i in range(2))\n        key_exp_in, add_round_in = (pyrtl.WireVector(len(plaintext_in)) for i in range(2))\n\n        counter = pyrtl.Register(4, 'counter')\n        round = pyrtl.WireVector(4, 'round')\n        counter.next <<= round\n        sub_out = self._sub_bytes(plain_text)\n        shift_out = self._shift_rows(sub_out)\n        mix_out = self._mix_columns(shift_out)\n        key_out = self._key_expansion(key, counter)\n        add_round_out = self._add_round_key(add_round_in, key_exp_in)\n        with pyrtl.conditional_assignment:\n            with reset == 1:\n                round |= 0\n                key_exp_in |= key_in  # to lower the number of cycles\n                plain_text.next |= add_round_out\n                key.next |= key_in\n                add_round_in |= plaintext_in\n\n            with counter == 10:  # keep everything the same\n                round |= counter\n                plain_text.next |= plain_text\n\n            with pyrtl.otherwise:  # running through AES\n                round |= counter + 1\n                key_exp_in |= key_out\n                plain_text.next |= add_round_out\n                key.next |= key_out\n                with counter == 9:\n                    add_round_in |= shift_out\n                with pyrtl.otherwise:\n                    add_round_in |= mix_out\n\n        ready = (counter == 10)\n        return ready, plain_text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a single cycle AES Decryption circuit containing the plaintext data.", "response": "def decryption(self, ciphertext, key):\n        \"\"\"\n        Builds a single cycle AES Decryption circuit\n\n        :param WireVector ciphertext: data to decrypt\n        :param WireVector key: AES key to use to encrypt (AES is symmetric)\n        :return: a WireVector containing the plaintext\n        \"\"\"\n        if len(ciphertext) != self._key_len:\n            raise pyrtl.PyrtlError(\"Ciphertext length is invalid\")\n        if len(key) != self._key_len:\n            raise pyrtl.PyrtlError(\"key length is invalid\")\n        key_list = self._key_gen(key)\n        t = self._add_round_key(ciphertext, key_list[10])\n\n        for round in range(1, 11):\n            t = self._inv_shift_rows(t)\n            t = self._sub_bytes(t, True)\n            t = self._add_round_key(t, key_list[10 - round])\n            if round != 10:\n                t = self._mix_columns(t, True)\n\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decryption_statem(self, ciphertext_in, key_in, reset):\n        if len(key_in) != len(ciphertext_in):\n            raise pyrtl.PyrtlError(\"AES key and ciphertext should be the same length\")\n\n        cipher_text, key = (pyrtl.Register(len(ciphertext_in)) for i in range(2))\n        key_exp_in, add_round_in = (pyrtl.WireVector(len(ciphertext_in)) for i in range(2))\n\n        # this is not part of the state machine as we need the keys in\n        # reverse order...\n        reversed_key_list = reversed(self._key_gen(key_exp_in))\n\n        counter = pyrtl.Register(4, 'counter')\n        round = pyrtl.WireVector(4)\n        counter.next <<= round\n\n        inv_shift = self._inv_shift_rows(cipher_text)\n        inv_sub = self._sub_bytes(inv_shift, True)\n        key_out = pyrtl.mux(round, *reversed_key_list, default=0)\n        add_round_out = self._add_round_key(add_round_in, key_out)\n        inv_mix_out = self._mix_columns(add_round_out, True)\n\n        with pyrtl.conditional_assignment:\n            with reset == 1:\n                round |= 0\n                key.next |= key_in\n                key_exp_in |= key_in  # to lower the number of cycles needed\n                cipher_text.next |= add_round_out\n                add_round_in |= ciphertext_in\n\n            with counter == 10:  # keep everything the same\n                round |= counter\n                cipher_text.next |= cipher_text\n\n            with pyrtl.otherwise:  # running through AES\n                round |= counter + 1\n\n                key.next |= key\n                key_exp_in |= key\n                add_round_in |= inv_sub\n                with counter == 9:\n                    cipher_text.next |= add_round_out\n                with pyrtl.otherwise:\n                    cipher_text.next |= inv_mix_out\n\n        ready = (counter == 10)\n        return ready, cipher_text", "response": "Builds a multiple cycle AES Decryption state machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _g(self, word, key_expand_round):\n        import numbers\n        self._build_memories_if_not_exists()\n        a = libutils.partition_wire(word, 8)\n        sub = [self.sbox[a[index]] for index in (3, 0, 1, 2)]\n        if isinstance(key_expand_round, numbers.Number):\n            rcon_data = self._rcon_data[key_expand_round + 1]  # int value\n        else:\n            rcon_data = self.rcon[key_expand_round + 1]\n        sub[3] = sub[3] ^ rcon_data\n        return pyrtl.concat_list(sub)", "response": "One - byte left circular rotation substitution of each byte\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshallowing dictionary merge Args: a: dict to extend b: dict to apply to a Returns: new instance of the same type as _a_, with _a_ and _b_ merged.", "response": "def extend(*args):\n    \"\"\"shallow dictionary merge\n\n    Args:\n        a: dict to extend\n        b: dict to apply to a\n\n    Returns:\n        new instance of the same type as _a_, with _a_ and _b_ merged.\n    \"\"\"\n    if not args:\n        return {}\n\n    first = args[0]\n    rest = args[1:]\n    out = type(first)(first)\n    for each in rest:\n        out.update(each)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef input_from_blif(blif, block=None, merge_io_vectors=True):\n    import pyparsing\n    import six\n    from pyparsing import (Word, Literal, OneOrMore, ZeroOrMore,\n                           Suppress, Group, Keyword)\n\n    block = working_block(block)\n\n    try:\n        blif_string = blif.read()\n    except AttributeError:\n        if isinstance(blif, six.string_types):\n            blif_string = blif\n        else:\n            raise PyrtlError('input_blif expecting either open file or string')\n\n    def SKeyword(x):\n        return Suppress(Keyword(x))\n\n    def SLiteral(x):\n        return Suppress(Literal(x))\n\n    def twire(x):\n        \"\"\" find or make wire named x and return it \"\"\"\n        s = block.get_wirevector_by_name(x)\n        if s is None:\n            s = WireVector(bitwidth=1, name=x)\n        return s\n\n    # Begin BLIF language definition\n    signal_start = pyparsing.alphas + '$:[]_<>\\\\\\/'\n    signal_middle = pyparsing.alphas + pyparsing.nums + '$:[]_<>\\\\\\/.'\n    signal_id = Word(signal_start, signal_middle)\n    header = SKeyword('.model') + signal_id('model_name')\n    input_list = Group(SKeyword('.inputs') + OneOrMore(signal_id))('input_list')\n    output_list = Group(SKeyword('.outputs') + OneOrMore(signal_id))('output_list')\n\n    cover_atom = Word('01-')\n    cover_list = Group(ZeroOrMore(cover_atom))('cover_list')\n    namesignal_list = Group(OneOrMore(signal_id))('namesignal_list')\n    name_def = Group(SKeyword('.names') + namesignal_list + cover_list)('name_def')\n\n    # asynchronous Flip-flop\n    dffas_formal = (SLiteral('C=') + signal_id('C') +\n                    SLiteral('R=') + signal_id('R') +\n                    SLiteral('D=') + signal_id('D') +\n                    SLiteral('Q=') + signal_id('Q'))\n    dffas_keyword = SKeyword('$_DFF_PN0_') | SKeyword('$_DFF_PP0_')\n    dffas_def = Group(SKeyword('.subckt') + dffas_keyword + dffas_formal)('dffas_def')\n\n    # synchronous Flip-flop\n    dffs_def = Group(SKeyword('.latch') +\n                     signal_id('D') +\n                     signal_id('Q') +\n                     SLiteral('re') +\n                     signal_id('C'))('dffs_def')\n    command_def = name_def | dffas_def | dffs_def\n    command_list = Group(OneOrMore(command_def))('command_list')\n\n    footer = SKeyword('.end')\n    model_def = Group(header + input_list + output_list + command_list + footer)\n    model_list = OneOrMore(model_def)\n    parser = model_list.ignore(pyparsing.pythonStyleComment)\n\n    # Begin actually reading and parsing the BLIF file\n    result = parser.parseString(blif_string, parseAll=True)\n    # Blif file with multiple models (currently only handles one flattened models)\n    assert(len(result) == 1)\n    clk_set = set([])\n    ff_clk_set = set([])\n\n    def extract_inputs(model):\n        start_names = [re.sub(r'\\[([0-9]+)\\]$', '', x) for x in model['input_list']]\n        name_counts = collections.Counter(start_names)\n        for input_name in name_counts:\n            bitwidth = name_counts[input_name]\n            if input_name == 'clk':\n                clk_set.add(input_name)\n            elif not merge_io_vectors or bitwidth == 1:\n                block.add_wirevector(Input(bitwidth=1, name=input_name))\n            else:\n                wire_in = Input(bitwidth=bitwidth, name=input_name, block=block)\n                for i in range(bitwidth):\n                    bit_name = input_name + '[' + str(i) + ']'\n                    bit_wire = WireVector(bitwidth=1, name=bit_name, block=block)\n                    bit_wire <<= wire_in[i]\n\n    def extract_outputs(model):\n        start_names = [re.sub(r'\\[([0-9]+)\\]$', '', x) for x in model['output_list']]\n        name_counts = collections.Counter(start_names)\n        for output_name in name_counts:\n            bitwidth = name_counts[output_name]\n            if not merge_io_vectors or bitwidth == 1:\n                block.add_wirevector(Output(bitwidth=1, name=output_name))\n            else:\n                wire_out = Output(bitwidth=bitwidth, name=output_name, block=block)\n                bit_list = []\n                for i in range(bitwidth):\n                    bit_name = output_name + '[' + str(i) + ']'\n                    bit_wire = WireVector(bitwidth=1, name=bit_name, block=block)\n                    bit_list.append(bit_wire)\n                wire_out <<= concat(*bit_list)\n\n    def extract_commands(model):\n        # for each \"command\" (dff or net) in the model\n        for command in model['command_list']:\n            # if it is a net (specified as a cover)\n            if command.getName() == 'name_def':\n                extract_cover(command)\n            # else if the command is a d flop flop\n            elif command.getName() == 'dffas_def' or command.getName() == 'dffs_def':\n                extract_flop(command)\n            else:\n                raise PyrtlError('unknown command type')\n\n    def extract_cover(command):\n        netio = command['namesignal_list']\n        if len(command['cover_list']) == 0:\n            output_wire = twire(netio[0])\n            output_wire <<= Const(0, bitwidth=1, block=block)  # const \"FALSE\"\n        elif command['cover_list'].asList() == ['1']:\n            output_wire = twire(netio[0])\n            output_wire <<= Const(1, bitwidth=1, block=block)  # const \"TRUE\"\n        elif command['cover_list'].asList() == ['1', '1']:\n            # Populate clock list if one input is already a clock\n            if(netio[1] in clk_set):\n                clk_set.add(netio[0])\n            elif(netio[0] in clk_set):\n                clk_set.add(netio[1])\n            else:\n                output_wire = twire(netio[1])\n                output_wire <<= twire(netio[0])  # simple wire\n        elif command['cover_list'].asList() == ['0', '1']:\n            output_wire = twire(netio[1])\n            output_wire <<= ~ twire(netio[0])  # not gate\n        elif command['cover_list'].asList() == ['11', '1']:\n            output_wire = twire(netio[2])\n            output_wire <<= twire(netio[0]) & twire(netio[1])  # and gate\n        elif command['cover_list'].asList() == ['00', '1']:\n            output_wire = twire(netio[2])\n            output_wire <<= ~ (twire(netio[0]) | twire(netio[1]))  # nor gate\n        elif command['cover_list'].asList() == ['1-', '1', '-1', '1']:\n            output_wire = twire(netio[2])\n            output_wire <<= twire(netio[0]) | twire(netio[1])  # or gate\n        elif command['cover_list'].asList() == ['10', '1', '01', '1']:\n            output_wire = twire(netio[2])\n            output_wire <<= twire(netio[0]) ^ twire(netio[1])  # xor gate\n        elif command['cover_list'].asList() == ['1-0', '1', '-11', '1']:\n            output_wire = twire(netio[3])\n            output_wire <<= (twire(netio[0]) & ~ twire(netio[2])) \\\n                | (twire(netio[1]) & twire(netio[2]))   # mux\n        elif command['cover_list'].asList() == ['-00', '1', '0-0', '1']:\n            output_wire = twire(netio[3])\n            output_wire <<= (~twire(netio[1]) & ~twire(netio[2])) \\\n                | (~twire(netio[0]) & ~twire(netio[2]))\n        else:\n            raise PyrtlError('Blif file with unknown logic cover set \"%s\"'\n                             '(currently gates are hard coded)' % command['cover_list'])\n\n    def extract_flop(command):\n        if(command['C'] not in ff_clk_set):\n            ff_clk_set.add(command['C'])\n\n        # Create register and assign next state to D and output to Q\n        regname = command['Q'] + '_reg'\n        flop = Register(bitwidth=1, name=regname)\n        flop.next <<= twire(command['D'])\n        flop_output = twire(command['Q'])\n        flop_output <<= flop\n\n    for model in result:\n        extract_inputs(model)\n        extract_outputs(model)\n        extract_commands(model)", "response": "Read a string of blif file or string as input updating the block appropriately"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef output_to_firrtl(open_file, rom_blocks=None, block=None):\n    block = working_block(block)\n    f = open_file\n    # write out all the implicit stuff\n    f.write(\"circuit Example : \\n\")\n    f.write(\"  module Example : \\n\")\n    f.write(\"    input clock : Clock\\n    input reset : UInt<1>\\n\")\n    # write out IO signals, wires and registers\n    wireRegDefs = \"\"\n    for wire in list(block.wirevector_subset()):\n        if type(wire) == Input:\n            f.write(\"    input %s : UInt<%d>\\n\" % (wire.name, wire.bitwidth))\n        elif type(wire) == Output:\n            f.write(\"    output %s : UInt<%d>\\n\" % (wire.name, wire.bitwidth))\n        elif type(wire) == WireVector:\n            wireRegDefs += \"    wire {} : UInt<{}>\\n\".format(wire.name, wire.bitwidth)\n        elif type(wire) == Register:\n            wireRegDefs += \"    reg {} : UInt<{}>, clock\\n\".format(wire.name, wire.bitwidth)\n        elif type(wire) == Const:\n            # some const is in the form like const_0_1'b1, is this legal operation?\n            wire.name = wire.name.split(\"'\").pop(0)\n            wireRegDefs += \"    node {} = UInt<{}>({})\\n\".format(wire.name, wire.bitwidth, wire.val)\n        else:\n            return 1\n    f.write(wireRegDefs)\n    f.write(\"\\n\")\n\n    # write \"Main\"\n    node_cntr = 0\n    initializedMem = []\n    for log_net in list(block.logic_subset()):\n        if log_net.op == '&':\n            f.write(\"    %s <= and(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == '|':\n            f.write(\"    %s <= or(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                log_net.args[1].name))\n        elif log_net.op == '^':\n            f.write(\"    %s <= xor(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == 'n':\n            f.write(\"    node T_%d = and(%s, %s)\\n\" % (node_cntr, log_net.args[0].name,\n                                                       log_net.args[1].name))\n            f.write(\"    %s <= not(T_%d)\\n\" % (log_net.dests[0].name, node_cntr))\n            node_cntr += 1\n        elif log_net.op == '~':\n            f.write(\"    %s <= not(%s)\\n\" % (log_net.dests[0].name, log_net.args[0].name))\n        elif log_net.op == '+':\n            f.write(\"    %s <= add(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == '-':\n            f.write(\"    %s <= sub(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == '*':\n            f.write(\"    %s <= mul(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == '=':\n            f.write(\"    %s <= eq(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                log_net.args[1].name))\n        elif log_net.op == '<':\n            f.write(\"    %s <= lt(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                log_net.args[1].name))\n        elif log_net.op == '>':\n            f.write(\"    %s <= gt(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                log_net.args[1].name))\n        elif log_net.op == 'w':\n            f.write(\"    %s <= %s\\n\" % (log_net.dests[0].name, log_net.args[0].name))\n        elif log_net.op == 'x':\n            f.write(\"    %s <= mux(%s, %s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                     log_net.args[2].name, log_net.args[1].name))\n        elif log_net.op == 'c':\n            f.write(\"    %s <= cat(%s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                 log_net.args[1].name))\n        elif log_net.op == 's':\n            selEnd = log_net.op_param[0]\n            if len(log_net.op_param) < 2:\n                selBegin = selEnd\n            else:\n                selBegin = log_net.op_param[len(log_net.op_param)-1]\n            f.write(\"    %s <= bits(%s, %s, %s)\\n\" % (log_net.dests[0].name, log_net.args[0].name,\n                                                      selBegin, selEnd))\n        elif log_net.op == 'r':\n            f.write(\"    %s <= mux(reset, UInt<%s>(0), %s)\\n\" %\n                    (log_net.dests[0].name, log_net.dests[0].bitwidth, log_net.args[0].name))\n        elif log_net.op == 'm':\n            # if there are rom blocks, need to be initialized\n            if rom_blocks is not None:\n                if not log_net.op_param[0] in initializedMem:\n                    initializedMem.append(log_net.op_param[0])\n\n                    # find corresponding rom block according to memid\n                    curr_rom = next((x for x in rom_blocks if x.id == log_net.op_param[0]), None)\n                    f.write(\"    wire %s : UInt<%s>[%s]\\n\" %\n                            (log_net.op_param[1].name, log_net.op_param[1].bitwidth,\n                             2**log_net.op_param[1].addrwidth))\n\n                    # if rom data is a function, calculate the data first\n                    if callable(curr_rom.data):\n                        romdata = [curr_rom.data(i) for i in range(2**curr_rom.addrwidth)]\n                        curr_rom.data = romdata\n\n                    # write rom block initialization data\n                    for i in range(len(curr_rom.data)):\n                        f.write(\"    %s[%s] <= UInt<%s>(%s)\\n\" %\n                                (log_net.op_param[1].name, i, log_net.op_param[1].bitwidth,\n                                 curr_rom.data[i]))\n\n                # write the connection\n                f.write(\"    %s <= %s[%s]\\n\" % (log_net.dests[0].name, log_net.op_param[1].name,\n                                                log_net.args[0].name))\n\n            else:\n                if not log_net.op_param[0] in initializedMem:\n                    initializedMem.append(log_net.op_param[0])\n                    f.write(\"    cmem %s_%s : UInt<%s>[%s]\\n\" %\n                            (log_net.op_param[1].name, log_net.op_param[0],\n                             log_net.op_param[1].bitwidth, 2**log_net.op_param[1].addrwidth))\n                f.write(\"    infer mport T_%d  = %s_%s[%s], clock\\n\" %\n                        (node_cntr, log_net.op_param[1].name, log_net.op_param[0],\n                         log_net.args[0].name))\n                f.write(\"    %s <= T_%d\\n\" % (log_net.dests[0].name, node_cntr))\n                node_cntr += 1\n        elif log_net.op == '@':\n            if not log_net.op_param[0] in initializedMem:\n                initializedMem.append(log_net.op_param[0])\n                f.write(\"    cmem %s_%s : UInt<%s>[%s]\\n\" %\n                        (log_net.op_param[1].name, log_net.op_param[0],\n                         log_net.op_param[1].bitwidth, 2**log_net.op_param[1].addrwidth))\n            f.write(\"    when %s :\\n\" % log_net.args[2].name)\n            f.write(\"      infer mport T_%d  = %s_%s[%s], clock\\n\" %\n                    (node_cntr, log_net.op_param[1].name, log_net.op_param[0],\n                     log_net.args[0].name))\n            f.write(\"      T_%d <= %s\\n\" % (node_cntr, log_net.args[1].name))\n            f.write(\"      skip\\n\")\n            node_cntr += 1\n        else:\n            pass\n\n    f.close()\n    return 0", "response": "Output the block as firrtl code to the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _trivialgraph_default_namer(thing, is_edge=True):\n    if is_edge:\n        if thing.name is None or thing.name.startswith('tmp'):\n            return ''\n        else:\n            return '/'.join([thing.name, str(len(thing))])\n    elif isinstance(thing, Const):\n        return str(thing.val)\n    elif isinstance(thing, WireVector):\n        return thing.name or '??'\n    else:\n        try:\n            return thing.op + str(thing.op_param or '')\n        except AttributeError:\n            raise PyrtlError('no naming rule for \"%s\"' % str(thing))", "response": "Returns a good string for thing in printed graphs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a graph representation of the current block.", "response": "def net_graph(block=None, split_state=False):\n    \"\"\" Return a graph representation of the current block.\n\n    Graph has the following form:\n        { node1: { nodeA: edge1A, nodeB: edge1B},\n          node2: { nodeB: edge2B, nodeC: edge2C},\n          ...\n        }\n\n    aka: edge = graph[source][dest]\n\n    Each node can be either a logic net or a WireVector (e.g. an Input, and Output, a\n    Const or even an undriven WireVector (which acts as a source or sink in the network)\n    Each edge is a WireVector or derived type (Input, Output, Register, etc.)\n    Note that inputs, consts, and outputs will be both \"node\" and \"edge\".\n    WireVectors that are not connected to any nets are not returned as part\n    of the graph.\n    \"\"\"\n    # FIXME: make it not try to add unused wires (issue #204)\n    block = working_block(block)\n    from .wire import Register\n    # self.sanity_check()\n    graph = {}\n\n    # add all of the nodes\n    for net in block.logic:\n        graph[net] = {}\n\n    wire_src_dict, wire_dst_dict = block.net_connections()\n    dest_set = set(wire_src_dict.keys())\n    arg_set = set(wire_dst_dict.keys())\n    dangle_set = dest_set.symmetric_difference(arg_set)\n    for w in dangle_set:\n        graph[w] = {}\n    if split_state:\n        for w in block.wirevector_subset(Register):\n            graph[w] = {}\n\n    # add all of the edges\n    for w in (dest_set & arg_set):\n        try:\n            _from = wire_src_dict[w]\n        except Exception:\n            _from = w\n        if split_state and isinstance(w, Register):\n            _from = w\n\n        try:\n            _to_list = wire_dst_dict[w]\n        except Exception:\n            _to_list = [w]\n\n        for _to in _to_list:\n            graph[_from][_to] = w\n\n    return graph"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef output_to_trivialgraph(file, namer=_trivialgraph_default_namer, block=None):\n    graph = net_graph(block)\n    node_index_map = {}  # map node -> index\n\n    # print the list of nodes\n    for index, node in enumerate(graph):\n        print('%d %s' % (index, namer(node, is_edge=False)), file=file)\n        node_index_map[node] = index\n\n    print('#', file=file)\n\n    # print the list of edges\n    for _from in graph:\n        for _to in graph[_from]:\n            from_index = node_index_map[_from]\n            to_index = node_index_map[_to]\n            edge = graph[_from][_to]\n            print('%d %d %s' % (from_index, to_index, namer(edge)), file=file)", "response": "Walk the block and output it in trivial graph format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _graphviz_default_namer(thing, is_edge=True, is_to_splitmerge=False):\n    if is_edge:\n        if (thing.name is None or\n                thing.name.startswith('tmp') or\n                isinstance(thing, (Input, Output, Const, Register))):\n            name = ''\n        else:\n            name = '/'.join([thing.name, str(len(thing))])\n        penwidth = 2 if len(thing) == 1 else 6\n        arrowhead = 'none' if is_to_splitmerge else 'normal'\n        return '[label=\"%s\", penwidth=\"%d\", arrowhead=\"%s\"]' % (name, penwidth, arrowhead)\n\n    elif isinstance(thing, Const):\n        return '[label=\"%d\", shape=circle, fillcolor=lightgrey]' % thing.val\n    elif isinstance(thing, (Input, Output)):\n        return '[label=\"%s\", shape=circle, fillcolor=none]' % thing.name\n    elif isinstance(thing, Register):\n        return '[label=\"%s\", shape=square, fillcolor=gold]' % thing.name\n    elif isinstance(thing, WireVector):\n        return '[label=\"\", shape=circle, fillcolor=none]'\n    else:\n        try:\n            if thing.op == '&':\n                return '[label=\"and\"]'\n            elif thing.op == '|':\n                return '[label=\"or\"]'\n            elif thing.op == '^':\n                return '[label=\"xor\"]'\n            elif thing.op == '~':\n                return '[label=\"not\"]'\n            elif thing.op == 'x':\n                return '[label=\"mux\"]'\n            elif thing.op in 'sc':\n                return '[label=\"\", height=.1, width=.1]'\n            elif thing.op == 'r':\n                name = thing.dests[0].name or ''\n                return '[label=\"%s.next\", shape=square, fillcolor=gold]' % name\n            elif thing.op == 'w':\n                return '[label=\"buf\"]'\n            else:\n                return '[label=\"%s\"]' % (thing.op + str(thing.op_param or ''))\n        except AttributeError:\n            raise PyrtlError('no naming rule for \"%s\"' % str(thing))", "response": "Returns a graphviz label for the given thing."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwalks the block and output it in graphviz format.", "response": "def output_to_graphviz(file, namer=_graphviz_default_namer, block=None):\n    \"\"\" Walk the block and output it in graphviz format to the open file. \"\"\"\n    print(block_to_graphviz_string(block, namer), file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a graphviz string for the block.", "response": "def block_to_graphviz_string(block=None, namer=_graphviz_default_namer):\n    \"\"\" Return a graphviz string for the block. \"\"\"\n    graph = net_graph(block, split_state=True)\n    node_index_map = {}  # map node -> index\n\n    rstring = \"\"\"\\\n              digraph g {\\n\n              graph [splines=\"spline\"];\n              node [shape=circle, style=filled, fillcolor=lightblue1,\n                    fontcolor=grey, fontname=helvetica, penwidth=0,\n                    fixedsize=true];\n              edge [labelfloat=false, penwidth=2, color=deepskyblue, arrowsize=.5];\n              \"\"\"\n\n    # print the list of nodes\n    for index, node in enumerate(graph):\n        label = namer(node, is_edge=False)\n        rstring += '    n%s %s;\\n' % (index, label)\n        node_index_map[node] = index\n\n    # print the list of edges\n    for _from in graph:\n        for _to in graph[_from]:\n            from_index = node_index_map[_from]\n            to_index = node_index_map[_to]\n            edge = graph[_from][_to]\n            is_to_splitmerge = True if hasattr(_to, 'op') and _to.op in 'cs' else False\n            label = namer(edge, is_to_splitmerge=is_to_splitmerge)\n            rstring += '   n%d -> n%d %s;\\n' % (from_index, to_index, label)\n\n    rstring += '}\\n'\n    return rstring"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an SVG for the given block.", "response": "def block_to_svg(block=None):\n    \"\"\" Return an SVG for the block. \"\"\"\n    block = working_block(block)\n    try:\n        from graphviz import Source\n        return Source(block_to_graphviz_string())._repr_svg_()\n    except ImportError:\n        raise PyrtlError('need graphviz installed (try \"pip install graphviz\")')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef trace_to_html(simtrace, trace_list=None, sortkey=None):\n\n    from .simulation import SimulationTrace, _trace_sort_key\n    if not isinstance(simtrace, SimulationTrace):\n        raise PyrtlError('first arguement must be of type SimulationTrace')\n\n    trace = simtrace.trace\n    if sortkey is None:\n        sortkey = _trace_sort_key\n\n    if trace_list is None:\n        trace_list = sorted(trace, key=sortkey)\n\n    wave_template = (\n        \"\"\"\\\n        <script type=\"WaveDrom\">\n        { signal : [\n        %s\n        ]}\n        </script>\n\n        \"\"\"\n        )\n\n    def extract(w):\n        wavelist = []\n        datalist = []\n        last = None\n        for i, value in enumerate(trace[w]):\n            if last == value:\n                wavelist.append('.')\n            else:\n                if len(w) == 1:\n                    wavelist.append(str(value))\n                else:\n                    wavelist.append('=')\n                    datalist.append(value)\n                last = value\n\n        wavestring = ''.join(wavelist)\n        datastring = ', '.join(['\"%d\"' % data for data in datalist])\n        if len(w) == 1:\n            return bool_signal_template % (w, wavestring)\n        else:\n            return int_signal_template % (w, wavestring, datastring)\n\n    bool_signal_template = '{ name: \"%s\",  wave: \"%s\" },'\n    int_signal_template = '{ name: \"%s\",  wave: \"%s\", data: [%s] },'\n    signals = [extract(w) for w in trace_list]\n    all_signals = '\\n'.join(signals)\n    wave = wave_template % all_signals\n    # print(wave)\n    return wave", "response": "Return a HTML block showing the trace."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_store(reducer, initial_state=None, enhancer=None):\n    if enhancer is not None:\n        if not hasattr(enhancer, '__call__'):\n            raise TypeError('Expected the enhancer to be a function.')\n        return enhancer(create_store)(reducer, initial_state)\n\n    if not hasattr(reducer, '__call__'):\n        raise TypeError('Expected the reducer to be a function.')\n\n    # single-element arrays for r/w closure\n    current_reducer = [reducer]\n    current_state = [initial_state]\n    current_listeners = [[]]\n    next_listeners = [current_listeners[0]]\n    is_dispatching = [False]\n\n    def ensure_can_mutate_next_listeners():\n        if next_listeners[0] == current_listeners[0]:\n            next_listeners[0] = current_listeners[0][:]\n\n    def get_state():\n        return current_state[0]\n\n    def subscribe(listener):\n        if not hasattr(listener, '__call__'):\n            raise TypeError('Expected listener to be a function.')\n\n        is_subscribed = [True]  # r/w closure\n\n        ensure_can_mutate_next_listeners()\n        next_listeners[0].append(listener)\n\n        def unsubcribe():\n            if not is_subscribed[0]:\n                return\n            is_subscribed[0] = False\n\n            ensure_can_mutate_next_listeners()\n            index = next_listeners[0].index(listener)\n            next_listeners[0].pop(index)\n\n        return unsubcribe\n\n    def dispatch(action):\n        if not isinstance(action, dict):\n            raise TypeError('Actions must be a dict. '\n                            'Use custom middleware for async actions.')\n\n        if action.get('type') is None:\n            raise ValueError('Actions must have a non-None \"type\" property. '\n                             'Have you misspelled a constant?')\n\n        if is_dispatching[0]:\n            raise Exception('Reducers may not dispatch actions.')\n\n        try:\n            is_dispatching[0] = True\n            current_state[0] = current_reducer[0](current_state[0], action)\n        finally:\n            is_dispatching[0] = False\n\n        listeners = current_listeners[0] = next_listeners[0]\n        for listener in listeners:\n            listener()\n\n        return action\n\n    def replace_reducer(next_reducer):\n        if not hasattr(next_reducer, '__call__'):\n            raise TypeError('Expected next_reducer to be a function')\n\n        current_reducer[0] = next_reducer\n        dispatch({'type': ActionTypes.INIT})\n\n    dispatch({'type': ActionTypes.INIT})\n\n    return StoreDict(\n        dispatch=dispatch,\n        subscribe=subscribe,\n        get_state=get_state,\n        replace_reducer=replace_reducer,\n    )", "response": "Create a new nutshell store."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattempt to find the lowest user - level call into the pyrtl module or None if no such call is found.", "response": "def _get_useful_callpoint_name():\n    \"\"\" Attempts to find the lowest user-level call into the pyrtl module\n    :return (string, int) or None: the file name and line number respectively\n\n    This function walks back the current frame stack attempting to find the\n    first frame that is not part of the pyrtl module.  The filename (stripped\n    of path and .py extention) and line number of that call are returned.\n    This point should be the point where the user-level code is making the\n    call to some pyrtl intrisic (for example, calling \"mux\").   If the\n    attempt to find the callpoint fails for any reason, None is returned.\n    \"\"\"\n    if not _setting_slower_but_more_descriptive_tmps:\n        return None\n\n    import inspect\n    loc = None\n    frame_stack = inspect.stack()\n    try:\n        for frame in frame_stack:\n            modname = inspect.getmodule(frame[0]).__name__\n            if not modname.startswith('pyrtl.'):\n                full_filename = frame[0].f_code.co_filename\n                filename = full_filename.split('/')[-1].rstrip('.py')\n                lineno = frame[0].f_lineno\n                loc = (filename, lineno)\n                break\n    except:\n        loc = None\n    finally:\n        del frame_stack\n    return loc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the global debug mode.", "response": "def set_debug_mode(debug=True):\n    \"\"\" Set the global debug mode. \"\"\"\n    global debug_mode\n    global _setting_keep_wirevector_call_stack\n    global _setting_slower_but_more_descriptive_tmps\n    debug_mode = debug\n    _setting_keep_wirevector_call_stack = debug\n    _setting_slower_but_more_descriptive_tmps = debug"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_wirevector(self, wirevector):\n        self.sanity_check_wirevector(wirevector)\n        self.wirevector_set.add(wirevector)\n        self.wirevector_by_name[wirevector.name] = wirevector", "response": "Adds a wirevector object to the block."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_wirevector(self, wirevector):\n        self.wirevector_set.remove(wirevector)\n        del self.wirevector_by_name[wirevector.name]", "response": "Removes a wirevector object from the block."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a net to the logic of the block.", "response": "def add_net(self, net):\n        \"\"\" Add a net to the logic of the block.\n\n        The passed net, which must be of type LogicNet, is checked and then\n        added to the block.  No wires are added by this member, they must be\n        added seperately with add_wirevector.\"\"\"\n\n        self.sanity_check_net(net)\n        self.logic.add(net)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wirevector_subset(self, cls=None, exclude=tuple()):\n        if cls is None:\n            initial_set = self.wirevector_set\n        else:\n            initial_set = (x for x in self.wirevector_set if isinstance(x, cls))\n        if exclude == tuple():\n            return set(initial_set)\n        else:\n            return set(x for x in initial_set if not isinstance(x, exclude))", "response": "Return set of wirevectors filtered by the type or tuple of types provided as cls."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef logic_subset(self, op=None):\n        if op is None:\n            return self.logic\n        else:\n            return set(x for x in self.logic if x.op in op)", "response": "Return set of logicnets filtered by the type of logic op provided as op."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_wirevector_by_name(self, name, strict=False):\n        if name in self.wirevector_by_name:\n            return self.wirevector_by_name[name]\n        elif strict:\n            raise PyrtlError('error, block does not have a wirevector named %s' % name)\n        else:\n            return None", "response": "Return the wirevector with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef net_connections(self, include_virtual_nodes=False):\n        src_list = {}\n        dst_list = {}\n\n        def add_wire_src(edge, node):\n            if edge in src_list:\n                raise PyrtlError('Wire \"{}\" has multiple drivers (check for multiple assignments '\n                                 'with \"<<=\" or accidental mixing of \"|=\" and \"<<=\")'.format(edge))\n            src_list[edge] = node\n\n        def add_wire_dst(edge, node):\n            if edge in dst_list:\n                # if node in dst_list[edge]:\n                #     raise PyrtlError(\"The net already exists in the graph\")\n                dst_list[edge].append(node)\n            else:\n                dst_list[edge] = [node]\n\n        if include_virtual_nodes:\n            from .wire import Input, Output, Const\n            for wire in self.wirevector_subset((Input, Const)):\n                add_wire_src(wire, wire)\n\n            for wire in self.wirevector_subset(Output):\n                add_wire_dst(wire, wire)\n\n        for net in self.logic:\n            for arg in set(net.args):  # prevents unexpected duplicates when doing b <<= a & a\n                add_wire_dst(arg, net)\n            for dest in net.dests:\n                add_wire_src(dest, net)\n        return src_list, dst_list", "response": "Returns a dictionary that maps wire vectors to the relevant wire vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sanity_check(self):\n\n        # TODO: check that the wirevector_by_name is sane\n        from .wire import Input, Const, Output\n        from .helperfuncs import get_stack, get_stacks\n\n        # check for valid LogicNets (and wires)\n        for net in self.logic:\n            self.sanity_check_net(net)\n\n        for w in self.wirevector_subset():\n            if w.bitwidth is None:\n                raise PyrtlError(\n                    'error, missing bitwidth for WireVector \"%s\" \\n\\n %s' % (w.name, get_stack(w)))\n\n        # check for unique names\n        wirevector_names_set = set(x.name for x in self.wirevector_set)\n        if len(self.wirevector_set) != len(wirevector_names_set):\n            wirevector_names_list = [x.name for x in self.wirevector_set]\n            for w in wirevector_names_set:\n                wirevector_names_list.remove(w)\n            raise PyrtlError('Duplicate wire names found for the following '\n                             'different signals: %s' % repr(wirevector_names_list))\n\n        # check for dead input wires (not connected to anything)\n        all_input_and_consts = self.wirevector_subset((Input, Const))\n\n        # The following line also checks for duplicate wire drivers\n        wire_src_dict, wire_dst_dict = self.net_connections()\n        dest_set = set(wire_src_dict.keys())\n        arg_set = set(wire_dst_dict.keys())\n        full_set = dest_set | arg_set\n        connected_minus_allwires = full_set.difference(self.wirevector_set)\n        if len(connected_minus_allwires) > 0:\n            bad_wire_names = '\\n    '.join(str(x) for x in connected_minus_allwires)\n            raise PyrtlError('Unknown wires found in net:\\n %s \\n\\n %s' % (bad_wire_names,\n                             get_stacks(*connected_minus_allwires)))\n        allwires_minus_connected = self.wirevector_set.difference(full_set)\n        allwires_minus_connected = allwires_minus_connected.difference(all_input_and_consts)\n        #   ^ allow inputs and consts to be unconnected\n        if len(allwires_minus_connected) > 0:\n            bad_wire_names = '\\n    '.join(str(x) for x in allwires_minus_connected)\n            raise PyrtlError('Wires declared but not connected:\\n %s \\n\\n %s' % (bad_wire_names,\n                             get_stacks(*allwires_minus_connected)))\n\n        # Check for wires that are inputs to a logicNet, but are not block inputs and are never\n        # driven.\n        ins = arg_set.difference(dest_set)\n        undriven = ins.difference(all_input_and_consts)\n        if len(undriven) > 0:\n            raise PyrtlError('Wires used but never driven: %s \\n\\n %s' %\n                             ([w.name for w in undriven], get_stacks(*undriven)))\n\n        # Check for async memories not specified as such\n        self.sanity_check_memory_sync(wire_src_dict)\n\n        if debug_mode:\n            # Check for wires that are destinations of a logicNet, but are not outputs and are never\n            # used as args.\n            outs = dest_set.difference(arg_set)\n            unused = outs.difference(self.wirevector_subset(Output))\n            if len(unused) > 0:\n                names = [w.name for w in unused]\n                print('Warning: Wires driven but never used { %s } ' % names)\n                print(get_stacks(*unused))", "response": "Check that the data structures are well - formed and throw PyrtlInternalError if there is an issue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanity_check_memory_sync(self, wire_src_dict=None):\n        sync_mems = set(m for m in self.logic_subset('m') if not m.op_param[1].asynchronous)\n        if not len(sync_mems):\n            return  # nothing to check here\n\n        if wire_src_dict is None:\n            wire_src_dict, wdd = self.net_connections()\n\n        from .wire import Input, Const\n        sync_src = 'r'\n        sync_prop = 'wcs'\n        for net in sync_mems:\n            wires_to_check = list(net.args)\n            while len(wires_to_check):\n                wire = wires_to_check.pop()\n                if isinstance(wire, (Input, Const)):\n                    continue\n                src_net = wire_src_dict[wire]\n                if src_net.op == sync_src:\n                    continue\n                elif src_net.op in sync_prop:\n                    wires_to_check.extend(src_net.args)\n                else:\n                    raise PyrtlError(\n                        'memory \"%s\" is not specified as asynchronous but has an index '\n                        '\"%s\" that is not ready at the start of the cycle due to net \"%s\"'\n                        % (net.op_param[1].name, net.args[0].name, str(src_net)))", "response": "Sanity check the memory sync."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that w is a valid wirevector type.", "response": "def sanity_check_wirevector(self, w):\n        \"\"\" Check that w is a valid wirevector type. \"\"\"\n        from .wire import WireVector\n        if not isinstance(w, WireVector):\n            raise PyrtlError(\n                'error attempting to pass an input of type \"%s\" '\n                'instead of WireVector' % type(w))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks that a given net is a valid LogicNet.", "response": "def sanity_check_net(self, net):\n        \"\"\" Check that net is a valid LogicNet. \"\"\"\n        from .wire import Input, Output, Const\n        from .memory import _MemReadBase\n\n        # general sanity checks that apply to all operations\n        if not isinstance(net, LogicNet):\n            raise PyrtlInternalError('error, net must be of type LogicNet')\n        if not isinstance(net.args, tuple):\n            raise PyrtlInternalError('error, LogicNet args must be tuple')\n        if not isinstance(net.dests, tuple):\n            raise PyrtlInternalError('error, LogicNet dests must be tuple')\n        for w in net.args + net.dests:\n            self.sanity_check_wirevector(w)\n            if w._block is not self:\n                raise PyrtlInternalError('error, net references different block')\n            if w not in self.wirevector_set:\n                raise PyrtlInternalError('error, net with unknown source \"%s\"' % w.name)\n\n        # checks that input and output wirevectors are not misused\n        for w in net.dests:\n            if isinstance(w, (Input, Const)):\n                raise PyrtlInternalError('error, Inputs, Consts cannot be destinations to a net')\n        for w in net.args:\n            if isinstance(w, Output):\n                raise PyrtlInternalError('error, Outputs cannot be arguments for a net')\n\n        if net.op not in self.legal_ops:\n            raise PyrtlInternalError('error, net op \"%s\" not from acceptable set %s' %\n                                     (net.op, self.legal_ops))\n\n        # operation specific checks on arguments\n        if net.op in 'w~rsm' and len(net.args) != 1:\n            raise PyrtlInternalError('error, op only allowed 1 argument')\n        if net.op in '&|^n+-*<>=' and len(net.args) != 2:\n            raise PyrtlInternalError('error, op only allowed 2 arguments')\n        if net.op == 'x':\n            if len(net.args) != 3:\n                raise PyrtlInternalError('error, op only allowed 3 arguments')\n            if net.args[1].bitwidth != net.args[2].bitwidth:\n                raise PyrtlInternalError('error, args have mismatched bitwidths')\n            if net.args[0].bitwidth != 1:\n                raise PyrtlInternalError('error, mux select must be a single bit')\n        if net.op == '@' and len(net.args) != 3:\n            raise PyrtlInternalError('error, op only allowed 3 arguments')\n        if net.op in '&|^n+-*<>=' and net.args[0].bitwidth != net.args[1].bitwidth:\n            raise PyrtlInternalError('error, args have mismatched bitwidths')\n        if net.op in 'm@' and net.args[0].bitwidth != net.op_param[1].addrwidth:\n            raise PyrtlInternalError('error, mem addrwidth mismatch')\n        if net.op == '@' and net.args[1].bitwidth != net.op_param[1].bitwidth:\n            raise PyrtlInternalError('error, mem bitwidth mismatch')\n        if net.op == '@' and net.args[2].bitwidth != 1:\n            raise PyrtlInternalError('error, mem write enable must be 1 bit')\n\n        # operation specific checks on op_params\n        if net.op in 'w~&|^n+-*<>=xcr' and net.op_param is not None:\n            raise PyrtlInternalError('error, op_param should be None')\n        if net.op == 's':\n            if not isinstance(net.op_param, tuple):\n                raise PyrtlInternalError('error, select op requires tuple op_param')\n            for p in net.op_param:\n                if not isinstance(p, int):\n                    raise PyrtlInternalError('error, select op_param requires ints')\n                if p < 0 or p >= net.args[0].bitwidth:\n                    raise PyrtlInternalError('error, op_param out of bounds')\n        if net.op in 'm@':\n            if not isinstance(net.op_param, tuple):\n                raise PyrtlInternalError('error, mem op requires tuple op_param')\n            if len(net.op_param) != 2:\n                raise PyrtlInternalError('error, mem op requires 2 op_params in tuple')\n            if not isinstance(net.op_param[0], int):\n                raise PyrtlInternalError('error, mem op requires first operand as int')\n            if not isinstance(net.op_param[1], _MemReadBase):\n                raise PyrtlInternalError('error, mem op requires second operand of a memory type')\n\n        # check destination validity\n        if net.op in 'w~&|^nr' and net.dests[0].bitwidth > net.args[0].bitwidth:\n            raise PyrtlInternalError('error, upper bits of destination unassigned')\n        if net.op in '<>=' and net.dests[0].bitwidth != 1:\n            raise PyrtlInternalError('error, destination should be of bitwidth=1')\n        if net.op in '+-' and net.dests[0].bitwidth > net.args[0].bitwidth + 1:\n            raise PyrtlInternalError('error, upper bits of destination unassigned')\n        if net.op == '*' and net.dests[0].bitwidth > 2 * net.args[0].bitwidth:\n            raise PyrtlInternalError('error, upper bits of destination unassigned')\n        if net.op == 'x' and net.dests[0].bitwidth > net.args[1].bitwidth:\n            raise PyrtlInternalError('error, upper bits of mux output undefined')\n        if net.op == 'c' and net.dests[0].bitwidth > sum(x.bitwidth for x in net.args):\n            raise PyrtlInternalError('error, upper bits of concat output undefined')\n        if net.op == 's' and net.dests[0].bitwidth > len(net.op_param):\n            raise PyrtlInternalError('error, upper bits of select output undefined')\n        if net.op == 'm' and net.dests[0].bitwidth != net.op_param[1].bitwidth:\n            raise PyrtlInternalError('error, mem read dest bitwidth mismatch')\n        if net.op == '@' and net.dests != ():\n            raise PyrtlInternalError('error, mem write dest should be empty tuple')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_valid_string(self, string=''):\n        if not self.is_valid_str(string):\n            if string in self.val_map and not self.allow_dups:\n                raise IndexError(\"Value {} has already been given to the sanitizer\".format(string))\n            internal_name = super(_NameSanitizer, self).make_valid_string()\n            self.val_map[string] = internal_name\n            return internal_name\n        else:\n            if self.map_valid:\n                self.val_map[string] = string\n            return string", "response": "Inputting a value for the first time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a string to an array of integer values according to the base specified.", "response": "def str_to_int_array(string, base=16):\n    \"\"\"\n    Converts a string to an array of integer values according to the\n    base specified (int numbers must be whitespace delimited).\\n\n    Example: \"13 a3 3c\" => [0x13, 0xa3, 0x3c]\n\n    :return: [int]\n    \"\"\"\n\n    int_strings = string.split()\n    return [int(int_str, base) for int_str in int_strings]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a value to it s two - complement integer representation using a given bitwidth", "response": "def twos_comp_repr(val, bitwidth):\n    \"\"\"\n    Converts a value to it's two's-complement (positive) integer representation using a\n    given bitwidth (only converts the value if it is negative).\n    For use with Simulation.step() etc. in passing negative numbers, which it does not accept\n    \"\"\"\n    correctbw = abs(val).bit_length() + 1\n    if bitwidth < correctbw:\n        raise pyrtl.PyrtlError(\"please choose a larger target bitwidth\")\n    if val >= 0:\n        return val\n    else:\n        return (~abs(val) & (2**bitwidth-1)) + 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rev_twos_comp_repr(val, bitwidth):\n    valbl = val.bit_length()\n    if bitwidth < val.bit_length() or val == 2**(bitwidth-1):\n        raise pyrtl.PyrtlError(\"please choose a larger target bitwidth\")\n    if bitwidth == valbl:  # MSB is a 1, value is negative\n        return -((~val & (2**bitwidth-1)) + 1)  # flip the bits, add one, and make negative\n    else:\n        return val", "response": "Converts a two - complement represented value to a signed integer based on the provided bitwidth."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _shifted_reg_next(reg, direct, num=1):\n    if direct == 'l':\n        if num >= len(reg):\n            return 0\n        else:\n            return pyrtl.concat(reg, pyrtl.Const(0, num))\n    elif direct == 'r':\n        if num >= len(reg):\n            return 0\n        else:\n            return reg[num:]\n    else:\n        raise pyrtl.PyrtlError(\"direction must be specified with 'direct'\"\n                               \"parameter as either 'l' or 'r'\")", "response": "Returns a shifted register containing the next state in the given register."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an optimized version of a synthesized hardware block.", "response": "def optimize(update_working_block=True, block=None, skip_sanity_check=False):\n    \"\"\"\n    Return an optimized version of a synthesized hardware block.\n\n    :param Boolean update_working_block: Don't copy the block and optimize the\n    new block\n    :param Block block: the block to optimize (defaults to working block)\n\n    Note:\n    optimize works on all hardware designs, both synthesized and non synthesized\n    \"\"\"\n    block = working_block(block)\n    if not update_working_block:\n        block = copy_block(block)\n\n    with set_working_block(block, no_sanity_check=True):\n        if (not skip_sanity_check) or debug_mode:\n            block.sanity_check()\n        _remove_wire_nets(block)\n        constant_propagation(block, True)\n        _remove_unlistened_nets(block)\n        common_subexp_elimination(block)\n        if (not skip_sanity_check) or debug_mode:\n            block.sanity_check()\n    return block"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _remove_wire_nets(block):\n\n    wire_src_dict = _ProducerList()\n    wire_removal_set = set()  # set of all wirevectors to be removed\n\n    # one pass to build the map of value producers and\n    # all of the nets and wires to be removed\n    for net in block.logic:\n        if net.op == 'w':\n            wire_src_dict[net.dests[0]] = net.args[0]\n            if not isinstance(net.dests[0], Output):\n                wire_removal_set.add(net.dests[0])\n\n    # second full pass to create the new logic without the wire nets\n    new_logic = set()\n    for net in block.logic:\n        if net.op != 'w' or isinstance(net.dests[0], Output):\n            new_args = tuple(wire_src_dict.find_producer(x) for x in net.args)\n            new_net = LogicNet(net.op, net.op_param, new_args, net.dests)\n            new_logic.add(new_net)\n\n    # now update the block with the new logic and remove wirevectors\n    block.logic = new_logic\n    for dead_wirevector in wire_removal_set:\n        del block.wirevector_by_name[dead_wirevector.name]\n        block.wirevector_set.remove(dead_wirevector)\n\n    block.sanity_check()", "response": "Remove all wire nodes from the block."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef constant_propagation(block, silence_unexpected_net_warnings=False):\n    net_count = _NetCount(block)\n    while net_count.shrinking():\n        _constant_prop_pass(block, silence_unexpected_net_warnings)", "response": "Remove excess constants in the block."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndoes one constant propagation pass", "response": "def _constant_prop_pass(block, silence_unexpected_net_warnings=False):\n    \"\"\" Does one constant propagation pass \"\"\"\n    valid_net_ops = '~&|^nrwcsm@'\n    no_optimization_ops = 'wcsm@'\n    one_var_ops = {\n        '~': lambda x: 1-x,\n        'r': lambda x: x   # This is only valid for constant folding purposes\n    }\n    two_var_ops = {\n        '&': lambda l, r: l & r,\n        '|': lambda l, r: l | r,\n        '^': lambda l, r: l ^ r,\n        'n': lambda l, r: 1-(l & r),\n    }\n\n    def _constant_prop_error(net, error_str):\n        if not silence_unexpected_net_warnings:\n            raise PyrtlError(\"Unexpected net, {}, has {}\".format(net, error_str))\n\n    def constant_prop_check(net_checking):\n        def replace_net(new_net):\n            nets_to_remove.add(net_checking)\n            nets_to_add.add(new_net)\n\n        def replace_net_with_const(const_val):\n            new_const_wire = Const(bitwidth=1, val=const_val, block=block)\n            wire_add_set.add(new_const_wire)\n            replace_net_with_wire(new_const_wire)\n\n        def replace_net_with_wire(new_wire):\n            if isinstance(net_checking.dests[0], Output):\n                replace_net(LogicNet('w', None, args=(new_wire,),\n                                     dests=net_checking.dests))\n            else:\n                nets_to_remove.add(net_checking)\n                new_wire_src[net_checking.dests[0]] = new_wire\n\n        if net_checking.op not in valid_net_ops:\n            _constant_prop_error(net_checking, \"has a net not handled by constant_propagation\")\n            return  # skip if we are ignoring unoptimizable ops\n\n        num_constants = sum((isinstance(arg, Const) for arg in net_checking.args))\n\n        if num_constants is 0 or net_checking.op in no_optimization_ops:\n            return  # assuming wire nets are already optimized\n\n        if (net_checking.op in two_var_ops) and num_constants == 1:\n            long_wires = [w for w in net_checking.args + net_checking.dests if len(w) != 1]\n            if len(long_wires):\n                _constant_prop_error(net_checking, \"has wire(s) {} with bitwidths that are not 1\"\n                                     .format(long_wires))\n                return  # skip if we are ignoring unoptimizable ops\n\n            # special case\n            const_wire, other_wire = net_checking.args\n            if isinstance(other_wire, Const):\n                const_wire, other_wire = other_wire, const_wire\n\n            outputs = [two_var_ops[net_checking.op](const_wire.val, other_val)\n                       for other_val in (0, 1)]\n\n            if outputs[0] == outputs[1]:\n                replace_net_with_const(outputs[0])\n            elif outputs[0] == 0:\n                replace_net_with_wire(other_wire)\n            else:\n                replace_net(LogicNet('~', None, args=(other_wire,),\n                                     dests=net_checking.dests))\n\n        else:\n            # this optimization is actually compatible with long wires\n            if net_checking.op in two_var_ops:\n                output = two_var_ops[net_checking.op](net_checking.args[0].val,\n                                                      net_checking.args[1].val)\n            else:\n                output = one_var_ops[net_checking.op](net_checking.args[0].val)\n            replace_net_with_const(output)\n\n    new_wire_src = _ProducerList()\n    wire_add_set = set()\n    nets_to_add = set()\n    nets_to_remove = set()\n\n    for a_net in block.logic:\n        constant_prop_check(a_net)\n    # second full pass to cleanup\n\n    new_logic = set()\n    for net in block.logic.union(nets_to_add) - nets_to_remove:\n        new_args = tuple(new_wire_src.find_producer(x) for x in net.args)\n        new_net = LogicNet(net.op, net.op_param, new_args, net.dests)\n        new_logic.add(new_net)\n\n    block.logic = new_logic\n    for new_wirevector in wire_add_set:\n        block.add_wirevector(new_wirevector)\n\n    _remove_unused_wires(block)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remove_unlistened_nets(block):\n\n    listened_nets = set()\n    listened_wires = set()\n    prev_listened_net_count = 0\n\n    def add_to_listened(net):\n        listened_nets.add(net)\n        listened_wires.update(net.args)\n\n    for a_net in block.logic:\n        if a_net.op == '@':\n            add_to_listened(a_net)\n        elif any(isinstance(destW, Output) for destW in a_net.dests):\n            add_to_listened(a_net)\n\n    while len(listened_nets) > prev_listened_net_count:\n        prev_listened_net_count = len(listened_nets)\n\n        for net in block.logic - listened_nets:\n            if any((destWire in listened_wires) for destWire in net.dests):\n                add_to_listened(net)\n\n    block.logic = listened_nets\n    _remove_unused_wires(block)", "response": "Removes all nets that are not connected to an output wirevector\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _remove_unused_wires(block, keep_inputs=True):\n    valid_wires = set()\n    for logic_net in block.logic:\n        valid_wires.update(logic_net.args, logic_net.dests)\n\n    wire_removal_set = block.wirevector_set.difference(valid_wires)\n    for removed_wire in wire_removal_set:\n        if isinstance(removed_wire, Input):\n            term = \" optimized away\"\n            if keep_inputs:\n                valid_wires.add(removed_wire)\n                term = \" deemed useless by optimization\"\n\n            print(\"Input Wire, \" + removed_wire.name + \" has been\" + term)\n        if isinstance(removed_wire, Output):\n            PyrtlInternalError(\"Output wire, \" + removed_wire.name + \" not driven\")\n\n    block.wirevector_set = valid_wires", "response": "Removes all unconnected wires from a block."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef synthesize(update_working_block=True, block=None):\n\n    block_pre = working_block(block)\n    block_pre.sanity_check()  # before going further, make sure that pressynth is valid\n    block_in = copy_block(block_pre, update_working_block=False)\n\n    block_out = PostSynthBlock()\n    # resulting block should only have one of a restricted set of net ops\n    block_out.legal_ops = set('~&|^nrwcsm@')\n    wirevector_map = {}  # map from (vector,index) -> new_wire\n\n    with set_working_block(block_out, no_sanity_check=True):\n        # First, replace advanced operators with simpler ones\n        for op, fun in [\n                ('*', _basic_mult),\n                ('+', _basic_add),\n                ('-', _basic_sub),\n                ('x', _basic_select),\n                ('=', _basic_eq),\n                ('<', _basic_lt),\n                ('>', _basic_gt)]:\n            net_transform(_replace_op(op, fun), block_in)\n\n        # Next, create all of the new wires for the new block\n        # from the original wires and store them in the wirevector_map\n        # for reference.\n        for wirevector in block_in.wirevector_subset():\n            for i in range(len(wirevector)):\n                new_name = '_'.join((wirevector.name, 'synth', str(i)))\n                if isinstance(wirevector, Const):\n                    new_val = (wirevector.val >> i) & 0x1\n                    new_wirevector = Const(bitwidth=1, val=new_val)\n                elif isinstance(wirevector, (Input, Output)):\n                    new_wirevector = WireVector(name=\"tmp_\" + new_name, bitwidth=1)\n                else:\n                    new_wirevector = wirevector.__class__(name=new_name, bitwidth=1)\n                wirevector_map[(wirevector, i)] = new_wirevector\n\n        # Now connect up the inputs and outputs to maintain the interface\n        for wirevector in block_in.wirevector_subset(Input):\n            input_vector = Input(name=wirevector.name, bitwidth=len(wirevector))\n            for i in range(len(wirevector)):\n                wirevector_map[(wirevector, i)] <<= input_vector[i]\n        for wirevector in block_in.wirevector_subset(Output):\n            output_vector = Output(name=wirevector.name, bitwidth=len(wirevector))\n            # the \"reversed\" is needed because most significant bit comes first in concat\n            output_bits = [wirevector_map[(wirevector, i)]\n                           for i in range(len(output_vector))]\n            output_vector <<= concat_list(output_bits)\n\n        # Now that we have all the wires built and mapped, walk all the blocks\n        # and map the logic to the equivalent set of primitives in the system\n        out_mems = block_out.mem_map  # dictionary: PreSynth Map -> PostSynth Map\n        for net in block_in.logic:\n            _decompose(net, wirevector_map, out_mems, block_out)\n\n    if update_working_block:\n        set_working_block(block_out, no_sanity_check=True)\n    return block_out", "response": "Lower the design to just single - bit and or and not gates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecomposing a net into a single tree structure.", "response": "def _decompose(net, wv_map, mems, block_out):\n    \"\"\" Add the wires and logicnets to block_out and wv_map to decompose net \"\"\"\n\n    def arg(x, i):\n        # return the mapped wire vector for argument x, wire number i\n        return wv_map[(net.args[x], i)]\n\n    def destlen():\n        # return iterator over length of the destination in bits\n        return range(len(net.dests[0]))\n\n    def assign_dest(i, v):\n        # assign v to the wiremap for dest[0], wire i\n        wv_map[(net.dests[0], i)] <<= v\n\n    one_var_ops = {\n        'w': lambda w: w,\n        '~': lambda w: ~w,\n    }\n    c_two_var_ops = {\n        '&': lambda l, r: l & r,\n        '|': lambda l, r: l | r,\n        '^': lambda l, r: l ^ r,\n        'n': lambda l, r: l.nand(r),\n    }\n\n    if net.op in one_var_ops:\n        for i in destlen():\n            assign_dest(i, one_var_ops[net.op](arg(0, i)))\n    elif net.op in c_two_var_ops:\n        for i in destlen():\n            assign_dest(i, c_two_var_ops[net.op](arg(0, i), arg(1, i)))\n    elif net.op == 's':\n        for i in destlen():\n            selected_bit = arg(0, net.op_param[i])\n            assign_dest(i, selected_bit)\n    elif net.op == 'c':\n        arg_wirelist = []\n        # generate list of wires for vectors being concatenated\n        for arg_vector in net.args:\n            arg_vector_as_list = [wv_map[(arg_vector, i)] for i in range(len(arg_vector))]\n            arg_wirelist = arg_vector_as_list + arg_wirelist\n        for i in destlen():\n            assign_dest(i, arg_wirelist[i])\n    elif net.op == 'r':\n        for i in destlen():\n            args = (arg(0, i),)\n            dests = (wv_map[(net.dests[0], i)],)\n            new_net = LogicNet('r', None, args=args, dests=dests)\n            block_out.add_net(new_net)\n    elif net.op == 'm':\n        arg0list = [arg(0, i) for i in range(len(net.args[0]))]\n        addr = concat_list(arg0list)\n        new_mem = _get_new_block_mem_instance(net.op_param, mems, block_out)[1]\n        data = as_wires(new_mem[addr])\n        for i in destlen():\n            assign_dest(i, data[i])\n    elif net.op == '@':\n        addrlist = [arg(0, i) for i in range(len(net.args[0]))]\n        addr = concat_list(addrlist)\n        datalist = [arg(1, i) for i in range(len(net.args[1]))]\n        data = concat_list(datalist)\n        enable = arg(2, 0)\n        new_mem = _get_new_block_mem_instance(net.op_param, mems, block_out)[1]\n        new_mem[addr] <<= MemBlock.EnabledWrite(data=data, enable=enable)\n    else:\n        raise PyrtlInternalError('Unable to synthesize the following net '\n                                 'due to unimplemented op :\\n%s' % str(net))\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nand_synth(net):\n    if net.op in '~nrwcsm@':\n        return True\n\n    def arg(num):\n        return net.args[num]\n\n    dest = net.dests[0]\n    if net.op == '&':\n        dest <<= ~(arg(0).nand(arg(1)))\n    elif net.op == '|':\n        dest <<= (~arg(0)).nand(~arg(1))\n    elif net.op == '^':\n        temp_0 = arg(0).nand(arg(1))\n        dest <<= temp_0.nand(arg(0)).nand(temp_0.nand(arg(1)))\n    else:\n        raise PyrtlError(\"Op, '{}' is not supported in nand_synth\".format(net.op))", "response": "Synthesizes a Post - Synthesis block into one consisting of nands and inverters in place."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef and_inverter_synth(net):\n    if net.op in '~&rwcsm@':\n        return True\n\n    def arg(num):\n        return net.args[num]\n\n    dest = net.dests[0]\n    if net.op == '|':\n        dest <<= ~(~arg(0) & ~arg(1))\n    elif net.op == '^':\n        all_1 = arg(0) & arg(1)\n        all_0 = ~arg(0) & ~arg(1)\n        dest <<= all_0 & ~all_1\n    elif net.op == 'n':\n        dest <<= ~(arg(0) & arg(1))\n    else:\n        raise PyrtlError(\"Op, '{}' is not supported in and_inv_synth\".format(net.op))", "response": "Transposes a decomposed block into one consisting of ands and inverters in place\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef barrel_shifter(bits_to_shift, bit_in, direction, shift_dist, wrap_around=0):\n    from pyrtl import concat, select  # just for readability\n\n    if wrap_around != 0:\n        raise NotImplementedError\n\n    # Implement with logN stages pyrtl.muxing between shifted and un-shifted values\n    final_width = len(bits_to_shift)\n    val = bits_to_shift\n    append_val = bit_in\n\n    for i in range(len(shift_dist)):\n        shift_amt = pow(2, i)  # stages shift 1,2,4,8,...\n        if shift_amt < final_width:\n            newval = select(direction,\n                            concat(val[:-shift_amt], append_val),  # shift up\n                            concat(append_val, val[shift_amt:]))  # shift down\n            val = select(shift_dist[i],\n                         truecase=newval,  # if bit of shift is 1, do the shift\n                         falsecase=val)  # otherwise, don't\n            # the value to append grows exponentially, but is capped at full width\n            append_val = concat(append_val, append_val)[:final_width]\n        else:\n            # if we are shifting this much, all the data is gone\n            val = select(shift_dist[i],\n                         truecase=append_val,  # if bit of shift is 1, do the shift\n                         falsecase=val)  # otherwise, don't\n\n    return val", "response": "Create a shifted version of a 1 - bit wire."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a function that can be used to compose a list of functions into a new object.", "response": "def compose(*funcs):\n    \"\"\"\n    chained function composition wrapper\n\n    creates function f, where f(x) = arg0(arg1(arg2(...argN(x))))\n\n    if *funcs is empty, an identity function is returned.\n\n    Args:\n        *funcs: list of functions to chain\n    \n    Returns:\n        a new function composed of chained calls to *args\n    \"\"\"\n    if not funcs:\n        return lambda *args: args[0] if args else None\n\n    if len(funcs) == 1:\n        return funcs[0]\n\n    last = funcs[-1]\n    rest = funcs[0:-1]\n    return lambda *args: reduce(lambda ax, func: func(ax),\n                                reversed(rest), last(*args))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef combine_reducers(reducers):\n    final_reducers = {key: reducer\n                      for key, reducer in reducers.items()\n                      if hasattr(reducer, '__call__')}\n\n    sanity_error = None\n    try:\n        assert_reducer_sanity(final_reducers)\n    except Exception as e:\n        sanity_error = e\n\n    def combination(state=None, action=None):\n        if state is None:\n            state = {}\n        if sanity_error:\n            raise sanity_error\n\n        has_changed = False\n        next_state = {}\n        for key, reducer in final_reducers.items():\n            previous_state_for_key = state.get(key)\n            next_state_for_key = reducer(previous_state_for_key, action)\n            if next_state_for_key is None:\n                msg = get_undefined_state_error_message(key, action)\n                raise Exception(msg)\n            next_state[key] = next_state_for_key\n            has_changed = (has_changed or\n                           next_state_for_key != previous_state_for_key)\n        return next_state if has_changed else state\n\n    return combination", "response": "Combine a dictionary of reducers into a single tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef software_fibonacci(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "response": "a normal old python function to return the Nth fibonacci number"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_middleware(*middlewares):\n    def inner(create_store_):\n        def create_wrapper(reducer, enhancer=None):\n            store = create_store_(reducer, enhancer)\n            dispatch = store['dispatch']\n            middleware_api = {\n                'get_state': store['get_state'],\n                'dispatch': lambda action: dispatch(action),\n            }\n            chain = [mw(middleware_api) for mw in middlewares]\n            dispatch = compose(*chain)(store['dispatch'])\n\n            return extend(store, {'dispatch': dispatch})\n        return create_wrapper\n    return inner", "response": "Decorator that creates an enhancer function composed of middleware functions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mux(index, *mux_ins, **kwargs):\n    if kwargs:  # only \"default\" is allowed as kwarg.\n        if len(kwargs) != 1 or 'default' not in kwargs:\n            try:\n                result = select(index, **kwargs)\n                import warnings\n                warnings.warn(\"Predicates are being deprecated in Mux. \"\n                              \"Use the select operator instead.\", stacklevel=2)\n                return result\n            except Exception:\n                bad_args = [k for k in kwargs.keys() if k != 'default']\n                raise PyrtlError('unknown keywords %s applied to mux' % str(bad_args))\n        default = kwargs['default']\n    else:\n        default = None\n\n    # find the diff between the addressable range and number of inputs given\n    short_by = 2**len(index) - len(mux_ins)\n    if short_by > 0:\n        if default is not None:  # extend the list to appropriate size\n            mux_ins = list(mux_ins)\n            extention = [default] * short_by\n            mux_ins.extend(extention)\n\n    if 2 ** len(index) != len(mux_ins):\n        raise PyrtlError(\n            'Mux select line is %d bits, but selecting from %d inputs. '\n            % (len(index), len(mux_ins)))\n\n    if len(index) == 1:\n        return select(index, falsecase=mux_ins[0], truecase=mux_ins[1])\n    half = len(mux_ins) // 2\n    return select(index[-1],\n                  falsecase=mux(index[0:-1], *mux_ins[:half]),\n                  truecase=mux(index[0:-1], *mux_ins[half:]))", "response": "Multiplexer returning the value of the wire in."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef concat(*args):\n    if len(args) <= 0:\n        raise PyrtlError('error, concat requires at least 1 argument')\n    if len(args) == 1:\n        return as_wires(args[0])\n\n    arg_wirevectors = tuple(as_wires(arg) for arg in args)\n    final_width = sum(len(arg) for arg in arg_wirevectors)\n    outwire = WireVector(bitwidth=final_width)\n    net = LogicNet(\n        op='c',\n        op_param=None,\n        args=arg_wirevectors,\n        dests=(outwire,))\n    working_block().add_net(net)\n    return outwire", "response": "Concatenates multiple WireVectors into a single WireVector."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef signed_add(a, b):\n    a, b = match_bitwidth(as_wires(a), as_wires(b), signed=True)\n    result_len = len(a) + 1\n    ext_a = a.sign_extended(result_len)\n    ext_b = b.sign_extended(result_len)\n    # add and truncate to the correct length\n    return (ext_a + ext_b)[0:result_len]", "response": "Return wirevector for signed addition."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef signed_mult(a, b):\n    a, b = as_wires(a), as_wires(b)\n    final_len = len(a) + len(b)\n    # sign extend both inputs to the final target length\n    a, b = a.sign_extended(final_len), b.sign_extended(final_len)\n    # the result is the multiplication of both, but truncated\n    # TODO: this may make estimates based on the multiplication overly\n    # pessimistic as half of the multiply result is thrown right away!\n    return (a * b)[0:final_len]", "response": "Return a * b where a and b are treated as signed values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a single bit result of signed less than comparison.", "response": "def signed_lt(a, b):\n    \"\"\" Return a single bit result of signed less than comparison. \"\"\"\n    a, b = match_bitwidth(as_wires(a), as_wires(b), signed=True)\n    r = a - b\n    return r[-1] ^ (~a[-1]) ^ (~b[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a single bit result of signed less than or equal comparison.", "response": "def signed_le(a, b):\n    \"\"\" Return a single bit result of signed less than or equal comparison. \"\"\"\n    a, b = match_bitwidth(as_wires(a), as_wires(b), signed=True)\n    r = a - b\n    return (r[-1] ^ (~a[-1]) ^ (~b[-1])) | (a == b)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a single bit result of signed greater than comparison.", "response": "def signed_gt(a, b):\n    \"\"\" Return a single bit result of signed greater than comparison. \"\"\"\n    a, b = match_bitwidth(as_wires(a), as_wires(b), signed=True)\n    r = b - a\n    return r[-1] ^ (~a[-1]) ^ (~b[-1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a single bit result of signed greater than or equal comparison.", "response": "def signed_ge(a, b):\n    \"\"\" Return a single bit result of signed greater than or equal comparison. \"\"\"\n    a, b = match_bitwidth(as_wires(a), as_wires(b), signed=True)\n    r = b - a\n    return (r[-1] ^ (~a[-1]) ^ (~b[-1])) | (a == b)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshifting the right of a base - 2 block of a node.", "response": "def shift_right_arithmetic(bits_to_shift, shift_amount):\n    \"\"\" Shift right arithmetic operation.\n\n    :param bits_to_shift: WireVector to shift right\n    :param shift_amount: WireVector specifying amount to shift\n    :return: WireVector of same length as bits_to_shift\n\n    This function returns a new WireVector of length equal to the length\n    of the input `bits_to_shift` but where the bits have been shifted\n    to the right.  An arithemetic shift is one that treats the value as\n    as signed number, meaning the sign bit (the most significant bit of\n    `bits_to_shift`) is shifted in. Note that `shift_amount` is treated as\n    unsigned.\n    \"\"\"\n    a, shamt = _check_shift_inputs(bits_to_shift, shift_amount)\n    bit_in = bits_to_shift[-1]  # shift in sign_bit\n    dir = Const(0)  # shift right\n    return barrel.barrel_shifter(bits_to_shift, bit_in, dir, shift_amount)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_bitwidth(*args, **opt):\n    # TODO: when we drop 2.7 support, this code should be cleaned up with explicit\n    # kwarg support for \"signed\" rather than the less than helpful \"**opt\"\n    if len(opt) == 0:\n        signed = False\n    else:\n        if len(opt) > 1 or 'signed' not in opt:\n            raise PyrtlError('error, only supported kwarg to match_bitwidth is \"signed\"')\n        signed = bool(opt['signed'])\n\n    max_len = max(len(wv) for wv in args)\n    if signed:\n        return (wv.sign_extended(max_len) for wv in args)\n    else:\n        return (wv.zero_extended(max_len) for wv in args)", "response": "Matches the bitwidth of all of the input arguments with zero or sign extend\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_wires(val, bitwidth=None, truncating=True, block=None):\n    from .memory import _MemIndexed\n    block = working_block(block)\n\n    if isinstance(val, (int, six.string_types)):\n        # note that this case captures bool as well (as bools are instances of ints)\n        return Const(val, bitwidth=bitwidth, block=block)\n    elif isinstance(val, _MemIndexed):\n        # convert to a memory read when the value is actually used\n        if val.wire is None:\n            val.wire = as_wires(val.mem._readaccess(val.index), bitwidth, truncating, block)\n        return val.wire\n    elif not isinstance(val, WireVector):\n        raise PyrtlError('error, expecting a wirevector, int, or verilog-style '\n                         'const string got %s instead' % repr(val))\n    elif bitwidth == '0':\n        raise PyrtlError('error, bitwidth must be >= 1')\n    elif val.bitwidth is None:\n        raise PyrtlError('error, attempting to use wirevector with no defined bitwidth')\n    elif bitwidth and bitwidth > val.bitwidth:\n        return val.zero_extended(bitwidth)\n    elif bitwidth and truncating and bitwidth < val.bitwidth:\n        return val[:bitwidth]  # truncate the upper bits\n    else:\n        return val", "response": "Convert a wirevector - like object or a string into a Const object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the wirevector w with some bits overwritten by newvalue.", "response": "def bitfield_update(w, range_start, range_end, newvalue, truncating=False):\n    \"\"\" Return wirevector w but with some of the bits overwritten by newvalue.\n\n    :param w: a wirevector to use as the starting point for the update\n    :param range_start: the start of the range of bits to be updated\n    :param range_end: the end of the range of bits to be updated\n    :param newvalue: the value to be written in to the start:end range\n    :param truncating: if true, clip the newvalue to be the proper number of bits\n\n    Given a wirevector w, this function returns a new wirevector that\n    is identical to w except in the range of bits specified.  In that\n    specified range, the value newvalue is swapped in.  For example:\n    `bitfield_update(w, 20, 23, 0x7)` will return return a wirevector\n    of the same length as w, and with the same values as w, but with\n    bits 20, 21, and 22 all set to 1.\n\n    Note that range_start and range_end will be inputs to a slice and\n    so standar Python slicing rules apply (e.g. negative values for\n    end-relative indexing and support for None). ::\n\n        w = bitfield_update(w, 20, 23, 0x7)  # sets bits 20, 21, 22 to 1\n        w = bitfield_update(w, 20, 23, 0x6)  # sets bit 20 to 0, bits 21 and 22 to 1\n        w = bitfield_update(w, 20, None, 0x7)  # assuming w is 32 bits, sets bits 31..20 = 0x7\n        w = bitfield_update(w, -1, None, 0x1)  # set the LSB (bit) to 1\n    \"\"\"\n    from .corecircuits import concat_list\n\n    w = as_wires(w)\n    idxs = list(range(len(w)))  # we make a list of integers and slice those up to use as indexes\n    idxs_lower = idxs[0:range_start]\n    idxs_middle = idxs[range_start:range_end]\n    idxs_upper = idxs[range_end:]\n\n    if len(idxs_middle) == 0:\n        raise PyrtlError('Cannot update bitfield of size 0 (i.e. there are no bits to update)')\n    newvalue = as_wires(newvalue, bitwidth=len(idxs_middle), truncating=truncating)\n    if len(idxs_middle) != len(newvalue):\n        raise PyrtlError('Cannot update bitfield of length %d with value of length %d '\n                         'unless truncating=True is specified' % (len(idxs_middle), len(newvalue)))\n\n    result_list = []\n    if idxs_lower:\n        result_list.append(w[idxs_lower[0]:idxs_lower[-1]+1])\n    result_list.append(newvalue)\n    if idxs_upper:\n        result_list.append(w[idxs_upper[0]:idxs_upper[-1]+1])\n    result = concat_list(result_list)\n\n    if len(result) != len(w):\n        raise PyrtlInternalError('len(result)=%d, len(original)=%d' % (len(result), len(w)))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enum_mux(cntrl, table, default=None, strict=True):\n    # check dictionary keys are of the right type\n    keytypeset = set(type(x) for x in table.keys() if x is not otherwise)\n    if len(keytypeset) != 1:\n        raise PyrtlError('table mixes multiple types {} as keys'.format(keytypeset))\n    keytype = list(keytypeset)[0]\n    # check that dictionary is complete for the enum\n    try:\n        enumkeys = list(keytype.__members__.values())\n    except AttributeError:\n        raise PyrtlError('type {} not an Enum and does not support the same interface'\n                         .format(keytype))\n    missingkeys = [e for e in enumkeys if e not in table]\n\n    # check for \"otherwise\" in table and move it to a default\n    if otherwise in table:\n        if default is not None:\n            raise PyrtlError('both \"otherwise\" and default provided to enum_mux')\n        else:\n            default = table[otherwise]\n\n    if strict and default is None and missingkeys:\n        raise PyrtlError('table provided is incomplete, missing: {}'.format(missingkeys))\n\n    # generate the actual mux\n    vals = {k.value: d for k, d in table.items() if k is not otherwise}\n    if default is not None:\n        vals['default'] = default\n    return muxes.sparse_mux(cntrl, vals)", "response": "Builds a mux for the control signals specified by an enum."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rtl_all(*vectorlist):\n    if len(vectorlist) <= 0:\n        raise PyrtlError('rtl_all requires at least 1 argument')\n    converted_vectorlist = [as_wires(v) for v in vectorlist]\n    if any(len(v) != 1 for v in converted_vectorlist):\n        raise PyrtlError('only length 1 WireVectors can be inputs to rtl_all')\n    return and_all_bits(concat_list(converted_vectorlist))", "response": "Hardware equivalent of python native all."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _basic_mult(A, B):\n    if len(B) == 1:\n        A, B = B, A  # so that we can reuse the code below :)\n    if len(A) == 1:\n        return concat_list(list(A & b for b in B) + [Const(0)])  # keep WireVector len consistent\n\n    result_bitwidth = len(A) + len(B)\n    bits = [[] for weight in range(result_bitwidth)]\n    for i, a in enumerate(A):\n        for j, b in enumerate(B):\n            bits[i + j].append(a & b)\n\n    while not all(len(i) <= 2 for i in bits):\n        deferred = [[] for weight in range(result_bitwidth + 1)]\n        for i, w_array in enumerate(bits):  # Start with low weights and start reducing\n            while len(w_array) >= 3:  # build a new full adder\n                a, b, cin = (w_array.pop(0) for j in range(3))\n                deferred[i].append(a ^ b ^ cin)\n                deferred[i + 1].append(a & b | a & cin | b & cin)\n            if len(w_array) == 2:\n                a, b = w_array\n                deferred[i].append(a ^ b)\n                deferred[i + 1].append(a & b)\n            else:\n                deferred[i].extend(w_array)\n        bits = deferred[:result_bitwidth]\n\n    import six\n    add_wires = tuple(six.moves.zip_longest(*bits, fillvalue=Const(0)))\n    adder_result = concat_list(add_wires[0]) + concat_list(add_wires[1])\n    return adder_result[:result_bitwidth]", "response": "A stripped - down copy of the Wallace multiplier in rtllib"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _push_condition(predicate):\n    global _depth\n    _check_under_condition()\n    _depth += 1\n    if predicate is not otherwise and len(predicate) > 1:\n        raise PyrtlError('all predicates for conditional assignments must wirevectors of len 1')\n    _conditions_list_stack[-1].append(predicate)\n    _conditions_list_stack.append([])", "response": "As we enter new conditions this pushes them on the predicate stack."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstoring the wire assignment details until finalize is called.", "response": "def _build(lhs, rhs):\n    \"\"\"Stores the wire assignment details until finalize is called.\"\"\"\n    _check_under_condition()\n    final_predicate, pred_set = _current_select()\n    _check_and_add_pred_set(lhs, pred_set)\n    _predicate_map.setdefault(lhs, []).append((final_predicate, rhs))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if predicate sets are in conflict False otherwise.", "response": "def _pred_sets_are_in_conflict(pred_set_a, pred_set_b):\n    \"\"\" Find conflict in sets, return conflict if found, else None. \"\"\"\n    # pred_sets conflict if we cannot find one shared predicate that is \"negated\" in one\n    # and \"non-negated\" in the other\n    for pred_a, bool_a in pred_set_a:\n        for pred_b, bool_b in pred_set_b:\n            if pred_a is pred_b and bool_a != bool_b:\n                return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _finalize():\n    from .memory import MemBlock\n    from pyrtl.corecircuits import select\n    for lhs in _predicate_map:\n        # handle memory write ports\n        if isinstance(lhs, MemBlock):\n            p, (addr, data, enable) = _predicate_map[lhs][0]\n            combined_enable = select(p, truecase=enable, falsecase=Const(0))\n            combined_addr = addr\n            combined_data = data\n\n            for p, (addr, data, enable) in _predicate_map[lhs][1:]:\n                combined_enable = select(p, truecase=enable, falsecase=combined_enable)\n                combined_addr = select(p, truecase=addr, falsecase=combined_addr)\n                combined_data = select(p, truecase=data, falsecase=combined_data)\n\n            lhs._build(combined_addr, combined_data, combined_enable)\n\n        # handle wirevector and register assignments\n        else:\n            if isinstance(lhs, Register):\n                result = lhs  # default for registers is \"self\"\n            elif isinstance(lhs, WireVector):\n                result = 0  # default for wire is \"0\"\n            else:\n                raise PyrtlInternalError('unknown assignment in finalize')\n            predlist = _predicate_map[lhs]\n            for p, rhs in predlist:\n                result = select(p, truecase=rhs, falsecase=result)\n            lhs._build(result)", "response": "Builds the required muxes and call back to WireVector to finalize the wirevector build."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions to calculate the current predicate in the current context.", "response": "def _current_select():\n    \"\"\" Function to calculate the current \"predicate\" in the current context.\n\n    Returns a tuple of information: (predicate, pred_set).\n    The value pred_set is a set([ (predicate, bool), ... ]) as described in\n    the _reset_conditional_state\n    \"\"\"\n\n    # helper to create the conjuction of predicates\n    def and_with_possible_none(a, b):\n        assert(a is not None or b is not None)\n        if a is None:\n            return b\n        if b is None:\n            return a\n        return a & b\n\n    def between_otherwise_and_current(predlist):\n        lastother = None\n        for i, p in enumerate(predlist[:-1]):\n            if p is otherwise:\n                lastother = i\n        if lastother is None:\n            return predlist[:-1]\n        else:\n            return predlist[lastother+1:-1]\n\n    select = None\n    pred_set = set()\n\n    # for all conditions except the current children (which should be [])\n    for predlist in _conditions_list_stack[:-1]:\n        # negate all of the predicates between \"otherwise\" and the current one\n        for predicate in between_otherwise_and_current(predlist):\n            select = and_with_possible_none(select, ~predicate)\n            pred_set.add((predicate, True))\n        # include the predicate for the current one (not negated)\n        if predlist[-1] is not otherwise:\n            predicate = predlist[-1]\n            select = and_with_possible_none(select, predicate)\n            pred_set.add((predicate, False))\n\n    if select is None:\n        raise PyrtlError('problem with conditional assignment')\n    if len(select) != 1:\n        raise PyrtlInternalError('conditional predicate with length greater than 1')\n\n    return select, pred_set"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nestimates the total area of the block.", "response": "def area_estimation(tech_in_nm=130, block=None):\n    \"\"\" Estimates the total area of the block.\n\n    :param tech_in_nm: the size of the circuit technology to be estimated\n        (for example, 65 is 65nm and 250 is 0.25um)\n    :return: tuple of estimated areas (logic, mem) in terms of mm^2\n\n    The estimations are based off of 130nm stdcell designs for the logic, and\n    custom memory blocks from the literature.  The results are not fully validated\n    and we do not recommend that this function be used in carrying out science for\n    publication.\n    \"\"\"\n\n    def mem_area_estimate(tech_in_nm, bits, ports, is_rom):\n        # http://www.cs.ucsb.edu/~sherwood/pubs/ICCD-srammodel.pdf\n        # ROM is assumed to be 1/10th of area of SRAM\n        tech_in_um = tech_in_nm / 1000.0\n        area_estimate = 0.001 * tech_in_um**2.07 * bits**0.9 * ports**0.7 + 0.0048\n        return area_estimate if not is_rom else area_estimate / 10.0\n\n    # Subset of the raw data gathered from yosys, mapping to vsclib 130nm library\n    # Width   Adder_Area  Mult_Area  (area in \"tracks\" as discussed below)\n    # 8       211         2684\n    # 16      495         12742\n    # 32      1110        49319\n    # 64      2397        199175\n    # 128     4966        749828\n\n    def adder_stdcell_estimate(width):\n        return width * 34.4 - 25.8\n\n    def multiplier_stdcell_estimate(width):\n        if width == 1:\n            return 5\n        elif width == 2:\n            return 39\n        elif width == 3:\n            return 219\n        else:\n            return -958 + (150 * width) + (45 * width**2)\n\n    def stdcell_estimate(net):\n        if net.op in 'w~sc':\n            return 0\n        elif net.op in '&|n':\n            return 40/8.0 * len(net.args[0])   # 40 lambda\n        elif net.op in '^=<>x':\n            return 80/8.0 * len(net.args[0])   # 80 lambda\n        elif net.op == 'r':\n            return 144/8.0 * len(net.args[0])  # 144 lambda\n        elif net.op in '+-':\n            return adder_stdcell_estimate(len(net.args[0]))\n        elif net.op == '*':\n            return multiplier_stdcell_estimate(len(net.args[0]))\n        elif net.op in 'm@':\n            return 0  # memories handled elsewhere\n        else:\n            raise PyrtlInternalError('Unable to estimate the following net '\n                                     'due to unimplemented op :\\n%s' % str(net))\n\n    block = working_block(block)\n\n    # The functions above were gathered and calibrated by mapping\n    # reference designs to an openly available 130nm stdcell library.\n    # http://www.vlsitechnology.org/html/vsc_description.html\n    # http://www.vlsitechnology.org/html/cells/vsclib013/lib_gif_index.html\n\n    # In a standard cell design, each gate takes up a length of standard \"track\"\n    # in the chip.  The functions above return that length for each of the different\n    # types of functions in the units of \"tracks\".  In the 130nm process used,\n    # 1 lambda is 55nm, and 1 track is 8 lambda.\n\n    # first, sum up the area of all of the logic elements (including registers)\n    total_tracks = sum(stdcell_estimate(a_net) for a_net in block.logic)\n    total_length_in_nm = total_tracks * 8 * 55\n    # each track is then 72 lambda tall, and converted from nm2 to mm2\n    area_in_mm2_for_130nm = (total_length_in_nm * (72 * 55)) / 1e12\n\n    # scaling from 130nm to the target tech\n    logic_area = area_in_mm2_for_130nm / (130.0/tech_in_nm)**2\n\n    # now sum up the area of the memories\n    mem_area = 0\n    for mem in set(net.op_param[1] for net in block.logic_subset('@m')):\n        bits, ports, is_rom = _bits_ports_and_isrom_from_memory(mem)\n        mem_area += mem_area_estimate(tech_in_nm, bits, ports, is_rom)\n\n    return logic_area, mem_area"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _bits_ports_and_isrom_from_memory(mem):\n    is_rom = False\n    bits = 2**mem.addrwidth * mem.bitwidth\n    read_ports = len(mem.readport_nets)\n    try:\n        write_ports = len(mem.writeport_nets)\n    except AttributeError:  # dealing with ROMs\n        if not isinstance(mem, RomBlock):\n            raise PyrtlInternalError('Mem with no writeport_nets attribute'\n                                     ' but not a ROM? Thats an error')\n        write_ports = 0\n        is_rom = True\n    ports = max(read_ports, write_ports)\n    return bits, ports, is_rom", "response": "Helper function to extract bits ports and is_rom from memory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsynthesizing with Yosys and return estimate of area and delay.", "response": "def yosys_area_delay(library, abc_cmd=None, block=None):\n    \"\"\" Synthesize with Yosys and return estimate of area and delay.\n\n    :param library: stdcell library file to target in liberty format\n    :param abc_cmd: string of commands for yosys to pass to abc for synthesis\n    :param block: pyrtl block to analyze\n    :return: a tuple of numbers: area, delay\n\n    The area and delay are returned in units as defined by the stdcell\n    library.  In the standard vsc 130nm library, the area is in a number of\n    \"tracks\", each of which is about 1.74 square um (see area estimation\n    for more details) and the delay is in ps.\n\n    http://www.vlsitechnology.org/html/vsc_description.html\n\n    May raise `PyrtlError` if yosys is not configured correctly, and\n    `PyrtlInternalError` if the call to yosys was not able successfully\n    \"\"\"\n\n    if abc_cmd is None:\n        abc_cmd = 'strash;scorr;ifraig;retime;dch,-f;map;print_stats;'\n    else:\n        # first, replace whitespace with commas as per yosys requirements\n        re.sub(r\"\\s+\", ',', abc_cmd)\n        # then append with \"print_stats\" to generate the area and delay info\n        abc_cmd = '%s;print_stats;' % abc_cmd\n\n    def extract_area_delay_from_yosys_output(yosys_output):\n        report_lines = [line for line in yosys_output.split('\\n') if 'ABC: netlist' in line]\n        area = re.match('.*area\\s*=\\s*([0-9\\.]*)', report_lines[0]).group(1)\n        delay = re.match('.*delay\\s*=\\s*([0-9\\.]*)', report_lines[0]).group(1)\n        return float(area), float(delay)\n\n    yosys_arg_template = \"\"\"-p\n    read_verilog %s;\n    synth -top toplevel;\n    dfflibmap -liberty %s;\n    abc -liberty %s -script +%s\n    \"\"\"\n\n    temp_d, temp_path = tempfile.mkstemp(suffix='.v')\n    try:\n        # write the verilog to a temp\n        with os.fdopen(temp_d, 'w') as f:\n            OutputToVerilog(f, block=block)\n        # call yosys on the temp, and grab the output\n        yosys_arg = yosys_arg_template % (temp_path, library, library, abc_cmd)\n        yosys_output = subprocess.check_output(['yosys', yosys_arg])\n        area, delay = extract_area_delay_from_yosys_output(yosys_output)\n    except (subprocess.CalledProcessError, ValueError) as e:\n        print('Error with call to yosys...', file=sys.stderr)\n        print('---------------------------------------------', file=sys.stderr)\n        print(e.output, file=sys.stderr)\n        print('---------------------------------------------', file=sys.stderr)\n        raise PyrtlError('Yosys callfailed')\n    except OSError as e:\n        print('Error with call to yosys...', file=sys.stderr)\n        raise PyrtlError('Call to yosys failed (not installed or on path?)')\n    finally:\n        os.remove(temp_path)\n    return area, delay"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef max_freq(self, tech_in_nm=130, ffoverhead=None):\n        cp_length = self.max_length()\n        scale_factor = 130.0 / tech_in_nm\n        if ffoverhead is None:\n            clock_period_in_ps = scale_factor * (cp_length + 189 + 194)\n        else:\n            clock_period_in_ps = (scale_factor * cp_length) + ffoverhead\n        return 1e6 * 1.0/clock_period_in_ps", "response": "Estimate the maximum frequency of a time - series entry in MHz."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a timing map and returns the critical paths of the terminal.", "response": "def critical_path(self, print_cp=True, cp_limit=100):\n        \"\"\" Takes a timing map and returns the critical paths of the system.\n\n        :param print_cp: Whether to print the critical path to the terminal\n            after calculation\n        :return: a list containing tuples with the 'first' wire as the\n            first value and the critical paths (which themselves are lists\n            of nets) as the second\n        \"\"\"\n        critical_paths = []  # storage of all completed critical paths\n        wire_src_map, dst_map = self.block.net_connections()\n\n        def critical_path_pass(old_critical_path, first_wire):\n            if isinstance(first_wire, (Input, Const, Register)):\n                critical_paths.append((first_wire, old_critical_path))\n                return\n\n            if len(critical_paths) >= cp_limit:\n                raise self._TooManyCPsError()\n\n            source = wire_src_map[first_wire]\n            critical_path = [source]\n            critical_path.extend(old_critical_path)\n            arg_max_time = max(self.timing_map[arg_wire] for arg_wire in source.args)\n            for arg_wire in source.args:\n                # if the time for both items are the max, both will be on a critical path\n                if self.timing_map[arg_wire] == arg_max_time:\n                    critical_path_pass(critical_path, arg_wire)\n\n        max_time = self.max_length()\n        try:\n            for wire_pair in self.timing_map.items():\n                if wire_pair[1] == max_time:\n                    critical_path_pass([], wire_pair[0])\n        except self._TooManyCPsError:\n            print(\"Critical path count limit reached\")\n\n        if print_cp:\n            self.print_critical_paths(critical_paths)\n        return critical_paths"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_critical_paths(critical_paths):\n        line_indent = \" \" * 2\n        #  print the critical path\n        for cp_with_num in enumerate(critical_paths):\n            print(\"Critical path\", cp_with_num[0], \":\")\n            print(line_indent, \"The first wire is:\", cp_with_num[1][0])\n            for net in cp_with_num[1][1]:\n                print(line_indent, (net))\n            print()", "response": "Prints the critical path length analysis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _request(self, endpoint, method, data=None, **kwargs):\n        final_url = self.url + endpoint\n\n        if not self._is_authenticated:\n            raise LoginRequired\n\n        rq = self.session\n        if method == 'get':\n            request = rq.get(final_url, **kwargs)\n        else:\n            request = rq.post(final_url, data, **kwargs)\n\n        request.raise_for_status()\n        request.encoding = 'utf_8'\n\n        if len(request.text) == 0:\n            data = json.loads('{}')\n        else:\n            try:\n                data = json.loads(request.text)\n            except ValueError:\n                data = request.text\n\n        return data", "response": "This method handles both GET and POST requests."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nauthenticate the qBittorrent Client with the specified username and password.", "response": "def login(self, username='admin', password='admin'):\n        \"\"\"\n        Method to authenticate the qBittorrent Client.\n\n        Declares a class attribute named ``session`` which\n        stores the authenticated session if the login is correct.\n        Else, shows the login error.\n\n        :param username: Username.\n        :param password: Password.\n\n        :return: Response to login request to the API.\n        \"\"\"\n        self.session = requests.Session()\n        login = self.session.post(self.url+'login',\n                                  data={'username': username,\n                                        'password': password})\n        if login.text == 'Ok.':\n            self._is_authenticated = True\n        else:\n            return login.text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of torrents matching the supplied filters.", "response": "def torrents(self, **filters):\n        \"\"\"\n        Returns a list of torrents matching the supplied filters.\n\n        :param filter: Current status of the torrents.\n        :param category: Fetch all torrents with the supplied label.\n        :param sort: Sort torrents by.\n        :param reverse: Enable reverse sorting.\n        :param limit: Limit the number of torrents returned.\n        :param offset: Set offset (if less than 0, offset from end).\n\n        :return: list() of torrent with matching filter.\n        \"\"\"\n        params = {}\n        for name, value in filters.items():\n            # make sure that old 'status' argument still works\n            name = 'filter' if name == 'status' else name\n            params[name] = value\n\n        return self._get('query/torrents', params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the current qBittorrent preferences.", "response": "def preferences(self):\n        \"\"\"\n        Get the current qBittorrent preferences.\n        Can also be used to assign individual preferences.\n        For setting multiple preferences at once,\n        see ``set_preferences`` method.\n\n        Note: Even if this is a ``property``,\n        to fetch the current preferences dict, you are required\n        to call it like a bound method.\n\n        Wrong::\n\n            qb.preferences\n\n        Right::\n\n            qb.preferences()\n\n        \"\"\"\n        prefs = self._get('query/preferences')\n\n        class Proxy(Client):\n            \"\"\"\n            Proxy class to to allow assignment of individual preferences.\n            this class overrides some methods to ease things.\n\n            Because of this, settings can be assigned like::\n\n                In [5]: prefs = qb.preferences()\n\n                In [6]: prefs['autorun_enabled']\n                Out[6]: True\n\n                In [7]: prefs['autorun_enabled'] = False\n\n                In [8]: prefs['autorun_enabled']\n                Out[8]: False\n\n            \"\"\"\n\n            def __init__(self, url, prefs, auth, session):\n                super(Proxy, self).__init__(url)\n                self.prefs = prefs\n                self._is_authenticated = auth\n                self.session = session\n\n            def __getitem__(self, key):\n                return self.prefs[key]\n\n            def __setitem__(self, key, value):\n                kwargs = {key: value}\n                return self.set_preferences(**kwargs)\n\n            def __call__(self):\n                return self.prefs\n\n        return Proxy(self.url, prefs, self._is_authenticated, self.session)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download_from_link(self, link, **kwargs):\n        # old:new format\n        old_arg_map = {'save_path': 'savepath'}  # , 'label': 'category'}\n\n        # convert old option names to new option names\n        options = kwargs.copy()\n        for old_arg, new_arg in old_arg_map.items():\n            if options.get(old_arg) and not options.get(new_arg):\n                options[new_arg] = options[old_arg]\n\n        if type(link) is list:\n            options['urls'] = \"\\n\".join(link)\n        else:\n            options['urls'] = link\n\n        # workaround to send multipart/formdata request\n        # http://stackoverflow.com/a/23131823/4726598\n        dummy_file = {'_dummy': (None, '_dummy')}\n\n        return self._post('command/download', data=options, files=dummy_file)", "response": "Download torrent using a link."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload torrent using a file.", "response": "def download_from_file(self, file_buffer, **kwargs):\n        \"\"\"\n        Download torrent using a file.\n\n        :param file_buffer: Single file() buffer or list of.\n        :param save_path: Path to download the torrent.\n        :param label: Label of the torrent(s).\n\n        :return: Empty JSON data.\n        \"\"\"\n        if isinstance(file_buffer, list):\n            torrent_files = {}\n            for i, f in enumerate(file_buffer):\n                torrent_files.update({'torrents%s' % i: f})\n        else:\n            torrent_files = {'torrents': file_buffer}\n\n        data = kwargs.copy()\n\n        if data.get('save_path'):\n            data.update({'savepath': data['save_path']})\n        return self._post('command/upload', data=data, files=torrent_files)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_trackers(self, infohash, trackers):\n        data = {'hash': infohash.lower(),\n                'urls': trackers}\n        return self._post('command/addTrackers', data=data)", "response": "Add trackers to a torrent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pause_multiple(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/pauseAll', data=data)", "response": "Pause multiple torrents.\n\n        :param infohash_list: Single or list() of infohashes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the label on multiple torrents.", "response": "def set_label(self, infohash_list, label):\n        \"\"\"\n        Set the label on multiple torrents.\n        IMPORTANT: OLD API method, kept as it is to avoid breaking stuffs.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        data['label'] = label\n        return self._post('command/setLabel', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_category(self, infohash_list, category):\n        data = self._process_infohash_list(infohash_list)\n        data['category'] = category\n        return self._post('command/setCategory', data=data)", "response": "Set the category on multiple torrents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resume_multiple(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/resumeAll', data=data)", "response": "Resume multiple paused torrents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete torrents. :param infohash_list: Single or list() of infohashes.", "response": "def delete(self, infohash_list):\n        \"\"\"\n        Delete torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/delete', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_permanently(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/deletePerm', data=data)", "response": "Permanently delete torrents.\n\n        :param infohash_list: Single or list() of infohashes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrechecks torrents. :param infohash_list: Single or list() of infohashes.", "response": "def recheck(self, infohash_list):\n        \"\"\"\n        Recheck torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/recheck', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nincrease priority of torrents.", "response": "def increase_priority(self, infohash_list):\n        \"\"\"\n        Increase priority of torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/increasePrio', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecrease priority of torrents.", "response": "def decrease_priority(self, infohash_list):\n        \"\"\"\n        Decrease priority of torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/decreasePrio', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset torrents to maximum priority level.", "response": "def set_max_priority(self, infohash_list):\n        \"\"\"\n        Set torrents to maximum priority level.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/topPrio', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting torrents to minimum priority level.", "response": "def set_min_priority(self, infohash_list):\n        \"\"\"\n        Set torrents to minimum priority level.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/bottomPrio', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the priority of a file in a torrent.", "response": "def set_file_priority(self, infohash, file_id, priority):\n        \"\"\"\n        Set file of a torrent to a supplied priority level.\n\n        :param infohash: INFO HASH of torrent.\n        :param file_id: ID of the file to set priority.\n        :param priority: Priority level of the file.\n        \"\"\"\n        if priority not in [0, 1, 2, 7]:\n            raise ValueError(\"Invalid priority, refer WEB-UI docs for info.\")\n        elif not isinstance(file_id, int):\n            raise TypeError(\"File ID must be an int\")\n\n        data = {'hash': infohash.lower(),\n                'id': file_id,\n                'priority': priority}\n\n        return self._post('command/setFilePrio', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_torrent_download_limit(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/getTorrentsDlLimit', data=data)", "response": "Get download speed limit of the supplied torrents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_torrent_download_limit(self, infohash_list, limit):\n        data = self._process_infohash_list(infohash_list)\n        data.update({'limit': limit})\n        return self._post('command/setTorrentsDlLimit', data=data)", "response": "Set download speed limit of the supplied torrents."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_torrent_upload_limit(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/getTorrentsUpLimit', data=data)", "response": "Get upoload speed limit of the supplied torrents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset upload speed limit of the supplied torrents.", "response": "def set_torrent_upload_limit(self, infohash_list, limit):\n        \"\"\"\n        Set upload speed limit of the supplied torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        :param limit: Speed limit in bytes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        data.update({'limit': limit})\n        return self._post('command/setTorrentsUpLimit', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_preferences(self, **kwargs):\n        json_data = \"json={}\".format(json.dumps(kwargs))\n        headers = {'content-type': 'application/x-www-form-urlencoded'}\n        return self._post('command/setPreferences', data=json_data,\n                          headers=headers)", "response": "Set all possible preferences of qBittorrent."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntoggling sequential download in supplied torrents.", "response": "def toggle_sequential_download(self, infohash_list):\n        \"\"\"\n        Toggle sequential download in supplied torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/toggleSequentialDownload', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef toggle_first_last_piece_priority(self, infohash_list):\n        data = self._process_infohash_list(infohash_list)\n        return self._post('command/toggleFirstLastPiecePrio', data=data)", "response": "Toggle first or last piece priority of supplied torrents."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nforce start selected torrents.", "response": "def force_start(self, infohash_list, value=True):\n        \"\"\"\n        Force start selected torrents.\n\n        :param infohash_list: Single or list() of infohashes.\n        :param value: Force start value (bool)\n        \"\"\"\n        data = self._process_infohash_list(infohash_list)\n        data.update({'value': json.dumps(value)})\n        return self._post('command/setForceStart', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vue_find_resource(name, use_minified=None):\n    target = list(filter(lambda x: x['name'] == name, current_app.config['VUE_CONFIGURATION']))\n    if not target:\n        raise ValueError('Can not find resource from configuration.')\n    target = target[0]\n    use_minified = (isinstance(use_minified, bool) and use_minified) or current_app.config['VUE_USE_MINIFIED']\n    CdnClass = LocalCDN if target['use_local'] else getattr(cdn, target['cdn'], CDN)\n    resource_url = CdnClass(name=name, version=target.get('version', ''),\n                            use_minified=use_minified).get_resource_url()\n    if resource_url.startswith('//') and current_app.config['VUE_CDN_FORCE_SSL']:\n        resource_url = 'https:%s' % resource_url\n    return resource_url", "response": "Resource finding function also available in templates."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a time in seconds to a reasonable human readable time.", "response": "def humantime(time):\n    \"\"\"Converts a time in seconds to a reasonable human readable time\n\n    Parameters\n    ----------\n    t : float\n        The number of seconds\n\n    Returns\n    -------\n    time : string\n        The human readable formatted value of the given time\n    \"\"\"\n    try:\n        time = float(time)\n    except (ValueError, TypeError):\n        raise ValueError(\"Input must be numeric\")\n\n    # weeks\n    if time >= 7 * 60 * 60 * 24:\n        weeks = math.floor(time / (7 * 60 * 60 * 24))\n        timestr = \"{:g} weeks, \".format(weeks) + humantime(time % (7 * 60 * 60 * 24))\n\n    # days\n    elif time >= 60 * 60 * 24:\n        days = math.floor(time / (60 * 60 * 24))\n        timestr = \"{:g} days, \".format(days) + humantime(time % (60 * 60 * 24))\n\n    # hours\n    elif time >= 60 * 60:\n        hours = math.floor(time / (60 * 60))\n        timestr = \"{:g} hours, \".format(hours) + humantime(time % (60 * 60))\n\n    # minutes\n    elif time >= 60:\n        minutes = math.floor(time / 60.)\n        timestr = \"{:g} min., \".format(minutes) + humantime(time % 60)\n\n    # seconds\n    elif (time >= 1) | (time == 0):\n        timestr = \"{:g} s\".format(time)\n\n    # milliseconds\n    elif time >= 1e-3:\n        timestr = \"{:g} ms\".format(time * 1e3)\n\n    # microseconds\n    elif time >= 1e-6:\n        timestr = \"{:g} \\u03BCs\".format(time * 1e6)\n\n    # nanoseconds or smaller\n    else:\n        timestr = \"{:g} ns\".format(time * 1e9)\n\n    return timestr"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ansi_len(string):\n    return len(string) - wcswidth(re.compile(r'\\x1b[^m]*m').sub('', string))", "response": "Extra length due to any ANSI sequences in the string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat a list of elements using the given line style", "response": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_width(width, n):\n    if isinstance(width, int):\n        widths = [width] * n\n\n    else:\n        assert len(width) == n, \"Widths and data do not match\"\n        widths = width\n\n    return widths", "response": "Parses an int or array of widths returning a list of widths"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints a table with the given data", "response": "def table(data, headers=None, format_spec=FMT, width=WIDTH, align=ALIGN, style=STYLE, out=sys.stdout):\n    \"\"\"Print a table with the given data\n\n    Parameters\n    ----------\n    data : array_like\n        An (m x n) array containing the data to print (m rows of n columns)\n\n    headers : list, optional\n        A list of n strings consisting of the header of each of the n columns (Default: None)\n\n    format_spec : string, optional\n        Format specification for formatting numbers (Default: '5g')\n\n    width : int or array_like, optional\n        The width of each column in the table (Default: 11)\n\n    align : string\n        The alignment to use ('left', 'center', or 'right'). (Default: 'right')\n\n    style : string or tuple, optional\n        A formatting style. (Default: 'fancy_grid')\n\n    out : writer, optional\n        A file handle or object that has write() and flush() methods (Default: sys.stdout)\n    \"\"\"\n    # Number of columns in the table.\n    ncols = len(data[0]) if headers is None else len(headers)\n    tablestyle = STYLES[style]\n    widths = parse_width(width, ncols)\n\n    # Initialize with a hr or the header\n    tablestr = [hrule(ncols, widths, tablestyle.top)] \\\n        if headers is None else [header(headers, width=widths, align=align, style=style)]\n\n    # parse each row\n    tablestr += [row(d, widths, format_spec, align, style) for d in data]\n\n    # only add the final border if there was data in the table\n    if len(data) > 0:\n        tablestr += [hrule(ncols, widths, tablestyle.bottom)]\n\n    # print the table\n    out.write('\\n'.join(tablestr) + '\\n')\n    out.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef header(headers, width=WIDTH, align=ALIGN, style=STYLE, add_hr=True):\n    tablestyle = STYLES[style]\n    widths = parse_width(width, len(headers))\n    alignment = ALIGNMENTS[align]\n\n    # string formatter\n    data = map(lambda x: ('{:%s%d}' % (alignment, x[0] + ansi_len(x[1]))).format(x[1]), zip(widths, headers))\n\n    # build the formatted str\n    headerstr = format_line(data, tablestyle.row)\n\n    if add_hr:\n        upper = hrule(len(headers), widths, tablestyle.top)\n        lower = hrule(len(headers), widths, tablestyle.below_header)\n        headerstr = '\\n'.join([upper, headerstr, lower])\n\n    return headerstr", "response": "Returns a formatted row of column header strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef row(values, width=WIDTH, format_spec=FMT, align=ALIGN, style=STYLE):\n    tablestyle = STYLES[style]\n    widths = parse_width(width, len(values))\n\n    assert isinstance(format_spec, string_types) | isinstance(format_spec, list), \\\n        \"format_spec must be a string or list of strings\"\n\n    if isinstance(format_spec, string_types):\n        format_spec = [format_spec] * len(list(values))\n\n    # mapping function for string formatting\n    def mapdata(val):\n\n        # unpack\n        width, datum, prec = val\n\n        if isinstance(datum, string_types):\n            return ('{:%s%i}' % (ALIGNMENTS[align], width + ansi_len(datum))).format(datum)\n\n        elif isinstance(datum, Number):\n            return ('{:%s%i.%s}' % (ALIGNMENTS[align], width, prec)).format(datum)\n\n        else:\n            raise ValueError('Elements in the values array must be strings, ints, or floats')\n\n    # string formatter\n    data = map(mapdata, zip(widths, values, format_spec))\n\n    # build the row string\n    return format_line(data, tablestyle.row)", "response": "Returns a formatted row of data in a new column of the log file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef hrule(n=1, width=WIDTH, linestyle=LineStyle('', '\u2500', '\u2500', '')):\n    widths = parse_width(width, n)\n    hrstr = linestyle.sep.join([('{:%s^%i}' % (linestyle.hline, width)).format('')\n                                for width in widths])\n    return linestyle.begin + hrstr + linestyle.end", "response": "Returns a formatted string used as a border between table rows."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef top(n, width=WIDTH, style=STYLE):\n    return hrule(n, width, linestyle=STYLES[style].top)", "response": "Prints the top row of a table"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef banner(message, width=30, style='banner', out=sys.stdout):\n    out.write(header([message], width=max(width, len(message)), style=style) + '\\n')\n    out.flush()", "response": "Prints a banner message in the alphabetical order"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a table with data from the given pandas DataFrame", "response": "def dataframe(df, **kwargs):\n    \"\"\"Print table with data from the given pandas DataFrame\n\n    Parameters\n    ----------\n    df : DataFrame\n        A pandas DataFrame with the table to print\n    \"\"\"\n    table(df.values, list(df.columns), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the address of the resource.", "response": "def set_address(self, address):\n        \"\"\"\n        Set the address.\n        :param address:\n        \"\"\"\n        self._query_params += str(QueryParam.ADVANCED) + str(QueryParam.ADDRESS) + address.replace(\" \", \"+\").lower()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the minimum lease period in months.", "response": "def set_min_lease(self, min_lease):\n        \"\"\"\n        Set the minimum lease period in months.\n        :param min_lease: int\n        \"\"\"\n        self._query_params += str(QueryParam.MIN_LEASE) + str(min_lease)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_added_since(self, added):\n        self._query_params += str(QueryParam.DAYS_OLD) + str(added)", "response": "Sets the added since parameter for the resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the maximum lease period in months.", "response": "def set_max_lease(self, max_lease):\n        \"\"\"\n        Set the maximum lease period in months.\n        :param max_lease: int\n        \"\"\"\n        self._query_params += str(QueryParam.MAX_LEASE) + str(max_lease)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the availability of the resource.", "response": "def set_availability(self, availability):\n        \"\"\"\n        Set the maximum lease period in months.\n        :param availability:\n        \"\"\"\n        if availability >= 5:\n            availability = '5%2B'\n        self._query_params += str(QueryParam.AVALIABILITY) + str(availability)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the room type.", "response": "def set_room_type(self, room_type):\n        \"\"\"\n        Set the room type.\n        :param room_type:\n        \"\"\"\n        if not isinstance(room_type, RoomType):\n            raise DaftException(\"room_type should be an instance of RoomType.\")\n        self._query_params += str(QueryParam.ROOM_TYPE) + str(room_type)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_keywords(self, keywords):\n        self._query_params += str(QueryParam.KEYWORDS) + '+'.join(keywords)", "response": "Sets the keywords for the query"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the area to retrieve listings from. Use an array to search multiple areas.", "response": "def set_area(self, area):\n        \"\"\"\n        The area to retrieve listings from. Use an array to search multiple areas.\n        :param area:\n        :return:\n        \"\"\"\n        self._area = area.replace(\" \", \"-\").lower() if isinstance(area, str) else ','.join(\n            map(lambda x: x.lower().replace(' ', '-'), area))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the _open_viewing property to True to only search for properties that have upcoming open for viewing dates.", "response": "def set_open_viewing(self, open_viewing):\n        \"\"\"\n        Set to True to only search for properties that have upcoming 'open for viewing' dates.\n        :param open_viewing:\n        :return:\n        \"\"\"\n        if open_viewing:\n            self._open_viewing = open_viewing\n            self._query_params += str(QueryParam.OPEN_VIEWING)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the offset of the record set.", "response": "def set_offset(self, offset):\n        \"\"\"\n        The page number which is in increments of 10. The default page number is 0.\n        :param offset:\n        :return:\n        \"\"\"\n\n        if not isinstance(offset, int) or offset < 0:\n            raise DaftException(\"Offset should be a positive integer.\")\n\n        self._offset = str(offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the minimum price of the resource.", "response": "def set_min_price(self, min_price):\n        \"\"\"\n        The minimum price.\n        :param min_price:\n        :return:\n        \"\"\"\n\n        if not isinstance(min_price, int):\n            raise DaftException(\"Min price should be an integer.\")\n\n        self._min_price = str(min_price)\n        self._price += str(QueryParam.MIN_PRICE) + self._min_price"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_max_price(self, max_price):\n\n        if not isinstance(max_price, int):\n            raise DaftException(\"Max price should be an integer.\")\n\n        self._max_price = str(max_price)\n        self._price += str(QueryParam.MAX_PRICE) + self._max_price", "response": "Sets the max price of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_listing_type(self, listing_type):\n\n        if not isinstance(listing_type, SaleType) and not isinstance(listing_type, RentType):\n            raise DaftException(\"listing_type should be an instance of SaleType or RentType.\")\n\n        self._listing_type = listing_type", "response": "Sets the listing type of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the minimum number of beds for the resource.", "response": "def set_min_beds(self, min_beds):\n        \"\"\"\n        The minimum number of beds.\n        :param min_beds:\n        :return:\n        \"\"\"\n\n        if not isinstance(min_beds, int):\n            raise DaftException(\"Minimum number of beds should be an integer.\")\n\n        self._min_beds = str(min_beds)\n        self._query_params += str(QueryParam.MIN_BEDS) + self._min_beds"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the maximum number of beds for a resource.", "response": "def set_max_beds(self, max_beds):\n        \"\"\"\n        The maximum number of beds.\n        :param max_beds:\n        :return:\n        \"\"\"\n        if not isinstance(max_beds, int):\n            raise DaftException(\"Maximum number of beds should be an integer.\")\n\n        self._max_beds = str(max_beds)\n        self._query_params += str(QueryParam.MAX_BEDS) + self._max_beds"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_sort_by(self, sort_by):\n        if not isinstance(sort_by, SortType):\n            raise DaftException(\"sort_by should be an instance of SortType.\")\n\n        self._sort_by = str(sort_by)", "response": "Set the sort_by property of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the sort order of the listings.", "response": "def set_sort_order(self, sort_order):\n        \"\"\"\n        Use the SortOrder object to sort the listings descending or ascending.\n        :param sort_order:\n        :return:\n        \"\"\"\n\n        if not isinstance(sort_order, SortOrder):\n            raise DaftException(\"sort_order should be an instance of SortOrder.\")\n\n        self._sort_order = str(sort_order)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the commercial property type.", "response": "def set_commercial_property_type(self, commercial_property_type):\n        \"\"\"\n        Use the CommercialType object to set the commercial property type.\n        :param commercial_property_type:\n        :return:\n        \"\"\"\n\n        if not isinstance(commercial_property_type, CommercialType):\n            raise DaftException(\"commercial_property_type should be an instance of CommercialType.\")\n\n        self._commercial_property_type = str(commercial_property_type)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the commercial minimum size in sq ft.", "response": "def set_commercial_min_size(self, commercial_min_size):\n        \"\"\"\n        The minimum size in sq ft.\n        :param commercial_min_size:\n        :return:\n        \"\"\"\n        if not isinstance(commercial_min_size, int):\n            raise DaftException(\"commercial_min_size should be an integer.\")\n\n        self._commercial_min_size = str(commercial_min_size)\n        self._query_params += str(QueryParam.COMMERCIAL_MIN) + self._commercial_min_size"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the commercial max size in sq ft.", "response": "def set_commercial_max_size(self, commercial_max_size):\n        \"\"\"\n        The maximum size in sq ft.\n        :param commercial_max_size:\n        :return:\n        \"\"\"\n        if not isinstance(commercial_max_size, int):\n            raise DaftException(\"commercial_max_size should be an integer.\")\n\n        self._commercial_max_size = str(commercial_max_size)\n        self._query_params += str(QueryParam.COMMERCIAL_MAX) + self._commercial_max_size"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the student accomodation type.", "response": "def set_student_accommodation_type(self, student_accommodation_type):\n        \"\"\"\n        Set the student accomodation type.\n        :param student_accommodation_type: StudentAccomodationType\n        \"\"\"\n        if not isinstance(student_accommodation_type, StudentAccommodationType):\n            raise DaftException(\"student_accommodation_type should be an instance of StudentAccommodationType.\")\n\n        self._student_accommodation_type = str(student_accommodation_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_num_occupants(self, num_occupants):\n        self._query_params += str(QueryParam.NUM_OCCUPANTS) + str(num_occupants)", "response": "Sets the number of occupants living in the property for rent."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_public_transport_route(self, public_transport_route):\n        self._query_params += str(QueryParam.ROUTE_ID) + str(public_transport_route)", "response": "Sets the public transport route for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the property type for rents.", "response": "def set_property_type(self, property_types):\n        \"\"\"\n        Set the property type for rents.\n        :param property_types: Array of Enum PropertyType\n        \"\"\"\n        query_add = ''\n        for property_type in property_types:\n            if not isinstance(property_type, PropertyType):\n                raise DaftException(\"property_types should be an instance of PropertyType.\")\n            query_add += str(property_type)\n\n        self._query_params += query_add"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search(self):\n        self.set_url()\n        listings = []\n        request = Request(debug=self._debug)\n        url = self.get_url()\n        soup = request.get(url)\n        divs = soup.find_all(\"div\", {\"class\": \"box\"})\n        [listings.append(Listing(div, debug=self._debug)) for div in divs]\n        return listings", "response": "The search function returns an array of Listing objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef price_change(self):\n        try:\n            if self._data_from_search:\n                return self._data_from_search.find('div', {'class': 'price-changes-sr'}).text\n            else:\n                return self._ad_page_content.find('div', {'class': 'price-changes-sr'}).text\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting price_change. Error message: \" + e.args[0])\n            return", "response": "This method returns any price change."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an array of upcoming viewings for a property.", "response": "def upcoming_viewings(self):\n        \"\"\"\n        Returns an array of upcoming viewings for a property.\n        :return:\n        \"\"\"\n        upcoming_viewings = []\n        try:\n            if self._data_from_search:\n                viewings = self._data_from_search.find_all(\n                    'div', {'class': 'smi-onview-text'})\n            else:\n                viewings = []\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting upcoming_viewings. Error message: \" + e.args[0])\n            return\n        for viewing in viewings:\n            upcoming_viewings.append(viewing.text.strip())\n        return upcoming_viewings"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef facilities(self):\n        facilities = []\n        try:\n            list_items = self._ad_page_content.select(\"#facilities li\")\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting facilities. Error message: \" + e.args[0])\n            return\n\n        for li in list_items:\n            facilities.append(li.text)\n        return facilities", "response": "This method returns the properties facilities."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef overviews(self):\n        overviews = []\n        try:\n            list_items = self._ad_page_content.select(\"#overview li\")\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting overviews. Error message: \" + e.args[0])\n            return\n\n        for li in list_items:\n            overviews.append(li.text)\n        return overviews", "response": "This method returns the properties overviews."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef features(self):\n        features = []\n        try:\n            list_items = self._ad_page_content.select(\"#features li\")\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting features. Error message: \" + e.args[0])\n            return\n\n        for li in list_items:\n            features.append(li.text)\n        return features", "response": "This method returns the properties features."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef images(self):\n        try:\n            uls = self._ad_page_content.find(\n                \"ul\", {\"class\": \"smi-gallery-list\"})\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting images. Error message: \" + e.args[0])\n            return\n        images = []\n        if uls is None:\n            return\n        for li in uls.find_all('li'):\n            if li.find('img')['src']:\n                images.append(li.find('img')['src'])\n\n        return images", "response": "This method returns the listing image."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef agent_url(self):\n        try:\n            if self._data_from_search:\n                agent = self._data_from_search.find('ul', {'class': 'links'})\n                links = agent.find_all('a')\n                return links[1]['href']\n            else:\n                return self._ad_page_content.find('a', {'id': 'smi-link-branded'})['href']\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting agent_url. Error message: \" + e.args[0])\n            return", "response": "This method returns the agent s url."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef contact_number(self):\n        try:\n            number = self._ad_page_content.find(\n                'button', {'class': 'phone-number'})\n            return (base64.b64decode(number.attrs['data-p'])).decode('ascii')\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting contact_number. Error message: \" + e.args[0])\n            return 'N/A'", "response": "This method returns the contact phone number."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef daft_link(self):\n        try:\n            if self._data_from_search:\n                link = self._data_from_search.find('a', href=True)\n                return 'http://www.daft.ie' + link['href']\n            else:\n                return self._ad_page_content.find('link', {'rel': 'canonical'})['href']\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting daft_link. Error message: \" + e.args[0])\n            return", "response": "This method returns the url of the daft. ie."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef shortcode(self):\n        try:\n            div = self._ad_page_content.find(\n                'div', {'class': 'description_extras'})\n            index = [i for i, s in enumerate(\n                div.contents) if 'Shortcode' in str(s)][0] + 1\n            return div.contents[index]['href']\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting shortcode. Error message: \" + e.args[0])\n            return 'N/A'", "response": "This method returns the shortcode url of the listing."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef views(self):\n        try:\n            div = self._ad_page_content.find(\n                'div', {'class': 'description_extras'})\n            index = [i for i, s in enumerate(\n                div.contents) if 'Property Views' in str(s)][0] + 1\n            return int(''.join(list(filter(str.isdigit, div.contents[index]))))\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting views. Error message: \" + e.args[0])\n            return 'N/A'", "response": "This method returns the Property Views from listing."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dwelling_type(self):\n        try:\n            if self._data_from_search:\n                info = self._data_from_search.find(\n                    'ul', {\"class\": \"info\"}).text\n                s = info.split('|')\n                return s[0].strip()\n            else:\n                return self._ad_page_content.find(\n                    'div', {'id': 'smi-summary-items'}\n                ).find('span', {'class': 'header_text'}).text\n\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting dwelling_type. Error message: \" + e.args[0])\n            return", "response": "This method returns the dwelling type of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transport_routes(self):\n        routes = {}\n        try:\n            big_div = self._ad_page_content.find(\n                'div', {\"class\": \"half_area_box_right\"})\n            uls = big_div.find(\"ul\")\n            if uls is None:\n                return None\n            for li in uls.find_all('li'):\n                route_li = li.text.split(':')\n                routes[route_li[0]] = [x.strip()\n                                       for x in route_li[1].split(',')]\n            return routes\n        except Exception as e:\n            if self._debug:\n                logging.error(e.args[0])\n            return 'N/A'", "response": "This method gets a dict of routes listed in Daft."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef longitude(self):\n        try:\n            scripts = self._ad_page_content.find_all('script')\n            for script in scripts:\n                if 'longitude' in script.text:\n                    find_list = re.findall(\n                        r'\"longitude\":\"([\\-]?[0-9.]*[0-9]+)\"', script.text)\n                    if len(find_list) >= 1:\n                        return find_list[0]\n            return None\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting longitude. Error message: \" + e.args[0])\n            return None", "response": "This method gets a dict of routes listed in Daft."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ber_code(self):\n        try:\n            alt_text = self._ad_page_content.find(\n                'span', {'class': 'ber-hover'}\n            ).find('img')['alt']\n\n            if ('exempt' in alt_text):\n                return 'exempt'\n            else:\n                alt_arr = alt_text.split()\n                if 'ber' in alt_arr[0].lower():\n                    return alt_arr[1].lower()\n                else:\n                    return None\n        except Exception as e:\n            if self._debug:\n                logging.error(\n                    \"Error getting the Ber Code. Error message: \" + e.args[0])\n            return None", "response": "This method gets the Ber Code from the Daft."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_dict(self):\n        return {\n            'search_type': self.search_type,\n            'agent_id': self.agent_id,\n            'id': self.id,\n            'price': self.price,\n            'price_change': self.price_change,\n            'viewings': self.upcoming_viewings,\n            'facilities': self.facilities,\n            'overviews': self.overviews,\n            'formalised_address': self.formalised_address,\n            'address_line_1': self.address_line_1,\n            'county': self.county,\n            'listing_image': self.images,\n            'listing_hires_image': self.hires_images,\n            'agent': self.agent,\n            'agent_url': self.agent_url,\n            'contact_number': self.contact_number,\n            'daft_link': self.daft_link,\n            'shortcode': self.shortcode,\n            'date_insert_update': self.date_insert_update,\n            'views': self.views,\n            'description': self.description,\n            'dwelling_type': self.dwelling_type,\n            'posted_since': self.posted_since,\n            'num_bedrooms': self.bedrooms,\n            'num_bathrooms': self.bathrooms,\n            'city_center_distance': self.city_center_distance,\n            'transport_routes': self.transport_routes,\n            'latitude': self.latitude,\n            'longitude': self.longitude,\n            'ber_code': self.ber_code,\n            'commercial_area_size': self.commercial_area_size\n        }", "response": "Return a Listing object as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches the variables and functions", "response": "def on_config(self, config):\n        \"Fetch the variables and functions\"\n        #print(\"Here is the config:\", config)\n\n        # fetch variables from YAML file:\n        self._variables = config.get(YAML_SUBSET)\n\n        # add variables and functions from the module:\n        module_reader.load_variables(self._variables, config)\n\n        print(\"Variables:\", self.variables)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_page_markdown(self, markdown, page, config,\n                          site_navigation=None, **kwargs):\n        \"Provide a hook for defining functions from an external module\"\n\n        # the site_navigation argument has been made optional\n        # (deleted in post 1.0 mkdocs, but maintained here\n        # for backward compatibility)\n\n        if not self.variables:\n            return markdown\n\n        else:\n\n            # Create templae and get the variables\n            md_template = Template(markdown)\n\n            # Execute the jinja2 template and return\n            return md_template.render(**self.variables)", "response": "Provide a hook for defining functions from an external module"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the variables from the yaml file and add them to the internal list of variables.", "response": "def load_variables(variables, config):\n    \"\"\"\n    Add the template functions, via the python module\n    located in the same directory as the Yaml config file.\n\n    The python module must contain the following hook:\n\n    declare_variables(variables, macro):\n\n        variables['a'] = 5\n\n\n        @macro\n        def bar(x):\n            ....\n\n        @macro\n        def baz(x):\n            ....\n\n\n    \"\"\"\n\n    def macro(v, name=''):\n        \"\"\"\n        Registers a variable as a macro in the template,\n        i.e. in the variables dictionary:\n\n            macro(myfunc)\n\n        Optionally, you can assign a different name:\n\n            macro(myfunc, 'funcname')\n\n\n        You can also use it as a decorator:\n\n        @macro\n        def foo(a):\n            return a ** 2\n\n        More info:\n        https://stackoverflow.com/questions/6036082/call-a-python-function-from-jinja2\n        \"\"\"\n\n        name = name or v.__name__\n        variables[name] = v\n        return v\n\n\n\n    # determine the package name, from the filename:\n    python_module = config.get('python_module') or DEFAULT_MODULE_NAME\n    # get the directory of the yaml file:\n    config_file = config['config_file_path']\n    yaml_dir = os.path.dirname(config_file)\n    # print(\"Found yaml directory: %s\" % yaml_dir)\n\n    # that's the directory of the package:\n    repackage.add(yaml_dir)\n    try:\n        module = importlib.import_module(python_module)\n        print(\"Found module '%s'\" % python_module)\n        # execute the hook, passing the template decorator function\n        module.declare_variables(variables, macro)\n    except ModuleNotFoundError:\n        print(\"No module found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecoding bytes encoded with the standard Base64 alphabet.", "response": "def b64decode(s, altchars=None, validate=False):\n    \"\"\"Decode bytes encoded with the standard Base64 alphabet.\n\n    Argument ``s`` is a :term:`bytes-like object` or ASCII string to\n    decode.\n\n    Optional ``altchars`` must be a :term:`bytes-like object` or ASCII\n    string of length 2 which specifies the alternative alphabet used instead\n    of the '+' and '/' characters.\n\n    If ``validate`` is ``False`` (the default), characters that are neither in\n    the normal base-64 alphabet nor the alternative alphabet are discarded\n    prior to the padding check.\n    If ``validate`` is ``True``, these non-alphabet characters in the input\n    result in a :exc:`binascii.Error`.\n\n    The result is returned as a :class:`bytes` object.\n\n    A :exc:`binascii.Error` is raised if ``s`` is incorrectly padded.\n    \"\"\"\n    if version_info < (3, 0) or validate:\n        if validate and len(s) % 4 != 0:\n            raise BinAsciiError('Incorrect padding')\n        s = _get_bytes(s)\n        if altchars is not None:\n            altchars = _get_bytes(altchars)\n            assert len(altchars) == 2, repr(altchars)\n            if version_info < (3, 0):\n                map = maketrans(altchars, b'+/')\n            else:\n                map = bytes.maketrans(altchars, b'+/')\n            s = s.translate(map)\n        try:\n            result = builtin_decode(s, altchars)\n        except TypeError as e:\n            raise BinAsciiError(str(e))\n        if validate:\n            # check length of result vs length of input\n            padding = 0\n            if len(s) > 1 and s[-2] in (b'=', 61):\n                padding = padding + 1\n            if len(s) > 0 and s[-1] in (b'=', 61):\n                padding = padding + 1\n            if 3 * (len(s) / 4) - padding != len(result):\n                raise BinAsciiError('Non-base64 digit found')\n        return result\n    return builtin_decode(s, altchars)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding bytes using the standard Base64 alphabet.", "response": "def b64encode(s, altchars=None):\n    \"\"\"Encode bytes using the standard Base64 alphabet.\n\n    Argument ``s`` is a :term:`bytes-like object` to encode.\n\n    Optional ``altchars`` must be a byte string of length 2 which specifies\n    an alternative alphabet for the '+' and '/' characters.  This allows an\n    application to e.g. generate url or filesystem safe Base64 strings.\n\n    The result is returned as a :class:`bytes` object.\n    \"\"\"\n    if altchars is not None:\n        altchars = _get_bytes(altchars)\n        assert len(altchars) == 2, repr(altchars)\n    if version_info < (3, 0):\n        if isinstance(s, text_type):\n            raise TypeError('a bytes-like object is required, not \\''\n                            + type(s).__name__ + '\\'')\n    return builtin_encode(s, altchars)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nimproving file name by removing words such as HD Official etc.", "response": "def improve_name(song_name):\n    \"\"\"\n    Improves file name by removing words such as HD, Official,etc\n    eg : Hey Jude (Official HD) lyrics -> Hey Jude\n    This helps in better searching of metadata since a spotify search of\n    'Hey Jude (Official HD) lyrics' fetches 0 results\n    \"\"\"\n\n    try:\n        song_name = os.path.splitext(song_name)[0]\n    except IndexError:\n        pass\n\n    song_name = song_name.partition('ft')[0]\n\n    # Replace characters to filter with spaces\n    song_name = ''.join(\n        map(lambda c: \" \" if c in chars_filter else c, song_name))\n\n    # Remove crap words\n    song_name = re.sub('|'.join(re.escape(key) for key in words_filter),\n                       \"\", song_name, flags=re.IGNORECASE)\n\n    # Remove duplicate spaces\n    song_name = re.sub(' +', ' ', song_name)\n\n    return song_name.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngathers all urls titles for a search query from youtube", "response": "def get_song_urls(song_input):\n    \"\"\"\n    Gather all urls, titles for a search query\n    from youtube\n    \"\"\"\n    YOUTUBECLASS = 'spf-prefetch'\n\n    html = requests.get(\"https://www.youtube.com/results\",\n                        params={'search_query': song_input})\n    soup = BeautifulSoup(html.text, 'html.parser')\n\n    soup_section = soup.findAll('a', {'rel': YOUTUBECLASS})\n\n    # Use generator over list, since storage isn't important\n    song_urls = ('https://www.youtube.com' + i.get('href')\n                 for i in soup_section)\n    song_titles = (i.get('title') for i in soup_section)\n\n    youtube_list = list(zip(song_urls, song_titles))\n\n    del song_urls\n    del song_titles\n\n    return youtube_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload a song using youtube url and song title", "response": "def download_song(song_url, song_title):\n    \"\"\"\n    Download a song using youtube url and song title\n    \"\"\"\n\n    outtmpl = song_title + '.%(ext)s'\n    ydl_opts = {\n        'format': 'bestaudio/best',\n        'outtmpl': outtmpl,\n        'postprocessors': [\n            {'key': 'FFmpegExtractAudio','preferredcodec': 'mp3',\n             'preferredquality': '192',\n            },\n            {'key': 'FFmpegMetadata'},\n        ],\n    }\n\n    with youtube_dl.YoutubeDL(ydl_opts) as ydl:\n        info_dict = ydl.extract_info(song_url, download=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry finding metadata through Spotify", "response": "def get_metadata(file_name, client_id, client_secret):\n    \"\"\"\n    Tries finding metadata through Spotify\n    \"\"\"\n\n    song_name = improve_name(file_name)  # Remove useless words from title\n    client_credentials_manager = SpotifyClientCredentials(client_id, client_secret)\n\n    spotify = spotipy.Spotify(client_credentials_manager=client_credentials_manager)\n    results = spotify.search(song_name, limit=1)\n\n    results = results['tracks']['items'][0]  # Find top result\n    album = results['album']['name']  # Parse json dictionary\n    artist = results['album']['artists'][0]['name']\n    song_title = results['name']\n    album_art = results['album']['images'][0]['url']\n\n    return artist, album, song_title, album_art"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_album_art(file_name, album_art):\n\n    img = requests.get(album_art, stream=True)  # Gets album art from url\n    img = img.raw\n\n    audio = EasyMP3(file_name, ID3=ID3)\n\n    try:\n        audio.add_tags()\n    except _util.error:\n        pass\n\n    audio.tags.add(\n        APIC(\n            encoding=3,  # UTF-8\n            mime='image/png',\n            type=3,  # 3 is for album art\n            desc='Cover',\n            data=img.read()  # Reads and adds album art\n        )\n    )\n    audio.save()\n\n    return album_art", "response": "Add album_art in. mp3 s tags\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding metadata to the neccessary object.", "response": "def add_metadata(file_name, title, artist, album):\n    \"\"\"\n    As the method name suggests\n    \"\"\"\n    \n    tags = EasyMP3(file_name)\n    if title: \n        tags[\"title\"] = title\n    if artist:     \n        tags[\"artist\"] = artist\n    if album:\n        tags[\"album\"] = album\n    tags.save()\n\n    return file_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef revert_metadata(files):\n    for file_path in files:\n        tags = EasyMP3(file_path)\n        tags.delete()\n        tags.save()", "response": "Revert all tags from a mp3 file to a new mp3 file"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a vault_id string or None", "response": "def get_user_vault_instance_or_none(self, user):\n        \"\"\"Returns a vault_id string or None\"\"\"\n        qset = self.filter(user=user)\n        if not qset:\n            return None\n        \n        if qset.count() > 1:\n            raise Exception('This app does not currently support multiple vault ids')\n        \n        return qset.get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncharging a user in a vault.", "response": "def charge(self, user, vault_id=None):\n        \"\"\"If vault_id is not passed this will assume that there is only one instane of user and vault_id in the db.\"\"\"\n        assert self.is_in_vault(user)\n        if vault_id:\n            user_vault = self.get(user=user, vault_id=vault_id)\n        else:\n            user_vault = self.get(user=user)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef charge(self, amount):\n        try:\n            result = Transaction.sale(\n                {\n                    'amount': amount.quantize(Decimal('.01')),\n                    'customer_id': self.vault_id,\n                    \"options\": {\n                        \"submit_for_settlement\": True\n                    }\n                }\n            )\n\n            if result.is_success:\n                # create a payment log\n                payment_log = PaymentLog.objects.create(user=self.user, amount=amount, transaction_id=result.transaction.id)\n                return payment_log\n            else:\n                raise Exception('Logical error in CC transaction')\n        except Exception:\n            logging.error('Failed to charge $%s to user: %s with vault_id: %s' % (amount, self.user, self.vault_id))\n            return None", "response": "Charge the users credit card with he passed amount. Returns the payment log instance if successful."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the current user to the vault.", "response": "def save(self, prepend_vault_id=''):\n        \"\"\"\n        Adds or updates a users CC to the vault.\n        \n        @prepend_vault_id: any string to prepend all vault id's with in case the same braintree account is used by\n        multiple projects/apps.\n        \"\"\"\n        assert self.is_valid()\n        \n        cc_details_map = {    # cc details\n            'number': self.cleaned_data['cc_number'],\n            'cardholder_name': self.cleaned_data['name'],\n            'expiration_date': '%s/%s' %\\\n                (self.cleaned_data['expiration_month'], self.cleaned_data['expiration_year']),\n            'cvv': self.cleaned_data['cvv'],\n            'billing_address': {\n                'postal_code': self.cleaned_data['zip_code'],\n            }\n        }\n        \n        if self.__user_vault:\n            try:\n                # get customer info, its credit card and then update that credit card\n                response = Customer.find(self.__user_vault.vault_id)\n                cc_info = response.credit_cards[0]\n                return CreditCard.update(cc_info.token, params=cc_details_map)\n            except Exception, e:\n                logging.error('Was not able to get customer from vault. %s' % e)\n                self.__user_vault.delete()  # delete the stale instance from our db\n        \n        # in case the above updating fails or user was never in the vault\n        new_customer_vault_id = '%s%s' % (prepend_vault_id, md5_hash()[:24])\n        respone = Customer.create({    # creating a customer, but we really just want to store their CC details\n            'id': new_customer_vault_id,   # vault id, uniquely identifies customer. We're not caring about tokens (used for storing multiple CC's per user)\n            'credit_card': cc_details_map\n        })\n        \n        if respone.is_success:  # save a new UserVault instance\n            UserVault.objects.create(user=self.__user, vault_id=new_customer_vault_id)\n        \n        return respone"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef payments_billing(request, template='django_braintree/payments_billing.html'):\n    d = {}\n    \n    if request.method == 'POST':\n        # Credit Card is being changed/updated by the user\n        form = UserCCDetailsForm(request.user, True, request.POST)\n        if form.is_valid():\n            response = form.save()\n            if response.is_success:\n                messages.add_message(request, messages.SUCCESS, 'Your credit card information has been securely saved.')\n                return JsonResponse()\n            else:\n                return JsonResponse(success=False, errors=[BAD_CC_ERROR_MSG])\n        \n        return JsonResponse(success=False, data={'form': form_errors_serialize(form)})\n    else:\n        if UserVault.objects.is_in_vault(request.user):\n            try:\n                response = Customer.find(UserVault.objects.get_user_vault_instance_or_none(request.user).vault_id)\n                d['current_cc_info'] = response.credit_cards[0]\n            except Exception, e:\n                logging.error('Unable to get vault information for user from braintree. %s' % e)\n        d['cc_form'] = UserCCDetailsForm(request.user)\n    \n    return render(request, template, d)", "response": "Renders both the past payments that have occurred on the users credit card and their CC information on file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsnooze incident. :param requester: The email address of the individual requesting snooze.", "response": "def snooze(self, requester, duration):\n        \"\"\"Snooze incident.\n        :param requester: The email address of the individual requesting snooze.\n        \"\"\"\n        path = '{0}/{1}/{2}'.format(self.collection.name, self.id, 'snooze')\n        data = {\"duration\": duration}\n        extra_headers = {\"From\": requester}\n        return self.pagerduty.request('POST', path, data=_json_dumper(data), extra_headers=extra_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreassigning this incident to a user or list of users", "response": "def reassign(self, user_ids, requester):\n        \"\"\"Reassign this incident to a user or list of users\n\n        :param user_ids: A non-empty list of user ids\n        :param requester: The email address of individual requesting reassign\n        \"\"\"\n        path = '{0}'.format(self.collection.name)\n        assignments = []\n        if not user_ids:\n            raise Error('Must pass at least one user id')\n        for user_id in user_ids:\n            ref = {\n                \"assignee\": {\n                    \"id\": user_id,\n                    \"type\": \"user_reference\"\n                }\n            }\n            assignments.append(ref)\n        data = {\n            \"incidents\": [\n                {\n                    \"id\": self.id,\n                    \"type\": \"incident_reference\",\n                    \"assignments\": assignments\n                }\n            ]\n        }\n        extra_headers = {\"From\": requester}\n        return self.pagerduty.request('PUT', path, data=_json_dumper(data), extra_headers=extra_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve_incident(self, incident_key,\n                         description=None, details=None):\n        \"\"\" Causes the referenced incident to enter resolved state.\n        Send a resolve event when the problem that caused the initial\n        trigger has been fixed.\n        \"\"\"\n\n        return self.create_event(description, \"resolve\",\n                                 details, incident_key)", "response": "Send a resolve event when the problem that caused the referenced incident to enter resolved state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _lower(string):\n    if not string:\n        return \"\"\n\n    new_string = [string[0].lower()]\n    for char in string[1:]:\n        if char.isupper():\n            new_string.append(\"_\")\n        new_string.append(char.lower())\n\n    return \"\".join(new_string)", "response": "Custom lower string function."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reassign(self, user_ids, requester_id):\n        if not user_ids:\n            raise Error('Must pass at least one user id')\n        self._do_action('reassign', requester_id=requester_id, assigned_to_user=','.join(user_ids))", "response": "Reassign this incident to a user or list of users\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef acknowledge_incident(self, service_key, incident_key,\n                             description=None, details=None):\n        \"\"\" Causes the referenced incident to enter the acknowledged state.\n        Send an acknowledge event when someone is presently working on the\n        incident.\n        \"\"\"\n\n        return self.create_event(service_key, description, \"acknowledge\",\n                                 details, incident_key)", "response": "Send an acknowledge event to the user who has entered the acknowledged state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreports a new or ongoing problem.", "response": "def trigger_incident(self, service_key, description,\n                         incident_key=None, details=None,\n                         client=None, client_url=None, contexts=None):\n        \"\"\" Report a new or ongoing problem. When PagerDuty receives a trigger,\n        it will either open a new incident, or add a new log entry to an\n        existing incident.\n        \"\"\"\n\n        return self.create_event(service_key, description, \"trigger\",\n                                 details, incident_key,\n                                 client=client, client_url=client_url, contexts=contexts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfirms shape of dataset and range of array", "response": "def check_dataset(dataset):\n    \"\"\"Confirm shape (3 colors x rows x cols) and values [0 to 255] are OK.\"\"\"\n    if isinstance(dataset, numpy.ndarray) and not len(dataset.shape) == 4:\n        check_dataset_shape(dataset)\n        check_dataset_range(dataset)\n    else:  # must be a list of arrays or a 4D NumPy array\n        for i, d in enumerate(dataset):\n            if not isinstance(d, numpy.ndarray):\n                raise ValueError(\n                    'Requires a NumPy array (rgb x rows x cols) '\n                    'with integer values in the range [0, 255].'\n                )\n            try:\n                check_dataset_shape(d)\n                check_dataset_range(d)\n            except ValueError as err:\n                raise ValueError(\n                    '{}\\nAt position {} in the list of arrays.'\n                    .format(err, i)\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef try_fix_dataset(dataset):\n    if isinstance(dataset, numpy.ndarray):\n        if len(dataset.shape) == 3:  # NumPy 3D\n            if dataset.shape[-1] == 3:\n                return dataset.transpose((2, 0, 1))\n        elif len(dataset.shape) == 4:  # NumPy 4D\n            if dataset.shape[-1] == 3:\n                return dataset.transpose((0, 3, 1, 2))\n        # Otherwise couldn't fix it.\n        return dataset\n    # List of Numpy 3D arrays.\n    for i, d in enumerate(dataset):\n        if not isinstance(d, numpy.ndarray):\n            return dataset\n        if not (len(d.shape) == 3 and d.shape[-1] == 3):\n            return dataset\n        dataset[i] = d.transpose()\n    return dataset", "response": "Transpose the image data if it s in PIL format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts the NumPy array to two nested lists with r g b tuples.", "response": "def get_image(dataset):\n    \"\"\"Convert the NumPy array to two nested lists with r,g,b tuples.\"\"\"\n    dim, nrow, ncol = dataset.shape\n    uint8_dataset = dataset.astype('uint8')\n    if not (uint8_dataset == dataset).all():\n        message = (\n            \"\\nYour image was cast to a `uint8` (`<img>.astype(uint8)`), \"\n            \"but some information was lost.\\nPlease check your gif and \"\n            \"convert to uint8 beforehand if the gif looks wrong.\"\n        )\n        warnings.warn(message)\n    image = [[\n            struct.pack(\n                'BBB',\n                uint8_dataset[0, i, j],\n                uint8_dataset[1, i, j],\n                uint8_dataset[2, i, j]\n            )\n            for j in range(ncol)]\n        for i in range(nrow)]\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_color_table_size(num_colors):\n    nbits = max(math.ceil(math.log(num_colors, 2)), 2)\n    return '{:03b}'.format(int(nbits - 1))", "response": "Returns the size of the color table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Counter containing each color and how often it appears.", "response": "def get_colors(image):\n    \"\"\"Return a Counter containing each color and how often it appears.\n    \"\"\"\n    colors = Counter(pixel for row in image for pixel in row)\n    if len(colors) > 256:\n        msg = (\n            \"The maximum number of distinct colors in a GIF is 256 but \"\n            \"this image has {} colors and can't be encoded properly.\"\n        )\n        raise RuntimeError(msg.format(len(colors)))\n    return colors"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a color table sorted in descending order of count.", "response": "def _get_global_color_table(colors):\n    \"\"\"Return a color table sorted in descending order of count.\n    \"\"\"\n    global_color_table = b''.join(c[0] for c in colors.most_common())\n    full_table_size = 2**(1+int(get_color_table_size(len(colors)), 2))\n    repeats = 3 * (full_table_size - len(colors))\n    zeros = struct.pack('<{}x'.format(repeats))\n    return global_color_table + zeros"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform the LZW compression as described by Matthew Flickinger.", "response": "def _get_image_data(image, colors):\n    \"\"\"Performs the LZW compression as described by Matthew Flickinger.\n\n    This isn't fast, but it works.\n    http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp\n    \"\"\"\n    lzw_code_size, coded_bits = _lzw_encode(image, colors)\n    coded_bytes = ''.join(\n        '{{:0{}b}}'.format(nbits).format(val) for val, nbits in coded_bits)\n    coded_bytes = '0' * ((8 - len(coded_bytes)) % 8) + coded_bytes\n    coded_data = list(\n        reversed([\n            int(coded_bytes[8*i:8*(i+1)], 2)\n            for i in range(len(coded_bytes) // 8)\n        ])\n    )\n    output = [struct.pack('<B', lzw_code_size)]\n    # Must output the data in blocks of length 255\n    block_length = min(255, len(coded_data))\n    while block_length > 0:\n        block = struct.pack(\n            '<{}B'.format(block_length + 1),\n            block_length,\n            *coded_data[:block_length]\n        )\n        output.append(block)\n        coded_data = coded_data[block_length:]\n        block_length = min(255, len(coded_data))\n    return b''.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_gif(dataset, filename, fps=10):\n    try:\n        check_dataset(dataset)\n    except ValueError as e:\n        dataset = try_fix_dataset(dataset)\n        check_dataset(dataset)\n    delay_time = 100 // int(fps)\n\n    def encode(d):\n        four_d = isinstance(dataset, numpy.ndarray) and len(dataset.shape) == 4\n        if four_d or not isinstance(dataset, numpy.ndarray):\n            return _make_animated_gif(d, delay_time=delay_time)\n        else:\n            return _make_gif(d)\n\n    with open(filename, 'wb') as outfile:\n        outfile.write(HEADER)\n        for block in encode(dataset):\n            outfile.write(block)\n        outfile.write(TRAILER)", "response": "Write a NumPy array to GIF 89a format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_stylesheet():\n\n    # Smart import of the rc file\n    f = QtCore.QFile(':qdarkgraystyle/style.qss')\n    if not f.exists():\n        _logger().error('Unable to load stylesheet, file not found in '\n                        'resources')\n        return ''\n    else:\n        f.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text)\n        ts = QtCore.QTextStream(f)\n        stylesheet = ts.readAll()\n        if platform.system().lower() == 'darwin':  # see issue #12 on github\n            mac_fix = '''\n            QDockWidget::title\n            {\n                background-color: #31363b;\n                text-align: center;\n                height: 12px;\n            }\n            '''\n            stylesheet += mac_fix\n        return stylesheet", "response": "Loads the stylesheet for use in a pyqt5 application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting time offset that aligns image timestamps with gyro timestamps. Given an image sequence, and gyroscope data, with their respective timestamps, calculate the offset that aligns the image data with the gyro data. The timestamps must only differ by an offset, not a scale factor. This function finds an approximation of the offset *d* that makes this transformation t_gyro = t_camera + d i.e. your new image timestamps should be image_timestamps_aligned = image_timestamps + d The offset is calculated using zero-mean cross correlation of the gyroscope data magnitude and the optical flow magnitude, calculated from the image sequence. ZNCC is performed using pyramids to make it quick. The offset is accurate up to about +/- 2 frames, so you should run *refine_time_offset* if you need better accuracy. Parameters --------------- image_sequence_or_flow : sequence of image data, or ndarray This must be either a list or generator that provides a stream of images that are used for optical flow calculations. image_timestamps : ndarray Timestamps of the images in image_sequence gyro_data : (3, N) ndarray Gyroscope measurements (angular velocity) gyro_timestamps : ndarray Timestamps of data in gyro_data levels : int Number of pyramid levels full_output : bool If False, only return the offset, otherwise return extra data Returns -------------- time_offset : float The time offset to add to image_timestamps to align the image data with the gyroscope data flow : ndarray (Only if full_output=True) The calculated optical flow magnitude", "response": "def sync_camera_gyro(image_sequence_or_flow, image_timestamps, gyro_data, gyro_timestamps, levels=6, full_output=False):\n    \"\"\"Get time offset that aligns image timestamps with gyro timestamps.\n    \n    Given an image sequence, and gyroscope data, with their respective timestamps,\n    calculate the offset that aligns the image data with the gyro data.\n    The timestamps must only differ by an offset, not a scale factor.\n\n    This function finds an approximation of the offset *d* that makes this transformation\n\n        t_gyro = t_camera + d\n        \n    i.e. your new image timestamps should be\n    \n        image_timestamps_aligned = image_timestamps + d\n        \n    The offset is calculated using zero-mean cross correlation of the gyroscope data magnitude\n    and the optical flow magnitude, calculated from the image sequence.\n    ZNCC is performed using pyramids to make it quick.\n    \n    The offset is accurate up to about +/- 2 frames, so you should run\n    *refine_time_offset* if you need better accuracy.\n    \n    Parameters\n    ---------------\n    image_sequence_or_flow : sequence of image data, or ndarray\n            This must be either a list or generator that provides a stream of \n            images that are used for optical flow calculations.\n    image_timestamps : ndarray\n            Timestamps of the images in image_sequence\n    gyro_data : (3, N) ndarray\n            Gyroscope measurements (angular velocity)\n    gyro_timestamps : ndarray\n            Timestamps of data in gyro_data\n    levels : int\n            Number of pyramid levels\n    full_output : bool\n            If False, only return the offset, otherwise return extra data\n            \n    Returns\n    --------------\n    time_offset  :  float\n            The time offset to add to image_timestamps to align the image data\n            with the gyroscope data\n    flow : ndarray\n            (Only if full_output=True)\n            The calculated optical flow magnitude\n    \"\"\"\n    \n    # If input is not flow, then create from iamge sequence\n    try:\n        assert image_sequence_or_flow.ndim == 1\n        flow_org = image_sequence_or_flow\n    except AssertionError:    \n        flow_org = tracking.optical_flow_magnitude(image_sequence_or_flow)\n    \n    # Gyro from gyro data\n    gyro_mag = np.sum(gyro_data**2, axis=0)\n    flow_timestamps = image_timestamps[:-2]\n\n    # Resample to match highest\n    rate = lambda ts: len(ts) / (ts[-1] - ts[0])\n    freq_gyro = rate(gyro_timestamps)\n    freq_image = rate(flow_timestamps)\n    \n    if freq_gyro > freq_image:\n        rel_rate = freq_gyro / freq_image\n        flow_mag = znccpyr.upsample(flow_org, rel_rate)\n    else:\n        flow_mag = flow_org\n        rel_rate = freq_image / freq_gyro\n        gyro_mag = znccpyr.upsample(gyro_mag, rel_rate)\n    \n    ishift = znccpyr.find_shift_pyr(flow_mag, gyro_mag, levels)\n    \n    if freq_gyro > freq_image:\n        flow_shift = int(-ishift / rel_rate)\n    else:\n        flow_shift = int(-ishift)\n    \n    time_offset = flow_timestamps[flow_shift]\n    \n    if full_output:\n        return time_offset, flow_org # Return the orginal flow, not the upsampled version\n    else:\n        return time_offset"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting time offset that aligns image timestamps with gyro timestamps. Given an image sequence, and gyroscope data, with their respective timestamps, calculate the offset that aligns the image data with the gyro data. The timestamps must only differ by an offset, not a scale factor. This function finds an approximation of the offset *d* that makes this transformation t_gyro = t_camera + d i.e. your new image timestamps should be image_timestamps_aligned = image_timestamps + d The offset is calculated using correlation. The parts of the signals to use are chosen by the user by picking points in a plot window. The offset is accurate up to about +/- 2 frames, so you should run *refine_time_offset* if you need better accuracy. Parameters --------------- image_sequence : sequence of image data This must be either a list or generator that provides a stream of images that are used for optical flow calculations. image_timestamps : ndarray Timestamps of the images in image_sequence gyro_data : (3, N) ndarray Gyroscope measurements (angular velocity) gyro_timestamps : ndarray Timestamps of data in gyro_data full_output : bool If False, only return the offset, otherwise return extra data Returns -------------- time_offset : float The time offset to add to image_timestamps to align the image data with the gyroscope data flow : ndarray (Only if full_output=True) The calculated optical flow magnitude frame_pair : (int, int) The frame pair that was picked for synchronization", "response": "def sync_camera_gyro_manual(image_sequence, image_timestamps, gyro_data, gyro_timestamps, full_output=False):\n    \"\"\"Get time offset that aligns image timestamps with gyro timestamps.\n    \n    Given an image sequence, and gyroscope data, with their respective timestamps,\n    calculate the offset that aligns the image data with the gyro data.\n    The timestamps must only differ by an offset, not a scale factor.\n\n    This function finds an approximation of the offset *d* that makes this transformation\n\n        t_gyro = t_camera + d\n        \n    i.e. your new image timestamps should be\n    \n        image_timestamps_aligned = image_timestamps + d\n        \n    The offset is calculated using correlation. The parts of the signals to use are\n    chosen by the user by picking points in a plot window.\n\n    The offset is accurate up to about +/- 2 frames, so you should run\n    *refine_time_offset* if you need better accuracy.\n    \n    Parameters\n    ---------------\n    image_sequence : sequence of image data\n            This must be either a list or generator that provides a stream of \n            images that are used for optical flow calculations.\n    image_timestamps : ndarray\n            Timestamps of the images in image_sequence\n    gyro_data : (3, N) ndarray\n            Gyroscope measurements (angular velocity)\n    gyro_timestamps : ndarray\n            Timestamps of data in gyro_data\n    full_output : bool\n            If False, only return the offset, otherwise return extra data\n            \n    Returns\n    --------------\n    time_offset  :  float\n            The time offset to add to image_timestamps to align the image data\n            with the gyroscope data\n    flow : ndarray\n            (Only if full_output=True)\n            The calculated optical flow magnitude\n    frame_pair : (int, int)\n            The frame pair that was picked for synchronization\n    \"\"\"\n    \n    flow = tracking.optical_flow_magnitude(image_sequence)\n    flow_timestamps = image_timestamps[:-2]    \n    \n    # Let user select points in both pieces of data\n    (frame_pair, gyro_idx) = manual_sync_pick(flow, gyro_timestamps, gyro_data)\n    \n    # Normalize data\n    gyro_abs_max = np.max(np.abs(gyro_data), axis=0)\n    gyro_normalized = (gyro_abs_max / np.max(gyro_abs_max)).flatten()\n    flow_normalized = (flow / np.max(flow)).flatten()\n\n    rate = lambda ts: len(ts) / (ts[-1] - ts[0])\n\n    # Resample to match highest\n    freq_gyro = rate(gyro_timestamps)\n    freq_image = rate(flow_timestamps)\n    logger.debug(\"Gyro sampling frequency: %.2f Hz, Image sampling frequency: %.2f Hz\", freq_gyro, freq_image)\n    \n    gyro_part = gyro_normalized[gyro_idx[0]:gyro_idx[1]+1] # only largest\n    flow_part = flow_normalized[frame_pair[0]:frame_pair[1]+1]\n    \n    N = flow_part.size * freq_gyro / freq_image\n    flow_part_resampled = ssig.resample(flow_part, N).flatten()\n    \n    # ) Cross correlate the two signals and find time diff\n    corr = ssig.correlate(gyro_part, flow_part_resampled, 'full') # Find the flow in gyro data\n \n    i = np.argmax(corr)\n    \n    t_0_f = flow_timestamps[frame_pair[0]]\n    t_1_f = flow_timestamps[frame_pair[1]]\n    \n    t_off_g = gyro_timestamps[gyro_idx[0] + i]\n    t_off_f = t_1_f\n    time_offset = t_off_g - t_off_f\n    \n    if full_output:\n        return time_offset, flow, frame_pair\n    else:\n        return time_offset"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrefines a time offset between camera and IMU using rolling shutter aware optimization. To refine the time offset using this function, you must meet the following constraints 1) The data must already be roughly aligned. Only a few image frames of error is allowed. 2) The images *must* have been captured by a *rolling shutter* camera. This function finds a refined offset using optimization. Points are first tracked from the start to the end of the provided images. Then an optimization function looks at the reprojection error of the tracked points given the IMU-data and the refined offset. The found offset *d* is such that you want to perform the following time update new_frame_timestamps = frame_timestamps + d Parameters ------------ image_list : list of ndarray A list of images to perform tracking on. High quality tracks are required, so make sure the sequence you choose is easy to track in. frame_timestamps : ndarray Timestamps of image_list rotation_sequence : (4, N) ndarray Absolute rotations as a sequence of unit quaternions (first element is scalar). rotation_timestamps : ndarray Timestamps of rotation_sequence camera_matrix : (3,3) ndarray The internal camera calibration matrix of the camera. readout_time : float The readout time of the camera. Returns ------------ offset : float A refined offset that aligns the image data with the rotation data.", "response": "def refine_time_offset(image_list, frame_timestamps, rotation_sequence, rotation_timestamps, camera_matrix, readout_time):\n    \"\"\"Refine a time offset between camera and IMU using rolling shutter aware optimization.\n    \n    To refine the time offset using this function, you must meet the following constraints\n    \n    1) The data must already be roughly aligned. Only a few image frames of error\n        is allowed.\n    2) The images *must* have been captured by a *rolling shutter* camera.\n    \n    This function finds a refined offset using optimization.\n    Points are first tracked from the start to the end of the provided images.\n    Then an optimization function looks at the reprojection error of the tracked points\n    given the IMU-data and the refined offset.\n    \n    The found offset *d* is such that you want to perform the following time update\n    \n        new_frame_timestamps = frame_timestamps + d\n    \n    Parameters\n    ------------\n    image_list : list of ndarray\n            A list of images to perform tracking on. High quality tracks are required,\n            so make sure the sequence you choose is easy to track in.\n    frame_timestamps : ndarray\n            Timestamps of image_list\n    rotation_sequence : (4, N) ndarray\n            Absolute rotations as a sequence of unit quaternions (first element is scalar).\n    rotation_timestamps : ndarray\n            Timestamps of rotation_sequence\n    camera_matrix : (3,3) ndarray\n            The internal camera calibration matrix of the camera.\n    readout_time : float\n            The readout time of the camera.\n            \n    Returns\n    ------------\n    offset : float\n            A refined offset that aligns the image data with the rotation data.\n    \"\"\"\n    # ) Track points\n    max_corners = 200\n    quality_level = 0.07\n    min_distance = 5\n    max_tracks = 20\n    initial_points = cv2.goodFeaturesToTrack(image_list[0], max_corners, quality_level, min_distance)\n    (points, status) = tracking.track_retrack(image_list, initial_points)\n\n    # Prune to at most max_tracks number of tracks, choose randomly    \n    track_id_list = np.random.permutation(points.shape[0])[:max_tracks]\n        \n    rows, cols = image_list[0].shape[:2]\n    row_delta_time = readout_time / rows            \n    num_tracks, num_frames, _ = points.shape\n    K = np.matrix(camera_matrix)\n    \n    def func_to_optimize(td, *args):\n        res = 0.0\n        N = 0\n        for frame_idx in range(num_frames-1):            \n            for track_id in track_id_list:                \n                p1 = points[track_id, frame_idx, :].reshape((-1,1))\n                p2 = points[track_id, frame_idx + 1, :].reshape((-1,1))\n                t1 = frame_timestamps[frame_idx] + (p1[1] - 1) * row_delta_time + td\n                t2 = frame_timestamps[frame_idx + 1] + (p2[1] - 1) * row_delta_time +td\n                t1 = float(t1)\n                t2 = float(t2)\n                q1 = IMU.rotation_at_time(t1, rotation_timestamps, rotation_sequence)\n                q2 = IMU.rotation_at_time(t2, rotation_timestamps, rotation_sequence)\n                R1 = rotations.quat_to_rotation_matrix(q1)\n                R2 = rotations.quat_to_rotation_matrix(q2)\n                p1_rec = K.dot(R1.T).dot(R2).dot(K.I).dot(np.vstack((p2, 1)))\n                if p1_rec[2] == 0:\n                    continue\n                else:\n                    p1_rec /= p1_rec[2]                    \n                res += np.sum((p1 - np.array(p1_rec[0:2]))**2)\n                N += 1\n        return res / N\n    \n    # Bounded Brent optimizer\n    t0 = time.time()\n    tolerance = 1e-4 # one tenth millisecond\n    (refined_offset, fval, ierr, numfunc) = scipy.optimize.fminbound(func_to_optimize, -0.12, 0.12, xtol=tolerance, full_output=True)\n    t1 = time.time()\n    if ierr == 0:\n        logger.info(\"Time offset found by brent optimizer: %.4f. Elapsed: %.2f seconds (%d function calls)\", refined_offset, t1-t0, numfunc)\n    else:\n        logger.error(\"Brent optimizer did not converge. Aborting!\")\n        raise Exception(\"Brent optimizer did not converge, when trying to refine offset.\")\n    \n    return refined_offset"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of good frames to track in the given optical flow.", "response": "def good_sequences_to_track(flow, motion_threshold=1.0):\n    \"\"\"Get list of good frames to do tracking in.\n\n    Looking at the optical flow, this function chooses a span of frames\n    that fulfill certain criteria.\n    These include\n        * not being too short or too long\n        * not too low or too high mean flow magnitude\n        * a low max value (avoids motion blur)\n    Currently, the cost function for a sequence is hard coded. Sorry about that.\n    \n    Parameters\n    -------------\n    flow : ndarray\n            The optical flow magnitude\n    motion_threshold : float\n            The maximum amount of motion to consider for sequence endpoints.\n            \n    Returns\n    ------------\n    sequences : list\n            Sorted list of (a, b, score) elements (highest scpre first) of sequences\n            where a sequence is frames with frame indices in the span [a, b].\n    \"\"\"\n    endpoints = []\n    in_low = False\n    for i, val in enumerate(flow):\n        if val < motion_threshold:\n            if not in_low:\n                endpoints.append(i)\n                in_low = True\n        else:\n            if in_low:\n                endpoints.append(i-1) # Previous was last in a low spot\n            in_low = False\n    \n    def mean_score_func(m):\n        mu = 15\n        sigma = 8\n        top_val = normpdf(mu, mu, sigma)\n        return normpdf(m, mu, sigma) / top_val\n    \n    def max_score_func(m):\n        mu = 40\n        sigma = 8\n        if m <= mu:\n            return 1.\n        else:\n            top_val = normpdf(mu, mu, sigma)\n            return normpdf(m, mu, sigma) / top_val\n    \n    def length_score_func(l):\n        mu = 30\n        sigma = 10\n        top_val = normpdf(mu, mu, sigma)\n        return normpdf(l, mu, sigma) / top_val\n    \n    min_length = 5 # frames\n    sequences = []\n    for k, i in enumerate(endpoints[:-1]):\n        for j in endpoints[k+1:]:\n            length = j - i\n            if length < min_length:\n                continue\n            seq = flow[i:j+1]\n            m_score = mean_score_func(np.mean(seq))\n            mx_score = max_score_func(np.max(seq))\n            l_score = length_score_func(length)\n            logger.debug(\"%d, %d scores: (mean=%.5f, max=%.5f, length=%.5f)\" % (i,j,m_score, mx_score, l_score))\n            if min(m_score, mx_score, l_score) < 0.2:\n                continue\n            \n            score = m_score + mx_score + l_score \n            sequences.append((i, j, score))\n\n    return sorted(sequences, key=lambda x: x[2], reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the calendar with the provided gyroscope sample rate and optionally a list of slices.", "response": "def initialize(self, gyro_rate, slices=None, skip_estimation=False):\n        \"\"\"Prepare calibrator for calibration\n\n        This method does three things:\n        1. Create slices from the video stream, if not already provided\n        2. Estimate time offset\n        3. Estimate rotation between camera and gyroscope\n\n        Parameters\n        ------------------\n        gyro_rate : float\n            Estimated gyroscope sample rate\n        slices : list of Slice, optional\n            Slices to use for optimization\n        skip_estimation : bool\n            Do not estimate initial time offset and rotation.\n\n        Raises\n        --------------------\n        InitializationError\n            If the initialization fails\n        \"\"\"\n        self.params['user']['gyro_rate'] = gyro_rate\n\n        for p in ('gbias_x', 'gbias_y', 'gbias_z'):\n            self.params['initialized'][p] = 0.0\n\n        if slices is not None:\n            self.slices = slices\n\n        if self.slices is None:\n            self.slices = videoslice.Slice.from_stream_randomly(self.video)\n            logger.debug(\"Number of slices: {:d}\".format(len(self.slices)))\n\n        if len(self.slices) < 2:\n            logger.error(\"Calibration requires at least 2 video slices to proceed, got %d\", len(self.slices))\n            raise InitializationError(\"Calibration requires at least 2 video slices to proceed, got {:d}\".format(len(self.slices)))\n\n        if not skip_estimation:\n            time_offset = self.find_initial_offset()\n            # TODO: Detect when time offset initialization fails, and raise InitializationError\n\n            R = self.find_initial_rotation()\n            if R is None:\n                raise InitializationError(\"Failed to calculate initial rotation\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef video_time_to_gyro_sample(self, t):\n        f_g = self.parameter['gyro_rate']\n        d_c = self.parameter['time_offset']\n        n = f_g * (t + d_c)\n        n0 = int(np.floor(n))\n        tau = n - n0\n        return n0, tau", "response": "Convert video time to gyroscope sample index and interpolation factor"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parameter(self):\n        D = {}\n        for source in PARAM_SOURCE_ORDER:\n            D.update(self.params[source])\n        return D", "response": "Return the current best value of a parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calibrate(self, max_tracks=MAX_OPTIMIZATION_TRACKS, max_eval=MAX_OPTIMIZATION_FEV, norm_c=DEFAULT_NORM_C):\n        x0 = np.array([self.parameter[param] for param in PARAM_ORDER])\n        available_tracks = np.sum([len(s.inliers) for s in self.slices])\n        if available_tracks < max_tracks:\n            warnings.warn(\"Could not use the requested {} tracks, since only {} were available in the slice data.\".format(max_tracks, available_tracks))\n            max_tracks = available_tracks\n\n        # Get subset of available tracks such that all slices are still used\n        slice_sample_idxs = videoslice.fill_sampling(self.slices, max_tracks)\n\n        func_args = (self.slices, slice_sample_idxs, self.video.camera_model, self.gyro, norm_c)\n        self.slice_sample_idxs = slice_sample_idxs\n        logger.debug(\"Starting optimization on {:d} slices and {:d} tracks\".format(len(self.slices), max_tracks))\n        start_time = time.time()\n        # TODO: Check what values of ftol and xtol are required for good results. The current setting is probably pessimistic.\n        leastsq_result = scipy.optimize.leastsq(optimization_func, x0, args=func_args, full_output=True, ftol=1e-10, xtol=1e-10, maxfev=max_eval)\n        elapsed = time.time() - start_time\n        x, covx, infodict, mesg, ier = leastsq_result\n        self.__debug_leastsq = leastsq_result\n        logger.debug(\"Optimization completed in {:.1f} seconds and {:d} function evaluations. ier={}, mesg='{}'\".format(elapsed, infodict['nfev'], ier, mesg))\n        if ier in (1,2,3,4):\n            for pname, val in zip(PARAM_ORDER, x):\n                self.params['calibrated'][pname] = val\n            return self.parameter\n        else:\n            raise CalibrationError(mesg)", "response": "Perform calibration on the available inliers and return a dictionary of the results."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_initial_offset(self, pyramids=6):\n        flow = self.video.flow\n        gyro_rate = self.parameter['gyro_rate']\n        frame_times = np.arange(len(flow)) / self.video.frame_rate\n        gyro_times = np.arange(self.gyro.num_samples) / gyro_rate\n        time_offset = timesync.sync_camera_gyro(flow, frame_times, self.gyro.data.T, gyro_times, levels=pyramids)\n        \n        logger.debug(\"Initial time offset: {:.4f}\".format(time_offset))\n        self.params['initialized']['time_offset'] = time_offset\n        \n        return time_offset", "response": "This sets and returns the initial time offset estimation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nestimating the initial rotation between camera and gyroscope. This function returns the initial rotation estimate.", "response": "def find_initial_rotation(self):\n        \"\"\"Estimate rotation between camera and gyroscope\n        \n        This sets and returns the initial rotation estimate.\n        Note that the initial time offset must have been estimated before calling this function!\n\n\n        Returns\n        --------------------\n        (3,3) ndarray\n            Estimated rotation between camera and gyroscope\n        \"\"\"\n        if 'time_offset' not in self.parameter:\n            raise InitializationError(\"Can not estimate rotation without an estimate of time offset. Please estimate the offset and try again.\")\n            \n        dt = float(1.0 / self.parameter['gyro_rate']) # Must be python float for fastintegrate\n        q = self.gyro.integrate(dt)\n        \n        video_axes = []\n        gyro_axes = []\n        \n        for _slice in self.slices:\n            # Estimate rotation here\n            _slice.estimate_rotation(self.video.camera_model, ransac_threshold=7.0) # sets .axis and .angle memebers\n            if _slice.axis is None:\n                continue\n            assert _slice.angle > 0\n            \n            t1 = _slice.start / self.video.frame_rate\n            n1, _ = self.video_time_to_gyro_sample(t1)\n            t2 = _slice.end / self.video.frame_rate\n            n2, _ = self.video_time_to_gyro_sample(t2)\n            \n            try:\n                qx = q[n1]\n                qy = q[n2]\n            except IndexError:\n                continue # No gyro data -> nothing to do with this slice\n                \n            Rx = rotations.quat_to_rotation_matrix(qx)\n            Ry = rotations.quat_to_rotation_matrix(qy)\n            R = np.dot(Rx.T, Ry)\n            v, theta = rotations.rotation_matrix_to_axis_angle(R)\n            if theta < 0:\n                v = -v\n                \n            gyro_axes.append(v)\n            video_axes.append(_slice.axis)\n            \n        if len(gyro_axes) < 2:\n            logger.warning(\"Rotation estimation requires at least 2 rotation axes, got {}\".format(len(gyro_axes)))\n            return None\n\n        logger.debug(\"Using {:d} slices (from initial {:d} for rotation estimation\".format(len(gyro_axes), len(self.slices)))\n\n        model_func = lambda data: rotations.procrustes(data[:3], data[3:6], remove_mean=False)[0]\n        \n        def eval_func(model, data):\n            X = data[:3].reshape(3,-1)\n            Y = data[3:6].reshape(3,-1)\n            R = model\n            Xhat = np.dot(R, Y)\n            \n            costheta = np.sum(Xhat*X, axis=0)\n            theta = np.arccos(costheta)\n            \n            return theta\n       \n        inlier_selection_prob = 0.99999\n        model_points = 2 # Set to 3 to use non-minimal case\n        inlier_ratio = 0.5\n        threshold = np.deg2rad(10.0)\n        ransac_iterations = int(np.log(1 - inlier_selection_prob) / np.log(1-inlier_ratio**model_points))\n        data = np.vstack((np.array(video_axes).T, np.array(gyro_axes).T))    \n        assert data.shape == (6, len(gyro_axes))\n        \n        R, ransac_conseus_idx = ransac.RANSAC(model_func, eval_func, data,\n                                              model_points, ransac_iterations,\n                                              threshold, recalculate=True)\n\n        n, theta = rotations.rotation_matrix_to_axis_angle(R)\n        logger.debug(\"Found rotation: n={} theta={};  r={}\".format(n, theta, n*theta))\n        logger.debug(R)\n        rx, ry, rz = theta * n\n        self.params['initialized']['rot_x'] = rx\n        self.params['initialized']['rot_y'] = ry\n        self.params['initialized']['rot_z'] = rz\n\n        return R"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_params(self):\n        print(\"Parameters\")\n        print(\"--------------------\")\n        for param in PARAM_ORDER:\n            print('  {:>11s} = {}'.format(param, self.parameter[param]))", "response": "Print the current best set of parameters"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_slp(img, gstd1=GSTD1, gstd2=GSTD2, gstd3=GSTD3, ksize=KSIZE, w=W):\n    gf1 = cv2.getGaussianKernel(ksize, gstd1)\n    gf2 = cv2.getGaussianKernel(ksize, gstd2)\n    gf3 = cv2.getGaussianKernel(ksize, gstd3)\n    sqrtimg = cv2.sqrt(img)\n    p1 = cv2.sepFilter2D(sqrtimg, -1, gf1, gf1)\n    p2 = cv2.sepFilter2D(sqrtimg, -1, gf2, gf2)\n    maxarr = np.maximum(0, (p1 - p2) / p2)\n    minarr = np.minimum(w * maxarr, 1)\n    p = 1 - minarr\n    nc = cv2.sepFilter2D(p, -1, gf3, gf3) + EPS\n    output = cv2.sepFilter2D(p*sqrtimg, -1, gf3, gf3)\n    output = (output / nc) ** 2 # Since input is sqrted\n    \n    return output", "response": "Remove the SLP from kinect IR image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload camera model parameters from a HDF5 file.", "response": "def from_hdf(cls, filename):\n        \"\"\"Load camera model params from a HDF5 file\n\n        The HDF5 file should contain the following datasets:\n            wc : (2,) float with distortion center\n            lgamma : float distortion parameter\n            readout : float readout value\n            size : (2,) int image size\n            fps : float frame rate\n            K : (3, 3) float camera matrix\n\n        Parameters\n        --------------------\n        filename : str\n            Path to file with parameters\n\n        Returns\n        ---------------------\n        AtanCameraModel\n            Camera model instance\n        \"\"\"\n        import h5py\n        with h5py.File(filename, 'r') as f:\n            wc = f[\"wc\"].value\n            lgamma = f[\"lgamma\"].value\n            K = f[\"K\"].value\n            readout = f[\"readout\"].value\n            image_size = f[\"size\"].value\n            fps = f[\"fps\"].value\n            instance = cls(image_size, fps, readout, K, wc, lgamma)\n            return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef invert(self, points):\n        X = points if not points.ndim == 1 else points.reshape((points.size, 1))\n\n        wx, wy = self.wc\n\n        # Switch to polar coordinates\n        rn = np.sqrt((X[0,:] - wx)**2 + (X[1,:] - wy)**2)\n        phi = np.arctan2(X[1,:] - wy, X[0,:]-wx)\n        # 'atan' method\n        r = np.tan(rn * self.lgamma) / self.lgamma;\n\n        # Switch back to rectangular coordinates\n        Y = np.ones(X.shape)\n        Y[0,:] = wx + r * np.cos(phi)\n        Y[1,:]= wy + r * np.sin(phi)\n        return Y", "response": "Invert the distortion of the distortion of the current image."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef project(self, points):\n        K = self.camera_matrix\n        XU = points\n        XU = XU / np.tile(XU[2], (3,1))\n        X = self.apply(XU)\n        x2d = np.dot(K, X)\n        return from_homogeneous(x2d)", "response": "Project 3D points to image coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unproject(self, image_points):\n        Ki = self.inv_camera_matrix\n        X = np.dot(Ki, to_homogeneous(image_points))\n        X = X / X[2]\n        XU = self.invert(X)\n        return XU", "response": "Unproject an image point into a 3D coordinate."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef project(self, points):\n        rvec = tvec = np.zeros(3)\n        image_points, jac = cv2.projectPoints(points.T.reshape(-1,1,3), rvec, tvec, self.camera_matrix, self.dist_coefs)\n        return image_points.reshape(-1,2).T", "response": "Project 3D points to image coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds (up to scale) 3D coordinate of an image point This is the inverse of the `project` function. The resulting 3D points are only valid up to an unknown scale. Parameters ---------------------- image_points : (2, N) ndarray Image points Returns ---------------------- points : (3, N) ndarray 3D coordinates (valid up to scale)", "response": "def unproject(self, image_points):\n        \"\"\"Find (up to scale) 3D coordinate of an image point\n\n        This is the inverse of the `project` function.\n        The resulting 3D points are only valid up to an unknown scale.\n\n        Parameters\n        ----------------------\n        image_points : (2, N) ndarray\n            Image points\n\n        Returns\n        ----------------------\n        points : (3, N) ndarray\n            3D coordinates (valid up to scale)\n        \"\"\"\n        undist_image_points = cv2.undistortPoints(image_points.T.reshape(1,-1,2), self.camera_matrix, self.dist_coefs, P=self.camera_matrix)\n        world_points = np.dot(self.inv_camera_matrix, to_homogeneous(undist_image_points.reshape(-1,2).T))\n        return world_points"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking list of Kinect filenames without path and extracts timestamps while accounting for timestamp overflow ( returns linear timestamps.", "response": "def timestamps_from_file_list(file_list):\n        \"Take list of Kinect filenames (without path) and extracts timestamps while accounting for timestamp overflow (returns linear timestamps).\"\n        timestamps = np.array([Kinect.timestamp_from_filename(fname) for fname in file_list])\n\n        # Handle overflow\n        diff = np.diff(timestamps)\n        idxs = np.flatnonzero(diff < 0)\n        ITEM_SIZE = 2**32\n        for i in idxs:\n            timestamps[i+1:] += ITEM_SIZE\n\n        return timestamps.flatten()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of image files find bad frames remove them and modify file_list", "response": "def purge_bad_timestamp_files(file_list):\n        \"Given a list of image files, find bad frames, remove them and modify file_list\"\n        MAX_INITIAL_BAD_FRAMES = 15\n        bad_ts = Kinect.detect_bad_timestamps(Kinect.timestamps_from_file_list(file_list))\n        \n        # Trivial case\n        if not bad_ts:\n            return file_list\n\n        # No bad frames after the initial allowed\n        last_bad = max(bad_ts)\n        if last_bad >= MAX_INITIAL_BAD_FRAMES:\n            raise Exception('Only 15 initial bad frames are allowed, but last bad frame is %d' % last_bad)\n\n        # Remove all frames up to the last bad frame\n        for i in range(last_bad + 1):\n            os.remove(file_list[i])\n\n        # Purge from the list\n        file_list = file_list[last_bad+1:]\n\n        return file_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef depth_file_for_nir_file(video_filename, depth_file_list):\n        (root, filename) = os.path.split(video_filename)\n        needle_ts = int(filename.split('-')[2].split('.')[0])\n        haystack_ts_list = np.array(Kinect.timestamps_from_file_list(depth_file_list))\n        haystack_idx = np.flatnonzero(haystack_ts_list == needle_ts)[0]\n        depth_filename = depth_file_list[haystack_idx]\n        return depth_filename", "response": "Returns the corresponding depth filename given a NIR filename"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the closest depth file from an RGB filename", "response": "def depth_file_for_rgb_file(rgb_filename, rgb_file_list, depth_file_list):\n        \"\"\"Returns the *closest* depth file from an RGB filename\"\"\"\n        (root, filename) = os.path.split(rgb_filename)\n        rgb_timestamps = np.array(Kinect.timestamps_from_file_list(rgb_file_list))\n        depth_timestamps = np.array(Kinect.timestamps_from_file_list(depth_file_list))\n        needle_ts = rgb_timestamps[rgb_file_list.index(rgb_filename)]\n        haystack_idx = np.argmin(np.abs(depth_timestamps - needle_ts))\n        depth_filename = depth_file_list[haystack_idx]\n        return depth_filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all files without its own counterpart. Returns new lists of files", "response": "def find_nir_file_with_missing_depth(video_file_list, depth_file_list):\n        \"Remove all files without its own counterpart. Returns new lists of files\"\n        new_video_list = []\n        new_depth_list = []\n        for fname in video_file_list:\n            try:\n                depth_file = Kinect.depth_file_for_nir_file(fname, depth_file_list)                \n                new_video_list.append(fname)\n                new_depth_list.append(depth_file)\n            except IndexError: # Missing file\n                pass\n                \n        # Purge bad files\n        bad_nir = [f for f in video_file_list if f not in new_video_list]\n        bad_depth = [f for f in depth_file_list if f not in new_depth_list]\n        \n        return (new_video_list, new_depth_list, bad_nir, bad_depth)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting image of Kinect disparity values to distance ( linear method )", "response": "def disparity_image_to_distance(self, dval_img):\n        \"Convert image of Kinect disparity values to distance (linear method)\"\n        dist_img = dval_img / 2048.0\n        dist_img = 1 / (self.opars[0]*dist_img + self.opars[1])\n        return dist_img"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fill_sampling(slice_list, N):\n    A = [len(s.inliers) for s in slice_list]\n    N_max = np.sum(A)\n    if N > N_max:\n        raise ValueError(\"Tried to draw {:d} samples from a pool of only {:d} items\".format(N, N_max))\n    \n    samples_from = np.zeros((len(A),), dtype='int') # Number of samples to draw from each group\n\n    remaining = N\n    while remaining > 0:\n        remaining_groups = np.flatnonzero(samples_from - np.array(A))\n        \n        if remaining < len(remaining_groups):\n            np.random.shuffle(remaining_groups)\n            for g in remaining_groups[:remaining]:\n                samples_from[g] += 1\n        else:\n            # Give each group the allowed number of samples. Constrain to their max size.\n            to_each = max(1, int(remaining / len(remaining_groups)))\n            samples_from = np.min(np.vstack((samples_from + to_each, A)), axis=0)\n        \n        # Update remaining count\n        remaining = int(N - np.sum(samples_from))\n    if not remaining == 0:\n        raise ValueError(\"Still {:d} samples left! This is an error in the selection.\")\n\n    # Construct index list of selected samples\n    samples = []\n    for s, a, n in zip(slice_list, A, samples_from):\n        if a == n:\n            samples.append(np.array(s.inliers)) # all\n        elif a == 0:\n            samples.append(np.arange([]))\n        else:\n            chosen = np.random.choice(s.inliers, n, replace=False)\n            samples.append(np.array(chosen))\n    return samples", "response": "Given a list of slices draw N samples such that each slice contributes as much as possible\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nestimating the rotation between the first and last frame of the current object.", "response": "def estimate_rotation(self, camera, ransac_threshold=7.0):\n        \"\"\"Estimate the rotation between first and last frame\n\n        It uses RANSAC where the error metric is the reprojection error of the points\n        from the last frame to the first frame.\n\n        Parameters\n        -----------------\n        camera : CameraModel\n            Camera model\n        ransac_threshold : float\n            Distance threshold (in pixels) for a reprojected point to count as an inlier\n        \"\"\"\n        if self.axis is None:\n            x = self.points[:, 0, :].T\n            y = self.points[:, -1, :].T\n            inlier_ratio = 0.5\n            R, t, dist, idx = rotations.estimate_rotation_procrustes_ransac(x, y,\n                                                                     camera, \n                                                                     ransac_threshold,\n                                                                     inlier_ratio=inlier_ratio,\n                                                                     do_translation=False)\n            \n            if R is not None:                                      \n                self.axis, self.angle = rotations.rotation_matrix_to_axis_angle(R)\n                if self.angle < 0: # Constrain to positive angles\n                    self.angle = -self.angle\n                    self.axis = -self.axis\n                self.inliers = idx\n                                                          \n        return self.axis is not None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a list of slices from a random sampling of a video stream.", "response": "def from_stream_randomly(video_stream, step_bounds=(5, 15), length_bounds=(2, 15), max_start=None, min_distance=10, min_slice_points=10):\n        \"\"\"Create slices from a video stream using random sampling\n\n        Parameters\n        -----------------\n        video_stream : VideoStream\n            A video stream\n        step_bounds : tuple\n            Range bounds (inclusive) of possible step lengths\n        length_bounds : tuple\n            Range bounds (inclusive) of possible slice lengths\n        max_start : int\n            Maximum frame number to start from\n        min_distance : float\n            Minimum (initial) distance between tracked points\n        min_slice_points : int\n            Minimum number of points to keep a slice\n\n        Returns\n        -------------------\n        list of Slice\n            List of slices\n        \"\"\"\n        new_step = lambda: int(np.random.uniform(low=step_bounds[0], high=step_bounds[1]))\n        new_length = lambda: int(np.random.uniform(low=length_bounds[0], high=length_bounds[1]))\n        \n        seq_frames = []\n        slices = []\n        seq_start_points = None\n        next_seq_start = new_step() if max_start is None else min(new_step(), max_start)\n        next_seq_length = new_length()\n        for i, im in enumerate(video_stream):            \n            if next_seq_start <= i < next_seq_start + next_seq_length:\n                im = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\n                seq_frames.append(im)\n                \n                if len(seq_frames) == 1:\n                    max_corners = 400\n                    quality_level = 0.07\n                    seq_start_points = cv2.goodFeaturesToTrack(im, max_corners, quality_level, min_distance)\n                    \n                elif len(seq_frames) == next_seq_length:                               \n                    points, status = tracking.track_retrack(seq_frames, seq_start_points)\n                    if points.shape[0] >= min_slice_points:\n                        s = Slice(next_seq_start, i, points)\n                        slices.append(s)\n                        logger.debug('{0:4d} {1:3d} {2:5d} {3:>5d}-{4:<5d}'.format(len(slices)-1, points.shape[1], points.shape[0], next_seq_start, i))\n                    seq_frames = []\n                    next_seq_start = i + new_step()\n                    next_seq_length = new_length()\n        \n        return slices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsolving the best rotation and translation of a set of points X and Y.", "response": "def procrustes(X, Y, remove_mean=False):\n    \"\"\"Orthogonal procrustes problem solver\n    \n    The procrustes problem  finds the best rotation R, and translation t\n    where\n        X = R*Y + t\n    \n    The number of points in X and Y must be at least 2.\n    For the minimal case of two points, a third point is temporarily created\n    and used for the estimation.\n    \n    Parameters\n    -----------------\n    X : (3, N) ndarray\n            First set of points\n    Y : (3, N) ndarray\n            Second set of points\n    remove_mean : bool\n            If true, the mean is removed from X and Y before solving the\n            procrustes problem. Can yield better results in some applications.\n            \n    Returns\n    -----------------\n    R : (3,3) ndarray\n            Rotation component\n    t : (3,) ndarray\n            Translation component (None if remove_mean is False)\n \"\"\"\n\n    assert X.shape == Y.shape\n    assert X.shape[0] > 1\n    \n    # Minimal case, create third point using cross product\n    if X.shape[0] == 2:\n        X3 = np.cross(X[:,0], X[:,1], axis=0)\n        X = np.hstack((X, X3 / np.linalg.norm(X3)))\n        Y3 = np.cross(Y[:,0], Y[:,1], axis=0)\n        Y = np.hstack((Y, Y3 / np.linalg.norm(Y3)))\n        \n    \n    D, N = X.shape[:2]\n    if remove_mean:\n        mx = np.mean(X, axis=1).reshape(D, 1)\n        my = np.mean(Y, axis=1).reshape(D, 1)\n        Xhat = X - mx\n        Yhat = Y - my\n    else:\n        Xhat = X\n        Yhat = Y\n\n\n    (U, S, V) = np.linalg.svd((Xhat).dot(Yhat.T))\n\n    Dtmp = np.eye(Xhat.shape[0])\n    Dtmp[-1,-1] = np.linalg.det(U.dot(V))\n\n    R_est = U.dot(Dtmp).dot(V)\n\n    # Now X=R_est*(Y-my)+mx=R_est*Y+t_est\n    if remove_mean:\n        t_est= mx - R_est.dot(my)\n    else:\n        t_est = None\n    return (R_est, t_est)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a 3D rotation matrix to a 3D axis angle representation.", "response": "def rotation_matrix_to_axis_angle(R):\n    \"\"\"Convert a 3D rotation matrix to a 3D axis angle representation\n    \n    Parameters\n    ---------------\n    R : (3,3) array\n        Rotation matrix\n        \n    Returns\n    ----------------\n    v : (3,) array\n        (Unit-) rotation angle\n    theta : float\n        Angle of rotations, in radians\n    \n    Note\n    --------------\n    This uses the algorithm as described in Multiple View Geometry, p. 584\n    \"\"\"\n    assert R.shape == (3,3)\n    assert_almost_equal(np.linalg.det(R), 1.0, err_msg=\"Not a rotation matrix: determinant was not 1\")\n    S, V = np.linalg.eig(R)\n    k = np.argmin(np.abs(S - 1.))\n    s = S[k]\n    assert_almost_equal(s, 1.0, err_msg=\"Not a rotation matrix: No eigen value s=1\")\n    v = np.real(V[:, k]) # Result is generally complex\n    \n    vhat = np.array([R[2,1] - R[1,2], R[0,2] - R[2,0], R[1,0] - R[0,1]])\n    sintheta = 0.5 * np.dot(v, vhat)\n    costheta = 0.5 * (np.trace(R) - 1)\n    theta = np.arctan2(sintheta, costheta)\n    \n    return (v, theta)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting rotation from axis - angle to rotation matrix", "response": "def axis_angle_to_rotation_matrix(v, theta):\n    \"\"\"Convert rotation from axis-angle to rotation matrix\n    \n        Parameters\n    ---------------\n    v : (3,) ndarray\n            Rotation axis (normalized)\n    theta : float\n            Rotation angle (radians)\n\n    Returns\n    ----------------\n    R : (3,3) ndarray\n            Rotation matrix\n    \"\"\"\n    if np.abs(theta) < np.spacing(1):\n        return np.eye(3)\n    else:\n        v = v.reshape(3,1)\n        np.testing.assert_almost_equal(np.linalg.norm(v), 1.)\n        vx = np.array([[0, -v[2], v[1]],\n                       [v[2], 0, -v[0]],\n                       [-v[1], v[0], 0]])\n        vvt = np.dot(v, v.T)\n        R = np.eye(3)*np.cos(theta) + (1 - np.cos(theta))*vvt + vx * np.sin(theta)\n        return R"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert unit quaternion to rotation matrix", "response": "def quat_to_rotation_matrix(q):\n    \"\"\"Convert unit quaternion to rotation matrix\n    \n    Parameters\n    -------------\n    q : (4,) ndarray\n            Unit quaternion, scalar as first element\n\n    Returns\n    ----------------\n    R : (3,3) ndarray\n            Rotation matrix\n    \n    \"\"\"\n    q = q.flatten()\n    assert q.size == 4\n    assert_almost_equal(np.linalg.norm(q), 1.0, err_msg=\"Not a unit quaternion!\")\n    qq = q ** 2\n    R = np.array([[qq[0] + qq[1] - qq[2] - qq[3], 2*q[1]*q[2] -\n2*q[0]*q[3], 2*q[1]*q[3] + 2*q[0]*q[2]],\n                [2*q[1]*q[2] + 2*q[0]*q[3], qq[0] - qq[1] + qq[2] -\nqq[3], 2*q[2]*q[3] - 2*q[0]*q[1]],\n                [2*q[1]*q[3] - 2*q[0]*q[2], 2*q[2]*q[3] + 2*q[0]*q[1],\nqq[0] - qq[1] - qq[2] + qq[3]]])\n    return R"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef integrate_gyro_quaternion(gyro_ts, gyro_data):\n    #NB: Quaternion q = [a, n1, n2, n3], scalar first\n    q_list = np.zeros((gyro_ts.shape[0], 4)) # Nx4 quaternion list\n    q_list[0,:] = np.array([1, 0, 0, 0]) # Initial rotation (no rotation)\n    \n    # Iterate over all (except first)\n    for i in range(1, gyro_ts.size):\n        w = gyro_data[i]\n        dt = gyro_ts[i] - gyro_ts[i - 1]\n        qprev = q_list[i - 1]\n        \n        A = np.array([[0,    -w[0],  -w[1],  -w[2]],\n                     [w[0],  0,      w[2],  -w[1]],\n                     [w[1], -w[2],   0,      w[0]],\n                     [w[2],  w[1],  -w[0],   0]])\n        qnew = (np.eye(4) + (dt/2.0) * A).dot(qprev)\n        qnorm = np.sqrt(np.sum(qnew ** 2))\n        qnew /= qnorm\n        q_list[i] = qnew\n         \n    return q_list", "response": "Integrate angular velocities to rotations\n    \n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef slerp(q1, q2, u):\n    q1 = q1.flatten()\n    q2 = q2.flatten()\n    assert q1.shape == q2.shape\n    assert q1.size == 4\n    costheta = np.dot(q1, q2)\n\n    if np.isclose(u, 0.):\n        return q1\n    elif np.isclose(u, 1.):\n        return q2\n    elif u > 1 or u < 0:\n        raise ValueError(\"u must be in range [0, 1]\")\n\n    # Shortest path\n    if costheta < 0:\n        costheta = -costheta\n        q2 = -q2\n\n    # Almost the same, we can return any of them?\n    if np.isclose(costheta, 1.0):\n        return q1\n\n    theta = np.arccos(costheta)\n\n    f1 = np.sin((1.0 - u)*theta) / np.sin(theta)\n    f2 = np.sin(u*theta) / np.sin(theta)\n    q = f1*q1 + f2*q2\n    q = q / np.sqrt(np.sum(q**2)) # Normalize\n    return q", "response": "SLERP is a linear interpolation between two unit quaternions."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nestimating the rotation between two sets of image coordinates using ransac.", "response": "def estimate_rotation_procrustes_ransac(x, y, camera, threshold, inlier_ratio=0.75, do_translation=False):\n    \"\"\"Calculate rotation between two sets of image coordinates using ransac.\n    \n    Inlier criteria is the reprojection error of y into image 1.\n\n    Parameters\n    -------------------------\n    x : array 2xN image coordinates in image 1\n    y : array 2xN image coordinates in image 2\n    camera : Camera model\n    threshold : float pixel distance threshold to accept as inlier\n    do_translation : bool Try to estimate the translation as well\n\n    Returns\n    ------------------------\n    R : array 3x3 The rotation that best fulfills X = RY\n    t : array 3x1 translation if do_translation is False\n    residual : array pixel distances ||x - xhat|| where xhat ~ KRY (and lens distorsion)\n    inliers : array Indices of the points (in X and Y) that are RANSAC inliers\n    \"\"\"\n    assert x.shape == y.shape\n    assert x.shape[0] == 2\n    \n    X = camera.unproject(x)\n    Y = camera.unproject(y)\n    \n    data = np.vstack((X, Y, x))\n    assert data.shape[0] == 8\n    \n    model_func = lambda data: procrustes(data[:3], data[3:6], remove_mean=do_translation)\n    \n    def eval_func(model, data):\n        Y = data[3:6].reshape(3,-1)\n        x = data[6:].reshape(2,-1)\n        R, t = model\n\n        Xhat = np.dot(R, Y) if t is None else np.dot(R, Y) + t\n        xhat = camera.project(Xhat)\n        dist = np.sqrt(np.sum((x-xhat)**2, axis=0))\n\n        return dist\n    \n    inlier_selection_prob = 0.99999\n    model_points = 2\n    ransac_iterations = int(np.log(1 - inlier_selection_prob) / np.log(1-inlier_ratio**model_points))\n    \n    model_est, ransac_consensus_idx = ransac.RANSAC(model_func, eval_func, data, model_points, ransac_iterations, threshold, recalculate=True)    \n    if model_est is not None:\n        (R, t) = model_est\n        dist = eval_func((R, t), data)                \n    else:\n        dist = None\n        R, t = None, None\n        ransac_consensus_idx = []\n\n    return R, t, dist, ransac_consensus_idx"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef RANSAC(model_func, eval_func, data, num_points, num_iter, threshold, recalculate=False):\n    M = None\n    max_consensus = 0\n    all_idx = list(range(data.shape[1]))\n    final_consensus = []\n    for k in range(num_iter):\n        np.random.shuffle(all_idx)\n        model_set = all_idx[:num_points]\n        x = data[:, model_set]\n        m = model_func(x)\n\n        model_error = eval_func(m, data)\n        assert model_error.ndim == 1\n        assert model_error.size == data.shape[1]\n        consensus_idx = np.flatnonzero(model_error < threshold)\n\n        if len(consensus_idx) > max_consensus:\n            M = m\n            max_consensus = len(consensus_idx)\n            final_consensus = consensus_idx            \n\n    # Recalculate using current consensus set?\n    if recalculate and len(final_consensus) > 0:\n        final_consensus_set = data[:, final_consensus]\n        M = model_func(final_consensus_set)\n\n    return (M, final_consensus)", "response": "This function applies the RANSAC model_func and eval_func to generate a random model and the final model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef track_points(img1, img2, initial_points=None, gftt_params={}):\n    params = GFTT_DEFAULTS\n    if gftt_params:\n        params.update(gftt_params)\n\n    if initial_points is None:\n        initial_points = cv2.goodFeaturesToTrack(img1, params['max_corners'], params['quality_level'], params['min_distance'])\n    \n    [_points, status, err] = cv2.calcOpticalFlowPyrLK(img1, img2, initial_points, np.array([]))\n\n    # Filter out valid points only\n    points = _points[np.nonzero(status)]\n    initial_points = initial_points[np.nonzero(status)]\n\n    return (points, initial_points)", "response": "Track points between two images and return a tuple of points and initial_points"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef optical_flow_magnitude(image_sequence, max_diff=60, gftt_options={}):\n    flow = []\n    prev_img = None\n    for img in image_sequence:\n        if img.ndim == 3 and img.shape[2] == 3:\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n        if prev_img is None:\n            prev_img = img\n            continue\n        (next_points, prev_points) = track_points(prev_img, img, gftt_params=gftt_options)\n        distance = np.sqrt(np.sum((next_points - prev_points)**2, 1))\n        distance2 = distance[np.nonzero(distance < max_diff)] # Crude outlier rejection\n        dm = np.mean(distance2)\n        if np.isnan(dm):\n            dm = 0\n        flow.append(dm)\n        prev_img = img\n\n    return np.array(flow)", "response": "Calculate the optical flow magnitude for the given image sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef track(image_list, initial_points, remove_bad=True):\n    # Precreate track array\n    tracks = np.zeros((initial_points.shape[0], len(image_list), 2), dtype='float32') # NxMx2\n    tracks[:,0,:] = np.reshape(np.array(initial_points), [-1,2])\n    track_status = np.ones([np.size(initial_points,0),1]) # All initial points are OK\n    empty = np.array([])\n    window_size = (5,5)\n    for i in range(1, len(image_list)):\n        img1 = image_list[i-1]\n        img2 = image_list[i]\n        prev_ok_track = np.flatnonzero(track_status)\n        prev_points = tracks[prev_ok_track,i-1,:]\n        [points, status, err] = cv2.calcOpticalFlowPyrLK(img1, img2, prev_points, empty, empty, empty, window_size)\n        if status is None:\n            track_status[:] = 0 # All tracks are bad\n            break\n        valid_set = np.flatnonzero(status)\n        now_ok_tracks = prev_ok_track[valid_set] # Remap\n        tracks[now_ok_tracks,i,:] = points[valid_set]\n        track_status[prev_ok_track] = status\n\n    if remove_bad:\n        final_ok = np.flatnonzero(track_status)\n        tracks = tracks[final_ok] # Only rows/tracks with nonzero status\n        track_status = track_status[final_ok] \n\n    return (tracks, track_status)", "response": "This function tracks the points in image_list in a new node and returns a new node with the new image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_mat_file(cls, matfilename):\n        M = scipy.io.loadmat(matfilename)\n        instance = cls()\n        instance.gyro_data = M['gyro']\n        instance.timestamps = M['timestamps']\n        return instance", "response": "Load the IMU class from a. mat file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rate(self):\n        N = len(self.timestamps)\n        t = self.timestamps[-1] - self.timestamps[0]\n        rate = 1.0 * N / t\n        return rate", "response": "Get the sample rate in Hz."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming zero - level calibration from the chosen time interval.", "response": "def zero_level_calibrate(self, duration, t0=0.0):\n        \"\"\"Performs zero-level calibration from the chosen time interval.\n        \n        This changes the previously lodaded data in-place.\n        \n        Parameters\n        --------------------\n        duration : float\n                Number of timeunits to use for calibration\n        t0 : float \n                Starting time for calibration\n                \n        Returns\n        ----------------------\n        gyro_data : (3, N) float ndarray\n                The calibrated data (note that it is also changed in-place!)\n        \"\"\"\n        \n        t1 = t0 + duration\n        indices = np.flatnonzero((self.timestamps >= t0) & (self.timestamps <= t1))\n        m = np.mean(self.gyro_data[:, indices], axis=1)\n        self.gyro_data -= m.reshape(3,1)\n        \n        return self.gyro_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef integrate(self, pose_correction=np.eye(3), uniform=True):\n        \n        if uniform:\n            dt = float(self.timestamps[1]-self.timestamps[0]) # Must be python float for fastintegrate to work\n            return fastintegrate.integrate_gyro_quaternion_uniform(self.gyro_data_corrected, dt)\n        else:            \n            N = len(self.timestamps)\n            integrated = np.zeros((4, N))\n            integrated[:,0] = np.array([1, 0, 0, 0]) # Initial rotation (no rotation)\n            \n            # Iterate over all\n            for i in range(1, len(self.timestamps)):\n                w = pose_correction.dot(self.gyro_data[:, i]) # Change to correct coordinate frame\n                dt = float(self.timestamps[i] - self.timestamps[i - 1])\n                qprev = integrated[:, i - 1].flatten()\n                \n                A = np.array([[0,    -w[0],  -w[1],  -w[2]],\n                             [w[0],  0,      w[2],  -w[1]],\n                             [w[1], -w[2],   0,      w[0]],\n                             [w[2],  w[1],  -w[0],   0]])\n                qnew = (np.eye(4) + (dt/2.0) * A).dot(qprev)\n                qnorm = np.sqrt(np.sum(qnew ** 2))\n                qnew = qnew / qnorm if qnorm > 0 else 0\n                integrated[:, i] = qnew\n                #print \"%d, %s, %s, %s, %s\" % (i, w, dt, qprev, qnew)\n            return integrated", "response": "Integrate angular velocity measurements to rotations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rotation_at_time(t, timestamps, rotation_sequence):\n        idx = np.flatnonzero(timestamps >= (t - 0.0001))[0]\n        t0 = timestamps[idx - 1]\n        t1 = timestamps[idx]\n        tau = (t - t0) / (t1 - t0)\n        \n        q1 = rotation_sequence[:, idx - 1]\n        q2 = rotation_sequence[:, idx]\n        q = rotations.slerp(q1, q2, tau)\n        return q", "response": "Get the gyro rotation at time t using SLERP."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_csv(cls, filename):\n        instance = cls()\n        instance.data = np.loadtxt(filename, delimiter=',')\n        return instance", "response": "Create gyro stream from a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates gyroscope stream from data array", "response": "def from_data(cls, data):\n        \"\"\"Create gyroscope stream from data array\n\n        Parameters\n        -------------------\n        data : (N, 3) ndarray\n            Data array of angular velocities (rad/s)\n\n        Returns\n        -------------------\n        GyroStream\n            Stream object\n        \"\"\"\n        if not data.shape[1] == 3:\n            raise ValueError(\"Gyroscope data must have shape (N, 3)\")\n\n        instance = cls()\n        instance.data = data\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef integrate(self, dt):\n        if not dt == self.__last_dt:\n            self.__last_q = fastintegrate.integrate_gyro_quaternion_uniform(self.data, dt)\n            self.__last_dt = dt\n        return self.__last_q", "response": "Integrate gyro measurements to orientation using a uniform sample rate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate odd sized truncated Gaussian filter kernel", "response": "def gaussian_kernel(gstd):\n    \"\"\"Generate odd sized truncated Gaussian\n\n    The generated filter kernel has a cutoff at $3\\sigma$\n    and is normalized to sum to 1\n\n    Parameters\n    -------------\n    gstd : float\n            Standard deviation of filter\n\n    Returns\n    -------------\n    g : ndarray\n            Array with kernel coefficients\n    \"\"\"\n    Nc = np.ceil(gstd*3)*2+1\n    x = np.linspace(-(Nc-1)/2,(Nc-1)/2,Nc,endpoint=True)\n    g = np.exp(-.5*((x/gstd)**2))\n    g = g/np.sum(g)\n\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upsample(time_series, scaling_factor):\n    Ns0 = np.size(time_series)\n    Ns  = np.int(np.floor(np.size(time_series)*scaling_factor))\n    ts_out = np.zeros((Ns,1), dtype='float64')\n    for k in range(0,Ns):\n        cpos  = int(np.min([Ns0-1,np.max([0.,(k+0.5)/scaling_factor-0.5])]))\n        cfrac = cpos-np.floor(cpos)\n        cind  = int(np.floor(cpos))\n        #print \"cpos=%f cfrac=%f cind=%d\", (cpos,cfrac,cind)\n        if cfrac>0:\n            ts_out[k]=time_series[cind]*(1-cfrac)+time_series[cind+1]*cfrac\n        else:\n            ts_out[k]=time_series[cind]\n        \n    return ts_out", "response": "Upsample using linear interpolation of the value at edges of the signal"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef zncc(ts1,ts2):\n    # Output is the same size as ts1\n    Ns1 = np.size(ts1)\n    Ns2 = np.size(ts2)\n    ts_out = np.zeros((Ns1,1), dtype='float64')\n\n    ishift = int(np.floor(Ns2/2)) # origin of ts2\n\n    t1m = np.mean(ts1)\n    t2m = np.mean(ts2)\n            \n    for k in range(0,Ns1):\n        lstart = np.int(ishift-k)\n        if lstart<0 :\n            lstart=0\n        lend = np.int(ishift-k+Ns2)\n        imax = np.int(np.min([Ns2,Ns1-k+ishift]))\n        if lend>imax :\n            lend=imax\n        csum = 0\n        ts1sum = 0\n        ts1sum2 = 0\n        ts2sum = 0\n        ts2sum2 = 0\n        \n        Nterms = lend-lstart        \n        for l in range(lstart,lend):\n            csum    += ts1[k+l-ishift]*ts2[l]\n            ts1sum  += ts1[k+l-ishift]\n            ts1sum2 += ts1[k+l-ishift]*ts1[k+l-ishift]\n            ts2sum  += ts2[l]\n            ts2sum2 += ts2[l]*ts2[l]\n        ts1sum2 = np.max([t1m*t1m*100,ts1sum2])-ts1sum*ts1sum/Nterms\n        ts2sum2 = np.max([t2m*t2m*100,ts2sum2])-ts2sum*ts2sum/Nterms\n        #ts_out[k]=csum/np.sqrt(ts1sum2*ts2sum2)\n        ts_out[k]=(csum-2.0*ts1sum*ts2sum/Nterms+ts1sum*ts2sum/Nterms/Nterms)/np.sqrt(ts1sum2*ts2sum2)\n    best_shift = np.argmax(ts_out)-ishift\n    return best_shift, ts_out", "response": "This function does ZNCC of two signals ts1 and ts2 and returns a new array containing the mean normalised cross - correlation of the two signals."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_shift_pyr(ts1,ts2,nlevels):\n    pyr1 = create_pyramid(ts1,nlevels)\n    pyr2 = create_pyramid(ts2,nlevels)\n    \n    logger.debug(\"pyramid size = %d\" % len(pyr1))\n    logger.debug(\"size of first element %d \" % np.size(pyr1[0]))\n    logger.debug(\"size of last element %d \" % np.size(pyr1[-1]))\n\n    ishift, corrfn = zncc(pyr1[-1],pyr2[-1])\n\n    for k in range(1,nlevels+1):\n        ishift, corrfn = refine_correlation(pyr1[-k-1],pyr2[-k-1],ishift*2)\n\n    return ishift", "response": "Find shift that best aligns two time series ts1 with ts2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading gyro data collected by the arduino version of the L3G logging platform and return the data ( in rad / s a time vector and the sample rate ( seconds )", "response": "def load_L3G_arduino(filename, remove_begin_spurious=False, return_parser=False):\n    \"Load gyro data collected by the arduino version of the L3G logging platform, and return the data (in rad/s), a time vector, and the sample rate (seconds)\"\n    file_data = open(filename, 'rb').read()\n    parser = L3GArduinoParser()\n    parser.parse(file_data[7:]) # Skip first \"GYROLOG\" header in file\n    data = parser.data\n    if parser.actual_data_rate:\n        T = 1. / parser.actual_data_rate\n        print(\"Found measured data rate %.3f ms (%.3f Hz)\" % (1000*T, 1. / T))\n    else:\n        T = 1. / parser.data_rate\n        print(\"Using data rate provided by gyro (probably off by a few percent!) %.3f ms (%.3f Hz)\" % (1000*T, 1. / T))\n        \n    N = parser.data.shape[1]\n    t = np.linspace(0, T*N, num=data.shape[1])\n    print(t.shape, data.shape)\n    print(\"Loaded %d samples (%.2f seconds) with expected sample rate %.3f ms (%.3f Hz)\" % (N, t[-1], T*1000.0, 1./T))\n    try:\n        print(\"Actual sample rate is %.3f ms (%.3f Hz)\" % (1000. / parser.actual_data_rate, parser.actual_data_rate, ))\n    except TypeError:\n        pass\n    \n    if remove_begin_spurious:\n        to_remove = int(0.3/T) # Remove first three tenth of second\n        data[:,:to_remove] = 0.0\n    \n    if return_parser:\n        return np.deg2rad(data), t, T, parser\n    else:\n        return np.deg2rad(data), t, T"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting combined axis angle vector to rotation matrix", "response": "def to_rot_matrix(r):\n    \"Convert combined axis angle vector to rotation matrix\"\n    theta = np.linalg.norm(r)\n    v = r/theta\n    R = crisp.rotations.axis_angle_to_rotation_matrix(v, theta)\n    return R"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef estimate_pose(image_sequences, imu_sequences, K):\n    assert len(image_sequences) == len(imu_sequences)\n    assert len(image_sequences) >= 2\n    # Note: list(image_sequence) here makes sure any generator type input is expanded to an actual list\n    sync_correspondences = [_get_point_correspondences(list(image_sequence)) for image_sequence in image_sequences]\n    \n    # ) Procrustes on corresponding pairs\n    PROCRUSTES_MAX_POINTS = 15 # Number of tracks/points to use for procrustes\n    logger.debug(\"Running procrustes on track-retrack results\")\n    image_rotation_axes = []\n    for i, points in enumerate(sync_correspondences):\n        if points.size < 1:\n            logger.error('Shape of points are %s', str(points.shape))\n            raise Exception(\"Did not get enough points when tracking\")\n        num_points_to_use = min(PROCRUSTES_MAX_POINTS, points.shape[0])\n        logger.debug(\"Using %d tracks to calculate procrustes\", num_points_to_use)\n        idxs_to_use = np.random.permutation(points.shape[0])[:num_points_to_use]\n        assert points.shape[-1] == 2\n        x = points[idxs_to_use,0,:].T.reshape(2,-1)\n        y = points[idxs_to_use,-1,:].T.reshape(2,-1)\n\n        x = np.vstack((x, np.ones((1, x.shape[1]))))\n        y = np.vstack((y, np.ones((1, y.shape[1]))))\n\n        K_inv = np.linalg.inv(K)\n        X = K_inv.dot(x)\n        Y = K_inv.dot(y)\n\n        # Depth must be positive\n        (R, t) = rotations.procrustes(X, Y, remove_mean=False) # X = R * Y + t\n        (v, theta) = rotations.rotation_matrix_to_axis_angle(R)\n        image_rotation_axes.append(v) # Save rotation axis\n        \n        # Check the quality via the mean reprojection error\n        mean_error = np.mean(np.sqrt(np.sum((X - R.dot(Y))**2, axis=0)))\n        MEAN_ERROR_LIMIT = 0.1 # Arbitrarily chosen limit (in meters)\n        logger.debug('Image sequence %d: Rotation axis %s, degrees %.2f, mean error %.3f',\n            i, v, np.rad2deg(theta), mean_error)\n        if mean_error > MEAN_ERROR_LIMIT: \n            logger.warning(\"Procrustes solution mean error %.3f > %.3f\", mean_error, MEAN_ERROR_LIMIT)\n\n    # ) Gyro principal rotation axis\n    gyro_rotation_axes = []\n    for i, gyro_seq in enumerate(imu_sequences):\n        assert gyro_seq.shape[0] == 3\n        v = principal_rotation_axis(gyro_seq)\n        logger.debug('Gyro sequence %d: Rotation axis %s', i, v)\n        gyro_rotation_axes.append(v)\n        \n    # ) Procrustes to get rotation between coordinate frames\n    X = np.vstack(image_rotation_axes).T\n    Y = np.vstack(gyro_rotation_axes).T\n    (R,t) = rotations.procrustes(X, Y, remove_mean=False)\n\n    return (R, t)", "response": "Estimate the relative pose between the IMU and camera based on the optical flow of the given images and gyroreadings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pick_manual(image_sequence, imu_gyro, num_sequences=2):\n    assert num_sequences >= 2    \n    # Create optical flow for user to select parts in\n    logger.info(\"Calculating optical flow\")\n    flow = tracking.optical_flow_magnitude(image_sequence)\n    \n    # ) Prompt user for sync slices\n    logger.debug(\"Prompting user for %d sequences\" % num_sequences)\n    imu_fake_timestamps = np.linspace(0,1,num=imu_gyro.shape[1])\n    sync_sequences = [timesync.manual_sync_pick(flow, imu_fake_timestamps, imu_gyro) for i in range(num_sequences)]\n\n    return sync_sequences", "response": "Select N matching sequences and return data indices."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef principal_rotation_axis(gyro_data):\n    N = np.zeros((3,3))\n    for x in gyro_data.T: # Transpose because samples are stored as columns\n        y = x.reshape(3,1)\n        N += y.dot(y.T)\n        \n    (eig_val, eig_vec) = np.linalg.eig(N)\n    i = np.argmax(eig_val)\n    v = eig_vec[:,i]\n    \n    # Make sure v has correct sign\n    s = 0\n    for x in gyro_data.T: # Transpose because samples are stored as columns\n        s += v.T.dot(x.reshape(3,1))\n        \n    v *= np.sign(s)\n    \n    return v", "response": "Get the principal rotation axis of angular velocity measurements."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef visit_image(self, node):\n        uri = node.attributes['uri']\n        doc_folder = os.path.dirname(self.builder.current_docname)\n        if uri.startswith(doc_folder):\n            # drop docname prefix\n            uri = uri[len(doc_folder):]\n            if uri.startswith(\"/\"):\n                uri = \".\" + uri\n        self.add('\\n\\n![image](%s)\\n\\n' % uri)", "response": "Visit an image node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_pass_thru(pass_thrus):\n    def meth(self, node):\n        pass\n\n    def dec(cls):\n        for element_name in pass_thrus:\n            for meth_prefix in ('visit_', 'depart_'):\n                meth_name = meth_prefix + element_name\n                if hasattr(cls, meth_name):\n                    raise ValueError('method name {} already defined'\n                                     .format(meth_name))\n                setattr(cls, meth_name, meth)\n        return cls\n\n    return dec", "response": "Decorator adds explicit pass - through visit and depart methods to the class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self):\n        string = ''.join(self.content)\n        lines = string.splitlines(True)\n        if len(lines) == 0:\n            return\n        texts = [self.first_prefix + lines[0]]\n        for line in lines[1:]:\n            if line.strip() == '':  # avoid prefix for empty lines\n                texts.append('\\n')\n            else:\n                texts.append(self.prefix + line)\n        self.base.append(''.join(texts))", "response": "Write the contents of the current entry to the base list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef identifier(self):\n        key = self.get_public_key_hex()\n        return ensure_bytes(hexlify(hash160(unhexlify(ensure_bytes(key)))))", "response": "Get the identifier for this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nderives a child key. :param child_number: The number of the child key to compute :type child_number: int :param is_prime: If True, the child is calculated via private derivation. If False, then public derivation is used. If None, then it is figured out from the value of child_number. :type is_prime: bool, defaults to None :param as_private: If True, strips private key from the result. Defaults to False. If there is no private key present, this is ignored. :type as_private: bool Positive child_numbers (>= 0, < 2,147,483,648) produce publicly derived children. (prime=False) Negative numbers (> -2,147,483,648, < 0) use private derivation. (prime=True) NOTE: Python can't do -0, so if you want the privately derived 0th child you need to manually set is_prime=True. NOTE: negative numbered children are provided as a convenience because nobody wants to remember the above numbers. Negative numbers are considered 'prime children', which is described in the BIP32 spec as a leading 1 in a 32 bit unsigned int. This derivation is fully described at https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-functions # nopep8", "response": "def get_child(self, child_number, is_prime=None, as_private=True):\n        \"\"\"Derive a child key.\n\n        :param child_number: The number of the child key to compute\n        :type child_number: int\n        :param is_prime: If True, the child is calculated via private\n            derivation. If False, then public derivation is used. If None,\n            then it is figured out from the value of child_number.\n        :type is_prime: bool, defaults to None\n        :param as_private: If True, strips private key from the result.\n            Defaults to False. If there is no private key present, this is\n            ignored.\n        :type as_private: bool\n\n        Positive child_numbers (>= 0, < 2,147,483,648) produce publicly\n        derived children. (prime=False)\n\n        Negative numbers (> -2,147,483,648, < 0) use private derivation.\n        (prime=True)\n\n        NOTE: Python can't do -0, so if you want the privately derived 0th\n        child you need to manually set is_prime=True.\n\n        NOTE: negative numbered children are provided as a convenience\n        because nobody wants to remember the above numbers. Negative numbers\n        are considered 'prime children', which is described in the BIP32 spec\n        as a leading 1 in a 32 bit unsigned int.\n\n        This derivation is fully described at\n        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-functions  # nopep8\n        \"\"\"\n        boundary = 0x80000000\n\n        # Note: If this boundary check gets removed, then children above\n        # the boundary should use private (prime) derivation.\n        if abs(child_number) >= boundary:\n            raise ValueError(\"Invalid child number %s\" % child_number)\n\n        # If is_prime isn't set, then we can infer it from the child_number\n        if is_prime is None:\n            # Prime children are either < 0 or > 0x80000000\n            if child_number < 0:\n                child_number = abs(child_number)\n                is_prime = True\n            else:\n                is_prime = False\n        else:\n            # Otherwise is_prime is set so the child_number should be between\n            # 0 and 0x80000000\n            if child_number < 0 or child_number >= boundary:\n                raise ValueError(\n                    \"Invalid child number. Must be between 0 and %s\" %\n                    boundary)\n\n        if not self.private_key and is_prime:\n            raise ValueError(\n                \"Cannot compute a prime child without a private key\")\n\n        if is_prime:\n            # Even though we take child_number as an int < boundary, the\n            # internal derivation needs it to be the larger number.\n            child_number = child_number + boundary\n        child_number_hex = long_to_hex(child_number, 8)\n\n        if is_prime:\n            # Let data = concat(0x00, self.key, child_number)\n            data = b'00' + self.private_key.get_key()\n        else:\n            data = self.get_public_key_hex()\n        data += child_number_hex\n\n        # Compute a 64 Byte I that is the HMAC-SHA512, using self.chain_code\n        # as the seed, and data as the message.\n        I = hmac.new(\n            unhexlify(ensure_bytes(self.chain_code)),\n            msg=unhexlify(ensure_bytes(data)),\n            digestmod=sha512).digest()\n        # Split I into its 32 Byte components.\n        I_L, I_R = I[:32], I[32:]\n\n        if long_or_int(hexlify(I_L), 16) >= SECP256k1.order:\n            raise InvalidPrivateKeyError(\"The derived key is too large.\")\n\n        c_i = hexlify(I_R)\n        private_exponent = None\n        public_pair = None\n        if self.private_key:\n            # Use private information for derivation\n            # I_L is added to the current key's secret exponent (mod n), where\n            # n is the order of the ECDSA curve in use.\n            private_exponent = (\n                (long_or_int(hexlify(I_L), 16) +\n                 long_or_int(self.private_key.get_key(), 16))\n                % SECP256k1.order)\n            # I_R is the child's chain code\n        else:\n            # Only use public information for this derivation\n            g = SECP256k1.generator\n            I_L_long = long_or_int(hexlify(I_L), 16)\n            point = (_ECDSA_Public_key(g, g * I_L_long).point +\n                     self.public_key.to_point())\n            # I_R is the child's chain code\n            public_pair = PublicPair(point.x(), point.y())\n\n        child = self.__class__(\n            chain_code=c_i,\n            depth=self.depth + 1,  # we have to go deeper...\n            parent_fingerprint=self.fingerprint,\n            child_number=child_number_hex,\n            private_exponent=private_exponent,\n            public_pair=public_pair,\n            network=self.network)\n        if child.public_key.to_point() == INFINITY:\n            raise InfinityPointException(\"The point at infinity is invalid.\")\n        if not as_private:\n            return child.public_copy()\n        return child"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crack_private_key(self, child_private_key):\n        if self.private_key:\n            raise AssertionError(\"You already know the private key\")\n        if child_private_key.parent_fingerprint != self.fingerprint:\n            raise ValueError(\"This is not a valid child\")\n        if child_private_key.child_number >= 0x80000000:\n            raise ValueError(\n                \"Cannot crack private keys from private derivation\")\n\n        # Duplicate the public child derivation\n        child_number_hex = long_to_hex(child_private_key.child_number, 8)\n        data = self.get_public_key_hex() + child_number_hex\n        I = hmac.new(\n            unhexlify(ensure_bytes(self.chain_code)),\n            msg=unhexlify(ensure_bytes(data)),\n            digestmod=sha512).digest()\n        I_L, I_R = I[:32], I[32:]\n        # Public derivation is the same as private derivation plus some offset\n        # knowing the child's private key allows us to find this offset just\n        # by subtracting the child's private key from the parent I_L data\n        privkey = PrivateKey(long_or_int(hexlify(I_L), 16),\n                             network=self.network)\n        parent_private_key = child_private_key.private_key - privkey\n        return self.__class__(\n            chain_code=self.chain_code,\n            depth=self.depth,\n            parent_fingerprint=self.parent_fingerprint,\n            child_number=self.child_number,\n            private_key=parent_private_key,\n            network=self.network)", "response": "Crack the parent private key given a child private key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexports a key to WIF.", "response": "def export_to_wif(self):\n        \"\"\"Export a key to WIF.\n\n        See https://en.bitcoin.it/wiki/Wallet_import_format for a full\n        description.\n        \"\"\"\n        # Add the network byte, creating the \"extended key\"\n        extended_key_hex = self.private_key.get_extended_key()\n        # BIP32 wallets have a trailing \\01 byte\n        extended_key_bytes = unhexlify(ensure_bytes(extended_key_hex)) + b'\\01'\n        # And return the base58-encoded result with a checksum\n        return base58.b58encode_check(extended_key_bytes)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npushing a new package to PyPI.", "response": "def _pypi_push(dist):\n    \"\"\"Push created package to PyPI.\n\n    Requires the following defined environment variables:\n        - TWINE_USERNAME: The PyPI username to upload this package under\n        - TWINE_PASSWORD: The password to the user's account\n\n    Args:\n        dist (str):\n            The distribution to push. Must be a valid directory; shell globs are\n            NOT allowed.\n    \"\"\"\n    # Register all distributions and wheels with PyPI. We have to list the dist\n    # directory and register each file individually because `twine` doesn't\n    # handle globs.\n    for filename in os.listdir(dist):\n        full_path = os.path.join(dist, filename)\n        if os.path.isfile(full_path):\n            # This will fail if the project has never been uploaded, so use check=false\n            _shell('twine register ' + shlex.quote(full_path), check=False)\n\n    _shell('twine upload ' + shlex.quote(dist + '/*'))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeploying the package and documentation to the PyPI repository.", "response": "def deploy(target):\n    \"\"\"Deploys the package and documentation.\n\n    Proceeds in the following steps:\n\n    1. Ensures proper environment variables are set and checks that we are on Circle CI\n    2. Tags the repository with the new version\n    3. Creates a standard distribution and a wheel\n    4. Updates version.py to have the proper version\n    5. Commits the ChangeLog, AUTHORS, and version.py file\n    6. Pushes to PyPI\n    7. Pushes the tags and newly committed files\n\n    Raises:\n        `EnvironmentError`:\n            - Not running on CircleCI\n            - `*_PYPI_USERNAME` and/or `*_PYPI_PASSWORD` environment variables\n               are missing\n            - Attempting to deploy to production from a branch that isn't master\n    \"\"\"\n    # Ensure proper environment\n    if not os.getenv(CIRCLECI_ENV_VAR):     # pragma: no cover\n        raise EnvironmentError('Must be on CircleCI to run this script')\n\n    current_branch = os.getenv('CIRCLE_BRANCH')\n    if (target == 'PROD') and (current_branch != 'master'):\n        raise EnvironmentError(\n            f'Refusing to deploy to production from branch {current_branch!r}. '\n            f'Production deploys can only be made from master.')\n\n    if target in ('PROD', 'TEST'):\n        pypi_username = os.getenv(f'{target}_PYPI_USERNAME')\n        pypi_password = os.getenv(f'{target}_PYPI_PASSWORD')\n    else:\n        raise ValueError(f\"Deploy target must be 'PROD' or 'TEST', got {target!r}.\")\n\n    if not (pypi_username and pypi_password):  # pragma: no cover\n        raise EnvironmentError(\n            f\"Missing '{target}_PYPI_USERNAME' and/or '{target}_PYPI_PASSWORD' \"\n            f\"environment variables. These are required to push to PyPI.\")\n\n    # Twine requires these environment variables to be set. Subprocesses will\n    # inherit these when we invoke them, so no need to pass them on the command\n    # line. We want to avoid that in case something's logging each command run.\n    os.environ['TWINE_USERNAME'] = pypi_username\n    os.environ['TWINE_PASSWORD'] = pypi_password\n\n    # Set up git on circle to push to the current branch\n    _shell('git config --global user.email \"dev@cloverhealth.com\"')\n    _shell('git config --global user.name \"Circle CI\"')\n    _shell('git config push.default current')\n\n    # Obtain the version to deploy\n    ret = _shell('make version', stdout=subprocess.PIPE)\n    version = ret.stdout.decode('utf-8').strip()\n\n    print(f'Deploying version {version!r}...')\n\n    # Tag the version\n    _shell(f'git tag -f -a {version} -m \"Version {version}\"')\n\n    # Update the version\n    _shell(\n        f'sed -i.bak \"s/^__version__ = .*/__version__ = {version!r}/\" */version.py')\n\n    # Create a standard distribution and a wheel\n    _shell('python setup.py sdist bdist_wheel')\n\n    # Add the updated ChangeLog and AUTHORS\n    _shell('git add ChangeLog AUTHORS */version.py')\n\n    # Start the commit message with \"Merge\" so that PBR will ignore it in the\n    # ChangeLog. Use [skip ci] to ensure CircleCI doesn't recursively deploy.\n    _shell('git commit --no-verify -m \"Merge autogenerated files [skip ci]\"')\n\n    # Push the distributions to PyPI.\n    _pypi_push('dist')\n\n    # Push the tag and AUTHORS / ChangeLog after successful PyPI deploy\n    _shell('git push --follow-tags')\n\n    print(f'Deployment complete. Latest version is {version}.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_triplet(dd):\n    return _s(dd['q']), _s(dd.get('r', NoResponse)), _s(dd.get('e', NoResponse))", "response": "Return a triplet from a dialogue dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_resource(name):\n    with closing(pkg_resources.resource_stream(__name__, name)) as fp:\n        rbytes = fp.read()\n\n    return _load(StringIO(rbytes.decode('utf-8')))", "response": "Parse a resource file containing a list of dicts"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_component(name, comp, component_dict):\n    for dia in component_dict.get('dialogues', ()):\n        try:\n            comp.add_dialogue(*_get_pair(dia))\n        except Exception as e:\n            msg = 'In device %s, malformed dialogue %s\\n%r'\n            raise Exception(msg % (name, dia, e))\n\n    for prop_name, prop_dict in component_dict.get('properties', {}).items():\n        try:\n            getter = (_get_pair(prop_dict['getter'])\n                      if 'getter' in prop_dict else None)\n            setter = (_get_triplet(prop_dict['setter'])\n                      if 'setter' in prop_dict else None)\n            comp.add_property(prop_name, prop_dict.get('default', ''),\n                              getter, setter, prop_dict.get('specs', {}))\n        except Exception as e:\n            msg = 'In device %s, malformed property %s\\n%r'\n            raise type(e)(msg % (name, prop_name, format_exc()))", "response": "Update a component from a component dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_channel(device, ch_name, channel_dict, loader, resource_dict):\n    channel_dict = get_bases(channel_dict, loader)\n\n    r_ids = resource_dict.get('channel_ids', {}).get(ch_name, [])\n    ids = r_ids if r_ids else channel_dict.get('ids', {})\n\n    can_select = False if channel_dict.get('can_select') == 'False' else True\n    channels = Channels(device, ids, can_select)\n\n    update_component(ch_name, channels, channel_dict)\n\n    return channels", "response": "Get a channels from a channels dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a device from a device dictionary.", "response": "def get_device(name, device_dict, loader, resource_dict):\n    \"\"\"Get a device from a device dictionary.\n\n    :param name: name of the device\n    :param device_dict: device dictionary\n    :rtype: Device\n    \"\"\"\n    device = Device(name, device_dict.get('delimiter', ';').encode('utf-8'))\n\n    device_dict = get_bases(device_dict, loader)\n\n    err = device_dict.get('error', {})\n    device.add_error_handler(err)\n\n    for itype, eom_dict in device_dict.get('eom', {}).items():\n        device.add_eom(itype, *_get_pair(eom_dict))\n\n    update_component(name, device, device_dict)\n\n    for ch_name, ch_dict in device_dict.get('channels', {}).items():\n        device.add_channels(ch_name, get_channel(device, ch_name, ch_dict,\n                                                 loader, resource_dict))\n\n    return device"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_devices(filename, bundled):\n\n    loader = Loader(filename, bundled)\n\n    data = loader.data\n\n    devices = Devices()\n\n    # Iterate through the resources and generate each individual device\n    # on demand.\n\n    for resource_name, resource_dict in data.get('resources', {}).items():\n        device_name = resource_dict['device']\n\n        dd = loader.get_device_dict(device_name,\n                                    resource_dict.get('filename', None),\n                                    resource_dict.get('bundled', False),\n                                    SPEC_VERSION_TUPLE[0])\n\n        devices.add_device(resource_name,\n                           get_device(device_name, dd, loader, resource_dict))\n\n    return devices", "response": "Get a Devices object from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_value(self, string_value):\n        value = self.validate_value(string_value)\n        self._value = defaultdict(lambda: value)", "response": "Create an empty defaultdict holding the default value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current value for a channel.", "response": "def set_value(self, string_value):\n        \"\"\"Set the current value for a channel.\n\n        \"\"\"\n        value = self.validate_value(string_value)\n        self._value[self._channel._selected] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds dialogue to channel.", "response": "def add_dialogue(self, query, response):\n        \"\"\"Add dialogue to channel.\n\n        :param query: query string\n        :param response: response string\n        \"\"\"\n        self._dialogues['__default__'][to_bytes(query)] = to_bytes(response)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a property to the channel.", "response": "def add_property(self, name, default_value, getter_pair, setter_triplet,\n                     specs):\n        \"\"\"Add property to channel\n\n        :param name: property name\n        :param default_value: default value as string\n        :param getter_pair: (query, response)\n        :param setter_triplet: (query, response, error)\n        :param specs: specification of the Property\n        \"\"\"\n        self._properties[name] = ChannelProperty(self, name,\n                                                 default_value, specs)\n\n        if getter_pair:\n            query, response = getter_pair\n            self._getters['__default__'][to_bytes(query)] = name, response\n\n        if setter_triplet:\n            query, response, error = setter_triplet\n            self._setters.append((name,\n                                  stringparser.Parser(query),\n                                  to_bytes(response),\n                                  to_bytes(error)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef match(self, query):\n        if not self.can_select:\n            ch_id = self._device._properties['selected_channel'].get_value()\n            if ch_id in self._ids:\n                self._selected = ch_id\n            else:\n                return\n\n            response = self._match_dialog(query,\n                                          self._dialogues['__default__'])\n            if response is not None:\n                return response\n\n            response = self._match_getters(query,\n                                           self._getters['__default__'])\n            if response is not None:\n                return response\n\n        else:\n            for ch_id in self._ids:\n                self._selected = ch_id\n                response = self._match_dialog(query,\n                                              self._dialogues[ch_id])\n                if response is not None:\n                    return response\n\n                response = self._match_getters(query,\n                                               self._getters[ch_id])\n\n                if response is not None:\n                    return response\n\n        return self._match_setters(query)", "response": "Try to find a match for a query in the channel commands."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _match_setters(self, query):\n        q = query.decode('utf-8')\n        for name, parser, response, error_response in self._setters:\n            try:\n                parsed = parser(q)\n                logger.debug('Found response in setter of %s' % name)\n            except ValueError:\n                continue\n\n            try:\n                if isinstance(parsed, dict) and 'ch_id' in parsed:\n                    self._selected = parsed['ch_id']\n                    self._properties[name].set_value(parsed['0'])\n                else:\n                    self._properties[name].set_value(parsed)\n                return response\n            except ValueError:\n                if isinstance(error_response, bytes):\n                    return error_response\n                return self._device.error_response('command_error')\n\n        return None", "response": "Try to find a match in the setters list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_debug_info():\n        from . import __version__\n        from .parser import SPEC_VERSION\n        d = OrderedDict()\n        d['Version'] = '%s' % __version__\n        d['Spec version'] = SPEC_VERSION\n\n        return d", "response": "Return a list of lines with backend info."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self, session, resource_name,\n             access_mode=constants.AccessModes.no_lock, open_timeout=constants.VI_TMO_IMMEDIATE):\n        \"\"\"Opens a session to the specified resource.\n\n        Corresponds to viOpen function of the VISA library.\n\n        :param session: Resource Manager session\n                        (should always be a session returned\n                        from open_default_resource_manager()).\n        :param resource_name: Unique symbolic name of a resource.\n        :param access_mode: Specifies the mode by which the resource is to be accessed. (constants.AccessModes)\n        :param open_timeout: Specifies the maximum time period (in milliseconds) that this operation waits\n                             before returning an error.\n        :return: Unique logical identifier reference to a session, return value of the library call.\n        :rtype: session, :class:`pyvisa.constants.StatusCode`\n        \"\"\"\n\n        try:\n            open_timeout = int(open_timeout)\n        except ValueError:\n            raise ValueError('open_timeout (%r) must be an integer (or compatible type)' % open_timeout)\n\n        try:\n            parsed = rname.parse_resource_name(resource_name)\n        except rname.InvalidResourceName:\n            return 0, constants.StatusCode.error_invalid_resource_name\n\n        # Loops through all session types, tries to parse the resource name and if ok, open it.\n        cls = sessions.Session.get_session_class(parsed.interface_type_const, parsed.resource_class)\n\n        sess = cls(session, resource_name, parsed)\n\n        try:\n            sess.device = self.devices[sess.attrs[constants.VI_ATTR_RSRC_NAME]]\n        except KeyError:\n            return 0, constants.StatusCode.error_resource_not_found\n\n        return self._register(sess), constants.StatusCode.success", "response": "Opens a session to the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef close(self, session):\n        try:\n            del self.sessions[session]\n            return constants.StatusCode.success\n        except KeyError:\n            return constants.StatusCode.error_invalid_object", "response": "Closes the specified session event or find list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_resources(self, session, query='?*::INSTR'):\n\n        # For each session type, ask for the list of connected resources and merge them into a single list.\n\n        resources = self.devices.list_resources()\n\n        resources = rname.filter(resources, query)\n\n        if resources:\n            return resources\n\n        raise errors.VisaIOError(errors.StatusCode.error_resource_not_found.value)", "response": "List all connected devices matching query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, session, count):\n\n        try:\n            sess = self.sessions[session]\n        except KeyError:\n            return b'', constants.StatusCode.error_invalid_object\n\n        try:\n            chunk, status = sess.read(count)\n            if status == constants.StatusCode.error_timeout:\n                raise errors.VisaIOError(constants.VI_ERROR_TMO)\n            return chunk, status\n        except AttributeError:\n            return b'', constants.StatusCode.error_nonsupported_operation", "response": "Reads data from device or interface synchronously."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, session, data):\n\n        try:\n            sess = self.sessions[session]\n        except KeyError:\n            return constants.StatusCode.error_invalid_object\n\n        try:\n            return sess.write(data)\n        except AttributeError:\n            return constants.StatusCode.error_nonsupported_operation", "response": "Writes data to device or interface synchronously."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the session class for a given interface type and resource class.", "response": "def get_session_class(cls, interface_type, resource_class):\n        \"\"\"Return the session class for a given interface type and resource class.\n\n        :type interface_type: constants.InterfaceType\n        :type resource_class: str\n        :return: Session\n        \"\"\"\n        try:\n            return cls._session_classes[(interface_type, resource_class)]\n        except KeyError:\n            raise ValueError('No class registered for %s, %s' % (interface_type, resource_class))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(cls, interface_type, resource_class):\n        def _internal(python_class):\n            if (interface_type, resource_class) in cls._session_classes:\n                logger.warning('%s is already registered in the ResourceManager. '\n                               'Overwriting with %s' % ((interface_type, resource_class), python_class))\n\n            python_class.session_type = (interface_type, resource_class)\n            cls._session_classes[(interface_type, resource_class)] = python_class\n            return python_class\n        return _internal", "response": "Register a session class for a given interface type and resource class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_attribute(self, attribute):\n\n        # Check that the attribute exists.\n        try:\n            attr = attributes.AttributesByID[attribute]\n        except KeyError:\n            return 0, constants.StatusCode.error_nonsupported_attribute\n\n        # Check that the attribute is valid for this session type.\n        if not attr.in_resource(self.session_type):\n            return 0, constants.StatusCode.error_nonsupported_attribute\n\n        # Check that the attribute is readable.\n        if not attr.read:\n            raise Exception('Do not now how to handle write only attributes.')\n\n        # Return the current value of the default according the VISA spec\n        return self.attrs.setdefault(attribute, attr.default), constants.StatusCode.success", "response": "Get an attribute from the session."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets an attribute from the session.", "response": "def set_attribute(self, attribute, attribute_state):\n        \"\"\"Get an attribute from the session.\n\n        :param attribute:\n        :return: attribute value, status code\n        :rtype: object, constants.StatusCode\n        \"\"\"\n\n        # Check that the attribute exists.\n        try:\n            attr = attributes.AttributesByID[attribute]\n        except KeyError:\n            return constants.StatusCode.error_nonsupported_attribute\n\n        # Check that the attribute is valid for this session type.\n        if not attr.in_resource(self.session_type):\n            return constants.StatusCode.error_nonsupported_attribute\n\n        # Check that the attribute is writable.\n        if not attr.write:\n            return constants.StatusCode.error_attribute_read_only\n\n        try:\n            self.attrs[attribute] = attribute_state\n        except ValueError:\n            return constants.StatusCode.error_nonsupported_attribute_state\n\n        return constants.StatusCode.success"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_bytes(val):\n    if val is NoResponse:\n        return val\n    val = val.replace('\\\\r', '\\r').replace('\\\\n', '\\n')\n    return val.encode()", "response": "Takes a text message and return a tuple\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates that a value matches the property specs.", "response": "def validate_value(self, string_value):\n        \"\"\"Validate that a value match the Property specs.\n\n        \"\"\"\n        specs = self.specs\n        if 'type' in specs:\n            value = specs['type'](string_value)\n        else:\n            value = string_value\n        if 'min' in specs and value < specs['min']:\n            raise ValueError\n        if 'max' in specs and value > specs['max']:\n            raise ValueError\n        if 'valid' in specs and value not in specs['valid']:\n            raise ValueError\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to match in dialogues", "response": "def _match_dialog(self, query, dialogues=None):\n        \"\"\"Tries to match in dialogues\n\n        :param query: message tuple\n        :type query: Tuple[bytes]\n        :return: response if found or None\n        :rtype: Tuple[bytes] | None\n        \"\"\"\n        if dialogues is None:\n            dialogues = self._dialogues\n\n        # Try to match in the queries\n        if query in dialogues:\n            response = dialogues[query]\n            logger.debug('Found response in queries: %s' % repr(response))\n\n            return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _match_getters(self, query, getters=None):\n        if getters is None:\n            getters = self._getters\n\n        if query in getters:\n            name, response = getters[query]\n            logger.debug('Found response in getter of %s' % name)\n            response = response.format(self._properties[name].get_value())\n            return response.encode('utf-8')", "response": "Tries to match in getters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _match_setters(self, query):\n        q = query.decode('utf-8')\n        for name, parser, response, error_response in self._setters:\n            try:\n                value = parser(q)\n                logger.debug('Found response in setter of %s' % name)\n            except ValueError:\n                continue\n\n            try:\n                self._properties[name].set_value(value)\n                return response\n            except ValueError:\n                if isinstance(error_response, bytes):\n                    return error_response\n                return self.error_response('command_error')\n\n        return None", "response": "Tries to match in setters\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_error_handler(self, error_input):\n\n        if isinstance(error_input, dict):\n            error_response = error_input.get('response', {})\n            cerr = error_response.get('command_error', NoResponse)\n            qerr = error_response.get('query_error', NoResponse)\n\n            response_dict = {'command_error': cerr,\n                             'query_error': qerr}\n\n            register_list = error_input.get('status_register', [])\n\n            for register_dict in register_list:\n                query = register_dict['q']\n                register = StatusRegister(register_dict)\n                self._status_registers[to_bytes(query)] = register\n                for key in register.keys():\n                    self._error_map[key] = register\n\n            queue_list = error_input.get('error_queue', [])\n\n            for queue_dict in queue_list:\n                query = queue_dict['q']\n                err_queue = ErrorQueue(queue_dict)\n                self._error_queues[to_bytes(query)] = err_queue\n\n        else:\n            response_dict = {'command_error': error_input,\n                             'query_error': error_input}\n\n        for key, value in response_dict.items():\n            self._error_response[key] = to_bytes(value)", "response": "Add error handler to the device"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_eom(self, type_class, query_termination, response_termination):\n        interface_type, resource_class = type_class.split(' ')\n        interface_type = getattr(constants.InterfaceType,\n                                 interface_type.lower())\n        self._eoms[(interface_type,\n                    resource_class)] = (to_bytes(query_termination),\n                                        to_bytes(response_termination))", "response": "Add default end of message for a given interface type and resource class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite data into the device input buffer.", "response": "def write(self, data):\n        \"\"\"Write data into the device input buffer.\n\n        :param data: single element byte\n        :type data: bytes\n        \"\"\"\n        logger.debug('Writing into device input buffer: %r' % data)\n        if not isinstance(data, bytes):\n            raise TypeError('data must be an instance of bytes')\n\n        if len(data) != 1:\n            msg = 'data must have a length of 1, not %d'\n            raise ValueError(msg % len(data))\n\n        self._input_buffer.extend(data)\n\n        l = len(self._query_eom)\n        if not self._input_buffer.endswith(self._query_eom):\n            return\n\n        try:\n            message = bytes(self._input_buffer[:-l])\n            queries = (message.split(self.delimiter) if self.delimiter\n                       else [message])\n            for query in queries:\n                response = self._match(query)\n                eom = self._response_eom\n\n                if response is None:\n                    response = self.error_response('command_error')\n\n                if response is not NoResponse:\n                    self._output_buffer.extend(response)\n                    self._output_buffer.extend(eom)\n\n        finally:\n            self._input_buffer = bytearray()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read(self):\n        if self._output_buffer:\n            b, self._output_buffer = (self._output_buffer[0:1],\n                                      self._output_buffer[1:])\n            return b\n\n        return b''", "response": "Return a single byte from the output buffer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry to match in dialogues getters and setters and subcomponents of the current user.", "response": "def _match(self, query):\n        \"\"\"Tries to match in dialogues, getters and setters and subcomponents\n\n        :param query: message tuple\n        :type query: Tuple[bytes]\n        :return: response if found or None\n        :rtype: Tuple[bytes] | None\n        \"\"\"\n        response = self._match_dialog(query)\n        if response is not None:\n            return response\n\n        response = self._match_getters(query)\n        if response is not None:\n            return response\n\n        response = self._match_registers(query)\n        if response is not None:\n            return response\n\n        response = self._match_errors_queues(query)\n        if response is not None:\n            return response\n\n        response = self._match_setters(query)\n        if response is not None:\n            return response\n\n        if response is None:\n            for channel in self._channels.values():\n                response = channel.match(query)\n                if response:\n                    return response\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to match in status registers with the given message tuple.", "response": "def _match_registers(self, query):\n        \"\"\"Tries to match in status registers\n\n        :param query: message tuple\n        :type query: Tuple[bytes]\n        :return: response if found or None\n        :rtype: Tuple[bytes] | None\n        \"\"\"\n        if query in self._status_registers:\n            register = self._status_registers[query]\n            response = register.value\n            logger.debug('Found response in status register: %s',\n                         repr(response))\n            register.clear()\n\n            return response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _match_errors_queues(self, query):\n        if query in self._error_queues:\n            queue = self._error_queues[query]\n            response = queue.value\n            logger.debug('Found response in error queue: %s',\n                         repr(response))\n\n            return response", "response": "Tries to match in error queues\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbinding a device to resource name", "response": "def add_device(self, resource_name, device):\n        \"\"\"Bind device to resource name\n        \"\"\"\n\n        if device.resource_name is not None:\n            msg = 'The device %r is already assigned to %s'\n            raise ValueError(msg % (device, device.resource_name))\n\n        device.resource_name = resource_name\n\n        self._internal[device.resource_name] = device"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ordering(self, *args, **kwargs):\n        result = super(SequenceCursorPagination, self).get_ordering(*args, **kwargs)\n\n        # Because paginate_queryset sets self.ordering after reading it...we\n        # need to only modify it sometimes. (This allows re-use of the\n        # paginator, which probably only happens in tests.)\n        if result[0] != '#':\n            result = ('#', ) + result\n\n        return result", "response": "Take whatever the expected ordering is and then first order by QuerySet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the position of the current instance based on the ordering property.", "response": "def _get_position_from_instance(self, instance, ordering):\n        \"\"\"\n        The position will be a tuple of values:\n\n            The QuerySet number inside of the QuerySetSequence.\n            Whatever the normal value taken from the ordering property gives.\n\n        \"\"\"\n        # Get the QuerySet number of the current instance.\n        qs_order = getattr(instance, '#')\n\n        # Strip the '#' and call the standard _get_position_from_instance.\n        result = super(SequenceCursorPagination, self)._get_position_from_instance(instance, ordering[1:])\n\n        # Return a tuple of these two elements.\n        return (qs_order, result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a request with a cursor return a Cursor instance.", "response": "def decode_cursor(self, request):\n        \"\"\"\n        Given a request with a cursor, return a `Cursor` instance.\n\n        Differs from the standard CursorPagination to handle a tuple in the\n        position field.\n        \"\"\"\n        # Determine if we have a cursor, and if so then decode it.\n        encoded = request.query_params.get(self.cursor_query_param)\n        if encoded is None:\n            return None\n\n        try:\n            querystring = b64decode(encoded.encode('ascii')).decode('ascii')\n            tokens = urlparse.parse_qs(querystring, keep_blank_values=True)\n\n            offset = tokens.get('o', ['0'])[0]\n            offset = _positive_int(offset, cutoff=self.offset_cutoff)\n\n            reverse = tokens.get('r', ['0'])[0]\n            reverse = bool(int(reverse))\n\n            # The difference. Don't get just the 0th entry: get all entries.\n            position = tokens.get('p', None)\n        except (TypeError, ValueError):\n            raise NotFound(self.invalid_cursor_message)\n\n        return Cursor(offset=offset, reverse=reverse, position=position)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a comparator function based on the field names.", "response": "def _generate_comparator(cls, field_names):\n        \"\"\"\n        Construct a comparator function based on the field names. The comparator\n        returns the first non-zero comparison value.\n\n        Inputs:\n            field_names (iterable of strings): The field names to sort on.\n\n        Returns:\n            A comparator function.\n        \"\"\"\n        # Ensure that field names is a list and not a tuple.\n        field_names = list(field_names)\n\n        # For fields that start with a '-', reverse the ordering of the\n        # comparison.\n        reverses = [1] * len(field_names)\n        for i, field_name in enumerate(field_names):\n            if field_name[0] == '-':\n                reverses[i] = -1\n                field_names[i] = field_name[1:]\n\n        field_names = [f.replace(LOOKUP_SEP, '.') for f in field_names]\n\n        def comparator(i1, i2):\n            # Get a tuple of values for comparison.\n            v1 = attrgetter(*field_names)(i1)\n            v2 = attrgetter(*field_names)(i2)\n\n            # If there's only one arg supplied, attrgetter returns a single\n            # item, directly return the result in this case.\n            if len(field_names) == 1:\n                return cls._cmp(v1, v2) * reverses[0]\n\n            # Compare each field for the two items, reversing if necessary.\n            order = multiply_iterables(list(map(cls._cmp, v1, v2)), reverses)\n\n            try:\n                # The first non-zero element.\n                return next(dropwhile(__not__, order))\n            except StopIteration:\n                # Everything was equivalent.\n                return 0\n\n        return comparator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over the items in the unordered order.", "response": "def _unordered_iterator(self):\n        \"\"\"\n        Return the value of each QuerySet, but also add the '#' property to each\n        return item.\n        \"\"\"\n        for i, qs in zip(self._queryset_idxs, self._querysets):\n            for item in qs:\n                setattr(item, '#', i)\n                yield item"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _filter_or_exclude_querysets(self, negate, **kwargs):\n        # Ensure negate is a boolean.\n        negate = bool(negate)\n\n        for kwarg, value in kwargs.items():\n            parts = kwarg.split(LOOKUP_SEP)\n\n            # Ensure this is being used to filter QuerySets.\n            if parts[0] != '#':\n                raise ValueError(\"Keyword '%s' is not a valid keyword to filter over, \"\n                                 \"it must begin with '#'.\" % kwarg)\n\n            # Don't allow __ multiple times.\n            if len(parts) > 2:\n                raise ValueError(\"Keyword '%s' must not contain multiple \"\n                                 \"lookup seperators.\" % kwarg)\n\n            # The actual lookup is the second part.\n            try:\n                lookup = parts[1]\n            except IndexError:\n                lookup = 'exact'\n\n            # Math operators that all have the same logic.\n            LOOKUP_TO_OPERATOR = {\n                'exact': eq,\n                'iexact': eq,\n                'gt': gt,\n                'gte': ge,\n                'lt': lt,\n                'lte': le,\n            }\n            try:\n                operator = LOOKUP_TO_OPERATOR[lookup]\n\n                # These expect integers, this matches the logic in\n                # IntegerField.get_prep_value(). (Essentially treat the '#'\n                # field as an IntegerField.)\n                if value is not None:\n                    value = int(value)\n\n                self._queryset_idxs = filter(lambda i: operator(i, value) != negate, self._queryset_idxs)\n                continue\n            except KeyError:\n                # It wasn't one of the above operators, keep trying.\n                pass\n\n            # Some of these seem to get handled as bytes.\n            if lookup in ('contains', 'icontains'):\n                value = six.text_type(value)\n                self._queryset_idxs = filter(lambda i: (value in six.text_type(i)) != negate, self._queryset_idxs)\n\n            elif lookup == 'in':\n                self._queryset_idxs = filter(lambda i: (i in value) != negate, self._queryset_idxs)\n\n            elif lookup in ('startswith', 'istartswith'):\n                value = six.text_type(value)\n                self._queryset_idxs = filter(lambda i: six.text_type(i).startswith(value) != negate, self._queryset_idxs)\n\n            elif lookup in ('endswith', 'iendswith'):\n                value = six.text_type(value)\n                self._queryset_idxs = filter(lambda i: six.text_type(i).endswith(value) != negate, self._queryset_idxs)\n\n            elif lookup == 'range':\n                # Inclusive include.\n                start, end = value\n                self._queryset_idxs = filter(lambda i: (start <= i <= end) != negate, self._queryset_idxs)\n\n            else:\n                # Any other field lookup is not supported, e.g. date, year, month,\n                # day, week_day, hour, minute, second, isnull, search, regex, and\n                # iregex.\n                raise ValueError(\"Unsupported lookup '%s'\" % lookup)\n\n        # Convert back to a list on Python 3.\n        self._queryset_idxs = list(self._queryset_idxs)\n\n        # Finally, keep only the QuerySets we care about!\n        self._querysets = [self._querysets[i] for i in self._queryset_idxs]", "response": "Filter the list of QuerySets in the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a custom transit tag and parser function for use during reads.", "response": "def register(self, key_or_tag, f_val):\n        \"\"\"Register a custom transit tag and decoder/parser function for use\n        during reads.\n        \"\"\"\n        self.reader.decoder.register(key_or_tag, f_val)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the name if it is in the cache otherwise returns the name if it is not in the cache.", "response": "def decode(self, name, as_map_key=False):\n        \"\"\"Always returns the name\"\"\"\n        if is_cache_key(name) and (name in self.key_to_value):\n            return self.key_to_value[name]\n        return self.encache(name) if is_cacheable(name, as_map_key) else name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encode(self, name, as_map_key=False):\n        if name in self.key_to_value:\n            return self.key_to_value[name]\n        return self.encache(name) if is_cacheable(name, as_map_key) else name", "response": "Returns the name the first time and the key after that"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_chunk(stream):\n    chunk = stream.read(1)\n    while chunk in SKIP:\n        chunk = stream.read(1)\n    if chunk == \"\\\"\":\n        chunk += stream.read(1)\n        while not chunk.endswith(\"\\\"\"):\n            if chunk[-1] == ESCAPE:\n                chunk += stream.read(2)\n            else:\n                chunk += stream.read(1)\n    return chunk", "response": "Read a single chunk from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef items(stream, **kwargs):\n    for s in yield_json(stream):\n        yield json.loads(s, **kwargs)", "response": "Yields items from a stream"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields JSON items from the given stream.", "response": "def yield_json(stream):\n    \"\"\"Uses array and object delimiter counts for balancing.\n    \"\"\"\n    buff = u\"\"\n    arr_count = 0\n    obj_count = 0\n    while True:\n        buff += read_chunk(stream)\n\n        # If we finish parsing all objs or arrays, yield a finished JSON\n        # entity.\n        if buff.endswith('{'):\n            obj_count += 1\n        if buff.endswith('['):\n            arr_count += 1\n        if buff.endswith(']'):\n            arr_count -= 1\n            if obj_count == arr_count == 0:\n                json_item = copy(buff)\n                buff = u\"\"\n                yield json_item\n        if buff.endswith('}'):\n            obj_count -= 1\n            if obj_count == arr_count == 0:\n                json_item = copy(buff)\n                buff = u\"\"\n                yield json_item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef are_stringable_keys(self, m):\n        for x in m.keys():\n            if len(self.handlers[x].tag(x)) != 1:\n                return False\n        return True", "response": "Test whether the keys within a map are stringable - a simple map that can be optimized and whose keys can be cached"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmarshals an individual object potentially as part of another container object.", "response": "def marshal(self, obj, as_map_key, cache):\n        \"\"\"Marshal an individual obj, potentially as part of another container\n        object (like a list/dictionary/etc).  Specify if this object is a key\n        to a map/dict, and pass in the current cache being used.\n        This method should only be called by a top-level marshalling call\n        and should not be considered an entry-point for integration.\n        \"\"\"\n        handler = self.handlers[obj]\n        tag = handler.tag(obj)\n        f = marshal_dispatch.get(tag)\n\n        if f:\n            f(self, obj, handler.string_rep(obj) if as_map_key else handler.rep(obj), as_map_key, cache)\n        else:\n            self.emit_encoded(tag, handler, obj, as_map_key, cache)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef marshal_top(self, obj, cache=None):\n        if not cache:\n            cache = RollingCache()\n\n        handler = self.handlers[obj]\n\n        tag = handler.tag(obj)\n        if tag:\n            if len(tag) == 1:\n                self.marshal(TaggedValue(QUOTE, obj), False, cache)\n            else:\n                self.marshal(obj, False, cache)\n            self.flush()\n        else:\n            raise AssertionError(\"Handler must provide a non-nil tag: \" + str(handler))", "response": "Given a complete object that needs to be marshaled into Transit\n        data dispatch accordingly and flush the data\n        directly into the IO stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dispatch_map(self, rep, as_map_key, cache):\n        if self.are_stringable_keys(rep):\n            return self.emit_map(rep, as_map_key, cache)\n        return self.emit_cmap(rep, as_map_key, cache)", "response": "Dispatches a map to the appropriate handler."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nemit a map as per default JSON spec.", "response": "def emit_map(self, m, _, cache):\n        \"\"\"Emits array as per default JSON spec.\"\"\"\n        self.emit_array_start(None)\n        self.marshal(MAP_AS_ARR, False, cache)\n        for k, v in m.items():\n            self.marshal(k, True, cache)\n            self.marshal(v, False, cache)\n        self.emit_array_end()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode(self, node, cache=None, as_map_key=False):\n        if not cache:\n            cache = RollingCache()\n        return self._decode(node, cache, as_map_key)", "response": "Given a node of data return the decoded object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decode_list(self, node, cache, as_map_key):\n        if node:\n            if node[0] == MAP_AS_ARR:\n                # key must be decoded before value for caching to work.\n                returned_dict = {}\n                for k, v in pairs(node[1:]):\n                    key = self._decode(k, cache, True)\n                    val = self._decode(v, cache, as_map_key)\n                    returned_dict[key] = val\n                return transit_types.frozendict(returned_dict)\n\n            decoded = self._decode(node[0], cache, as_map_key)\n            if isinstance(decoded, Tag):\n                return self.decode_tag(decoded.tag,\n                                       self._decode(node[1], cache, as_map_key))\n        return tuple(self._decode(x, cache, as_map_key) for x in node)", "response": "Decode a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode a string - arguments follow the same convention as the top - level decode function.", "response": "def decode_string(self, string, cache, as_map_key):\n        \"\"\"Decode a string - arguments follow the same convention as the\n        top-level 'decode' function.\n        \"\"\"\n        if is_cache_key(string):\n            return self.parse_string(cache.decode(string, as_map_key),\n                                     cache, as_map_key)\n        if is_cacheable(string, as_map_key):\n            cache.encode(string, as_map_key)\n        return self.parse_string(string, cache, as_map_key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(self, key_or_tag, obj):\n        if key_or_tag == \"default_decoder\":\n            self.options[\"default_decoder\"] = obj\n        else:\n            self.decoders[key_or_tag] = obj", "response": "Register a custom Transit tag and new parsing function with the\n        decoder."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_rep(u):\n        if isinstance(u, pyversion.string_types):\n            return uuid.UUID(u)\n\n        # hack to remove signs\n        a = ctypes.c_ulong(u[0])\n        b = ctypes.c_ulong(u[1])\n        combined = a.value << 64 | b.value\n        return uuid.UUID(int=combined)", "response": "Given a string return a UUID object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the in_port value from the OXM_TLV field of the PacketIn.", "response": "def in_port(self):\n        \"\"\"Retrieve the 'in_port' that generated the PacketIn.\n\n        This method will look for the OXM_TLV with type OFPXMT_OFB_IN_PORT on\n        the `oxm_match_fields` field from `match` field and return its value,\n        if the OXM exists.\n\n        Returns:\n            The integer number of the 'in_port' that generated the PacketIn if\n            it exists. Otherwise return None.\n\n        \"\"\"\n        in_port = self.match.get_field(OxmOfbMatchField.OFPXMT_OFB_IN_PORT)\n        return int.from_bytes(in_port, 'big')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack a binary message into this object s attributes based on the binary value of the message.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results. It is an inplace method and it receives the binary data\n        of the message **without the header**.\n\n        This class' unpack method is like the :meth:`.GenericMessage.unpack`\n        one, except for the ``actions`` attribute which has a length determined\n        by the ``actions_len`` attribute.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked, without the\n                header.\n            offset (int): Where to begin unpacking.\n        \"\"\"\n        begin = offset\n        for attribute_name, class_attribute in self.get_class_attributes():\n            if type(class_attribute).__name__ != \"Header\":\n                attribute = deepcopy(class_attribute)\n                if attribute_name == 'actions':\n                    length = self.actions_len.value\n                    attribute.unpack(buff[begin:begin+length])\n                else:\n                    attribute.unpack(buff, begin)\n                setattr(self, attribute_name, attribute)\n                begin += attribute.get_size()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_actions_len(self):\n        if isinstance(self.actions, ListOfActions):\n            self.actions_len = self.actions.get_size()\n        else:\n            self.actions_len = ListOfActions(self.actions).get_size()", "response": "Update the actions_len field based on actions value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_in_port(self):\n        is_valid_range = self.in_port > 0 and self.in_port <= Port.OFPP_MAX\n        is_valid_virtual_in_ports = self.in_port in _VIRT_IN_PORTS\n\n        if (is_valid_range or is_valid_virtual_in_ports) is False:\n            raise ValidationError(f'{self.in_port} is not a valid input port.')", "response": "Validate the in_port attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pack(self, value=None):\n        backup = self.body\n        if not value:\n            value = self.body\n\n        if hasattr(value, 'pack'):\n            self.body = value.pack()\n        stats_request_packed = super().pack()\n\n        self.body = backup\n        return stats_request_packed", "response": "Pack according to body_type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unpack(self, buff, offset=0):\n        super().unpack(buff)\n\n        class_name = self._get_body_class()\n        buff = self.body.value\n        self.body = FixedTypeList(pyof_class=class_name)\n        self.body.unpack(buff)", "response": "Unpack according to body_type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a class related with this type.", "response": "def find_class(self):\n        \"\"\"Return a class related with this type.\"\"\"\n        if self.value <= 1:\n            return InstructionsProperty\n        elif self.value <= 3:\n            return NextTablesProperty\n        elif self.value <= 7:\n            return ActionsProperty\n\n        return OxmProperty"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unpack(self, buff=None, offset=0):\n        property_type = UBInt16(enum_ref=TableFeaturePropType)\n        property_type.unpack(buff, offset)\n        self.__class__ = TableFeaturePropType(property_type.value).find_class()\n\n        length = UBInt16()\n        length.unpack(buff, offset=offset+2)\n        super().unpack(buff[:offset+length.value], offset=offset)", "response": "Unpack the contents of the n - tuple into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack(self, buff=None, offset=0):\n        length = UBInt16()\n        length.unpack(buff, offset)\n        super().unpack(buff[:offset+length.value], offset)", "response": "Unpack the contents of the n - tuple into this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive an OpenFlow Message Type return an empty OpenFlow message of that type.", "response": "def new_message_from_message_type(message_type):\n    \"\"\"Given an OpenFlow Message Type, return an empty message of that type.\n\n    Args:\n        messageType (:class:`~pyof.v0x01.common.header.Type`):\n            Python-openflow message.\n\n    Returns:\n        Empty OpenFlow message of the requested message type.\n\n    Raises:\n        KytosUndefinedMessageType: Unkown Message_Type.\n\n    \"\"\"\n    message_type = str(message_type)\n\n    if message_type not in MESSAGE_TYPES:\n        raise ValueError('\"{}\" is not known.'.format(message_type))\n\n    message_class = MESSAGE_TYPES.get(message_type)\n    message_instance = message_class()\n\n    return message_instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive an OF Header return an empty OpenFlow message of the same type of message_type attribute from that header.", "response": "def new_message_from_header(header):\n    \"\"\"Given an OF Header, return an empty message of header's message_type.\n\n    Args:\n        header (~pyof.v0x01.common.header.Header): Unpacked OpenFlow Header.\n\n    Returns:\n        Empty OpenFlow message of the same type of message_type attribute from\n        the given header.\n        The header attribute of the message will be populated.\n\n    Raises:\n        KytosUndefinedMessageType: Unkown Message_Type.\n\n    \"\"\"\n    message_type = header.message_type\n    if not isinstance(message_type, Type):\n        try:\n            if isinstance(message_type, str):\n                message_type = Type[message_type]\n            elif isinstance(message_type, int):\n                message_type = Type(message_type)\n        except ValueError:\n            raise ValueError\n\n    message = new_message_from_message_type(message_type)\n    message.header.xid = header.xid\n    message.header.length = header.length\n\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack the whole buffer including header pack.", "response": "def unpack_message(buffer):\n    \"\"\"Unpack the whole buffer, including header pack.\n\n    Args:\n        buffer (bytes): Bytes representation of a openflow message.\n\n    Returns:\n        object: Instance of openflow message.\n\n    \"\"\"\n    hdr_size = Header().get_size()\n    hdr_buff, msg_buff = buffer[:hdr_size], buffer[hdr_size:]\n    header = Header()\n    header.unpack(hdr_buff)\n    message = new_message_from_header(header)\n    message.unpack(msg_buff)\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unpack(self, buff=None, offset=0):\n        band_type = UBInt16(enum_ref=MeterBandType)\n        band_type.unpack(buff, offset)\n        self.__class__ = MeterBandType(band_type.value).find_class()\n\n        length = UBInt16()\n        length.unpack(buff, offset=offset+2)\n\n        super().unpack(buff[:offset+length.value], offset)", "response": "Unpack the contents of the passed in buffer into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pack(self, value=None):\n        buff = self.body\n        if not value:\n            value = self.body\n\n        if value:\n            if isinstance(value, (list, FixedTypeList)):\n                obj = self._get_body_instance()\n                obj.extend(value)\n            elif hasattr(value, 'pack'):\n                obj = value\n\n            self.body = obj.pack()\n\n        multipart_packed = super().pack()\n        self.body = buff\n\n        return multipart_packed", "response": "Pack a StatsReply using the object s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunpacking a binary message into this object s attributes based on the results.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results. It is an inplace method and it receives the binary data\n        of the message **without the header**.\n\n        This class' unpack method is like the :meth:`.GenericMessage.unpack`\n        one, except for the ``body`` attribute which has its type determined\n        by the ``multipart_type`` attribute.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked, without the\n                header.\n        \"\"\"\n        super().unpack(buff[offset:])\n        self._unpack_body()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _unpack_body(self):\n        obj = self._get_body_instance()\n        obj.unpack(self.body.value)\n        self.body = obj", "response": "Unpack body replace it by the result."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_body_instance(self):\n        exp_header = ExperimenterMultipartHeader\n        simple_body = {MultipartType.OFPMP_DESC: Desc,\n                       MultipartType.OFPMP_GROUP_FEATURES: GroupFeatures,\n                       MultipartType.OFPMP_METER_FEATURES: MeterFeatures,\n                       MultipartType.OFPMP_EXPERIMENTER: exp_header}\n\n        array_of_bodies = {MultipartType.OFPMP_FLOW: FlowStats,\n                           MultipartType.OFPMP_AGGREGATE: AggregateStatsReply,\n                           MultipartType.OFPMP_TABLE: TableStats,\n                           MultipartType.OFPMP_PORT_STATS: PortStats,\n                           MultipartType.OFPMP_QUEUE: QueueStats,\n                           MultipartType.OFPMP_GROUP: GroupStats,\n                           MultipartType.OFPMP_GROUP_DESC: GroupDescStats,\n                           MultipartType.OFPMP_METER: MeterStats,\n                           MultipartType.OFPMP_METER_CONFIG: MeterConfig,\n                           MultipartType.OFPMP_TABLE_FEATURES: TableFeatures,\n                           MultipartType.OFPMP_PORT_DESC: Port}\n\n        if isinstance(self.multipart_type, (int, UBInt16)):\n            self.multipart_type = self.multipart_type.enum_ref(\n                self.multipart_type.value)\n\n        pyof_class = simple_body.get(self.multipart_type, None)\n        if pyof_class:\n            return pyof_class()\n\n        array_of_class = array_of_bodies.get(self.multipart_type, None)\n        if array_of_class:\n            return FixedTypeList(pyof_class=array_of_class)\n\n        return BinaryData(b'')", "response": "Return the body instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nunpacks a binary message into this object s attributes.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Pass the correct length for list unpacking.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n        \"\"\"\n        unpack_length = UBInt16()\n        unpack_length.unpack(buff, offset)\n        super().unpack(buff[:offset+unpack_length], offset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunpacking the contents of the passed in buffer into this object.", "response": "def unpack(self, buff=None, offset=0):\n        \"\"\"Unpack *buff* into this object.\n\n        This method will convert a binary data into a readable value according\n        to the attribute format.\n\n        Args:\n            buff (bytes): Binary buffer.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            :exc:`~.exceptions.UnpackException`: If unpack fails.\n\n        \"\"\"\n        length = UBInt16()\n        length.unpack(buff, offset)\n\n        length.unpack(buff, offset=offset+MeterStats.meter_id.get_size())\n        super().unpack(buff[:offset+length.value], offset=offset)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_class(self):\n        classes = {1: InstructionGotoTable, 2: InstructionWriteMetadata,\n                   3: InstructionWriteAction, 4: InstructionApplyAction,\n                   5: InstructionClearAction, 6: InstructionMeter}\n        return classes.get(self.value, None)", "response": "Return a class related with this type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nunpack the contents of the nacms entry class into this object.", "response": "def unpack(self, buff=None, offset=0):\n        \"\"\"Unpack *buff* into this object.\n\n        This method will convert a binary data into a readable value according\n        to the attribute format.\n\n        Args:\n            buff (bytes): Binary buffer.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            :exc:`~.exceptions.UnpackException`: If unpack fails.\n\n        \"\"\"\n        instruction_type = UBInt16(enum_ref=InstructionType)\n        instruction_type.unpack(buff, offset)\n        self.__class__ = InstructionType(instruction_type.value).find_class()\n\n        length = UBInt16()\n        length.unpack(buff, offset=offset+2)\n\n        super().unpack(buff[:offset+length.value], offset)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unpack(self, buff, offset=0):\n        super().unpack(buff, offset)\n        # Recover field from field_and_hasmask.\n        try:\n            self.oxm_field = self._unpack_oxm_field()\n        except ValueError as exception:\n            raise UnpackException(exception)\n\n        # The last bit of field_and_mask is oxm_hasmask\n        self.oxm_hasmask = (self.oxm_field_and_mask & 1) == 1  # as boolean\n\n        # Unpack oxm_value that has oxm_length bytes\n        start = offset + 4  # 4 bytes: class, field_and_mask and length\n        end = start + self.oxm_length\n        self.oxm_value = buff[start:end]", "response": "Unpack the buffer into a OxmTLV."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _unpack_oxm_field(self):\n        field_int = self.oxm_field_and_mask >> 1\n        # We know that the class below requires a subset of the ofb enum\n        if self.oxm_class == OxmClass.OFPXMC_OPENFLOW_BASIC:\n            return OxmOfbMatchField(field_int)\n        return field_int", "response": "Unpack oxm_field from oxm_field_and_mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the length field with the packed version of the packed version of the data.", "response": "def _update_length(self):\n        \"\"\"Update length field.\n\n        Update the oxm_length field with the packed payload length.\n\n        \"\"\"\n        payload = type(self).oxm_value.pack(self.oxm_value)\n        self.oxm_length = len(payload)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npacks the object into a byte string.", "response": "def pack(self, value=None):\n        \"\"\"Join oxm_hasmask bit and 7-bit oxm_field.\"\"\"\n        if value is not None:\n            return value.pack()\n\n        # Set oxm_field_and_mask instance attribute\n        # 1. Move field integer one bit to the left\n        try:\n            field_int = self._get_oxm_field_int()\n        except ValueError as exception:\n            raise PackException(exception)\n        field_bits = field_int << 1\n        # 2. hasmask bit\n        hasmask_bit = self.oxm_hasmask & 1\n        # 3. Add hasmask bit to field value\n        self.oxm_field_and_mask = field_bits + hasmask_bit\n\n        self._update_length()\n        return super().pack(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_oxm_field_int(self):\n        if self.oxm_class == OxmClass.OFPXMC_OPENFLOW_BASIC:\n            return OxmOfbMatchField(self.oxm_field).value\n        elif not isinstance(self.oxm_field, int) or self.oxm_field > 127:\n            raise ValueError('oxm_field above 127: \"{self.oxm_field}\".')\n        return self.oxm_field", "response": "Return a valid integer value for oxm_field. Used while packing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pack(self, value=None):\n        if isinstance(value, Match):\n            return value.pack()\n        elif value is None:\n            self._update_match_length()\n            packet = super().pack()\n            return self._complete_last_byte(packet)\n        raise PackException(f'Match can\\'t unpack \"{value}\".')", "response": "Pack and complete the last byte by padding."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _complete_last_byte(self, packet):\n        padded_size = self.get_size()\n        padding_bytes = padded_size - len(packet)\n        if padding_bytes > 0:\n            packet += Pad(padding_bytes).pack()\n        return packet", "response": "Pad until the packet length is a multiple of 8 ( bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_size(self, value=None):\n        if isinstance(value, Match):\n            return value.get_size()\n        elif value is None:\n            current_size = super().get_size()\n            return ceil(current_size / 8) * 8\n        raise ValueError(f'Invalid value \"{value}\" for Match.get_size()')", "response": "Return the packet length including the padding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunpacking the class attributes from a buffer.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Discard padding bytes using the unpacked length attribute.\"\"\"\n        begin = offset\n        for name, value in list(self.get_class_attributes())[:-1]:\n            size = self._unpack_attribute(name, value, buff, begin)\n            begin += size\n        self._unpack_attribute('oxm_match_fields', type(self).oxm_match_fields,\n                               buff[:offset+self.length], begin)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the value for the field_type field in oxm_match_fields.", "response": "def get_field(self, field_type):\n        \"\"\"Return the value for the 'field_type' field in oxm_match_fields.\n\n        Args:\n            field_type (~pyof.v0x04.common.flow_match.OxmOfbMatchField,\n                        ~pyof.v0x04.common.flow_match.OxmMatchFields):\n                The type of the OXM field you want the value.\n\n        Returns:\n            The integer number of the 'field_type' if it exists. Otherwise\n            return None.\n\n        \"\"\"\n        for field in self.oxm_match_fields:\n            if field.oxm_field == field_type:\n                return field.oxm_value\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns this type s value.", "response": "def value(self):\n        \"\"\"Return this type's value.\n\n        Returns:\n            object: The value of an enum, bitmask, etc.\n\n        \"\"\"\n        if self.isenum():\n            if isinstance(self._value, self.enum_ref):\n                return self._value.value\n            return self._value\n        elif self.is_bitmask():\n            return self._value.bitmask\n        else:\n            return self._value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack the contents of the buffer into the object.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack *buff* into this object.\n\n        This method will convert a binary data into a readable value according\n        to the attribute format.\n\n        Args:\n            buff (bytes): Binary buffer.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            :exc:`~.exceptions.UnpackException`: If unpack fails.\n\n        \"\"\"\n        try:\n            self._value = struct.unpack_from(self._fmt, buff, offset)[0]\n            if self.enum_ref:\n                self._value = self.enum_ref(self._value)\n        except (struct.error, TypeError, ValueError) as exception:\n            msg = '{}; fmt = {}, buff = {}, offset = {}.'.format(exception,\n                                                                 self._fmt,\n                                                                 buff, offset)\n            raise UnpackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the message type of the header.", "response": "def _header_message_type_update(obj, attr):\n        \"\"\"Update the message type on the header.\n\n        Set the message_type of the header according to the message_type of\n        the parent class.\n        \"\"\"\n        old_enum = obj.message_type\n        new_header = attr[1]\n        new_enum = new_header.__class__.message_type.enum_ref\n        #: This 'if' will be removed on the future with an\n        #: improved version of __init_subclass__ method of the\n        #: GenericMessage class\n        if old_enum:\n            msg_type_name = old_enum.name\n            new_type = new_enum[msg_type_name]\n            new_header.message_type = new_type\n        return (attr[0], new_header)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_pyof_version(module_fullname):\n        ver_module_re = re.compile(r'(pyof\\.)(v0x\\d+)(\\..*)')\n        matched = ver_module_re.match(module_fullname)\n        if matched:\n            version = matched.group(2)\n            return version\n        return None", "response": "Get the module pyof version based on the module fullname."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_pyof_version(module_fullname, version):\n        module_version = MetaStruct.get_pyof_version(module_fullname)\n        if not module_version or module_version == version:\n            return None\n\n        return module_fullname.replace(module_version, version)", "response": "Replaces the OF Version of a module fullname with a new version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pyof_obj_new_version(name, obj, new_version):\n        if new_version is None:\n            return (name, obj)\n\n        cls = obj.__class__\n        cls_name = cls.__name__\n        cls_mod = cls.__module__\n\n        #: If the module name does not starts with pyof.v0 then it is not a\n        #: 'pyof versioned' module (OpenFlow specification defined), so we do\n        #: not have anything to do with it.\n        new_mod = MetaStruct.replace_pyof_version(cls_mod, new_version)\n        if new_mod is not None:\n            # Loads the module\n            new_mod = importlib.import_module(new_mod)\n            #: Get the class from the loaded module\n            new_cls = getattr(new_mod, cls_name)\n            #: return the tuple with the attribute name and the instance\n            return (name, new_cls())\n\n        return (name, obj)", "response": "r This method returns a class attribute on a different pyof version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the type of each attribute.", "response": "def _validate_attributes_type(self):\n        \"\"\"Validate the type of each attribute.\"\"\"\n        for _attr, _class in self._get_attributes():\n            if isinstance(_attr, _class):\n                return True\n            elif issubclass(_class, GenericType):\n                if GenericStruct._attr_fits_into_class(_attr, _class):\n                    return True\n            elif not isinstance(_attr, _class):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_class_attributes(cls):\n        #: see this method docstring for a important notice about the use of\n        #: cls.__dict__\n        for name, value in cls.__dict__.items():\n            # gets only our (kytos) attributes. this ignores methods, dunder\n            # methods and attributes, and common python type attributes.\n            if GenericStruct._is_pyof_attribute(value):\n                yield (name, value)", "response": "Return a generator for class attributes names and values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a generator for instance attributes name and value.", "response": "def _get_instance_attributes(self):\n        \"\"\"Return a generator for instance attributes' name and value.\n\n        .. code-block:: python3\n\n            for _name, _value in self._get_instance_attributes():\n                print(\"attribute name: {}\".format(_name))\n                print(\"attribute value: {}\".format(_value))\n\n        Returns:\n            generator: tuples with attribute name and value.\n\n        \"\"\"\n        for name, value in self.__dict__.items():\n            if name in map((lambda x: x[0]), self.get_class_attributes()):\n                yield (name, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator for instance and class attribute.", "response": "def _get_attributes(self):\n        \"\"\"Return a generator for instance and class attribute.\n\n        .. code-block:: python3\n\n            for instance_attribute, class_attribute in self._get_attributes():\n                print(\"Instance Attribute: {}\".format(instance_attribute))\n                print(\"Class Attribute: {}\".format(class_attribute))\n\n        Returns:\n            generator: Tuples with instance attribute and class attribute\n\n        \"\"\"\n        return map((lambda i, c: (i[1], c[1])),\n                   self._get_instance_attributes(),\n                   self.get_class_attributes())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning generator for attribute s name instance and class values.", "response": "def _get_named_attributes(self):\n        \"\"\"Return generator for attribute's name, instance and class values.\n\n        Add attribute name to meth:`_get_attributes` for a better debugging\n        message, so user can find the error easier.\n\n        Returns:\n            generator: Tuple with attribute's name, instance and class values.\n\n        \"\"\"\n        for cls, instance in zip(self.get_class_attributes(),\n                                 self._get_instance_attributes()):\n            attr_name, cls_value = cls\n            instance_value = instance[1]\n            yield attr_name, instance_value, cls_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the total size in bytes.", "response": "def get_size(self, value=None):\n        \"\"\"Calculate the total struct size in bytes.\n\n        For each struct attribute, sum the result of each one's ``get_size()``\n        method.\n\n        Args:\n            value: In structs, the user can assign other value instead of a\n                class' instance.\n\n        Returns:\n            int: Total number of bytes used by the struct.\n\n        Raises:\n            Exception: If the struct is not valid.\n\n        \"\"\"\n        if value is None:\n            return sum(cls_val.get_size(obj_val) for obj_val, cls_val in\n                       self._get_attributes())\n        elif isinstance(value, type(self)):\n            return value.get_size()\n        else:\n            msg = \"{} is not an instance of {}\".format(value,\n                                                       type(self).__name__)\n            raise PackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pack(self, value=None):\n        if value is None:\n            if not self.is_valid():\n                error_msg = \"Error on validation prior to pack() on class \"\n                error_msg += \"{}.\".format(type(self).__name__)\n                raise ValidationError(error_msg)\n            else:\n                message = b''\n                # pylint: disable=no-member\n                for attr_info in self._get_named_attributes():\n                    name, instance_value, class_value = attr_info\n                    try:\n                        message += class_value.pack(instance_value)\n                    except PackException as pack_exception:\n                        cls = type(self).__name__\n                        msg = f'{cls}.{name} - {pack_exception}'\n                        raise PackException(msg)\n                return message\n        elif isinstance(value, type(self)):\n            return value.pack()\n        else:\n            msg = \"{} is not an instance of {}\".format(value,\n                                                       type(self).__name__)\n            raise PackException(msg)", "response": "Pack the struct into a binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npack the message into a binary data.", "response": "def pack(self, value=None):\n        \"\"\"Pack the message into a binary data.\n\n        One of the basic operations on a Message is the pack operation. During\n        the packing process, we convert all message attributes to binary\n        format.\n\n        Since that this is usually used before sending the message to a switch,\n        here we also call :meth:`update_header_length`.\n\n        .. seealso:: This method call its parent's :meth:`GenericStruct.pack`\n            after :meth:`update_header_length`.\n\n        Returns:\n            bytes: A binary data thats represents the Message.\n\n        Raises:\n            Exception: If there are validation errors.\n\n        \"\"\"\n        if value is None:\n            self.update_header_length()\n            return super().pack()\n        elif isinstance(value, type(self)):\n            return value.pack()\n        else:\n            msg = \"{} is not an instance of {}\".format(value,\n                                                       type(self).__name__)\n            raise PackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunpack a binary message into this object s attributes based .", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results. It is an inplace method and it receives the binary data\n        of the message **without the header**.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked, without the\n                header.\n            offset (int): Where to begin unpacking.\n        \"\"\"\n        begin = offset\n        for name, value in self.get_class_attributes():\n            if type(value).__name__ != \"Header\":\n                size = self._unpack_attribute(name, value, buff, begin)\n                begin += size"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting of selected enum names.", "response": "def names(self):\n        \"\"\"List of selected enum names.\n\n        Returns:\n            list: Enum names.\n\n        \"\"\"\n        result = []\n        for key, value in self.iteritems():\n            if value & self.bitmask:\n                result.append(key)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunpacking a binary message into this object s attributes based on the results.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            Exception: If there is a struct unpacking error.\n\n        \"\"\"\n        self.action_type = UBInt16(enum_ref=ActionType)\n        self.action_type.unpack(buff, offset)\n\n        for cls in ActionHeader.__subclasses__():\n            if self.action_type.value in cls.get_allowed_types():\n                self.__class__ = cls\n                break\n\n        super().unpack(buff, offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the body instance.", "response": "def _get_body_instance(self):\n        \"\"\"Return the body instance.\"\"\"\n        simple_body = {\n            MultipartType.OFPMP_FLOW: FlowStatsRequest,\n            MultipartType.OFPMP_AGGREGATE: AggregateStatsRequest,\n            MultipartType.OFPMP_PORT_STATS: PortStatsRequest,\n            MultipartType.OFPMP_QUEUE: QueueStatsRequest,\n            MultipartType.OFPMP_GROUP: GroupStatsRequest,\n            MultipartType.OFPMP_METER: MeterMultipartRequest,\n            MultipartType.OFPMP_EXPERIMENTER: ExperimenterMultipartHeader\n        }\n\n        array_of_bodies = {MultipartType.OFPMP_TABLE_FEATURES: TableFeatures}\n\n        if isinstance(self.multipart_type, UBInt16):\n            self.multipart_type = self.multipart_type.enum_ref(\n                self.multipart_type.value)\n\n        pyof_class = simple_body.get(self.multipart_type, None)\n        if pyof_class:\n            return pyof_class()\n\n        array_of_class = array_of_bodies.get(self.multipart_type, None)\n        if array_of_class:\n            return FixedTypeList(pyof_class=array_of_class)\n\n        return BinaryData(b'')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npack a StatsReply using the object s attributes.", "response": "def pack(self, value=None):\n        \"\"\"Pack a StatsReply using the object's attributes.\n\n        This method will pack the attribute body and body_type before pack the\n        StatsReply object, then will return this struct as a binary data.\n\n        Returns:\n            bytes: Binary data with StatsReply packed.\n\n        \"\"\"\n        buff = self.body\n        if not value:\n            value = self.body\n\n        if value and hasattr(value, 'pack'):\n            self.body = BinaryData(value.pack())\n        stats_reply_packed = super().pack()\n\n        self.body = buff\n        return stats_reply_packed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_body_instance(self):\n        pyof_class = self._get_body_class()\n\n        if pyof_class is None:\n            return BinaryData(b'')\n        elif pyof_class is DescStats:\n            return pyof_class()\n\n        return FixedTypeList(pyof_class=pyof_class)", "response": "Return the body instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack(self, buff, offset=0):\n        super().unpack(buff, offset)\n        self.wildcards = UBInt32(value=FlowWildCards.OFPFW_ALL,\n                                 enum_ref=FlowWildCards)\n        self.wildcards.unpack(buff, offset)", "response": "Unpack the contents of the n - tuple into this object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fill_wildcards(self, field=None, value=0):\n        if field in [None, 'wildcards'] or isinstance(value, Pad):\n            return\n\n        default_value = getattr(Match, field)\n        if isinstance(default_value, IPAddress):\n            if field == 'nw_dst':\n                shift = FlowWildCards.OFPFW_NW_DST_SHIFT\n                base_mask = FlowWildCards.OFPFW_NW_DST_MASK\n            else:\n                shift = FlowWildCards.OFPFW_NW_SRC_SHIFT\n                base_mask = FlowWildCards.OFPFW_NW_SRC_MASK\n\n            # First we clear the nw_dst/nw_src mask related bits on the current\n            # wildcard by setting 0 on all of them while we keep all other bits\n            # as they are.\n            self.wildcards &= FlowWildCards.OFPFW_ALL ^ base_mask\n\n            # nw_dst and nw_src wildcard fields have 6 bits each.\n            # \"base_mask\" is the 'all ones' for those 6 bits.\n            # Once we know the netmask, we can calculate the these 6 bits\n            # wildcard value and reverse them in order to insert them at the\n            # correct position in self.wildcards\n            wildcard = (value.max_prefix - value.netmask) << shift\n            self.wildcards |= wildcard\n        else:\n            wildcard_field = \"OFPFW_{}\".format(field.upper())\n            wildcard = getattr(FlowWildCards, wildcard_field)\n\n            if value == default_value and not (self.wildcards & wildcard) or \\\n               value != default_value and (self.wildcards & wildcard):\n                self.wildcards ^= wildcard", "response": "This method updates the wildcard attribute of the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npack the value as a binary representation.", "response": "def pack(self, value=None):\n        \"\"\"Pack the value as a binary representation.\n\n        Returns:\n            bytes: The binary representation.\n\n        Raises:\n            struct.error: If the value does not fit the binary format.\n\n        \"\"\"\n        if isinstance(value, type(self)):\n            return value.pack()\n        if value is None:\n            value = self._value\n        return struct.pack('!8B', *[int(v, 16) for v in value.split(':')])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunpacking a binary message into this object s attributes based on the contents of the buffer buff and update the attributes based on the results.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            Exception: If there is a struct unpacking error.\n\n        \"\"\"\n        begin = offset\n        hexas = []\n        while begin < offset + 8:\n            number = struct.unpack(\"!B\", buff[begin:begin+1])[0]\n            hexas.append(\"%.2x\" % number)\n            begin += 1\n        self._value = ':'.join(hexas)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacking the value as a binary representation.", "response": "def pack(self, value=None):\n        \"\"\"Pack the value as a binary representation.\n\n        Returns:\n            bytes: The binary representation.\n\n        Raises:\n            struct.error: If the value does not fit the binary format.\n\n        \"\"\"\n        if isinstance(value, type(self)):\n            return value.pack()\n\n        try:\n            if value is None:\n                value = self.value\n            packed = struct.pack(self._fmt, bytes(value, 'ascii'))\n            return packed[:-1] + b'\\0'  # null-terminated\n        except struct.error as err:\n            msg = \"Char Pack error. \"\n            msg += \"Class: {}, struct error: {} \".format(type(value).__name__,\n                                                         err)\n            raise exceptions.PackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunpack a binary message into this object s attributes based on the contents of the buffer buff.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            Exception: If there is a struct unpacking error.\n\n        \"\"\"\n        try:\n            begin = offset\n            end = begin + self.length\n            unpacked_data = struct.unpack(self._fmt, buff[begin:end])[0]\n        except struct.error:\n            raise Exception(\"%s: %s\" % (offset, buff))\n\n        self._value = unpacked_data.decode('ascii').rstrip('\\0')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack(self, buff, offset=0):\n        try:\n            unpacked_data = struct.unpack('!4B', buff[offset:offset+4])\n            self._value = '.'.join([str(x) for x in unpacked_data])\n        except struct.error as exception:\n            raise exceptions.UnpackException('%s; %s: %s' % (exception,\n                                                             offset, buff))", "response": "Unpack a binary message into this object s attributes based on the contents of the buffer buff and update the object s attributes based on the results."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pack(self, value=None):\n        if isinstance(value, type(self)):\n            return value.pack()\n\n        if value is None:\n            value = self._value\n\n        if value == 0:\n            value = '00:00:00:00:00:00'\n\n        value = value.split(':')\n\n        try:\n            return struct.pack('!6B', *[int(x, 16) for x in value])\n        except struct.error as err:\n            msg = \"HWAddress error. \"\n            msg += \"Class: {}, struct error: {} \".format(type(value).__name__,\n                                                         err)\n            raise exceptions.PackException(msg)", "response": "Pack the value as a binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunpack a binary message into this object s attributes based on the contents of the buffer buff and update the attributes based on the results.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            Exception: If there is a struct unpacking error.\n\n        \"\"\"\n        def _int2hex(number):\n            return \"{0:0{1}x}\".format(number, 2)\n\n        try:\n            unpacked_data = struct.unpack('!6B', buff[offset:offset+6])\n        except struct.error as exception:\n            raise exceptions.UnpackException('%s; %s: %s' % (exception,\n                                                             offset, buff))\n\n        transformed_data = ':'.join([_int2hex(x) for x in unpacked_data])\n        self._value = transformed_data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pack(self, value=None):\n        if value is None:\n            value = self._value\n\n        if hasattr(value, 'pack') and callable(value.pack):\n            return value.pack()\n        elif isinstance(value, bytes):\n            return value\n        elif value is None:\n            return b''\n        else:\n            raise ValueError(f\"BinaryData can't be {type(value)} = '{value}'\")", "response": "Pack the value as a binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_size(self, value=None):\n        if value is None:\n            value = self._value\n\n        if hasattr(value, 'get_size'):\n            return value.get_size()\n\n        return len(self.pack(value))", "response": "Return the size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npacks the value as a binary representation.", "response": "def pack(self, value=None):\n        \"\"\"Pack the value as a binary representation.\n\n        Returns:\n            bytes: The binary representation.\n\n        \"\"\"\n        if isinstance(value, type(self)):\n            return value.pack()\n\n        if value is None:\n            value = self\n        else:\n            container = type(self)(items=None)\n            container.extend(value)\n            value = container\n\n        bin_message = b''\n        try:\n            for item in value:\n                bin_message += item.pack()\n            return bin_message\n        except exceptions.PackException as err:\n            msg = \"{} pack error: {}\".format(type(self).__name__, err)\n            raise exceptions.PackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack(self, buff, item_class, offset=0):\n        begin = offset\n        limit_buff = len(buff)\n\n        while begin < limit_buff:\n            item = item_class()\n            item.unpack(buff, begin)\n            self.append(item)\n            begin += item.get_size()", "response": "Unpack the elements of the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_size(self, value=None):\n        if value is None:\n            if not self:\n                # If this is a empty list, then returns zero\n                return 0\n            elif issubclass(type(self[0]), GenericType):\n                # If the type of the elements is GenericType, then returns the\n                # length of the list multiplied by the size of the GenericType.\n                return len(self) * self[0].get_size()\n\n            # Otherwise iter over the list accumulating the sizes.\n            return sum(item.get_size() for item in self)\n\n        return type(self)(value).get_size()", "response": "Return the size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending one item to the list.", "response": "def append(self, item):\n        \"\"\"Append one item to the list.\n\n        Args:\n            item: Item to be appended. Its type must match the one defined in\n                the constructor.\n\n        Raises:\n            :exc:`~.exceptions.WrongListItemType`: If the item has a different\n                type than the one specified in the constructor.\n\n        \"\"\"\n        if isinstance(item, list):\n            self.extend(item)\n        elif issubclass(item.__class__, self._pyof_class):\n            list.append(self, item)\n        else:\n            raise exceptions.WrongListItemType(item.__class__.__name__,\n                                               self._pyof_class.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts an item at the specified index.", "response": "def insert(self, index, item):\n        \"\"\"Insert an item at the specified index.\n\n        Args:\n            index (int): Position to insert the item.\n            item: Item to be inserted. It must have the type specified in the\n                constructor.\n\n        Raises:\n            :exc:`~.exceptions.WrongListItemType`: If the item has a different\n                type than the one specified in the constructor.\n\n        \"\"\"\n        if issubclass(item.__class__, self._pyof_class):\n            list.insert(self, index, item)\n        else:\n            raise exceptions.WrongListItemType(item.__class__.__name__,\n                                               self._pyof_class.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunpack the elements of the list.", "response": "def unpack(self, buff, offset=0):  # pylint: disable=arguments-differ\n        \"\"\"Unpack the elements of the list.\n\n        This unpack method considers that all elements have the same size.\n        To use this class with a pyof_class that accepts elements with\n        different sizes, you must reimplement the unpack method.\n\n        Args:\n            buff (bytes): The binary data to be unpacked.\n            offset (int): If we need to shift the beginning of the data.\n        \"\"\"\n        super().unpack(buff, self._pyof_class, offset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nappends one item to the list.", "response": "def append(self, item):\n        \"\"\"Append one item to the list.\n\n        Args:\n            item: Item to be appended.\n\n        Raises:\n            :exc:`~.exceptions.WrongListItemType`: If an item has a different\n                type than the first item to be stored.\n\n        \"\"\"\n        if isinstance(item, list):\n            self.extend(item)\n        elif not self:\n            list.append(self, item)\n        elif item.__class__ == self[0].__class__:\n            list.append(self, item)\n        else:\n            raise exceptions.WrongListItemType(item.__class__.__name__,\n                                               self[0].__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts an item at the specified index.", "response": "def insert(self, index, item):\n        \"\"\"Insert an item at the specified index.\n\n        Args:\n            index (int): Position to insert the item.\n            item: Item to be inserted.\n\n        Raises:\n            :exc:`~.exceptions.WrongListItemType`: If an item has a different\n                type than the first item to be stored.\n\n        \"\"\"\n        if not self:\n            list.append(self, item)\n        elif item.__class__ == self[0].__class__:\n            list.insert(self, index, item)\n        else:\n            raise exceptions.WrongListItemType(item.__class__.__name__,\n                                               self[0].__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_size(self, value=None):\n        if isinstance(value, ActionHeader):\n            return value.get_size()\n        elif value is None:\n            current_size = super().get_size()\n            return ceil(current_size / 8) * 8\n        raise ValueError(f'Invalid value \"{value}\" for Action*.get_size()')", "response": "Return the action length including the padding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npacking this structure updating the length and padding it.", "response": "def pack(self, value=None):\n        \"\"\"Pack this structure updating the length and padding it.\"\"\"\n        self._update_length()\n        packet = super().pack()\n        return self._complete_last_byte(packet)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the length field of the struct.", "response": "def _update_length(self):\n        \"\"\"Update the length field of the struct.\"\"\"\n        action_length = 4 + len(self.field.pack())\n        overflow = action_length % 8\n        self.length = action_length\n        if overflow:\n            self.length = action_length + 8 - overflow"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack(self, buff, offset=0):\n        super().unpack(buff, offset)\n        if not self.is_valid():\n            raise UnpackException(\"Unsupported protocols in ARP packet\")", "response": "Unpack a binary struct into this object s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npack the instance into a binary representation.", "response": "def pack(self, value=None):\n        \"\"\"Pack the struct in a binary representation.\n\n        Merge some fields to ensure correct packing.\n\n        If no arguments are set for a particular instance, it is interpreted as\n        abscence of VLAN information, and the pack() method will return an\n        empty binary string.\n\n        Returns:\n            bytes: Binary representation of this instance.\n\n        \"\"\"\n        if isinstance(value, type(self)):\n            return value.pack()\n\n        if self.pcp is None and self.cfi is None and self.vid is None:\n            return b''\n        self.pcp = self.pcp if self.pcp is not None else 0\n        self.cfi = self.cfi if self.cfi is not None else 0\n        self.vid = self.vid if self.vid is not None else 0\n        self._tci = self.pcp << 13 | self.cfi << 12 | self.vid\n        return super().pack()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate(self):\n        if self.tpid.value not in (EtherType.VLAN, EtherType.VLAN_QINQ):\n            raise UnpackException\n        return", "response": "Assure this is a valid VLAN header instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunpacking a binary struct into this object s attributes.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary struct into this object's attributes.\n\n        Return the values instead of the lib's basic types.\n\n        After unpacking, the abscence of a `tpid` value causes the assignment\n        of None to the field values to indicate that there is no VLAN\n        information.\n\n        Args:\n            buff (bytes): Binary buffer.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            :exc:`~.exceptions.UnpackException`: If unpack fails.\n\n        \"\"\"\n        super().unpack(buff, offset)\n        if self.tpid.value:\n            self._validate()\n            self.tpid = self.tpid.value\n            self.pcp = self._tci.value >> 13\n            self.cfi = (self._tci.value >> 12) & 1\n            self.vid = self._tci.value & 4095\n        else:\n            self.tpid = EtherType.VLAN\n            self.pcp = None\n            self.cfi = None\n            self.vid = None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the total length of VLAN tags in a given Ethernet buffer.", "response": "def _get_vlan_length(buff):\n        \"\"\"Return the total length of VLAN tags in a given Ethernet buffer.\"\"\"\n        length = 0\n        begin = 12\n\n        while(buff[begin:begin+2] in (EtherType.VLAN.to_bytes(2, 'big'),\n                                      EtherType.VLAN_QINQ.to_bytes(2, 'big'))):\n            length += 4\n            begin += 4\n\n        return length"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunpacks a binary message into this object s attributes based on the attributes found in the Ethernet headers.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary message into this object's attributes.\n\n        Unpack the binary value *buff* and update this object attributes based\n        on the results.\n\n        Ethernet headers may have VLAN tags. If no VLAN tag is found, a\n        'wildcard VLAN tag' is inserted to assure correct unpacking.\n\n        Args:\n            buff (bytes): Binary data package to be unpacked.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            UnpackException: If there is a struct unpacking error.\n\n        \"\"\"\n        begin = offset\n\n        vlan_length = self._get_vlan_length(buff)\n\n        for attribute_name, class_attribute in self.get_class_attributes():\n            attribute = deepcopy(class_attribute)\n            if attribute_name == 'vlans':\n                attribute.unpack(buff[begin:begin+vlan_length])\n            else:\n                attribute.unpack(buff, begin)\n            setattr(self, attribute_name, attribute)\n            begin += attribute.get_size()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pack(self, value=None):\n        if value is None:\n            output = self.header.pack()\n            output += self.value.pack()\n            return output\n\n        elif isinstance(value, type(self)):\n            return value.pack()\n        else:\n            msg = \"{} is not an instance of {}\".format(value,\n                                                       type(self).__name__)\n            raise PackException(msg)", "response": "Pack the TLV in a binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack(self, buff, offset=0):\n        header = UBInt16()\n        header.unpack(buff[offset:offset+2])\n        self.tlv_type = header.value >> 9\n        length = header.value & 511\n        begin, end = offset + 2, offset + 2 + length\n        self._value = BinaryData(buff[begin:end])", "response": "Unpack a binary message into this object s attributes based on the contents of the buffer buff and update the attributes based on the results."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_size(self, value=None):\n        if isinstance(value, type(self)):\n            return value.get_size()\n\n        return 2 + self.length", "response": "Returns the size of the structure based on inner attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the checksum to enable integrity check.", "response": "def _update_checksum(self):\n        \"\"\"Update the packet checksum to enable integrity check.\"\"\"\n        source_list = [int(octet) for octet in self.source.split(\".\")]\n        destination_list = [int(octet) for octet in\n                            self.destination.split(\".\")]\n        source_upper = (source_list[0] << 8) + source_list[1]\n        source_lower = (source_list[2] << 8) + source_list[3]\n        destination_upper = (destination_list[0] << 8) + destination_list[1]\n        destination_lower = (destination_list[2] << 8) + destination_list[3]\n\n        block_sum = ((self._version_ihl << 8 | self._dscp_ecn) + self.length +\n                     self.identification + self._flags_offset +\n                     (self.ttl << 8 | self.protocol) + source_upper +\n                     source_lower + destination_upper + destination_lower)\n\n        while block_sum > 65535:\n            carry = block_sum >> 16\n            block_sum = (block_sum & 65535) + carry\n\n        self.checksum = ~block_sum & 65535"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pack(self, value=None):\n        # Set the correct IHL based on options size\n        if self.options:\n            self.ihl += int(len(self.options) / 4)\n\n        # Set the correct packet length based on header length and data\n        self.length = int(self.ihl * 4 + len(self.data))\n\n        self._version_ihl = self.version << 4 | self.ihl\n        self._dscp_ecn = self.dscp << 2 | self.ecn\n        self._flags_offset = self.flags << 13 | self.offset\n\n        # Set the checksum field before packing\n        self._update_checksum()\n\n        return super().pack()", "response": "Pack the structure into a binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunpacking a binary struct into this object s attributes.", "response": "def unpack(self, buff, offset=0):\n        \"\"\"Unpack a binary struct into this object's attributes.\n\n        Return the values instead of the lib's basic types.\n\n        Args:\n            buff (bytes): Binary buffer.\n            offset (int): Where to begin unpacking.\n\n        Raises:\n            :exc:`~.exceptions.UnpackException`: If unpack fails.\n\n        \"\"\"\n        super().unpack(buff, offset)\n\n        self.version = self._version_ihl.value >> 4\n        self.ihl = self._version_ihl.value & 15\n        self.dscp = self._dscp_ecn.value >> 2\n        self.ecn = self._dscp_ecn.value & 3\n        self.length = self.length.value\n        self.identification = self.identification.value\n        self.flags = self._flags_offset.value >> 13\n        self.offset = self._flags_offset.value & 8191\n        self.ttl = self.ttl.value\n        self.protocol = self.protocol.value\n        self.checksum = self.checksum.value\n        self.source = self.source.value\n        self.destination = self.destination.value\n\n        if self.ihl > 5:\n            options_size = (self.ihl - 5) * 4\n            self.data = self.options.value[options_size:]\n            self.options = self.options.value[:options_size]\n        else:\n            self.data = self.options.value\n            self.options = b''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning sub type and sub value as binary data.", "response": "def value(self):\n        \"\"\"Return sub type and sub value as binary data.\n\n        Returns:\n            :class:`~pyof.foundation.basic_types.BinaryData`:\n                BinaryData calculated.\n\n        \"\"\"\n        binary = UBInt8(self.sub_type).pack() + self.sub_value.pack()\n        return BinaryData(binary)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unpack(self, buff, offset=0):\n        header = UBInt16()\n        header.unpack(buff[offset:offset+2])\n        self.tlv_type = header.value >> 9\n        length = header.value & 511\n        begin, end = offset + 2, offset + 2 + length\n        sub_type = UBInt8()\n        sub_type.unpack(buff[begin:begin+1])\n        self.sub_type = sub_type.value\n        self.sub_value = BinaryData(buff[begin+1:end])", "response": "Unpack a binary message into this object s attributes based on the results."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if packet is valid OF packet. Raises UnpackException if the packet is invalid.", "response": "def validate_packet(packet):\n    \"\"\"Check if packet is valid OF packet.\n\n    Raises:\n        UnpackException: If the packet is invalid.\n\n    \"\"\"\n    if not isinstance(packet, bytes):\n        raise UnpackException('invalid packet')\n\n    packet_length = len(packet)\n\n    if packet_length < 8 or packet_length > 2**16:\n        raise UnpackException('invalid packet')\n\n    if packet_length != int.from_bytes(packet[2:4], byteorder='big'):\n        raise UnpackException('invalid packet')\n\n    version = packet[0]\n    if version == 0 or version >= 128:\n        raise UnpackException('invalid packet')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack(packet):\n    validate_packet(packet)\n\n    version = packet[0]\n    try:\n        pyof_lib = PYOF_VERSION_LIBS[version]\n    except KeyError:\n        raise UnpackException('Version not supported')\n\n    try:\n        message = pyof_lib.common.utils.unpack_message(packet)\n        return message\n    except (UnpackException, ValueError) as exception:\n        raise UnpackException(exception)", "response": "Unpack the OpenFlow Packet and returns a GenericMessage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_class(self):\n        classes = {'OFPET_HELLO_FAILED': HelloFailedCode,\n                   'OFPET_BAD_REQUEST': BadRequestCode,\n                   'OFPET_BAD_ACTION': BadActionCode,\n                   'OFPET_BAD_INSTRUCTION': BadInstructionCode,\n                   'OFPET_BAD_MATCH': BadMatchCode,\n                   'OFPET_FLOW_MOD_FAILED': FlowModFailedCode,\n                   'OFPET_GROUP_MOD_FAILED': GroupModFailedCode,\n                   'OFPET_PORT_MOD_FAILED': PortModFailedCode,\n                   'OFPET_QUEUE_OP_FAILED': QueueOpFailedCode,\n                   'OFPET_SWITCH_CONFIG_FAILED': SwitchConfigFailedCode,\n                   'OFPET_ROLE_REQUEST_FAILED': RoleRequestFailedCode,\n                   'OFPET_METER_MOD_FAILED': MeterModFailedCode,\n                   'OFPET_TABLE_MOD_FAILED': TableModFailedCode,\n                   'OFPET_TABLE_FEATURES_FAILED': TableFeaturesFailedCode}\n        return classes.get(self.name, GenericFailedCode)", "response": "Return a Code class based on current ErrorType value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unpack(self, buff, offset=0):\n        super().unpack(buff, offset)\n        code_class = ErrorType(self.error_type).get_class()\n        self.code = code_class(self.code)", "response": "Unpack binary data into python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Code class based on current ErrorType value.", "response": "def get_class(self):\n        \"\"\"Return a Code class based on current ErrorType value.\n\n        Returns:\n            enum.IntEnum: class referenced by current error type.\n\n        \"\"\"\n        classes = {'OFPET_HELLO_FAILED': HelloFailedCode,\n                   'OFPET_BAD_REQUEST': BadRequestCode,\n                   'OFPET_BAD_ACTION': BadActionCode,\n                   'OFPET_FLOW_MOD_FAILED': FlowModFailedCode,\n                   'OFPET_PORT_MOD_FAILED': PortModFailedCode,\n                   'OFPET_QUEUE_OP_FAILED': QueueOpFailedCode}\n        return classes.get(self.name, GenericFailedCode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npacking the value as a binary representation.", "response": "def pack(self, value=None):\n        \"\"\"Pack the value as a binary representation.\n\n        :attr:`data` is packed before the calling :meth:`.GenericMessage.pack`.\n        After that, :attr:`data`'s value is restored.\n\n        Returns:\n            bytes: The binary representation.\n\n        Raises:\n            :exc:`~.exceptions.PackException`: If pack fails.\n\n        \"\"\"\n        if value is None:\n            data_backup = None\n            if self.data is not None and not isinstance(self.data, bytes):\n                data_backup = self.data\n                self.data = self.data.pack()\n            packed = super().pack()\n            if data_backup is not None:\n                self.data = data_backup\n            return packed\n        elif isinstance(value, type(self)):\n            return value.pack()\n        else:\n            msg = \"{} is not an instance of {}\".format(value,\n                                                       type(self).__name__)\n            raise PackException(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _createAction(self, widget, iconFileName, text, shortcut, slot):\n        icon = qutepart.getIcon(iconFileName)\n        action = QAction(icon, text, widget)\n        action.setShortcut(QKeySequence(shortcut))\n        action.setShortcutContext(Qt.WidgetShortcut)\n        action.triggered.connect(slot)\n\n        widget.addAction(action)\n\n        return action", "response": "Create QAction with given parameters and add to the widget\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears bookmarks on a range including start and endBlock.", "response": "def clear(self, startBlock, endBlock):\n        \"\"\"Clear bookmarks on block range including start and end\n        \"\"\"\n        for block in qutepart.iterateBlocksFrom(startBlock):\n            self._setBlockMarked(block, False)\n            if block == endBlock:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntraversing document forward. Yield block columnIndex char", "response": "def _iterateDocumentCharsForward(self, block, startColumnIndex):\n        \"\"\"Traverse document forward. Yield (block, columnIndex, char)\n        Raise _TimeoutException if time is over\n        \"\"\"\n        # Chars in the start line\n        endTime = time.time() + self._MAX_SEARCH_TIME_SEC\n        for columnIndex, char in list(enumerate(block.text()))[startColumnIndex:]:\n            yield block, columnIndex, char\n        block = block.next()\n\n        # Next lines\n        while block.isValid():\n            for columnIndex, char in enumerate(block.text()):\n                yield block, columnIndex, char\n\n            if time.time() > endTime:\n                raise _TimeoutException('Time is over')\n\n            block = block.next()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntraverse document forward. Yield block columnIndex char", "response": "def _iterateDocumentCharsBackward(self, block, startColumnIndex):\n        \"\"\"Traverse document forward. Yield (block, columnIndex, char)\n        Raise _TimeoutException if time is over\n        \"\"\"\n        # Chars in the start line\n        endTime = time.time() + self._MAX_SEARCH_TIME_SEC\n        for columnIndex, char in reversed(list(enumerate(block.text()[:startColumnIndex]))):\n            yield block, columnIndex, char\n        block = block.previous()\n\n        # Next lines\n        while block.isValid():\n            for columnIndex, char in reversed(list(enumerate(block.text()))):\n                yield block, columnIndex, char\n\n            if time.time() > endTime:\n                raise _TimeoutException('Time is over')\n\n            block = block.previous()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _findMatchingBracket(self, bracket, qpart, block, columnIndex):\n        if bracket in self._START_BRACKETS:\n            charsGenerator = self._iterateDocumentCharsForward(block, columnIndex + 1)\n        else:\n            charsGenerator = self._iterateDocumentCharsBackward(block, columnIndex)\n\n        depth = 1\n        oposite = self._OPOSITE_BRACKET[bracket]\n        for block, columnIndex, char in charsGenerator:\n            if qpart.isCode(block, columnIndex):\n                if char == oposite:\n                    depth -= 1\n                    if depth == 0:\n                        return block, columnIndex\n                elif char == bracket:\n                    depth += 1\n        else:\n            return None, None", "response": "Find the matching bracket for the column."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _makeMatchSelection(self, block, columnIndex, matched):\n        selection = QTextEdit.ExtraSelection()\n\n        if matched:\n            bgColor = Qt.green\n        else:\n            bgColor = Qt.red\n\n        selection.format.setBackground(bgColor)\n        selection.cursor = QTextCursor(block)\n        selection.cursor.setPosition(block.position() + columnIndex)\n        selection.cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor)\n\n        return selection", "response": "Make matched or unmatched QTextEdit. ExtraSelection\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _highlightBracket(self, bracket, qpart, block, columnIndex):\n        try:\n            matchedBlock, matchedColumnIndex = self._findMatchingBracket(bracket, qpart, block, columnIndex)\n        except _TimeoutException:  # not found, time is over\n            return[] # highlight nothing\n\n        if matchedBlock is not None:\n            self.currentMatchedBrackets = ((block, columnIndex), (matchedBlock, matchedColumnIndex))\n            return [self._makeMatchSelection(block, columnIndex, True),\n                    self._makeMatchSelection(matchedBlock, matchedColumnIndex, True)]\n        else:\n            self.currentMatchedBrackets = None\n            return [self._makeMatchSelection(block, columnIndex, False)]", "response": "Highlights a bracket and matching bracket\n            returns tuple of QTextEdit. ExtraSelection s\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists of QTextEdit. ExtraSelection s which highlight brackets", "response": "def extraSelections(self, qpart, block, columnIndex):\n        \"\"\"List of QTextEdit.ExtraSelection's, which highlighte brackets\n        \"\"\"\n        blockText = block.text()\n\n        if columnIndex < len(blockText) and \\\n             blockText[columnIndex] in self._ALL_BRACKETS and \\\n             qpart.isCode(block, columnIndex):\n            return self._highlightBracket(blockText[columnIndex], qpart, block, columnIndex)\n        elif columnIndex > 0 and \\\n           blockText[columnIndex - 1] in self._ALL_BRACKETS and \\\n           qpart.isCode(block, columnIndex - 1):\n            return self._highlightBracket(blockText[columnIndex - 1], qpart, block, columnIndex - 1)\n        else:\n            self.currentMatchedBrackets = None\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if character at column is a code", "response": "def isCode(self, block, column):\n        \"\"\"Check if character at column is a a code\n        \"\"\"\n        dataObject = block.userData()\n        data = dataObject.data if dataObject is not None else None\n        return self._syntax.isCode(data, column)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isComment(self, block, column):\n        dataObject = block.userData()\n        data = dataObject.data if dataObject is not None else None\n        return self._syntax.isComment(data, column)", "response": "Check if character at column is a comment."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isBlockComment(self, block, column):\n        dataObject = block.userData()\n        data = dataObject.data if dataObject is not None else None\n        return self._syntax.isBlockComment(data, column)", "response": "Check if character at column is a block comment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if character at column is a here document.", "response": "def isHereDoc(self, block, column):\n        \"\"\"Check if character at column is a here document\n        \"\"\"\n        dataObject = block.userData()\n        data = dataObject.data if dataObject is not None else None\n        return self._syntax.isHereDoc(data, column)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _highlighBlocks(self, fromBlock, atLeastUntilBlock, timeout):\n        endTime = time.time() + timeout\n\n        block = fromBlock\n        lineData = self._lineData(block.previous())\n\n        while block.isValid() and block != atLeastUntilBlock:\n            if time.time() >= endTime:  # time is over, schedule parsing later and release event loop\n                self._pendingBlockNumber = block.blockNumber()\n                self._pendingAtLeastUntilBlockNumber = atLeastUntilBlock.blockNumber()\n                self._globalTimer.scheduleCallback(self._onContinueHighlighting)\n                return\n\n            contextStack = lineData[0] if lineData is not None else None\n            if block.length() < 4096:\n                lineData, highlightedSegments = self._syntax.highlightBlock(block.text(), contextStack)\n            else:\n                \"\"\"Parser freezes for a long time, if line is too long\n                invalid parsing results are still better, than freeze\n                \"\"\"\n                lineData, highlightedSegments = None, []\n            if lineData is not None:\n                block.setUserData(_TextBlockUserData(lineData))\n            else:\n                block.setUserData(None)\n\n            self._applyHighlightedSegments(block, highlightedSegments)\n            block = block.next()\n\n        # reached atLeastUntilBlock, now parse next only while data changed\n        prevLineData = self._lineData(block)\n        while block.isValid():\n            if time.time() >= endTime:  # time is over, schedule parsing later and release event loop\n                self._pendingBlockNumber = block.blockNumber()\n                self._pendingAtLeastUntilBlockNumber = atLeastUntilBlock.blockNumber()\n                self._globalTimer.scheduleCallback(self._onContinueHighlighting)\n                return\n            contextStack = lineData[0] if lineData is not None else None\n            lineData, highlightedSegments = self._syntax.highlightBlock(block.text(), contextStack)\n            if lineData is not None:\n                block.setUserData(_TextBlockUserData(lineData))\n            else:\n                block.setUserData(None)\n\n            self._applyHighlightedSegments(block, highlightedSegments)\n            if prevLineData == lineData:\n                break\n\n            block = block.next()\n            prevLineData = self._lineData(block)\n\n        # sucessfully finished, reset pending tasks\n        self._pendingBlockNumber = None\n        self._pendingAtLeastUntilBlockNumber = None\n\n        \"\"\"Emit sizeChanged when highlighting finished, because document size might change.\n        See andreikop/enki issue #191\n        \"\"\"\n        documentLayout = self._textEdit.document().documentLayout()\n        documentLayout.documentSizeChanged.emit(documentLayout.documentSize())", "response": "Highlighs the blocks in the given block until the given time."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef computeSmartIndent(self, block, ch):\n        if re.search(r'^\\s*;;;', block.text()):\n            return ''\n        elif re.search(r'^\\s*;;', block.text()):\n            #try to align with the next line\n            nextBlock = self._nextNonEmptyBlock(block)\n            if nextBlock.isValid():\n                return self._blockIndent(nextBlock)\n\n        try:\n            foundBlock, foundColumn = self.findBracketBackward(block, 0, '(')\n        except ValueError:\n            return ''\n        else:\n            return self._increaseIndent(self._blockIndent(foundBlock))", "response": "computeSmartIndent - computes the indentation of a single line of code"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _atomicModification(func):\n        def wrapper(*args, **kwargs):\n            self = args[0]\n            with self._qpart:\n                func(*args, **kwargs)\n        return wrapper", "response": "Decorator for making document modification atomic"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking integer index convert from less than zero notation", "response": "def _checkAndConvertIndex(self, index):\n        \"\"\"Check integer index, convert from less than zero notation\n        \"\"\"\n        if index < 0:\n            index = len(self) + index\n        if index < 0 or index >= self._doc.blockCount():\n            raise IndexError('Invalid block index', index)\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef append(self, text):\n        cursor = QTextCursor(self._doc)\n        cursor.movePosition(QTextCursor.End)\n        cursor.insertBlock()\n        cursor.insertText(text)", "response": "Append text to the end of the document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninsert a line to the document.", "response": "def insert(self, index, text):\n        \"\"\"Insert line to the document\n        \"\"\"\n        if index < 0 or index > self._doc.blockCount():\n            raise IndexError('Invalid block index', index)\n\n        if index == 0:  # first\n            cursor = QTextCursor(self._doc.firstBlock())\n            cursor.insertText(text)\n            cursor.insertBlock()\n        elif index != self._doc.blockCount():  # not the last\n            cursor = QTextCursor(self._doc.findBlockByNumber(index).previous())\n            cursor.movePosition(QTextCursor.EndOfBlock)\n            cursor.insertBlock()\n            cursor.insertText(text)\n        else:  # last append to the end\n            self.append(text)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the indentation for the block.", "response": "def computeSmartIndent(self, block, char):\n        \"\"\"Compute indent for the block\n        \"\"\"\n        lineText = block.text()\n        prevLineText = self._prevNonEmptyBlock(block).text()\n\n        alignOnly = char == ''\n\n        if alignOnly:\n            # XML might be all in one line, in which case we want to break that up.\n            tokens = re.split(r'>\\s*<', lineText)\n\n            if len(tokens) > 1:\n\n                prevIndent = self._lineIndent(prevLineText)\n\n                for index, newLine in enumerate(tokens):\n                    if index > 0:\n                        newLine = '<' + newLine\n\n                    if index < len(tokens) - 1:\n                        newLine = newLine + '>'\n                    if re.match(r'^\\s*</', newLine):\n                        char = '/'\n                    elif re.match(r'\\\\>[^<>]*$', newLine):\n                        char = '>'\n                    else:\n                        char = '\\n'\n\n                    indentation = self.processChar(newLine, prevLineText, char)\n                    newLine = indentation + newLine\n\n                    tokens[index] = newLine\n                    prevLineText = newLine;\n\n                self._qpart.lines[block.blockNumber()] =  '\\n'.join(tokens)\n                return None\n            else:  # no tokens, do not split line, just compute indent\n                if re.search(r'^\\s*</', lineText):\n                    char = '/'\n                elif re.search(r'>[^<>]*', lineText):\n                    char = '>'\n                else:\n                    char = '\\n'\n\n        return self.processChar(lineText, prevLineText, char)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _prevNonCommentBlock(self, block):\n        block = self._prevNonEmptyBlock(block)\n        while block.isValid() and self._isCommentBlock(block):\n            block = self._prevNonEmptyBlock(block)\n        return block", "response": "Return the closest non - empty line ignoring comments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _isLastCodeColumn(self, block, column):\n        return column >= self._lastColumn(block) or \\\n               self._isComment(block, self._nextNonSpaceColumn(block, column + 1))", "response": "Return true if the given column is at least equal to the last non - whitespace character at the given line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the last open bracket before the current line. Return None if no bracket was found.", "response": "def lastAnchor(self, block, column):\n        \"\"\"Find the last open bracket before the current line.\n        Return (block, column, char) or (None, None, None)\n        \"\"\"\n        currentPos = -1\n        currentBlock = None\n        currentColumn = None\n        currentChar = None\n        for char in '({[':\n            try:\n                foundBlock, foundColumn = self.findBracketBackward(block, column, char)\n            except ValueError:\n                continue\n            else:\n                pos = foundBlock.position() + foundColumn\n                if pos > currentPos:\n                    currentBlock = foundBlock\n                    currentColumn = foundColumn\n                    currentChar = char\n                    currentPos = pos\n\n        return currentBlock, currentColumn, currentChar"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the first line that is not preceded by a continuing line. Return the first line that is not preceded by a continuing line.", "response": "def findStmtStart(self, block):\n        \"\"\"Return the first line that is not preceded by a \"continuing\" line.\n        Return currBlock if currBlock <= 0\n        \"\"\"\n        prevBlock = self._prevNonCommentBlock(block)\n        while prevBlock.isValid() and \\\n              (((prevBlock == block.previous()) and self._isBlockContinuing(prevBlock)) or \\\n               self.isStmtContinuing(prevBlock)):\n            block = prevBlock\n            prevBlock = self._prevNonCommentBlock(block)\n        return block"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _isValidTrigger(block, ch):\n        if ch == \"\" or ch == \"\\n\":\n            return True # Explicit align or new line\n\n        match = rxUnindent.match(block.text())\n        return match is not None and \\\n               match.group(3) == \"\"", "response": "check if the trigger characters are in the right context"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef findPrevStmt(self, block):\n        stmtEnd = self._prevNonCommentBlock(block)\n        stmtStart = self.findStmtStart(stmtEnd)\n        return Statement(self._qpart, stmtStart, stmtEnd)", "response": "Returns a tuple that contains the first and last line of the\n        previous statement before line."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the indentation of a single line or a single line.", "response": "def computeSmartIndent(self, block, ch):\n        \"\"\"indent gets three arguments: line, indentWidth in spaces,\n        typed character indent\n        \"\"\"\n        if not self._isValidTrigger(block, ch):\n            return None\n\n        prevStmt = self.findPrevStmt(block)\n        if not prevStmt.endBlock.isValid():\n            return None  # Can't indent the first line\n\n        prevBlock = self._prevNonEmptyBlock(block)\n\n        # HACK Detect here documents\n        if self._qpart.isHereDoc(prevBlock.blockNumber(), prevBlock.length() - 2):\n          return None\n\n        # HACK Detect embedded comments\n        if self._qpart.isBlockComment(prevBlock.blockNumber(), prevBlock.length() - 2):\n            return None\n\n        prevStmtCnt = prevStmt.content()\n        prevStmtInd = prevStmt.indent()\n\n        # Are we inside a parameter list, array or hash?\n        foundBlock, foundColumn, foundChar = self.lastAnchor(block, 0)\n        if foundBlock is not None:\n            shouldIndent = foundBlock == prevStmt.endBlock or \\\n                           self.testAtEnd(prevStmt, re.compile(',\\s*'))\n            if (not self._isLastCodeColumn(foundBlock, foundColumn)) or \\\n                self.lastAnchor(foundBlock, foundColumn)[0] is not None:\n                # TODO This is alignment, should force using spaces instead of tabs:\n                if shouldIndent:\n                    foundColumn += 1\n                    nextCol = self._nextNonSpaceColumn(foundBlock, foundColumn)\n                    if nextCol > 0 and \\\n                       (not self._isComment(foundBlock, nextCol)):\n                        foundColumn = nextCol\n\n                # Keep indent of previous statement, while aligning to the anchor column\n                if len(prevStmtInd) > foundColumn:\n                    return prevStmtInd\n                else:\n                    return self._makeIndentAsColumn(foundBlock, foundColumn)\n            else:\n                indent = self._blockIndent(foundBlock)\n                if shouldIndent:\n                    indent = self._increaseIndent(indent)\n                return indent\n\n        # Handle indenting of multiline statements.\n        if (prevStmt.endBlock == block.previous() and \\\n             self._isBlockContinuing(prevStmt.endBlock)) or \\\n           self.isStmtContinuing(prevStmt.endBlock):\n            if prevStmt.startBlock == prevStmt.endBlock:\n                if ch == '' and \\\n                   len(self._blockIndent(block)) > len(self._blockIndent(prevStmt.endBlock)):\n                    return None  # Don't force a specific indent level when aligning manually\n                return self._increaseIndent(self._increaseIndent(prevStmtInd))\n            else:\n                return self._blockIndent(prevStmt.endBlock)\n\n        if rxUnindent.match(block.text()):\n            startStmt = self.findBlockStart(block)\n            if startStmt.startBlock.isValid():\n                return startStmt.indent()\n            else:\n                return None\n\n        if self.isBlockStart(prevStmt) and not rxBlockEnd.search(prevStmt.content()):\n            return self._increaseIndent(prevStmtInd)\n        elif re.search(r'[\\[\\{]\\s*$', prevStmtCnt) is not None:\n            return self._increaseIndent(prevStmtInd)\n\n        # Keep current\n        return prevStmtInd"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef isDeleteKeyEvent(self, keyEvent):\n        return self._start is not None and \\\n               (keyEvent.matches(QKeySequence.Delete) or \\\n                (keyEvent.key() == Qt.Key_Backspace and keyEvent.modifiers() == Qt.NoModifier))", "response": "Check if key event should be handled as Delete command"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self):\n        with self._qpart:\n            for cursor in self.cursors():\n                if cursor.hasSelection():\n                    cursor.deleteChar()", "response": "Del or Backspace pressed. Delete selection"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the given key event should expand rectangular selection", "response": "def isExpandKeyEvent(self, keyEvent):\n        \"\"\"Check if key event should expand rectangular selection\"\"\"\n        return keyEvent.modifiers() & Qt.ShiftModifier and \\\n               keyEvent.modifiers() & Qt.AltModifier and \\\n               keyEvent.key() in (Qt.Key_Left, Qt.Key_Right, Qt.Key_Down, Qt.Key_Up,\n                                  Qt.Key_PageUp, Qt.Key_PageDown, Qt.Key_Home, Qt.Key_End)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef onExpandKeyEvent(self, keyEvent):\n        if self._start is None:\n            currentBlockText = self._qpart.textCursor().block().text()\n            line = self._qpart.cursorPosition[0]\n            visibleColumn = self._realToVisibleColumn(currentBlockText, self._qpart.cursorPosition[1])\n            self._start = (line, visibleColumn)\n        modifiersWithoutAltShift = keyEvent.modifiers() & ( ~ (Qt.AltModifier | Qt.ShiftModifier))\n        newEvent = QKeyEvent(keyEvent.type(),\n                             keyEvent.key(),\n                             modifiersWithoutAltShift,\n                             keyEvent.text(),\n                             keyEvent.isAutoRepeat(),\n                             keyEvent.count())\n\n        self._qpart.cursorPositionChanged.disconnect(self._reset)\n        self._qpart.selectionChanged.disconnect(self._reset)\n        super(self._qpart.__class__, self._qpart).keyPressEvent(newEvent)\n        self._qpart.cursorPositionChanged.connect(self._reset)\n        self._qpart.selectionChanged.connect(self._reset)", "response": "One of expand selection key events"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _realToVisibleColumn(self, text, realColumn):\n        generator = self._visibleCharPositionGenerator(text)\n        for i in range(realColumn):\n            val = next(generator)\n        val = next(generator)\n        return val", "response": "This function converts real position of symbol in block to visible position"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _visibleToRealColumn(self, text, visiblePos):\n        if visiblePos == 0:\n            return 0\n        elif not '\\t' in text:\n            return visiblePos\n        else:\n            currentIndex = 1\n            for currentVisiblePos in self._visibleCharPositionGenerator(text):\n                if currentVisiblePos >= visiblePos:\n                    return currentIndex - 1\n                currentIndex += 1\n\n            return None", "response": "This function converts visible to real column."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild list of extra selections for rectangular selection", "response": "def selections(self):\n        \"\"\"Build list of extra selections for rectangular selection\"\"\"\n        selections = []\n        cursors = self.cursors()\n        if cursors:\n            background = self._qpart.palette().color(QPalette.Highlight)\n            foreground = self._qpart.palette().color(QPalette.HighlightedText)\n            for cursor in cursors:\n                selection = QTextEdit.ExtraSelection()\n                selection.format.setBackground(background)\n                selection.format.setForeground(foreground)\n                selection.cursor = cursor\n\n                selections.append(selection)\n\n        return selections"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self):\n        data = QMimeData()\n        text = '\\n'.join([cursor.selectedText() \\\n                            for cursor in self.cursors()])\n        data.setText(text)\n        data.setData(self.MIME_TYPE, text.encode('utf8'))\n        QApplication.clipboard().setMimeData(data)", "response": "Copy to the clipboard"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncutting the cursor and delete the current entry", "response": "def cut(self):\n        \"\"\"Cut action. Copy and delete\n        \"\"\"\n        cursorPos = self._qpart.cursorPosition\n        topLeft = (min(self._start[0], cursorPos[0]),\n                   min(self._start[1], cursorPos[1]))\n        self.copy()\n        self.delete()\n\n        \"\"\"Move cursor to top-left corner of the selection,\n        so that if text gets pasted again, original text will be restored\"\"\"\n        self._qpart.cursorPosition = topLeft"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _indentUpTo(self, text, width):\n        visibleTextWidth = self._realToVisibleColumn(text, len(text))\n        diff = width - visibleTextWidth\n        if diff <= 0:\n            return ''\n        elif self._qpart.indentUseTabs and \\\n           all([char == '\\t' for char in text]):  # if using tabs and only tabs in text\n            return '\\t' * (diff // self._qpart.indentWidth) + \\\n                   ' ' * (diff % self._qpart.indentWidth)\n        else:\n            return ' ' * int(diff)", "response": "Add space to text so text width will be at least width."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npastes recrangular selection. Add space at the beginning of line, if necessary", "response": "def paste(self, mimeData):\n        \"\"\"Paste recrangular selection.\n        Add space at the beginning of line, if necessary\n        \"\"\"\n        if self.isActive():\n            self.delete()\n        elif self._qpart.textCursor().hasSelection():\n            self._qpart.textCursor().deleteChar()\n\n        text = bytes(mimeData.data(self.MIME_TYPE)).decode('utf8')\n        lines = text.splitlines()\n        cursorLine, cursorCol = self._qpart.cursorPosition\n        if cursorLine + len(lines) > len(self._qpart.lines):\n           for i in range(cursorLine + len(lines) - len(self._qpart.lines)):\n               self._qpart.lines.append('')\n\n        with self._qpart:\n            for index, line in enumerate(lines):\n                currentLine = self._qpart.lines[cursorLine + index]\n                newLine = currentLine[:cursorCol] + \\\n                          self._indentUpTo(currentLine, cursorCol) + \\\n                          line + \\\n                          currentLine[cursorCol:]\n                self._qpart.lines[cursorLine + index] = newLine\n        self._qpart.cursorPosition = cursorLine, cursorCol"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __allocateBits(self):\n        if self._bit_count < 0:\n            raise Exception( \"A margin cannot request negative number of bits\" )\n        if self._bit_count == 0:\n            return\n\n        # Build a list of occupied ranges\n        margins = self._qpart.getMargins()\n\n        occupiedRanges = []\n        for margin in margins:\n            bitRange = margin.getBitRange()\n            if bitRange is not None:\n                # pick the right position\n                added = False\n                for index in range( len( occupiedRanges ) ):\n                    r = occupiedRanges[ index ]\n                    if bitRange[ 1 ] < r[ 0 ]:\n                        occupiedRanges.insert(index, bitRange)\n                        added = True\n                        break\n                if not added:\n                    occupiedRanges.append(bitRange)\n\n        vacant = 0\n        for r in occupiedRanges:\n            if r[ 0 ] - vacant >= self._bit_count:\n                self._bitRange = (vacant, vacant + self._bit_count - 1)\n                return\n            vacant = r[ 1 ] + 1\n        # Not allocated, i.e. grab the tail bits\n        self._bitRange = (vacant, vacant + self._bit_count - 1)", "response": "Allocates the bit range depending on the required bit count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the line number area if necessary", "response": "def __updateRequest(self, rect, dy):\n        \"\"\"Repaint line number area if necessary\n        \"\"\"\n        if dy:\n            self.scroll(0, dy)\n        elif self._countCache[0] != self._qpart.blockCount() or \\\n             self._countCache[1] != self._qpart.textCursor().block().lineCount():\n\n            # if block height not added to rect, last line number sometimes is not drawn\n            blockHeight = self._qpart.blockBoundingRect(self._qpart.firstVisibleBlock()).height()\n\n            self.update(0, rect.y(), self.width(), rect.height() + blockHeight)\n            self._countCache = (self._qpart.blockCount(), self._qpart.textCursor().block().lineCount())\n\n        if rect.contains(self._qpart.viewport().rect()):\n            self._qpart.updateViewportMargins()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the required value to the block without damaging the other bits", "response": "def setBlockValue(self, block, value):\n        \"\"\"Sets the required value to the block without damaging the other bits\n        \"\"\"\n        if self._bit_count == 0:\n            raise Exception( \"The margin '\" + self._name +\n                             \"' did not allocate any bits for the values\")\n        if value < 0:\n            raise Exception( \"The margin '\" + self._name +\n                             \"' must be a positive integer\"  )\n\n        if value >= 2 ** self._bit_count:\n            raise Exception( \"The margin '\" + self._name +\n                             \"' value exceeds the allocated bit range\" )\n\n        newMarginValue = value << self._bitRange[ 0 ]\n        currentUserState = block.userState()\n\n        if currentUserState in [ 0, -1 ]:\n            block.setUserState(newMarginValue)\n        else:\n            marginMask = 2 ** self._bit_count - 1\n            otherMarginsValue = currentUserState & ~marginMask\n            block.setUserState(newMarginValue | otherMarginsValue)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getBlockValue(self, block):\n        if self._bit_count == 0:\n            raise Exception( \"The margin '\" + self._name +\n                             \"' did not allocate any bits for the values\")\n        val = block.userState()\n        if val in [ 0, -1 ]:\n            return 0\n\n        # Shift the value to the right\n        val >>= self._bitRange[ 0 ]\n\n        # Apply the mask to the value\n        mask = 2 ** self._bit_count - 1\n        val &= mask\n        return val", "response": "Provides the previously set block value respecting the bits range."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide(self):\n        if not self.isHidden():\n            QWidget.hide(self)\n            self._qpart.updateViewport()", "response": "Override the QWidget. hide method to properly recalculate the the\n           editor viewport."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\noverrides the QWidget. show method to properly recalculate the the editor viewport.", "response": "def show(self):\n        \"\"\"Override the QWidget::show() method to properly recalculate the\n           editor viewport.\n        \"\"\"\n        if self.isHidden():\n            QWidget.show(self)\n            self._qpart.updateViewport()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\noverriding the QWidget. setVisible method to properly properly recalculate the editor viewport.", "response": "def setVisible(self, val):\n        \"\"\"Override the QWidget::setVisible(bool) method to properly\n           recalculate the editor viewport.\n        \"\"\"\n        if val != self.isVisible():\n            if val:\n                QWidget.setVisible(self, True)\n            else:\n                QWidget.setVisible(self, False)\n            self._qpart.updateViewport()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear(self):\n        if self._bit_count == 0:\n            return\n\n        block = self._qpart.document().begin()\n        while block.isValid():\n            if self.getBlockValue(block):\n                self.setBlockValue(block, 0)\n            block = block.next()", "response": "Convenience method to reset all the block values to 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting text type of the current entry in the table.", "response": "def _getTextType(self, lineData, column):\n        \"\"\"Get text type (letter)\n        \"\"\"\n        if lineData is None:\n            return ' '  # default is code\n\n        textTypeMap = lineData[1]\n        if column >= len(textTypeMap):  # probably, not actual data, not updated yet\n            return ' '\n\n        return textTypeMap[column]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets syntax by its xml file name.", "response": "def _getSyntaxByXmlFileName(self, xmlFileName):\n        \"\"\"Get syntax by its xml file name\n        \"\"\"\n        import qutepart.syntax.loader  # delayed import for avoid cross-imports problem\n\n        with self._loadedSyntaxesLock:\n            if not xmlFileName in self._loadedSyntaxes:\n                xmlFilePath = os.path.join(os.path.dirname(__file__), \"data\", \"xml\", xmlFileName)\n                syntax = Syntax(self)\n                self._loadedSyntaxes[xmlFileName] = syntax\n                qutepart.syntax.loader.loadSyntax(syntax, xmlFilePath)\n\n            return self._loadedSyntaxes[xmlFileName]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a syntax by its name.", "response": "def _getSyntaxByLanguageName(self, syntaxName):\n        \"\"\"Get syntax by its name. Name is defined in the xml file\n        \"\"\"\n        xmlFileName = self._syntaxNameToXmlFileName[syntaxName]\n        return self._getSyntaxByXmlFileName(xmlFileName)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _getSyntaxBySourceFileName(self, name):\n        for regExp, xmlFileName in self._extensionToXmlFileName.items():\n            if regExp.match(name):\n                return self._getSyntaxByXmlFileName(xmlFileName)\n        else:\n            raise KeyError(\"No syntax for \" + name)", "response": "Get syntax by source name of file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _getSyntaxByMimeType(self, mimeType):\n        xmlFileName = self._mimeTypeToXmlFileName[mimeType]\n        return self._getSyntaxByXmlFileName(xmlFileName)", "response": "Get the syntax by MIME type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the syntax for the first line of the file.", "response": "def _getSyntaxByFirstLine(self, firstLine):\n        \"\"\"Get syntax by first line of the file\n        \"\"\"\n        for pattern, xmlFileName in self._firstLineToXmlFileName.items():\n            if fnmatch.fnmatch(firstLine, pattern):\n                return self._getSyntaxByXmlFileName(xmlFileName)\n        else:\n            raise KeyError(\"No syntax for \" + firstLine)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the syntax of a specific language.", "response": "def getSyntax(self,\n                  xmlFileName=None,\n                  mimeType=None,\n                  languageName=None,\n                  sourceFilePath=None,\n                  firstLine=None):\n        \"\"\"Get syntax by one of parameters:\n            * xmlFileName\n            * mimeType\n            * languageName\n            * sourceFilePath\n        First parameter in the list has biggest priority\n        \"\"\"\n        syntax = None\n\n        if syntax is None and xmlFileName is not None:\n            try:\n                syntax = self._getSyntaxByXmlFileName(xmlFileName)\n            except KeyError:\n                _logger.warning('No xml definition %s' % xmlFileName)\n\n        if syntax is None and mimeType is not None:\n            try:\n                syntax = self._getSyntaxByMimeType(mimeType)\n            except KeyError:\n                _logger.warning('No syntax for mime type %s' % mimeType)\n\n        if syntax is None and languageName is not None:\n            try:\n                syntax = self._getSyntaxByLanguageName(languageName)\n            except KeyError:\n                _logger.warning('No syntax for language %s' % languageName)\n\n        if syntax is None and sourceFilePath is not None:\n            baseName = os.path.basename(sourceFilePath)\n            try:\n                syntax = self._getSyntaxBySourceFileName(baseName)\n            except KeyError:\n                pass\n\n        if syntax is None and firstLine is not None:\n            try:\n                syntax = self._getSyntaxByFirstLine(firstLine)\n            except KeyError:\n                pass\n\n        return syntax"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pop(self, count):\n        if len(self._contexts) - 1 < count:\n            _logger.error(\"#pop value is too big %d\", len(self._contexts))\n            if len(self._contexts) > 1:\n                return ContextStack(self._contexts[:1], self._data[:1])\n            else:\n                return self\n\n        return ContextStack(self._contexts[:-count], self._data[:-count])", "response": "Returns new context stack which doesn t contain few levels\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn new context which contains current stack and new frame", "response": "def append(self, context, data):\n        \"\"\"Returns new context, which contains current stack and new frame\n        \"\"\"\n        return ContextStack(self._contexts + [context], self._data + [data])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tryMatch(self, textToMatchObject):\n        # Skip if column doesn't match\n        if self.column != -1 and \\\n           self.column != textToMatchObject.currentColumnIndex:\n            return None\n\n        if self.firstNonSpace and \\\n           (not textToMatchObject.firstNonSpace):\n            return None\n\n        return self._tryMatch(textToMatchObject)", "response": "Try to find themselves in the text."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _makeDynamicSubsctitutions(string, contextData):\n        def _replaceFunc(escapeMatchObject):\n            stringIndex = escapeMatchObject.group(0)[1]\n            index = int(stringIndex)\n            if index < len(contextData):\n                return contextData[index]\n            else:\n                return escapeMatchObject.group(0)  # no any replacements, return original value\n\n        return _numSeqReplacer.sub(_replaceFunc, string)", "response": "For dynamic rules replace %d patterns with actual strings\n        Python function which is used by C extension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _tryMatch(self, textToMatchObject):\n        # Special case. if pattern starts with \\b, we have to check it manually,\n        # because string is passed to .match(..) without beginning\n        if self.wordStart and \\\n           (not textToMatchObject.isWordStart):\n                return None\n\n        #Special case. If pattern starts with ^ - check column number manually\n        if self.lineStart and \\\n           textToMatchObject.currentColumnIndex > 0:\n            return None\n\n        if self.dynamic:\n            string = self._makeDynamicSubsctitutions(self.string, textToMatchObject.contextData)\n            regExp = self._compileRegExp(string, self.insensitive, self.minimal)\n        else:\n            regExp = self.regExp\n\n        if regExp is None:\n            return None\n\n        wholeMatch, groups = self._matchPattern(regExp, textToMatchObject.text)\n        if wholeMatch is not None:\n            count = len(wholeMatch)\n            return RuleTryMatchResult(self, count, groups)\n        else:\n            return None", "response": "Tries to parse text. If matched - saves data for dynamic context\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncompiles regular expression. A simple wrapper around compileRegExp.", "response": "def _compileRegExp(string, insensitive, minimal):\n        \"\"\"Compile regular expression.\n        Python function, used by C code\n\n        NOTE minimal flag is not supported here, but supported on PCRE\n        \"\"\"\n        flags = 0\n        if insensitive:\n            flags = re.IGNORECASE\n\n        string = string.replace('[_[:alnum:]]', '[\\\\w\\\\d]') # ad-hoc fix for C++ parser\n        string = string.replace('[:digit:]', '\\\\d')\n        string = string.replace('[:blank:]', '\\\\s')\n\n        try:\n            return re.compile(string, flags)\n        except (re.error, AssertionError) as ex:\n            _logger.warning(\"Invalid pattern '%s': %s\", string, str(ex))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _matchPattern(regExp, string):\n        match = regExp.match(string)\n        if match is not None and match.group(0):\n            return match.group(0), (match.group(0), ) + match.groups()\n        else:\n            return None, None", "response": "Try to match pattern.\n        Returns tuple of match groups or None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries to find themselves in the text.", "response": "def _tryMatch(self, textToMatchObject):\n        \"\"\"Try to find themselves in the text.\n        Returns (count, matchedRule) or (None, None) if doesn't match\n        \"\"\"\n\n        # andreikop: This check is not described in kate docs, and I haven't found it in the code\n        if not textToMatchObject.isWordStart:\n            return None\n\n        index = self._tryMatchText(textToMatchObject.text)\n        if index is None:\n            return None\n\n        if textToMatchObject.currentColumnIndex + index < len(textToMatchObject.wholeLineText):\n            newTextToMatchObject = TextToMatchObject(textToMatchObject.currentColumnIndex + index,\n                                                      textToMatchObject.wholeLineText,\n                                                      self.parentContext.parser.deliminatorSet,\n                                                      textToMatchObject.contextData)\n            for rule in self.childRules:\n                ruleTryMatchResult = rule.tryMatch(newTextToMatchObject)\n                if ruleTryMatchResult is not None:\n                    index += ruleTryMatchResult.length\n                    break\n                # child rule context and attribute ignored\n\n        return RuleTryMatchResult(self, index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _countDigits(self, text):\n        index = 0\n        while index < len(text):\n            if not text[index].isdigit():\n                break\n            index += 1\n        return index", "response": "Count digits at start of text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tryMatch(self, textToMatchObject):\n        for rule in self.context.rules:\n            ruleTryMatchResult = rule.tryMatch(textToMatchObject)\n            if ruleTryMatchResult is not None:\n                _logger.debug('\\tmatched rule %s at %d in included context %s/%s',\n                              rule.shortId(),\n                              textToMatchObject.currentColumnIndex,\n                              self.context.parser.syntax.name,\n                              self.context.name)\n                return ruleTryMatchResult\n        else:\n            return None", "response": "Try to find themselves in the text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsearch for a needle and return the block and column", "response": "def findTextBackward(self, block, column, needle):\n        \"\"\"Search for a needle and return (block, column)\n        Raise ValueError, if not found\n        \"\"\"\n        if column is not None:\n            index = block.text()[:column].rfind(needle)\n        else:\n            index = block.text().rfind(needle)\n\n        if index != -1:\n            return block, index\n\n        for block in self.iterateBlocksBackFrom(block.previous()):\n            column = block.text().rfind(needle)\n            if column != -1:\n                return block, column\n\n        raise ValueError('Not found')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for a corresponding '{' and return its indentation", "response": "def findLeftBrace(self, block, column):\n        \"\"\"Search for a corresponding '{' and return its indentation\n        If not found return None\n        \"\"\"\n        block, column = self.findBracketBackward(block, column, '{')  # raise ValueError if not found\n\n        try:\n            block, column = self.tryParenthesisBeforeBrace(block, column)\n        except ValueError:\n            pass # leave previous values\n        return self._blockIndent(block)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tryParenthesisBeforeBrace(self, block, column):\n        text = block.text()[:column - 1].rstrip()\n        if not text.endswith(')'):\n            raise ValueError()\n        return self.findBracketBackward(block, len(text) - 1, '(')", "response": "Try to find the right indentation of a tag before a brace."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntry to find a previous default case or switch and return its indentation or None if not found.", "response": "def trySwitchStatement(self, block):\n        \"\"\"Check for default and case keywords and assume we are in a switch statement.\n        Try to find a previous default, case or switch and return its indentation or\n        None if not found.\n        \"\"\"\n        if not re.match(r'^\\s*(default\\s*|case\\b.*):', block.text()):\n            return None\n\n        for block in self.iterateBlocksBackFrom(block.previous()):\n            text = block.text()\n            if re.match(r\"^\\s*(default\\s*|case\\b.*):\", text):\n                dbg(\"trySwitchStatement: success in line %d\" % block.blockNumber())\n                return self._lineIndent(text)\n            elif re.match(r\"^\\s*switch\\b\", text):\n                if CFG_INDENT_CASE:\n                    return self._increaseIndent(self._lineIndent(text))\n                else:\n                    return self._lineIndent(text)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to find a previous private protected public or signals or return its indentation or None if not found.", "response": "def tryAccessModifiers(self, block):\n        \"\"\"Check for private, protected, public, signals etc... and assume we are in a\n        class definition. Try to find a previous private/protected/private... or\n        class and return its indentation or null if not found.\n        \"\"\"\n\n        if CFG_ACCESS_MODIFIERS < 0:\n            return None\n\n        if not re.match(r'^\\s*((public|protected|private)\\s*(slots|Q_SLOTS)?|(signals|Q_SIGNALS)\\s*):\\s*$', block.text()):\n            return None\n\n        try:\n            block, notUsedColumn = self.findBracketBackward(block, 0, '{')\n        except ValueError:\n            return None\n\n        indentation = self._blockIndent(block)\n        for i in range(CFG_ACCESS_MODIFIERS):\n            indentation = self._increaseIndent(indentation)\n\n        dbg(\"tryAccessModifiers: success in line %d\" % block.blockNumber())\n        return indentation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tryCKeywords(self, block, isBrace):\n        currentBlock = self._prevNonEmptyBlock(block)\n        if not currentBlock.isValid():\n            return None\n\n        # if line ends with ')', find the '(' and check this line then.\n\n        if currentBlock.text().rstrip().endswith(')'):\n            try:\n                foundBlock, foundColumn = self.findBracketBackward(currentBlock, len(currentBlock.text()), '(')\n            except ValueError:\n                pass\n            else:\n                currentBlock = foundBlock\n\n        # found non-empty line\n        currentBlockText = currentBlock.text()\n        if re.match(r'^\\s*(if\\b|for|do\\b|while|switch|[}]?\\s*else|((private|public|protected|case|default|signals|Q_SIGNALS).*:))', currentBlockText) is None:\n            return None\n\n        indentation = None\n\n        # ignore trailing comments see: https:#bugs.kde.org/show_bug.cgi?id=189339\n        try:\n            index = currentBlockText.index('//')\n        except ValueError:\n            pass\n        else:\n            currentBlockText = currentBlockText[:index]\n\n        # try to ignore lines like: if (a) b; or if (a) { b; }\n        if not currentBlockText.endswith(';') and \\\n           not currentBlockText.endswith('}'):\n            # take its indentation and add one indentation level\n            indentation = self._lineIndent(currentBlockText)\n            if not isBrace:\n                indentation = self._increaseIndent(indentation)\n        elif currentBlockText.endswith(';'):\n            # stuff like:\n            # for(int b;\n            #     b < 10;\n            #     --b)\n            try:\n                foundBlock, foundColumn = self.findBracketBackward(currentBlock, None, '(')\n            except ValueError:\n                pass\n            else:\n                dbg(\"tryCKeywords: success 1 in line %d\" % block.blockNumber())\n                return self._makeIndentAsColumn(foundBlock, foundColumn, 1)\n        if indentation is not None:\n            dbg(\"tryCKeywords: success in line %d\" % block.blockNumber())\n\n        return indentation", "response": "Try to find keywords in the block."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tryCondition(self, block):\n        currentBlock = self._prevNonEmptyBlock(block)\n        if not currentBlock.isValid():\n            return None\n\n        # found non-empty line\n        currentText = currentBlock.text()\n        if currentText.rstrip().endswith(';') and \\\n           re.search(r'^\\s*(if\\b|[}]?\\s*else|do\\b|while\\b|for)', currentText) is None:\n            # idea: we had something like:\n            #   if/while/for (expression)\n            #       statement();  <-- we catch this trailing ';'\n            # Now, look for a line that starts with if/for/while, that has one\n            # indent level less.\n            currentIndentation = self._lineIndent(currentText)\n            if not currentIndentation:\n                return None\n\n            for block in self.iterateBlocksBackFrom(currentBlock.previous()):\n                if block.text().strip(): # not empty\n                    indentation = self._blockIndent(block)\n\n                    if len(indentation) < len(currentIndentation):\n                        if re.search(r'^\\s*(if\\b|[}]?\\s*else|do\\b|while\\b|for)[^{]*$', block.text()) is not None:\n                            dbg(\"tryCondition: success in line %d\" % block.blockNumber())\n                            return indentation\n                        break\n\n        return None", "response": "Search for if do while for... as we want to indent then. Return null if nothing useful found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntrying to find the entry in the current line and return its .", "response": "def tryStatement(self, block):\n        \"\"\" If the non-empty line ends with ); or ',', then search for '(' and return its\n        indentation; also try to ignore trailing comments.\n        \"\"\"\n        currentBlock = self._prevNonEmptyBlock(block)\n\n        if not currentBlock.isValid():\n            return None\n\n        indentation = None\n\n        currentBlockText = currentBlock.text()\n        if currentBlockText.endswith('('):\n            # increase indent level\n            dbg(\"tryStatement: success 1 in line %d\" % block.blockNumber())\n            return self._increaseIndent(self._lineIndent(currentBlockText))\n\n        alignOnSingleQuote = self._qpart.language() in ('PHP/PHP', 'JavaScript')\n        # align on strings \"...\"\\n => below the opening quote\n        # multi-language support: [\\.+] for javascript or php\n        pattern =  '^(.*)'                   # any                                                  group 1\n        pattern += '([,\"\\'\\\\)])'             # one of [ , \" ' )                                     group 2\n        pattern += '(;?)'                    # optional ;                                           group 3\n        pattern += '\\s*[\\.+]?\\s*'            # optional spaces  optional . or +   optional spaces\n        pattern += '(//.*|/\\\\*.*\\\\*/\\s*)?$'  # optional(//any  or  /*any*/spaces)                   group 4\n        match = re.match(pattern, currentBlockText)\n        if match is not None:\n            alignOnAnchor = len(match.group(3)) == 0 and match.group(2) != ')'\n            # search for opening \", ' or (\n            if match.group(2) == '\"' or (alignOnSingleQuote and match.group(2) == \"'\"):\n                startIndex = len(match.group(1))\n                while True:\n                    # start from matched closing ' or \"\n                    # find string opener\n                    for i in range(startIndex - 1, 0, -1):\n                        # make sure it's not commented out\n                        if currentBlockText[i] == match.group(2) and (i == 0 or currentBlockText[i - 1] != '\\\\'):\n                            # also make sure that this is not a line like '#include \"...\"' <-- we don't want to indent here\n                            if re.match(r'^#include', currentBlockText):\n                                dbg(\"tryStatement: success 2 in line %d\" % block.blockNumber())\n                                return indentation\n\n                            break\n\n                    if not alignOnAnchor and currentBlock.previous().isValid():\n                        # when we finished the statement (;) we need to get the first line and use it's indentation\n                        # i.e.: $foo = \"asdf\"; -> align on $\n                        i -= 1 # skip \" or '\n                        # skip whitespaces and stuff like + or . (for PHP, JavaScript, ...)\n                        for i in range(i, 0, -1):\n                            if currentBlockText[i] in (' ', '\\t', '.', '+'):\n                                continue\n                            else:\n                                break\n\n                        if i > 0:\n                            # there's something in this line, use it's indentation\n                            break\n                        else:\n                            # go to previous line\n                            currentBlock = currentBlock.previous()\n                            currentBlockText = currentBlock.text()\n                            startIndex = len(currentBlockText)\n                    else:\n                        break\n\n            elif match.group(2) == ',' and not '(' in currentBlockText:\n                # assume a function call: check for '(' brace\n                # - if not found, use previous indentation\n                # - if found, compare the indentation depth of current line and open brace line\n                #   - if current indentation depth is smaller, use that\n                #   - otherwise, use the '(' indentation + following white spaces\n                currentIndentation = self._blockIndent(currentBlock)\n                try:\n                    foundBlock, foundColumn = self.findBracketBackward(currentBlock, len(match.group(1)), '(')\n                except ValueError:\n                    indentation = currentIndentation\n                else:\n                    indentWidth = foundColumn + 1\n                    text = foundBlock.text()\n                    while indentWidth < len(text) and text[indentWidth].isspace():\n                        indentWidth += 1\n                    indentation = self._makeIndentAsColumn(foundBlock, indentWidth)\n\n            else:\n                try:\n                    foundBlock, foundColumn = self.findBracketBackward(currentBlock, len(match.group(1)), '(')\n                except ValueError:\n                    pass\n                else:\n                    if alignOnAnchor:\n                        if not match.group(2) in ('\"', \"'\"):\n                            foundColumn += 1\n                        foundBlockText = foundBlock.text()\n                        while foundColumn < len(foundBlockText) and \\\n                              foundBlockText[foundColumn].isspace():\n                            foundColumn += 1\n                        indentation = self._makeIndentAsColumn(foundBlock, foundColumn)\n                    else:\n                        currentBlock = foundBlock\n                        indentation = self._blockIndent(currentBlock)\n        elif currentBlockText.rstrip().endswith(';'):\n            indentation = self._blockIndent(currentBlock)\n\n        if indentation is not None:\n            dbg(\"tryStatement: success in line %d\" % currentBlock.blockNumber())\n        return indentation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tryMatchedAnchor(self, block, autoIndent):\n        oposite = { ')': '(',\n                    '}': '{',\n                    ']': '['}\n\n        char = self._firstNonSpaceChar(block)\n        if not char in oposite.keys():\n            return None\n\n        # we pressed enter in e.g. ()\n        try:\n            foundBlock, foundColumn = self.findBracketBackward(block, 0, oposite[char])\n        except ValueError:\n            return None\n\n        if autoIndent:\n            # when aligning only, don't be too smart and just take the indent level of the open anchor\n            return self._blockIndent(foundBlock)\n\n        lastChar = self._lastNonSpaceChar(block.previous())\n        charsMatch = ( lastChar == '(' and char == ')' ) or \\\n                     ( lastChar == '{' and char == '}' ) or \\\n                     ( lastChar == '[' and char == ']' )\n\n        indentation = None\n        if (not charsMatch) and char != '}':\n            # otherwise check whether the last line has the expected\n            # indentation, if not use it instead and place the closing\n            # anchor on the level of the opening anchor\n            expectedIndentation = self._increaseIndent(self._blockIndent(foundBlock))\n            actualIndentation = self._increaseIndent(self._blockIndent(block.previous()))\n            indentation = None\n            if len(expectedIndentation) <= len(actualIndentation):\n                if lastChar == ',':\n                    # use indentation of last line instead and place closing anchor\n                    # in same column of the opening anchor\n                    self._qpart.insertText((block.blockNumber(), self._firstNonSpaceColumn(block.text())), '\\n')\n                    self._qpart.cursorPosition = (block.blockNumber(), len(actualIndentation))\n                    # indent closing anchor\n                    self._setBlockIndent(block.next(), self._makeIndentAsColumn(foundBlock, foundColumn))\n                    indentation = actualIndentation\n                elif expectedIndentation == self._blockIndent(block.previous()):\n                    # otherwise don't add a new line, just use indentation of closing anchor line\n                    indentation = self._blockIndent(foundBlock)\n                else:\n                    # otherwise don't add a new line, just align on closing anchor\n                    indentation = self._makeIndentAsColumn(foundBlock, foundColumn)\n\n                dbg(\"tryMatchedAnchor: success in line %d\" % foundBlock.blockNumber())\n                return indentation\n\n        # otherwise we i.e. pressed enter between (), [] or when we enter before curly brace\n        # increase indentation and place closing anchor on the next line\n        indentation = self._blockIndent(foundBlock)\n        self._qpart.replaceText((block.blockNumber(), 0), len(self._blockIndent(block)), \"\\n\")\n        self._qpart.cursorPosition = (block.blockNumber(), len(indentation))\n        # indent closing brace\n        self._setBlockIndent(block.next(), indentation)\n        dbg(\"tryMatchedAnchor: success in line %d\" % foundBlock.blockNumber())\n        return self._increaseIndent(indentation)", "response": "Try to match an anchor in a block."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nindent line. Return filler or null.", "response": "def indentLine(self, block, autoIndent):\n        \"\"\" Indent line.\n        Return filler or null.\n        \"\"\"\n        indent = None\n        if indent is None:\n            indent = self.tryMatchedAnchor(block, autoIndent)\n        if indent is None:\n            indent = self.tryCComment(block)\n        if indent is None and not autoIndent:\n            indent = self.tryCppComment(block)\n        if indent is None:\n            indent = self.trySwitchStatement(block)\n        if indent is None:\n            indent = self.tryAccessModifiers(block)\n        if indent is None:\n            indent = self.tryBrace(block)\n        if indent is None:\n            indent = self.tryCKeywords(block, block.text().lstrip().startswith('{'))\n        if indent is None:\n            indent = self.tryCondition(block)\n        if indent is None:\n            indent = self.tryStatement(block)\n\n        if indent is not None:\n            return indent\n        else:\n            dbg(\"Nothing matched\")\n            return self._prevNonEmptyBlockIndent(block)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _findExpressionEnd(self, block):\n        while block.isValid():\n            column = self._lastColumn(block)\n            if column > 0:\n                return block, column\n            block = block.previous()\n        raise UserWarning()", "response": "Find the end of the last expression in the block"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves backward to the end of the word at the end of a string.", "response": "def _lastWord(self, text):\n        \"\"\"Move backward to the start of the word at the end of a string.\n        Return the word\n        \"\"\"\n        for index, char in enumerate(text[::-1]):\n            if char.isspace() or \\\n               char in ('(', ')'):\n                return text[len(text) - index :]\n        else:\n            return text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds start of not finished expression Raise UserWarning if not found", "response": "def _findExpressionStart(self, block):\n        \"\"\"Find start of not finished expression\n        Raise UserWarning, if not found\n        \"\"\"\n\n        # raise expession on next level, if not found\n        expEndBlock, expEndColumn = self._findExpressionEnd(block)\n\n        text = expEndBlock.text()[:expEndColumn + 1]\n        if text.endswith(')'):\n            try:\n                return self.findBracketBackward(expEndBlock, expEndColumn, '(')\n            except ValueError:\n                raise UserWarning()\n        else:\n            return expEndBlock, len(text) - len(self._lastWord(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef computeSmartIndent(self, block, char):\n        try:\n            foundBlock, foundColumn = self._findExpressionStart(block.previous())\n        except UserWarning:\n            return ''\n        expression = foundBlock.text()[foundColumn:].rstrip()\n        beforeExpression = foundBlock.text()[:foundColumn].strip()\n\n        if beforeExpression.startswith('(module'):  # special case\n            return ''\n        elif beforeExpression.endswith('define'):  # special case\n            return ' ' * (len(beforeExpression) - len('define') + 1)\n        elif beforeExpression.endswith('let'):  # special case\n            return ' ' * (len(beforeExpression) - len('let') + 1)\n        else:\n            return ' ' * foundColumn", "response": "Compute the indent for the block\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _getSmartIndenter(indenterName, qpart, indenter):\n    indenterName = indenterName.lower()\n\n    if indenterName in ('haskell', 'lilypond'):  # not supported yet\n        logger.warning('Smart indentation for %s not supported yet. But you could be a hero who implemented it' % indenterName)\n        from qutepart.indenter.base import IndentAlgNormal as indenterClass\n    elif 'none' == indenterName:\n        from qutepart.indenter.base import IndentAlgBase as indenterClass\n    elif 'normal' == indenterName:\n        from qutepart.indenter.base import IndentAlgNormal as indenterClass\n    elif 'cstyle' == indenterName:\n        from qutepart.indenter.cstyle import IndentAlgCStyle as indenterClass\n    elif 'python' == indenterName:\n        from qutepart.indenter.python import IndentAlgPython as indenterClass\n    elif 'ruby' == indenterName:\n        from qutepart.indenter.ruby import IndentAlgRuby as indenterClass\n    elif 'xml' == indenterName:\n        from qutepart.indenter.xmlindent import IndentAlgXml as indenterClass\n    elif 'haskell' == indenterName:\n        from qutepart.indenter.haskell import IndenterHaskell as indenterClass\n    elif 'lilypond' == indenterName:\n        from qutepart.indenter.lilypond import IndenterLilypond as indenterClass\n    elif 'lisp' == indenterName:\n        from qutepart.indenter.lisp import IndentAlgLisp as indenterClass\n    elif 'scheme' == indenterName:\n        from qutepart.indenter.scheme import IndentAlgScheme as indenterClass\n    else:\n        raise KeyError(\"Indenter %s not found\" % indenterName)\n\n    return indenterClass(qpart, indenter)", "response": "Get a single SmartIndenter by name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nindent the block after Enter pressed or trigger character", "response": "def autoIndentBlock(self, block, char='\\n'):\n        \"\"\"Indent block after Enter pressed or trigger character typed\n        \"\"\"\n        currentText = block.text()\n        spaceAtStartLen = len(currentText) - len(currentText.lstrip())\n        currentIndent = currentText[:spaceAtStartLen]\n        indent = self._smartIndenter.computeIndent(block, char)\n        if indent is not None and indent != currentIndent:\n            self._qpart.replaceText(block.position(), spaceAtStartLen, indent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the indentation level of selected blocks.", "response": "def onChangeSelectedBlocksIndent(self, increase, withSpace=False):\n        \"\"\"Tab or Space pressed and few blocks are selected, or Shift+Tab pressed\n        Insert or remove text from the beginning of blocks\n        \"\"\"\n        def blockIndentation(block):\n            text = block.text()\n            return text[:len(text) - len(text.lstrip())]\n\n        def cursorAtSpaceEnd(block):\n            cursor = QTextCursor(block)\n            cursor.setPosition(block.position() + len(blockIndentation(block)))\n            return cursor\n\n        def indentBlock(block):\n            cursor = cursorAtSpaceEnd(block)\n            cursor.insertText(' ' if withSpace else self.text())\n\n        def spacesCount(text):\n            return len(text) - len(text.rstrip(' '))\n\n        def unIndentBlock(block):\n            currentIndent = blockIndentation(block)\n\n            if currentIndent.endswith('\\t'):\n                charsToRemove = 1\n            elif withSpace:\n                charsToRemove = 1 if currentIndent else 0\n            else:\n                if self.useTabs:\n                    charsToRemove = min(spacesCount(currentIndent), self.width)\n                else:  # spaces\n                    if currentIndent.endswith(self.text()):  # remove indent level\n                        charsToRemove = self.width\n                    else:  # remove all spaces\n                        charsToRemove = min(spacesCount(currentIndent), self.width)\n\n            if charsToRemove:\n                cursor = cursorAtSpaceEnd(block)\n                cursor.setPosition(cursor.position() - charsToRemove, QTextCursor.KeepAnchor)\n                cursor.removeSelectedText()\n\n        cursor = self._qpart.textCursor()\n\n        startBlock = self._qpart.document().findBlock(cursor.selectionStart())\n        endBlock = self._qpart.document().findBlock(cursor.selectionEnd())\n        if(cursor.selectionStart() != cursor.selectionEnd() and\n           endBlock.position() == cursor.selectionEnd() and\n           endBlock.previous().isValid()):\n            endBlock = endBlock.previous()  # do not indent not selected line if indenting multiple lines\n\n        indentFunc = indentBlock if increase else unIndentBlock\n\n        if startBlock != endBlock:  # indent multiply lines\n            stopBlock = endBlock.next()\n\n            block = startBlock\n\n            with self._qpart:\n                while block != stopBlock:\n                    indentFunc(block)\n                    block = block.next()\n\n            newCursor = QTextCursor(startBlock)\n            newCursor.setPosition(endBlock.position() + len(endBlock.text()), QTextCursor.KeepAnchor)\n            self._qpart.setTextCursor(newCursor)\n        else:  # indent 1 line\n            indentFunc(startBlock)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef onShortcutIndentAfterCursor(self):\n        cursor = self._qpart.textCursor()\n\n        def insertIndent():\n            if self.useTabs:\n                cursor.insertText('\\t')\n            else:  # indent to integer count of indents from line start\n                charsToInsert = self.width - (len(self._qpart.textBeforeCursor()) % self.width)\n                cursor.insertText(' ' * charsToInsert)\n\n        if cursor.positionInBlock() == 0:  # if no any indent - indent smartly\n            block = cursor.block()\n            self.autoIndentBlock(block, '')\n\n            # if no smart indentation - just insert one indent\n            if self._qpart.textBeforeCursor() == '':\n                insertIndent()\n        else:\n            insertIndent()", "response": "Insert text after cursor and indent if no selection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef onShortcutUnindentWithBackspace(self):\n        assert self._qpart.textBeforeCursor().endswith(self.text())\n\n        charsToRemove = len(self._qpart.textBeforeCursor()) % len(self.text())\n        if charsToRemove == 0:\n            charsToRemove = len(self.text())\n\n        cursor = self._qpart.textCursor()\n        cursor.setPosition(cursor.position() - charsToRemove, QTextCursor.KeepAnchor)\n        cursor.removeSelectedText()", "response": "Unindent the current item with backspace."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nindent current line or selected lines", "response": "def onAutoIndentTriggered(self):\n        \"\"\"Indent current line or selected lines\n        \"\"\"\n        cursor = self._qpart.textCursor()\n\n        startBlock = self._qpart.document().findBlock(cursor.selectionStart())\n        endBlock = self._qpart.document().findBlock(cursor.selectionEnd())\n\n        if startBlock != endBlock:  # indent multiply lines\n            stopBlock = endBlock.next()\n\n            block = startBlock\n\n            with self._qpart:\n                while block != stopBlock:\n                    self.autoIndentBlock(block, '')\n                    block = block.next()\n        else:  # indent 1 line\n            self.autoIndentBlock(startBlock, '')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets indenter for a given syntax", "response": "def _chooseSmartIndenter(self, syntax):\n        \"\"\"Get indenter for syntax\n        \"\"\"\n        if syntax.indenter is not None:\n            try:\n                return _getSmartIndenter(syntax.indenter, self._qpart, self)\n            except KeyError:\n                logger.error(\"Indenter '%s' is not finished yet. But you can do it!\" % syntax.indenter)\n\n        try:\n            return _getSmartIndenter(syntax.name, self._qpart, self)\n        except KeyError:\n            pass\n\n        return _getSmartIndenter('normal', self._qpart, self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _processEscapeSequences(replaceText):\n    def _replaceFunc(escapeMatchObject):\n        char = escapeMatchObject.group(0)[1]\n        if char in _escapeSequences:\n            return _escapeSequences[char]\n\n        return escapeMatchObject.group(0)  # no any replacements, return original value\n\n    return _seqReplacer.sub(_replaceFunc, replaceText)", "response": "Replace symbols like \\\\ \\ n \\\\ etc. with the original value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting rules from Context or Rule xml element", "response": "def _loadChildRules(context, xmlElement, attributeToFormatMap):\n    \"\"\"Extract rules from Context or Rule xml element\n    \"\"\"\n    rules = []\n    for ruleElement in xmlElement.getchildren():\n        if not ruleElement.tag in _ruleClassDict:\n            raise ValueError(\"Not supported rule '%s'\" % ruleElement.tag)\n        rule = _ruleClassDict[ruleElement.tag](context, ruleElement, attributeToFormatMap)\n        rules.append(rule)\n    return rules"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a context from an XML element.", "response": "def _loadContext(context, xmlElement, attributeToFormatMap):\n    \"\"\"Construct context from XML element\n    Contexts are at first constructed, and only then loaded, because when loading context,\n    _makeContextSwitcher must have references to all defined contexts\n    \"\"\"\n    attribute = _safeGetRequiredAttribute(xmlElement, 'attribute', '<not set>').lower()\n    if attribute != '<not set>':  # there are no attributes for internal contexts, used by rules. See perl.xml\n        try:\n            format = attributeToFormatMap[attribute]\n        except KeyError:\n            _logger.warning('Unknown context attribute %s', attribute)\n            format = TextFormat()\n    else:\n        format = None\n\n    textType = format.textType if format is not None else ' '\n    if format is not None:\n        format = _convertFormat(format)\n\n    lineEndContextText = xmlElement.attrib.get('lineEndContext', '#stay')\n    lineEndContext = _makeContextSwitcher(lineEndContextText,  context.parser)\n    lineBeginContextText = xmlElement.attrib.get('lineBeginContext', '#stay')\n    lineBeginContext = _makeContextSwitcher(lineBeginContextText, context.parser)\n    lineEmptyContextText = xmlElement.attrib.get('lineEmptyContext', '#stay')\n    lineEmptyContext = _makeContextSwitcher(lineEmptyContextText, context.parser)\n\n    if _parseBoolAttribute(xmlElement.attrib.get('fallthrough', 'false')):\n        fallthroughContextText = _safeGetRequiredAttribute(xmlElement, 'fallthroughContext', '#stay')\n        fallthroughContext = _makeContextSwitcher(fallthroughContextText, context.parser)\n    else:\n        fallthroughContext = None\n\n    dynamic = _parseBoolAttribute(xmlElement.attrib.get('dynamic', 'false'))\n\n    context.setValues(attribute, format, lineEndContext, lineBeginContext, lineEmptyContext, fallthroughContext, dynamic, textType)\n\n    # load rules\n    rules = _loadChildRules(context, xmlElement, attributeToFormatMap)\n    context.setRules(rules)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the text type of the given attribute and defStyleName", "response": "def _textTypeForDefStyleName(attribute, defStyleName):\n    \"\"\" ' ' for code\n        'c' for comments\n        'b' for block comments\n        'h' for here documents\n    \"\"\"\n    if 'here' in attribute.lower() and defStyleName == 'dsOthers':\n        return 'h'  # ruby\n    elif 'block' in attribute.lower() and defStyleName == 'dsComment':\n        return 'b'\n    elif defStyleName in ('dsString', 'dsRegionMarker', 'dsChar', 'dsOthers'):\n        return 's'\n    elif defStyleName == 'dsComment':\n        return 'c'\n    else:\n        return ' '"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef computeIndent(self, block, char):\n        prevBlockText = block.previous().text()  # invalid block returns empty text\n        if char == '\\n' and \\\n           prevBlockText.strip() == '':  # continue indentation, if no text\n            return self._prevBlockIndent(block)\n        else:  # be smart\n            return self.computeSmartIndent(block, char)", "response": "Compute indentation for the block."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _decreaseIndent(self, indent):\n        if indent.endswith(self._qpartIndent()):\n            return indent[:-len(self._qpartIndent())]\n        else:  # oops, strange indentation, just return previous indent\n            return indent", "response": "Remove 1 indentation level"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _makeIndentFromWidth(self, width):\n        if self._indenter.useTabs:\n            tabCount, spaceCount = divmod(width, self._indenter.width)\n            return ('\\t' * tabCount) + (' ' * spaceCount)\n        else:\n            return ' ' * width", "response": "Make indent text with specified with.\n        Contains width count of tabs or spaces and spaces."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _makeIndentAsColumn(self, block, column, offset=0):\n        blockText = block.text()\n        textBeforeColumn = blockText[:column]\n        tabCount = textBeforeColumn.count('\\t')\n\n        visibleColumn = column + (tabCount * (self._indenter.width - 1))\n        return self._makeIndentFromWidth(visibleColumn + offset)", "response": "Make indent equal to column indent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting blocks indent. Modify text in qpart", "response": "def _setBlockIndent(self, block, indent):\n        \"\"\"Set blocks indent. Modify text in qpart\n        \"\"\"\n        currentIndent = self._blockIndent(block)\n        self._qpart.replaceText((block.blockNumber(), 0), len(currentIndent), indent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iterateBlocksFrom(block):\n        count = 0\n        while block.isValid() and count < MAX_SEARCH_OFFSET_LINES:\n            yield block\n            block = block.next()\n            count += 1", "response": "Generator which iterates QTextBlocks from block until the End of a document\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iterateBlocksBackFrom(block):\n        count = 0\n        while block.isValid() and count < MAX_SEARCH_OFFSET_LINES:\n            yield block\n            block = block.previous()\n            count += 1", "response": "Generator which iterates QTextBlocks from block until the Start of a document\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findBracketBackward(self, block, column, bracket):\n        if bracket in ('(', ')'):\n            opening = '('\n            closing = ')'\n        elif bracket in ('[', ']'):\n            opening = '['\n            closing = ']'\n        elif bracket in ('{', '}'):\n            opening = '{'\n            closing = '}'\n        else:\n            raise AssertionError('Invalid bracket \"%s\"' % bracket)\n\n        depth = 1\n        for foundBlock, foundColumn, char in self.iterateCharsBackwardFrom(block, column):\n            if not self._qpart.isComment(foundBlock.blockNumber(), foundColumn):\n                if char == opening:\n                    depth = depth - 1\n                elif char == closing:\n                    depth = depth + 1\n\n                if depth == 0:\n                    return foundBlock, foundColumn\n        else:\n            raise ValueError('Not found')", "response": "Search for a needle and return the block and column. Raise ValueError if not found."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for a needle and return the first found element", "response": "def findAnyBracketBackward(self, block, column):\n        \"\"\"Search for a needle and return (block, column)\n        Raise ValueError, if not found\n\n        NOTE this methods ignores strings and comments\n        \"\"\"\n        depth = {'()': 1,\n                 '[]': 1,\n                 '{}': 1\n                }\n\n        for foundBlock, foundColumn, char in self.iterateCharsBackwardFrom(block, column):\n            if self._qpart.isCode(foundBlock.blockNumber(), foundColumn):\n                for brackets in depth.keys():\n                    opening, closing = brackets\n                    if char == opening:\n                        depth[brackets] -= 1\n                        if depth[brackets] == 0:\n                            return foundBlock, foundColumn\n                    elif char == closing:\n                        depth[brackets] += 1\n        else:\n            raise ValueError('Not found')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the last non - whitespace column in the given line.", "response": "def _lastColumn(self, block):\n        \"\"\"Returns the last non-whitespace column in the given line.\n        If there are only whitespaces in the line, the return value is -1.\n        \"\"\"\n        text = block.text()\n        index = len(block.text()) - 1\n        while index >= 0 and \\\n              (text[index].isspace() or \\\n               self._qpart.isComment(block.blockNumber(), index)):\n            index -= 1\n\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the column with a non - whitespace characters starting at the given cursor position.", "response": "def _nextNonSpaceColumn(block, column):\n        \"\"\"Returns the column with a non-whitespace characters\n        starting at the given cursor position and searching forwards.\n        \"\"\"\n        textAfter = block.text()[column:]\n        if textAfter.strip():\n            spaceLen = len(textAfter) - len(textAfter.lstrip())\n            return column + spaceLen\n        else:\n            return -1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_arg_list(param_start):\n    values = [arg[len(param_start):]\n              for arg in sys.argv\n              if arg.startswith(param_start)]\n\n    # remove recognized arguments from the sys.argv\n    otherArgs = [arg\n                 for arg in sys.argv\n                 if not arg.startswith(param_start)]\n    sys.argv = otherArgs\n\n    return values", "response": "Return a list of arguments that start with param_start."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _checkBuildDependencies():\n    compiler = distutils.ccompiler.new_compiler()\n    \"\"\"check if function without parameters from stdlib can be called\n    There should be better way to check, if C compiler is installed\n    \"\"\"\n    if not compiler.has_function('rand', includes=['stdlib.h']):\n        print(\"It seems like C compiler is not installed or not operable.\")\n        return False\n\n    if not compiler.has_function('rand',\n                                 includes=['stdlib.h', 'Python.h'],\n                                 include_dirs=[distutils.sysconfig.get_python_inc()],\n                                 library_dirs=[os.path.join(os.path.dirname(sys.executable), 'libs')]):\n        print(\"Failed to find Python headers.\")\n        print(\"Try to install python-dev package\")\n        print(\"If not standard directories are used, pass parameters\")\n        print(\"\\tpython setup.py install --lib-dir=c://github/pcre-8.37/build/Release --include-dir=c://github/pcre-8.37/build\")\n        print(\"\\tpython setup.py install --lib-dir=/my/local/lib --include-dir=/my/local/include\")\n        print(\"--lib-dir= and --include-dir= may be used multiple times\")\n        return False\n\n    if not compiler.has_function('pcre_version',\n                                 includes=['pcre.h'],\n                                 libraries=['pcre'],\n                                 include_dirs=include_dirs,\n                                 library_dirs=library_dirs):\n        print(\"Failed to find pcre library.\")\n        print(\"Try to install libpcre{version}-dev package, or go to http://pcre.org\")\n        print(\"If not standard directories are used, pass parameters:\")\n        print(\"\\tpython setup.py install --lib-dir=c://github/pcre-8.37/build/Release --include-dir=c://github/pcre-8.37/build\")\n        print(\"\\tpython setup.py install --lib-dir=/my/local/lib --include-dir=/my/local/include\")\n        print(\"--lib-dir= and --include-dir= may be used multiple times\")\n        return False\n\n    return True", "response": "check if C compiler is installed and if not install it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if an event may be a typed character", "response": "def isChar(ev):\n    \"\"\" Check if an event may be a typed character\n    \"\"\"\n    text = ev.text()\n    if len(text) != 1:\n        return False\n\n    if ev.modifiers() not in (Qt.ShiftModifier, Qt.KeypadModifier, Qt.NoModifier):\n        return False\n\n    asciiCode = ord(text)\n    if asciiCode <= 31 or asciiCode == 0x7f:  # control characters\n        return False\n\n    if text == ' ' and ev.modifiers() == Qt.ShiftModifier:\n        return False  # Shift+Space is a shortcut, not a text\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef keyPressEvent(self, ev):\n        if ev.key() in (Qt.Key_Shift, Qt.Key_Control,\n                        Qt.Key_Meta, Qt.Key_Alt,\n                        Qt.Key_AltGr, Qt.Key_CapsLock,\n                        Qt.Key_NumLock, Qt.Key_ScrollLock):\n            return False  # ignore modifier pressing. Will process key pressing later\n\n        self._processingKeyPress = True\n        try:\n            ret = self._mode.keyPressEvent(ev)\n        finally:\n            self._processingKeyPress = False\n        return ret", "response": "Check the event. Return True if processed and False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extraSelections(self):\n        if not isinstance(self._mode, Normal):\n            return []\n\n        selection = QTextEdit.ExtraSelection()\n        selection.format.setBackground(QColor('#ffcc22'))\n        selection.format.setForeground(QColor('#000000'))\n        selection.cursor = self._qpart.textCursor()\n        selection.cursor.movePosition(QTextCursor.NextCharacter, QTextCursor.KeepAnchor)\n\n        return [selection]", "response": "In normal mode - QTextEdit. ExtraSelection which highlightes the cursor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmoving cursor. Used by Normal and Visual mode", "response": "def _moveCursor(self, motion, count, searchChar=None, select=False):\n        \"\"\" Move cursor.\n        Used by Normal and Visual mode\n        \"\"\"\n        cursor = self._qpart.textCursor()\n\n        effectiveCount = count or 1\n\n        moveMode = QTextCursor.KeepAnchor if select else QTextCursor.MoveAnchor\n\n        moveOperation = {_b: QTextCursor.WordLeft,\n                         _j: QTextCursor.Down,\n                         _Down: QTextCursor.Down,\n                         _k: QTextCursor.Up,\n                         _Up: QTextCursor.Up,\n                         _h: QTextCursor.Left,\n                         _Left: QTextCursor.Left,\n                         _BackSpace: QTextCursor.Left,\n                         _l: QTextCursor.Right,\n                         _Right: QTextCursor.Right,\n                         _Space: QTextCursor.Right,\n                         _w: QTextCursor.WordRight,\n                         _Dollar: QTextCursor.EndOfBlock,\n                         _End: QTextCursor.EndOfBlock,\n                         _0: QTextCursor.StartOfBlock,\n                         _Home: QTextCursor.StartOfBlock,\n                         'gg': QTextCursor.Start,\n                         _G: QTextCursor.End\n                        }\n\n\n        if motion == _G:\n            if count == 0:  # default - go to the end\n                cursor.movePosition(QTextCursor.End, moveMode)\n            else:  # if count is set - move to line\n                block = self._qpart.document().findBlockByNumber(count - 1)\n                if not block.isValid():\n                    return\n                cursor.setPosition(block.position(), moveMode)\n            self.moveToFirstNonSpace(cursor, moveMode)\n        elif motion in moveOperation:\n            for _ in range(effectiveCount):\n                cursor.movePosition(moveOperation[motion], moveMode)\n        elif motion in (_e, _E):\n            for _ in range(effectiveCount):\n                # skip spaces\n                text = cursor.block().text()\n                pos = cursor.positionInBlock()\n                for char in text[pos:]:\n                    if char.isspace():\n                        cursor.movePosition(QTextCursor.NextCharacter, moveMode)\n                    else:\n                        break\n\n                if cursor.positionInBlock() == len(text):  # at the end of line\n                    cursor.movePosition(QTextCursor.NextCharacter, moveMode)  # move to the next line\n\n                # now move to the end of word\n                if motion == _e:\n                    cursor.movePosition(QTextCursor.EndOfWord, moveMode)\n                else:\n                    text = cursor.block().text()\n                    pos = cursor.positionInBlock()\n                    for char in text[pos:]:\n                        if not char.isspace():\n                            cursor.movePosition(QTextCursor.NextCharacter, moveMode)\n                        else:\n                            break\n        elif motion == _B:\n            cursor.movePosition(QTextCursor.WordLeft, moveMode)\n            while cursor.positionInBlock() != 0 and \\\n                  (not cursor.block().text()[cursor.positionInBlock() - 1].isspace()):\n                cursor.movePosition(QTextCursor.WordLeft, moveMode)\n        elif motion == _W:\n            cursor.movePosition(QTextCursor.WordRight, moveMode)\n            while cursor.positionInBlock() != 0 and \\\n                  (not cursor.block().text()[cursor.positionInBlock() - 1].isspace()):\n                cursor.movePosition(QTextCursor.WordRight, moveMode)\n        elif motion == _Percent:\n            # Percent move is done only once\n            if self._qpart._bracketHighlighter.currentMatchedBrackets is not None:\n                ((startBlock, startCol), (endBlock, endCol)) = self._qpart._bracketHighlighter.currentMatchedBrackets\n                startPos = startBlock.position() + startCol\n                endPos = endBlock.position() + endCol\n                if select and \\\n                   (endPos > startPos):\n                    endPos += 1  # to select the bracket, not only chars before it\n                cursor.setPosition(endPos, moveMode)\n        elif motion == _Caret:\n            # Caret move is done only once\n            self.moveToFirstNonSpace(cursor, moveMode)\n        elif motion in (_f, _F, _t, _T):\n            if motion in (_f, _t):\n                iterator = self._iterateDocumentCharsForward(cursor.block(), cursor.columnNumber())\n                stepForward = QTextCursor.Right\n                stepBack = QTextCursor.Left\n            else:\n                iterator = self._iterateDocumentCharsBackward(cursor.block(), cursor.columnNumber())\n                stepForward = QTextCursor.Left\n                stepBack = QTextCursor.Right\n\n            for block, columnIndex, char in iterator:\n                if char == searchChar:\n                    cursor.setPosition(block.position() + columnIndex, moveMode)\n                    if motion in (_t, _T):\n                        cursor.movePosition(stepBack, moveMode)\n                    if select:\n                        cursor.movePosition(stepForward, moveMode)\n                    break\n        elif motion in (_PageDown, _PageUp):\n            cursorHeight = self._qpart.cursorRect().height()\n            qpartHeight = self._qpart.height()\n            visibleLineCount = qpartHeight / cursorHeight\n            direction = QTextCursor.Down if motion == _PageDown else QTextCursor.Up\n            for _ in range(int(visibleLineCount)):\n                cursor.movePosition(direction, moveMode)\n        elif motion in (_Enter, _Return):\n            if cursor.block().next().isValid():  # not the last line\n                for _ in range(effectiveCount):\n                    cursor.movePosition(QTextCursor.NextBlock, moveMode)\n                    self.moveToFirstNonSpace(cursor, moveMode)\n        else:\n            assert 0, 'Not expected motion ' + str(motion)\n\n        self._qpart.setTextCursor(cursor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntraverses document forward. Yields ( block columnIndex char", "response": "def _iterateDocumentCharsForward(self, block, startColumnIndex):\n        \"\"\"Traverse document forward. Yield (block, columnIndex, char)\n        Raise _TimeoutException if time is over\n        \"\"\"\n        # Chars in the start line\n        for columnIndex, char in list(enumerate(block.text()))[startColumnIndex:]:\n            yield block, columnIndex, char\n        block = block.next()\n\n        # Next lines\n        while block.isValid():\n            for columnIndex, char in enumerate(block.text()):\n                yield block, columnIndex, char\n\n            block = block.next()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate the document characters backwards.", "response": "def _iterateDocumentCharsBackward(self, block, startColumnIndex):\n        \"\"\"Traverse document forward. Yield (block, columnIndex, char)\n        Raise _TimeoutException if time is over\n        \"\"\"\n        # Chars in the start line\n        for columnIndex, char in reversed(list(enumerate(block.text()[:startColumnIndex]))):\n            yield block, columnIndex, char\n        block = block.previous()\n\n        # Next lines\n        while block.isValid():\n            for columnIndex, char in reversed(list(enumerate(block.text()))):\n                yield block, columnIndex, char\n\n            block = block.previous()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreset selection. If moveToTop is True - move cursor to the top position", "response": "def _resetSelection(self, moveToTop=False):\n        \"\"\" Reset selection.\n        If moveToTop is True - move cursor to the top position\n        \"\"\"\n        ancor, pos = self._qpart.selectedPosition\n        dst = min(ancor, pos) if moveToTop else pos\n        self._qpart.cursorPosition = dst"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the start and end of the selected lines range for line manipulation methods", "response": "def _selectedLinesRange(self):\n        \"\"\" Selected lines range for line manipulation methods\n        \"\"\"\n        (startLine, startCol), (endLine, endCol) = self._qpart.selectedPosition\n        start = min(startLine, endLine)\n        end = max(startLine, endLine)\n        return start, end"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _repeat(self, count, func):\n        if count != 1:\n            with self._qpart:\n                for _ in range(count):\n                    func()\n        else:\n            func()", "response": "Repeat action 1 or more times."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsubstitutes the selected text with the given command.", "response": "def cmdSubstitute(self, cmd, count):\n        \"\"\" s\n        \"\"\"\n        cursor = self._qpart.textCursor()\n        for _ in range(count):\n            cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor)\n\n        if cursor.selectedText():\n            _globalClipboard.value = cursor.selectedText()\n            cursor.removeSelectedText()\n\n        self._saveLastEditSimpleCmd(cmd, count)\n        self.switchMode(Insert)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubstitute the specified number of lines with the current one.", "response": "def cmdSubstituteLines(self, cmd, count):\n        \"\"\" S\n        \"\"\"\n        lineIndex = self._qpart.cursorPosition[0]\n        availableCount = len(self._qpart.lines) - lineIndex\n        effectiveCount = min(availableCount, count)\n\n        _globalClipboard.value = self._qpart.lines[lineIndex:lineIndex + effectiveCount]\n        with self._qpart:\n            del self._qpart.lines[lineIndex:lineIndex + effectiveCount]\n            self._qpart.lines.insert(lineIndex, '')\n            self._qpart.cursorPosition = (lineIndex, 0)\n            self._qpart._indenter.autoIndentBlock(self._qpart.textCursor().block())\n\n        self._saveLastEditSimpleCmd(cmd, count)\n        self.switchMode(Insert)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmdDelete(self, cmd, count):\n        cursor = self._qpart.textCursor()\n        direction = QTextCursor.Left if cmd == _X else QTextCursor.Right\n        for _ in range(count):\n            cursor.movePosition(direction, QTextCursor.KeepAnchor)\n\n        if cursor.selectedText():\n            _globalClipboard.value = cursor.selectedText()\n            cursor.removeSelectedText()\n\n        self._saveLastEditSimpleCmd(cmd, count)", "response": "Delete count entries from clipboard."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting count entries from the clipboard until the end of the block.", "response": "def cmdDeleteUntilEndOfBlock(self, cmd, count):\n        \"\"\" C and D\n        \"\"\"\n        cursor = self._qpart.textCursor()\n        for _ in range(count - 1):\n            cursor.movePosition(QTextCursor.Down, QTextCursor.KeepAnchor)\n        cursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)\n        _globalClipboard.value = cursor.selectedText()\n        cursor.removeSelectedText()\n        if cmd == _C:\n            self.switchMode(Insert)\n\n        self._saveLastEditSimpleCmd(cmd, count)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute smart indent for case when cursor is on a valid line.", "response": "def _computeSmartIndent(self, block, column):\n        \"\"\"Compute smart indent for case when cursor is on (block, column)\n        \"\"\"\n        lineStripped = block.text()[:column].strip()  # empty text from invalid block is ok\n        spaceLen = len(block.text()) - len(block.text().lstrip())\n\n        \"\"\"Move initial search position to bracket start, if bracket was closed\n        l = [1,\n             2]|\n        \"\"\"\n        if lineStripped and \\\n           lineStripped[-1] in ')]}':\n            try:\n                foundBlock, foundColumn = self.findBracketBackward(block,\n                                                                   spaceLen + len(lineStripped) - 1,\n                                                                   lineStripped[-1])\n            except ValueError:\n                pass\n            else:\n                return self._computeSmartIndent(foundBlock, foundColumn)\n\n        \"\"\"Unindent if hanging indentation finished\n        func(a,\n             another_func(a,\n                          b),|\n        \"\"\"\n        if len(lineStripped) > 1 and \\\n           lineStripped[-1] == ',' and \\\n           lineStripped[-2] in ')]}':\n\n            try:\n                foundBlock, foundColumn = self.findBracketBackward(block,\n                                                                   len(block.text()[:column].rstrip()) - 2,\n                                                                   lineStripped[-2])\n            except ValueError:\n                pass\n            else:\n                return self._computeSmartIndent(foundBlock, foundColumn)\n\n        \"\"\"Check hanging indentation\n        call_func(x,\n                  y,\n                  z\n        But\n        call_func(x,\n            y,\n            z\n        \"\"\"\n        try:\n            foundBlock, foundColumn = self.findAnyBracketBackward(block,\n                                                                  column)\n        except ValueError:\n            pass\n        else:\n            # indent this way only line, which contains 'y', not 'z'\n            if foundBlock.blockNumber() == block.blockNumber():\n                return self._makeIndentAsColumn(foundBlock, foundColumn + 1)\n\n        # finally, a raise, pass, and continue should unindent\n        if lineStripped in ('continue', 'break', 'pass', 'raise', 'return') or \\\n           lineStripped.startswith('raise ') or \\\n           lineStripped.startswith('return '):\n            return self._decreaseIndent(self._blockIndent(block))\n\n\n        \"\"\"\n        for:\n\n        func(a,\n             b):\n        \"\"\"\n        if lineStripped.endswith(':'):\n            newColumn = spaceLen + len(lineStripped) - 1\n            prevIndent = self._computeSmartIndent(block, newColumn)\n            return self._increaseIndent(prevIndent)\n\n        \"\"\" Generally, when a brace is on its own at the end of a regular line\n        (i.e a data structure is being started), indent is wanted.\n        For example:\n        dictionary = {\n            'foo': 'bar',\n        }\n        \"\"\"\n        if lineStripped.endswith('{['):\n            return self._increaseIndent(self._blockIndent(block))\n\n        return self._blockIndent(block)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef terminate(self):\n        self.text = ''\n        self._completer.terminate()\n\n        if self._highlighter is not None:\n            self._highlighter.terminate()\n\n        if self._vim is not None:\n            self._vim.terminate()", "response": "Terminate the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _initActions(self):\n\n        def createAction(text, shortcut, slot, iconFileName=None):\n            \"\"\"Create QAction with given parameters and add to the widget\n            \"\"\"\n            action = QAction(text, self)\n            if iconFileName is not None:\n                action.setIcon(getIcon(iconFileName))\n\n            keySeq = shortcut if isinstance(shortcut, QKeySequence) else QKeySequence(shortcut)\n            action.setShortcut(keySeq)\n            action.setShortcutContext(Qt.WidgetShortcut)\n            action.triggered.connect(slot)\n\n            self.addAction(action)\n\n            return action\n\n        # scrolling\n        self.scrollUpAction = createAction('Scroll up', 'Ctrl+Up',\n                                           lambda: self._onShortcutScroll(down = False),\n                                           'go-up')\n        self.scrollDownAction = createAction('Scroll down', 'Ctrl+Down',\n                                             lambda: self._onShortcutScroll(down = True),\n                                             'go-down')\n        self.selectAndScrollUpAction = createAction('Select and scroll Up', 'Ctrl+Shift+Up',\n                                                    lambda: self._onShortcutSelectAndScroll(down = False))\n        self.selectAndScrollDownAction = createAction('Select and scroll Down', 'Ctrl+Shift+Down',\n                                                      lambda: self._onShortcutSelectAndScroll(down = True))\n\n        # indentation\n        self.increaseIndentAction = createAction('Increase indentation', 'Tab',\n                                                 self._onShortcutIndent,\n                                                 'format-indent-more')\n        self.decreaseIndentAction = createAction('Decrease indentation', 'Shift+Tab',\n                            lambda: self._indenter.onChangeSelectedBlocksIndent(increase = False),\n                            'format-indent-less')\n        self.autoIndentLineAction = createAction('Autoindent line', 'Ctrl+I',\n                                                  self._indenter.onAutoIndentTriggered)\n        self.indentWithSpaceAction = createAction('Indent with 1 space', 'Ctrl+Shift+Space',\n                        lambda: self._indenter.onChangeSelectedBlocksIndent(increase=True,\n                                                                              withSpace=True))\n        self.unIndentWithSpaceAction = createAction('Unindent with 1 space', 'Ctrl+Shift+Backspace',\n                            lambda: self._indenter.onChangeSelectedBlocksIndent(increase=False,\n                                                                                  withSpace=True))\n\n        # editing\n        self.undoAction = createAction('Undo', QKeySequence.Undo,\n                                       self.undo, 'edit-undo')\n        self.redoAction = createAction('Redo', QKeySequence.Redo,\n                                       self.redo, 'edit-redo')\n\n        self.moveLineUpAction = createAction('Move line up', 'Alt+Up',\n                                             lambda: self._onShortcutMoveLine(down = False), 'go-up')\n        self.moveLineDownAction = createAction('Move line down', 'Alt+Down',\n                                               lambda: self._onShortcutMoveLine(down = True), 'go-down')\n        self.deleteLineAction = createAction('Delete line', 'Alt+Del', self._onShortcutDeleteLine, 'edit-delete')\n        self.cutLineAction = createAction('Cut line', 'Alt+X', self._onShortcutCutLine, 'edit-cut')\n        self.copyLineAction = createAction('Copy line', 'Alt+C', self._onShortcutCopyLine, 'edit-copy')\n        self.pasteLineAction = createAction('Paste line', 'Alt+V', self._onShortcutPasteLine, 'edit-paste')\n        self.duplicateLineAction = createAction('Duplicate line', 'Alt+D', self._onShortcutDuplicateLine)\n        self.invokeCompletionAction = createAction('Invoke completion', 'Ctrl+Space', self._completer.invokeCompletion)\n\n        # other\n        self.printAction = createAction('Print', 'Ctrl+P', self._onShortcutPrint, 'document-print')", "response": "Initialize actions for text editing and editing."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _updateTabStopWidth(self):\n        self.setTabStopWidth(self.fontMetrics().width(' ' * self._indenter.width))", "response": "Update tabstop width after font or indentation changed\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting text with correct EOL symbols. Use this method for saving a file to storage", "response": "def textForSaving(self):\n        \"\"\"Get text with correct EOL symbols. Use this method for saving a file to storage\n        \"\"\"\n        lines = self.text.splitlines()\n        if self.text.endswith('\\n'):  # splitlines ignores last \\n\n            lines.append('')\n        return self.eol.join(lines) + self.eol"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resetSelection(self):\n        cursor = self.textCursor()\n        cursor.setPosition(cursor.position())\n        self.setTextCursor(cursor)", "response": "Reset selection. Nothing will be selected."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replaceText(self, pos, length, text):\n        if isinstance(pos, tuple):\n            pos = self.mapToAbsPosition(*pos)\n\n        endPos = pos + length\n\n        if not self.document().findBlock(pos).isValid():\n            raise IndexError('Invalid start position %d' % pos)\n\n        if not self.document().findBlock(endPos).isValid():\n            raise IndexError('Invalid end position %d' % endPos)\n\n        cursor = QTextCursor(self.document())\n        cursor.setPosition(pos)\n        cursor.setPosition(endPos, QTextCursor.KeepAnchor)\n\n        cursor.insertText(text)", "response": "Replace length symbols from pos with new text."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetects syntax by next parameter.", "response": "def detectSyntax(self,\n                     xmlFileName=None,\n                     mimeType=None,\n                     language=None,\n                     sourceFilePath=None,\n                     firstLine=None):\n        \"\"\"Get syntax by next parameters (fill as many, as known):\n\n            * name of XML file with syntax definition\n            * MIME type of source file\n            * Programming language name\n            * Source file path\n            * First line of source file\n\n        First parameter in the list has the hightest priority.\n        Old syntax is always cleared, even if failed to detect new.\n\n        Method returns ``True``, if syntax is detected, and ``False`` otherwise\n        \"\"\"\n        oldLanguage = self.language()\n\n        self.clearSyntax()\n\n        syntax = self._globalSyntaxManager.getSyntax(xmlFileName=xmlFileName,\n                                                     mimeType=mimeType,\n                                                     languageName=language,\n                                                     sourceFilePath=sourceFilePath,\n                                                     firstLine=firstLine)\n\n        if syntax is not None:\n            self._highlighter = SyntaxHighlighter(syntax, self)\n            self._indenter.setSyntax(syntax)\n            keywords = {kw for kwList in syntax.parser.lists.values() for kw in kwList}\n            self._completer.setKeywords(keywords)\n\n        newLanguage = self.language()\n        if oldLanguage != newLanguage:\n            self.languageChanged.emit(newLanguage)\n\n        return syntax is not None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clearSyntax(self):\n        if self._highlighter is not None:\n            self._highlighter.terminate()\n            self._highlighter = None\n            self.languageChanged.emit(None)", "response": "Clear syntax. Disables syntax highlighting\n\n        This method might take long time, if document is big. Don't call it if you don't have to (i.e. in destructor)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a set of custom completions to the editors completions.", "response": "def setCustomCompletions(self, wordSet):\n        \"\"\"Add a set of custom completions to the editors completions.\n\n        This set is managed independently of the set of keywords and words from\n        the current document, and can thus be changed at any time.\n\n        \"\"\"\n        if not isinstance(wordSet, set):\n            raise TypeError('\"wordSet\" is not a set: %s' % type(wordSet))\n        self._completer.setCustomCompletions(wordSet)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isCode(self, blockOrBlockNumber, column):\n        if isinstance(blockOrBlockNumber, QTextBlock):\n            block = blockOrBlockNumber\n        else:\n            block = self.document().findBlockByNumber(blockOrBlockNumber)\n\n        return self._highlighter is None or \\\n               self._highlighter.isCode(block, column)", "response": "Check if text at given position is a code."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if text at given position is a comment. Including block comments and here documents.", "response": "def isComment(self, line, column):\n        \"\"\"Check if text at given position is a comment. Including block comments and here documents.\n\n        If language is not known, or text is not parsed yet, ``False`` is returned\n        \"\"\"\n        return self._highlighter is not None and \\\n               self._highlighter.isComment(self.document().findBlockByNumber(line), column)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isBlockComment(self, line, column):\n        return self._highlighter is not None and \\\n               self._highlighter.isBlockComment(self.document().findBlockByNumber(line), column)", "response": "Check if text at given position is a block comment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isHereDoc(self, line, column):\n        return self._highlighter is not None and \\\n               self._highlighter.isHereDoc(self.document().findBlockByNumber(line), column)", "response": "Check if text at given position is a here document."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setExtraSelections(self, selections):\n        def _makeQtExtraSelection(startAbsolutePosition, length):\n            selection = QTextEdit.ExtraSelection()\n            cursor = QTextCursor(self.document())\n            cursor.setPosition(startAbsolutePosition)\n            cursor.setPosition(startAbsolutePosition + length, QTextCursor.KeepAnchor)\n            selection.cursor = cursor\n            selection.format = self._userExtraSelectionFormat\n            return selection\n\n        self._userExtraSelections = [_makeQtExtraSelection(*item) for item in selections]\n        self._updateExtraSelections()", "response": "Set list of extra selections."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mapToAbsPosition(self, line, column):\n        block = self.document().findBlockByNumber(line)\n        if not block.isValid():\n            raise IndexError(\"Invalid line index %d\" % line)\n        if column >= block.length():\n            raise IndexError(\"Invalid column index %d\" % column)\n        return block.position() + column", "response": "Convert line and column number to absolute position"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef mapToLineCol(self, absPosition):\n        block = self.document().findBlock(absPosition)\n        if not block.isValid():\n            raise IndexError(\"Invalid absolute position %d\" % absPosition)\n\n        return (block.blockNumber(),\n                absPosition - block.position())", "response": "Convert absolute position to line and column"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _setSolidEdgeGeometry(self):\n        if self._lineLengthEdge is not None:\n            cr = self.contentsRect()\n\n            # contents margin usually gives 1\n            # cursor rectangle left edge for the very first character usually\n            # gives 4\n            x = self.fontMetrics().width('9' * self._lineLengthEdge) + \\\n                self._totalMarginWidth + \\\n                self.contentsMargins().left() + \\\n                self.__cursorRect(self.firstVisibleBlock(), 0, offset=0).left()\n            self._solidEdgeLine.setGeometry(QRect(x, cr.top(), 1, cr.bottom()))", "response": "Sets the solid edge line geometry if needed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _insertNewBlock(self):\n        cursor = self.textCursor()\n        atStartOfLine = cursor.positionInBlock() == 0\n        with self:\n            cursor.insertBlock()\n            if not atStartOfLine:  # if whole line is moved down - just leave it as is\n                self._indenter.autoIndentBlock(cursor.block())\n        self.ensureCursorVisible()", "response": "Insert properly indented block\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _drawIndentMarkersAndEdge(self, paintEventRect):\n        painter = QPainter(self.viewport())\n\n        def drawWhiteSpace(block, column, char):\n            leftCursorRect = self.__cursorRect(block, column, 0)\n            rightCursorRect = self.__cursorRect(block, column + 1, 0)\n            if leftCursorRect.top() == rightCursorRect.top():  # if on the same visual line\n                middleHeight = (leftCursorRect.top() + leftCursorRect.bottom()) / 2\n                if char == ' ':\n                    painter.setPen(Qt.transparent)\n                    painter.setBrush(QBrush(Qt.gray))\n                    xPos = (leftCursorRect.x() + rightCursorRect.x()) / 2\n                    painter.drawRect(QRect(xPos, middleHeight, 2, 2))\n                else:\n                    painter.setPen(QColor(Qt.gray).lighter(factor=120))\n                    painter.drawLine(leftCursorRect.x() + 3, middleHeight,\n                                     rightCursorRect.x() - 3, middleHeight)\n\n        def effectiveEdgePos(text):\n            \"\"\"Position of edge in a block.\n            Defined by self._lineLengthEdge, but visible width of \\t is more than 1,\n            therefore effective position depends on count and position of \\t symbols\n            Return -1 if line is too short to have edge\n            \"\"\"\n            if self._lineLengthEdge is None:\n                return -1\n\n            tabExtraWidth = self.indentWidth - 1\n            fullWidth = len(text) + (text.count('\\t') * tabExtraWidth)\n            if fullWidth <= self._lineLengthEdge:\n                return -1\n\n            currentWidth = 0\n            for pos, char in enumerate(text):\n                if char == '\\t':\n                    # Qt indents up to indentation level, so visible \\t width depends on position\n                    currentWidth += (self.indentWidth - (currentWidth % self.indentWidth))\n                else:\n                    currentWidth += 1\n                if currentWidth > self._lineLengthEdge:\n                    return pos\n            else:  # line too narrow, probably visible \\t width is small\n                return -1\n\n        def drawEdgeLine(block, edgePos):\n            painter.setPen(QPen(QBrush(self._lineLengthEdgeColor), 0))\n            rect = self.__cursorRect(block, edgePos, 0)\n            painter.drawLine(rect.topLeft(), rect.bottomLeft())\n\n        def drawIndentMarker(block, column):\n            painter.setPen(QColor(Qt.blue).lighter())\n            rect = self.__cursorRect(block, column, offset=0)\n            painter.drawLine(rect.topLeft(), rect.bottomLeft())\n\n        indentWidthChars = len(self._indenter.text())\n        cursorPos = self.cursorPosition\n\n        for block in iterateBlocksFrom(self.firstVisibleBlock()):\n            blockGeometry = self.blockBoundingGeometry(block).translated(self.contentOffset())\n            if blockGeometry.top() > paintEventRect.bottom():\n                break\n\n            if block.isVisible() and blockGeometry.toRect().intersects(paintEventRect):\n\n                # Draw indent markers, if good indentation is not drawn\n                if self._drawIndentations:\n                    text = block.text()\n                    if not self.drawAnyWhitespace:\n                        column = indentWidthChars\n                        while text.startswith(self._indenter.text()) and \\\n                              len(text) > indentWidthChars and \\\n                              text[indentWidthChars].isspace():\n\n                            if column != self._lineLengthEdge and \\\n                               (block.blockNumber(), column) != cursorPos:  # looks ugly, if both drawn\n                                \"\"\"on some fonts line is drawn below the cursor, if offset is 1\n                                Looks like Qt bug\"\"\"\n                                drawIndentMarker(block, column)\n\n                            text = text[indentWidthChars:]\n                            column += indentWidthChars\n\n                # Draw edge, but not over a cursor\n                if not self._drawSolidEdge:\n                    edgePos = effectiveEdgePos(block.text())\n                    if edgePos != -1 and edgePos != cursorPos[1]:\n                        drawEdgeLine(block, edgePos)\n\n                if self.drawAnyWhitespace or \\\n                   self.drawIncorrectIndentation:\n                    text = block.text()\n                    for column, draw in enumerate(self._chooseVisibleWhitespace(text)):\n                        if draw:\n                            drawWhiteSpace(block, column, text[column])", "response": "Draw indentation markers and edge in a block."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of extra selections that highlightes the current line", "response": "def _currentLineExtraSelections(self):\n        \"\"\"QTextEdit.ExtraSelection, which highlightes current line\n        \"\"\"\n        if self._currentLineColor is None:\n            return []\n\n        def makeSelection(cursor):\n            selection = QTextEdit.ExtraSelection()\n            selection.format.setBackground(self._currentLineColor)\n            selection.format.setProperty(QTextFormat.FullWidthSelection, True)\n            cursor.clearSelection()\n            selection.cursor = cursor\n            return selection\n\n        rectangularSelectionCursors = self._rectangularSelection.cursors()\n        if rectangularSelectionCursors:\n            return [makeSelection(cursor) \\\n                        for cursor in rectangularSelectionCursors]\n        else:\n            return [makeSelection(self.textCursor())]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _updateExtraSelections(self):\n        cursorColumnIndex = self.textCursor().positionInBlock()\n\n        bracketSelections = self._bracketHighlighter.extraSelections(self,\n                                                                     self.textCursor().block(),\n                                                                     cursorColumnIndex)\n\n        selections = self._currentLineExtraSelections() + \\\n                     self._rectangularSelection.selections() + \\\n                     bracketSelections + \\\n                     self._userExtraSelections\n\n        self._nonVimExtraSelections = selections\n\n        if self._vim is None:\n            allSelections = selections\n        else:\n            allSelections = selections + self._vim.extraSelections()\n\n        QPlainTextEdit.setExtraSelections(self, allSelections)", "response": "Update the extra selections of the current line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _onShortcutHome(self, select):\n        # Gather info for cursor state and movement.\n        cursor = self.textCursor()\n        text = cursor.block().text()\n        indent = len(text) - len(text.lstrip())\n        anchor = QTextCursor.KeepAnchor if select else QTextCursor.MoveAnchor\n\n        # Determine current state and move based on that.\n        if cursor.positionInBlock() == indent:\n            # We're at the beginning of the indent. Go to the beginning of the\n            # block.\n            cursor.movePosition(QTextCursor.StartOfBlock, anchor)\n        elif cursor.atBlockStart():\n            # We're at the beginning of the block. Go to the beginning of the\n            # indent.\n            setPositionInBlock(cursor, indent, anchor)\n        else:\n            # Neither of the above. There's no way I can find to directly\n            # determine if we're at the beginning of a line. So, try moving and\n            # see if the cursor location changes.\n            pos = cursor.positionInBlock()\n            cursor.movePosition(QTextCursor.StartOfLine, anchor)\n            # If we didn't move, we were already at the beginning of the line.\n            # So, move to the indent.\n            if pos == cursor.positionInBlock():\n                setPositionInBlock(cursor, indent, anchor)\n            # If we did move, check to see if the indent was closer to the\n            # cursor than the beginning of the indent. If so, move to the\n            # indent.\n            elif cursor.positionInBlock() < indent:\n                setPositionInBlock(cursor, indent, anchor)\n\n        self.setTextCursor(cursor)", "response": "Handle the home button."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _selectLines(self, startBlockNumber, endBlockNumber):\n        startBlock = self.document().findBlockByNumber(startBlockNumber)\n        endBlock = self.document().findBlockByNumber(endBlockNumber)\n        cursor = QTextCursor(startBlock)\n        cursor.setPosition(endBlock.position(), QTextCursor.KeepAnchor)\n        cursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)\n        self.setTextCursor(cursor)", "response": "Select whole lines in the document."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _selectedBlocks(self):\n        cursor = self.textCursor()\n        return self.document().findBlock(cursor.selectionStart()), \\\n               self.document().findBlock(cursor.selectionEnd())", "response": "Return selected blocks and tuple"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _selectedBlockNumbers(self):\n        startBlock, endBlock = self._selectedBlocks()\n        return startBlock.blockNumber(), endBlock.blockNumber()", "response": "Return the selected block numbers and tuple"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove line up or down depending on whether the line is selected or not.", "response": "def _onShortcutMoveLine(self, down):\n        \"\"\"Move line up or down\n        Actually, not a selected text, but next or previous block is moved\n        TODO keep bookmarks when moving\n        \"\"\"\n        startBlock, endBlock = self._selectedBlocks()\n\n        startBlockNumber = startBlock.blockNumber()\n        endBlockNumber = endBlock.blockNumber()\n\n        def _moveBlock(block, newNumber):\n            text = block.text()\n            with self:\n                del self.lines[block.blockNumber()]\n                self.lines.insert(newNumber, text)\n\n        if down:  # move next block up\n            blockToMove = endBlock.next()\n            if not blockToMove.isValid():\n                return\n\n            # if operaiton is UnDone, marks are located incorrectly\n            markMargin = self.getMargin(\"mark_area\")\n            if markMargin:\n                markMargin.clearBookmarks(startBlock, endBlock.next())\n\n            _moveBlock(blockToMove, startBlockNumber)\n\n            self._selectLines(startBlockNumber + 1, endBlockNumber + 1)\n        else:  # move previous block down\n            blockToMove = startBlock.previous()\n            if not blockToMove.isValid():\n                return\n\n            # if operaiton is UnDone, marks are located incorrectly\n            markMargin = self.getMargin(\"mark_area\")\n            if markMargin:\n                markMargin.clearBookmarks(startBlock, endBlock)\n\n            _moveBlock(blockToMove, endBlockNumber)\n\n            self._selectLines(startBlockNumber - 1, endBlockNumber - 1)\n\n        if markMargin:\n            markMargin.update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy selected lines to the clipboard", "response": "def _onShortcutCopyLine(self):\n        \"\"\"Copy selected lines to the clipboard\n        \"\"\"\n        lines = self.lines[self._selectedLinesSlice()]\n        text = self._eol.join(lines)\n        QApplication.clipboard().setText(text)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _onShortcutPasteLine(self):\n        lines = self.lines[self._selectedLinesSlice()]\n        text = QApplication.clipboard().text()\n        if text:\n            with self:\n                if self.textCursor().hasSelection():\n                    startBlockNumber, endBlockNumber = self._selectedBlockNumbers()\n                    del self.lines[self._selectedLinesSlice()]\n                    self.lines.insert(startBlockNumber, text)\n                else:\n                    line, col = self.cursorPosition\n                    if col > 0:\n                        line = line + 1\n                    self.lines.insert(line, text)", "response": "Paste lines from the clipboard."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncutting selected lines to the clipboard", "response": "def _onShortcutCutLine(self):\n        \"\"\"Cut selected lines to the clipboard\n        \"\"\"\n        lines = self.lines[self._selectedLinesSlice()]\n\n        self._onShortcutCopyLine()\n        self._onShortcutDeleteLine()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _onShortcutDuplicateLine(self):\n        cursor = self.textCursor()\n        if cursor.hasSelection():  # duplicate selection\n            text = cursor.selectedText()\n            selectionStart, selectionEnd = cursor.selectionStart(), cursor.selectionEnd()\n            cursor.setPosition(selectionEnd)\n            cursor.insertText(text)\n            # restore selection\n            cursor.setPosition(selectionStart)\n            cursor.setPosition(selectionEnd, QTextCursor.KeepAnchor)\n            self.setTextCursor(cursor)\n        else:\n            line = cursor.blockNumber()\n            self.lines.insert(line + 1, self.lines[line])\n            self.ensureCursorVisible()\n\n        self._updateExtraSelections()", "response": "Duplicate selected text or current line"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting file with current user.", "response": "def _onShortcutPrint(self):\n        \"\"\"Ctrl+P handler.\n        Show dialog, print file\n        \"\"\"\n        dialog = QPrintDialog(self)\n        if dialog.exec_() == QDialog.Accepted:\n            printer = dialog.printer()\n            self.print_(printer)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new margin.", "response": "def addMargin(self, margin, index=None):\n        \"\"\"Adds a new margin.\n           index: index in the list of margins. Default: to the end of the list\n        \"\"\"\n        if index is None:\n            self._margins.append(margin)\n        else:\n            self._margins.insert(index, margin)\n        if margin.isVisible():\n            self.updateViewport()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getMargin(self, name):\n        for margin in self._margins:\n            if margin.getName() == name:\n                return margin\n        return None", "response": "Provides the requested margin. Returns a reference to the margin if found and None otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a margin. Returns True if the margin was deleted and False otherwise.", "response": "def delMargin(self, name):\n        \"\"\"Deletes a margin.\n           Returns True if the margin was deleted and False otherwise.\n        \"\"\"\n        for index, margin in enumerate(self._margins):\n            if margin.getName() == name:\n                visible = margin.isVisible()\n                margin.clear()\n                margin.deleteLater()\n                del self._margins[index]\n                if visible:\n                    self.updateViewport()\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paintEvent(self, event):\n        painter = QPainter(self)\n        painter.fillRect(event.rect(), self.palette().color(QPalette.Window))\n        painter.setPen(Qt.black)\n\n        block = self._qpart.firstVisibleBlock()\n        blockNumber = block.blockNumber()\n        top = int(self._qpart.blockBoundingGeometry(block).translated(self._qpart.contentOffset()).top())\n        bottom = top + int(self._qpart.blockBoundingRect(block).height())\n        singleBlockHeight = self._qpart.cursorRect().height()\n\n        boundingRect = self._qpart.blockBoundingRect(block)\n        availableWidth = self.__width - self._RIGHT_MARGIN - self._LEFT_MARGIN\n        availableHeight = self._qpart.fontMetrics().height()\n        while block.isValid() and top <= event.rect().bottom():\n            if block.isVisible() and bottom >= event.rect().top():\n                number = str(blockNumber + 1)\n                painter.drawText(self._LEFT_MARGIN, top,\n                                 availableWidth, availableHeight,\n                                 Qt.AlignRight, number)\n                if boundingRect.height() >= singleBlockHeight * 2:  # wrapped block\n                    painter.fillRect(1, top + singleBlockHeight,\n                                     self.__width - 2, boundingRect.height() - singleBlockHeight - 2,\n                                     Qt.darkGreen)\n\n            block = block.next()\n            boundingRect = self._qpart.blockBoundingRect(block)\n            top = bottom\n            bottom = top + int(boundingRect.height())\n            blockNumber += 1", "response": "implementation\n        paintEvent - paints the event"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncanceling scheduled method Safe method, may be called with not-scheduled method", "response": "def cancel(self, method):\n        \"\"\"Cancel scheduled method\n        Safe method, may be called with not-scheduled method\"\"\"\n        if method in self._scheduledMethods:\n            self._scheduledMethods.remove(method)\n\n        if not self._scheduledMethods:\n            self._timer.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data(self, index, role):\n        if role == Qt.DisplayRole and \\\n           index.row() < len(self.words):\n            text = self.words[index.row()]\n            typed = text[:len(self._typedText)]\n            canComplete = text[len(self._typedText):len(self._typedText) + len(self.canCompleteText)]\n            rest = text[len(self._typedText) + len(self.canCompleteText):]\n            if canComplete:\n                # NOTE foreground colors are hardcoded, but I can't set background color of selected item (Qt bug?)\n                # might look bad on some color themes\n                return '<html>' \\\n                            '%s' \\\n                            '<font color=\"#e80000\">%s</font>' \\\n                            '%s' \\\n                        '</html>' % (typed, canComplete, rest)\n            else:\n                return typed + rest\n        else:\n            return None", "response": "method implementation of data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets common start of all words.", "response": "def _commonWordStart(self, words):\n        \"\"\"Get common start of all words.\n        i.e. for ['blablaxxx', 'blablayyy', 'blazzz'] common start is 'bla'\n        \"\"\"\n        if not words:\n            return ''\n\n        length = 0\n        firstWord = words[0]\n        otherWords = words[1:]\n        for index, char in enumerate(firstWord):\n            if not all([word[index] == char for word in otherWords]):\n                break\n            length = index + 1\n\n        return firstWord[:length]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes list of completions which shall be shown", "response": "def _makeListOfCompletions(self, wordBeforeCursor, wholeWord):\n        \"\"\"Make list of completions, which shall be shown\n        \"\"\"\n        onlySuitable = [word for word in self._wordSet \\\n                                if word.startswith(wordBeforeCursor) and \\\n                                   word != wholeWord]\n\n        return sorted(onlySuitable)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        self._closeIfNotUpdatedTimer.stop()\n        self._qpart.removeEventFilter(self)\n        self._qpart.cursorPositionChanged.disconnect(self._onCursorPositionChanged)\n\n        QListView.close(self)", "response": "Explicitly called destructor.\n        Removes widget from the qpart"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the horizontal shift of the item based on the current model s typed text.", "response": "def _horizontalShift(self):\n        \"\"\"List should be plased such way, that typed text in the list is under\n        typed text in the editor\n        \"\"\"\n        strangeAdjustment = 2  # I don't know why. Probably, won't work on other systems and versions\n        return self.fontMetrics().width(self.model().typedText()) + strangeAdjustment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmoving widget to point under cursor", "response": "def updateGeometry(self):\n        \"\"\"Move widget to point under cursor\n        \"\"\"\n        WIDGET_BORDER_MARGIN = 5\n        SCROLLBAR_WIDTH = 30  # just a guess\n\n        sizeHint = self.sizeHint()\n        width = sizeHint.width()\n        height = sizeHint.height()\n\n        cursorRect = self._qpart.cursorRect()\n        parentSize = self.parentWidget().size()\n\n        spaceBelow = parentSize.height() - cursorRect.bottom() - WIDGET_BORDER_MARGIN\n        spaceAbove = cursorRect.top() - WIDGET_BORDER_MARGIN\n\n        if height <= spaceBelow or \\\n           spaceBelow > spaceAbove:\n            yPos = cursorRect.bottom()\n            if height > spaceBelow and \\\n               spaceBelow > self.minimumHeight():\n                height = spaceBelow\n                width = width + SCROLLBAR_WIDTH\n        else:\n            if height > spaceAbove and \\\n               spaceAbove > self.minimumHeight():\n                height = spaceAbove\n                width = width + SCROLLBAR_WIDTH\n            yPos = max(3, cursorRect.top() - height)\n\n        xPos = cursorRect.right() - self._horizontalShift()\n\n        if xPos + width + WIDGET_BORDER_MARGIN > parentSize.width():\n            xPos = max(3, parentSize.width() - WIDGET_BORDER_MARGIN - width)\n\n        self.setGeometry(xPos, yPos, width, height)\n        self._closeIfNotUpdatedTimer.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncatching events from qpart Move selection select item or close themselves", "response": "def eventFilter(self, object, event):\n        \"\"\"Catch events from qpart\n        Move selection, select item, or close themselves\n        \"\"\"\n        if event.type() == QEvent.KeyPress and event.modifiers() == Qt.NoModifier:\n            if event.key() == Qt.Key_Escape:\n                self.closeMe.emit()\n                return True\n            elif event.key() == Qt.Key_Down:\n                if self._selectedIndex + 1 < self.model().rowCount():\n                    self._selectItem(self._selectedIndex + 1)\n                return True\n            elif event.key() == Qt.Key_Up:\n                if self._selectedIndex - 1 >= 0:\n                    self._selectItem(self._selectedIndex - 1)\n                return True\n            elif event.key() in (Qt.Key_Enter, Qt.Key_Return):\n                if self._selectedIndex != -1:\n                    self.itemSelected.emit(self._selectedIndex)\n                    return True\n            elif event.key() == Qt.Key_Tab:\n                self.tabPressed.emit()\n                return True\n        elif event.type() == QEvent.FocusOut:\n            self.closeMe.emit()\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _selectItem(self, index):\n        self._selectedIndex = index\n        self.setCurrentIndex(self.model().createIndex(index, 0))", "response": "Select item in the list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _updateWordSet(self):\n        self._wordSet = set(self._keywords) | set(self._customCompletions)\n\n        start = time.time()\n\n        for line in self._qpart.lines:\n            for match in _wordRegExp.findall(line):\n                self._wordSet.add(match)\n            if time.time() - start > self._WORD_SET_UPDATE_MAX_TIME_SEC:\n                \"\"\"It is better to have incomplete word set, than to freeze the GUI\"\"\"\n                break", "response": "Update the internal word set with the complete words from the text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose completion if visible.", "response": "def _closeCompletion(self):\n        \"\"\"Close completion, if visible.\n        Delete widget\n        \"\"\"\n        if self._widget is not None:\n            self._widget.close()\n            self._widget = None\n            self._completionOpenedManually = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _wordBeforeCursor(self):\n        cursor = self._qpart.textCursor()\n        textBeforeCursor = cursor.block().text()[:cursor.positionInBlock()]\n        match = _wordAtEndRegExp.search(textBeforeCursor)\n        if match:\n            return match.group(0)\n        else:\n            return ''", "response": "Get word which is located before cursor\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _wordAfterCursor(self):\n        cursor = self._qpart.textCursor()\n        textAfterCursor = cursor.block().text()[cursor.positionInBlock():]\n        match = _wordAtStartRegExp.search(textAfterCursor)\n        if match:\n            return match.group(0)\n        else:\n            return ''", "response": "Get word which is located before cursor\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert completion to editor", "response": "def _onCompletionListItemSelected(self, index):\n        \"\"\"Item selected. Insert completion to editor\n        \"\"\"\n        model = self._widget.model()\n        selectedWord = model.words[index]\n        textToInsert = selectedWord[len(model.typedText()):]\n        self._qpart.textCursor().insertText(textToInsert)\n        self._closeCompletion()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _onCompletionListTabPressed(self):\n        canCompleteText = self._widget.model().canCompleteText\n        if canCompleteText:\n            self._qpart.textCursor().insertText(canCompleteText)\n            self.invokeCompletionIfAvailable()", "response": "Tab pressed on completion list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_choice(klass, choices, subsets, kwargs):\n\n    obj = klass(*choices, **kwargs)\n    for subset in subsets:\n        obj.add_subset(*subset)\n    return obj", "response": "Create an instance of a Choices object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates each choices and convert each to a new set of items.", "response": "def _convert_choices(self, choices):\n        \"\"\"Validate each choices\n\n        Parameters\n        ----------\n        choices : list of tuples\n            The list of choices to be added\n\n        Returns\n        -------\n        list\n            The list of the added constants\n\n        \"\"\"\n\n        # Check that each new constant is unique.\n        constants = [c[0] for c in choices]\n        constants_doubles = [c for c in constants if constants.count(c) > 1]\n        if constants_doubles:\n            raise ValueError(\"You cannot declare two constants with the same constant name. \"\n                             \"Problematic constants: %s \" % list(set(constants_doubles)))\n\n        # Check that none of the new constants already exists.\n        bad_constants = set(constants).intersection(self.constants)\n        if bad_constants:\n            raise ValueError(\"You cannot add existing constants. \"\n                             \"Existing constants: %s.\" % list(bad_constants))\n\n        # Check that none of the constant is an existing attributes\n        bad_constants = [c for c in constants if hasattr(self, c)]\n        if bad_constants:\n            raise ValueError(\"You cannot add constants that already exists as attributes. \"\n                             \"Existing attributes: %s.\" % list(bad_constants))\n\n        # Check that each new value is unique.\n        values = [c[1] for c in choices]\n        values_doubles = [c for c in values if values.count(c) > 1]\n        if values_doubles:\n            raise ValueError(\"You cannot declare two choices with the same name.\"\n                             \"Problematic values: %s \" % list(set(values_doubles)))\n\n        # Check that none of the new values already exists.\n        try:\n            bad_values = set(values).intersection(self.values)\n        except TypeError:\n            raise ValueError(\"One value cannot be used in: %s\" % list(values))\n        else:\n            if bad_values:\n                raise ValueError(\"You cannot add existing values. \"\n                                 \"Existing values: %s.\" % list(bad_values))\n\n        # We can now add each choice.\n        for choice_tuple in choices:\n\n            # Convert the choice tuple in a ``ChoiceEntry`` instance if it's not already done.\n            # It allows to share choice entries between a ``Choices`` instance and its subsets.\n            choice_entry = choice_tuple\n            if not isinstance(choice_entry, self.ChoiceEntryClass):\n                choice_entry = self.ChoiceEntryClass(choice_entry)\n\n            # Append to the main list the choice as expected by django: (value, display name).\n            self.append(choice_entry.choice)\n            # And the ``ChoiceEntry`` instance to our own internal list.\n            self.entries.append(choice_entry)\n\n            # Make the value accessible via an attribute (the constant being its name).\n            setattr(self, choice_entry.constant, choice_entry.value)\n\n            # Fill dicts to access the ``ChoiceEntry`` instance by its constant, value or display..\n            self.constants[choice_entry.constant] = choice_entry\n            self.values[choice_entry.value] = choice_entry\n            self.displays[choice_entry.display] = choice_entry\n\n        return constants"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds some choices to the current set of available choices.", "response": "def add_choices(self, *choices, **kwargs):\n        \"\"\"Add some choices to the current ``Choices`` instance.\n\n        The given choices will be added to the existing choices.\n        If a ``name`` attribute is passed, a new subset will be created with all the given\n        choices.\n\n        Note that it's not possible to add new choices to a subset.\n\n        Parameters\n        ----------\n        *choices : list of tuples\n            It's the list of tuples to add to the ``Choices`` instance, each tuple having three\n            entries: the constant name, the value, the display name.\n\n            A dict could be added as a 4th entry in the tuple to allow setting arbitrary\n            arguments to the final ``ChoiceEntry`` created for this choice tuple.\n\n            If the first entry of ``*choices`` is a string, then it will be used as a name for a\n            new subset that will contain all the given choices.\n        **kwargs : dict\n            name : string\n                Instead of using the first entry of the ``*choices`` to pass a name of a subset to\n                create, you can pass it via the ``name`` named argument.\n\n        Example\n        -------\n\n        >>> MY_CHOICES = Choices()\n        >>> MY_CHOICES.add_choices(('ZERO', 0, 'zero'))\n        >>> MY_CHOICES\n        [('ZERO', 0, 'zero')]\n        >>> MY_CHOICES.add_choices('SMALL', ('ONE', 1, 'one'), ('TWO', 2, 'two'))\n        >>> MY_CHOICES\n        [('ZERO', 0, 'zero'), ('ONE', 1, 'one'), ('TWO', 2, 'two')]\n        >>> MY_CHOICES.SMALL\n        [('ONE', 1, 'one'), ('TWO', 2, 'two')]\n        >>> MY_CHOICES.add_choices(('THREE', 3, 'three'), ('FOUR', 4, 'four'), name='BIG')\n        >>> MY_CHOICES\n        [('ZERO', 0, 'zero'), ('ONE', 1, 'one'), ('TWO', 2, 'two'), ('THREE', 3, 'three'), ('FOUR', 4, 'four')]\n        >>> MY_CHOICES.BIG\n        [('THREE', 3, 'three'), ('FOUR', 4, 'four')]\n\n        Raises\n        ------\n        RuntimeError\n            When the ``Choices`` instance is marked as not mutable, which is the case for subsets.\n\n        ValueError\n\n            * if the subset name is defined as first argument and as named argument.\n            * if some constants have the same name or the same value.\n            * if at least one constant or value already exists in the instance.\n\n        \"\"\"\n\n        # It the ``_mutable`` flag is falsy, which is the case for subsets, we refuse to add\n        # new choices.\n        if not self._mutable:\n            raise RuntimeError(\"This ``Choices`` instance cannot be updated.\")\n\n        # Check for an optional subset name as the first argument (so the first entry of *choices).\n        subset_name = None\n        if choices and isinstance(choices[0], six.string_types) and choices[0] != _NO_SUBSET_NAME_:\n            subset_name = choices[0]\n            choices = choices[1:]\n\n        # Check for an optional subset name in the named arguments.\n        if kwargs.get('name', None):\n            if subset_name:\n                raise ValueError(\"The name of the subset cannot be defined as the first \"\n                                 \"argument and also as a named argument\")\n            subset_name = kwargs['name']\n\n        constants = self._convert_choices(choices)\n\n        # If we have a subset name, create a new subset with all the given constants.\n        if subset_name:\n            self.add_subset(subset_name, constants)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a subset of entries from the current choice set.", "response": "def extract_subset(self, *constants):\n        \"\"\"Create a subset of entries\n\n        This subset is a new ``Choices`` instance, with only the wanted constants from the\n        main ``Choices`` (each \"choice entry\" in the subset is shared from the main ``Choices``)\n\n        Parameters\n        ----------\n        *constants: list\n            The constants names of this ``Choices`` object to make available in the subset.\n\n        Returns\n        -------\n        Choices\n            The newly created subset, which is a ``Choices`` object\n\n\n        Example\n        -------\n\n        >>> STATES = Choices(\n        ...     ('ONLINE',  1, 'Online'),\n        ...     ('DRAFT',   2, 'Draft'),\n        ...     ('OFFLINE', 3, 'Offline'),\n        ... )\n        >>> STATES\n        [('ONLINE', 1, 'Online'), ('DRAFT', 2, 'Draft'), ('OFFLINE', 3, 'Offline')]\n        >>> subset = STATES.extract_subset('DRAFT', 'OFFLINE')\n        >>> subset\n        [('DRAFT', 2, 'Draft'), ('OFFLINE', 3, 'Offline')]\n        >>> subset.DRAFT\n        2\n        >>> subset.for_constant('DRAFT') is STATES.for_constant('DRAFT')\n        True\n        >>> subset.ONLINE\n        Traceback (most recent call last):\n        ...\n        AttributeError: 'Choices' object has no attribute 'ONLINE'\n\n\n        Raises\n        ------\n        ValueError\n            If a constant is not defined as a constant in the ``Choices`` instance.\n\n        \"\"\"\n\n        # Ensure that all passed constants exists as such in the list of available constants.\n        bad_constants = set(constants).difference(self.constants)\n        if bad_constants:\n            raise ValueError(\"All constants in subsets should be in parent choice. \"\n                             \"Missing constants: %s.\" % list(bad_constants))\n\n        # Keep only entries we asked for.\n        choice_entries = [self.constants[c] for c in constants]\n\n        # Create a new ``Choices`` instance with the limited set of entries, and pass the other\n        # configuration attributes to share the same behavior as the current ``Choices``.\n        # Also we set ``mutable`` to False to disable the possibility to add new choices to the\n        # subset.\n        subset = self.__class__(\n            *choice_entries,\n            **{\n                'dict_class': self.dict_class,\n                'mutable': False,\n            }\n        )\n\n        return subset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_subset(self, name, constants):\n\n        # Ensure that the name is not already used as an attribute.\n        if hasattr(self, name):\n            raise ValueError(\"Cannot use '%s' as a subset name. \"\n                             \"It's already an attribute.\" % name)\n\n        subset = self.extract_subset(*constants)\n\n        # Make the subset accessible via an attribute.\n        setattr(self, name, subset)\n        self.subsets.append(name)", "response": "Add a subset of entries under a defined name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the list of choices into a list of display values.", "response": "def _convert_choices(self, choices):\n        \"\"\"Auto create display values then call super method\"\"\"\n\n        final_choices = []\n        for choice in choices:\n\n            if isinstance(choice, ChoiceEntry):\n                final_choices.append(choice)\n                continue\n\n            original_choice = choice\n            choice = list(choice)\n            length = len(choice)\n\n            assert 2 <= length <= 4, 'Invalid number of entries in %s' % (original_choice,)\n\n            final_choice = []\n\n            # do we have attributes?\n            if length > 2 and isinstance(choice[-1], Mapping):\n                final_choice.append(choice.pop())\n            elif length == 4:\n                attributes = choice.pop()\n                assert attributes is None or isinstance(attributes, Mapping), 'Last argument must be a dict-like object in %s' % (original_choice,)\n                if attributes:\n                    final_choice.append(attributes)\n\n            # the constant\n            final_choice.insert(0, choice.pop(0))\n\n            # the db value\n            final_choice.insert(1, choice.pop(0))\n\n            if len(choice):\n                # we were given a display value\n                final_choice.insert(2, choice.pop(0))\n            else:\n                # no display value, we compute it from the constant\n                final_choice.insert(2, self.display_transform(final_choice[0]))\n\n            final_choices.append(final_choice)\n\n        return super(AutoDisplayChoices, self)._convert_choices(final_choices)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_choices(self, *choices, **kwargs):\n        return super(AutoChoices, self).add_choices(_NO_SUBSET_NAME_, *choices, **kwargs)", "response": "Disallow super method to thing the first argument is a subset name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the choices to the correct format", "response": "def _convert_choices(self, choices):\n        \"\"\"Auto create db values then call super method\"\"\"\n\n        final_choices = []\n        for choice in choices:\n\n            if isinstance(choice, ChoiceEntry):\n                final_choices.append(choice)\n                continue\n\n            original_choice = choice\n            if isinstance(choice, six.string_types):\n                if choice == _NO_SUBSET_NAME_:\n                    continue\n                choice = [choice, ]\n            else:\n                choice = list(choice)\n\n            length = len(choice)\n\n            assert 1 <= length <= 4, 'Invalid number of entries in %s' % (original_choice,)\n\n            final_choice = []\n\n            # do we have attributes?\n            if length > 1 and isinstance(choice[-1], Mapping):\n                final_choice.append(choice.pop())\n            elif length == 4:\n                attributes = choice.pop()\n                assert attributes is None or isinstance(attributes, Mapping), 'Last argument must be a dict-like object in %s' % (original_choice,)\n                if attributes:\n                    final_choice.append(attributes)\n\n            # the constant\n            final_choice.insert(0, choice.pop(0))\n\n            if len(choice):\n                # we were given a db value\n                final_choice.insert(1, choice.pop(0))\n                if len(choice):\n                    # we were given a display value\n                    final_choice.insert(2, choice.pop(0))\n            else:\n                # set None to compute it later\n                final_choice.insert(1, None)\n\n            if final_choice[1] is None:\n                # no db value, we compute it from the constant\n                final_choice[1] = self.value_transform(final_choice[0])\n\n            final_choices.append(final_choice)\n\n        return super(AutoChoices, self)._convert_choices(final_choices)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the constant to the real choice value.", "response": "def to_python(self, value):\n        \"\"\"Convert the constant to the real choice value.\"\"\"\n\n        # ``is_required`` is already checked in ``validate``.\n        if value is None:\n            return None\n\n        # Validate the type.\n        if not isinstance(value, six.string_types):\n            raise forms.ValidationError(\n                \"Invalid value type (should be a string).\",\n                code='invalid-choice-type',\n            )\n\n        # Get the constant from the choices object, raising if it doesn't exist.\n        try:\n            final = getattr(self.choices, value)\n        except AttributeError:\n            available = '[%s]' % ', '.join(self.choices.constants)\n            raise forms.ValidationError(\n                \"Invalid value (not in available choices. Available ones are: %s\" % available,\n                code='non-existing-choice',\n            )\n\n        return final"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an instance of a subclass of ChoiceAttributeMixin for the given value.", "response": "def create_choice_attribute(creator_type, value, choice_entry):\n    \"\"\"Create an instance of a subclass of ChoiceAttributeMixin for the given value.\n\n    Parameters\n    ----------\n    creator_type : type\n        ``ChoiceAttributeMixin`` or a subclass, from which we'll call the ``get_class_for_value``\n        class-method.\n    value : ?\n        The value for which we want to create an instance of a new subclass of ``creator_type``.\n    choice_entry: ChoiceEntry\n        The ``ChoiceEntry`` instance that hold the current value, used to access its constant,\n        value and display name.\n\n    Returns\n    -------\n    ChoiceAttributeMixin\n        An instance of a subclass of ``creator_type`` for the given value\n\n    \"\"\"\n\n    klass = creator_type.get_class_for_value(value)\n    return klass(value, choice_entry)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclasses method to construct a new class based on this mixin and the type of the given value.", "response": "def get_class_for_value(cls, value):\n        \"\"\"Class method to construct a class based on this mixin and the type of the given value.\n\n        Parameters\n        ----------\n        value: ?\n            The value from which to extract the type to create the new class.\n\n        Notes\n        -----\n        The  create classes are cached (in ``cls.__classes_by_type``) to avoid recreating already\n        created classes.\n        \"\"\"\n        type_ = value.__class__\n\n        # Check if the type is already a ``ChoiceAttribute``\n        if issubclass(type_, ChoiceAttributeMixin):\n            # In this case we can return this type\n            return type_\n\n        # Create a new class only if it wasn't already created for this type.\n        if type_ not in cls._classes_by_type:\n            # Compute the name of the class with the name of the type.\n            class_name = str('%sChoiceAttribute' % type_.__name__.capitalize())\n            # Create a new class and save it in the cache.\n            cls._classes_by_type[type_] = type(class_name, (cls, type_), {\n                'creator_type': cls,\n            })\n\n        # Return the class from the cache based on the type.\n        return cls._classes_by_type[type_]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_choice_attribute(self, value):\n\n        if value is None:\n            raise ValueError('Using `None` in a `Choices` object is not supported. You may '\n                             'use an empty string.')\n\n        return create_choice_attribute(self.ChoiceAttributeMixin, value, self)", "response": "Returns a choice attribute for the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\njoins given arguments into a url. Trailing but not leading slashes are stripped for each argument.", "response": "def urljoin(*args):\n        \"\"\"\n        Joins given arguments into a url. Trailing but not leading slashes are\n        stripped for each argument.\n        \"\"\"\n        return \"/\".join(map(lambda x: str(x).rstrip('/'), args)).rstrip('/')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef server_version(self):\n        if self.__server_version is None:\n            from yagocd.resources.info import InfoManager\n            self.__server_version = InfoManager(self).version\n\n        return self.__server_version", "response": "Get the server version of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pipeline_name(self):\n        if 'pipeline_name' in self.data and self.data.pipeline_name:\n            return self.data.get('pipeline_name')\n        elif self.stage.pipeline is not None:\n            return self.stage.pipeline.data.name\n        else:\n            return self.stage.data.pipeline_name", "response": "Get pipeline name of current job instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets pipeline counter of current job instance.", "response": "def pipeline_counter(self):\n        \"\"\"\n        Get pipeline counter of current job instance.\n\n        Because instantiating job instance could be performed in different ways and those return different results,\n        we have to check where from to get counter of the pipeline.\n\n        :return: pipeline counter.\n        \"\"\"\n        if 'pipeline_counter' in self.data and self.data.pipeline_counter:\n            return self.data.get('pipeline_counter')\n        elif self.stage.pipeline is not None:\n            return self.stage.pipeline.data.counter\n        else:\n            return self.stage.data.pipeline_counter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting stage name of current job instance.", "response": "def stage_name(self):\n        \"\"\"\n        Get stage name of current job instance.\n\n        Because instantiating job instance could be performed in different ways and those return different results,\n        we have to check where from to get name of the stage.\n\n        :return: stage name.\n        \"\"\"\n        if 'stage_name' in self.data and self.data.stage_name:\n            return self.data.get('stage_name')\n        else:\n            return self.stage.data.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stage_counter(self):\n        if 'stage_counter' in self.data and self.data.stage_counter:\n            return self.data.get('stage_counter')\n        else:\n            return self.stage.data.counter", "response": "Get stage counter of current job instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef properties(self):\n        return PropertyManager(\n            session=self._session,\n            pipeline_name=self.pipeline_name,\n            pipeline_counter=self.pipeline_counter,\n            stage_name=self.stage_name,\n            stage_counter=self.stage_counter,\n            job_name=self.data.name\n        )", "response": "Property for accessing the current job."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns url for accessing the current instance of this object.", "response": "def url(self):\n        \"\"\"\n        Returns url for accessing stage instance.\n        \"\"\"\n        return \"{server_url}/go/pipelines/{pipeline_name}/{pipeline_counter}/{stage_name}/{stage_counter}\".format(\n            server_url=self._session.server_url,\n            pipeline_name=self.pipeline_name,\n            pipeline_counter=self.pipeline_counter,\n            stage_name=self.data.name,\n            stage_counter=self.data.counter,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets pipeline name of current stage instance.", "response": "def pipeline_name(self):\n        \"\"\"\n        Get pipeline name of current stage instance.\n\n        Because instantiating stage instance could be performed in different ways and those return different results,\n        we have to check where from to get name of the pipeline.\n\n        :return: pipeline name.\n        \"\"\"\n        if 'pipeline_name' in self.data:\n            return self.data.get('pipeline_name')\n        elif self.pipeline is not None:\n            return self.pipeline.data.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pipeline_counter(self):\n        if 'pipeline_counter' in self.data:\n            return self.data.get('pipeline_counter')\n        elif self.pipeline is not None:\n            return self.pipeline.data.counter", "response": "Get pipeline counter of current stage instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncanceling an active pipeline of a specified stage.", "response": "def cancel(self):\n        \"\"\"\n        Cancel an active stage of a specified stage.\n\n        :return: a text confirmation.\n        \"\"\"\n        return self._manager.cancel(pipeline_name=self.pipeline_name, stage_name=self.stage_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef jobs(self):\n        jobs = list()\n        for data in self.data.jobs:\n            jobs.append(JobInstance(session=self._session, data=data, stage=self))\n\n        return jobs", "response": "Method for getting jobs from stage instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef job(self, name):\n        for job in self.jobs():\n            if job.data.name == name:\n                return job", "response": "Method for searching specific job by it s name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef agents(self):\n        if self._agent_manager is None:\n            self._agent_manager = AgentManager(session=self._session)\n        return self._agent_manager", "response": "Property for accessing AgentManager instance which is used to manage agents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configurations(self):\n        if self._configuration_manager is None:\n            self._configuration_manager = ConfigurationManager(session=self._session)\n        return self._configuration_manager", "response": "Property for accessing configuration manager instance which is used to manage configurations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encryption(self):\n        if self._encryption_manager is None:\n            self._encryption_manager = EncryptionManager(session=self._session)\n        return self._encryption_manager", "response": "Property for accessing encryption manager instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef elastic_profiles(self):\n        if self._elastic_agent_profile_manager is None:\n            self._elastic_agent_profile_manager = ElasticAgentProfileManager(session=self._session)\n        return self._elastic_agent_profile_manager", "response": "Property for accessing ElasticAgentProfileManager instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef environments(self):\n        if self._environment_manager is None:\n            self._environment_manager = EnvironmentManager(session=self._session)\n        return self._environment_manager", "response": "Property for accessing environment manager instance which is used to manage environments."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef feeds(self):\n        if self._feed_manager is None:\n            self._feed_manager = FeedManager(session=self._session)\n        return self._feed_manager", "response": "Property for accessing the FeedManager instance which is used to manage feeds."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef jobs(self):\n        if self._job_manager is None:\n            self._job_manager = JobManager(session=self._session)\n        return self._job_manager", "response": "Property for accessing the JobManager instance which is used to manage feeds."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pipeline_configs(self):\n        if self._pipeline_config_manager is None:\n            self._pipeline_config_manager = PipelineConfigManager(session=self._session)\n        return self._pipeline_config_manager", "response": "Property for accessing PipelineConfigManager instance which is used to manage pipeline configurations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plugin_info(self):\n        if self._plugin_info_manager is None:\n            self._plugin_info_manager = PluginInfoManager(session=self._session)\n        return self._plugin_info_manager", "response": "Property for accessing the PluginInfoManager instance which is used to manage pipeline configurations."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scms(self):\n        if self._scm_manager is None:\n            self._scm_manager = SCMManager(session=self._session)\n        return self._scm_manager", "response": "Property for accessing the SCM manager instance which is used to manage pluggable SCM materials."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef templates(self):\n        if self._template_manager is None:\n            self._template_manager = TemplateManager(session=self._session)\n        return self._template_manager", "response": "Property for accessing the TemplateManager instance which is used to manage templates."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef versions(self):\n        if self._version_manager is None:\n            self._version_manager = VersionManager(session=self._session)\n        return self._version_manager", "response": "Property for accessing version. VersionManager instance which is used to get server info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef url(self):\n        return self.get_url(server_url=self._session.server_url, pipeline_name=self.data.name)", "response": "Returns the url for accessing the current pipeline entity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef config(self):\n        return PipelineConfigManager(session=self._session, pipeline_name=self.data.name)", "response": "Property for accessing pipeline configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the pipeline history for this pipeline.", "response": "def history(self, offset=0):\n        \"\"\"\n        The pipeline history allows users to list pipeline instances.\n\n        :param offset: number of pipeline instances to be skipped.\n        :return: an array of pipeline instances :class:`yagocd.resources.pipeline.PipelineInstance`.\n        :rtype: list of yagocd.resources.pipeline.PipelineInstance\n        \"\"\"\n        return self._pipeline.history(name=self.data.name, offset=offset)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, counter):\n        return self._pipeline.get(name=self.data.name, counter=counter)", "response": "Gets pipeline instance object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pause(self, cause):\n        self._pipeline.pause(name=self.data.name, cause=cause)", "response": "Pause the current pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef schedule(self, materials=None, variables=None, secure_variables=None):\n        return self._pipeline.schedule(\n            name=self.data.name,\n            materials=materials,\n            variables=variables,\n            secure_variables=secure_variables\n        )", "response": "Schedules a specific pipeline for the current user to set the environment variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nschedule a new instance of the current object and return it.", "response": "def schedule_with_instance(\n        self,\n        materials=None,\n        variables=None,\n        secure_variables=None,\n        backoff=0.5,\n        max_tries=20\n    ):\n        \"\"\"\n        Schedule pipeline and return instance.\n        Credits of implementation comes to `gaqzi`:\n        https://github.com/gaqzi/py-gocd/blob/master/gocd/api/pipeline.py#L122\n\n        :warning: Replace this with whatever is the official way as soon as gocd#990 is fixed. \\\n        https://github.com/gocd/gocd/issues/990\n\n        :param materials: material revisions to use.\n        :param variables: environment variables to set.\n        :param secure_variables: secure environment variables to set.\n        :param backoff: time to wait before checking for new instance.\n        :param max_tries: maximum tries to do.\n        :return: possible triggered instance of pipeline.\n        :rtype: yagocd.resources.pipeline.PipelineInstance\n        \"\"\"\n        return self._pipeline.schedule_with_instance(\n            name=self.data.name,\n            materials=materials,\n            variables=variables,\n            secure_variables=secure_variables,\n            backoff=backoff,\n            max_tries=max_tries\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pipeline_url(self):\n        return PipelineEntity.get_url(server_url=self._session.server_url, pipeline_name=self.data.name)", "response": "Returns the url for accessing the pipeline entity."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _accept_header(self):\n        if not self.VERSION_TO_ACCEPT_HEADER:\n            return self.ACCEPT_HEADER\n\n        return YagocdUtil.choose_option(\n            version_to_options=self.VERSION_TO_ACCEPT_HEADER,\n            default=self.ACCEPT_HEADER,\n            server_version=self._session.server_version\n        )", "response": "Method for determining correct Accept header."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_predecessors(self, transitive=False):\n        result = self._predecessors\n        if transitive:\n            return YagocdUtil.graph_depth_walk(result, lambda v: v.predecessors)\n        return result", "response": "Property for getting predecessors of current pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_descendants(self, transitive=False):\n        result = self._descendants\n        if transitive:\n            return YagocdUtil.graph_depth_walk(result, lambda v: v.descendants)\n        return result", "response": "Property for getting descendants of current pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate a given launch request.", "response": "def validate_launch_request(\n            self,\n            launch_url,\n            headers,\n            args\n    ):\n        \"\"\"\n        Validate a given launch request\n\n        launch_url: Full URL that the launch request was POSTed to\n        headers: k/v pair of HTTP headers coming in with the POST\n        args: dictionary of body arguments passed to the launch_url\n            Must have the following keys to be valid:\n                oauth_consumer_key, oauth_timestamp, oauth_nonce,\n                oauth_signature\n        \"\"\"\n\n        # Validate args!\n        if 'oauth_consumer_key' not in args:\n            raise web.HTTPError(401, \"oauth_consumer_key missing\")\n        if args['oauth_consumer_key'] not in self.consumers:\n            raise web.HTTPError(401, \"oauth_consumer_key not known\")\n\n        if 'oauth_signature' not in args:\n            raise web.HTTPError(401, \"oauth_signature missing\")\n        if 'oauth_timestamp' not in args:\n            raise web.HTTPError(401, 'oauth_timestamp missing')\n\n        # Allow 30s clock skew between LTI Consumer and Provider\n        # Also don't accept timestamps from before our process started, since that could be\n        # a replay attack - we won't have nonce lists from back then. This would allow users\n        # who can control / know when our process restarts to trivially do replay attacks.\n        oauth_timestamp = int(float(args['oauth_timestamp']))\n        if (\n                int(time.time()) - oauth_timestamp > 30\n                or oauth_timestamp < LTILaunchValidator.PROCESS_START_TIME\n        ):\n            raise web.HTTPError(401, \"oauth_timestamp too old\")\n\n        if 'oauth_nonce' not in args:\n            raise web.HTTPError(401, 'oauth_nonce missing')\n        if (\n                oauth_timestamp in LTILaunchValidator.nonces\n                and args['oauth_nonce'] in LTILaunchValidator.nonces[oauth_timestamp]\n        ):\n            raise web.HTTPError(401, \"oauth_nonce + oauth_timestamp already used\")\n        LTILaunchValidator.nonces.setdefault(oauth_timestamp, set()).add(args['oauth_nonce'])\n\n\n        args_list = []\n        for key, values in args.items():\n            if type(values) is list:\n                args_list += [(key, value) for value in values]\n            else:\n                args_list.append((key, values))\n\n        base_string = signature.construct_base_string(\n            'POST',\n            signature.normalize_base_string_uri(launch_url),\n            signature.normalize_parameters(\n                signature.collect_parameters(body=args_list, headers=headers)\n            )\n        )\n\n        consumer_secret = self.consumers[args['oauth_consumer_key']]\n\n        sign = signature.sign_hmac_sha1(base_string, consumer_secret, None)\n        is_valid = signature.safe_string_equals(sign, args['oauth_signature'])\n\n        if not is_valid:\n            raise web.HTTPError(401, \"Invalid oauth_signature\")\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenable plotting in the iPython notebook.", "response": "def enable_ipython(self, **kwargs):\n        \"\"\"\n        Enable plotting in the iPython notebook.\n\n        Once enabled, all lightning plots will be automatically produced\n        within the iPython notebook. They will also be available on\n        your lightning server within the current session.\n        \"\"\"\n\n        # inspired by code powering similar functionality in mpld3\n        # https://github.com/jakevdp/mpld3/blob/master/mpld3/_display.py#L357\n\n        from IPython.core.getipython import get_ipython\n        from IPython.display import display, Javascript, HTML\n\n        self.ipython_enabled = True\n        self.set_size('medium')\n\n        ip = get_ipython()\n        formatter = ip.display_formatter.formatters['text/html']\n\n        if self.local_enabled:\n            from lightning.visualization import VisualizationLocal\n            js = VisualizationLocal.load_embed()\n            display(HTML(\"<script>\" + js + \"</script>\"))\n            if not self.quiet:\n                print('Running local mode, some functionality limited.\\n')\n            formatter.for_type(VisualizationLocal, lambda viz, kwds=kwargs: viz.get_html())\n        else:\n            formatter.for_type(Visualization, lambda viz, kwds=kwargs: viz.get_html())\n            r = requests.get(self.get_ipython_markup_link(), auth=self.auth)\n            display(Javascript(r.text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisables plotting in the iPython notebook.", "response": "def disable_ipython(self):\n        \"\"\"\n        Disable plotting in the iPython notebook.\n\n        After disabling, lightning plots will be produced in your lightning server,\n        but will not appear in the notebook.\n        \"\"\"\n        from IPython.core.getipython import get_ipython\n\n        self.ipython_enabled = False\n        ip = get_ipython()\n        formatter = ip.display_formatter.formatters['text/html']\n        formatter.type_printers.pop(Visualization, None)\n        formatter.type_printers.pop(VisualizationLocal, None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_session(self, name=None):\n        self.session = Session.create(self, name=name)\n        return self.session", "response": "Create a lightning session."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use_session(self, session_id):\n        self.session = Session(lgn=self, id=session_id)\n        return self.session", "response": "Use the specified lightning session."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the host for a lightning server.", "response": "def set_host(self, host):\n        \"\"\"\n        Set the host for a lightning server.\n\n        Host can be local (e.g. http://localhost:3000), a heroku\n        instance (e.g. http://lightning-test.herokuapp.com), or\n        a independently hosted lightning server.\n        \"\"\"\n        if host[-1] == '/':\n            host = host[:-1]\n\n        self.host = host\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_status(self):\n        try:\n            r = requests.get(self.host + '/status', auth=self.auth,\n                             timeout=(10.0, 10.0))\n            if not r.status_code == requests.codes.ok:\n                print(\"Problem connecting to server at %s\" % self.host)\n                print(\"status code: %s\" % r.status_code)\n                return False\n            else:\n                print(\"Connected to server at %s\" % self.host)\n                return True\n        except (requests.exceptions.ConnectionError,\n                requests.exceptions.MissingSchema,\n                requests.exceptions.InvalidSchema) as e:\n            print(\"Problem connecting to server at %s\" % self.host)\n            print(\"error: %s\" % e)\n            return False", "response": "Check the server for status"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _clean_data(cls, *args, **kwargs):\n\n        datadict = cls.clean(*args, **kwargs)\n\n        if 'data' in datadict:\n            data = datadict['data']\n            data = cls._ensure_dict_or_list(data)\n        else:\n            data = {}\n            for key in datadict:\n                if key == 'images':\n                    data[key] = datadict[key]\n                else:\n                    d = cls._ensure_dict_or_list(datadict[key])\n                    data[key] = cls._check_unkeyed_arrays(key, d)\n\n        return data", "response": "Convert raw data into a dictionary with plot - type specific methods."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _baseplot(cls, session, type, *args, **kwargs):\n\n        if not type:\n            raise Exception(\"Must provide a plot type\")\n\n        options, description = cls._clean_options(**kwargs)\n        data = cls._clean_data(*args)\n\n        if 'images' in data and len(data) > 1:\n            images = data['images']\n            del data['images']\n            viz = cls._create(session, data=data, type=type, options=options, description=description)\n            first_image, remaining_images = images[0], images[1:]\n            viz._append_image(first_image)\n            for image in remaining_images:\n                viz._append_image(image)\n\n        elif 'images' in data:\n            images = data['images']\n            viz = cls._create(session, images=images, type=type, options=options, description=description)\n\n        else:\n            viz = cls._create(session, data=data, type=type, options=options, description=description)\n\n        return viz", "response": "Base method for plotting data and images."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the data of the object with the given args and kwargs.", "response": "def update(self, *args, **kwargs):\n        \"\"\"\n        Base method for updating data.\n\n        Applies a plot-type specific cleaning operation, then\n        updates the data in the visualization.\n        \"\"\"\n\n        data = self._clean_data(*args, **kwargs)\n        if 'images' in data:\n            images = data['images']\n            for img in images:\n                self._update_image(img)\n        else:\n            self._update_data(data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append(self, *args, **kwargs):\n\n        data = self._clean_data(*args, **kwargs)\n        if 'images' in data:\n            images = data['images']\n            for img in images:\n                self._append_image(img)\n        else:\n            self._append_data(data=data)", "response": "Base method for appending data to the visualization."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets user data from a viz.", "response": "def _get_user_data(self):\n        \"\"\"\n        Base method for retrieving user data from a viz.\n        \"\"\"\n\n        url = self.session.host + '/sessions/' + str(self.session.id) + '/visualizations/' + str(self.id) + '/settings/'\n        r = requests.get(url)\n        if r.status_code == 200:\n            content = r.json()\n        else:\n            raise Exception('Error retrieving user data from server')\n\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_property(prop, name, **kwargs):\n\n    checkers = {\n        'color': check_color,\n        'alpha': check_alpha,\n        'size': check_size,\n        'thickness': check_thickness,\n        'index': check_index,\n        'coordinates': check_coordinates,\n        'colormap': check_colormap,\n        'bins': check_bins,\n        'spec': check_spec\n    }\n\n    if name in checkers:\n        return checkers[name](prop, **kwargs)\n    elif isinstance(prop, list) or isinstance(prop, ndarray) or isscalar(prop):\n        return check_1d(prop, name)\n    else:\n        return prop", "response": "Check and parse a property with a specific checking function or a generic parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_coordinates(co, xy=None):\n    if isinstance(co, ndarray):\n        co = co.tolist()\n    if not (isinstance(co[0][0], list) or isinstance(co[0][0], tuple)):\n        co = [co]\n    if xy is not True:\n        co = map(lambda p: asarray(p)[:, ::-1].tolist(), co)\n    return co", "response": "Check and parse coordinates as either a single coordinate list or a sequence of coordinates for multiple regions."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks and parse color specs as either a single r g b or a list of tuples of r g b.", "response": "def check_color(c):\n    \"\"\"\n    Check and parse color specs as either a single [r,g,b] or a list of\n    [[r,g,b],[r,g,b]...]\n    \"\"\"\n\n    c = asarray(c)\n    if c.ndim == 1:\n        c = c.flatten()\n        c = c[newaxis, :]\n        if c.shape[1] != 3:\n            raise Exception(\"Color must have three values per point\")\n    elif c.ndim == 2:\n        if c.shape[1] != 3:\n            raise Exception(\"Color array must have three values per point\")\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_colormap(cmap):\n    names = set(['BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu', 'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral',\n                 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens', 'Greys', 'Oranges', 'OrRd', 'PuBu',\n                 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd',\n                 'Accent', 'Dark2', 'Paired', 'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3', 'Lightning'])\n    if cmap not in names:\n        raise Exception(\"Invalid cmap '%s',  must be one of %s\" % (cmap, names))\n    else:\n        return cmap", "response": "Check if cmap is one of the colorbrewer maps\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_size(s):\n\n    s = check_1d(s, \"size\")\n    if any(map(lambda d: d <= 0, s)):\n        raise Exception('Size cannot be 0 or negative')\n\n    return s", "response": "Check and parse size specs as either a single list or a list of [ s... ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_thickness(s):\n\n    s = check_1d(s, \"thickness\")\n    if any(map(lambda d: d <= 0, s)):\n        raise Exception('Thickness cannot be 0 or negative')\n\n    return s", "response": "Check and parse thickness specs as either a single string or a list of strings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks and parses an index spec", "response": "def check_index(i):\n    \"\"\"\n    Checks and parses an index spec, must be a one-dimensional array [i0, i1, ...]\n    \"\"\"\n\n    i = asarray(i)\n    if (i.ndim > 1) or (size(i) < 1):\n        raise Exception(\"Index must be one-dimensional and non-singleton\")\n\n    return i"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_alpha(a):\n\n    a = check_1d(a, \"alpha\")\n    if any(map(lambda d: d <= 0, a)):\n        raise Exception('Alpha cannot be 0 or negative')\n\n    return a", "response": "Check and parse alpha specs as either a single list or a list of [ a... ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_1d(x, name):\n\n    x = asarray(x)\n    if size(x) == 1:\n        x = asarray([x])\n    if x.ndim == 2:\n        raise Exception(\"Property: %s must be one-dimensional\" % name)\n    x = x.flatten()\n\n    return x", "response": "Check and parse a one - dimensional spec as either a single [ x x... ] or a list of [ x x... ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of pairs of points which define a polygon return a binary mask covering the interior of the polygon with dimensions dim", "response": "def polygon_to_mask(coords, dims, z=None):\n    \"\"\"\n    Given a list of pairs of points which define a polygon, return a binary\n    mask covering the interior of the polygon with dimensions dim\n    \"\"\"\n\n    bounds = array(coords).astype('int')\n    path = Path(bounds)\n\n    grid = meshgrid(range(dims[1]), range(dims[0]))\n    grid_flat = zip(grid[0].ravel(), grid[1].ravel())\n\n    mask = path.contains_points(grid_flat).reshape(dims[0:2]).astype('int')\n\n    if z is not None:\n        if len(dims) < 3:\n            raise Exception('Dims must have three-dimensions for embedding z-index')\n        if z >= dims[2]:\n            raise Exception('Z-index %g exceeds third dimension %g' % (z, dims[2]))\n        tmp = zeros(dims)\n        tmp[:, :, z] = mask\n        mask = tmp\n\n    return mask"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list of pairs of points which define a polygon return a list of points interior to the polygon", "response": "def polygon_to_points(coords, z=None):\n    \"\"\"\n    Given a list of pairs of points which define a polygon,\n    return a list of points interior to the polygon\n    \"\"\"\n\n    bounds = array(coords).astype('int')\n\n    bmax = bounds.max(0)\n    bmin = bounds.min(0)\n\n    path = Path(bounds)\n\n    grid = meshgrid(range(bmin[0], bmax[0]+1), range(bmin[1], bmax[1]+1))\n\n    grid_flat = zip(grid[0].ravel(), grid[1].ravel())\n\n    points = path.contains_points(grid_flat).reshape(grid[0].shape).astype('int')\n    points = where(points)\n    points = (vstack([points[0], points[1]]).T + bmin[-1::-1]).tolist()\n    if z is not None:\n        points = map(lambda p: [p[0], p[1], z], points)\n\n    return points"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves self - contained html to a file.", "response": "def save_html(self, filename=None, overwrite=False):\n        \"\"\"\n        Save self-contained html to a file.\n\n        Parameters\n        ----------\n        filename : str\n            The filename to save to\n        \"\"\"\n\n        if filename is None:\n            raise ValueError('Please provide a filename, e.g. viz.save_html(filename=\"viz.html\").')\n\n        import os\n        base = self._html\n        js = self.load_embed()\n        if os.path.exists(filename):\n            if overwrite is False:\n                raise ValueError(\"File '%s' exists. To ovewrite call save_html with overwrite=True.\"\n                                 % os.path.abspath(filename))\n            else:\n                os.remove(filename)\n        with open(filename, \"wb\") as f:\n            f.write(base.encode('utf-8'))\n            f.write('<script>' + js.encode('utf-8') + '</script>')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndefaulting 503 handler, which looks for the requested URL in the redirects table, redirects if found, and displays 404 page if not redirected. Templates: ``503.html`` Context: request_path The path of the requested URL (e.g., '/app/pages/bad_page/')", "response": "def temporary_unavailable(request, template_name='503.html'):\n    \"\"\"\n    Default 503 handler, which looks for the requested URL in the\n    redirects table, redirects if found, and displays 404 page if not\n    redirected.\n\n    Templates: ``503.html``\n    Context:\n        request_path\n            The path of the requested URL (e.g., '/app/pages/bad_page/')\n\n    \"\"\"\n    context = {\n        'request_path': request.path,\n    }\n    return http.HttpResponseTemporaryUnavailable(\n        render_to_string(template_name, context))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to simplify a SpecifierSet by combining redundant specifiers.", "response": "def simplify_specifiers(spec):\n    \"\"\"Try to simplify a SpecifierSet by combining redundant specifiers.\"\"\"\n\n    def key(s):\n        return (s.version, 1 if s.operator in ['>=', '<'] else 2)\n\n    def in_bounds(v, lo, hi):\n        if lo and v not in lo:\n            return False\n        if hi and v not in hi:\n            return False\n        return True\n\n    def err(reason='inconsistent'):\n        return ValueError('{} specifier set {}'.format(reason, spec))\n\n    gt = None\n    lt = None\n    eq = None\n    ne = []\n\n    for i in spec:\n        if i.operator == '==':\n            if eq is None:\n                eq = i\n            elif eq != i:  # pragma: no branch\n                raise err()\n        elif i.operator == '!=':\n            ne.append(i)\n        elif i.operator in ['>', '>=']:\n            gt = i if gt is None else max(gt, i, key=key)\n        elif i.operator in ['<', '<=']:\n            lt = i if lt is None else min(lt, i, key=key)\n        else:\n            raise err('invalid')\n\n    ne = [i for i in ne if in_bounds(i.version, gt, lt)]\n    if eq:\n        if ( any(i.version in eq for i in ne) or\n             not in_bounds(eq.version, gt, lt)):\n            raise err()\n        return SpecifierSet(str(eq))\n    if lt and gt:\n        if lt.version not in gt or gt.version not in lt:\n            raise err()\n        if ( gt.version == lt.version and gt.operator == '>=' and\n             lt.operator == '<='):\n            return SpecifierSet('=={}'.format(gt.version))\n\n    return SpecifierSet(\n        ','.join(str(i) for i in chain(iterate(gt), iterate(lt), ne))\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_node(cls, func_name, lineno, type_=None):\n        entry = global_.SYMBOL_TABLE.declare_func(func_name, lineno, type_=type_)\n        if entry is None:\n            return None\n\n        entry.declared = True\n        return cls(entry, lineno)", "response": "This will return a node with the symbol as a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck the function types", "response": "def check_type(*args, **kwargs):\n    ''' Checks the function types\n    '''\n    args = tuple(x if isinstance(x, collections.Iterable) else (x,) for x in args)\n    kwargs = {x: kwargs[x] if isinstance(kwargs[x], collections.Iterable) else (kwargs[x],) for x in kwargs}\n\n    def decorate(func):\n        types = args\n        kwtypes = kwargs\n        gi = \"Got <{}> instead\"\n        errmsg1 = \"to be of type <{}>. \" + gi\n        errmsg2 = \"to be one of type ({}). \" + gi\n        errar = \"{}:{} expected '{}' \"\n        errkw = \"{}:{} expected {} \"\n\n        def check(*ar, **kw):\n            line = inspect.getouterframes(inspect.currentframe())[1][2]\n            fname = os.path.basename(inspect.getouterframes(inspect.currentframe())[1][1])\n\n            for arg, type_ in zip(ar, types):\n                if type(arg) not in type_:\n                    if len(type_) == 1:\n                        raise TypeError((errar + errmsg1).format(fname, line, arg, type_[0].__name__,\n                                                                 type(arg).__name__))\n                    else:\n                        raise TypeError((errar + errmsg2).format(fname, line, arg,\n                                                                 ', '.join('<%s>' % x.__name__ for x in type_),\n                                                                 type(arg).__name__))\n            for kwarg in kw:\n                if kwtypes.get(kwarg, None) is None:\n                    continue\n                if type(kw[kwarg]) not in kwtypes[kwarg]:\n                    if len(kwtypes[kwarg]) == 1:\n                        raise TypeError((errkw + errmsg1).format(fname, line, kwarg, kwtypes[kwarg][0].__name__,\n                                                                 type(kw[kwarg]).__name__))\n                    else:\n                        raise TypeError((errkw + errmsg2).format(\n                            fname,\n                            line,\n                            kwarg,\n                            ', '.join('<%s>' % x.__name__ for x in kwtypes[kwarg]),\n                            type(kw[kwarg]).__name__)\n                        )\n\n            return func(*ar, **kw)\n\n        return check\n\n    return decorate"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmapping the given string into a unique label ID.", "response": "def add_string_label(self, str_):\n        \"\"\" Maps (\"folds\") the given string, returning an unique label ID.\n        This allows several constant labels to be initialized to the same address\n        thus saving memory space.\n        :param str_: the string to map\n        :return: the unique label ID\n        \"\"\"\n        if self.STRING_LABELS.get(str_, None) is None:\n            self.STRING_LABELS[str_] = backend.tmp_label()\n\n        return self.STRING_LABELS[str_]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a backend type from api. constants to a SymbolTYPE object.", "response": "def TYPE(type_):\n        \"\"\" Converts a backend type (from api.constants)\n        to a SymbolTYPE object (taken from the SYMBOL_TABLE).\n        If type_ is already a SymbolTYPE object, nothing\n        is done.\n        \"\"\"\n        if isinstance(type_, symbols.TYPE):\n            return type_\n\n        assert TYPE.is_valid(type_)\n        return gl.SYMBOL_TABLE.basic_types[type_]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the given args to a Quad and store it in the memory.", "response": "def emit(*args):\n        \"\"\" Convert the given args to a Quad (3 address code) instruction\n        \"\"\"\n        quad = Quad(*args)\n        __DEBUG__('EMIT ' + str(quad))\n        MEMORY.append(quad)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef traverse_const(node):\n        if node.token == 'NUMBER':\n            return node.t\n\n        if node.token == 'UNARY':\n            mid = node.operator\n            if mid == 'MINUS':\n                result = ' -' + Translator.traverse_const(node.operand)\n            elif mid == 'ADDRESS':\n                if node.operand.scope == SCOPE.global_ or node.operand.token in ('LABEL', 'FUNCTION'):\n                    result = Translator.traverse_const(node.operand)\n                else:\n                    syntax_error_not_constant(node.operand.lineno)\n                    return\n            else:\n                raise InvalidOperatorError(mid)\n            return result\n\n        if node.token == 'BINARY':\n            mid = node.operator\n            if mid == 'PLUS':\n                mid = '+'\n            elif mid == 'MINUS':\n                mid = '-'\n            elif mid == 'MUL':\n                mid = '*'\n            elif mid == 'DIV':\n                mid = '/'\n            elif mid == 'MOD':\n                mid = '%'\n            elif mid == 'POW':\n                mid = '^'\n            elif mid == 'SHL':\n                mid = '>>'\n            elif mid == 'SHR':\n                mid = '<<'\n            else:\n                raise InvalidOperatorError(mid)\n\n            return '(%s) %s (%s)' % (Translator.traverse_const(node.left), mid, Translator.traverse_const(node.right))\n\n        if node.token == 'TYPECAST':\n            if node.type_ in (Type.byte_, Type.ubyte):\n                return '(' + Translator.traverse_const(node.operand) + ') & 0xFF'\n            if node.type_ in (Type.integer, Type.uinteger):\n                return '(' + Translator.traverse_const(node.operand) + ') & 0xFFFF'\n            if node.type_ in (Type.long_, Type.ulong):\n                return '(' + Translator.traverse_const(node.operand) + ') & 0xFFFFFFFF'\n            if node.type_ == Type.fixed:\n                return '((' + Translator.traverse_const(node.operand) + ') & 0xFFFF) << 16'\n            syntax_error_cant_convert_to_type(node.lineno, str(node.operand), node.type_)\n            return\n\n        if node.token in ('VAR', 'VARARRAY', 'LABEL', 'FUNCTION'):\n            # TODO: Check what happens with local vars and params\n            return node.t\n\n        if node.token == 'CONST':\n            return Translator.traverse_const(node.expr)\n\n        if node.token == 'ARRAYACCESS':\n            return '({} + {})'.format(node.entry.mangled, node.offset)\n\n        raise InvalidCONSTexpr(node)", "response": "Traverse a constant and returns an arithmetic expression that represents the constant."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_attr(node, n):\n        if len(node.children) > n:\n            return node.children[n]", "response": "Check if ATTR has to be normalized\n            after this instruction has been translated\n            to intermediate code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emit_var_assign(self, var, t):\n        p = '*' if var.byref else ''  # Indirection prefix\n        if self.O_LEVEL > 1 and not var.accessed:\n            return\n\n        if not var.type_.is_basic:\n            raise NotImplementedError()\n\n        if var.scope == SCOPE.global_:\n            self.emit('store' + self.TSUFFIX(var.type_), var.mangled, t)\n        elif var.scope == SCOPE.parameter:\n            self.emit('pstore' + self.TSUFFIX(var.type_), p + str(var.offset), t)\n        elif var.scope == SCOPE.local:\n            if var.alias is not None and var.alias.class_ == CLASS.array:\n                var.offset -= 1 + 2 * var.alias.count\n            self.emit('pstore' + self.TSUFFIX(var.type_), p + str(-var.offset), t)", "response": "Emits code for storing a value into a variable in a specific location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the label for the loop type which is the loop exit.", "response": "def loop_exit_label(self, loop_type):\n        \"\"\" Returns the label for the given loop type which\n        exits the loop. loop_type must be one of 'FOR', 'WHILE', 'DO'\n        \"\"\"\n        for i in range(len(self.LOOPS) - 1, -1, -1):\n            if loop_type == self.LOOPS[i][0]:\n                return self.LOOPS[i][1]\n\n        raise InvalidLoopError(loop_type)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the label for the loop type which is the loop_type that continues the loop.", "response": "def loop_cont_label(self, loop_type):\n        \"\"\" Returns the label for the given loop type which\n        continues the loop. loop_type must be one of 'FOR', 'WHILE', 'DO'\n        \"\"\"\n        for i in range(len(self.LOOPS) - 1, -1, -1):\n            if loop_type == self.LOOPS[i][0]:\n                return self.LOOPS[i][2]\n\n        raise InvalidLoopError(loop_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef default_value(cls, type_, expr):  # TODO: This function must be moved to api.xx\n        assert isinstance(type_, symbols.TYPE)\n        assert type_.is_basic\n        assert check.is_static(expr)\n\n        if isinstance(expr, (symbols.CONST, symbols.VAR)):  # a constant expression like @label + 1\n            if type_ in (cls.TYPE(TYPE.float_), cls.TYPE(TYPE.string)):\n                syntax_error(expr.lineno, \"Can't convert non-numeric value to {0} at compile time\".format(type_.name))\n                return ['<ERROR>']\n\n            val = Translator.traverse_const(expr)\n            if type_.size == 1:  # U/byte\n                if expr.type_.size != 1:\n                    return ['#({0}) & 0xFF'.format(val)]\n                else:\n                    return ['#{0}'.format(val)]\n\n            if type_.size == 2:  # U/integer\n                if expr.type_.size != 2:\n                    return ['##({0}) & 0xFFFF'.format(val)]\n                else:\n                    return ['##{0}'.format(val)]\n\n            if type_ == cls.TYPE(TYPE.fixed):\n                return ['0000', '##({0}) & 0xFFFF'.format(val)]\n\n            # U/Long\n            return ['##({0}) & 0xFFFF'.format(val), '##(({0}) >> 16) & 0xFFFF'.format(val)]\n\n        if type_ == cls.TYPE(TYPE.float_):\n            C, DE, HL = _float(expr.value)\n            C = C[:-1]  # Remove 'h' suffix\n            if len(C) > 2:\n                C = C[-2:]\n\n            DE = DE[:-1]  # Remove 'h' suffix\n            if len(DE) > 4:\n                DE = DE[-4:]\n            elif len(DE) < 3:\n                DE = '00' + DE\n\n            HL = HL[:-1]  # Remove 'h' suffix\n            if len(HL) > 4:\n                HL = HL[-4:]\n            elif len(HL) < 3:\n                HL = '00' + HL\n\n            return [C, DE[-2:], DE[:-2], HL[-2:], HL[:-2]]\n\n        if type_ == cls.TYPE(TYPE.fixed):\n            value = 0xFFFFFFFF & int(expr.value * 2 ** 16)\n        else:\n            value = int(expr.value)\n\n        result = [value, value >> 8, value >> 16, value >> 24]\n        result = ['%02X' % (v & 0xFF) for v in result]\n        return result[:type_.size]", "response": "Returns a list of bytes for the current value of the given type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of bytes which represents the array initial value.", "response": "def array_default_value(type_, values):\n        \"\"\" Returns a list of bytes (as hexadecimal 2 char string)\n        which represents the array initial value.\n        \"\"\"\n        if not isinstance(values, list):\n            return Translator.default_value(type_, values)\n\n        l = []\n        for row in values:\n            l.extend(Translator.array_default_value(type_, row))\n\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_control_chars(i):\n        if not hasattr(i, 'type_'):\n            return False\n\n        if i.type_ != Type.string:\n            return False\n\n        if i.token in ('VAR', 'PARAMDECL'):\n            return True  # We don't know what an alphanumeric variable will hold\n\n        if i.token == 'STRING':\n            for c in i.value:\n                if 15 < ord(c) < 22:  # is it an attr char?\n                    return True\n            return False\n\n        for j in i.children:\n            if Translator.has_control_chars(j):\n                return True\n\n        return False", "response": "Returns true if the passed token is an unknown string containing control chars."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef visit_USR(self, node):\n        self.emit('fparam' + self.TSUFFIX(gl.PTR_TYPE), node.children[0].t)\n        self.emit('call', 'USR', node.type_.size)\n        backend.REQUIRES.add('usr.asm')", "response": "Emit a user call from basic\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies all other attributes from the other object to this object.", "response": "def copy_attr(self, other):\n        \"\"\" Copies all other attributes (not methods)\n        from the other object to this instance.\n        \"\"\"\n        if not isinstance(other, Symbol):\n            return  # Nothing done if not a Symbol object\n\n        tmp = re.compile('__.*__')\n        for attr in (x for x in dir(other) if not tmp.match(x)):\n\n            if (\n                hasattr(self.__class__, attr) and\n                str(type(getattr(self.__class__, attr)) in ('property', 'function', 'instancemethod'))\n            ):\n                continue\n\n            val = getattr(other, attr)\n            if isinstance(val, str) or str(val)[0] != '<':  # Not a value\n                setattr(self, attr, val)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndefines the value of a macro. Issues a warning if the macro is already defined.", "response": "def define(self, id_, lineno, value='', fname=None, args=None):\n        \"\"\" Defines the value of a macro.\n        Issues a warning if the macro is already defined.\n        \"\"\"\n        if fname is None:\n            if CURRENT_FILE:\n                fname = CURRENT_FILE[-1]\n            else:  # If no files opened yet, use owns program fname\n                fname = sys.argv[0]\n\n        if self.defined(id_):\n            i = self.table[id_]\n            warning(lineno, '\"%s\" redefined (previous definition at %s:%i)' %\n                    (i.name, i.fname, i.lineno))\n        self.set(id_, lineno, value, fname, args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set(self, id_, lineno, value='', fname=None, args=None):\n        if fname is None:\n            if CURRENT_FILE:\n                fname = CURRENT_FILE[-1]\n            else:  # If no files opened yet, use owns program fname\n                fname = sys.argv[0]\n        self.table[id_] = ID(id_, args, value, lineno, fname)", "response": "Set a new entry in the internal table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list with two strings with two integers.", "response": "def _int_ops(op1, op2, swap=True):\n    \"\"\" Receives a list with two strings (operands).\n    If none of them contains integers, returns None.\n    Otherwise, returns a t-uple with (op[0], op[1]),\n    where op[1] is the integer one (the list is swapped)\n    unless swap is False (e.g. sub and div used this\n    because they're not commutative).\n\n    The integer operand is always converted to int type.\n    \"\"\"\n    if is_int(op1):\n        if swap:\n            return op2, int(op1)\n        else:\n            return int(op1), op2\n\n    if is_int(op2):\n        return op1, int(op2)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _f_ops(op1, op2, swap=True):\n    if is_float(op1):\n        if swap:\n            return op2, float(op1)\n        else:\n            return float(op1), op2\n\n    if is_float(op2):\n        return op1, float(op2)\n\n    return None", "response": "Receives a list with two strings ( operands ). Returns None if there are no operands."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_node(clss, node, *params):\n        ''' This will return a node with a param_list\n        (declared in a function declaration)\n        Parameters:\n            -node: A SymbolPARAMLIST instance or None\n            -params: SymbolPARAMDECL insances\n        '''\n        if node is None:\n            node = clss()\n\n        if node.token != 'PARAMLIST':\n            return clss.make_node(None, node, *params)\n\n        for i in params:\n            if i is not None:\n                node.appendChild(i)\n\n        return node", "response": "This will return a node with a param_list\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef appendChild(self, param):\n        ''' Overrides base class.\n        '''\n        Symbol.appendChild(self, param)\n        if param.offset is None:\n            param.offset = self.size\n            self.size += param.size", "response": "Adds a child to the end of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a binary node for a binary operation.", "response": "def make_node(cls, operator, left, right, lineno, func=None,\n                  type_=None):\n        \"\"\" Creates a binary node for a binary operation,\n            e.g. A + 6 => '+' (A, 6) in prefix notation.\n\n            Parameters:\n            -operator: the binary operation token. e.g. 'PLUS' for A + 6\n            -left: left operand\n            -right: right operand\n            -func: is a lambda function used when constant folding is applied\n            -type_: resulting type (to enforce it).\n\n            If no type_ is specified the resulting one will be guessed.\n        \"\"\"\n        if left is None or right is None:\n            return None\n\n        a, b = left, right  # short form names\n        # Check for constant non-numeric operations\n        c_type = common_type(a, b)  # Resulting operation type or None\n        if c_type:  # there must be a common type for a and b\n            if is_numeric(a, b) and (is_const(a) or is_number(a)) and \\\n                    (is_const(b) or is_number(b)):\n                if func is not None:\n                    a = SymbolTYPECAST.make_node(c_type, a, lineno)  # ensure type\n                    b = SymbolTYPECAST.make_node(c_type, b, lineno)  # ensure type\n                    return SymbolNUMBER(func(a.value, b.value), type_=type_, lineno=lineno)\n\n            if is_static(a, b):\n                a = SymbolTYPECAST.make_node(c_type, a, lineno)  # ensure type\n                b = SymbolTYPECAST.make_node(c_type, b, lineno)  # ensure type\n                return SymbolCONST(cls(operator, a, b, lineno, type_=type_, func=func), lineno=lineno)\n\n        if operator in ('BNOT', 'BAND', 'BOR', 'BXOR', 'NOT', 'AND', 'OR',\n                        'XOR', 'MINUS', 'MULT', 'DIV', 'SHL', 'SHR') and \\\n                not is_numeric(a, b):\n            syntax_error(lineno, 'Operator %s cannot be used with STRINGS' % operator)\n            return None\n\n        if is_string(a, b) and func is not None:  # Are they STRING Constants?\n            if operator == 'PLUS':\n                return SymbolSTRING(func(a.value, b.value), lineno)\n\n            return SymbolNUMBER(int(func(a.text, b.text)), type_=TYPE.ubyte,\n                                lineno=lineno)  # Convert to u8 (boolean)\n\n        if operator in ('BNOT', 'BAND', 'BOR', 'BXOR'):\n            if TYPE.is_decimal(c_type):\n                c_type = TYPE.long_\n\n        if a.type_ != b.type_ and TYPE.string in (a.type_, b.type_):\n            c_type = a.type_  # Will give an error based on the fist operand\n\n        if operator not in ('SHR', 'SHL'):\n            a = SymbolTYPECAST.make_node(c_type, a, lineno)\n            b = SymbolTYPECAST.make_node(c_type, b, lineno)\n\n        if a is None or b is None:\n            return None\n\n        if type_ is None:\n            if operator in ('LT', 'GT', 'EQ', 'LE', 'GE', 'NE', 'AND', 'OR',\n                            'XOR', 'NOT'):\n                type_ = TYPE.ubyte  # Boolean type\n            else:\n                type_ = c_type\n\n        return cls(operator, a, b, type_=type_, lineno=lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_dynamic(self):\n        if self is not self.final:\n            return self.final.is_dynamic\n\n        return any([x.is_dynamic for x in self.children])", "response": "True if this type uses dynamic memory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn signed type or equivalent", "response": "def to_signed(cls, t):\n        \"\"\" Return signed type or equivalent\n        \"\"\"\n        assert isinstance(t, SymbolTYPE)\n        t = t.final\n        assert t.is_basic\n        if cls.is_unsigned(t):\n            return {cls.ubyte: cls.byte_,\n                    cls.uinteger: cls.integer,\n                    cls.ulong: cls.long_}[t]\n        if cls.is_signed(t) or cls.is_decimal(t):\n            return t\n        return cls.unknown"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the entry with the given ID in the given scope. Returns None if not found.", "response": "def get_entry(self, id_, scope=None):\n        \"\"\" Returns the ID entry stored in self.table, starting\n        by the first one. Returns None if not found.\n        If scope is not None, only the given scope is searched.\n        \"\"\"\n        if id_[-1] in DEPRECATED_SUFFIXES:\n            id_ = id_[:-1]  # Remove it\n\n        if scope is not None:\n            assert len(self.table) > scope\n            return self[scope][id_]\n\n        for sc in self:\n            if sc[id_] is not None:\n                return sc[id_]\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef declare(self, id_, lineno, entry):\n        id2 = id_\n        type_ = entry.type_\n\n        if id2[-1] in DEPRECATED_SUFFIXES:\n            id2 = id2[:-1]  # Remove it\n            type_ = symbols.TYPEREF(self.basic_types[SUFFIX_TYPE[id_[-1]]], lineno)  # Overrides type_\n            if entry.type_ is not None and not entry.type_.implicit and type_ != entry.type_:\n                syntax_error(lineno, \"expected type {2} for '{0}', got {1}\".format(id_, entry.type_.name, type_.name))\n\n        # Checks if already declared\n        if self[self.current_scope][id2] is not None:\n            return None\n\n        entry.caseins = OPTIONS.case_insensitive.value\n        self[self.current_scope][id2] = entry\n        entry.name = id2  # Removes DEPRECATED SUFFIXES if any\n\n        if isinstance(entry, symbols.TYPE):\n            return entry  # If it's a type declaration, we're done\n\n        # HINT: The following should be done by the respective callers!\n        # entry.callable = None  # True if function, strings or arrays\n        # entry.class_ = None  # TODO: important\n\n        entry.forwarded = False  # True for a function header\n        entry.mangled = '%s%s%s' % (self.mangle, global_.MANGLE_CHR, entry.name)  # Mangled name\n        entry.type_ = type_  # type_ now reflects entry sigil (i.e. a$ => 'string' type) if any\n        entry.scopeRef = self[self.current_scope]\n\n        return entry", "response": "Check that the id is already declared in the current scope and creates and returns it. If it is a type declaration and the caller function raises the syntax error."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_is_declared(self, id_, lineno, classname='identifier',\n                          scope=None, show_error=True):\n        \"\"\" Checks if the given id is already defined in any scope\n            or raises a Syntax Error.\n\n            Note: classname is not the class attribute, but the name of\n            the class as it would appear on compiler messages.\n        \"\"\"\n        result = self.get_entry(id_, scope)\n        if isinstance(result, symbols.TYPE):\n            return True\n\n        if result is None or not result.declared:\n            if show_error:\n                syntax_error(lineno, 'Undeclared %s \"%s\"' % (classname, id_))\n            return False\n        return True", "response": "Checks if the given id is already declared in any scope."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the given identifier is not already declared. Returns True if OK False otherwise.", "response": "def check_is_undeclared(self, id_, lineno, classname='identifier',\n                            scope=None, show_error=False):\n        \"\"\" The reverse of the above.\n\n        Check the given identifier is not already declared. Returns True\n        if OK, False otherwise.\n        \"\"\"\n        result = self.get_entry(id_, scope)\n        if result is None or not result.declared:\n            return True\n\n        if scope is None:\n            scope = self.current_scope\n\n        if show_error:\n            syntax_error(lineno,\n                         'Duplicated %s \"%s\" (previous one at %s:%i)' %\n                         (classname, id_, self.table[scope][id_].filename,\n                          self.table[scope][id_].lineno))\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_class(self, id_, class_, lineno, scope=None, show_error=True):\n        assert CLASS.is_valid(class_)\n        entry = self.get_entry(id_, scope)\n        if entry is None or entry.class_ == CLASS.unknown:  # Undeclared yet\n            return True\n\n        if entry.class_ != class_:\n            if show_error:\n                if entry.class_ == CLASS.array:\n                    a1 = 'n'\n                else:\n                    a1 = ''\n                if class_ == CLASS.array:\n                    a2 = 'n'\n                else:\n                    a2 = ''\n                syntax_error(lineno, \"identifier '%s' is a%s %s, not a%s %s\" %\n                             (id_, a1, entry.class_, a2, class_))\n            return False\n\n        return True", "response": "Check the class of the given identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enter_scope(self, funcname):\n        old_mangle = self.mangle\n        self.mangle = '%s%s%s' % (self.mangle, global_.MANGLE_CHR, funcname)\n        self.table.append(SymbolTable.Scope(self.mangle, parent_mangle=old_mangle))\n        global_.META_LOOPS.append(global_.LOOPS)  # saves current LOOPS state\n        global_.LOOPS = []", "response": "Enter a new variable scope."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef leave_scope(self):\n        def entry_size(entry):\n            \"\"\" For local variables and params, returns the real variable or\n            local array size in bytes\n            \"\"\"\n            if entry.scope == SCOPE.global_ or \\\n                    entry.is_aliased:  # aliases or global variables = 0\n                return 0\n\n            if entry.class_ != CLASS.array:\n                return entry.size\n\n            return entry.memsize\n\n        for v in self.table[self.current_scope].values(filter_by_opt=False):\n            if not v.accessed:\n                if v.scope == SCOPE.parameter:\n                    kind = 'Parameter'\n                    v.accessed = True  # HINT: Parameters must always be present even if not used!\n                    warning_not_used(v.lineno, v.name, kind=kind)\n\n        entries = sorted(self.table[self.current_scope].values(filter_by_opt=True), key=entry_size)\n        offset = 0\n\n        for entry in entries:  # Symbols of the current level\n            if entry.class_ is CLASS.unknown:\n                self.move_to_global_scope(entry.name)\n\n            if entry.class_ in (CLASS.function, CLASS.label, CLASS.type_):\n                continue\n\n            # Local variables offset\n            if entry.class_ == CLASS.var and entry.scope == SCOPE.local:\n                if entry.alias is not None:  # alias of another variable?\n                    if entry.offset is None:\n                        entry.offset = entry.alias.offset\n                    else:\n                        entry.offset = entry.alias.offset - entry.offset\n                else:\n                    offset += entry_size(entry)\n                    entry.offset = offset\n\n            if entry.class_ == CLASS.array and entry.scope == SCOPE.local:\n                entry.offset = entry_size(entry) + offset\n                offset = entry.offset\n\n        self.mangle = self[self.current_scope].parent_mangle\n        self.table.pop()\n        global_.LOOPS = global_.META_LOOPS.pop()\n        return offset", "response": "Ends a function body and pops current scope out of the symbol table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move_to_global_scope(self, id_):\n        # In the current scope and more than 1 scope?\n        if id_ in self.table[self.current_scope].keys(filter_by_opt=False) and len(self.table) > 1:\n            symbol = self.table[self.current_scope][id_]\n            symbol.offset = None\n            symbol.scope = SCOPE.global_\n            if symbol.class_ != CLASS.label:\n                symbol.mangled = \"%s%s%s\" % (self.table[self.global_scope].mangle, global_.MANGLE_CHR, id_)\n\n            self.table[self.global_scope][id_] = symbol\n            del self.table[self.current_scope][id_]  # Removes it from the current scope\n            __DEBUG__(\"'{}' entry moved to global scope\".format(id_))", "response": "Move the given id to the global scope."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_static(self, id_):\n        entry = self.table[self.current_scope][id_]\n        entry.scope = SCOPE.global_\n        self.table[self.global_scope][entry.mangled] = entry", "response": "Make a static variable in the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses a symbol by its identifier and checks if it exists and if it is an implicit declared variable.", "response": "def access_id(self, id_, lineno, scope=None, default_type=None, default_class=CLASS.unknown):\n        \"\"\" Access a symbol by its identifier and checks if it exists.\n        If not, it's supposed to be an implicit declared variable.\n\n        default_class is the class to use in case of an undeclared-implicit-accessed id\n        \"\"\"\n        if isinstance(default_type, symbols.BASICTYPE):\n            default_type = symbols.TYPEREF(default_type, lineno, implicit=False)\n        assert default_type is None or isinstance(default_type, symbols.TYPEREF)\n\n        if not check_is_declared_explicit(lineno, id_):\n            return None\n\n        result = self.get_entry(id_, scope)\n        if result is None:\n            if default_type is None:\n                default_type = symbols.TYPEREF(self.basic_types[global_.DEFAULT_IMPLICIT_TYPE],\n                                               lineno, implicit=True)\n\n            result = self.declare_variable(id_, lineno, default_type)\n            result.declared = False  # It was implicitly declared\n            result.class_ = default_class\n            return result\n\n        # The entry was already declared. If it's type is auto and the default type is not None,\n        # update its type.\n        if default_type is not None and result.type_ == self.basic_types[TYPE.auto]:\n            result.type_ = default_type\n            warning_implicit_type(lineno, id_, default_type)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef access_var(self, id_, lineno, scope=None, default_type=None):\n        result = self.access_id(id_, lineno, scope, default_type)\n        if result is None:\n            return None\n\n        if not self.check_class(id_, CLASS.var, lineno, scope):\n            return None\n\n        assert isinstance(result, symbols.VAR)\n        result.class_ = CLASS.var\n\n        return result", "response": "Access a variable in the current context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef access_array(self, id_, lineno, scope=None, default_type=None):\n        if not self.check_is_declared(id_, lineno, 'array', scope):\n            return None\n\n        if not self.check_class(id_, CLASS.array, lineno, scope):\n            return None\n\n        return self.access_id(id_, lineno, scope=scope, default_type=default_type)", "response": "Called when an accessed variable is expected to be an array. Returns the object that is used to access the array."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naccess a function in the current scope.", "response": "def access_func(self, id_, lineno, scope=None, default_type=None):\n        \"\"\"\n        Since ZX BASIC allows access to undeclared functions, we must allow\n        and *implicitly* declare them if they are not declared already.\n        This function just checks if the id_ exists and returns its entry if so.\n        Otherwise, creates an implicit declared variable entry and returns it.\n        \"\"\"\n        assert default_type is None or isinstance(default_type, symbols.TYPEREF)\n\n        result = self.get_entry(id_, scope)\n        if result is None:\n            if default_type is None:\n                if global_.DEFAULT_IMPLICIT_TYPE == TYPE.auto:\n                    default_type = symbols.TYPEREF(self.basic_types[TYPE.auto], lineno, implicit=True)\n                else:\n                    default_type = symbols.TYPEREF(self.basic_types[global_.DEFAULT_TYPE], lineno, implicit=True)\n\n            return self.declare_func(id_, lineno, default_type)\n\n        if not self.check_class(id_, CLASS.function, lineno, scope):\n            return None\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a func array or string call. Checks if id is callable or not. Returns None if it is not callable.", "response": "def access_call(self, id_, lineno, scope=None, type_=None):\n        \"\"\" Creates a func/array/string call. Checks if id is callable or not.\n        An identifier is \"callable\" if it can be followed by a list of para-\n        meters.\n        This does not mean the id_ is a function, but that it allows the same\n        syntax a function does:\n\n        For example:\n           - MyFunction(a, \"hello\", 5) is a Function so MyFuncion is callable\n           - MyArray(5, 3.7, VAL(\"32\")) makes MyArray identifier \"callable\".\n           - MyString(5 TO 7) or MyString(5) is a \"callable\" string.\n        \"\"\"\n        entry = self.access_id(id_, lineno, scope, default_type=type_)\n        if entry is None:\n            return self.access_func(id_, lineno)\n\n        if entry.callable is False:  # Is it NOT callable?\n            if entry.type_ != self.basic_types[TYPE.string]:\n                syntax_error_not_array_nor_func(lineno, id_)\n                return None\n            else:  # Ok, it is a string slice if it has 0 or 1 parameters\n                return entry\n\n        if entry.callable is None and entry.type_ == self.basic_types[TYPE.string]:\n            # Ok, it is a string slice if it has 0 or 1 parameters\n            entry.callable = False\n            return entry\n\n        # Mangled name (functions always has _name as mangled)\n        # entry.mangled = '_%s' % entry.name\n        # entry.callable = True  # HINT: must be true already\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef declare_variable(self, id_, lineno, type_, default_value=None):\n        assert isinstance(type_, symbols.TYPEREF)\n        if not self.check_is_undeclared(id_, lineno, scope=self.current_scope, show_error=False):\n            entry = self.get_entry(id_)\n            if entry.scope == SCOPE.parameter:\n                syntax_error(lineno,\n                             \"Variable '%s' already declared as a parameter \"\n                             \"at %s:%i\" % (id_, entry.filename, entry.lineno))\n            else:\n                syntax_error(lineno, \"Variable '%s' already declared at \"\n                                     \"%s:%i\" % (id_, entry.filename, entry.lineno))\n            return None\n\n        if not self.check_class(id_, CLASS.var, lineno, scope=self.current_scope):\n            return None\n\n        entry = (self.get_entry(id_, scope=self.current_scope) or\n                 self.declare(id_, lineno, symbols.VAR(id_, lineno, class_=CLASS.var)))\n        __DEBUG__(\"Entry %s declared with class %s at scope %i\" % (entry.name, CLASS.to_string(entry.class_),\n                                                                   self.current_scope))\n\n        if entry.type_ is None or entry.type_ == self.basic_types[TYPE.unknown]:\n            entry.type_ = type_\n\n        if entry.type_ != type_:\n            if not type_.implicit and entry.type_ is not None:\n                syntax_error(lineno,\n                             \"'%s' suffix is for type '%s' but it was \"\n                             \"declared as '%s'\" %\n                             (id_, entry.type_, type_))\n                return None\n                # type_ = entry.type_  # TODO: Unused??\n\n        entry.scope = SCOPE.global_ if self.current_scope == self.global_scope else SCOPE.local\n        entry.callable = False\n        entry.class_ = CLASS.var  # HINT: class_ attribute could be erased if access_id was used.\n        entry.declared = True  # marks it as declared\n\n        if entry.type_.implicit and entry.type_ != self.basic_types[TYPE.unknown]:\n            warning_implicit_type(lineno, id_, entry.type_.name)\n\n        if default_value is not None and entry.type_ != default_value.type_:\n            if is_number(default_value):\n                default_value = symbols.TYPECAST.make_node(entry.type_, default_value,\n                                                           lineno)\n                if default_value is None:\n                    return None\n            else:\n                syntax_error(lineno,\n                             \"Variable '%s' declared as '%s' but initialized \"\n                             \"with a '%s' value\" %\n                             (id_, entry.type_, default_value.type_))\n                return None\n\n        entry.default_value = default_value\n        return entry", "response": "This method declares a variable in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef declare_type(self, type_):\n        assert isinstance(type_, symbols.TYPE)\n        # Checks it's not a basic type\n        if not type_.is_basic and type_.name.lower() in TYPE.TYPE_NAMES.values():\n            syntax_error(type_.lineno, \"'%s' is a basic type and cannot be redefined\" %\n                         type_.name)\n            return None\n\n        if not self.check_is_undeclared(type_.name, type_.lineno, scope=self.current_scope, show_error=True):\n            return None\n\n        entry = self.declare(type_.name, type_.lineno, type_)\n        return entry", "response": "Declares a type. Checks that the given type is not already declared in the current scope and that it s not a basic type. Returns the type_ Symbol or None on error."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef declare_label(self, id_, lineno):\n        # TODO: consider to make labels private\n        id1 = id_\n        id_ = str(id_)\n\n        if not self.check_is_undeclared(id_, lineno, 'label'):\n            entry = self.get_entry(id_)\n            syntax_error(lineno, \"Label '%s' already used at %s:%i\" %\n                         (id_, entry.filename, entry.lineno))\n            return entry\n\n        entry = self.get_entry(id_)\n        if entry is not None and entry.declared:\n            if entry.is_line_number:\n                syntax_error(lineno, \"Duplicated line number '%s'. \"\n                                     \"Previous was at %i\" % (entry.name, entry.lineno))\n            else:\n                syntax_error(lineno, \"Label '%s' already declared at line %i\" %\n                             (id_, entry.lineno))\n            return None\n\n        entry = (self.get_entry(id_, scope=self.current_scope) or\n                 self.get_entry(id_, scope=self.global_scope) or\n                 self.declare(id_, lineno, symbols.LABEL(id_, lineno)))\n        if entry is None:\n            return None\n\n        if not isinstance(entry, symbols.LABEL):\n            entry = symbols.VAR.to_label(entry)\n\n        if id_[0] == '.':\n            id_ = id_[1:]\n            # HINT: ??? Mangled name. Just the label, 'cause it starts with '.'\n            entry.mangled = '%s' % id_\n        else:\n            # HINT: Mangled name. Labels are __LABEL__\n            entry.mangled = '__LABEL__%s' % entry.name\n\n        entry.is_line_number = isinstance(id1, int)\n\n        if global_.FUNCTION_LEVEL:\n            entry.scope_owner = list(global_.FUNCTION_LEVEL)\n\n        self.move_to_global_scope(id_)  # Labels are always global # TODO: not in the future\n        entry.declared = True\n        entry.type_ = self.basic_types[global_.PTR_TYPE]\n        return entry", "response": "Declares a label (line numbers are also labels).\n            Unlike variables, labels are always global."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef declare_param(self, id_, lineno, type_=None):\n        if not self.check_is_undeclared(id_, lineno, classname='parameter',\n                                        scope=self.current_scope, show_error=True):\n            return None\n\n        entry = self.declare(id_, lineno, symbols.PARAMDECL(id_, lineno, type_))\n        if entry is None:\n            return\n        entry.declared = True\n        if entry.type_.implicit:\n            warning_implicit_type(lineno, id_, type_)\n        return entry", "response": "Declares a parameter\n        Check if entry.declared is False. Otherwise raises an error."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndeclare an array in the symbol table. Error if already exists.", "response": "def declare_array(self, id_, lineno, type_, bounds, default_value=None):\n        \"\"\" Declares an array in the symbol table (VARARRAY). Error if already\n        exists.\n        \"\"\"\n        assert isinstance(type_, symbols.TYPEREF)\n        assert isinstance(bounds, symbols.BOUNDLIST)\n\n        if not self.check_class(id_, CLASS.array, lineno, scope=self.current_scope):\n            return None\n\n        entry = self.get_entry(id_, self.current_scope)\n        if entry is None:\n            entry = self.declare(id_, lineno, symbols.VARARRAY(id_, bounds, lineno, type_=type_))\n\n        if not entry.declared:\n            if entry.callable:\n                syntax_error(lineno,\n                             \"Array '%s' must be declared before use. \"\n                             \"First used at line %i\" %\n                             (id_, entry.lineno))\n                return None\n        else:\n            if entry.scope == SCOPE.parameter:\n                syntax_error(lineno, \"variable '%s' already declared as a \"\n                                     \"parameter at line %i\" % (id_, entry.lineno))\n            else:\n                syntax_error(lineno, \"variable '%s' already declared at \"\n                                     \"line %i\" % (id_, entry.lineno))\n            return None\n\n        if entry.type_ != self.basic_types[TYPE.unknown] and entry.type_ != type_:\n            if not type_.implicit:\n                syntax_error(lineno, \"Array suffix for '%s' is for type '%s' \"\n                                     \"but declared as '%s'\" %\n                             (entry.name, entry.type_, type_))\n                return None\n\n            type_.implicit = False\n            type_ = entry.type_\n\n        if type_.implicit:\n            warning_implicit_type(lineno, id_, type_)\n\n        if not isinstance(entry, symbols.VARARRAY):\n            entry = symbols.VAR.to_vararray(entry, bounds)\n\n        entry.declared = True\n        entry.type_ = type_\n        entry.scope = SCOPE.global_ if self.current_scope == self.global_scope else SCOPE.local\n        entry.default_value = default_value\n        entry.callable = True\n        entry.class_ = CLASS.array\n        entry.lbound_used = entry.ubound_used = False  # Flag to true when LBOUND/UBOUND used somewhere in the code\n\n        __DEBUG__('Entry %s declared with class %s at scope %i' % (id_, CLASS.to_string(entry.class_),\n                                                                   self.current_scope))\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef declare_func(self, id_, lineno, type_=None):\n        if not self.check_class(id_, 'function', lineno):\n            entry = self.get_entry(id_)  # Must not exist or have _class = None or Function and declared = False\n            an = 'an' if entry.class_.lower()[0] in 'aeio' else 'a'\n            syntax_error(lineno, \"'%s' already declared as %s %s at %i\" % (id_, an, entry.class_, entry.lineno))\n            return None\n\n        entry = self.get_entry(id_)  # Must not exist or have _class = None or Function and declared = False\n        if entry is not None:\n            if entry.declared and not entry.forwarded:\n                syntax_error(lineno, \"Duplicate function name '%s', previously defined at %i\" % (id_, entry.lineno))\n                return None\n\n            if entry.class_ != CLASS.unknown and entry.callable is False:  # HINT: Must use is False here.\n                syntax_error_not_array_nor_func(lineno, id_)\n                return None\n\n            if id_[-1] in DEPRECATED_SUFFIXES and entry.type_ != self.basic_types[SUFFIX_TYPE[id_[-1]]]:\n                syntax_error_func_type_mismatch(lineno, entry)\n\n            if entry.token == 'VAR':  # This was a function used in advance\n                symbols.VAR.to_function(entry, lineno=lineno)\n            entry.mangled = '%s_%s' % (self.mangle, entry.name)  # HINT: mangle for nexted scopes\n        else:\n            entry = self.declare(id_, lineno, symbols.FUNCTION(id_, lineno, type_=type_))\n\n        if entry.forwarded:\n            entry.forwared = False  # No longer forwarded\n            old_type = entry.type_  # Remembers the old type\n            if entry.type_ is not None:\n                if entry.type_ != old_type:\n                    syntax_error_func_type_mismatch(lineno, entry)\n            else:\n                entry.type_ = old_type\n        else:\n            entry.params_size = 0  # Size of parameters\n\n        entry.locals_size = 0  # Size of local variables\n        return entry", "response": "Declares a function in the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if all the labels have been declared", "response": "def check_labels(self):\n        \"\"\" Checks if all the labels has been declared\n        \"\"\"\n        for entry in self.labels:\n            self.check_is_declared(entry.name, entry.lineno, CLASS.label)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_classes(self, scope=-1):\n        for entry in self[scope].values():\n            if entry.class_ is None:\n                syntax_error(entry.lineno, \"Unknown identifier '%s'\" % entry.name)", "response": "Check if pending identifiers are defined or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of symbol instances corresponding to variables in the current scope.", "response": "def vars_(self):\n        \"\"\" Returns symbol instances corresponding to variables\n        of the current scope.\n        \"\"\"\n        return [x for x in self[self.current_scope].values() if x.class_ == CLASS.var]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef labels(self):\n        return [x for x in self[self.current_scope].values() if x.class_ == CLASS.label]", "response": "Returns a list of symbol instances corresponding to labels in the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all types that are defined in the current scope.", "response": "def types(self):\n        \"\"\" Returns symbol instances corresponding to type declarations\n        within the current scope.\n        \"\"\"\n        return [x for x in self[self.current_scope].values() if isinstance(x, symbols.TYPE)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef arrays(self):\n        return [x for x in self[self.current_scope].values() if x.class_ == CLASS.array]", "response": "Returns a list of symbol instances corresponding to arrays in the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of symbol instances corresponding to functions in the current scope.", "response": "def functions(self):\n        \"\"\" Returns symbol instances corresponding to functions\n        of the current scope.\n        \"\"\"\n        return [x for x in self[self.current_scope].values() if x.class_ in\n                (CLASS.function, CLASS.sub)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef aliases(self):\n        return [x for x in self[self.current_scope].values() if x.is_aliased]", "response": "Returns a list of symbol instances corresponding to aliased vars."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking arg s type is one in type_list otherwise raises an error.", "response": "def check_type(lineno, type_list, arg):\n    \"\"\" Check arg's type is one in type_list, otherwise,\n    raises an error.\n    \"\"\"\n    if not isinstance(type_list, list):\n        type_list = [type_list]\n\n    if arg.type_ in type_list:\n        return True\n\n    if len(type_list) == 1:\n        syntax_error(lineno, \"Wrong expression type '%s'. Expected '%s'\" %\n                     (arg.type_, type_list[0]))\n    else:\n        syntax_error(lineno, \"Wrong expression type '%s'. Expected one of '%s'\"\n                     % (arg.type_, tuple(type_list)))\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_is_declared_explicit(lineno, id_, classname='variable'):\n    if not config.OPTIONS.explicit.value:\n        return True\n\n    entry = global_.SYMBOL_TABLE.check_is_declared(id_, lineno, classname)\n    return entry is not None", "response": "Check if the current ID is already declared."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_call_arguments(lineno, id_, args):\n    if not global_.SYMBOL_TABLE.check_is_declared(id_, lineno, 'function'):\n        return False\n\n    if not global_.SYMBOL_TABLE.check_class(id_, CLASS.function, lineno):\n        return False\n\n    entry = global_.SYMBOL_TABLE.get_entry(id_)\n\n    if len(args) != len(entry.params):\n        c = 's' if len(entry.params) != 1 else ''\n        syntax_error(lineno, \"Function '%s' takes %i parameter%s, not %i\" %\n                     (id_, len(entry.params), c, len(args)))\n        return False\n\n    for arg, param in zip(args, entry.params):\n        if not arg.typecast(param.type_):\n            return False\n\n        if param.byref:\n            from symbols.var import SymbolVAR\n            if not isinstance(arg.value, SymbolVAR):\n                syntax_error(lineno, \"Expected a variable name, not an \"\n                                     \"expression (parameter By Reference)\")\n                return False\n\n            if arg.class_ not in (CLASS.var, CLASS.array):\n                syntax_error(lineno, \"Expected a variable or array name \"\n                                     \"(parameter By Reference)\")\n                return False\n\n            arg.byref = True\n\n    if entry.forwarded:  # The function / sub was DECLARED but not implemented\n        syntax_error(lineno, \"%s '%s' declared but not implemented\" % (CLASS.to_string(entry.class_), entry.name))\n        return False\n\n    return True", "response": "Checks the arguments in a function call against a function signature. Returns True on success Returns False on error"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_pending_calls():\n    result = True\n\n    # Check for functions defined after calls (parametres, etc)\n    for id_, params, lineno in global_.FUNCTION_CALLS:\n        result = result and check_call_arguments(lineno, id_, params)\n\n    return result", "response": "Checks if any pending calls are made to the current scope\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the given AST has pending labels.", "response": "def check_pending_labels(ast):\n    \"\"\" Iteratively traverses the node looking for ID with no class set,\n    marks them as labels, and check they've been declared.\n\n    This way we avoid stack overflow for high line-numbered listings.\n    \"\"\"\n    result = True\n    visited = set()\n    pending = [ast]\n\n    while pending:\n        node = pending.pop()\n\n        if node is None or node in visited:  # Avoid recursive infinite-loop\n            continue\n\n        visited.add(node)\n        for x in node.children:\n            pending.append(x)\n\n        if node.token != 'VAR' or (node.token == 'VAR' and node.class_ is not CLASS.unknown):\n            continue\n\n        tmp = global_.SYMBOL_TABLE.get_entry(node.name)\n        if tmp is None or tmp.class_ is CLASS.unknown:\n            syntax_error(node.lineno, 'Undeclared identifier \"%s\"'\n                         % node.name)\n        else:\n            assert tmp.class_ == CLASS.label\n            node.to_label(node)\n\n        result = result and tmp is not None\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the given label is valid and returns a label object.", "response": "def check_and_make_label(lbl, lineno):\n    \"\"\" Checks if the given label (or line number) is valid and, if so,\n    returns a label object.\n    :param lbl: Line number of label (string)\n    :param lineno: Line number in the basic source code for error reporting\n    :return: Label object or None if error.\n    \"\"\"\n    if isinstance(lbl, float):\n        if lbl == int(lbl):\n            id_ = str(int(lbl))\n        else:\n            syntax_error(lineno, 'Line numbers must be integers.')\n            return None\n    else:\n        id_ = lbl\n\n    return global_.SYMBOL_TABLE.access_label(id_, lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_null(*symbols):\n    from symbols.symbol_ import Symbol\n\n    for sym in symbols:\n        if sym is None:\n            continue\n        if not isinstance(sym, Symbol):\n            return False\n        if sym.token == 'NOP':\n            continue\n        if sym.token == 'BLOCK':\n            if not is_null(*sym.children):\n                return False\n            continue\n        return False\n    return True", "response": "True if no nodes or all the given nodes are either NOP or empty blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_SYMBOL(token, *symbols):\n    from symbols.symbol_ import Symbol\n    assert all(isinstance(x, Symbol) for x in symbols)\n    for sym in symbols:\n        if sym.token != token:\n            return False\n\n    return True", "response": "Returns True if all of the given argument are AST nodes of the given token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_const(*p):\n    return is_SYMBOL('VAR', *p) and all(x.class_ == CLASS.const for x in p)", "response": "A constant in the program."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if ALL of the arguments are AST nodes containing NUMBER or numeric CONSTANTS", "response": "def is_number(*p):\n    \"\"\" Returns True if ALL of the arguments are AST nodes\n    containing NUMBER or numeric CONSTANTS\n    \"\"\"\n    try:\n        for i in p:\n            if i.token != 'NUMBER' and (i.token != 'ID' or i.class_ != CLASS.const):\n                return False\n\n        return True\n    except:\n        pass\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_unsigned(*p):\n    from symbols.type_ import Type\n\n    try:\n        for i in p:\n            if not i.type_.is_basic or not Type.is_unsigned(i.type_):\n                return False\n\n        return True\n    except:\n        pass\n\n    return False", "response": "Returns true if all types in p are unsigned"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_type(type_, *p):\n    try:\n        for i in p:\n            if i.type_ != type_:\n                return False\n\n        return True\n    except:\n        pass\n\n    return False", "response": "True if all args have the same type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntrues if all args are dynamic", "response": "def is_dynamic(*p):  # TODO: Explain this better\n    \"\"\" True if all args are dynamic (e.g. Strings, dynamic arrays, etc)\n    The use a ptr (ref) and it might change during runtime.\n    \"\"\"\n    from symbols.type_ import Type\n\n    try:\n        for i in p:\n            if i.scope == SCOPE.global_ and i.is_basic and \\\n                    i.type_ != Type.string:\n                return False\n\n        return True\n    except:\n        pass\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrue if all the args are functions and / or subroutines.", "response": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if a block is accessed.", "response": "def is_block_accessed(block):\n    \"\"\" Returns True if a block is \"accessed\". A block of code is accessed if\n    it has a LABEL and it is used in a GOTO, GO SUB or @address access\n    :param block: A block of code (AST node)\n    :return: True / False depending if it has labels accessed or not\n    \"\"\"\n    if is_LABEL(block) and block.accessed:\n        return True\n\n    for child in block.children:\n        if not is_callable(child) and is_block_accessed(child):\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef common_type(a, b):\n    from symbols.type_ import SymbolBASICTYPE as BASICTYPE\n    from symbols.type_ import Type as TYPE\n    from symbols.type_ import SymbolTYPE\n\n    if a is None or b is None:\n        return None\n\n    if not isinstance(a, SymbolTYPE):\n        a = a.type_\n\n    if not isinstance(b, SymbolTYPE):\n        b = b.type_\n\n    if a == b:  # Both types are the same?\n        return a  # Returns it\n\n    if a == TYPE.unknown and b == TYPE.unknown:\n        return BASICTYPE(global_.DEFAULT_TYPE)\n\n    if a == TYPE.unknown:\n        return b\n\n    if b == TYPE.unknown:\n        return a\n\n    # TODO: This will removed / expanded in the future\n    assert a.is_basic\n    assert b.is_basic\n\n    types = (a, b)\n\n    if TYPE.float_ in types:\n        return TYPE.float_\n\n    if TYPE.fixed in types:\n        return TYPE.fixed\n\n    if TYPE.string in types:  # TODO: Check this ??\n        return TYPE.unknown\n\n    result = a if a.size > b.size else b\n\n    if not TYPE.is_unsigned(a) or not TYPE.is_unsigned(b):\n        result = TYPE.to_signed(result)\n\n    return result", "response": "Returns a type which is common for both a and b types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfilter the output removing useless preprocessor directives and writes it to the given file or to the screen.", "response": "def output(memory, ofile=None):\n    \"\"\" Filters the output removing useless preprocessor #directives\n    and writes it to the given file or to the screen if no file is passed\n    \"\"\"\n    for m in memory:\n        m = m.rstrip('\\r\\n\\t ')  # Ensures no trailing newlines (might with upon includes)\n        if m and m[0] == '#':  # Preprocessor directive?\n            if ofile is None:\n                print(m)\n            else:\n                ofile.write('%s\\n' % m)\n            continue\n\n        # Prints a 4 spaces \"tab\" for non labels\n        if m and ':' not in m:\n            if ofile is None:\n                print('    '),\n            else:\n                ofile.write('\\t')\n\n        if ofile is None:\n            print(m)\n        else:\n            ofile.write('%s\\n' % m)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _16bit_oper(op1, op2=None, reversed=False):\n    ''' Returns pop sequence for 16 bits operands\n    1st operand in HL, 2nd operand in DE\n\n    For subtraction, division, etc. you can swap operators extraction order\n    by setting reversed to True\n    '''\n    output = []\n\n    if op1 is not None:\n        op1 = str(op1)  # always to str\n\n    if op2 is not None:\n        op2 = str(op2)  # always to str\n\n    if op2 is not None and reversed:\n        op1, op2 = op2, op1\n\n    op = op1\n    indirect = (op[0] == '*')\n    if indirect:\n        op = op[1:]\n\n    immediate = (op[0] == '#')\n    if immediate:\n        op = op[1:]\n\n    if is_int(op):\n        op = int(op)\n\n        if indirect:\n            output.append('ld hl, (%i)' % op)\n        else:\n            output.append('ld hl, %i' % int16(op))\n    else:\n        if immediate:\n            if indirect:\n                output.append('ld hl, (%s)' % op)\n            else:\n                output.append('ld hl, %s' % op)\n        else:\n            if op[0] == '_':\n                output.append('ld hl, (%s)' % op)\n            else:\n                output.append('pop hl')\n\n            if indirect:\n                output.append('ld a, (hl)')\n                output.append('inc hl')\n                output.append('ld h, (hl)')\n                output.append('ld l, a')\n\n    if op2 is None:\n        return output\n\n    if not reversed:\n        tmp = output\n        output = []\n\n    op = op2\n    indirect = (op[0] == '*')\n    if indirect:\n        op = op[1:]\n\n    immediate = (op[0] == '#')\n    if immediate:\n        op = op[1:]\n\n    if is_int(op):\n        op = int(op)\n\n        if indirect:\n            output.append('ld de, (%i)' % op)\n        else:\n            output.append('ld de, %i' % int16(op))\n    else:\n        if immediate:\n            output.append('ld de, %s' % op)\n        else:\n            if op[0] == '_':\n                output.append('ld de, (%s)' % op)\n            else:\n                output.append('pop de')\n\n            if indirect:\n                output.append('call __LOAD_DE_DE')  # DE = (DE)\n                REQUIRES.add('lddede.asm')\n\n    if not reversed:\n        output.extend(tmp)\n\n    return output", "response": "Returns pop sequence for 16 bits operands in HL 2nd operand in DE"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the last 2 bytes of the stack and adds them to the stack.", "response": "def _add16(ins):\n    ''' Pops last 2 bytes from the stack and adds them.\n    Then push the result onto the stack.\n\n\n    Optimizations:\n      * If any of the operands is ZERO,\n        then do NOTHING: A + 0 = 0 + A = A\n\n      * If any of the operands is < 4, then\n        INC is used\n\n      * If any of the operands is > (65531) (-4), then\n        DEC is used\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n    if _int_ops(op1, op2) is not None:\n        op1, op2 = _int_ops(op1, op2)\n        op2 = int16(op2)\n        output = _16bit_oper(op1)\n\n        if op2 == 0:\n            output.append('push hl')\n            return output  # ADD HL, 0 => NOTHING\n\n        if op2 < 4:\n            output.extend(['inc hl'] * op2)  # ADD HL, 2 ==> inc hl; inc hl\n            output.append('push hl')\n            return output\n\n        if op2 > 65531:  # (between -4 and 0)\n            output.extend(['dec hl'] * (0x10000 - op2))\n            output.append('push hl')\n            return output\n\n        output.append('ld de, %i' % op2)\n        output.append('add hl, de')\n        output.append('push hl')\n        return output\n\n    if op2[0] == '_':  # stack optimization\n        op1, op2 = op2, op1\n\n    output = _16bit_oper(op1, op2)\n    output.append('add hl, de')\n    output.append('push hl')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sub16(ins):\n    ''' Pops last 2 words from the stack and subtract them.\n    Then push the result onto the stack. Top of the stack is\n    subtracted Top -1\n\n    Optimizations:\n      * If 2nd op is ZERO,\n        then do NOTHING: A - 0 = A\n\n      * If any of the operands is < 4, then\n        DEC is used\n\n      * If any of the operands is > 65531 (-4..-1), then\n        INC is used\n    '''\n    op1, op2 = tuple(ins.quad[2:4])\n\n    if is_int(op2):\n        op = int16(op2)\n        output = _16bit_oper(op1)\n\n        if op == 0:\n            output.append('push hl')\n            return output\n\n        if op < 4:\n            output.extend(['dec hl'] * op)\n            output.append('push hl')\n            return output\n\n        if op > 65531:\n            output.extend(['inc hl'] * (0x10000 - op))\n            output.append('push hl')\n            return output\n\n        output.append('ld de, -%i' % op)\n        output.append('add hl, de')\n        output.append('push hl')\n        return output\n\n    if op2[0] == '_':  # Optimization when 2nd operand is an id\n        rev = True\n        op1, op2 = op2, op1\n    else:\n        rev = False\n\n    output = _16bit_oper(op1, op2, rev)\n    output.append('or a')\n    output.append('sbc hl, de')\n    output.append('push hl')\n    return output", "response": "Sub16 operation for internal use only."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _mul16(ins):\n    ''' Multiplies tow last 16bit values on top of the stack and\n    and returns the value on top of the stack\n\n    Optimizations:\n      * If any of the ops is ZERO,\n        then do A = 0 ==> XOR A, cause A * 0 = 0 * A = 0\n\n      * If any ot the ops is ONE, do NOTHING\n        A * 1 = 1 * A = A\n\n      * If B is 2^n and B < 16 => Shift Right n\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n    if _int_ops(op1, op2) is not None:   # If any of the operands is constant\n        op1, op2 = _int_ops(op1, op2)    # put the constant one the 2nd\n        output = _16bit_oper(op1)\n\n        if op2 == 0:  # A * 0 = 0 * A = 0\n            if op1[0] in ('_', '$'):\n                output = []  # Optimization: Discard previous op if not from the stack\n            output.append('ld hl, 0')\n            output.append('push hl')\n            return output\n\n        if op2 == 1:  # A * 1 = 1 * A == A => Do nothing\n            output.append('push hl')\n            return output\n\n        if op2 == 0xFFFF:  # This is the same as (-1)\n            output.append('call __NEGHL')\n            output.append('push hl')\n            REQUIRES.add('neg16.asm')\n            return output\n\n        if is_2n(op2) and log2(op2) < 4:\n            output.extend(['add hl, hl'] * int(log2(op2)))\n            output.append('push hl')\n            return output\n\n        output.append('ld de, %i' % op2)\n    else:\n        if op2[0] == '_':  # stack optimization\n            op1, op2 = op2, op1\n\n        output = _16bit_oper(op1, op2)\n\n    output.append('call __MUL16_FAST')  # Inmmediate\n    output.append('push hl')\n    REQUIRES.add('mul16.asm')\n    return output", "response": "Multiplies tow last 16bit values on top of the stack and returns the value on top of the stack and\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndividing 2 16bit unsigned integers. The result is pushed onto the stack.", "response": "def _divu16(ins):\n    ''' Divides 2 16bit unsigned integers. The result is pushed onto the stack.\n\n    Optimizations:\n      * If 2nd op is 1 then\n        do nothing\n\n      * If 2nd op is 2 then\n        Shift Right Logical\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n    if is_int(op1) and int(op1) == 0:  # 0 / A = 0\n        if op2[0] in ('_', '$'):\n            output = []  # Optimization: Discard previous op if not from the stack\n        else:\n            output = _16bit_oper(op2)  # Normalize stack\n\n        output.append('ld hl, 0')\n        output.append('push hl')\n        return output\n\n    if is_int(op2):\n        op = int16(op2)\n        output = _16bit_oper(op1)\n\n        if op2 == 0:  # A * 0 = 0 * A = 0\n            if op1[0] in ('_', '$'):\n                output = []  # Optimization: Discard previous op if not from the stack\n            output.append('ld hl, 0')\n            output.append('push hl')\n            return output\n\n        if op == 1:\n            output.append('push hl')\n            return output\n\n        if op == 2:\n            output.append('srl h')\n            output.append('rr l')\n            output.append('push hl')\n            return output\n\n        output.append('ld de, %i' % op)\n    else:\n        if op2[0] == '_':  # Optimization when 2nd operand is an id\n            rev = True\n            op1, op2 = op2, op1\n        else:\n            rev = False\n        output = _16bit_oper(op1, op2, rev)\n\n    output.append('call __DIVU16')\n    output.append('push hl')\n    REQUIRES.add('div16.asm')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a 16bit unsigned integer array.", "response": "def _modu16(ins):\n    ''' Reminder of div. 2 16bit unsigned integers. The result is pushed onto the stack.\n\n        Optimizations:\n         * If 2nd operand is 1 => Return 0\n         * If 2nd operand = 2^n => do AND (2^n - 1)\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n\n    if is_int(op2):\n        op2 = int16(op2)\n        output = _16bit_oper(op1)\n\n        if op2 == 1:\n            if op2[0] in ('_', '$'):\n                output = []  # Optimization: Discard previous op if not from the stack\n\n            output.append('ld hl, 0')\n            output.append('push hl')\n            return output\n\n        if is_2n(op2):\n            k = op2 - 1\n            if op2 > 255:  # only affects H\n                output.append('ld a, h')\n                output.append('and %i' % (k >> 8))\n                output.append('ld h, a')\n            else:\n                output.append('ld h, 0')  # High part goes 0\n                output.append('ld a, l')\n                output.append('and %i' % (k % 0xFF))\n                output.append('ld l, a')\n\n            output.append('push hl')\n            return output\n\n        output.append('ld de, %i' % op2)\n    else:\n        output = _16bit_oper(op1, op2)\n\n    output.append('call __MODU16')\n    output.append('push hl')\n    REQUIRES.add('div16.asm')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _ltu16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand < 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit unsigned version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('or a')\n    output.append('sbc hl, de')\n    output.append('sbc a, a')\n    output.append('push af')\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand < 2nd operand. Returns the instruction to be pushed onto the stack."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomparing top 2 operands out of the stack and checks if the 1st operand < 2nd operand. Returns a new stack with the operands pushed onto the stack.", "response": "def _lti16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand < 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit signed version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('call __LTI16')\n    output.append('push af')\n    REQUIRES.add('lti16.asm')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing top 2 operands out of the stack and checks if the 1st operand > 2nd operand. Returns a new string in the stack.", "response": "def _gtu16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand > 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit unsigned version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3], reversed=True)\n    output.append('or a')\n    output.append('sbc hl, de')\n    output.append('sbc a, a')\n    output.append('push af')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _gti16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand > 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit signed version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3], reversed=True)\n    output.append('call __LTI16')\n    output.append('push af')\n    REQUIRES.add('lti16.asm')\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand > 2nd operand. Returns a new stack with the operands pushed onto the stack."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _leu16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand <= 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit unsigned version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3], reversed=True)\n    output.append('or a')\n    output.append('sbc hl, de')  # Carry if A > B\n    output.append('ccf')  # Negates the result => Carry if A <= B\n    output.append('sbc a, a')\n    output.append('push af')\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand < 2nd operand. Returns a new string with the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _lei16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand <= 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit signed version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('call __LEI16')\n    output.append('push af')\n    REQUIRES.add('lei16.asm')\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand < 2nd operand. Returns the new stack."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _geu16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand >= 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit unsigned version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('or a')\n    output.append('sbc hl, de')\n    output.append('ccf')\n    output.append('sbc a, a')\n    output.append('push af')\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand > 2nd operand. Returns a new string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _eq16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand == 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit un/signed version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('call __EQ16')\n    output.append('push af')\n    REQUIRES.add('eq16.asm')\n\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        if the 1st operand == 2nd operand. Returns a new stack with the operands pushed onto the stack."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _ne16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand != 2nd operand (top of the stack).\n        Pushes 0 if False, 1 if True.\n\n        16 bit un/signed version\n    '''\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('or a')  # Resets carry flag\n    output.append('sbc hl, de')\n    output.append('ld a, h')\n    output.append('or l')\n    output.append('push af')\n\n    return output", "response": "Compares top 2 operands out of the stack and checks\n        16 bit unsigned version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomparing 2 operands and returns either 0 if False 1 if True.", "response": "def _or16(ins):\n    ''' Compares & pops top 2 operands out of the stack, and checks\n        if the 1st operand OR (logical) 2nd operand (top of the stack),\n        pushes 0 if False, 1 if True.\n\n        16 bit un/signed version\n\n        Optimizations:\n\n        If any of the operators are constants: Returns either 0 or\n        the other operand\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n\n    if _int_ops(op1, op2) is not None:\n        op1, op2 = _int_ops(op1, op2)\n\n        if op2 == 0:\n            output = _16bit_oper(op1)\n            output.append('ld a, h')\n            output.append('or l')  # Convert x to Boolean\n            output.append('push af')\n            return output  # X or False = X\n\n        output = _16bit_oper(op1)\n        output.append('ld a, 0FFh')  # X or True = True\n        output.append('push af')\n        return output\n\n    output = _16bit_oper(ins.quad[2], ins.quad[3])\n    output.append('ld a, h')\n    output.append('or l')\n    output.append('or d')\n    output.append('or e')\n    output.append('push af')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npops top 2 operands out of the stack, and performs 1st operand OR (bitwise) 2nd operand (top of the stack), pushes result (16 bit in HL). 16 bit un/signed version Optimizations: If any of the operators are constants: Returns either 0 or the other operand", "response": "def _bor16(ins):\n    ''' Pops top 2 operands out of the stack, and performs\n        1st operand OR (bitwise) 2nd operand (top of the stack),\n        pushes result (16 bit in HL).\n\n        16 bit un/signed version\n\n        Optimizations:\n\n        If any of the operators are constants: Returns either 0 or\n        the other operand\n    '''\n    op1, op2 = tuple(ins.quad[2:])\n\n    if _int_ops(op1, op2) is not None:\n        op1, op2 = _int_ops(op1, op2)\n\n        output = _16bit_oper(op1)\n        if op2 == 0:  # X | 0 = X\n            output.append('push hl')\n            return output\n\n        if op2 == 0xFFFF:  # X & 0xFFFF = 0xFFFF\n            output.append('ld hl, 0FFFFh')\n            output.append('push hl')\n            return output\n\n    output = _16bit_oper(op1, op2)\n    output.append('call __BOR16')\n    output.append('push hl')\n    REQUIRES.add('bor16.asm')\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _not16(ins):\n    ''' Negates top (Logical NOT) of the stack (16 bits in HL)\n    '''\n    output = _16bit_oper(ins.quad[2])\n    output.append('ld a, h')\n    output.append('or l')\n    output.append('sub 1')\n    output.append('sbc a, a')\n    output.append('push af')\n    return output", "response": "Negates top ( Logical NOT ) of the stack"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _bnot16(ins):\n    ''' Negates top (Bitwise NOT) of the stack (16 bits in HL)\n    '''\n    output = _16bit_oper(ins.quad[2])\n    output.append('call __BNOT16')\n    output.append('push hl')\n    REQUIRES.add('bnot16.asm')\n    return output", "response": "Negates top ( Bitwise NOT of the stack"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnegates top of the stack ( 16 bits in HL", "response": "def _neg16(ins):\n    ''' Negates top of the stack (16 bits in HL)\n    '''\n    output = _16bit_oper(ins.quad[2])\n    output.append('call __NEGHL')\n    output.append('push hl')\n    REQUIRES.add('neg16.asm')\n    return output"}
